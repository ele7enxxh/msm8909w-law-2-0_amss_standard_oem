/*====*====*====*====*====*====*====*===*====*====*====*====*====*====*====*

           C A L L   M A N A G E R   P H O N E   M O D U L E

GENERAL DESCRIPTION
  This module contains the Call Manager Phone Object.

  The Phone Object is responsible for:
  1. Processing clients' phone commands.
  2. Processing MC replies for clients' phone commands.
  3. Processing MC phone related notifications.
  4. Notifying the client list of phone events.


EXTERNALIZED FUNCTIONS

  cmph_init
    Initializing the phone object.

  cmph_get_curr_nam
    Get the current NAM.

  cmph_autonam_is_enabled
    Check whether auto-NAM is currently enabled.

  cmph_is_valid_mode_pref
    Check whether a given mode preference is valid.

  cmph_is_valid_mode_band_pref
    Check whether a given mode preference is valid.

  cmph_force_mode_on_the_fly
    Force the mode preference on the fly.

  cmph_unforce_mode_on_the_fly
    Unforce the mode preference on the fly.

  cmph_call_start
    Does necessary phone's call start activities.

  cmph_call_end
    Does necessary phone's call end activities.

  cmph_is_waiting_for_reply
    Check whether the phone object is currently waiting for a reply.

  cmph_info_get.
    Copy the current phone state information into a specified buffer.

  cmph_client_cmd_proc.
    Process clients' phone commands

  cmph_mc_rpt_proc.
    Process MC reports.

  cmph_timer_proc
    Process timer events.


  cmph_offline
     Perform offline processing


INITIALIZATION AND SEQUENCING REQUIREMENTS
  cmph_init() must be call to initialize this module before any other
  function declared in this module is being called.


Copyright (c) 1998 - 2014 by Qualcomm Technologies INCORPORATED. All Rights Reserved.

Export of this technology or software is regulated by the U.S. Government.
Diversion contrary to U.S. law prohibited.

*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/mmcp/mmode/cm/src/cmph.c#1 $

when       who     what, where, why
--------   ---     -------------------------------------------------------
11/18/14   xs      VOLTE call handling during L->D IRAT
04/22/14   xs      hVOLTE SSAC support
01/28/14   ss      Disable CSG Support by default is feature enabled
01/02/14   ss      Check for on-going voice or emergency calls before forcing
                   user prefs down to MMoC in SGLTE
12/04/13   jvo     Mainline FEATURE_MMODE_RPM
12/09/13   xs      FDN issue fix
11/14/13   ss      Reset last srv request buffer in in regprx when processing
                   deact ind from NAS
11/13/13   xs      Add control for VOLTE SR LTE failure
10/25/13   xs      Add support to send voice pref on legacy RATs
10/24/13   jvo     Added FTM->OFFLINE transition to oprt_mode_tbl
05/15/13   fj      Add support for segment loading.
10/07/13   jvo     Replace FEATURE_UICC_RAT_INDICATOR_SUPPORT with
                   is_rat_bal flag, get 2 NV items from MMGSDI cache
09/23/13   cl      CM support CM_PH_SIM_AVAILABLE_EVENT to AT-COP
07/22/13   fj      Add support for DSDX L+G
09/12/13   jvo     Fix 1 static analysis error by returning after null ptr
09/04/13   mh/jvo  Mainline the modem statistics code
08/25/13   sm      VOLTE concurrency during e911 orig
08/13/13   sm      Midcall SRVCC feature
08/13/13   cl      CM supports explicit PS_DETACH when capability from PM changed
08/07/13   skk     FR3663:Support to limit the bands searched during a manual search
07/19/13   jvo     Remove all MDM/MSM Fusion features
07/15/13   ss      FR1860 - T/G on DSDS
07/10/13   ar      Checking pointer(ph_orig_ptr , ph_orig_hybr_2_top_ptr ,
                   ph_hybr_2_orig_top_ptr) value is NULL or Not NULL
07/01/13   kc      FR15569 - Graceful Modem Power Down
06/25/13   sm      IMS deregister request for subs unavailable cmd
06/24/13   dk      KW error fix in cmph_force_pref_on_the_fly_hybr_2()
06/19/13   gm      Send pref to SD-ALL stacks before ONLINE/PWRUP ind
06/18/13   gm      FR 2617 - OMADM IMS and ADMIN PDN Disable Requirement
06/14/13   jqi     Add of TTL markers to prfile the boot up time.
06/13/13   fj      Only evaluate ps detach flag if TOP Q is changed.
05/12/13   gm      ACK for SIM refresh in LPM
05/17/13   fj      Evaluate whether ps detach is required before forcing
                   preference to SD.
05/16/13   fj      Avoid duplicate preferece forced to SD after ATCOP PS
                   detach.
05/03/13   fj      Reject mode change request if there's PS data call and SMS
                   in progress.
05/03/13   fj      When LTE is capable, if there's change of 1X/HDR, PS detach
05/22/13   qf      Enable world mode and single sim in dsds
04/30/13   skk     Enhance Interface For Packet Attach/Detach
04/25/13   xs      FRAT support
04/24/13   gm      Don't send subscription in FTM
04/16/13   sm      Reset bsr timer and flag when phone goes to LPM/onilne.
03/15/13   gm      UT fix for sending pref only on MAIN at ONLINE
02/11/13   xs      SD send acq fail to CM during HDR silent redial
02/03/13   cl      FR1975: Dynamic Switch SVLTE <-> CSFB
01/23/13   qf      Remove nv/efs write during cm initialization
01/25/13   gm      FR 3059 - ONLINE optimization - skip duplicate subscription
01/07/13   qf      FR 2564 - World mode support for DSDA
01/07/12   xs      Added PS supplemetary service support
11/28/12   vm      Unsuspend hybrid stack during subscription not available
10/15/12   cl      Recalculate incoming PS_DATA LTE call orig_mode
10/15/12   mg      Update valid cm mode pref on enabling LTE after ps detach.
09/21/12   vm      Unsuspend LTE/HDR stack when phone goes ONLINE
09/20/12   sk      Manage the ok to proceed with refresh flags effectively for
                   different sessions
09/20/12   qf      Unforce correct orig_mode upon call ending if the top
                   priority of the priority queue is CM_ACT_PRIORITY_END
09/19/12   sg      Remove MMGSDI_RAT_MODE_PREF_TDS_ONLY
09/07/12   fj      Added tds_band_pref support in cmph_force_orig_mode_on_ss.
08/17/12   gm      Mainline EFS feature - Remove FEATURE_EFS
08/10/12   gm      Unicore modem reset, allow ONLINE->RESET
08/07/12   gm      RF init status synch and handling oprt modes
07/30/12   vm      Initialize rtre config and control from NV 855 in cmph_init
07/20/12   fj      Added support for sending NAS request to set IRAT timer for
                   TDS to LTE HPLMN search.
07/19/12   aj      block hybr2 stack acq during emergency call
06/07/12   fj      Added support for disable/enable LTE.
07/17/12   aj      gw systems scanned per BST on 1x system loss when in DO/LTE
                   coverage
07/11/12   xs      Mapping LPM->RESET to trigger ACQ DB writing
07/10/12   xs      Hold subscription unavailable and ok_to_proceed to GSDI
                   until get DS session termination confirmation
07/02/12   sg      Added support C+H+G+W+L mode
06/21/12   sk      Accept Sys sel pref cmd in LPM
06/20/12   xs      Add efs_prepare_shutdown support as temp solution
                   due to no sys monitor yet
03/01/12   fj      Added support for DRX.
01/31/12   fj      Fixed klocwork errors.
05/14/12   cl      Allow emergency call with originated Voice Type before
                   PRL_INIT
05/15/12   gm      ETM on SVLTE: Disable HYBR_2 ( LTE ) when in ETM
04/24/12   sg      Add required changes to support TDS in Automatic mode
04/10/12   sk      Fixing the CW and KW warnings
04/05/12   sg      Add TDS into default TOT table
04/04/12   sg      Add support for new mode pref TDS_LTE
03/28/12   jh      Integrated RPM feature
03/27/12   cl      SD notify acq fail so CM can realign HDR when LTE pref no
                   change
03/26/12   cl      Reject get_net_list for LTE only mode when SIM invalid.
03/23/12   gm      DIME integration fix: TMC deprecation and others.
03/19/12   ak/gm   Fix ETM to wait for detach
03/06/12   ak      Deprecate is_data_switch_over_call_success from the CM code
03/06/12   chl     Support switching to FTM directly from LPM
02/22/12   vk      FIX to remove LTE from user mode pref when LTE is disabled
02/19/12   ak      Move cm_gwl_avoidance_timers to CMPH
11/30/11   jh      Added feature for dynamic rat acq order change
02/13/12   qf      Map ef_rat tri-mode to CM_MODE_PREF_GWL
02/12/12   aj      update orig mode of LTE call in HYBR2 priority Q
02/09/12   aj      restore 3GPP to MAIN mode pref if 3GPP is acquired
02/09/12   cl      Update the pref_reas when forcing HDR stacks
02/09/12   aj      defer hdr acq after LTE acq fail, if LTE active
02/09/12   cl      Scanning LTE/HDR at power-up on best-effort
02/07/12   aj      update cmpref2_proc_cmd_pref_sys_chgd() param to fix mem
                   issue
02/07/12   aj      remove is_hybr_2_restart flag
02/03/12   mj      Check TDS band pref when verifying valid mode/band pref
01/31/12   vk      Reset lte_disable_uptime during mode change to any but LTE.
01/24/12   xs      Patch: Subscription buffer handling during emergency call
01/20/12   gm      Data synchronization for CM Call objects
01/17/12   aj/cl   SC SVLTE SO 33 suspend changes
01/16/12   ar      Removing LTE from mode preference when PS detach is made.
                   Send this pref to MMOC/SD/LL only when in idle mode.
01/12/12   sg      Made changes for TGWL configuration.
01/10/12   gm      Mainlining HDR API change integration
01/06/12   gm      Data synchronization changes for freefloating platform
01/03/11   fj      Add support for WL network scan on non-SVLTE.
01/05/12   qf      Block GET_NET_LIST request by CM, if mode_pref contains
                   3GPP2
01/03/12   vk      Removal of feature flag for CSFB CS DATA call.
12/22/11   xs      Subscription buffer handling fix
12/21/11   vk      Changes for CSFB CS DATA call feature
12/20/11   sg      Added a check for TDS_GSM_WCDMA / TDS_GSM_WCDMA_LTE
12/19/11   xs      Add Hybr2 stack handling for PS detach
12/19/11   ak      Enable GWL avoidance by default.
12/06/11   sg      Add TDS band pref to mmoc_cmd_get_networks_gw().
12/05/11   sg      Added a check for tds_mode_band_pref.
12/01/11   vk      PS voice domain selection migration from CNE to CM
11/28/11   rk      Fusion 2 Refactoring change
11/18/11   sg      TD-SCDMA changes for CM to support manual PLMN selection.
11/17/11   ak      Extend GWL avoidance when LTE camped on Hybrid 2
11/08/11   gm      Previous phone pref are forced on ETM exit
11/02/11   gm      Changes for HDR API cleanup
10/31/11   ak      Ensure MDM hybr pref in sync with MSM oprt_mode on reset.
10/25/11   vk      Changes related to manual search rejection in RLF
10/21/11   rj      Feature to clear the Avoid System list
10/19/11   xs      Reset shorten LTE BSR flag only when eHRPD personality
10/19/11   xs      Shorten BSR to force LTE scan after HDR srv lost
10/14/11   aj      update plmn blocking for SC SVLTE
10/17/11   skp     Fixing corner case in DSDS WCDMA mode pref. handling.
10/07/11   rk      Fix to block changing mode_pref that includes LTE when
                   EF RAT mode_pref is GW only
09/27/11   rj      Undefine PLMN for Persistent Hybr Stack Info.
09/21/11   ar      Handling CM_MODE_PREF_NO_CHANGE in get networks command
09/15/11   rk      Fix to populate orig_mode correctly for PS data call.
09/14/11   vk      New MMOC Transaction "MMOC_TRANS_DEACT_1XCSFB_PROT_CMD"
                   related changes.
09/15/11   rk      Fix to populate orig_mode correctly for PS data call.
09/14/11   rk      Fix to send SS event with CM_SS_NO_CHANGE_MASK when user
                   selected same PLMN again
09/01/11   ak      Revert to persistent provisions upon subscription event.
08/15/11   aj      update to LTE to do resel when LTE is on hybr2 stack
08/18/11   sh      CM should not accept roam pref with incorrect value.
08/17/11   xs      Added new mode pref CDMA_HDR_GSM
08/12/11   xs      VOLTE support for VT
08/07/11   aj      update logic determining hybrid pref at power up
08/05/11   xs      VOLTE phase 1 support
07/27/11   jh      Adding new mode_pref (GSM_LTE, CDMA_GSM_LTE, HDR_GSM_LTE,
                   WCDMA_LTE, CDMA_WCDMA_LTE, HDR_WCDMA_LTE)
07/24/11   aj      SC SVLTE 1.0 merge to mainline
07/15/11   cl      Remove GW on MSM when 1X subsc avail. with no scan perm.
07/12/11   fj      Don't end LTE call when sys_sel_pref change
07/05/11   rn      JCDMA White card support (Suppress REG only)
07/05/11   rn      Terminate Get Net only when reqd and abort seach at LL too
07/01/11   rn      lint clean
07/01/11   cl      Recover MDM to LPM after being sent to ONLINE by RIL
06/27/11   fj      For oprt_mode LPM request, don't end LTE calls.
06/23/11   sg      CM should allow to chnage mode pref during MT page call,
                   if mode change is due to ef_rat.
06/16/11   ak      MDM to notify MSM LTE activity status for MMSS arbitration
06/15/11   rk      End the GW PS calls when mode is changed to LTE only and
                   PDP activate request is not yet send to NAS.
06/14/11   gm      Mismatch in mode-pref b/w SD and CM due to PH cmd rem GWL
06/14/11   gm      Thermal emergency fixes - resuming HDR, LPM->Online
06/14/11   sg      If phone is PS invalid, do not allow Manual PLMN sel in LTE
                   Only mode.
06/13/11   rm      Lint clean
06/07/11   rm      Fixing compilation issues for FEATURE_CM_MMGSDI
06/02/11   rk      Fix to exclude LTE mode from favoured mode for  emergency
                   call when CSFB is not supported on LTE
06/02/11   rk      Fix for PS detach (in idle mode) in GWL configuration
                   when current domain preference is PS Only
05/27/11   sg      If mt_page_in_progress, CM would not allow to chnage mode
                   pref
05/25/11   cl      Remove/Restore GW for MMSS arbitration optimization
05/25/11   ak      Fixed mode pref on SVLTE II at pwr up based on scan perm
05/18/11   gm      Phone should block all MT 1x/DO calls in ETM state
05/18/11   cl      Added support for GW throttle filtering based on regions.
05/18/11   rk      Fix for PS detach (in idle mode) in GWL configuration
                   when current domain preference is CS+PS
05/18/11   rn      WCDMA Channel locking feature
05/16/11   rk      Fix for doing PS detach in PS only mode
05/12/11   mp      BPLMN - LTE Only capable is not able to perform Manual
                   Search
05/11/11   skp     Lint Issue Fixed.
05/09/11   skp     pushing mode pref as NONE on the other stack in case of W
                   conflict due to emergency call
05/06/11   ak      When going online force mode_pref as per scan_permission.
05/03/11   sv      Remove AMPS feature flag
04/26/11   cl      MDM should not force preference blindly with no change
04/22/11   cl      Fixing existing lint issue
04/21/11   sv      Correct Lint Errors
04/19/11   rm      LTE: Do PS detach only when EF RAT is not present
04/18/11   mp      Optimized function cmph_generic_rpt_proc to use memory from
                   heap
04/12/11   fj      Added support for PLMN blocking.
04/12/11   cl      Adding enhancement to bring MDM to LPM when MSM acquired GW
                   full service.
04/11/11   am      Cleaning stubs and runnning qtf SUTE
04/08/11   anm     Added precondition check for CM_PH_CMD_DUAL_STANDBY_PREF
04/08/11   cl      Initialization registration callback
04/08/11   sv      Read DRS bit value for Voice calls from EFS at power-up
04/06/11   rk      Fixing 1XCSFB emergency call issue not to enter to
                   emergency callback mode
04/06/11   rm      Fill subs info for main stack before sending subs evt
04/05/11   xs      Unblock DS packet state command when waiting for DS
                   confirmation for LPM/PWROFF command
03/30/11   rk      Fix to disble LTE if sim state is PS invalid and do not
                   do PS detach as part of LTE disable if SIM is PS invalid
03/29/11   rk      Fix for not doing PPCSFB after receiving AttachAccept with
                   SMSOnly set
03/24/11   cl      FUSION2 MMSS-Arbitration centralization rework
03/22/11   gm      Fix to waiting 4s after call end to force THERM EMERG
03/22/11   cl      Add GW-Throttle Mechanism during HDR/LTE Idle for FUSION2
03/17/11   gm      Fix invalid read size issue of cmefs_read (merge issue)
03/15/11   gm      Separate features for CFM interface & therm emerg
03/15/11   cl      Allow MDM to grant permission to MSM when permission is
                   pending
03/15/11   cl      Uses power-save from service status instead new indication
03/11/11   rm      GSDI clean-up
03/09/11   cl      Add support for SVLTE2 MMSS arbitration
03/09/11   rk      Fixing mode pref mapping issue from CM to SD mode pref
03/03/11   gm      Added separate queue processing for M2M indications
03/02/11   rk      Fixing issues for coming back to LTE after CSFB call end.
02/28/11   gm      Thermal emergency feature support
02/28/11   rk      Adding support for LTE UE mode preference
02/25/11   sn      Support for graceful pdp deactivation before detach.
02/24/11   sv      Support for AUTO standby preference
02/17/11   cl      Add support FEATURE_MMODE_REMOVE_1X for FUSION-MDM
02/16/11   cl      Update the acq_order_pref to current ph_ptr value when
                   force preference with acq_order_pref is NO_CHANGE
02/14/11   rm      LTE RAT-B changes
02/11/11   ak      MDM to notify MSM of DO activity for acq throttling
02/08/11   sg      Adding a check for CM_MODE_PREF_GWL, to allow term get
                   network.
02/04/11   xs      Wait for DS notification for PWROFF/LPM oprt mode change
02/03/11   sv      Disable subscription per slot for card related errors.
01/28/11   sv      Disable subscription corresponding to the SESSION_CHANGED
                   event recieved.
01/27/11   rk      Copying LTE band pref in priority queue for data call
01/24/11   cl      Update pref_term to use pref_term from ph_ptr
01/19/11   ak      Added support for periodic GWL scans in DO only coverage.
01/19/11   rm      DSDS Auto-activation changes
01/16/11   rk      Delaying unforcing of CSFB call preferences on call end
                   to 4 seconds when other active calls are present
12/28/10   sv      Fix DSDS code
12/23/10   sv      Integrate DSDS feature
12/20/10   rm      Notify GET_NETWORKS_CNF event per subscription
12/10/10   rk      Adding new orig mode for CSFB call
12/08/10   xs      Added New mode pref SD_SS_MODE_PREF_ANY_LESS_WLAN support
12/02/10   gm      Fix to MOB warning - name conflicts.
12/01/10   sv      Update nam range check. Fix lint errors on MOB
11/24/10   xs      Fusion featurization clean up
11/24/10   sg      CM should fill call end cause type as
                   "CM_CALL_END_LL_CAUSE" when PS call get terminated due to
                   PS_DETACH.
11/18/10   rk      Added mapping for SD_SS_MODE_PREF_ANY_BUT_HDR_LTE
11/13/10   xs      Need to read NV rtre control value after updating NV
11/15/10   rm      Memory optimization changes
11/02/10   am      Replacing FEATURE_MOB_MMODE_CUTE
11/07/10   aj      remove debug msg
10/07/10   ak      Updated Online command processing on MDM to also refer
                   archived MSM reports.
10/20/10   xs      Added support to make rsrp_delta and rsrq_delta
                   configurable
10/08/10   ak      Reset propagation from MSM to MDM.
10/07/10   xs      Lint error fix.
10/05/10   rk      Merging 1XCSFB pre-registration code
10/05/10   pm      Remove unneccesary clk.h & CLK_MS_PER_SEC
10/04/10   xs      Superlint critical/high error fixed
10/01/10   ak      Merged the Fusion code from Dev branch.
09/29/10   ak      Added support for HDR only mode on fusion.
09/28/10   sv      Added cmph_proc_illegal_subscription_rpt to handle
                   MMGSDI_ILLEGAL_SUBSCRIPTION_EVT
09/28/10   sg      Add a check with flag "wait_for_reply" on
                   CM_IP_APP_ALLAPPS_OPRT_CNF
09/24/10   cl      CM should end active calls when moving to LPM only after
                   the apps has finished deregistration
09/22/10   xs      Fixed target compiler warning
09/17/10   chl     Add clk.h back for CLK_MS_PER_SEC
09/17/10   aj      IRAT band pref fix in call object transfer
09/15/10   rm      Release-7 changes
09/14/10   pm      Remove unneccesary clk.h
09/13/10   aj      Fixed issue with updating persistent LTE band pref
09/03/10   gm      HICPS: Change pref from USER to STACK_SYNCUP for pending
                   kicks
09/01/10   ak      Fixed the phcmd processing during HICPS.
08/30/10   xs      Added error handle for subscription change during emergency
                   call
08/26/10   gm      Removed calls to cmnv_read_wait from frequently called APIs
08/31/10   sv      Remove the Hybrid check for IRAT
08/19/10   aj      support for LTE detach when mode pref does not incl LTE
08/19/10   xs      Remove subscription buffering
08/16/10   aj      support VOIP deregistration on ps detach
08/10/10   cl      CM to handle CARD_INIT_COMPLETE EVENT for non-session base
                   code
08/11/10   jqi     Remove API featurization between modems and CM/CNE modules.
08/05/10   rn      Multi PDP call during LTE-eHRPD redirection
08/02/10   gm      Add mode pref CM_MODE_PREF_CDMA_LTE_ONLY
07/30/10   rm      Add CM_MODE_PREF_GWL_WLAN, SD_SS_MODE_PREF_GWL_WLAN
                   and their corresponding mapping
07/29/10   aj      allow NV setting of LTE ONLY mode when WLAN is enabled.
07/22/10   aj      Debug msgs for LTE band pref
07/22/10   aj      NV EFS support for LTE band pref
07/14/10   mh      Fixed compile warnings
07/09/10   mj      Return lte_band_pref with ph_info
06/21/10   jqi     FEATURE_MMODE_MDM_MSM_EVENTS & FEATURE_CM_MSM_CDMA_SRV_RPT
06/15/10   sv      For 9K fusion allow removing GWL from main stack even when
                   there is no CDMA in mode preference.Main would be in pwr
                   save
05/24/10   sv      Updated callback functions to queue a rpt to CM
07/06/10   fj      Use cmph_map_cm_lte_band_pref_to_sd_lte_band_pref() to map
                   lte_band_pref.
06/28/10   ak      Added EOOS support
06/22/10   rm      Handle EF_RAT chnage when Subs available comes before
                   ONLINE during power-on
06/15/10   aj      support for IRAT measurement support
06/10/10   ak      Mainlining memory optimization changes.
06/09/10   rm      Reset the PLMN id of the phone if oprt mode is LPM
06/04/10   fj      Added LTE support in sd_ss_get_supp_mode_pref().
05/27/10   rn      Updated pref reason to USER in CM_LTE_DO_IRAT_F handling
05/24/10   fj      Added LTE support in cmph_client_cmd_forward_mmll().
05/20/10   sv      Include clk.h
05/15/10   mh      Send OFFLINE instead of OFFLINE_CDMA, if TMC init fails
05/13/10   fj      Added LTE support in cmph_cmd_get_networks_para_check() &
                   cmph_cmd_terminate_get_networks_para_check().
05/13/10   xs      Rename cmph_pref_nochg_e enum type
05/07/10   fj      Added support for LTE.
05/06/10   xs      Don't update NV when NO_CHANGE specified
04/29/10   rm      Adding Modem Statistics changes for 1x/HDR
04/27/10   rn      Added CM_LTE_DO_IRAT_F handling
04/26/10   cl      Remove FEATURE_CM_MVS_API
04/22/10   rm      Mode pref chg to non-GW/EF_RAT.Correcting misplaced 'break'
04/22/10   xs      Added mapping for CDMA_HDR_GW and CDMA_GW
04/14/10   cl      DDTM Allow Max should supports 37 SO and fallback to legacy
                   if number of support is set to be 0.
04/08/10   rk      Buffering subscription commands when emergency call is
                   present.
04/07/10   fj      Added MODE_PREF for HDR_LTE and CDMA_HDR_LTE.
04/07/10   rm      Allow mode_pref change to non-GW with EF_RAT On
04/04/10   rk      Reset manual plmn ID on subscription not available.
04/01/10   xs      update all prefs with prst values in CM when do ONLINE mode
                   oprt
03/31/10   cl      Add support for CM_PH_EVENT_PRL_INIT to indicate PRL is
                   loaded
03/23/10   mj      Update handling of CM_MMGSDI_CARD_RPT
03/15/10   np      Added to handle LTE Detach ATCOP
03/02/10   fj      Added HICPS support for LTE.
03/03/10   mj      Featurize use of MMGSDI_APP_CSIM
03/03/10   rn      Move to Auto with MM17 reject with new NV
02/27/10   mj      Check for CSIM card type on CM_MMGSDI_CARD_RPT event
02/24/10   aj      Add support for PS optimized silent redial
02/15/10   cl      Added support for blocking certain pages during emergency
                   callback mode
02/09/10   sg      Added cmph_map_sd_srv_domain_pref_to_cm_domain_pref()
02/08/10   fj      Modified subscription handling for LTE.
01/19/10   cl      Expose the PRL's id to the client
01/19/10   aj      Added VOIP support for emergency call
01/12/10   fj      Modification for lte_band_pref.
01/13/10   sg      Removing the legacy code which is causing issue in CR
                   218417.
01/11/10   mj      CSIM - GW uses Session based MMGSDI interfaces
01/06/10   fj      Added lte_band_pref check in sys_sel_pref_para_check().
01/05/10   pm      Removing UOOS
01/05/10   fj      Call sd_misc_is_supp_pref_lte() in cmph_init().
12/10/09   fj      Added lte_band_pref and lte_band_capability.
12/10/09   ak      Corrected KW errors.
12/03/09   fj      Correct NV_MODE_GWL name.
11/13/09   fj      Added mapping and handling MODE_PREF and SRV_PREF for LTE.
11/24/09   sg      Update domain_pref with persistent domain_pref on LPM ->
                   ONLINE
11/10/09   mp      Added support for MODE_PREF_DIGITAL_LESS_WLAN
11/06/09   aj      Allow user resel to proceed with auto to auto transition
11/05/09   fj      Remove LTE subscription available stub in cmph_rpt_proc().
11/09/09   sg      Add non-demand paging macro to function that are not to be
                   demand-paged.
11/02/09   cl      Expose the PRL's pref_only preference to the client
10/29/09   rm      Emergency call to be allowed in JCDMA configuration
10/19/09   cl      Fix CM state machine to set the correct Orig Mode
10/15/09   ks      Sending SS event as response to client against
                   sys_sel_pref cmd when network mode change from auto to
                   manual or vice versa
10/14/09   sg      ZI memory reduction. Mmode should call new Heap Manager API
                   to allocate memory dynamically.
10/05/09   fj      In cm_ph_info_s_type, change is_gwl_subscription_available
                   back to is_gw_subscription_available.
09/29/09   sv      KW Fixes
09/01/09   sv      Moving from clk API to time API
08/20/09   rm      Read EF_RAT file during power-on only if ENS flag in On.
08/07/09   rm      Sending correct band_pref while mode change happens
08/07/09   am      Changes related to handling subscription in CM are done to
                   process card events, PIN events, RTRE control and mode
                   changes to online
07/27/09   aj      update sys_sel_pref - net_sel mode pref chgd is not SET
                   when there is no change in the network sel preference.
07/13/09   rm      Service the get_networks request only if the service
                   domain preferance is valid
06/22/09   sv      Corrected the validation check for PRL Pref in cmph_init()
06/17/09   em      Removed check for network_sel_mode_pref to be manual in
                   in cmph_client_cmd_check()
06/03/09   rk      Sending PDP_ABORT_REQ to NAS on DETACH/or conflicting
                   mode change, so that NAS can deactivate PDP calls locally.
05/22/09   rm      RAT Balancing - Force EF_RAT mode when moving from LPM/FTM
                   to ONLINE.
05/06/09   aj      Reject get_networks for WLAN in absence of subscription
04/24/09   rm      Including cmlog_v.h
04/23/09   rm      Updating correct mode pref of phone when data_avaialable
                   request comes. Made misc_intersect_mode_pref non-static
04/17/09   ks      Added support for disable_call_type to cmnv_data_s_type
04/06/09   mj      Update BOOLEAN macro w/ namespace prefix to CM_BOOLEAN
03/24/09   sv      updated to cmtaski.h
03/23/09   rm      Adding _v.h files from NAS
03/20/09   rm      Renaming cmph_otasp_update_mode to cm_otasp_update_mode
03/23/09   mh      Added support for prl preffered setting in ph info
03/09/09   rm      Updating correct mode pref of phone when data_avaialable
                   request comes
04/03/09   aj      Added support for emergency callback exit on sys lost
02/27/09   rm      Adding header files of other MOBs
02/23/09   rm      Adding sys_wlan_v.h
02/23/09   rm      Removing cm_log_v.h
02/20/09   rm      Lint clean post CMI changes
02/17/09   rk      Removed CDMA feature flag so that ending PS call when
                   PS_DETACH is received will be applicable for GW target.
02/06/09   aj      wlan subscription decoupling related changes
01/29/09   rm      RAT balancing phase-2 - Vote YES to EF_RAT refresh during
                   CS/PS calls - MMGSDI changes
01/19/09   sv      Updated cmph_term_pending_get_networks_req to accept SS
12/08/08   fj      Added function cmph_map_sd_mode_pref_to_sys_mode_mask();
                   Added update of ph_ptr->mode_capability and
                   ph_ptr>band_capability in cmph_init();
                   Updated function cmph_get_mode_band_capability();
                   Added update of ph_ptr->mode_capability and
                   ph_ptr>band_capability in cmph_info_get();
12/17/08   jd      Fixed Lint errors
11/25/08   sv      Corrected Get Networks cmd check to check if the current
                   mode preference supports the get networks request
                   Corrected sys_sel_pref cmd check to check if network
                   selection pref and mode preference combination is valid.
11/21/08   am      Fixing compilation error for Running off-target tests
11/18/08   am      fixing RAT balancing - Honor EF_RAT file changes while
                   power up on MMGSDI side
11/17/08   am      Replacing CM GSDI interface with CM MMGSDI interface
11/13/08   aj      End data calls when user changes mode pref
12/11/08   am      Changes for mode retained after power cycle.
11/11/08   ks      Resolve Klocwork defects
11/07/08   rm      RAT balancing - Honor EF_RAT file changes while power up
11/06/08   rm      RAT balancing - Block user from changing mode_pref if
                   and only if mode_pref is being changed.
11/03/08   pk/ak   Updated the HICPS for RIM issues.
10/29/08   sv      WLAN System is written to manual netlist everytime wlan
                   system is selected manually.
10/21/08   ks      Update default threshold value for sir and pathloss and
                   add masks for RSSI event
10/02/08   aj      Add support for BC 17,18,19
10/01/08   sv      Featurizing voc.h include to remove lint errors.
09/18/08   rm      RAT Balancning enhancement- Block user from changing mode
                   pref only if ENS flag is ON and UIM_USIM_RAT file is
                   present
09/17/08   ks      When OOS in CELL_FACH, UE needs to follow UOOS scanning
                   pattern to re-acquire service
09/15/08   cl      Add initialization before subscription commands are sent.
                   This allows the service domain to be sent to UI correctly.
09/12/08   fj/aj   Support Android RIL for ARM9 Reset
09/10/08   ak      Fixed scenario of data call drop during GSM scan
09/04/08   dm/sv   Implemented WPS support for WLAN
09/02/08   sv      Corrected the condition when manual wlan system preferences
                   are written to netlist.
08/28/08   aj      Update cmph_client_cmd_check for CM_PH_CMD_CLIENT_ACT
08/20/08   st      Resolve Klockwork defects
08/05/08   aj      Check for activity on SS before queuing WAKEUP_FROM_STANDBY
08/05/08   rk      Block the mode pref change by CM clients when RAT balancing
                   feature is enabled.
07/30/08   ak      Fix for the HICPS scenario.
06/17/08   sv      Remove compiler warnings.
06/13/08   sv      Memory Reduction for ULC
06/12/08   sv      Resolve Klocwork defects
06/11/08   fj      Added API cmph_get_mode_band_capability
06/11/08   sv      Exposing cmph_info_alloc for power collapse buffered
                   events notifications.
                   Updating the buffered events notification trigger.
06/10/08   aj      Ensuring that appropriate SD_SS_PREF_REAS is given
                   when calling cmpref_proc_cmd_pref_sys_chgd
06/6/08    rn      Added fn for deleting ps activity from prio queue
06/06/08   sv      Removing unneccesary snd.h
05/27/08   sv      Added support to trigger info_get events when moving to
                   Power Restore State
05/22/08   rm      Making phone status to move out of EMERG_CB when the phone
                   enters LPM mode
05/22/08   vk/sv   added functionality to handle roam only preference
05/14/08   aj      Subscription change update to fix CR 146713
05/08/08   sv      Added support to put ph in LPM when modem is not
                   supported in msm.
04/28/08   rm      Doing get_networks with user specified network_type in
                   both AUTO and MANUAL mode
04/24/08   rm      Removing feature flag FEATURE_CM_NAS_SERVICE_REQ_TYPE
04/16/08   vk      changed subscription behaviour to buffer the subscription
                   command if the mode pref does not contain the technology,
                   but will allow all commands to go through if anyone
                   subscription goes through also checks buffers and sends
                   subscription command when mode pref changes
03/14/08   rm      CM-NAS interface for new service req type
03/05/08   vk      corrected code for HYBR_GW configuration
01/29/08   ks      Allow UE to set WCDMA+GSM mode using QXDM
01/24/08   vs      Updating orig_int_hybr_pref in
                   cmph_update_orig_param_incoming_call, to avoid hybr_pref
                   memory corruption.
01/02/08   sk/vs   Added support for disabling hybrid mode using
                   FEATURE_HDR_HYBRID_DISABLE.
12/21/07   vs      Fix for CR#124762 - Ending all active calls when
                   transitioning to LPM
12/20/07   ak      Removed Changes made for 'Allow CM_MODE_PREF_GSM_ONLY if
                   the hardware is EDGE_ONLY'
12/16/07   ks      Added cm_ph_cmd_signal_strength_delta
12/13/07   sk/ak   Added DCM.
12/12/07   rm      Adding RAT-balancing feature support
12/11/07   rn      Allow CM_MODE_PREF_GSM_ONLY if the hardware is EDGE_ONLY
12/07/07   ra      Added support for IMS VCC in HOMER files
11/13/07   sk/sv   SHARC 1.0 support.
11/16/07   rn      Added support for indicating clients of phone event in use
                   state when there is MT call coming in while MO call end
                   cnf is still expected
10/01/07   rm      Handling of GSDI_CARD_ERR_POLL_ERROR in CM
08/08/07   cl      Add OTASP Support for ASW Band
08/07/07   ic      Lint clean up
07/26/07   rn      Allow manual plmn selection during a PS call
07/16/07   sk      Changes to avoid garbage values in bss_type_pref when
                   ADHOC feature is not defined.
06/22/07   sk      DDTM rewrite and added support for ATOM.
06/14/07   pk/cl   Added support for power suspend
06/13/07   rp/cl   Changing logic to set srv_domain_to_be_forced
06/11/07   sk      Added memset to zero when writing WLAN manual system file.
                   Precautionary step to prevent validation errors when new
                   fields are added, but not initialized.
06/07/07   rp      Deleting and adding orig_q entry to make sure it is
                   inserted with the new priority.
06/05/07   pk      Added support to read mob_cai_rev from NV
04/17/07   rp      Setting  srv_domain_pref based on call_type for incoming
                   call
04/03/07   sk      Added code to free a client object and remove it from
                   client list upon receiving the CM_PH_CMD_CLIENT_RELEASE
                   command.
03/09/07   sk      RAM usage reduction.
02/27/07   ic      Lint fixes
02/26/07   ka      Changes to support Voip deregistration.
02/22/07   pk      C-GPS changes
02/12/07   pk      Honouring phone's band preference for HDR systems
01/03/07   pk      Added support for DO VOIP -> 1X Handoff
01/04/06   ic      Added missing else in ALS code for processing of
                   CM_PH_CMD_SUBSCRIPTION_AVAILABLE and
                   CM_PH_CMD_SUBSCRIPTION_CHANGED
                   Added messages for CM_PH_CMD_SUBSCRIPTION_* processing.
12/28/06   ka      Fix to ensure that NV srv domain does not change on
                   manual PLMN selection.
                   Adding persistent enums to acq order, band, roam, hyb pref
                   and srv domain enums.
11/22/06   sk      Added missing band read to WLAN manual system read.
11/17/06   pk      Added support for HYBR_GW and UMTS -> 1X handover cont...
11/11/06   pk      Added support for HYBR_GW and UMTS -> 1X handover cont...
11/09/06   pk      Added support for HYBR_GW and UMTS -> 1X handover cont...
11/09/06   rp      Added code to reject PS Attach if SIM state is invalid.
11/07/06   pk      Added support for HYBR_GW and UMTS -> 1X handover
11/07/06   sk      Memory reduction effort.
08/29/06   sk      Added WLAN Adhoc support.
08/16/06   ka/rp   Rejecting RESET ACM and SET ACMax commands when Advice of
                   charge (aoc_info) is not ready.
08/16/06   ic      Lint fixes
08/11/06   pk      Added support for UOOS
08/08/06   sk      Updated cmph_map_cm_mode_pref_to_sd_mode_pref() and
                   cmph_map_sd_mode_pref_to_cm_mode_pref().
07/19/06   ic      Lint fixes
07/07/06   pk      If a PD session is ended while changing the operating mode
                   to ONLINE, the operating mode change command is put on
                   hold for atmost a second, or PD handshake is received
07/03/06   ic      In cmph_map_mode_pref_nv2cm() added handling for NV enum
                   NV_MODE_WLAN_ONLY
06/12/06   jqi     Kept the emerg orig mode only if there is a active emerg
                   call in cmph_force_pref_on_the_fly
06/09/06   jqi     Only cleared the GW network list pending flag if SD stops
                   manual list search.
06/05/06   ka/ic   Ignoring LPM_OK report received from MMOC when CM is not
                   waiting on it.
05/26/06   pk      Modified the pref_term for incoming to
                   CM_PREF_TERM_CM_1_CALL_PLUS
05/24/06   pk      On LPM -> Online transistion subscription changed command
                   is processed through cmpref_proc_cmd_subsc_chgd, instead
                   of directly calling MMOC API
05/17/06   pk      Added support for DDTM during BCMCS flows
05/03/06   pk      Lint Fixes
04/06/06   sk      Fixed PS_DETACH and PS_ATTACH handling when in powered up
                   in PS_ONLY mode with a voice call and data call up.
04/06/06   sk      Added cmph_map_sd_ss_type_to_cm_ss_type()
04/01/06   ka      Changes for emerg serv category during orig, aborting
                   manual search and returning current band with srv ind.
03/27/06   pk      Added support for lowering the priority of DATA calls if
                   there is a user phone activity, for e.g: sys_sel_pref
                   ps_detach etc.
03/10/06   pk      Added support for high PSIST
03/09/06   pk      Added support for POWER COLLAPSE
03/05/06   jqi     Merged the WCDMA BC3,4,8,9 support.
03/01/06   pk      Corrected cmph_cmp_act_priorities
02/17/06   ka      Adding support for videoshare
01/26/06   ka      Sending CM_PH_EVENT_AVAILABLE_NETWORKS_CONF without
                   checking for Get net pending flag
01/18/06   pk      Initializing all the DDTM srv opt list to zero before
                   writing to NV
01/12/06   ic      For specific calls / walks Lint warnings, replaced global
                   -fsp comment with -e{error#} comments where needed
01/10/06   pk      Modified cmph_force_pref_on_the_fly(), to update the WLAN
                   Queue after the user's sys sel pref is forced
01/06/06   ka      Reading NV_GPRS_ANITE_GCF_I and storing the value.
01/06/06   ic      Lint cleanup
12/14/05   ic      Changed featurization for cmph_otasp_update_mode() so it
                   links for JCDMA builds
12/13/05   ic      Restored cmph_otasp_update_mode()
12/11/05   ic      Lint cleanup
11/30/05   ka      PS srv component should be added to srv_domain_pref when
                   Manual PLMN request is made during a ps call.
11/30/05   pk      Fixed NV setting for WLAN network_sel_mode_pref change
                   from manual to automatic
11/30/05   ka      Resetting network_sel_mode_pref in cmd_ptr for HPLMN SRCH
                   REQ so that it does not change ph object's
                   net_sel_mode_pref. Resetting pref_term to NONE for HPLMN
                   srch request.
10/04/05   ka      Changes to support on demand HPLMN search request.
11/21/05   pk      Corrected printing of F3 messages in
                   cmph_force_pref_on_the_fly
11/21/05   ic      Cleaned up cmph_offline()
11/10/05   pk      Added support for privacy_pref, and is_privacy in the
                   phone object
11/08/05   sk      Separated CM reports and commands.
11/07/05   jqi     Jump start HDR instance when we are in HICPS on JCDMA
                   build.
11/03/05   ic      Added CM_ASSERT() for ptr function parameters and lint
                   comments for 613 Lint error
11/01/05   ka      Helper functions to check if nam change is pending for
                   OTASP call.
10/25/05   pk      Fixed RVCT compiler warnings and added mapping functions
10/24/05   pk      Modified cmph_mo_sms_end to drop the priority to the
                   least after sms end
10/20/05   pk      Cleaned RVCT compiler warnings and added mapping functions
10/18/05   pk      Added cmph_map_sd_hybr_pref_to_cm_hybr_pref. As per the
                   new design, we no longer hold the call is a PD session
                   is ended because of a call origination. So we pass NULL
                   as the last parameter to cmpd_call_start()
10/13/05   ic      Mainlined FEATURE_HDR_HICPS20 and FEATURE_HDR_HICPS30
10/04/05   pk      Added message when we don't force preferences because of
                   a high priority activity going on.
10/03/05   pk      Added support for DDTM settings NV item
09/28/05   pk      Added support for CM_ACT_TYPE_NON_STD_OTASP
09/26/05   dk      Do not re-write WLAN Scan pref while reading Manual System
                   file for WLAN. Reported in CR 77056.
09/14/05   pk      Modifications to allow sys_sel_pref during call activity
09/15/05   pk      Added F3 message in cmph_orig_mode_reset_on_ss()
09/12/05   pk      Added checks for Dormant PD session for SYS_SEL_PREF
                   command, modified cmph_call_start to abort PD session
                   if required. Added cmph_pd_session_end(),
                   cmph_pd_session_start()
08/31/05   pk      Added support for priority Queue for the following call
                   types CM_CALL_TYPE_TEST, CM_CALL_TYPE_PD,
                   CM_CALL_TYPE_VT, CM_CALL_TYPE_VT_LOOPBACK,
                   CM_CALL_TYPE_SUPS
08/25/05   ic      Added FEATURE_HDR featurization to cmph_send_ddtm_status()
                   and cmph_ddtm_disable_cdma_tx()
08/23/05   ic      Lint fixes in cmph_force_pref_on_the_fly()
08/22/05   pk      Modified cmph_get_act_priority() to return the correct
                   priority for act_type CM_ACT_TYPE_PH_OBJ
08/15/05   pk      Added support for priority Queues for origination
                   parameters
08/15/05   pk      Moved is_hdr_kicked to a local function. Clear the
                   is_hdr_kicked flag on getting service indication
08/11/05   ka      ACM value maintained in ph cannot grow over 3 bytes, adding
                   the check for it.
08/02/05   ic      Print value that caused error in default switch case
07/21/05   sk      Set orig mode to SD_SS_ORIG_MODE_NORMAL for emergency calls
                   in JCDMA targets.
07/06/05   ka      Correcting the way protocols are being recorded during
                   subsc changed/subs avail and subs not available functions.
06/24/05   ic      Adding CCBS feature (merged in P4 change list 204600)
06/21/05   dk      Allow WLAN GetNetworks while in Voice call on 1X or GW.
06/15/05   ic      Added comment in cmph_init() on why CM defaults RTRE
                   settings instead of reading them from the NV
06/09/05   dk      Fixed some function prototypes to take void.
06/06/05   pk      Added access overlaod class information to the phone
                   object. Resetting origination throttle table on
                   Operating mode change, subscription change, NAM selection.
06/03/05   ic      Removed FEATURE_CM_INIT_PS_SERVICE_DOMAIN
                   Mainlined FEATURE_FACTORY_TESTMODE
05/11/05   ic      Moved cmph_net_list_copy() to cm.h/.c
05/04/05   jqi     Fixed for hybr data switch over.
04/14/05   dk      Fixed SysSelPref command processing where WLAN Manual
                   preferences were not being loaded correctly if user
                   indicated no change in WLAN network selection mode
                   preference and WLAN network selection mode preference is
                   Manual.
04/08/05   pk      Removed cmph_get_cur_hybr_status(void),
                   cmpref_is_hybr_status_on() is the correct function.
                   Modified handling of CM_ACQ_FAIL_F reports
04/05/05   pk      Modified cmph_info_get() to copy the current DDTM status
04/05/05   dk      Fixed Nam Sel issue to select correct nam while forwarding
                   command to MMOC.
03/25/05   dk      Fixed WLAN read/write profile by checking for NET_STATUS
                   explicitly.
03/14/05   ka      Adding support for SD_SS_HYBR_WLAN instance at required
                   places
03/09/05   pk      Added the CM_PH_EVENT_DDTM_STATUS event, it is triggered
                   when the DDTM status changes.
03/04/05   ic      Merged in DataOverSignaling (DOS) support
03/03/05   ka      Adding support to let mmoc know of protocol that has a
                   subs change when calling mmoc_cmd_subscription_chg
02/24/05   ic      In cmph_force_pref_on_the_fly() overwrite function
                   parameters to keep current preferences if we're in
                   emergency callback mode
02/23/05   pk      Turned off the assertions in cmph_call_end() to reproduce
                   CR#53684
02/17/05   pk      Modified cmph_map_sys_sys_mode_to_sd_mode() to support GW
                   mode
02/09/10   dk      Expanded cm_band_pref to 64 bit.
02/01/05   dk      Added WLAN Support.
01/24/05   ic      Exit emergency callback mode upon emergency call
                   origination and send CM_PH_EVENT_SYS_SEL_PREF to clients.
                   Added cmph_enter_emergency_cb() and
                   cmph_exit_emergency_cb()
                   Replaced cmph_is_ph_in_emerg_cb_mode() with
                   cmph_is_in_emergency_cb().
                   Cleaned up cmph_call_start() to send
                   CM_PH_EVENT_IN_USE_STATE only when phone state changes
                   (it used to send it always).
01/17/05   dk      Added support to read unpacked User PLMN Lists.
01/14/05   sj      Fixed issue with powerup in hdr only mode.
01/07/05   ic      Removed all code under and referring to FEATURE_UASMS
12/06/04   sj      Removed writing hybr_off during pwrup if mode_pref
                   doesn't have CDMA-HDR.
11/11/04   sj      Rearranged featurization for DDTM_CNTL and fixed issue
                   in cmph_call_end_req() which generates bogus IN_USE event.
11/16/04   sj      For DBM use preference as CM_MODE_PREF_CDMA_ONLY.
11/16/04   sj      Updated avoid_type mapping to SD types.
11/15/04   ic      Lint cleanup with CM_DEBUG on
10/22/04   ic      Featurization changes so it compiles without FEATURE_GPSONE
10/04/04   jqi     Valid band and mode againt both target and PRL for task
                   initialization and system pref change command.
09/23/04   jqi     Do not reset FTM flag when power off the phone.
09/17/04   ic      Merged in FEATURE_ALS changes from Saber 4.2 release
                   (MSMSHARED_CM.02.00.19.00.ALS.04)
09/10/04   jqi     Any systerm preference change or operation mode change
                   should terminate a pending get network request.
09/10/04   dk      Allow PLMN search request even when previous one is pending.
                   This is requried to fix CR 48462.
09/08/04   jqi     More ps dormant optimization.
09/03/04   ic      Merged in FEATURE_ALS changes from Saber 4.2 release
                   (MSMSHARED_CM.02.00.19.00.ALS.03)
09/03/04   dk      Added support to start PS_SIG_DOWN wait tiemr for online
                   mode transition and system selection preference change.
08/30/04   sj      Made orig_mode as an array. Added get/update orig mode
                   funcs.
08/27/04   jqi     Added ps dormant optimization.
08/25/04   ws      Stay in Emerg_cb if already there.
08/20/04   sj      Added support for PRL Preference.
08/16/04   ic      Removed some garbage invisible characters that made
                   compilation break with cmph.c(517) : error C2018: unknown
                   character '0x10'; unicode identifiers are not supported
08/12/04   ws      Remove cm20 support.
08/10/04   ic      Removed cmlog_get_operating_mode() as it became obsolete.
08/06/04   ic      Fixed compiler error from SNAR build
                   (undeclared name, inventing 'extern int gsdi_card_apps_T)
08/04/04   sj      From LPM -> online, generate subscription available
                   command to MMOC.
                   Fixed issue with setting user_resel when network_sel_mode
                   is given as persistent.
08/04/04   ic      Removed enabling/disabling of Lint error 788 as it is
                   globally suppressed in Lint config files.
                   Enabling it locally in CM files caused inconsistent
                   Lint issues reports when a file was linted separately
                   versus when it was linted as part of *.c batch
08/04/04   ic      Updated call to cm_aoc_save_acm()
08/04/04   ic      Removed cmph_stop_mode_req() as it became obsolete
                   Fixed missed issues with existing Lint suppression.
08/04/04   ic      CM Lint clean up - cmph.c with Lint supression verified and
                   free of Lint issues in all CUTE configurations.
07/29/04   sj      Issue subsc_chgd command only when transitioning from FTM
                   to online.
07/29/04   ws      Do not overwrite emerg_orig in orig_mode when originating
                   another data call.
07/27/04   ws      Fix lint error caused by additional SUPS Call Control
                   support.
07/26/04   ic      Changed include file order to customer.h, then cm.h then
                   cmi.h
07/12/04   ic      Added support for FEATURE_ALS
                   Removed code compiled under FEATURE_HDR_TEMP
07/09/04   sj      Unforce orig pref. if temporary upon getting get_networks
                   request.
07/07/04   ka      Fixed Lint errors
07/07/04   ic      Fixed compiler warning ('statement unreachable')
07/02/04   sj      Fixed lint errors.
06/30/04   ic      Fixed obvious RVCT 2.1 compiler warnings (Jaguar build)
06/30/04   dk      Added support for PS Signaling down indication flag and
                   uptime.
06/29/04   jqi     Fixed the manual network selection reset issue after reset.
06/25/04   dk      Allow the Network Test Mode request any time even if a call
                   is in progress. This is a requirement for the CR 43966.
06/25/04   dk      Changed reference from cmxcall_is_hybr_hdr_call() to
                   cmcall_is_hybr_hdr_call().
06/22/04   ic      Fixed obvious RVCT 2.1 compiler warnings
06/21/04   ic      Fixed some Lint errors.
                   Updated calls to cmxcall_is_hybr_hdr_call()
06/16/04   ws      Fix featurization with mmgsdi.
06/11/04   ws      Read spc during subscription/rtre config changes.
06/10/04   dk      Added cmph_call_end_req function. Also modified cmph_event
                   function to set the "in_use" flag based on the fact that
                   each call is in IDLE.
06/08/04   jqi     Upon unforce pref on the fly, set orig_mode to manual if
                   current network selection type is manual in phone object.
06/07/04   sj      Removed feature_reg_deep_sleep and functions for
                   standby_sleep & standby wakeup.
06/03/04   ka      Handling PS_ATTACH/PS_DETACH by writing to phone object
05/27/04   ic      In cmph_client_cmd_proc() call cmph_client_cmd_err()
                   irrespective of whether error occured or not (client is
                   supposed to be always notified about command processing
                   status)
05/19/04   ka      Removed unforcing system preference at end of Emergency
                   call by CM_CS_SIG_REL_IND and cmph_process_sig_rel_ind ()
05/17/04   ic      Fixed cmph_ph_cmd_sys_sel_pref_para_check() so it supports
                   1X+HDR+GSM build
05/14/04   ka      Fixed Lint errors.
05/06/04   ic      Added assertions on ph_ptr->is_in_use in cmph_call_end()
                   Added debug info for favored mode for origination
                   computation / forcing of origination mode.
04/30/04   ws      Fix CM/SD mapping functions to include more enums
04/29/04   ic      In cmph_map_cm_mode_pref_to_sd_mode_pref() added support
                   for CM_MODE_PREF_CDMA_HDR_ONLY and
                   CM_MODE_PREF_CDMA_AMPS_HDR_ONLY, removed
                   CM_MODE_PREF_ANY_BUT_HDR_AND_AMPS.
                   In cmph_map_sd_mode_pref_to_cm_mode_pref() added
                   SD_SS_MODE_PREF_CDMA_HDR.
                   Added support for CM_MODE_PREF_CURRENT_LESS_AMPS
04/23/04   ic      Merged over to CM mainline the delta between
                   MSMSHARED_CM.01.00.10.00.28 and MSMSHARED_CM.01.00.10.00.31
04/21/04   ka      Removed CDMA featurization in cmph_timer_proc for sending
                   the right preferences to SD on call end
04/14/04   ka      Added cmph_process_sig_rel_ind () to release signaling on
                   MM REJECT CAUSE.
04/13/04   ka      SD is informed after last call gets ended.
                   Moved cmph_unforce_ functions out of CDMA featurization.
04/12/04   sj      Added support for setting DDTM on while doing GPS fix.
04/12/04   jai     Make phone in use flag in dependent of signal release
                   /indicator.
04/08/04   ws      Merged changes from MSMSHARED_CM.01.00.32.00.03
04/02/04   ic      Merged over to CM mainline the delta between
                   MSMSHARED_CM.01.00.10.00.23 and MSMSHARED_CM.01.00.10.00.28
03/24/04   ic      Featurization changes to support multitarget unit test
                   compile.
                   cmph_orig_mode_reset() cleanup.
                   Fixed compiler warnings.
                   In cmph_init_orig_mode_vars() added resetting of
                   orig_srv_domain_pref.
03/23/04   ws      Merged changes from 6300.
03/18/04   sj      Added is_hybr_hdr_orig() and do not unforce pref if
                   SMS/DBM is in progress.
03/17/04   sj      Added support for ignoring user specified pages while in
                   DDTM.
03/16/04   ka      Offline signal received from tmc is used to call
                   cmlog_set_cm_offline_signal_recvd () to set phone's
                   operating mode.
03/15/04   ka      Merged changes from 6250. Fixed Lint errors.
03/10/04   ic      Initialize rtre_config field in phone object in cmph_init()
02/25/04   ic      Changes to make the code pass unit test cases and at the
                   same time make calls in Saber build
02/18/04   ws      Added hdr & amps when checking call end to write db_conv
02/12/04   ic      Merged in changes from MSMSHARED_CM.01.00.10.00.20 to
                   MSMSHARED_CM.01.00.10.00.23
02/09/04   ic      Changes so the code compiles for unit test.
02/06/04   ws      Initial jaguar/mainline merge.
01/21/04   RI      Modified cmph_force_pref_on_the_fly() to include service
                   domain preference parameter.
01/19/04   ws      Send sys_pref_change if RelA even if the phone is in use.
01/15/04   ws      Use sd_misc_is_target_supp_mode_band instead when
                   validating mode/band.
01/13/04   ka      Merged changes from MSM6200
12/16/03   rc/aaj  Support for FEATURE_HDR_HICPS20
12/15/03   ws      Do not set signaling_conn_rel_req since mode is not known
                   yet.
12/11/03   ws      Maintain prst network sel mode pref when unforcing after a
                   call.
11/25/03   ws      Support FTM or OFFLINE operational mode changes.
11/12/03   ws      Featurize srch_rude_wakeup for targets with CDMA
10/31/03   ws      Remove T_RF_ZRF6200 feature
10/23/03   ws      fix for PD sessions
10/20/03   ws      Dual Slot Support.
10/08/03   ws      Added check for USIM for subscription source
                   Added support for NV_PS_DATA_ORIG_PREF_I
10/06/03   vt      Modified to support common cm.h across all targets.
10/01/03   ws      Merged changes to compile for GW targets.
09/23/03   ws      Merged fix when SIM fails during emergency call
                   do not end the call.
09/19/03   ka      Modified get and set preferred PLMN list from SIM with
                   events
09/18/03   ws      Dual valid card support.
09/16/03   vt      Added preferred slot handling.
09/16/03   ws      Call rude wakeup when powering down.
                   uz_id update
08/28/03   ws      Added access functions for subscription information
08/22/03   vt      Mainlined packet state handling.
08/15/03   ws      Featurized diag_otasp_update
08/14/03   vt      Redid the changes for "wakeup from power save".
08/13/03   ws      Undid the changes for "wakeup from power save".
08/08/03   vt      Made cm band pref bitmask to 32 bit enum
07/14/03   jqi     Added Extended PRL support
                   -Passing down band pref to stack for get nw sel cmd.
07/03/03   prk     Modified processing of CM_PH_CMD_GET_NETWORKS for
                   multi-mode targets.
06/26/03   ws      Check for invalid band_pref and write a valid one if
                   necessary.
06/19/03   vt      Generate event to let clients know everytime we exit
                   emergency callback mode.
06/10/03   vt      Unwind any relaxation of mode preference for Emergency
                   calls.
                   Removed changing auto to digital only for non-amps build.
06/03/03   wli     Modified handling of SIM access for RTRE.
06/04/03   ic      Fixed compiler warnings:
                   - removed cmph_foward_client_ftm_cmd() as it became
                     obsolete
05/28/03   vt      Added new call events and changed roam and band enums.
05/22/03   prk     Modified is_valid_oprt_mode_switch() to allow a operating
                   mode transition from FTM to LPM.
05/05/03   prk     Fixed merge problem in cm_ph_increment_segments function
                   definition.
05/02/03   vt      Resetting voice as data fields on call end.
05/02/03   ws      Added FEATURE_UIM_RUIM for calls to diag_otasp_update
04/28/03   AT      Lint cleanup.
04/21/03   vt      Added handling of SIM access for RTRE.
04/14/03   prk     Removed references to FEATURE_AOC and FEATURE_MMGSDI.
                   Removed references to cmph_send_tc_stop_mode_req().
04/14/03   vt      Removed processing of RUIM config on ONLINE mode change.
04/07/03   ws      Fixed compiler warnings
03/21/03   hxw     Changed FEATURE_GPSONE_OOS to FEATURE_GPSONE_MSBASED.
03/18/03   sj      Removed sending of activation_req. Would be done in
                   regproxy.
03/12/03   ws      Modified timer proc to only return immediately if in GW
02/07/03   prk     Re-added call to cmph_send_activation_req()
02/28/03   prk     Mainlined FEATURE_MULTIMODE_ARCH.
02/28/03   ws      Featurized cmph_send_stop_mode_req for GW
02/27/03   prk     Removed sending of TMC_ONLINE command in
                   cmph_client_cmd_forward_mmll().  MMOC is now responsible
                   for sending this command.
02/27/03   vt      Properly featurized the ftm_mode nv update.
                   Replaced commented out mode_pref with sys_sel_pref event.
                   Allowed more transitions from FTM mode for GW.
02/27/03   ws      Fixes for MO SDB timeout problems.
02/25/03   RI      Modified processing of CM_PH_CMD_SYS_SEL_PREF to support
                   PS attach/detach on demand.
                   Added cmph_ps_attach_detach_para_check() for PS
                   attach/detach command check.
02/25/03   vt      Fixed a compile problem with HDR. Set the reply object for
                   LPM for 1x only.
02/21/03   sj      Send MMOC subsc_chgd command only in pwrup or online mode.
                   Moved shutdown_wcall_processing to cmregprx.c.
                   Calling new MMOC API to wakeup from power save.
02/21/03   vt      Fixed problems to build for HDR.
02/14/03   jqi     Added support for runtime FTM.
                   Limited it to CDMA only.
02/11/03   prk     Called cmph_shutdown_wcall_processing() if the operating
                   mode is changing to SYS_OPRT_MODE_OFFLINE_CDMA.
02/07/03   vt      Allowed FTM->OFFLINE_CDMA mode transition for GW.
                   Mainlined FEATURE_LPM. Fixed a compile error for GW for FTM
02/06/03   vt      Replaced ph_ptr->answer_duration with ph_ptr->answer_uptime
02/06/02   cs      Added valid card info which is used for call origination
                   handling.
02/04/03   ws      Modified cmph_otasp_update_mode to not read from NV.
01/21/03   ic      In cmph_cmd_copy_fields() and cmph_info_get() added copying
                   of ph_ptr->answer_voice and ph_ptr->answer_duration fields.
                   In cmph_timer_proc() replaced answer_uptime field name with
                   answer_duration.
01/20/03   ws      Updated copyright information for 2003
01/20/03   prk     Featured out calls to diag_otasp_update.
01/17/03   ws      Featurized cmph_complete_sys_sel_pref_req and
                   cmph_process_get_networks_req to remove warnings.
12/12/02   vt      Added Manual PLMN fix.
12/10/02   vt      Prohibited transitioning from FTM to ONLINE operating mode.
11/27/02   vt      Fixed bugs in subscription functions for CDMA.
11/26/02   vt      Fixed compile problems with cmph_send_service_req() and
                   cmph_cmd_get_networks_para_check().
11/25/02   vt      Fixed a bug with RTRE when RUIM card is pulled out.
11/22/02   vt      Disabled issueing subscription changed command when in
                   FTM mode during startup.
11/22/02   PRK     Added support for accessing user preferred PLMN list.
11/20/02   vt      Sending NVRUIM event only if proper features are defined.
11/20/02   vt      Moved diag updating from rtre changed to subscription
                   available command.
11/19/02   vt      Added changing RTRE configuration.
                   Removed handling of powerup pref mode nv item.
11/15/02   vt      Properly featurized the packet state.
11/14/02   vt      Merged changes from GW mainline.
                   [ws]Merged in position determination changes.
                   [prk]Added call to cmph_send_activation_req().
                   [prk]Removed call to cmph_send_activation_req() due to
                   issues in the lower layers.
                   [AT]Fixed some error messages, added some F3 messages when
                   we are running out of funds.
                   [YR]Added test control type handling.
                   [PRK]Added FEATURE_REG_DEEP_SLEEP.
                   [CS]Removed static from cmph_send_service_req definition.
10/31/02   vt      Fixed a problem with mode pref change
10/30/02   vt      Fixed compiler errors and warnings.
10/24/02   vt      Merged mm build changes.
10/23/02   vt      Made changes to get GW working.
                   Removed some compiler warnings.
10/22/02   vt      Uncommented code for GPS mode handling.
10/07/02   vt      Fixed a bug to set prst_mode_pref correct on bootup
                   for multimode. FTM changes too.
09/30/02   prk     Removed cmph_map_cm_mode_pref_to_ll.
09/24/02   prk     Sent the CM_PH_EVENT_SUBSCRIPTION_AVAILABLE event after
                   a service request has been made during processing of
                   CM_SIM_AVAILABLE_CNF.
09/24/02   prk     Mainlined code under FEATURE_CM_USE_UMTS_REG_INTERFACE.
                   Send activation request in cmph_init.
09/20/02   vt      Corrected a typo in checking persistent roam pref.
09/16/02   vt      Corrected some typos and compile errors for 1x build.
09/16/02   vt      Added FTM mode handling.
09/13/02   prk     Modified code to convert NV enums to CM enums for
                   NV_NET_SEL_MODE_PREF_I, NV_ACQ_ORDER_PREF_I and
                   NV_SERVICE_DOMAIN_PREF_I NV items.
09/10/02   ws      Added initial cm20 backward compatibility.
09/03/02   prk     Modified cmph_map_cm_mode_pref_acq_order_pref_to_ll to
                   remove compiler warning.
                   Called cm_aoc_init and sent the
                   CM_PH_EVENT_SUBSCRIPTION_AVAILABLE event to the processing
                   of the CM_SIM_AVAILABLE_CNF event so phone initialization
                   is faster.
                   Processed the CM_SIM_NOT_AVAILABLE_CNF event.
08/30/02   vt      RTRE changes & subscription change phone command.
08/10/02   tjw     Modified LPM to OFFLINE handling to go offline instead of
                   poweroff.
08/06/02   HQ      Added FEATURE_CDSMS.
07/30/02   AT      Added MSG_HIGH to help with AOC.
07/22/02   PRK     Added support for manual PLMN selection.
07/24/02   vt      Added handling for wakeup from deep sleep(standby)
07/03/02   vt      Removed procesing in cmph_offline().
07/03/02   vt      Added additional handling of offline operating mode.
06/05/02   PRK     Mainlined FEATURE_CM_USE_NV_PH_PREF.
06/04/02   PRK     Added FEATURE_CM_INIT_PS_SERVICE_DOMAIN.
05/28/02   PRK     Modified is_valid_oprt_mode_switch to process the
                   SYS_OPRT_MODE_ONLINE operating mode. Modified
                   cmph_client_cmd_forward_ll to process the
                   SYS_OPRT_MODE_ONLINE_CDMA operating mode.
                   Added FEATURE_LPM changes.
06/11/02   vt      Added convertion routines to translate enum values between
                   cm and sd for band, roam, & hybr preferences.
06/06/02   sj      Added support for Multi-mode architecture.
04/22/02   vt      Fixed a compile problem with SD1.0
04/12/02   sh      Remove analog from mode pref if FEATURE_ACP is not defined
04/09/02   sh      Added duration in cmph_mo_sms_end to allow caller to
                   specify when to unforce mode pref. Added
                   cmph_select_dbm_mode_pref
04/03/02   RC      Remove validation of AUTO in cmph_is_valid_mode_band_pref.
04/02/02   sh      Discard duplicate oprt cmd and added first_time_camp_on_1x
03/29/02   ic      In cmph_send_ss_pref_cmd() put #ifdef FEATURE_HDR_HYBRID
                   around line
                   mc_ptr->pref_sys_changed.mode_pref    = sd_mode_pref;
03/08/02   hxw     Added FEATURE_GPSONE_MSBASED to support MSBased gpsOne.
03/21/02   sh      Update hybrid HDR serving system status if HDR is
                   deactivated due to operating mode change
03/10/02   sh      Removed IDM timer cancellation when hybrid HDR is in
                   service
03/05/02   az      Added function call to read security code from NV upon
                   NAM change
03/03/02   sh      Set hybr pref to off and remove HDR from mode pref
                   in the online command. Simplfy the non-hybrid to hybrid
                   transition using the pref sys change command only
02/20/02   sh      Added data session handoff support for hybrid operation
02/06/02   sh      Added hybrid 3.0 support
01/25/02   sj      Added support for Tiered service - user zone feature.
01/19/02   az      Added a parameter in a call to cmph_force_mode_on_the_fly()
                   and accordingly changed where it is being called.
12/11/01   sh      Added preliminary hybrid operation NV item support
12/08/01   sh      Added preliminary hybrid operation support
05/07/02   PRK     Added processing of CM_PH_CMD_CLIENT_ACT for GSM/WCDMA.
                   Included cmxsms.h instead of cmsms.h
05/05/02   vt      Fixed compile problem with new mm cm.h
05/03/02   PRK     Updated code for WCDMA/GSM NV items.  Introduced
                   FEATURE_CM_USE_NV_PH_PREF.  Updated to support new REG-CM
                   interface.  Introduced FEATURE_CM_USE_UMTS_REG_INTERFACE.
04/26/02   ATM     Added call to cmlog_operating_mode()
04/22/02   ATM     Updating with changes for Advice of Charge.
03/01/02   ATM     Fixed TYPO: UMTS_GSM_ACCESS_ONLY should be
                   GSM_RADIO_ACCESS_ONLY.
02/25/02   PRK     Changed OVERALL_CALL_STATE_IDLE enum value to
                   CM_OVERALL_CALL_STATE_IDLE.
02/06/02   PRK     Added test control feature (FEATURE_TC).
01/28/02   PRK     Updated names of types/enums for PLMN selection/reselection
                   Featurized future PLMN selection/reselection code with
                   FEATURE_NEW_PLMN and removed "feature" REAL_CODE.
                   Added parameter checking for the subscription (not)
                   available commands.
01/18/02   ic      Merged MSM_CM.05.03.33 on top of tip CCS CM
                   Diffed MSM_CM.05.03.32 with MSM_CM.05.03.33 and only the
                   changes between those two were merged with CCS CM
12/13/01   ic      Merged MSM_CM.05.03.32 onto SVD CM tip.
                   CCS CM code started from CM VU MSM_CM.05.03.25 + WCDMA/GSM
                   stuff from SIMBA team merged on top of it.
                   We diff'ed MSM_CM.05.03.25 with MSM_CM.05.03.32
                   (CM VU in N*2165) that we needed to merge with and changes
                   between those two VUs were merged onto CCS CM tip.
12/13/01   ATT     Integrated AOC with GSDI.
11/21/01   PRK     Added REAL_CODE pre-processor "feature" to remove code not
                   needed in initial Surf testing.  Upon completion of Surf
                   testing the code should be restored to its original form.
11/17/01   sh      Added 1xhdr data session handoff support
11/15/01   ATT     Updated AOC feature to save numbers in correct units.
11/12/01   PRK     Removed reference to NV_MODE_NO_RADIO_ACCESS and made
                   changes due to nv_item_type field name changing to
                   pref_plmn.
11/01/01   sh      Renamed cmph_force_to_colloc as cmph_is_colloc_allowed
10/29/01   sh      Added MSM5500 release 2.0 hybrid operation support
10/23/01   VT/IC   Baseline for CCS
10/18/01   PRK     Added changes for WCDMA/GSM mode.
                     Added support for PLMN selection/reselection
                     (FEATURE_PLMN).
                     Re-added Serving System group and moved srv_state,
                     roam_status, rssi from phone group to serving system
                     group (FEATURE_NEWSS).
10/15/01   RI      Added support for Supplementary Services ( GSM/WCDMA ).
10/14/01   RC      More graceful handling of invalid mode preference in
                   map_mode_pref_to_sd_mode_pref().
09/14/01   HD      Added support for poweroff/offline mode change.
08/23/01   HD      NAS header file reorg changes + RSSI and Roaming ind.
08/21/01   ic      Main-lined FEATURE_NEWCM
08/14/01   WLI     With RUIM read SPC status from RUIM instead of from NV.
06/27/01   ych     Removed JCDMA specific code that was initializing srv_state
                   digital in cmph_init( )
05/31/01   RC      Added CM_CALL_TYPE_PD to map_call_type_to_sd_orig_mode()
05/24/01   RC      Added CM_MODE_PREF_CDMA_AMPS_ONLY
05/07/01   HQ      Added #include stdlib.h.
04/24/01   RC      FEATURE_NEWCM support for SD 2.0 related code.
04/13/01   SH      Added Preliminary HDR support
03/27/01   RC      Added SD 2.0 trimode support.
04/27/01   HD      Added changes for WCDMA/GSM mode.
03/08/01   RC      Fixed a problem with operating mode check.
02/16/01   SH      added CM_END_ACK_F
02/06/01   RC      Added support for System Determination 2.0.
01/23/01   ych     Merged JCDMA features.
08/23/00   vt      Added new CM interface changes.
04/07/00   CS      Saved the new NAM in NV when directed by the network.
03/27/00   HD      Added support for MODE_OFFLINE_ANALOG
03/19/00   RY      Removed OTASP_HOLD_CMD_IN_COMMIT processing from
                   CM_PH_CMD_OPRT_MODE in cmph_client_cmd_check() and
                   cm_client_cmd_forward_mc()
03/13/00   RY      Added OTAPA support
12/13/99   IT      Added handling for next data call as data.
12/03/99   VT      Merged TriMode Code.
12/02/99   VT      CR12075 - For OTASP call, auto nam is turned off.
11/04/99   SH      CR11880 - Fixed a problem with NDSS.
10/20/99   HD      Fixed the problem of DATA_ONCE setup not clearing(CR#11848)
09/14/99   SH      Added client ID checking for all client requests
09/14/99   SH      Removed CM_MODE_PREF_ANALOG_PREF
08/31/99   SH      Modified codes to featurize UASMS
06/08/99   SH      Modified codes in cmph_is_valid_pref_mode for
                   digital related modes
06/21/99   SH      added cmph_offline
06/16/99   SH      Added processing for CM_NAM_CHANGED_F
05/31/99   SH      Added CM 2.0 features
01/07/99   RC      Changes per ARM compiler.
12/30/98   RC      Changes per 4th week of I&T.
12/08/98   RC      Changes per second week of I&T.
11/24/98   RC      Initial release.

===========================================================================*/



/****************************************************************************

 Organization of the file:

    The file is divided into multiple sections.
    You can jump from one sections to the other by searching for / followed
    by 2 *'s. The order of objects defined is as follows:

        includes
        forward declarations
        #defines

        functions
        - Internal [Common, 1x only, GW only]
        - External [Common, 1x only, GW only]

****************************************************************************/

/**--------------------------------------------------------------------------
** Includes
** --------------------------------------------------------------------------
*/

#include "mmcp_variation.h"
#include "customer.h"  /* Customer configuration file */
#include "cm.h"        /* External interface to cm.c */
#include "cm_v.h"
#include "cmi.h"
#include "comdef.h"    /* Definition for basic types and macros */
#include "rex.h"       /* Interface to rex services */
#include "nv.h"        /* Interface to NV services */
#include "cmph.h"      /* Interface to CM phone object */
#include "cm_msgr_msg.h"
#include "cmsds.h"      /* Interface to Domain selection object*/
#include "cmss.h"      /* Interface to CM serving system object */
#include "cmtaski.h"   /* Interface to signal definitions */
#include "cmdbg.h"     /* Interface to CM debug services */
#include "cmclient.h"  /* Interface to CM Client Interface Block */
#include "cmcall.h"    /* Interface to CM call object */
#include "cmlog.h"     /* Interface to diag services */
#include "cmlog_v.h"
#include "cmnv.h"      /* Interface to CM NV services */
#include "time_svc.h"  /* Interface to clock services */
#include "cmxpd.h"     /* Interface to PD object */
#include "cmreply.h"
#include "prl_v.h"     /* Interface to PRL services */
#include "cmaccessctrl.h"

#ifdef FEATURE_IP_CALL
#include "cmipappi.h" /* Interface to inform cm ip app about service */
#endif
#include "mccdma_v.h"

#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
#include "cmxsms.h"    /* Interface to SMS object */
#include "cmxdbm.h"    /* Interface to DBM object */
#include "cmxll.h"     /* MC to CM interface*/
#include "cai.h"       /* Over the air messages definitions */
#include "cai_v.h"
#include "mc.h"        /* Interface to MC Task */
#include "mc_v.h"
#include "db.h"        /* Interface to database services */

#include <string.h>    /* Interface to string library */
#include "sd.h"        /* Interface to System Determination services */
#include "sd_v.h"

#ifdef FEATURE_JCDMA
#include "txc.h"       /* Interface to TXC subtask */
#endif /* FEATURE_JCDMA */
#endif /* #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

#if (defined FEATURE_HDR_HYBRID) || (defined FEATURE_CM_SS_MEAS)
#include "hdrcp_msg.h"
#include "cmd.h"
#endif  /* FEATURE_HDR_HYBRID */

#if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE) || defined(FEATURE_TDSCDMA)
#include "mm.h"
#include "reg_task.h"
#include "cmregprxi.h"
#endif

#ifdef CM_GW_SUPPORTED
/*lint -esym(766,reg_task_v.h)*/
#include "reg_task_v.h"
#include "cmutil.h"
#include "cmwcall.h"
#include "cmwaoc.h"    /* Interface to Advice of Charge utilities */
#include "cmregprx.h"

#ifdef FEATURE_TC
#include "tctask.h"
/*lint -esym(766,tctask_v.h)*/
#include "tctask_v.h"
#endif /* FEATURE_TC */

#ifdef FEATURE_SEGMENT_LOADING
#include "ITDSCDMA.h"
#include "IWCDMA.h"
#endif

#endif /* FEATURE_WCDMA, FEATURE_GSM */

#include "mmoc.h"
#include "diag.h"

#include "ftm.h"

#include "cmmsc.h"
#include "cmmsc_sglte.h"
#include "cmmsc_auto.h"
#include "cmsimcoord.h"
#include "cmclnup.h"
#if (defined(FEATURE_ALS) && defined(FEATURE_GSM))
#include "cmals.h"
#endif

#include "cmmmgsdi.h"

#ifdef FEATURE_HDR_HANDOFF
#include "cmssidm.h"
#endif

#include "sys.h"
#include "sys_v.h"
#include "sd.h"
#include "sd_v.h"
#include "sys_m_reset.h"

#include "cmefs.h"

#ifdef FEATURE_BCMCS
#include "cmbcmcs.h"
#endif

#include "cmpmprx.h"

#include "hdrcp_api.h"

/* For handling subscription in CM we need to include
** cmmmgsdi.h for CDMA also, hence making it more generic.
** For backward compatibility for CDMA configuration
** cmmmgsdi.h will not be needed but it won't create any issue
*/

#include "cmmmgsdi.h"
#include "cmcc.h"

#ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
#include "cmsoa.h"
#endif

#include "fs_public.h"  /* Interface to EFS services */
#include "mcfg_fs.h"    /* Interface to MCFG efs wrappers */

#include "cmstats.h"

#include "subs_prio.h"

#ifdef CM_DEBUG
#error code not present
#endif

#ifdef FEATURE_MMODE_QTF
#error code not present
#endif

#include "cmrpm.h"

#ifdef FEATURE_MMODE_RPM_TDSCDMA
#include "cmrpm_tds.h"
#endif
#ifdef FEATURE_TDSCDMA
#include "tdsrrcdataext.h"
#endif
#include "fs_public.h"

/* Header file Time Test Lite (TTL) framework for profiles modem boot up time
*/
#include "ttl_map.h"

#include "cmautoreg.h"      /* Interface to CM Auto Registration object */
#ifdef FEATURE_MODEM_CONFIG_REFRESH
#include "mcfg_refresh.h"    /* interface to MCFG refresh */
#endif

#ifdef FEATURE_CM_LTE
#include "mmtask_v.h"
#include "cmrpm_lte.h"
#endif
#include "cm_qsh_ext.h"
#include "cmdbg_qsh.h"

#include "cmpsm.h"
/**--------------------------------------------------------------------------
** Variables - external, common
** --------------------------------------------------------------------------
*/

extern   mmgsdi_data_type  cm_mmgsdi_read_cnf_ptr;

/**--------------------------------------------------------------------------
** Forward declarations
** --------------------------------------------------------------------------
*/

#ifdef FEATURE_MMODE_SXLTE_G
void cmph_initiate_sxlte_multimode_switch
(
  boolean force_subs_change
);
#endif

static void cmph_cmd_sys_sel_pref_proc(

  cm_ph_cmd_s_type         *ph_cmd_ptr
);

static void cmph_process_domain_pref_chg(

  cm_ph_cmd_s_type         *ph_cmd_ptr
);

static void cmph_hybr_2_gw_init(

   uint8             refresh_subs_mask ,
    /* Subs mask whose NVs need to be refreshed
    */
   boolean           is_pwr_on
    /* is this a power on refresh or MCFG triggered refresh
    */
);

static sd_ss_pref_reas_e_type cmph_get_pref_reason(cm_act_type_e_type    act_type);

/*===========================================================================

FUNCTION cmph_is_valid_client_asubs_id

DESCRIPTION
  Check whether the asubs_id is valid.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if the asubs_id is valid.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
static boolean cmph_is_valid_client_asubs_id(

       sys_modem_as_id_e_type      asubs_id
          /* Subscription id to be validated */

);

#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
static db_voice_as_data_type cmph_map_voice_answer_cm2db
(
  cm_answer_voice_e_type cm_voice
);

static cm_ph_cmd_err_e_type  cmph_cmd_packet_state_para_check(
  cm_ph_cmd_s_type           *ph_cmd_ptr
);
#endif /*  (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

static cm_ss_e_type cmph_get_ss_to_check_for_call(
  cm_ss_e_type ss
);

static cm_ph_cmd_err_e_type     cmph_cmd_get_networks_para_check(

  cmph_s_type          *ph_ptr,
      /* Pointer to a phone object */

  cm_ph_cmd_s_type           *ph_cmd_ptr
     /* Pointer at phone command component */
);

static cm_ph_cmd_err_e_type     cmph_cmd_terminate_get_networks_para_check(
    cm_ph_cmd_s_type               *ph_cmd_ptr
);

#define CMPH_RESCAN_TIME                4    /* seconds */
    /* Ballpark estimation for the time it takes the phone to do a rescan
    ** and reacquire service once the mode preference is forced */

#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
static cm_mode_pref_e_type remove_amps_from_cm_mode_pref(

  cm_mode_pref_e_type cm_mode_pref
   /* mode preference */
);
#endif /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */

#ifdef CM_GW_SUPPORTED

static boolean cmph_is_3GPP_ef_rat_mode_pref_change_allowed (
                                 sd_ss_mode_pref_e_type new_mode_pref ,
                                 sd_ss_mode_pref_e_type ef_rat_mode_pref );

#endif /* CM_GW_SUPPORTED */

static void cmph_set_is_sub2_map_to_hybr3(void);

static void cmph_init_single_sim_mode (void);

static void cmph_proc_subscription_ready_rpt(

       mmgsdi_session_id_type   session_id,
        /* Session Id of the report recieved */

       mmgsdi_slot_id_enum_type slot
        /* Slot on which the app is activated*/
);


static boolean cmph_cmd_standby_pref_proc_int(

  cm_ph_cmd_info_s_type            *cmd_info_ptr,
  cm_ph_cmd_e_type                  cmd,
  cm_client_id_type                client_id,
  boolean                          is_cdma_subscription_available,
  boolean                          is_gwl_subscription_available,
  boolean                          is_hybr_gw_subscription_available,
  boolean                      is_hybr_gw3_subscription_available
);

static void cmph_read_qmss_enabled (void);
static void cmph_read_operator_name (sys_modem_as_id_e_type asubs_id);
static void cmph_read_operator_imsi (void);
void cmph_send_trm_priority_req( 
  lte_trm_priority_e      trm_priority,
  sys_modem_as_id_e_type  as_id
);

static  void cmph_send_srvcc_capability_to_reg(cm_ph_cmd_info_s_type  *cmd_info_ptr);
#ifdef FEATURE_HDR
static void cmph_send_trm_priority_req_non_lte( boolean tune_away_req);
#endif

/**--------------------------------------------------------------------------
** Defines
** --------------------------------------------------------------------------
*/

#ifdef FEATURE_FULL_TIME_SHDR
#error code not present
#endif

/* Tunable phone parameters.
*/

/* Defines a datatype that maps nv band pref with cm band pref.
   NV items will always be 16-bit values.
   We intentionally use uint16 instead of nv_band_pref_enum_type
   because we want cm_band_pref and nv_band_pref fields to overlap in memory.
   We ran into problems when MS VC++ compiler expanded nv_band_pref_enum_type
   to 32 bit value.
*/
typedef union {
  //cm_band_pref_e_type     cm_band_pref;              /* CM band preference */
  uint32                  dummy;
  uint16                  nv_band_pref[2]; /* NV band prefrence */
} cm_nv_band_pref_u_type;


/**--------------------------------------------------------------------------
** Datatypes
** --------------------------------------------------------------------------
*/

#ifdef FEATURE_HICPS_STACK_SYNC_UP
/* Values read from EFS will be stored here */
static cm_gwl_avoidance_timers_s_type cm_gwl_avoidance_timers;
#endif

static cmnv_data_s_type      cmnv_data_buf;
    /* Static CM NV data buffer that is big enough to hold data
    ** that is associated with CM NV items.
    **
    ** Note that we could simply use nv_item_type, but this would
    ** be a waste of ~300 bytes of RAM */

/*lint -save -e826 */
static nv_item_type  *cmnv_item_ptr = (nv_item_type*) &cmnv_data_buf;
    /* NV Item pointer to do cmnv_write() and cmnv_read(). Note that
    ** this pointer is initialized to point at a RAM buffer of adequate
    ** size to do all CM NV read/writes operations */
/*lint -restore */

#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
static boolean otasp_autonam_restore = FALSE;
    /* This variable is used to restore the AUTO NAM for OTASP. AUTO NAM is
    ** disabled for OTASP call. On completion of OTASP call, this flag is
    ** used to determine if the AUTO NAM should be enabled or not. */
#endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

#ifdef CM_GW_SUPPORTED
#ifdef FEATURE_TC
static sys_oprt_mode_e_type             restore_oprt_mode;
  /*
  ** A variable that is used to restore the operating mode after a test
  ** control test has been completed.
  */
#endif /* FEATURE_TC */

#endif /* FEATURE_WCDMA, FEATURE_GSM */

#ifdef FEATURE_FULL_TIME_SHDR
#error code not present
#endif


static boolean cmph_gw_subs_from_card_sent;
  /* If the last GW subscription status, sent to CM, by calling
  ** cm_ph_cmd_subscription_available_new(), is available this will be TRUE,
  ** and if the last GW subscription status, sent to CM, by calling
  ** cm_ph_cmd_subscription_not_available_new(), is not avaialble, this will be
  ** FALSE.
  */

// instance pointer for segment loading of TDS or WCDMA
#ifdef FEATURE_SEGMENT_LOADING
interface_t *pi_mmode_tdscdma = NULL;
interface_t *pi_mmode_wcdma = NULL;
#endif

static boolean cmph_hybr_gw_subs_from_card_sent;
  /* If the last GW subscription status, sent to CM, by calling
  ** cm_ph_cmd_subscription_available_new(), is available this will be TRUE,
  ** and if the last GW subscription status, sent to CM, by calling
  ** cm_ph_cmd_subscription_not_available_new(), is not avaialble, this will be
  ** FALSE.
  */

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
static boolean cmph_hybr_3_gw_subs_from_card_sent;
  /* If the last GW subscription status, sent to CM, by calling
  ** cm_ph_cmd_subscription_available_new(), is available this will be TRUE,
  ** and if the last GW subscription status, sent to CM, by calling
  ** cm_ph_cmd_subscription_not_available_new(), is not avaialble, this will be
  ** FALSE.
  */
#endif


static boolean cmph_cdma_subs_from_card_sent;
  /* If the last CDMA subscription status, sent to CM, by calling
  ** cm_ph_cmd_subscription_available_new(), is available this will be TRUE,
  ** and if the last CDMA subscription status, sent to CM, by calling
  ** cm_ph_cmd_subscription_not_available_new(), is not avaialble, this will be
  ** FALSE.
  */

static boolean cmph_received_card_init_completed_evt;
  /* Stores the present status of card initilization completed event sent to
  ** CM
  */

#ifdef FEATURE_MMGSDI_SESSION_LIB
static boolean cmph_sessoin_open_sent;
  /* Stores the staus of the session open operation in CM.
  */
#endif

/*Table of hw-id's initialised in cmph init*/
/* SYS_MODEM_AS_ID_NO_CHANGE is being used here to get info of maximum subs present*/
static sys_vsid_type cmph_asid2vsid_map[CMPH_SUB_TYPE_MAX][SYS_VSID_APP_MAX];


static boolean cmph_subsc_cmd_proccessing_in_progress;
  /* To indicate if there is ongoing subscription command.
  **
  */

/* ds call back function pointer.
*/
static cm_ds_sys_pwroff_lpm_notif_f_type *cm_ds_sys_pwroff_lpm_notif_cb_func_ptr = NULL;
static cm_ds_cmd_notif_ext_f_type *cm_ds_subsc_cmd_notif_cb_ext_func_ptr = NULL;

/* Auto Register Attributes */
static char *CM_AUTO_REG_EFS_CU_IMSI_DIR1           = "/operator";
static char *CM_AUTO_REG_EFS_CU_IMSI_DIR2           = "/operator/cu";
static char *CM_AUTO_REG_EFS_CU_IMSI_FILE           = "/operator/cu/imsi.dat";
static char *CM_AUTO_REG_EFS_CMCC_IMSI_DIR2         = "/operator/cmcc";
static char *CM_AUTO_REG_EFS_CMCC_IMSI_FILE         = "/operator/cmcc/imsi.dat";

byte  cm_auto_reg_efs_cu_imsi[CM_AUTO_REG_EFS_CU_IMSI_LEN];
byte  cm_auto_reg_efs_cmcc_imsi[CM_AUTO_REG_EFS_CU_IMSI_LEN];

static sd_ss_mode_pref_e_type cmph_temp_ef_rat_disabled_mask=SD_SS_MODE_PREF_NONE;

/* return the pointer of static variable that record NO_CHANGE status
** for each SS preference when issue sys_sel_pref command
*/
static uint32  *cmph_pref_nochg_ptr( void );

/* set corresponding bit if NO_CHANGE specified for ss pref
*/
static void cmph_set_pref_nochg_flag(cmph_pref_nochg_e_type pref);

/* test if specific ss pref NO_CHANGE bit is set or not
*/
static boolean cmph_is_pref_nochg_set(cmph_pref_nochg_e_type pref);

/* clear all ss pref NO_CHANGE bit
*/
static void cmph_clr_all_pref_nochg_flag(void);

/* Check if there is subscription command on hold
*/
static boolean cmph_is_subsc_cmd_on_hold(void);

#ifdef FEATURE_RAT_PRIORITY_LIST
/* write rat_acq_order
*/
static boolean cmph_write_rat_acq_order(
  const cm_acq_pri_order_pref_s_type *rat_acq_order_ptr,
  sys_modem_as_id_e_type sub_id
);
#endif

/* Resume HDR/LTE stack */
static void cmph_resume_hybrid_opr_without_activating_prot( void );


static void cmph_set_act_update_reas_for_pm_rest (

  cmph_s_type                     *ph_ptr,
      /* Pointer to a phone object */

  sys_modem_as_id_e_type           asubs_id
);

static void cmph_load_prst_dual_standby_pref ( void );

static boolean cmph_is_subscription_available( uint8 new_sub_mask);

/**-------------------------------------------------------------------------
** Functions - internal, common
** -------------------------------------------------------------------------
*/

/*===========================================================================

FUNCTION cmph_set_is_user_resel_buffered_ss

DESCRIPTION
  Set the value to is_user_resel_buffered flag for ss

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  None

===========================================================================*/
void cmph_set_is_user_resel_buffered_ss(

  cm_ss_e_type            ss, 
    /* value that needs to be set to is_user_resel_buffered per SS */
  boolean                 val
)
{
  cmph_s_type             *ph_ptr = cmph_ptr();

  CM_MSG_HIGH_2( "is_user_resel_buffered set %d for ss = %d", val, ss );

  switch (ss)
  {
    case CM_SS_MAIN:
    case SD_SS_MAX:		

	  ph_ptr->main_stack_info.is_user_resel_buffered = val;
	  break;

    case CM_SS_HYBR_2:

	  ph_ptr->hybr_2_stack_info.is_user_resel_buffered = val;
      break;

    #if defined FEATURE_MMODE_SXLTE_G || defined(FEATURE_MMODE_TRIPLE_SIM)

    case CM_SS_HYBR_3:

      ph_ptr->hybr_3_stack_info.is_user_resel_buffered = val;
      break;
    #endif

    default:
      break;
  }

 return;
} /* cmph_set_is_user_resel_buffered_ss */


/*===========================================================================

FUNCTION cmph_get_is_user_resel_buffered_ss

DESCRIPTION
 Get the value for is_user_resel_buffered flag for ss

DEPENDENCIES
  none

RETURN VALUE
  boolean

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_get_is_user_resel_buffered_ss(

  cm_ss_e_type            ss 
)
{
  cmph_s_type             *ph_ptr = cmph_ptr();
  boolean ret_val = FALSE;

  switch (ss)
  {
    case CM_SS_MAIN:
    case SD_SS_MAX:

	  ret_val =  ph_ptr->main_stack_info.is_user_resel_buffered;
	  break;

    case CM_SS_HYBR_2:

	  ret_val =  ph_ptr->hybr_2_stack_info.is_user_resel_buffered;
      break;

    #if defined FEATURE_MMODE_SXLTE_G || defined(FEATURE_MMODE_TRIPLE_SIM)

    case CM_SS_HYBR_3:

      ret_val =  ph_ptr->hybr_3_stack_info.is_user_resel_buffered;
      break;
    #endif

    default:
      CM_MSG_HIGH_1( "is_user_resel_buffered: Invalid ss = %d", ss );
      break;
  }

 return ret_val;
} /* cmph_get_is_user_resel_buffered_ss */


/*===========================================================================

FUNCTION  is_contain_3GPP_mode_pref

DESCRIPTION
 Utility function which checks if the given mode preference contains any 3GPP
 mode preferences.

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
       boolean                         is_contain_3GPP_mode_pref(

       cm_mode_pref_e_type             mode_pref
)
{
  sd_ss_mode_pref_e_type     sd_mode_pref    = \
    cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref);

  return( SD_MODE_CONTAIN( sd_mode_pref, SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE) );
}

/*===========================================================================

FUNCTION  is_contain_3GPP2_mode_pref

DESCRIPTION
 Utility function which checks if the given mode preference contains any 3GPP2
 mode preferences.

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static boolean                         is_contain_3GPP2_mode_pref(

       cm_mode_pref_e_type             mode_pref
)
{
  sd_ss_mode_pref_e_type     sd_mode_pref    = \
    cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref);

  return( SD_MODE_CONTAIN( sd_mode_pref, SD_SS_MODE_PREF_CDMA_AMPS_HDR) );
}

/*===========================================================================

FUNCTION  cmph_get_feature_mode

DESCRIPTION
 Get the current feature mode configuration stored in phone object.

DEPENDENCIES
 None

RETURN VALUE
  feature_mode

SIDE EFFECTS
  None

===========================================================================*/
sys_overall_feature_t  cmph_get_feature_mode (void)
{
  sys_overall_feature_t feature_mode = cmph_ptr()->feature_mode;

  if (cmph_is_ssim() &&
    feature_mode != SYS_OVERALL_FEATURE_MODE_SGLTE &&
    feature_mode != SYS_OVERALL_FEATURE_MODE_SVLTE &&
    feature_mode != SYS_OVERALL_FEATURE_MODE_SRLTE)
  {
    feature_mode = SYS_OVERALL_FEATURE_MODE_NORMAL;
  }
  return feature_mode;
}

/*===========================================================================

FUNCTION  cmph_is_feature_mode_1x_sxlte

DESCRIPTION
 The function returns if the overall feature mode configuration is svlte/srlte.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if feature mode is svlte/srlte.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean  cmph_is_feature_mode_1x_sxlte (void)
{
   sys_overall_feature_t feature_mode = cmph_get_feature_mode();
   return (feature_mode == SYS_OVERALL_FEATURE_MODE_SVLTE ||
          feature_mode == SYS_OVERALL_FEATURE_MODE_SRLTE);
}

/*===========================================================================

FUNCTION  cmph_is_feature_mode_sglte

DESCRIPTION
 The function returns if the overall feature mode configuration is sglte.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if feature mode is sglte.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_feature_mode_sglte (void)
{
   sys_overall_feature_t feature_mode = cmph_get_feature_mode();

   if(feature_mode == SYS_OVERALL_FEATURE_MODE_SGLTE)
    return TRUE;

   return (FALSE);
}

/*===========================================================================

FUNCTION  cmph_get_subs_feature_mode

DESCRIPTION
 Get the current sub feature mode configuration stored in phone object.

DEPENDENCIES
 None

RETURN VALUE
  feature_mode

SIDE EFFECTS
  None

===========================================================================*/
sys_subs_feature_t  cmph_get_subs_feature_mode (sys_modem_as_id_e_type  asubs_id)
{
   if( (asubs_id > SYS_MODEM_AS_ID_NONE && asubs_id < SYS_MODEM_AS_ID_MAX ) && (asubs_id != SYS_MODEM_AS_ID_NO_CHANGE))
   {
    #if defined(FEATURE_MMODE_TRIPLE_SIM)
     if(SYS_MODEM_AS_ID_3 == asubs_id)
     {
       return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_3]);
     }
    #endif

    if( (SYS_MODEM_AS_ID_1 == asubs_id) || (SYS_MODEM_AS_ID_2 == asubs_id) )
   {
     return (cmph_ptr()->subs_feature_mode[asubs_id]);
   }
   else
   {
     return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1]);
   }
}
   else
   {
     return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1]);
   }
}


/*===========================================================================

FUNCTION  cmph_is_subs_feature_mode_sglte

DESCRIPTION
 The function returns if the subs feature mode configuration is sglte.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if feature mode is sglte.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/

boolean cmph_is_subs_feature_mode_sglte (
  sys_modem_as_id_e_type          asubs_id
)
{
   if((asubs_id > SYS_MODEM_AS_ID_NONE && asubs_id < SYS_MODEM_AS_ID_MAX) &&
     (asubs_id != SYS_MODEM_AS_ID_NO_CHANGE) &&
     (asubs_id < ARR_SIZE(cmph_ptr()->subs_feature_mode)))
   {
     #if defined(FEATURE_MMODE_TRIPLE_SIM)
     if(SYS_MODEM_AS_ID_3 == asubs_id)
     {
       return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_3] == SYS_SUBS_FEATURE_MODE_SGLTE);
     }
     #endif
     if( (SYS_MODEM_AS_ID_1 == asubs_id) || (SYS_MODEM_AS_ID_2 == asubs_id) )
     {
       return (cmph_ptr()->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_SGLTE);
     }
     else
     {
       return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SGLTE);
     }
   }
   else
   {
     return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SGLTE);
   }
}

/*===========================================================================

FUNCTION  cmph_is_subs_feature_mode_svlte

DESCRIPTION
 The function returns if the subs feature mode configuration is svlte.
 Note: SRLTE is only supported on sub1.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if feature mode is svlte.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_subs_feature_mode_svlte (
  sys_modem_as_id_e_type          asubs_id
)
{
   if((asubs_id > SYS_MODEM_AS_ID_NONE && asubs_id < SYS_MODEM_AS_ID_MAX) &&
     (asubs_id != SYS_MODEM_AS_ID_NO_CHANGE) &&
     (asubs_id < ARR_SIZE(cmph_ptr()->subs_feature_mode)))
   {
     #if defined(FEATURE_MMODE_TRIPLE_SIM)
     if(SYS_MODEM_AS_ID_3 == asubs_id)
     {
       return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_3] == SYS_SUBS_FEATURE_MODE_SVLTE);
     }
     #endif

     if( (SYS_MODEM_AS_ID_1 == asubs_id) || (SYS_MODEM_AS_ID_2 == asubs_id) )
     {
       return (cmph_ptr()->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_SVLTE);
     }
     else
     {
       return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE);
     }
   }
   else
   {
     return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE);
   }
}

/*===========================================================================

FUNCTION  cmph_is_subs_feature_mode_srlte

DESCRIPTION
 The function returns if the subs feature mode configuration is srlte.
 Note: SRLTE is only supported on sub1.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if feature mode is srlte.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_subs_feature_mode_srlte (
  sys_modem_as_id_e_type          asubs_id
)
{
   if((asubs_id > SYS_MODEM_AS_ID_NONE && asubs_id < SYS_MODEM_AS_ID_MAX) &&
     (asubs_id != SYS_MODEM_AS_ID_NO_CHANGE) &&
     (asubs_id < ARR_SIZE(cmph_ptr()->subs_feature_mode)))
   {
     #if defined(FEATURE_MMODE_TRIPLE_SIM)
     if(SYS_MODEM_AS_ID_3 == asubs_id)
     {
       return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_3] == SYS_SUBS_FEATURE_MODE_SRLTE);
     }
     #endif

     if( (SYS_MODEM_AS_ID_1 == asubs_id) || (SYS_MODEM_AS_ID_2 == asubs_id) )
     {
       return (cmph_ptr()->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_SRLTE);
     }
     else
     {
       return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SRLTE);
     }
   }
   else
   {
     return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SRLTE);
   }
}

/*===========================================================================

FUNCTION  cmph_is_subs_feature_mode_1x_sxlte

DESCRIPTION
 The function returns if the subs feature mode configuration is svlte/srlte.
 Note: SRLTE/SVLTE is only supported on sub1.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if feature mode is svlte/srlte.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_subs_feature_mode_1x_sxlte (
  sys_modem_as_id_e_type          asubs_id
)
{
   if((asubs_id > SYS_MODEM_AS_ID_NONE && asubs_id < SYS_MODEM_AS_ID_MAX) &&
     (asubs_id != SYS_MODEM_AS_ID_NO_CHANGE) &&
     (asubs_id < ARR_SIZE(cmph_ptr()->subs_feature_mode)))
   {

     #if defined(FEATURE_MMODE_TRIPLE_SIM)
     if(SYS_MODEM_AS_ID_3 == asubs_id)
     {
       return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_3] == SYS_SUBS_FEATURE_MODE_SVLTE ||
              cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_3] == SYS_SUBS_FEATURE_MODE_SRLTE);
     }
     #endif

     if( (SYS_MODEM_AS_ID_1 == asubs_id) || (SYS_MODEM_AS_ID_2 == asubs_id) )
     {
       return (cmph_ptr()->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_SVLTE ||
              cmph_ptr()->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_SRLTE);
     }
     else
     {
       return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE ||
              cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SRLTE);
     }
   }
   else
   {
     return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE ||
            cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SRLTE);
   }
}

/*===========================================================================

FUNCTION  cmph_is_subs_feature_mode_normal

DESCRIPTION
 The function returns if the subs feature mode configuration is normal.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if sub feature mode is normal.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_subs_feature_mode_normal (
  sys_modem_as_id_e_type          asubs_id
)
{
  if((asubs_id > SYS_MODEM_AS_ID_NONE && asubs_id < SYS_MODEM_AS_ID_MAX) &&
    (asubs_id != SYS_MODEM_AS_ID_NO_CHANGE) )
  {
    #if defined(FEATURE_MMODE_TRIPLE_SIM)
    if(SYS_MODEM_AS_ID_3 == asubs_id)
    {
      return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_3] == SYS_SUBS_FEATURE_MODE_NORMAL);
    }
    #endif

    if( (SYS_MODEM_AS_ID_1 == asubs_id) || (SYS_MODEM_AS_ID_2 == asubs_id) )
    {
      return (cmph_ptr()->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_NORMAL);
    }
    else
    {
      return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_NORMAL);
    }
  }
  else
  {
    return (cmph_ptr()->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_NORMAL);
  }
}

/*===========================================================================

FUNCTION  cmph_is_feature_mode_msim

DESCRIPTION
 The function returns if the feature mode configuration is multi-sim.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if feature mode is multi-sim.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_feature_mode_msim(void)
{
   sys_overall_feature_t feature_mode = cmph_get_feature_mode();
   return (feature_mode == SYS_OVERALL_FEATURE_MODE_MULTISIM);
}

/*===========================================================================

FUNCTION  cmph_is_feature_mask

DESCRIPTION
 The function checks the specfied feature mask against the current feature mode configuration.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if feature mode is sglte.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_feature_mask (
    cm_feature_mode_mask_e_type    feature_mask
)
{
   sys_overall_feature_t feature_mode = cmph_get_feature_mode();
   return ( (BM(feature_mode) & (uint32)feature_mask) > 0);
}

/*===========================================================================

FUNCTION  cmph_is_feature_mask_auto

DESCRIPTION
 The function checks the current feature mode configuration is feauture mask auto.

DEPENDENCIES
 none

RETURN VALUE
  boolean.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_feature_mask_auto (void)
{
   cm_feature_mode_mask_e_type    feature_mask = FEATURE_MODE_MASK_AUTO;
   sys_overall_feature_t feature_mode = cmph_get_feature_mode();
   return ( (BM(feature_mode) & (uint32)feature_mask) > 0);
}

/*===========================================================================

FUNCTION  cmph_is_subs_feature_mask_auto

DESCRIPTION
 The function checks the current feature mode configuration is feauture mask auto.

DEPENDENCIES
 none

RETURN VALUE
  boolean.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_subs_feature_mask_auto (
  sys_modem_as_id_e_type   asubs_id
)
{
   cmph_s_type* ph_ptr = cmph_ptr();

   if( (asubs_id > SYS_MODEM_AS_ID_NONE && asubs_id < SYS_MODEM_AS_ID_MAX) && (asubs_id != SYS_MODEM_AS_ID_NO_CHANGE))
   {
     #if defined(FEATURE_MMODE_TRIPLE_SIM)
       if(SYS_MODEM_AS_ID_3 == asubs_id)
       {
         if(ph_ptr->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_NORMAL ||
           ph_ptr->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_SVLTE ||
           ph_ptr->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_SRLTE)
         {
           return TRUE;
         }
       }
     #endif
     if( (SYS_MODEM_AS_ID_1 == asubs_id) || (SYS_MODEM_AS_ID_2 == asubs_id) )
     {
       if(ph_ptr->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_NORMAL ||
         ph_ptr->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_SVLTE ||
         ph_ptr->subs_feature_mode[asubs_id] == SYS_SUBS_FEATURE_MODE_SRLTE)
       {
         return TRUE;
       }
     }
   }

   return FALSE;
}


#if 0

/*===========================================================================

FUNCTION  cmph_determine_ss_per_mm_as_id

DESCRIPTION
 The function determines cm_ss base on as_id from mm indication and feature mode.

DEPENDENCIES
 none

RETURN VALUE
  cm_ss_e_type.

SIDE EFFECTS
  none

===========================================================================*/
cm_ss_e_type cmph_determine_ss_per_mm_as_id (
    sys_modem_as_id_e_type  as_id
)
{
  cm_ss_e_type cm_ss = CM_SS_MAIN;

  if (as_id != SYS_MODEM_AS_ID_1 && as_id != SYS_MODEM_AS_ID_2 && as_id != SYS_MODEM_AS_ID_3)
  {
    CM_ERR_2("invalid as_id value %d, default to %d", as_id, SYS_MODEM_AS_ID_1);
    as_id = SYS_MODEM_AS_ID_1;
  }

  /* svlte: LTE is on hybr2 if is_hybr_gw_operational == true */
  if( cmph_is_feature_mode_svlte() &&
      cmss_ptr()->info.is_hybr_gw_operational &&
      sys_srv_status_is_srv(cmss_ptr()->info.gw_srv_status) &&
      cmss_ptr()->info.gw_sys_mode == SYS_SYS_MODE_LTE)
  {
    cm_ss = CM_SS_HYBR_2;
  }

   /* multi-sim or sglte - map as_id to cm_ss
     sglte: as_id maps to stack
     multi-sim: as_id maps to sub
  */
  else if (cmph_is_feature_mode_sglte())
  {
    cm_ss = cmph_map_as_id_to_cm_ss(as_id);
  }

  else if (cmph_is_msim())
  {
    cm_ss = cmph_map_subs_to_ss(as_id);
  }

  return cm_ss;
}
#endif

/*===========================================================================

FUNCTION  cmph_determine_ss_per_as_id_and_rat

DESCRIPTION
 The function determines cm_ss base on asubs_id and rat.

DEPENDENCIES
 none

RETURN VALUE
  cm_ss_e_type.

SIDE EFFECTS
  none

===========================================================================*/
cm_ss_e_type cmph_determine_ss_per_rat (
    sys_modem_as_id_e_type  asubs_id,
    sys_sys_mode_e_type       rat
)
{
  cm_ss_e_type cm_ss = CM_SS_MAIN;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Non multi-sim: decide ss base on rat
  */

  if(rat == SYS_SYS_MODE_HDR)
  {
    if(cmss_ptr()->info.hdr_hybrid)
    {
      return CM_SS_HYBR_1;
    }
	else
	{
	  return CM_SS_MAIN;
	}
  }

  if (cmph_is_subs_feature_mode_1x_sxlte(asubs_id))
  {
    if (cmss_ptr()->info.is_hybr_gw_operational && rat == SYS_SYS_MODE_LTE)
    {
      cm_ss = CM_SS_HYBR_2;
    }
    else
    {
      cm_ss = CM_SS_MAIN;
    }
  }
  else if( cmph_is_subs_feature_mode_sglte(asubs_id) )

  {
    if (cmss_ptr()->info.is_hybr_gw_operational && rat == SYS_SYS_MODE_GSM)
      cm_ss = CM_SS_HYBR_2;
    else
      cm_ss = CM_SS_MAIN;
  }
  else if (cmph_is_msim())
  {
    /* multi-sim: asubs_id has one to one mapping to ss
    */
    cm_ss = cmph_map_subs_to_ss(asubs_id);
  }

  return cm_ss;
}

/*===========================================================================

FUNCTION  cmph_determine_cm_ss_per_domain

DESCRIPTION
 The function determines cm_ss base on asubs_id and domain.

DEPENDENCIES
 none

RETURN VALUE
  sys_modem_as_id_e_type.

SIDE EFFECTS
  none

===========================================================================*/
cm_ss_e_type  cmph_determine_ss_per_domain (
    sys_modem_as_id_e_type  asubs_id,
    sys_srv_domain_e_type     domain
)
{
  cm_ss_e_type cm_ss = CM_SS_MAIN;

  if(asubs_id == SYS_MODEM_AS_ID_NONE)
  {
    asubs_id = SYS_MODEM_AS_ID_1;
  CM_MSG_HIGH_0("asubs_id NONE received...default to AS_ID_1");
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Non multi-sim: decide ss base on rat
  */
  if (cmph_is_subs_feature_mode_sglte(asubs_id) && domain == SYS_SRV_DOMAIN_CS_ONLY)
  {
    /* With SGLTE, it's single SIM, and so asubs_id = MAIN, since SGLTE, Lower-layer often provide
    ** NONE for AS_ID.
    */
    cm_ss = cmmsc_sglte_get_ss_for_domain(asubs_id, SD_SS_SRV_DOMAIN_PREF_CS_ONLY);
  }

  else if (cmph_is_subs_feature_mode_1x_sxlte(asubs_id) &&
     cmss_ptr()->info.is_hybr_gw_operational &&
     domain == SYS_SRV_DOMAIN_PS_ONLY)
  {
    cm_ss = CM_SS_HYBR_2;
  }
  else if (cmph_is_msim())
  {
    /* multi-sim: asubs_id has one to one mapping to ss
      */
    cm_ss = cmph_map_subs_to_ss(asubs_id);
  }


  return cm_ss;
}

#if 0
/*===========================================================================

FUNCTION  cmph_determine_as_id_to_ll_per_domain

DESCRIPTION
 The function determines as_id in the command sent from CM.
 - MULTISIM: map asubs_id directly to as_id
 - SGLTE: if PS domain, return SYS_MODEM_AS_ID_1.
              Otherwise, return SYS_MODEM_AS_ID_2.

DEPENDENCIES
 none

RETURN VALUE
  sys_modem_as_id_e_type.

SIDE EFFECTS
  none

===========================================================================*/
sys_modem_as_id_e_type   cmph_determine_as_id_to_ll_per_domain (
    sys_modem_as_id_e_type  asubs_id,
    sys_srv_domain_e_type     domain
)
{
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_1;

  /* If neither sglte nor multi-sim, return default as_id */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK_MNAS))
  {
    return SYS_MODEM_AS_ID_1;
  }

  if (cmph_is_msim())
  {
    as_id = asubs_id;
  }

  else if (cmph_is_subs_feature_mode_sglte(asubs_id) &&
     domain == SYS_SRV_DOMAIN_CS_ONLY)
  {
    as_id = cmph_map_cm_ss_to_as_id (cmmsc_sglte_get_ss_for_domain(
                                         asubs_id,
                                         SD_SS_SRV_DOMAIN_PREF_CS_ONLY));
  }

  return as_id;
}
#endif

/*===========================================================================

FUNCTION  cmph_determine_as_id_to_ll_per_ss

DESCRIPTION
 The function determines as_id in the indication or command from CM to NAS.
 - MULTISIM: map asubs_id directly to as_id
 - SGLTE: Map cm_ss_main -> as_id 1, cm_ss_hybr2 -> as_id 2.

DEPENDENCIES
 none

RETURN VALUE
  sys_modem_as_id_e_type.

SIDE EFFECTS
  none

===========================================================================*/
sys_modem_as_id_e_type   cmph_determine_as_id_to_ll_per_ss (
    cm_ss_e_type                 cm_ss
)
{
  CM_ASSERT_ENUM_IS_INRANGE(cm_ss, CM_SS_MAX);

  if (cmph_is_ssim())
  {
    return SYS_MODEM_AS_ID_1;
  }

  if (!cmph_is_valid_cm_ss(cm_ss))
  {
    CM_ERR_2("Invalid cm_ss %d, default to %d", cm_ss, CM_SS_MAIN);
    cm_ss = CM_SS_MAIN;
  }

  if (cmph_is_msim())
  {
    return (cmph_map_cm_ss_to_subs(cm_ss));
  }

  return SYS_MODEM_AS_ID_1;
}

/*===========================================================================

FUNCTION  cmph_get_as_id_from_ll_ind

DESCRIPTION
 The function returns the asubs_id from lower layer indication/report for multi-sim
 configuration.  For non multi-sim, the function return the default asubs_id.

DEPENDENCIES
 none

RETURN VALUE
  cm_ss_e_type.

SIDE EFFECTS
  none

===========================================================================*/
sys_modem_as_id_e_type cmph_get_as_id_from_ll_ind (
    sys_modem_as_id_e_type  ll_asubs_id
)
{
  sys_modem_as_id_e_type  asubs_id;
  CM_MSG_HIGH_1("ll as_id=%d", ll_asubs_id);

  /*multi-sim
  */
  if (cmph_is_msim())
  {
    asubs_id = ll_asubs_id;
  }
  else
  {
    asubs_id = SYS_MODEM_AS_ID_1;
  }
  
  CM_ASSERT_ENUM_IS_INRANGE(asubs_id, SYS_MODEM_AS_ID_MAX);

  if (!(asubs_id >= SYS_MODEM_AS_ID_1 && asubs_id < SYS_MODEM_AS_ID_NO_CHANGE))
  {
    asubs_id = SYS_MODEM_AS_ID_1;
  }

  return asubs_id;
}


/*===========================================================================

FUNCTION  cmph_is_valid_asubs_id_from_client

DESCRIPTION
 The function validates the asubs_id from clients.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if asubs_id is valid.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_valid_asubs_id_from_client (
    sys_modem_as_id_e_type  asubs_id
)
{
  switch(asubs_id)
    {
    case SYS_MODEM_AS_ID_1:
    case SYS_MODEM_AS_ID_2:
    case SYS_MODEM_AS_ID_NO_CHANGE:
      return TRUE;

    default:
      return FALSE;
  }
}

/*===========================================================================

FUNCTION  cmph_is_valid_asubs_id_from_ll

DESCRIPTION
 The function validates the asubs_id from the lower layer.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if asubs_id is valid.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_valid_asubs_id_from_ll (
    sys_modem_as_id_e_type  asubs_id
)
{
  /* For multi-sim, lower layer needs to pass the valid as_id in rpt/ind.
  ** For non multi-sim, ignore as_id field.
  */
  if (cmph_is_msim())
  {
    switch(asubs_id)
    {
      case SYS_MODEM_AS_ID_1:
      case SYS_MODEM_AS_ID_2:
      #ifdef FEATURE_MMODE_TRIPLE_SIM
      case SYS_MODEM_AS_ID_3:
      #endif
        return TRUE;

      default:
        return FALSE;
    }
  }
  else
  {
     return TRUE;
  }

}


/*===========================================================================

FUNCTION  cmph_is_valid_cm_ss

DESCRIPTION
 The function checks if the cm_ss value is valid.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if cm_ss is valid.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_valid_cm_ss (
     cm_ss_e_type  cm_ss
)
{
  return (cm_ss >= CM_SS_MAIN && cm_ss < CM_SS_MAX);
}

/*===========================================================================

FUNCTION  cmph_is_dual_standby

DESCRIPTION
 The function checks if standby pref is dual standby vs. single standby.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if standby pref is dual standby.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_dual_standby (
  sys_modem_dual_standby_pref_e_type  standby_pref
)
{
  return (standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY ||
             standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY);
}


/*===========================================================================

FUNCTION  cmph_is_triple_standby

DESCRIPTION
 The function checks if standby pref is triple standby vs. single standby.

DEPENDENCIES
 none

RETURN VALUE
  TRUE if standby pref is dual standby.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_triple_standby (
  sys_modem_dual_standby_pref_e_type  standby_pref
)
{
  return (standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY ||
             standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY);
}

/*===========================================================================

FUNCTION  cmph_is_multimode_pref

DESCRIPTION
 Return if mode_pref is multimode preference.

DEPENDENCIES
 None

RETURN VALUE
  Boolean

SIDE EFFECTS
  None

===========================================================================*/
boolean  cmph_is_multimode_pref (
  cm_mode_pref_e_type  mode_pref
)
{
  if (cmcall_misc_is_mode_pref(mode_pref, CM_MODE_PREF_TDS_WCDMA_LTE) ||
     cmcall_misc_is_mode_pref(mode_pref, CM_MODE_PREF_CDMA_HDR_ONLY))
  {
    return TRUE;
  }

  return FALSE;
}

/*===========================================================================

FUNCTION  cmph_validate_multimode_pref

DESCRIPTION
 ERR FATAL if more than one active sub is multimode.

DEPENDENCIES
 None

RETURN VALUE
 None

SIDE EFFECTS
  None

===========================================================================*/
void  cmph_validate_multimode_pref (
  cm_mode_pref_e_type             main_mode_pref,
  
  cm_mode_pref_e_type             hybr_gw_mode_pref,
  
  cm_mode_pref_e_type             hybr_gw3_mode_pref
  
)
{
  /* No need to update for single sim opr mode */
  if (cmph_is_ssim())
  {
    return ;
  }

  /* If multimode-pref is being attempted on Hybr-2 ensure that multimode-pref is not
  ** present on both MAIN and HYBR-2
  */
  if (!cmph_is_sxlte())
  {
    if ( cmph_is_multimode_pref(main_mode_pref) &&
       cmss_ptr()->info.is_main_operational &&
       cmph_is_multimode_pref(hybr_gw_mode_pref) &&
       cmss_ptr()->info.is_hybr_gw_operational )
    {
      //CM_ERR_FATAL_2("main and hybr2 both have wcdma/tds/lte in mode pref main_mp=%d,hybr_gw_mp=%d",
      //                 main_mode_pref, hybr_gw_mode_pref);
    }
  }

}
/*===========================================================================

FUNCTION  cmph_is_sd_mode_pref_multimode_pref

DESCRIPTION
 Return if mode_pref is multimode preference.

DEPENDENCIES
 None

RETURN VALUE
  Boolean

SIDE EFFECTS
  None

===========================================================================*/
boolean  cmph_is_sd_mode_pref_multimode_pref (
  sd_ss_mode_pref_e_type  mode_pref
)
{
  if (SD_MODE_CONTAIN(mode_pref, SD_SS_MODE_PREF_TDS_WCDMA_LTE) ||
     SD_MODE_CONTAIN(mode_pref, SD_SS_MODE_PREF_CDMA_HDR))
  {
    return TRUE;
  }

  return FALSE;
}

/*===========================================================================

FUNCTION  cmph_msim_is_3gpp2_allowed

DESCRIPTION
 Return if 3GPP2 is allowed on the specified sub.

DEPENDENCIES
 None

RETURN VALUE
  Boolean

SIDE EFFECTS
  None

===========================================================================*/
boolean  cmph_msim_is_3gpp2_allowed (
  sys_modem_as_id_e_type  asubs_id
)
{
  #ifdef FEATURE_MMODE_DUAL_SIM
  if (cmph_is_ssim())
  {
    return TRUE;
  }

  if (asubs_id == SYS_MODEM_AS_ID_2 || asubs_id == SYS_MODEM_AS_ID_3)
  {
    return FALSE;
  }

  if (!cmph_is_subs_feature_mask_auto(asubs_id))
  {
    return FALSE;
  }
  #else
  SYS_ARG_NOT_USED(asubs_id);
  #endif

  return TRUE;
}

/*===========================================================================

FUNCTION  cmph_msim_remove_3gpp2_mode_pref

DESCRIPTION
 Remove 3GPP2 from the mode pref if 3GPP2 is not supported on the sub.

DEPENDENCIES
 None

RETURN VALUE
  Boolean

SIDE EFFECTS
  None

===========================================================================*/
void  cmph_msim_remove_3gpp2_mode_pref (
  cm_mode_pref_e_type     *mode_pref
)
{
  #if defined FEATURE_MMODE_DUAL_SIM && \
     (defined FEATURE_MMODE_CDMA_800 || defined FEATURE_MMODE_CDMA_1900)
  cm_mode_pref_e_type     old_mode_pref = CM_MODE_PREF_NONE;

  if (!mode_pref)
  {
    CM_ERR_0("NULL_PTR: mode_pref");
    return;
  }

  if (cmph_is_ssim())
  {
    return;
  }

  old_mode_pref = *mode_pref;

  /* Remove 3GPP2 if mode pref includes cdma/hdr */
  if (old_mode_pref != CM_MODE_PREF_EMERGENCY &&
     cmcall_misc_is_mode_pref(old_mode_pref, CM_MODE_PREF_CDMA_HDR_ONLY)
  )
  {
    *mode_pref = cm_remove_mode_pref_components(old_mode_pref, 3,
                   SD_SS_MODE_PREF_HDR,
                   SD_SS_MODE_PREF_CDMA,
                   SD_SS_MODE_PREF_AMPS);

    CM_MSG_HIGH_2("MSIM: mode_pref %d not expected!!! - force to %d",
                     old_mode_pref, *mode_pref);
  }

  #else
  SYS_ARG_NOT_USED(mode_pref);
  #endif
}

/*===========================================================================

FUNCTION  cmph_msim_modify_3gpp2_pref

DESCRIPTION
 Check if 3GPP pref is valid.  If any unsupported preference is detected, print error messages
 and correct the invalid preferences.
 This function is to avoid the following on subs other than sub1.
   1. 3GPP2 mode pref.
   2. Hybr pref on.

DEPENDENCIES
 None

RETURN VALUE
  Boolean

SIDE EFFECTS
  None

===========================================================================*/
void  cmph_msim_modify_3gpp2_pref (
  sys_modem_as_id_e_type   asubs_id,
  cm_mode_pref_e_type     *mode_pref,
  cm_hybr_pref_e_type     *hybr_pref
)
{
  #if (defined FEATURE_MMODE_CDMA_800 || defined FEATURE_MMODE_CDMA_1900)

  cm_mode_pref_e_type     old_mode_pref = CM_MODE_PREF_NONE;
  cm_hybr_pref_e_type     old_hybr_pref = CM_HYBR_PREF_NONE;

  if (!mode_pref || !hybr_pref)
  {
    CM_ERR_2("NULL_PTR: mode_pref %d, hybr_pref %d", mode_pref, hybr_pref);
    return;
  }

  if (cmph_is_ssim())
  {
    return;
  }

  if (cmph_msim_is_3gpp2_allowed(asubs_id))
  {
    return;
  }

  /* For now, not do anything for sglte sub */
  if (cmph_is_subs_feature_mode_sglte(asubs_id))
  {
    return;
  }

  old_mode_pref = *mode_pref;
  old_hybr_pref = *hybr_pref;

  /* Remove 3GPP2 if mode pref includes cdma/hdr */
  if (old_mode_pref != CM_MODE_PREF_EMERGENCY &&
     cmcall_misc_is_mode_pref(old_mode_pref, CM_MODE_PREF_CDMA_HDR_ONLY)
  )
  {
    *mode_pref = cm_remove_mode_pref_components(old_mode_pref, 3,
                   SD_SS_MODE_PREF_HDR,
                   SD_SS_MODE_PREF_CDMA,
                   SD_SS_MODE_PREF_AMPS);

    CM_MSG_HIGH_3("MSIM: mode_pref %d on asubs_id %d is not expected!!! - force to %d",
                     old_mode_pref, asubs_id, *mode_pref);
  }

  /* Force hybr pref off if it is on */
  if (old_hybr_pref == CM_HYBR_PREF_CDMA__HDR ||
     old_hybr_pref == CM_HYBR_PREF_CDMA__LTE__HDR
  )
  {
    *hybr_pref = CM_HYBR_PREF_OFF;

    CM_MSG_HIGH_3("MSIM: hybr_pref %d on asubs_id %d is not expected!!! - force to %d",
                     old_hybr_pref, asubs_id, *hybr_pref);
  }

  #else
  *hybr_pref = CM_HYBR_PREF_OFF;

  SYS_ARG_NOT_USED(asubs_id);
  SYS_ARG_NOT_USED(mode_pref);
  SYS_ARG_NOT_USED(hybr_pref);
  #endif
}

/*==========================================================================

FUNCTION cmph_get_received_card_init_completed_evt

DESCRIPTION
  The subcription handling in CM start listening the MMGSDI events only
  after receiving MMGSDI_CARD_INIT_COMPLETED_EVT from MMGSDI.
  As CM receives MMGSDI_CARD_INIT_COMPLETED_EVT it
  update the static variable cmph_received_card_init_completed_evt
  to TRUE. On some events (like refresh start) CM need to update the
  static variable cmph_received_card_init_completed_evt  to FALSE. By
  this function we can know what is the current status of
  cmph_received_card_init_completed_evt.

RETURN VALUE
  TRUE: if the present status of card intilization completed is TRUE
  FALSE: if the present status of card intilization completed is FALSE

DEPENDENCIES
  None

==========================================================================*/
boolean  cmph_get_received_card_init_completed_evt( void )
{
  return cmph_received_card_init_completed_evt;
} /* cmph_get_received_card_init_completed_evt() */


/*==========================================================================

FUNCTION cmph_is_subsc_cmd_proccessing_in_progress

DESCRIPTION
  Indicates if there is ongoing GWL subscription command processing in progress

RETURN VALUE
  TRUE: if there is ongoing GWL subscription command processing in progress
  FALSE: if there is no ongoing GWL subscription command processing

DEPENDENCIES
  None

==========================================================================*/
boolean  cmph_is_subsc_cmd_proccessing_in_progress( void )
{
  return cmph_subsc_cmd_proccessing_in_progress;
} /* cmph_is_subsc_cmd_proccessing_in_progress( */

/*==========================================================================

FUNCTION cmph_set_received_card_init_completed_evt

DESCRIPTION
  The subcription handling in CM start listening the MMGSDI events only
  after receiving MMGSDI_CARD_INIT_COMPLETED_EVT from MMGSDI.
  As CM receives MMGSDI_CARD_INIT_COMPLETED_EVT it
  update the static variable cmph_received_card_init_completed_evt
  to TRUE. On some events (like refresh start) CM need to update the
  static variable cmph_received_card_init_completed_evt  to FALSE.
  This function set the value of cmph_received_card_init_completed_evt
  as per the parameter passed.

RETURN VALUE
  NONE

DEPENDENCIES
  None

==========================================================================*/
void  cmph_set_received_card_init_completed_evt(

  boolean val
    /* this value is used to update the currect status of
    ** card initilization completed event
    */

)
{
  cmph_received_card_init_completed_evt = val;
  CM_MSG_HIGH_1("cmph_received_card_init_completed_evt %d",
               val);
} /* cmph_set_received_card_init_completed_evt() */

/*==========================================================================

FUNCTION cmph_get_gw_subs_from_card_sent

DESCRIPTION
  If GW subscription available is sent to CM module from subscription module
  cmph_gw_subs_from_card_sent is set to TRUE. If not,
  cmph_gw_subs_from_card_sent is set to FALSE. This function returns
  the value of cmph_gw_subs_from_card_sent.

RETURN VALUE
  TRUE: if GW subscription sent from card.
  FALSE: if GW subscription is not sent from card.

DEPENDENCIES
  None

==========================================================================*/
boolean  cmph_get_gw_subs_from_card_sent( void )
{
  return cmph_gw_subs_from_card_sent;
} /* cmph_get_gw_subs_from_card_sent() */

/*==========================================================================

FUNCTION cmph_get_hybr_gw_subs_from_card_sent

DESCRIPTION
  If GW subscription available is sent to CM module from subscription module
  cmph_gw_subs_from_card_sent is set to TRUE. If not,
  cmph_gw_subs_from_card_sent is set to FALSE. This function returns
  the value of cmph_gw_subs_from_card_sent.

RETURN VALUE
  TRUE: if GW subscription sent from card.
  FALSE: if GW subscription is not sent from card.

DEPENDENCIES
  None

==========================================================================*/
boolean  cmph_get_hybr_gw_subs_from_card_sent( void )
{
  return cmph_hybr_gw_subs_from_card_sent;
} /* cmph_get_hybr_gw_subs_from_card_sent() */

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*==========================================================================

FUNCTION cmph_get_hybr_3_gw_subs_from_card_sent

DESCRIPTION
  If GW subscription available is sent to CM module from subscription module
  cmph_gw_subs_from_card_sent is set to TRUE. If not,
  cmph_gw_subs_from_card_sent is set to FALSE. This function returns
  the value of cmph_gw_subs_from_card_sent.

RETURN VALUE
  TRUE: if GW subscription sent from card.
  FALSE: if GW subscription is not sent from card.

DEPENDENCIES
  None

==========================================================================*/
boolean  cmph_get_hybr_3_gw_subs_from_card_sent( void )
{
  return cmph_hybr_3_gw_subs_from_card_sent;
} /* cmph_get_hybr_gw_subs_from_card_sent() */
#endif /* FEATURE_MMODE_DUAL_SIM */


/*==========================================================================

FUNCTION cmph_set_gw_subs_from_card_sent

DESCRIPTION
  If GW subscription available is sent to CM module from subscription module
  cmph_gw_subs_from_card_sent is set to TRUE. If not,
  cmph_gw_subs_from_card_sent is set to FALSE.
  This function set the value of cmph_gw_subs_from_card_sent
  as per the parameter passed.

RETURN VALUE
  NONE

DEPENDENCIES
  None

===========================================================================*/
void  cmph_set_gw_subs_from_card_sent(

  boolean val
    /* Used to update the value of cmph_gw_subs_from_card_sent
    */
)
{
  cmph_gw_subs_from_card_sent = val;
  CM_MSG_HIGH_1("cmph_gw_subs_from_card_sent %d",
               val);
} /* cmph_set_gw_subs_from_card_sent() */

/*==========================================================================

FUNCTION cmph_set_hybr_gw_subs_from_card_sent

DESCRIPTION
  If GW subscription available is sent to CM module from subscription module
  cmph_gw_subs_from_card_sent is set to TRUE. If not,
  cmph_gw_subs_from_card_sent is set to FALSE.
  This function set the value of cmph_gw_subs_from_card_sent
  as per the parameter passed.

RETURN VALUE
  NONE

DEPENDENCIES
  None

===========================================================================*/
void  cmph_set_hybr_gw_subs_from_card_sent(

  boolean val
    /* Used to update the value of cmph_gw_subs_from_card_sent
    */
)
{
  cmph_hybr_gw_subs_from_card_sent = val;
  CM_MSG_HIGH_1("cmph_hybr_gw_subs_from_card_sent %d",
               val);
} /* cmph_set_hybr_gw_subs_from_card_sent() */

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*==========================================================================

FUNCTION cmph_set_hybr_3_gw_subs_from_card_sent

DESCRIPTION
  If GW subscription available is sent to CM module from subscription module
  cmph_gw_subs_from_card_sent is set to TRUE. If not,
  cmph_gw_subs_from_card_sent is set to FALSE.
  This function set the value of cmph_gw_subs_from_card_sent
  as per the parameter passed.

RETURN VALUE
  NONE

DEPENDENCIES
  None

===========================================================================*/
void  cmph_set_hybr_3_gw_subs_from_card_sent(

  boolean val
    /* Used to update the value of cmph_gw_subs_from_card_sent
    */
)
{
  cmph_hybr_3_gw_subs_from_card_sent = val;
  CM_MSG_HIGH_1("cmph_hybr_3_gw_subs_from_card_sent %d",
               val);
} /* cmph_set_hybr_gw_subs_from_card_sent() */
#endif /* FEATURE_MMODE_DUAL_SIM */


/*==========================================================================

FUNCTION cmph_get_cdma_subs_from_card_sent

DESCRIPTION
  If CDMA subscription available is sent to CM module from subscription
  module cmph_cdma_subs_from_card_sent is set to TRUE. If not,
  cmph_cdma_subs_from_card_sent is set to FALSE. This function returns
  the value of cmph_cdma_subs_from_card_sent.

RETURN VALUE
  TRUE: if CDMA subscription sent from card.
  FALSE: if CDMA subscription is not sent from card.

DEPENDENCIES
  None

==========================================================================*/
boolean  cmph_get_cdma_subs_from_card_sent( void )
{
  return cmph_cdma_subs_from_card_sent;
}  /* cmph_get_cdma_subs_from_card_sent() */

/*==========================================================================

FUNCTION cmph_set_cdma_subs_from_card_sent

DESCRIPTION
  If CDMA subscription available is sent to CM module from subscription
  module cmph_gw_subs_from_card_sent is set to TRUE. If not,
  cmph_gw_subs_from_card_sent is set to FALSE.
  This function set the value of cmph_cdma_subs_from_card_sent
  as per the parameter passed.

RETURN VALUE
  NONE

DEPENDENCIES
  None

==========================================================================*/
void  cmph_set_cdma_subs_from_card_sent(

   boolean val
    /* Used to update the value of cmph_cdma_subs_from_card_sent
    */

)
{
  cmph_cdma_subs_from_card_sent = val;
  CM_MSG_HIGH_1("cmph_cdma_subs_from_card_sent %d",
               val);
} /* cmph_set_cdma_subs_from_card_sent() */



/*===========================================================================

FUNCTION cmph_misc_intersect_mode_pref

DESCRIPTION
  Computes the intersection of the mode preferences

DEPENDENCIES


RETURN VALUE
Returns the mode preference

SIDE EFFECTS
  none

===========================================================================*/

cm_mode_pref_e_type cmph_misc_intersect_mode_pref(

  cm_srv_type_e_type srv_type,
    /* The srv type requested
    */

  cm_mode_pref_e_type mode_pref
    /* The current mode preference
    */
)
{
  cm_mode_pref_e_type requested_mode_pref = CM_MODE_PREF_NONE;

  switch( srv_type )
  {
    case CM_SRV_TYPE_AMPS:

      requested_mode_pref = CM_MODE_PREF_AMPS_ONLY;
      break;

    case CM_SRV_TYPE_HDR:
    case CM_SRV_TYPE_HDR_MORE_PREF:

      requested_mode_pref = CM_MODE_PREF_HDR_ONLY;
      break;

    case CM_SRV_TYPE_CDMA_SPECIFIC:
    case CM_SRV_TYPE_CDMA_AUTOMATIC:

      requested_mode_pref = CM_MODE_PREF_CDMA_ONLY;
      break;

    case CM_SRV_TYPE_CDMA_HDR:

      requested_mode_pref = CM_MODE_PREF_CDMA_HDR_ONLY;
      break;


    case CM_SRV_TYPE_GSM_WCDMA:

      requested_mode_pref = CM_MODE_PREF_GSM_WCDMA_ONLY;
      break;

    case CM_SRV_TYPE_WCDMA:

      requested_mode_pref = CM_MODE_PREF_WCDMA_ONLY;
      break;

    case CM_SRV_TYPE_GSM:

      requested_mode_pref = CM_MODE_PREF_GSM_ONLY;
      break;

    case CM_SRV_TYPE_LTE:

      requested_mode_pref = CM_MODE_PREF_LTE_ONLY;
      break;

    case CM_SRV_TYPE_GSM_WCDMA_LTE:

      requested_mode_pref = CM_MODE_PREF_GWL;
      break;

    case CM_SRV_TYPE_TDS:

      requested_mode_pref = CM_MODE_PREF_TDS_ONLY;
      break;

    case CM_SRV_TYPE_TDS_GSM:

      requested_mode_pref = CM_MODE_PREF_TDS_GSM;
      break;

    case CM_SRV_TYPE_TDS_GSM_LTE:

      requested_mode_pref = CM_MODE_PREF_TDS_GSM_LTE;
      break;

    case CM_SRV_TYPE_TDS_LTE:

      requested_mode_pref = CM_MODE_PREF_TDS_LTE;
      break;

    case CM_SRV_TYPE_TDS_GSM_WCDMA_LTE:

      requested_mode_pref = CM_MODE_PREF_TDS_GSM_WCDMA_LTE;
      break;

    case CM_SRV_TYPE_TDS_GSM_WCDMA:

      requested_mode_pref = CM_MODE_PREF_TDS_GSM_WCDMA;
      break;

      /* This should be never occur
      */
    default:

      /*
      ** 527: Unreachable
      ** This is because CM_ERR() evaluates to error fatal
      ** (i.e exit program)
      ** But for different feature set it may not to, so we want to
      ** supress the warning here
      */
      /*lint -save -e527 */
      requested_mode_pref = CM_MODE_PREF_NONE;
      /*lint -restore */
      break;
  }


  /* Find the intersection and if there is no intersection then
  ** return the requested preference
  */

  if( requested_mode_pref == CM_MODE_PREF_NONE )
  {
    return ( requested_mode_pref );
  }

  mode_pref = cmcall_misc_get_common_mode_pref(
                                         requested_mode_pref, 1, mode_pref );


  return ( mode_pref );

} /* cmph_misc_intersect_mode_pref */


/*===========================================================================

FUNCTION cmph_is_gw_subsc_avail

DESCRIPTION
  This function returns whether the corresponding sub have valid GW subscription.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  boolean

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_gw_subsc_avail(sys_modem_as_id_e_type as_id)
{
  boolean ret = FALSE;
  cmph_s_type  *ph_ptr = cmph_ptr();
  switch(as_id)
  {
    case SYS_MODEM_AS_ID_1:
      ret = ph_ptr->is_gwl_subscription_available;
      break;
    case SYS_MODEM_AS_ID_2:
      if (cmph_is_msim())
      {
        /* SXLTE+G case*/
        if (cmph_is_sxlte())
        {
          ret = ph_ptr->is_hybr_gw3_subscription_available;
        }
        /* DSDS case*/
        else
        {
          ret = ph_ptr->is_hybr_gw_subscription_available;
        }
      }
      break;
    case SYS_MODEM_AS_ID_3:
#if defined(FEATURE_MMODE_TRIPLE_SIM)
      if(cmph_is_tsts())
      {
        ret = ph_ptr->is_hybr_gw3_subscription_available;
      }
#endif
      break;
    default:
      CM_MSG_HIGH_1("Invalid asid %d",as_id);
      break;
  }
  return ret;
} /* cmph_is_gw_subsc_avail() */

/*===========================================================================

FUNCTION cmph_is_wait_on_ims_deregister

DESCRIPTION
  If srv domain pref is set to PS detach, sends service domain preference
  change information to IP apps registered to receive that information.
  wait until IPAPP is deregistered before continuing with
  operation mode change processing

DEPENDENCIES
  none

RETURN VALUE
  NV enum

SIDE EFFECTS
  none

===========================================================================*/
static boolean  cmph_is_wait_on_ims_deregister
(
  cm_ph_cmd_s_type      *ph_cmd_ptr
    /* Point at phone command component */

)
{
  #if defined(FEATURE_IP_CALL)

  cmph_s_type              *ph_ptr = cmph_ptr();
    /* Ph ptr */

  cm_ph_cmd_info_s_type    *cmd_info_ptr    = NULL;
    /* Point at command information component */
  cm_srv_domain_pref_e_type   srv_domain_pref;

  cm_ss_e_type              ss = CM_SS_MAIN;
  sys_modem_as_id_e_type    asubs_id = SYS_MODEM_AS_ID_1;
  boolean is_ps_detach_required = FALSE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if(cmph_ptr()->oprt_mode != SYS_OPRT_MODE_ONLINE)
  {
    CM_MSG_HIGH_0("No need to inform PS_Detach to IPAPPS as oprt mode is not ONLINE");
    return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */  
  if (cmph_is_msim())
  {
    ss = cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);
    asubs_id = cmd_info_ptr->cmd_subs;
  }
    
  if (cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_NO_CHANGE)
  {
    srv_domain_pref = CMPH_SS_SRV_DOMAIN_PREF( asubs_id, ph_ptr );
  }
  else
  {
    srv_domain_pref = cmd_info_ptr->srv_domain_pref;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch(ph_cmd_ptr->cmd)
  {
    case CM_PH_CMD_SYS_SEL_PREF:


   if(CM_SRV_DOMAIN_PREF_PS_DETACH != srv_domain_pref)
   {
     is_ps_detach_required = cmph_cmd_evaluate_is_ps_detach_required_per_sub(asubs_id,
                                                                             cmd_info_ptr->mode_pref,
                                                                             cmd_info_ptr->band_pref,
                                                                             cmd_info_ptr->lte_band_pref,
                                                                             cmd_info_ptr->tds_band_pref);

     if(is_ps_detach_required == TRUE)
     {
       srv_domain_pref = CM_PS_DETACH_BY_MMODE_TRIGGER;
     }

   }

   /* SIP dereg is not needed 
   ** if SUB is GSM only , else it causes SIP dereg on the other sub
   */
   /* SIP dereg is not needed when Volte call is active ,
   **   else Volte call will be dropped .
   */
   if (( srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_DETACH || 
        srv_domain_pref == CM_PS_DETACH_BY_MMODE_TRIGGER)
        &&
       (CM_CALL_ID_INVALID != cmcall_is_there_volte_call_obj(CM_CALL_TYPE_VOICE_MASK | CM_CALL_TYPE_VT_MASK | CM_CALL_TYPE_EMERG_MASK ) ||
        !cmph_is_lte_capable_on_sub(cmd_info_ptr->cmd_subs)))
   {  
     return FALSE;
   }

   /* Check if Subscription is available before 
   ** sending service domain to ipapps 
   */
   if (cmph_is_gw_subsc_avail(asubs_id) == TRUE)
   {
     /* If there are ipapps that have to perform
     ** deregistration, wait for them to complete
     */
     cmipapp_send_srv_domain (srv_domain_pref, asubs_id);
  
      /* Check if this srv domain pref requires a wait for cnf from app
      */
  
      if (cmipapp_is_wait_on_srv_domain_cnf (srv_domain_pref))
      {
        cm_reply_set( &ph_ptr->reply,
                       (cm_cmd_type*)ph_cmd_ptr,               /* command waiting on reply */
                       CM_IP_APP_ALLAPPS_SRV_DOM_CNF, /* wait for IPAPP rpt */
                       CMPH_MAX_IPAPP_DEREG_TIME ); /* wait for this long */
        return TRUE;
      }
     }
     break;

    case CM_PH_CMD_DUAL_STANDBY_PREF:
      {
        sys_modem_as_id_e_type                curr_data_subs;
        curr_data_subs = (ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY || 
                          ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY || 
                          (cmpmprx_get_num_of_active_data()== 2)) ? 
                          ph_ptr->default_data_subs: (ACTIVE_MASK_TO_AS_ID(ph_ptr->active_subs));

      /* Send srv domain DDS_SWITCH to IMS when:
      ** -DDS is switching
      ** -Current DDS has 3GPP subscription and LTE capable
      ** -Current DDS still has PS in srv domain
        */
      if(cmph_is_gw_subsc_avail(curr_data_subs) == TRUE &&
         cmd_info_ptr->default_data_subs != SYS_MODEM_AS_ID_NO_CHANGE &&
         cmd_info_ptr->default_data_subs != curr_data_subs &&
         cmph_is_lte_capable_on_sub(curr_data_subs) &&
        (CMPH_SS_SRV_DOMAIN_PREF(curr_data_subs, ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS ||
         CMPH_SS_SRV_DOMAIN_PREF(curr_data_subs, ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY))
        {
              cmipapp_send_srv_domain (CM_PS_DETACH_BY_MMODE_TRIGGER, curr_data_subs);
              if (cmipapp_is_wait_on_srv_domain_cnf (CM_PS_DETACH_BY_MMODE_TRIGGER))
              {
                cm_reply_set( &ph_ptr->reply,
                               (cm_cmd_type*)ph_cmd_ptr,               /* command waiting on reply */
                               CM_IP_APP_ALLAPPS_SRV_DOM_CNF, /* wait for IPAPP rpt */
                               CMPH_MAX_IPAPP_DEREG_TIME ); /* wait for this long */
                return TRUE;
              }
            }
          }
      break;
    

    default:
      break;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #else
  SYS_ARG_NOT_USED (ph_cmd_ptr);
  #endif
  SYS_ARG_NOT_CONST(ph_cmd_ptr);

  return FALSE;

} /* cmph_is_wait_on_ims_deregister */



/*===========================================================================

FUNCTION cmph_is_wait_on_oprt_mode_data_end

DESCRIPTION
  sends operation mode change information to DS
  If mode change is to LPM or poweroff, wait until DS tear down the data traffic
  before continuing with operation mode change processing

DEPENDENCIES
  none

RETURN VALUE
  TRUE - hold command until get confirmation from DS or time out
  FALSE - continue Proceed the command

SIDE EFFECTS
  none

===========================================================================*/

static boolean  cmph_is_wait_on_oprt_mode_data_end
(
  cm_ph_cmd_s_type      *ph_cmd_ptr
     /* Point at phone command component */
)
{
  cmph_s_type              *ph_ptr = cmph_ptr();
    /* Ph ptr */

  cm_ph_cmd_info_s_type    *cmd_info_ptr    = NULL;
    /* Point at command information component */

  cm_orig_q_s_type* q_ptr = NULL;
    /* Store power off LPM notification callback locally */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /*we only need tell DS tear down traffic when doing PWROFF or LPM*/
  if((cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_PWROFF) &&
    (cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_LPM) &&
     (ph_ptr->oprt_mode == SYS_OPRT_MODE_ONLINE)
    )
  {
    return FALSE;
  }


  q_ptr = cmtask_orig_para_search_act_type_act_priority(CM_SS_MAIN,
                                                         CM_ACT_TYPE_DATA_CALL,
                                                         CM_ACT_PRIORITY_END);

  if(q_ptr == NULL)
  {
    q_ptr = cmtask_orig_para_search_act_type_act_priority(CM_SS_MAIN,
                                                           CM_ACT_TYPE_DATA_CALL,
                                                           CM_ACT_PRIORITY_BELOW_PH);
  }

  /* If already waiting for response don't wait again. Wait if there is a call just ended in last 4 seconds and 1xcp is not in idle state*/
  if( q_ptr != NULL
      && q_ptr->orig->act_update_reas == CM_ACT_UPDATE_REAS_ACT_END
      && ph_ptr->is_wait_on_data_end != TRUE
      #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
      && (mcc_check_idle_state_ovhd_info()== FALSE)
      #endif
    )
  {
    int32 time = (int32)(q_ptr->orig->orig_mode_uptime - time_get_uptime_secs());

    if( (sd_misc_get_common_mode_pref(
           cmph_map_cm_mode_pref_to_sd_mode_pref(q_ptr->orig->orig_mode_pref),
                                  SD_SS_MODE_PREF_CDMA) != SD_SS_MODE_PREF_NONE)
          && time > 0
          && ( (&ph_ptr->reply)->cm_mc_rpt != CM_SRV_SYS_INFO_F))
    {
        cm_reply_set( &ph_ptr->reply,
                      (cm_cmd_type*)ph_cmd_ptr,               /* command waiting on reply */
                      CM_SRV_SYS_INFO_F, /* wait for ds traffic tear down rpt */
                      (dword)time + 1 ); /* wait for this long */
        ph_ptr->is_wait_on_data_end = TRUE;
        CM_MSG_HIGH_0("Data call just ended. Waiting for IDLE acquisition on 1xCP");
        return TRUE;
    }
  }

  return FALSE;
}


/*===========================================================================

FUNCTION cm_map_subs_to_sd_ss

DESCRIPTION
  Maps the active subscription id to SD SS

DEPENDENCIES
  None

RETURN VALUE
  SS to type sd_ss_e_type

SIDE EFFECTS
  None.

===========================================================================*/

sd_ss_e_type cmph_map_subs_to_sd_ss(

  sys_modem_as_id_e_type       asubs_id
    /* Call Type */
)
{
  cm_ss_e_type  ss;

  ss = cmph_map_subs_to_ss(asubs_id);

  if( ss == CM_SS_NONE )
  {
    return SD_SS_MAX;
  }
  else
  {
    return cmph_map_cm_ss_type_to_sd_ss_type(ss);
  }
}



/*===========================================================================

FUNCTION cmph_is_abort_wait

DESCRIPTION


DEPENDENCIES
  none

RETURN VALUE
  TRUE - hold command until get confirmation from DS or time out
  FALSE - continue Proceed the command

SIDE EFFECTS
  none

===========================================================================*/
static boolean                    cmph_is_abort_wait
(
       cm_ph_cmd_s_type           *ph_cmd_ptr,
          /* Point at phone command component */

       sys_stop_mode_reason_e_type reason,

       sys_modem_as_id_e_type      abort_as_id

)
{
  boolean          is_wait_reply = FALSE;

  #if (defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)||defined(FEATURE_TDSCDMA))
  cmph_s_type      *ph_ptr       = cmph_ptr();
  sd_ss_e_type      sd_ss        = SD_SS_MAIN;

  CM_MSG_HIGH_2("Enter cmph_is_abort_wait : ph_ptr->abort_ss_bitmask=%d,abort_as_id=%d",\
                                         ph_ptr->abort_ss_bitmask,abort_as_id);
  if(!( ph_ptr->abort_ss_bitmask & (BM(abort_as_id))))
  {
    sd_ss = cmph_map_subs_to_sd_ss(abort_as_id);
    if(cmregprx_get_stack_info_ptr(sd_ss)->state == CMREGPRX_STATE_ACTIVE)
  {
      cm_reply_set( &ph_ptr->reply,
                    (cm_cmd_type*)ph_cmd_ptr, /* command waiting on reply */
                    CM_ABORT_CC_CONF,               /* wait for ABORT CNF */
                    CMPH_CMREG_ABORT_CC_CNF_TIME ); /* wait for this long */

      is_wait_reply = TRUE;

      cmregprx_send_abort_cc_req( reason, abort_as_id );

      /* set the bitmask of abort_as_id so that next time it wont be sent */
       ph_ptr->abort_ss_bitmask |= BM(abort_as_id);
    }
    CM_MSG_HIGH_2("New bitmask : ph_ptr->abort_ss_bitmask=%d, sd_ss=%d",\
                                         ph_ptr->abort_ss_bitmask,sd_ss);
  }
  #endif

  return is_wait_reply;
}
/*===========================================================================

FUNCTION cmph_is_wait_on_oprt_mode

DESCRIPTION
  sends operation mode change information to IP apps registered to receive
  that information.
  If mode change is to LPM or poweroff, wait until IPAPP is deregistered
  before continuing with operation mode change processing

DEPENDENCIES
  none

RETURN VALUE
  NV enum

SIDE EFFECTS
  none

===========================================================================*/
static boolean  cmph_is_wait_on_oprt_mode
(
  cm_ph_cmd_s_type      *ph_cmd_ptr
     /* Point at phone command component */

)
/*lint -e{818} cmd_ptr can't be const */
{
  cmph_s_type              *ph_ptr = cmph_ptr();
    /* Ph ptr */

  cm_ph_cmd_info_s_type    *cmd_info_ptr    = NULL;
    /* Point at command information component */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*reply is being set inside the function*/

  if(cmph_is_wait_on_oprt_mode_data_end(ph_cmd_ptr))
  {
    return TRUE;
  }

  /* if LPM, send abort req and wait for abort cnf reply for 5s */
  #if (defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)||defined(FEATURE_TDSCDMA))
  if( ph_ptr->oprt_mode         == SYS_OPRT_MODE_ONLINE &&
      cmd_info_ptr->oprt_mode   != SYS_OPRT_MODE_ONLINE
    )
  {
    sys_stop_mode_reason_e_type reason = SYS_STOP_MODE_REASON_NONE;
    sys_modem_as_id_e_type         as_id = SYS_MODEM_AS_ID_1;
    boolean                        is_abort_wait = FALSE;

    switch(cmd_info_ptr->oprt_mode)
    {
       case SYS_OPRT_MODE_LPM:
         reason = SYS_STOP_MODE_REASON_LPM;
         break;

       case SYS_OPRT_MODE_PWROFF:
         reason = SYS_STOP_MODE_REASON_POWER_OFF;
         break;

       case SYS_OPRT_MODE_OFFLINE:
         reason = SYS_STOP_MODE_REASON_OFFLINE;
         break;

       case SYS_OPRT_MODE_FTM:
         reason = SYS_STOP_MODE_REASON_MODE_CHANGE_FTM;
         break;

       default:
         reason = SYS_STOP_MODE_REASON_MODE_CHANGE;
         break;
    }
    /* Abort indication will be sent to the each active sub */
     for(as_id = SYS_MODEM_AS_ID_1; as_id<CMPH_GET_MAX_ASIDS(cmpmprx_get_device_mode()); as_id++)
     {
         is_abort_wait = cmph_is_abort_wait(ph_cmd_ptr,reason,as_id);
         if(is_abort_wait == TRUE)
         {
           break;
         }
     }

     return is_abort_wait;

  }
  #endif
  return FALSE;

} /* cmph_is_wait_on_oprt_mode */

/*===========================================================================

FUNCTION cmds_is_wait_on_oprt_mode

DESCRIPTION
  sends operation mode change information to DS
  If mode change is to LPM or poweroff, wait until DS tear down the data traffic
  before continuing with operation mode change processing

DEPENDENCIES
  none

RETURN VALUE
  TRUE - hold command until get confirmation from DS or time out
  FALSE - continue Proceed the command

SIDE EFFECTS
  none

===========================================================================*/

EXTERN boolean  cmds_is_wait_on_oprt_mode
(
  sys_oprt_mode_e_type      oprt_mode
    /* New operating mode */
)
{
  cmph_s_type              *ph_ptr = cmph_ptr();
    /* Ph ptr */


  cm_ds_sys_pwroff_lpm_notif_f_type *cb_func_ptr = NULL;
    /* Store power off LPM notification callback locally */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /*we only need tell DS tear down traffic when doing PWROFF or LPM*/
  if( oprt_mode != SYS_OPRT_MODE_PWROFF &&
      oprt_mode != SYS_OPRT_MODE_LPM )
  {
    return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /*notify DS about the oprt mode change*/
  if( !ph_ptr->is_ds_cmd_ntfy_sent )
  {
    cb_func_ptr = cm_ds_sys_pwroff_lpm_notif_cb_func_ptr;
    if(cb_func_ptr == NULL)
    {
      CM_MSG_HIGH_0("CLNUP: DS callback not registered");
      return FALSE;
    }

    if(cb_func_ptr())
    {
       CM_MSG_HIGH_0("CLNUP: DS oprt mode change sent");
       return TRUE;
    }
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  return FALSE;
}

/*===========================================================================

FUNCTION cmph_compute_subs_bitmask

DESCRIPTION
  Computation for the iactive subs_id which is used to notify DS/IMS in case of
  subscription loss during Multisim operation.

DEPENDENCIES
  none

RETURN VALUE
  uint8

SIDE EFFECTS
  none

===========================================================================*/
uint8 cmph_compute_subs_bitmask(

   cm_subscription_status_e_type  cdma_status,

   cm_subscription_status_e_type  gwl_status,

   cm_subscription_status_e_type  gw2_status,

   cm_subscription_status_e_type  gw3_status
)
  {
  uint8  subs_id_bm     = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;

  if ( gwl_status == CM_SUBSCRIPTION_STATUS_CHANGE
       || cdma_status == CM_SUBSCRIPTION_STATUS_CHANGE)
  {
    subs_id_bm |=  SYS_MODEM_AS_ID_1_MASK ;
  }

  if ( gw2_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    subs_id_bm |=  SYS_MODEM_AS_ID_2_MASK ;
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if ( gw3_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    if( cmph_is_sxlte() &&
        cmph_is_feature_mode_msim())
    {
      if(cmph_ptr()->hybr_3_stack_info.asubs_id == SYS_MODEM_AS_ID_1)
      {
        subs_id_bm |= SYS_MODEM_AS_ID_1_MASK ;
      }
      else
      {
        subs_id_bm |= SYS_MODEM_AS_ID_2_MASK ;
      }
    }
    #ifdef FEATURE_MMODE_TRIPLE_SIM
    else
    {
      subs_id_bm |=  SYS_MODEM_AS_ID_3_MASK ;
    }
    #endif
  }
  #endif

  return subs_id_bm;
}

/*===========================================================================

FUNCTION cmds_is_wait_on_subsc_cmd

DESCRIPTION
  sends subsc change command notification to DS
  wait until DS tear down the data traffic before continuing with operation

DEPENDENCIES
  none

RETURN VALUE
  TRUE - hold command until get confirmation from DS or time out
  FALSE - continue Proceed the command

SIDE EFFECTS
  none

===========================================================================*/

EXTERN boolean  cmds_is_wait_on_subsc_cmd
(
  uint8      inactive_subs_id_bm
  /* Bitmask of subs_ids impacted */
)
{

  CM_MSG_HIGH_1("CLNUP: subs_id impacted: %d",inactive_subs_id_bm);

  if(!inactive_subs_id_bm)
        {
    return FALSE;
        }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  if(cm_ds_subsc_cmd_notif_cb_ext_func_ptr != NULL)
  {
    if( cm_ds_subsc_cmd_notif_cb_ext_func_ptr(inactive_subs_id_bm,cmclnup_get_sub_reason_mask() ))
    {
      CM_MSG_HIGH_1("CLNUP: DS subsc cmd ntfy sent with BM %d",inactive_subs_id_bm);
      return TRUE;
    }
  }


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  else
  {
    CM_MSG_HIGH_0("CLNUP: DS callback not registered");
           return FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  return FALSE;
}

/*===========================================================================

FUNCTION cmph_map_mode_pref_cm2nv

DESCRIPTION
  Translates CM enum to NV enum for mode preference

DEPENDENCIES
  none

RETURN VALUE
  NV enum

SIDE EFFECTS
  none

===========================================================================*/
nv_mode_enum_type cmph_map_mode_pref_cm2nv( cm_mode_pref_e_type  cm_mode )
{

  switch (cm_mode)
  {
    case CM_MODE_PREF_DIGITAL_ONLY:
      return NV_MODE_DIGITAL_ONLY;

    case CM_MODE_PREF_AMPS_ONLY:
      return NV_MODE_ANALOG_ONLY;

    case CM_MODE_PREF_AUTOMATIC:
      return NV_MODE_AUTOMATIC;

    case CM_MODE_PREF_EMERGENCY:
      return NV_MODE_E911;

    case CM_MODE_PREF_CDMA_ONLY:
      return NV_MODE_CDMA_ONLY;

    case CM_MODE_PREF_HDR_ONLY:
      return NV_MODE_HDR_ONLY;

    case CM_MODE_PREF_CDMA_AMPS_ONLY:
      return NV_MODE_CDMA_AMPS_ONLY;

    case CM_MODE_PREF_GPS_ONLY:
      return NV_MODE_GPS_ONLY;

     case CM_MODE_PREF_GSM_ONLY:
      return NV_MODE_GSM_ONLY;

    case CM_MODE_PREF_WCDMA_ONLY:
      return NV_MODE_WCDMA_ONLY;

    case CM_MODE_PREF_ANY_BUT_HDR:
      return NV_MODE_ANY_BUT_HDR;

    case CM_MODE_PREF_GSM_WCDMA_ONLY:
      return NV_MODE_GSM_WCDMA_ONLY;

    case CM_MODE_PREF_DIGITAL_LESS_HDR_ONLY:
      return NV_MODE_DIGITAL_LESS_HDR_ONLY;

    case CM_MODE_PREF_CDMA_HDR_ONLY:
      return NV_MODE_CDMA_HDR_ONLY;

    case CM_MODE_PREF_CDMA_AMPS_HDR_ONLY:
      return NV_MODE_CDMA_AMPS_HDR_ONLY;

    case CM_MODE_PREF_LTE_ONLY:
      return NV_MODE_LTE_ONLY;

    case CM_MODE_PREF_GWL:
      return NV_MODE_GWL;

    case CM_MODE_PREF_HDR_LTE_ONLY:
      return NV_MODE_HDR_LTE_ONLY;

    case CM_MODE_PREF_CDMA_HDR_LTE_ONLY:
      return NV_MODE_CDMA_HDR_LTE_ONLY;

    case CM_MODE_PREF_CDMA_HDR_GW:
      return NV_MODE_CDMA_HDR_GSM_WCDMA;

    case CM_MODE_PREF_CDMA_GW:
      return NV_MODE_CDMA_GSM_WCDMA;

    case CM_MODE_PREF_CDMA_LTE_ONLY:
      return NV_MODE_CDMA_LTE_ONLY;

    case CM_MODE_PREF_CDMA_HDR_GSM:
      return NV_MODE_CDMA_HDR_GSM;

   case CM_MODE_PREF_CDMA_GSM:
     return NV_MODE_CDMA_GSM;

    case CM_MODE_PREF_GSM_LTE:
      return NV_MODE_GSM_LTE_ONLY;

    case CM_MODE_PREF_CDMA_GSM_LTE:
      return NV_MODE_CDMA_GSM_LTE_ONLY;

    case CM_MODE_PREF_HDR_GSM_LTE:
      return NV_MODE_HDR_GSM_LTE_ONLY;

    case CM_MODE_PREF_WCDMA_LTE:
      return NV_MODE_WCDMA_LTE_ONLY;

    case CM_MODE_PREF_CDMA_WCDMA_LTE:
      return NV_MODE_CDMA_WCDMA_LTE_ONLY;

    case CM_MODE_PREF_HDR_WCDMA_LTE:
      return NV_MODE_HDR_WCDMA_LTE_ONLY;

    case CM_MODE_PREF_TDS_ONLY:
       return NV_MODE_TDS_ONLY;

    case CM_MODE_PREF_TDS_GSM:
       return NV_MODE_TDS_GSM;

    case CM_MODE_PREF_TDS_GSM_LTE:
       return NV_MODE_TDS_GSM_LTE;

    case CM_MODE_PREF_TDS_LTE:
       return NV_MODE_TDS_LTE;

    case CM_MODE_PREF_TDS_GSM_WCDMA_LTE:
       return NV_MODE_TDS_GSM_WCDMA_LTE;

    case CM_MODE_PREF_TDS_GSM_WCDMA:
       return NV_MODE_TDS_GSM_WCDMA;

    case CM_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE:
       return NV_MODE_CDMA_HDR_GSM_WCDMA_LTE;

    case CM_MODE_PREF_CDMA_GSM_WCDMA_LTE:
       return NV_MODE_CDMA_GSM_WCDMA_LTE;

    case CM_MODE_PREF_TDS_WCDMA:
       return NV_MODE_TDS_WCDMA;

    case CM_MODE_PREF_TDS_WCDMA_LTE:
       return NV_MODE_TDS_WCDMA_LTE;

    case CM_MODE_PREF_CDMA_HDR_GSM_TDS_LTE:
       return NV_MODE_CDMA_HDR_GSM_TDS_LTE;

    case CM_MODE_PREF_CDMA_GW_TDS:
      return NV_MODE_PREF_CDMA_GW_TDS;

    case CM_MODE_PREF_CDMA_HDR_GW_TDS:
      return NV_MODE_PREF_CDMA_HDR_GW_TDS;

    case CM_MODE_PREF_CDMA_HDR_GSM_LTE:
       return NV_MODE_PREF_CDMA_HDR_GSM_LTE;

    case CM_MODE_PREF_HDR_TDS_WCDMA:
      return NV_MODE_HDR_TDS_WCDMA;

    case CM_MODE_PREF_HDR_TDS_WCDMA_LTE:
      return NV_MODE_HDR_TDS_WCDMA_LTE;
 
    case CM_MODE_PREF_ANY_BUT_GSM:
        return NV_MODE_PREF_ANY_BUT_GSM;

    case CM_MODE_PREF_ANY_BUT_GSM_GPS:
        return NV_MODE_PREF_ANY_BUT_GSM_GPS;

    case CM_MODE_PREF_AMPS_CDMA_HDR_WCDMA_TDS: 
        return NV_MODE_PREF_AMPS_CDMA_HDR_WCDMA_TDS;

    case CM_MODE_PREF_AMPS_CDMA_HDR_GSM_TDS:
        return NV_MODE_PREF_AMPS_CDMA_HDR_GSM_TDS;       

    default:
      CM_MSG_HIGH_1( "Invalid MODE PREF %d, return AUTO", cm_mode );
      return NV_MODE_AUTOMATIC;
  }
} /* cmph_map_mode_pref_cm2nv() */



/*===========================================================================

FUNCTION cmph_map_mode_pref_nv2cm

DESCRIPTION
  Translates NV enum to CM enum for mode preference

DEPENDENCIES
  none

RETURN VALUE
  CM enum

SIDE EFFECTS
  none

===========================================================================*/
cm_mode_pref_e_type cmph_map_mode_pref_nv2cm( nv_mode_enum_type  nv_mode )
{

  switch (nv_mode)
  {
    case NV_MODE_DIGITAL_ONLY:
      return CM_MODE_PREF_DIGITAL_ONLY;

    case NV_MODE_ANALOG_ONLY:
      return CM_MODE_PREF_AMPS_ONLY;

    case NV_MODE_AUTOMATIC:
      return CM_MODE_PREF_AUTOMATIC;

    case NV_MODE_E911:
      return CM_MODE_PREF_EMERGENCY;

    case NV_MODE_CDMA_ONLY:
      return CM_MODE_PREF_CDMA_ONLY;

    case NV_MODE_HDR_ONLY:
      return CM_MODE_PREF_HDR_ONLY;

    case NV_MODE_CDMA_AMPS_ONLY:
      return CM_MODE_PREF_CDMA_AMPS_ONLY;

    case NV_MODE_GPS_ONLY:
      return CM_MODE_PREF_GPS_ONLY;

    case NV_MODE_GSM_ONLY:
      return CM_MODE_PREF_GSM_ONLY;

    case NV_MODE_WCDMA_ONLY:
      return CM_MODE_PREF_WCDMA_ONLY;

    case NV_MODE_ANY_BUT_HDR:
      return CM_MODE_PREF_ANY_BUT_HDR;

    case NV_MODE_GSM_WCDMA_ONLY:
      return CM_MODE_PREF_GSM_WCDMA_ONLY;

    case NV_MODE_DIGITAL_LESS_HDR_ONLY:
      return CM_MODE_PREF_DIGITAL_LESS_HDR_ONLY;

    case NV_MODE_CDMA_HDR_ONLY:
      return CM_MODE_PREF_CDMA_HDR_ONLY;

    case NV_MODE_CDMA_AMPS_HDR_ONLY:
      return CM_MODE_PREF_CDMA_AMPS_HDR_ONLY;

    case NV_MODE_LTE_ONLY:
      return CM_MODE_PREF_LTE_ONLY;

    case NV_MODE_GWL:
      return CM_MODE_PREF_GWL;

    case NV_MODE_HDR_LTE_ONLY:
      return CM_MODE_PREF_HDR_LTE_ONLY;

    case NV_MODE_CDMA_HDR_LTE_ONLY:
      return CM_MODE_PREF_CDMA_HDR_LTE_ONLY;

    case NV_MODE_CDMA_HDR_GSM_WCDMA:
      return CM_MODE_PREF_CDMA_HDR_GW;

    case NV_MODE_CDMA_GSM_WCDMA:
      return CM_MODE_PREF_CDMA_GW;

    case NV_MODE_CDMA_LTE_ONLY:
      return CM_MODE_PREF_CDMA_LTE_ONLY;

    case NV_MODE_CDMA_HDR_GSM:
      return CM_MODE_PREF_CDMA_HDR_GSM;

    case NV_MODE_CDMA_GSM:
      return CM_MODE_PREF_CDMA_GSM;

    case NV_MODE_GSM_LTE_ONLY:
      return CM_MODE_PREF_GSM_LTE;

    case NV_MODE_CDMA_GSM_LTE_ONLY:
      return CM_MODE_PREF_CDMA_GSM_LTE;

    case NV_MODE_HDR_GSM_LTE_ONLY:
      return CM_MODE_PREF_HDR_GSM_LTE;

    case NV_MODE_WCDMA_LTE_ONLY:
      return CM_MODE_PREF_WCDMA_LTE;

    case NV_MODE_CDMA_WCDMA_LTE_ONLY:
      return CM_MODE_PREF_CDMA_WCDMA_LTE;

    case NV_MODE_HDR_WCDMA_LTE_ONLY:
      return CM_MODE_PREF_HDR_WCDMA_LTE;

    case NV_MODE_TDS_ONLY:
      return CM_MODE_PREF_TDS_ONLY;

    case NV_MODE_TDS_GSM:
      return CM_MODE_PREF_TDS_GSM;

    case NV_MODE_TDS_GSM_LTE:
      return CM_MODE_PREF_TDS_GSM_LTE;

    case NV_MODE_TDS_LTE:
      return CM_MODE_PREF_TDS_LTE;

    case NV_MODE_TDS_GSM_WCDMA_LTE:
      return CM_MODE_PREF_TDS_GSM_WCDMA_LTE;

    case NV_MODE_TDS_GSM_WCDMA:
      return CM_MODE_PREF_TDS_GSM_WCDMA;

    case NV_MODE_CDMA_HDR_GSM_WCDMA_LTE:
       return CM_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE;

    case NV_MODE_CDMA_GSM_WCDMA_LTE:
       return CM_MODE_PREF_CDMA_GSM_WCDMA_LTE;

    case NV_MODE_TDS_WCDMA:
       return CM_MODE_PREF_TDS_WCDMA;

    case NV_MODE_TDS_WCDMA_LTE:
        return CM_MODE_PREF_TDS_WCDMA_LTE;

    case NV_MODE_CDMA_HDR_GSM_TDS_LTE:
       return CM_MODE_PREF_CDMA_HDR_GSM_TDS_LTE;

    case NV_MODE_PREF_CDMA_GW_TDS:
      return CM_MODE_PREF_CDMA_GW_TDS;

    case NV_MODE_PREF_CDMA_HDR_GW_TDS:
      return CM_MODE_PREF_CDMA_HDR_GW_TDS;

    case NV_MODE_PREF_CDMA_HDR_GSM_LTE:
       return CM_MODE_PREF_CDMA_HDR_GSM_LTE;

    case NV_MODE_HDR_TDS_WCDMA:
      return CM_MODE_PREF_HDR_TDS_WCDMA;

    case NV_MODE_HDR_TDS_WCDMA_LTE:
      return CM_MODE_PREF_HDR_TDS_WCDMA_LTE;
  
    case NV_MODE_PREF_ANY_BUT_GSM:
        return CM_MODE_PREF_ANY_BUT_GSM;

    case NV_MODE_PREF_ANY_BUT_GSM_GPS:
        return CM_MODE_PREF_ANY_BUT_GSM_GPS;

    case NV_MODE_PREF_AMPS_CDMA_HDR_WCDMA_TDS: 
        return CM_MODE_PREF_AMPS_CDMA_HDR_WCDMA_TDS;

    case NV_MODE_PREF_AMPS_CDMA_HDR_GSM_TDS:
        return CM_MODE_PREF_AMPS_CDMA_HDR_GSM_TDS;              


    default:
      CM_ERR_1("Invalid NV MODE %d, return AUTO",nv_mode);
      return CM_MODE_PREF_AUTOMATIC;
  }
} /* cmph_map_mode_pref_nv2cm() */


#if (defined CM_GW_SUPPORTED )
/*===========================================================================

FUNCTION cmph_map_net_sel_mode_pref_cm2nv

DESCRIPTION
  Translates CM enum to NV enum for network selection mode
  preference

DEPENDENCIES
  none

RETURN VALUE
  NV enum

SIDE EFFECTS
  none

===========================================================================*/
/*lint -esym(528, cmph_map_net_sel_mode_pref_cm2nv) not referenced */
static nv_net_sel_mode_pref_enum_type  cmph_map_net_sel_mode_pref_cm2nv
(
  cm_network_sel_mode_pref_e_type  cm_mode
)
{
  /*
  ** 571: suspicious cast
  ** nv_net_sel_mode_pref_enum_type is just a word
  ** so doing typedef is not illegal
  */
  /*lint -save -e571*/
  nv_net_sel_mode_pref_enum_type   nv_mode =
    ( nv_net_sel_mode_pref_enum_type ) cm_mode;    /* default */
  /*lint -restore */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( cm_mode == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC )
  {
    nv_mode = NV_NET_SEL_MODE_PREF_AUTOMATIC;
  }
  else if ( cm_mode == CM_NETWORK_SEL_MODE_PREF_MANUAL )
  {
    nv_mode = NV_NET_SEL_MODE_PREF_MANUAL;
  }
  else if ( cm_mode == CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV )
  {
    nv_mode = NV_NET_SEL_MODE_PREF_LIMITED_SRV;
  }
  else
  {
    nv_mode = NV_NET_SEL_MODE_PREF_AUTOMATIC;
  }

  return( nv_mode );

} /* cmph_map_net_sel_mode_pref_cm2nv */



/*===========================================================================

FUNCTION cmph_map_net_sel_mode_pref_nv2cm

DESCRIPTION
  Translates NV enum to CM enum for network selection mode preference

DEPENDENCIES
  none

RETURN VALUE
  CM enum

SIDE EFFECTS
  none

===========================================================================*/
/*lint -esym(528, cmph_map_net_sel_mode_pref_nv2cm) not referenced */
static cm_network_sel_mode_pref_e_type  cmph_map_net_sel_mode_pref_nv2cm
(
  nv_net_sel_mode_pref_enum_type   nv_mode
)
{
  cm_network_sel_mode_pref_e_type  cm_mode =
    ( cm_network_sel_mode_pref_e_type ) nv_mode;  /* default */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( nv_mode == NV_NET_SEL_MODE_PREF_AUTOMATIC )
  {
    cm_mode = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
  }
  else if ( nv_mode == NV_NET_SEL_MODE_PREF_MANUAL )
  {
    cm_mode = CM_NETWORK_SEL_MODE_PREF_MANUAL;
  }
  else if ( nv_mode == NV_NET_SEL_MODE_PREF_LIMITED_SRV )
  {
    cm_mode = CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV;
  }
  else
  {
    cm_mode = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
  }
  return( cm_mode );

} /* cmph_map_net_sel_mode_pref_nv2cm */
#endif /* ((FEATURE_WCDMA) || (FEATURE_GSM) ) */

/*===========================================================================

FUNCTION cmph_map_user_to_cm_net_sel_mode_pref

DESCRIPTION
  Translates cm user net_sel_mode_pref to cm net_sel_mode_pref

DEPENDENCIES
  none

RETURN VALUE
  NV enum

SIDE EFFECTS
  none

===========================================================================*/
static
cm_network_sel_mode_pref_e_type cmph_map_user_to_cm_net_sel_mode_pref
(
   cm_user_net_sel_mode_pref_e_type  cm_user_net_sel_mode
   /* User selected net_sel_mode */
)
{
  switch (cm_user_net_sel_mode)
  {
    case CM_USER_NETWORK_SEL_MODE_PREF_AUTOMATIC:
      return CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;

    case CM_USER_NETWORK_SEL_MODE_PREF_MANUAL:
      return CM_NETWORK_SEL_MODE_PREF_MANUAL;

    default:
      CM_ERR_0 ("Invalid user_net_sel_mode");
      return CM_NETWORK_SEL_MODE_PREF_NONE;
  }
}



#ifdef CM_GW_SUPPORTED
/*===========================================================================

FUNCTION acq_order_pref_cm2nv

DESCRIPTION
  Translates CM enum to NV enum for acquisition order preference

DEPENDENCIES
  none

RETURN VALUE
  NV enum

SIDE EFFECTS
  none

===========================================================================*/
static nv_acq_order_pref_enum_type  acq_order_pref_cm2nv
(
  cm_gw_acq_order_pref_e_type  cm_mode
)
{
  /*lint -save -e571*/
  nv_acq_order_pref_enum_type  nv_mode =
    ( nv_acq_order_pref_enum_type  ) cm_mode;    /* default */
  /*lint -restore */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( cm_mode == CM_GW_ACQ_ORDER_PREF_AUTOMATIC )
  {
    nv_mode = NV_ACQ_ORDER_PREF_AUTOMATIC;
  }
  else if ( cm_mode == CM_GW_ACQ_ORDER_PREF_GSM_WCDMA )
  {
    nv_mode = NV_ACQ_ORDER_PREF_GSM_WCDMA;
  }
  else if ( cm_mode == CM_GW_ACQ_ORDER_PREF_WCDMA_GSM )
  {
    nv_mode = NV_ACQ_ORDER_PREF_WCDMA_GSM;
  }

  return( nv_mode );

} /* acq_order_pref_cm2nv */



/*===========================================================================

FUNCTION acq_order_pref_nv2cm

DESCRIPTION
  Translates NV enum to CM enum for acquisition order preference

DEPENDENCIES
  none

RETURN VALUE
  CM enum

SIDE EFFECTS
  none

===========================================================================*/
static cm_gw_acq_order_pref_e_type  acq_order_pref_nv2cm
(
  nv_acq_order_pref_enum_type   nv_mode
)
{
  cm_gw_acq_order_pref_e_type   cm_mode =
    ( cm_gw_acq_order_pref_e_type ) nv_mode;  /* default */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( nv_mode == NV_ACQ_ORDER_PREF_AUTOMATIC )
  {
    cm_mode = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
  }
  else if ( nv_mode == NV_ACQ_ORDER_PREF_GSM_WCDMA )
  {
    cm_mode = CM_GW_ACQ_ORDER_PREF_GSM_WCDMA;
  }
  else if ( nv_mode == NV_ACQ_ORDER_PREF_WCDMA_GSM )
  {
    cm_mode = CM_GW_ACQ_ORDER_PREF_WCDMA_GSM;
  }

  return( cm_mode );

} /* cmph_map_net_sel_mode_pref_nv2cm */



/*===========================================================================

FUNCTION cmph_map_srv_domain_pref_cm2nv

DESCRIPTION
  Translates CM enum to NV enum for service domain preference

DEPENDENCIES
  none

RETURN VALUE
  NV enum

SIDE EFFECTS
  none

===========================================================================*/
static nv_srv_domain_pref_enum_type  cmph_map_srv_domain_pref_cm2nv
(
  cm_srv_domain_pref_e_type          cm_mode
)
{
  /*lint -save -e571*/
  nv_srv_domain_pref_enum_type       nv_mode =
    ( nv_srv_domain_pref_enum_type ) cm_mode;    /* default */
  /*lint -restore */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( cm_mode == CM_SRV_DOMAIN_PREF_CS_ONLY )
  {
    nv_mode = NV_SRV_DOMAIN_PREF_CS_ONLY;
  }
  else if ( cm_mode == CM_SRV_DOMAIN_PREF_PS_ONLY )
  {
    nv_mode = NV_SRV_DOMAIN_PREF_PS_ONLY;
  }
  else if ( cm_mode == CM_SRV_DOMAIN_PREF_CS_PS )
  {
    nv_mode = NV_SRV_DOMAIN_PREF_CS_PS;
  }
  else if ( cm_mode == CM_SRV_DOMAIN_PREF_ANY )
  {
    nv_mode = NV_SRV_DOMAIN_PREF_ANY;
  }

  return( nv_mode );

} /* cmph_map_srv_domain_pref_cm2nv */



/*===========================================================================

FUNCTION cmph_map_srv_domain_pref_nv2cm

DESCRIPTION
  Translates NV enum to CM enum for service domain preference

DEPENDENCIES
  none

RETURN VALUE
  CM enum

SIDE EFFECTS
  none

===========================================================================*/
static cm_srv_domain_pref_e_type  cmph_map_srv_domain_pref_nv2cm
(
  nv_srv_domain_pref_enum_type   nv_mode
)
{
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (nv_mode)
  {
    case NV_SRV_DOMAIN_PREF_CS_ONLY: return CM_SRV_DOMAIN_PREF_CS_ONLY;

    case NV_SRV_DOMAIN_PREF_PS_ONLY: return CM_SRV_DOMAIN_PREF_PS_ONLY;

    case NV_SRV_DOMAIN_PREF_CS_PS:   return CM_SRV_DOMAIN_PREF_CS_PS;

    case NV_SRV_DOMAIN_PREF_ANY:     return CM_SRV_DOMAIN_PREF_ANY;

    default:                         return ( cm_srv_domain_pref_e_type ) nv_mode;
  }


} /* cmph_map_srv_domain_pref_nv2cm */

/*===========================================================================

FUNCTION cmph_copy_ccbs_indexes

DESCRIPTION
  Copies ccb indexes into phone info that is sent to clients

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  None

===========================================================================*/
static void cmph_copy_ccbs_indexes
(

    cm_ph_info_s_type      *ph_info_ptr
      /* Phone info sent to clients
      */
)
{
  int                   ccbs_count = 0;  /* for loop */
  cmph_s_type          *ph_ptr     = cmph_ptr();
  int                   entry_num  = 0;  /* ccbs entry in ph_info_ptr */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT (ph_info_ptr != NULL)


  /* Copy current state of ccbs indx store from ph object
  ** to event information
  */
  for (ccbs_count = 0; ccbs_count < (int)ARR_SIZE(ph_ptr->ccbs_indx_store);
                                                 ++ccbs_count)
  {
    if (ph_ptr->ccbs_indx_store[ccbs_count].ccbs_index !=
                                                    CM_CCBS_INDX_INVALID)
    {
      entry_num = ph_info_ptr->ccbs_store_info.cm_ccbs_store_info_len;

      ph_info_ptr->ccbs_store_info.ccbs_indx_store[entry_num] =
                                      ph_ptr->ccbs_indx_store[ccbs_count];

      ph_info_ptr->ccbs_store_info.cm_ccbs_store_info_len ++;

    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return;

} /* cmph_copy_ccbs_indexes () */
#endif /* CM_GW_SUPPORTED */

/*===========================================================================

FUNCTION cmph_get_gprs_anite_gcf_ptr

DESCRIPTION
  Return a pointer to gprs anite gcf flag

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  None

===========================================================================*/
boolean *cmph_get_gprs_anite_gcf_ptr(void)
{
  static boolean gprs_anite_gcf  = FALSE;

  return &gprs_anite_gcf;
} /* cmph_get_gprs_anite_gcf_ptr */

/*===========================================================================

FUNCTION cmph_set_gprs_anite_gcf

DESCRIPTION
  Set the value to gprs anite gcf flag

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  None

===========================================================================*/
static void cmph_set_gprs_anite_gcf(

  boolean nv_value
    /* value that needs to be set to gprs anite gcf flag */
)
{
  boolean *gprs_anite_gcf_ptr = cmph_get_gprs_anite_gcf_ptr();

  *gprs_anite_gcf_ptr         = nv_value;
} /* cmph_set_gprs_anite_gcf_ptr */

#ifdef CM_GW_SUPPORTED
#ifdef FEATURE_GRACEFUL_PDP_DEACTIVATION_B4_DETACH
/*===========================================================================

FUNCTION cmph_get_pdp_deactivate_before_detach_supported_ptr

DESCRIPTION
  Return a pointer to pdp_deactivate_before_detach_supported flag

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  None

===========================================================================*/
boolean *cmph_get_pdp_deactivate_before_detach_supported_ptr(void)
{
  static boolean pdp_deactivate_before_detach_supported  = FALSE;

  return &pdp_deactivate_before_detach_supported;
} /* cmph_get_gprs_anite_gcf_ptr */

/*===========================================================================

FUNCTION cmph_set_pdp_deactivate_before_detach_supported

DESCRIPTION
  Set the value to pdp deactivate before detach supported flag

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  None

===========================================================================*/
static void cmph_set_pdp_deactivate_before_detach_supported(

  boolean nv_value
    /* value that needs to be set to gprs anite gcf flag */
)
{
  boolean *pdp_deactivate_before_detach_supported = cmph_get_pdp_deactivate_before_detach_supported_ptr();

  *pdp_deactivate_before_detach_supported         = nv_value;
} /* cmph_set_gprs_anite_gcf_ptr */
#endif

#endif /* #ifdef CM_GW_SUPPORTED */

/*===========================================================================

FUNCTION cmph_get_is_kicked_hybr_ptr

DESCRIPTION
  Returns the is_kicked_hdr value

DEPENDENCIES
  none

RETURN VALUE
  Returns the is_kicked_hdr value

SIDE EFFECTS
  None

===========================================================================*/

boolean *cmph_get_is_kicked_hybr_ptr()
{

  static boolean is_kicked_hybr = FALSE;
  return &is_kicked_hybr;
}

/*===========================================================================

FUNCTION cmph_get_is_kicked_hybr_ptr

DESCRIPTION
  Returns the is_kicked_hdr value

DEPENDENCIES
  none

RETURN VALUE
  Returns the is_kicked_hdr value

SIDE EFFECTS
  None

===========================================================================*/

boolean *cmph_get_is_kicked_hybr_2_ptr()
{

  static boolean is_kicked_hybr_2 = FALSE;
  return &is_kicked_hybr_2;
}

/*===========================================================================

FUNCTION cmph_hdr_kick_pending

DESCRIPTION
  Returns if hdr kick is pending

DEPENDENCIES
  none

RETURN VALUE
  Returns the is_kicked_hdr value

SIDE EFFECTS
  None

===========================================================================*/

boolean *cmph_hdr_kick_pending()
{
  #if defined( FEATURE_HICPS_STACK_SYNC_UP )
  static boolean is_kick_hdr_pending = FALSE;
  return &is_kick_hdr_pending;
  #else
  static boolean is_dummy = FALSE;
  return &is_dummy;
  #endif
}

/*===========================================================================

FUNCTION cmph_map_call_type_to_sd_orig_mode

DESCRIPTION
  Map CM call-type type to SD origination mode type.

DEPENDENCIES
  none

RETURN VALUE
  The SD origination mode that corresponds to the input CM call-type.

SIDE EFFECTS
  none

===========================================================================*/
sd_ss_orig_mode_e_type          cmph_map_cm_call_type_to_sd_orig_mode(

    cm_call_type_e_type         call_type,
        /* Call type to map */

    cm_ss_e_type                ss
      /* Stack on which the call is being originated */
)
{
  sd_ss_orig_mode_e_type     orig_mode = SD_SS_ORIG_MODE_NORMAL;
  cmph_s_type                *ph_ptr   = cmph_ptr();

  sys_modem_as_id_e_type   asubs_id = cmph_map_cm_ss_to_subs(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Map CM call-type to SD origination-mode.*/

  switch( call_type )
  {
    case CM_CALL_TYPE_NONE:

      orig_mode = cmph_map_cm_network_sel_mode_pref_to_orig_mode
                                  ( CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) );
      break;

    case CM_CALL_TYPE_PS_DATA:
    case CM_CALL_TYPE_SMS:
    case CM_CALL_TYPE_TEST:
    case CM_CALL_TYPE_NON_STD_OTASP:
    case CM_CALL_TYPE_VS:
     if( CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr)  == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
      }
      else
      {
        orig_mode = SD_SS_ORIG_MODE_NORMAL;
      }
      break;

    case CM_CALL_TYPE_PD:
    case CM_CALL_TYPE_CS_DATA:
    case CM_CALL_TYPE_VT:
    case CM_CALL_TYPE_VOICE:

      if( CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr)  == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        if(cmcall_is_there_volte_call(call_type)!= CM_CALL_ID_INVALID)
        {
            orig_mode = SD_SS_ORIG_MODE_VOLTE_MANUAL;
            CM_MSG_HIGH_1("Orig_mode=%d",orig_mode);
        }
        else
        {
          orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
        }
      }
      else
      {
        if(cmcall_is_there_volte_call(call_type)!= CM_CALL_ID_INVALID)
        {
          orig_mode = SD_SS_ORIG_MODE_VOLTE;
          CM_MSG_HIGH_1( "Determine orig_mode=%d",orig_mode );
        }
        #if defined (FEATURE_3GPP_CSFB) || defined (FEATURE_LTE_TO_1X)
        else if (cmcall_is_there_csfb_call(ss,CM_CALL_CSFB_TYPE_1XCSFB,
                                         CM_CALL_ID_INVALID)
                                         != CM_CALL_ID_INVALID)
        {
          /* It is 1XCSFB normal call */
          orig_mode = SD_SS_ORIG_MODE_1XCSFB_NORMAL_ORIG;
        }
        else if (cmcall_is_there_csfb_call(ss,CM_CALL_CSFB_TYPE_PPCSFB,
                                         CM_CALL_ID_INVALID)
                                         != CM_CALL_ID_INVALID)
        {
          /* It is  PPCSFB normal call */
          orig_mode = SD_SS_ORIG_MODE_PPCSFB_NORMAL_ORIG;
        }
        #endif
        else
        {
          orig_mode = SD_SS_ORIG_MODE_NORMAL;
        }
      }
      break;

    case CM_CALL_TYPE_STD_OTASP:

      orig_mode = SD_SS_ORIG_MODE_OTASP;
      break;

    case CM_CALL_TYPE_EMERGENCY:
        #if defined (FEATURE_3GPP_CSFB) || defined (FEATURE_LTE_TO_1X)
        if(cmcall_is_there_csfb_call(ss,CM_CALL_CSFB_TYPE_1XCSFB,
                                         CM_CALL_ID_INVALID)
                                         != CM_CALL_ID_INVALID)
        {
          /* It is  1XCSFB emergency call */
          orig_mode = SD_SS_ORIG_MODE_1XCSFB_EMERG_ORIG;
        }
        else  if(cmcall_is_there_csfb_call(ss,CM_CALL_CSFB_TYPE_PPCSFB,
                                         CM_CALL_ID_INVALID)
                                         != CM_CALL_ID_INVALID)
        {
          /* It is  PPCSFB emergency call */
          orig_mode = SD_SS_ORIG_MODE_PPCSFB_EMERG_ORIG;
        }
        else
        #endif
        {
          orig_mode = SD_SS_ORIG_MODE_EMERG_ORIG;
        }

      break;

    case CM_CALL_TYPE_OTAPA:

      orig_mode = SD_SS_ORIG_MODE_NORMAL;
      break;

    case CM_CALL_TYPE_SUPS:
    case CM_CALL_TYPE_MAX:
    default:
      CM_ERR_1( "unsupported call_type=%d",call_type);
      /*Note that unsupported CM origination
      ** call-types are mapped to SD_SS_ORIG_MODE_NORMAL.
      */
      break;
  } /* switch */

  return orig_mode;

} /* map_cm_call_type_to_sd_orig_mode() */


/*===========================================================================

FUNCTION cmph_cm_map_mode_pref_to_sd_mode_pref

DESCRIPTION
  Map CM mode-preference type to SD mode-preference type.

DEPENDENCIES
  none

RETURN VALUE
  The SD mode-preference that corresponds to the input CM mode-preference.

SIDE EFFECTS
  none

===========================================================================*/
sd_ss_mode_pref_e_type   cmph_map_cm_mode_pref_to_sd_mode_pref(

    cm_mode_pref_e_type    mode_pref
        /* Mode pref to map */
)
{
  /*
  ** Map CM mode-preference type to SD mode-preference type.
  ** Note that unsupported CM mode-preferences are mapped
  ** to SD_SS_MODE_PREF_NONE.
  */

  switch( mode_pref )
  {
    case CM_MODE_PREF_GSM_WCDMA_ONLY:
      return SD_SS_MODE_PREF_GW;

    case CM_MODE_PREF_AMPS_ONLY:
      return SD_SS_MODE_PREF_AMPS;

    case CM_MODE_PREF_CDMA_ONLY:
      return SD_SS_MODE_PREF_CDMA;

    case CM_MODE_PREF_HDR_ONLY:
      return SD_SS_MODE_PREF_HDR;

    case CM_MODE_PREF_CDMA_HDR_ONLY:
      return SD_SS_MODE_PREF_CDMA_HDR;

    case CM_MODE_PREF_CDMA_AMPS_HDR_ONLY:
      return SD_SS_MODE_PREF_CDMA_AMPS_HDR;

    case CM_MODE_PREF_GSM_ONLY:
      return SD_SS_MODE_PREF_GSM;

    case CM_MODE_PREF_WCDMA_ONLY:
      return SD_SS_MODE_PREF_WCDMA;

    case CM_MODE_PREF_DIGITAL_ONLY:
      return SD_SS_MODE_PREF_DIGITAL;

    case CM_MODE_PREF_DIGITAL_LESS_HDR_ONLY:
      return SD_SS_MODE_PREF_DIGITAL_LESS_HDR;

    case CM_MODE_PREF_CDMA_AMPS_ONLY:
      return SD_SS_MODE_PREF_CDMA_AMPS;

    case CM_MODE_PREF_GPS_ONLY:
      return SD_SS_MODE_PREF_GPS;

    case CM_MODE_PREF_AUTOMATIC:
      return SD_SS_MODE_PREF_ANY;

    case CM_MODE_PREF_EMERGENCY:
      if( cmmsc_auto_is_hybr_hdr_call_allowed(SYS_MODEM_AS_ID_1) &&
         cmcall_is_active_ip_app(SYS_SYS_MODE_HDR,
                           CM_CALL_TYPE_EMERGENCY)
        )
      {
        return SD_SS_MODE_PREF_ANY;
      }
      #if (defined( FEATURE_3GPP_CSFB) || defined (FEATURE_LTE_TO_1X) || defined FEATURE_IP_CALL) && defined FEATURE_LTE
        /* If IMS/CSFB is not allowed exclude LTE from mode preference */
      else if(!cmsds_is_LTE_emerg_call_possible(cmph_get_sub_with_lte_cap()))
      {
        return SD_SS_MODE_PREF_ANY_BUT_HDR_LTE;
      }
    #endif
      else
      {
        return SD_SS_MODE_PREF_ANY_BUT_HDR;
      }

    case CM_MODE_PREF_ANY_BUT_HDR:
      return SD_SS_MODE_PREF_ANY_BUT_HDR;

    case CM_MODE_PREF_ANY_BUT_CDMA_HDR:
      return SD_SS_MODE_PREF_ANY_BUT_CDMA_HDR;

    case CM_MODE_PREF_CDMA_GSM_AMPS:
      return SD_SS_MODE_PREF_CDMA_GSM_AMPS;

    case CM_MODE_PREF_CDMA_GSM_GPS_AMPS:
      return SD_SS_MODE_PREF_CDMA_GSM_GPS_AMPS;

    case CM_MODE_PREF_CDMA_HDR_GSM_AMPS:
      return SD_SS_MODE_PREF_CDMA_HDR_GSM_AMPS;

    case CM_MODE_PREF_CDMA_HDR_GSM_GPS_AMPS:
      return SD_SS_MODE_PREF_CDMA_HDR_GSM_GPS_AMPS;

    case CM_MODE_PREF_GSM_GPS:
      return SD_SS_MODE_PREF_GSM_GPS;

    case CM_MODE_PREF_WCDMA_GPS:
      return SD_SS_MODE_PREF_WCDMA_GPS;

    case CM_MODE_PREF_GW_GPS:
      return SD_SS_MODE_PREF_GW_GPS;

    case CM_MODE_PREF_HDR_GSM:
      return SD_SS_MODE_PREF_HDR_GSM;

    case CM_MODE_PREF_ANY_BUT_TDS:
      return SD_SS_MODE_PREF_ANY_BUT_TDS;

    case CM_MODE_PREF_ANY_BUT_HDR_TDS:
      return SD_SS_MODE_PREF_ANY_BUT_HDR_TDS;

    case CM_MODE_PREF_ANY_BUT_LTE_TDS:
      return SD_SS_MODE_PREF_ANY_BUT_LTE_TDS;

    case CM_MODE_PREF_ANY_BUT_HDR_LTE_TDS:
      return SD_SS_MODE_PREF_ANY_BUT_HDR_LTE_TDS;

    case CM_MODE_PREF_LTE_ONLY:
      return SD_SS_MODE_PREF_LTE;

    case CM_MODE_PREF_GWL:
      return SD_SS_MODE_PREF_GWL;

    case CM_MODE_PREF_NONE:
      return SD_SS_MODE_PREF_NONE;

    case CM_MODE_PREF_HDR_LTE_ONLY:
      return SD_SS_MODE_PREF_HDR_LTE;

    case CM_MODE_PREF_CDMA_HDR_LTE_ONLY:
      return SD_SS_MODE_PREF_CDMA_HDR_LTE;

    case CM_MODE_PREF_CDMA_HDR_GW:
      return SD_SS_MODE_PREF_CDMA_HDR_GW;

    case CM_MODE_PREF_CDMA_HDR_GW_TDS:
      return SD_SS_MODE_PREF_CDMA_HDR_GW_TDS;

    case CM_MODE_PREF_CDMA_GW:
      return SD_SS_MODE_PREF_CDMA_GW;

    case CM_MODE_PREF_CDMA_GW_TDS:
      return SD_SS_MODE_PREF_CDMA_GW_TDS;

    case CM_MODE_PREF_CDMA_LTE_ONLY:
      return SD_SS_MODE_PREF_CDMA_LTE;

    case CM_MODE_PREF_ANY_BUT_HDR_LTE:
      return SD_SS_MODE_PREF_ANY_BUT_HDR_LTE;

    case CM_MODE_PREF_CDMA_HDR_GSM:
      return SD_SS_MODE_PREF_CDMA_HDR_GSM;

    case CM_MODE_PREF_CDMA_GSM:
      return SD_SS_MODE_PREF_CDMA_GSM;

    case CM_MODE_PREF_ANY_BUT_LTE:
      return SD_SS_MODE_PREF_ANY_BUT_LTE;

    case CM_MODE_PREF_TDS_ONLY:
      return SD_SS_MODE_PREF_TDS;

    case CM_MODE_PREF_TDS_GSM:
      return SD_SS_MODE_PREF_TDS_GSM;

    case CM_MODE_PREF_TDS_GSM_GPS:
       return SD_SS_MODE_PREF_TDS_GSM_GPS;

    case CM_MODE_PREF_TDS_GSM_LTE:
      return SD_SS_MODE_PREF_TDS_GSM_LTE;

    case CM_MODE_PREF_TDS_LTE:
      return SD_SS_MODE_PREF_TDS_LTE;

    case CM_MODE_PREF_TDS_GSM_WCDMA_LTE:
      return SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE;

    case CM_MODE_PREF_TDS_GSM_WCDMA:
      return SD_SS_MODE_PREF_TDS_GSM_WCDMA;

    case CM_MODE_PREF_TDS_GSM_WCDMA_GPS:
       return SD_SS_MODE_PREF_TDS_GSM_WCDMA_GPS;

    case CM_MODE_PREF_GSM_LTE:
      return SD_SS_MODE_PREF_GSM_LTE;

    case CM_MODE_PREF_CDMA_GSM_LTE:
      return SD_SS_MODE_PREF_CDMA_GSM_LTE;

    case CM_MODE_PREF_HDR_GSM_LTE:
      return SD_SS_MODE_PREF_HDR_GSM_LTE;

    case CM_MODE_PREF_WCDMA_LTE:
      return SD_SS_MODE_PREF_WCDMA_LTE;

    case CM_MODE_PREF_CDMA_WCDMA_LTE:
      return SD_SS_MODE_PREF_CDMA_WCDMA_LTE;

    case CM_MODE_PREF_HDR_WCDMA_LTE:
      return SD_SS_MODE_PREF_HDR_WCDMA_LTE;

    case CM_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE:
       return SD_SS_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE;

    case CM_MODE_PREF_CDMA_GSM_WCDMA_LTE:
       return SD_SS_MODE_PREF_CDMA_GSM_WCDMA_LTE;

    case CM_MODE_PREF_TDS_WCDMA:
      return SD_SS_MODE_PREF_TDS_WCDMA;

    case CM_MODE_PREF_TDS_WCDMA_LTE:
       return SD_SS_MODE_PREF_TDS_WCDMA_LTE;

    case CM_MODE_PREF_CDMA_HDR_GSM_TDS_LTE:
       return SD_SS_MODE_PREF_CDMA_HDR_GSM_TDS_LTE;

    case CM_MODE_PREF_GSM_WCDMA_TDS_AMPS:
       return SD_SS_MODE_PREF_GSM_WCDMA_TDS_AMPS;

    case CM_MODE_PREF_GSM_WCDMA_LTE_AMPS:
       return SD_SS_MODE_PREF_GSM_WCDMA_LTE_AMPS;

    case CM_MODE_PREF_GSM_WCDMA_AMPS:
       return SD_SS_MODE_PREF_GSM_WCDMA_AMPS;

    case CM_MODE_PREF_CDMA_HDR_GSM_LTE:
       return SD_SS_MODE_PREF_CDMA_HDR_GSM_LTE;

    case CM_MODE_PREF_HDR_TDS_WCDMA:
       return SD_SS_MODE_PREF_HDR_TDS_WCDMA;

    case CM_MODE_PREF_HDR_TDS_WCDMA_LTE:
       return SD_SS_MODE_PREF_HDR_TDS_WCDMA_LTE;

    case CM_MODE_PREF_ANY_BUT_GSM:
        return SD_SS_MODE_PREF_ANY_BUT_GSM;

    case CM_MODE_PREF_ANY_BUT_GSM_GPS:
        return SD_SS_MODE_PREF_ANY_BUT_GSM_GPS;

    case CM_MODE_PREF_AMPS_CDMA_HDR_WCDMA_TDS:
        return SD_SS_MODE_PREF_AMPS_CDMA_HDR_WCDMA_TDS;

    case CM_MODE_PREF_AMPS_CDMA_HDR_GSM_TDS:
        return SD_SS_MODE_PREF_AMPS_CDMA_HDR_GSM_TDS;

    case CM_MODE_PREF_CURRENT_LESS_AMPS:
    case CM_MODE_PREF_CURRENT_LESS_HDR:
    case CM_MODE_PREF_CURRENT_LESS_HDR_AND_AMPS:
    case CM_MODE_PREF_PERSISTENT:
    case CM_MODE_PREF_NO_CHANGE:
    case CM_MODE_PREF_MAX:
    default:
      CM_MSG_HIGH_1( "CM mode_pref %d not mapped to SD mode pref!!!",mode_pref );
      return SD_SS_MODE_PREF_NONE;

  } /* switch */


} /* cmph_map_cm_mode_pref_to_sd_mode_pref() */

/*===========================================================================

FUNCTION cmph_map_sys_sys_mode_to_sd_mode

DESCRIPTION
  Map CM SYS mode type to SD mode type.

DEPENDENCIES
  none

RETURN VALUE
  The SD mode type that corresponds to the input CM SYS mode type or
  SD_MODE_MAX if not matched.

SIDE EFFECTS
  None

===========================================================================*/
sd_mode_e_type cmph_map_sys_sys_mode_to_sd_mode(sys_sys_mode_e_type mode)
{


  switch(mode)
  {

    case SYS_SYS_MODE_NO_SRV: return SD_MODE_INACT;
    case SYS_SYS_MODE_AMPS:   return SD_MODE_AMPS;
    case SYS_SYS_MODE_CDMA:   return SD_MODE_CDMA;
    case SYS_SYS_MODE_GSM:    return SD_MODE_GSM;
    case SYS_SYS_MODE_HDR:    return SD_MODE_HDR;
    case SYS_SYS_MODE_WCDMA:  return SD_MODE_WCDMA;
    case SYS_SYS_MODE_GPS:    return SD_MODE_GPS;
    case SYS_SYS_MODE_GW:     return SD_MODE_GW;
    case SYS_SYS_MODE_GWL:    return SD_MODE_GWL;
    case SYS_SYS_MODE_LTE:    return SD_MODE_LTE;
    case SYS_SYS_MODE_TDS:    return SD_MODE_TDS;

    default:
      CM_ERR_1("No match! - %d",mode);
      return SD_MODE_MAX;
  }


}


/*===========================================================================

FUNCTION cmph_map_cm_hybr_pref_to_sd_hybr_pref

DESCRIPTION
  Map CM hybr-preference type to SD hybr-preference type.

DEPENDENCIES
  none

RETURN VALUE
  The SD hybr-preference that corresponds to the input CM hybr-preference.

SIDE EFFECTS
  none

===========================================================================*/
sd_ss_hybr_pref_e_type   cmph_map_cm_hybr_pref_to_sd_hybr_pref
(
  cm_hybr_pref_e_type      hybr_pref
    /* hybr pref to map */
)
{
  /* Map CM hybr-preference type to SD hybr-preference type. Note that
  ** unsupported CM hybr-preferences are mapped to SD_SS_HYBR_PREF_NONE.
  */

  switch( hybr_pref )
  {
    case CM_HYBR_PREF_OFF:
      return SD_SS_HYBR_PREF_NONE;

    case CM_HYBR_PREF_CDMA__HDR:
      return SD_SS_HYBR_PREF_CDMA__HDR;

    case CM_HYBR_PREF_CDMA__LTE__HDR:
       return SD_SS_HYBR_PREF_CDMA__LTE__HDR;

    case CM_HYBR_PREF_CDMA__GWL__HDR:
      return SD_SS_HYBR_PREF_CDMA__GWL__HDR;

    default:
      CM_ERR_1( "cm_hybr_pref %d",hybr_pref);
      return SD_SS_HYBR_PREF_NONE;

  } /* switch */

} /* cmph_map_cm_hybr_pref_to_sd_hybr_pref() */


/*===========================================================================

FUNCTION cmph_map_sd_hybr_pref_to_cm_hybr_pref

DESCRIPTION
  Map SD hybr-preference type to CM hybr-preference type.

DEPENDENCIES
  none

RETURN VALUE
  The CM hybr-preference that corresponds to the input SD hybr-preference.

SIDE EFFECTS
  none

===========================================================================*/
cm_hybr_pref_e_type cmph_map_sd_hybr_pref_to_cm_hybr_pref
(
  sd_ss_hybr_pref_e_type       hybr_pref
    /* hybr pref to map */
)
{
  /* Map SD hybr-preference type to CM hybr-preference type. Note that
  ** unsuppor`ted SD hybr-preferences are mapped to CM_HYBR_PREF_NONE.
  */

  switch( hybr_pref )
  {
    case SD_SS_HYBR_PREF_NONE:       return CM_HYBR_PREF_OFF;
    case SD_SS_HYBR_PREF_CDMA__HDR:   return CM_HYBR_PREF_CDMA__HDR;
    case SD_SS_HYBR_PREF_CDMA__LTE__HDR:  return CM_HYBR_PREF_CDMA__LTE__HDR;
    case SD_SS_HYBR_PREF_CDMA__GWL__HDR:  return CM_HYBR_PREF_CDMA__GWL__HDR;
    default:
      CM_ERR_1( "sd_hybr_pref",hybr_pref);
      return CM_HYBR_PREF_NONE;

  } /* switch */

} /* cmph_map_sd_hybr_pref_to_cm_hybr_pref() */


/*===========================================================================

FUNCTION cmph_map_otasp_act_code_to_sd_band

DESCRIPTION
  Map CM otasp activation code to SD band.

DEPENDENCIES
  None

RETURN VALUE
  The SD band that corresponds to the input CM activation code.

SIDE EFFECTS
  None

===========================================================================*/
sd_band_e_type   cmph_map_otasp_act_code_to_sd_band(

    cm_activate_code_e_type   otasp_act_code
        /* OTASP call activation code */
)
{
  /* Map CM OTASP activation code to SD band.
  */

  switch( otasp_act_code )
  {
  #ifdef FEATURE_OTASP
    case CM_ABAND:
    case CM_BBAND:
      return SD_BAND_CELL;

    case CM_ABLOCK:
    case CM_BBLOCK:
    case CM_CBLOCK:
    case CM_DBLOCK:
    case CM_EBLOCK:
    case CM_FBLOCK:
    case CM_PREFERRED:
      return SD_BAND_PCS;

    case CM_ACTIVATE_CODE_BC4_ABAND:
    case CM_ACTIVATE_CODE_BC4_BBAND:
    case CM_ACTIVATE_CODE_BC4_CBAND:
      return SD_BAND_BC4;

    case CM_ACTIVATE_CODE_BC5_ABAND:
    case CM_ACTIVATE_CODE_BC5_BBAND:
    case CM_ACTIVATE_CODE_BC5_CBAND:
    case CM_ACTIVATE_CODE_BC5_DBAND:
    case CM_ACTIVATE_CODE_BC5_EBAND:
    case CM_ACTIVATE_CODE_BC5_FBAND:
    case CM_ACTIVATE_CODE_BC5_GBAND:
    case CM_ACTIVATE_CODE_BC5_HBAND:
      return SD_BAND_BC5;

    case CM_ACTIVATE_CODE_BC6:
      return SD_BAND_BC6;

    case CM_ACTIVATE_CODE_BC7_CBAND:
      return SD_BAND_BC7;

    case CM_ACTIVATE_CODE_BC8:
      return SD_BAND_BC8;

    case CM_ACTIVATE_CODE_BC9:
      return SD_BAND_BC9;

    case CM_ACTIVATE_CODE_BC10_ABAND:
    case CM_ACTIVATE_CODE_BC10_BBAND:
    case CM_ACTIVATE_CODE_BC10_CBAND:
    case CM_ACTIVATE_CODE_BC10_DBAND:
    case CM_ACTIVATE_CODE_BC10_EBAND:
      return SD_BAND_BC10;

    case CM_ACTIVATE_CODE_BC11_ABAND:
    case CM_ACTIVATE_CODE_BC11_BBAND:
    case CM_ACTIVATE_CODE_BC11_CBAND:
    case CM_ACTIVATE_CODE_BC11_DBAND:
    case CM_ACTIVATE_CODE_BC11_EBAND:
    case CM_ACTIVATE_CODE_BC11_FBAND:
      return SD_BAND_BC11;

    case CM_ACTIVATE_CODE_BC12_ABAND:
    case CM_ACTIVATE_CODE_BC12_BBAND:
      return SD_BAND_BC12;

    case CM_ACTIVATE_CODE_BC14_GBLOCK:
      return SD_BAND_BC14;

    case CM_ACTIVATE_CODE_BC15_ABAND:
    case CM_ACTIVATE_CODE_BC15_BBAND:
    case CM_ACTIVATE_CODE_BC15_CBAND:
    case CM_ACTIVATE_CODE_BC15_DBAND:
    case CM_ACTIVATE_CODE_BC15_EBAND:
    case CM_ACTIVATE_CODE_BC15_FBAND:
      return SD_BAND_BC15;

    case CM_ACTIVATE_CODE_BC16_ABAND:
    case CM_ACTIVATE_CODE_BC16_BBAND:
    case CM_ACTIVATE_CODE_BC16_CBAND:
    case CM_ACTIVATE_CODE_BC16_DBAND:
      return SD_BAND_BC16;

    case CM_ACTIVATE_CODE_BC19_ABAND:
    case CM_ACTIVATE_CODE_BC19_BBAND:
    case CM_ACTIVATE_CODE_BC19_CBAND:
      return SD_BAND_BC19;

    case CM_ACTIVATE_CODE_BC18_DBAND:
    case CM_ACTIVATE_CODE_BC18_PSB_BAND:
      return SD_BAND_BC18;

  #endif /* FEATURE_OTASP */


    case CM_OTASP_ACT_CODE_NONE:
      return SD_BAND_PCS;

    default:
      CM_ERR_1( "act_code = %d",otasp_act_code);
      /*lint -save -e527 Unreachable
      **     CM_ERR exits when CM_DEBUG is on
      */
      return SD_BAND_PCS;
      /*lint -restore */
  }


} /* cmph_map_otasp_act_code_to_sd_band() */



/*===========================================================================

FUNCTION cmph_map_otasp_act_code_to_sd_blksys

DESCRIPTION
  Map CM otasp activation code to SD PCS-block/Cellular-system.

DEPENDENCIES
  None

RETURN VALUE
  The SD blksys that corresponds to the input CM activation code.

SIDE EFFECTS
  None

===========================================================================*/
sd_blksys_e_type   cmph_map_otasp_act_code_to_sd_blksys(

    cm_activate_code_e_type   otasp_act_code
        /* OTASP call activation code */
)
{
  /* Map CM OTASP activation code to SD band.
  */

  switch( otasp_act_code )
  {
  #ifdef FEATURE_OTASP
    case CM_ABAND:
        return SD_BLKSYS_CELL_A;

    case CM_BBAND:
        return SD_BLKSYS_CELL_B;

    case CM_ABLOCK:
    case CM_ACTIVATE_CODE_BC5_ABAND:
    case CM_ACTIVATE_CODE_BC6:
    case CM_ACTIVATE_CODE_BC8:
    case CM_ACTIVATE_CODE_BC9:
    case CM_ACTIVATE_CODE_BC10_ABAND:
    case CM_ACTIVATE_CODE_BC11_ABAND:
    case CM_ACTIVATE_CODE_BC12_ABAND:
    case CM_ACTIVATE_CODE_BC15_ABAND:
    case CM_ACTIVATE_CODE_BC16_ABAND:
    case CM_ACTIVATE_CODE_BC19_ABAND:
        return SD_BLKSYS_PCS_A;

    case CM_BBLOCK:
    case CM_ACTIVATE_CODE_BC4_BBAND:
    case CM_ACTIVATE_CODE_BC5_BBAND:
    case CM_ACTIVATE_CODE_BC10_BBAND:
    case CM_ACTIVATE_CODE_BC11_BBAND:
    case CM_ACTIVATE_CODE_BC12_BBAND:
    case CM_ACTIVATE_CODE_BC15_BBAND:
    case CM_ACTIVATE_CODE_BC16_BBAND:
    case CM_ACTIVATE_CODE_BC19_BBAND:
        return SD_BLKSYS_PCS_B;

    case CM_CBLOCK:
    case CM_ACTIVATE_CODE_BC4_CBAND:
    case CM_ACTIVATE_CODE_BC5_CBAND:
    case CM_ACTIVATE_CODE_BC7_CBAND:
    case CM_ACTIVATE_CODE_BC10_CBAND:
    case CM_ACTIVATE_CODE_BC11_CBAND:
    case CM_ACTIVATE_CODE_BC15_CBAND:
    case CM_ACTIVATE_CODE_BC16_CBAND:
    case CM_ACTIVATE_CODE_BC19_CBAND:
        return SD_BLKSYS_PCS_C;

    case CM_DBLOCK:
    case CM_ACTIVATE_CODE_BC5_DBAND:
    case CM_ACTIVATE_CODE_BC10_DBAND:
    case CM_ACTIVATE_CODE_BC11_DBAND:
    case CM_ACTIVATE_CODE_BC15_DBAND:
    case CM_ACTIVATE_CODE_BC16_DBAND:
    case CM_ACTIVATE_CODE_BC18_DBAND:
        return SD_BLKSYS_PCS_D;

    case CM_ACTIVATE_CODE_BC18_PSB_BAND:
        return SD_BLKSYS_PSB;
    case CM_EBLOCK:
    case CM_ACTIVATE_CODE_BC5_EBAND:
    case CM_ACTIVATE_CODE_BC10_EBAND:
    case CM_ACTIVATE_CODE_BC11_EBAND:
    case CM_ACTIVATE_CODE_BC15_EBAND:
        return SD_BLKSYS_PCS_E;

    case CM_FBLOCK:
    case CM_ACTIVATE_CODE_BC5_FBAND:
    case CM_ACTIVATE_CODE_BC11_FBAND:
    case CM_ACTIVATE_CODE_BC15_FBAND:
        return SD_BLKSYS_PCS_F;

    case CM_ACTIVATE_CODE_BC5_GBAND:
    case CM_ACTIVATE_CODE_BC14_GBLOCK:
        return SD_BLKSYS_PCS_G;

    case CM_ACTIVATE_CODE_BC5_HBAND:
        return SD_BLKSYS_PCS_H;

    case CM_PREFERRED:   return SD_BLKSYS_PCS_A;
  #endif /* FEATURE_OTASP */


    case CM_OTASP_ACT_CODE_NONE:
      return SD_BLKSYS_PCS_A;

    default:
      CM_ERR_1( "act_code = %d",otasp_act_code);
      /*lint -save -e527 Unreachable
      **     CM_ERR exits when CM_DEBUG is on
      */
      return SD_BLKSYS_PCS_A;
      /*lint -restore */
  }


} /* cmph_map_otasp_act_code_to_sd_blksys() */



/*===========================================================================

FUNCTION cmph_map_cm_network_sel_mode_pref_to_orig_mode

DESCRIPTION
  This function translates a network selection mode preference to a
  to SD Orig mode.

DEPENDENCIES
  none

RETURN VALUE
  The  SD Orig Mode.

SIDE EFFECTS
  none
===========================================================================*/
sd_ss_orig_mode_e_type  cmph_map_cm_network_sel_mode_pref_to_orig_mode
(
  cm_network_sel_mode_pref_e_type    network_sel_mode_pref
)
{
  sd_ss_orig_mode_e_type  orig_mode;


  switch ( network_sel_mode_pref )
  {

   case CM_NETWORK_SEL_MODE_PREF_AUTOMATIC:
   case CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY:

     orig_mode = SD_SS_ORIG_MODE_NONE;
     break;

   case CM_NETWORK_SEL_MODE_PREF_MANUAL:
   case CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY:
         orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
     break;

   case CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV:
   case CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV:
   case CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV:
         orig_mode = SD_SS_ORIG_MODE_EMERG_ORIG;
     break;

   default:
     CM_MSG_HIGH_1( "Invalid network sel mode pref %d", network_sel_mode_pref );
     orig_mode = SD_SS_ORIG_MODE_NONE;
     break;
  } /* switch ( network_sel_mode_pref ) */

  if(orig_mode != SD_SS_ORIG_MODE_NONE)
  {
    CM_MSG_HIGH_2(" net_sel_mode %d --> orig_mode %d", network_sel_mode_pref, orig_mode);
  }

  return orig_mode;

} /* cmph_map_cm_network_sel_mode_pref_to_orig_mode */

/*===========================================================================

FUNCTION cmph_map_srv_domain_to_sd

DESCRIPTION
  This function translates a service domain to a service domain preference
  type used by the SD20.

DEPENDENCIES
  none

RETURN VALUE
  SD service domain preference.

SIDE EFFECTS
  none

===========================================================================*/
sd_ss_srv_domain_pref_e_type cmph_map_srv_domain_to_sd
(
    sys_srv_domain_e_type  srv_domain
)
{
  sd_ss_srv_domain_pref_e_type mapped_service_domain;

  switch ( srv_domain )
  {
    case SYS_SRV_DOMAIN_CS_ONLY:
      mapped_service_domain = SD_SS_SRV_DOMAIN_PREF_CS_ONLY;
      break;

    case SYS_SRV_DOMAIN_PS_ONLY:
      mapped_service_domain = SD_SS_SRV_DOMAIN_PREF_PS_ONLY;
      break;

    case SYS_SRV_DOMAIN_CS_PS:
      mapped_service_domain = SD_SS_SRV_DOMAIN_PREF_CS_PS;
      break;

    case SYS_SRV_DOMAIN_NONE:
    case SYS_SRV_DOMAIN_NO_SRV:
    case SYS_SRV_DOMAIN_CAMPED:
    case SYS_SRV_DOMAIN_MAX:
    default:
      CM_ERR_1("SC_SGLTE: No mapping for srv_domain=%d", srv_domain);
      mapped_service_domain = SD_SS_SRV_DOMAIN_PREF_NONE;
      break;
  } /* switch ( service_domain_pref ) */

  return mapped_service_domain;
}

/*===========================================================================

FUNCTION cmph_map_cm_srv_domain_pref_to_sd

DESCRIPTION
  This function translates a service domain preference to a service domain
  type used by the SD20.

DEPENDENCIES
  none

RETURN VALUE
  SD service domain preference.

SIDE EFFECTS
  none

===========================================================================*/
sd_ss_srv_domain_pref_e_type cmph_map_cm_srv_domain_pref_to_sd
(
  cm_srv_domain_pref_e_type  srv_domain_pref
)
{
  sd_ss_srv_domain_pref_e_type mapped_service_domain;


  switch ( srv_domain_pref )
  {

   case CM_SRV_DOMAIN_PREF_NONE:
     mapped_service_domain = SD_SS_SRV_DOMAIN_PREF_NONE;
     break;

   case CM_SRV_DOMAIN_PREF_CS_ONLY:
     mapped_service_domain = SD_SS_SRV_DOMAIN_PREF_CS_ONLY;
     break;

   case CM_SRV_DOMAIN_PREF_PS_ONLY:
     mapped_service_domain = SD_SS_SRV_DOMAIN_PREF_PS_ONLY;
     break;

   case CM_SRV_DOMAIN_PREF_CS_PS:
     mapped_service_domain = SD_SS_SRV_DOMAIN_PREF_CS_PS;
     break;

   default:
     CM_MSG_HIGH_1( "Invalid service domain %d", srv_domain_pref);
     mapped_service_domain = SD_SS_SRV_DOMAIN_PREF_CS_ONLY;
     break;
  } /* switch ( service_domain_pref ) */


  return mapped_service_domain;

} /* cmph_map_cm_srv_domain_pref_to_sd */



/*===========================================================================

FUNCTION cmph_map_cm_net_sel_mode_pref_to_camp_pref

DESCRIPTION
  This function translates a network selection mode preference to a camp mode pref
  type used by the SD.

DEPENDENCIES
  none

RETURN VALUE
  SD service domain preference.

SIDE EFFECTS
  none

===========================================================================*/
sd_ss_pref_camp_mode_e_type cmph_map_cm_net_sel_mode_pref_to_camp_pref
(
  cm_network_sel_mode_pref_e_type  cm_net_sel_mode_pref
)
{
  sd_ss_pref_camp_mode_e_type mapped_camp_mode = SD_SS_PREF_CAMP_MODE_OFF;


  switch ( cm_net_sel_mode_pref )
  {

   case CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY:
   case CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY:
     mapped_camp_mode = SD_SS_PREF_CAMP_MODE_ON;
     break;

   case CM_NETWORK_SEL_MODE_PREF_AUTOMATIC:
   case CM_NETWORK_SEL_MODE_PREF_MANUAL:
   case CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV:
   case CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV:
   case CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV:
   case CM_NETWORK_SEL_MODE_PREF_HPLMN_SRCH:
     mapped_camp_mode = SD_SS_PREF_CAMP_MODE_OFF;
     break;

   default:
     CM_MSG_HIGH_1( "Invalid network sel mode pref %d", cm_net_sel_mode_pref );
     mapped_camp_mode = SD_SS_PREF_CAMP_MODE_OFF;
     break;
  } /* switch ( cm_net_sel_mode_pref ) */

  return mapped_camp_mode;

} /* cmph_map_cm_net_sel_mode_pref_to_camp_pref */



/*===========================================================================
FUNCTION cmph_map_sd_srv_domain_pref_to_cm_domain_pref

DESCRIPTION
  This function translates a sd service domain to a cm service domain pref type.

DEPENDENCIES
  none

RETURN VALUE
  CM service domain preference.

SIDE EFFECTS
  none

===========================================================================*/
 cm_srv_domain_pref_e_type cmph_map_sd_srv_domain_pref_to_cm_domain_pref
(
  sd_ss_srv_domain_pref_e_type  srv_domain_pref
)
{
  cm_srv_domain_pref_e_type mapped_service_domain;


  switch ( srv_domain_pref )
  {

   case SD_SS_SRV_DOMAIN_PREF_NONE:
     mapped_service_domain = CM_SRV_DOMAIN_PREF_NONE;
     break;

   case SD_SS_SRV_DOMAIN_PREF_CS_ONLY:
     mapped_service_domain = CM_SRV_DOMAIN_PREF_CS_ONLY;
     break;

   case SD_SS_SRV_DOMAIN_PREF_PS_ONLY:
   case SD_SS_SRV_DOMAIN_PREF_VOLTE:
     mapped_service_domain = CM_SRV_DOMAIN_PREF_PS_ONLY;
     break;

   case SD_SS_SRV_DOMAIN_PREF_CS_PS:
   case SD_SS_SRV_DOMAIN_PREF_CS_VOLTE: /* Not need as of now but added for future use*/
     mapped_service_domain = CM_SRV_DOMAIN_PREF_CS_PS;
     break;

   default:
     CM_ERR_1( "Invalid service domain %d", srv_domain_pref);
     mapped_service_domain = CM_SRV_DOMAIN_PREF_CS_ONLY;
     break;
  } /* switch ( service_domain_pref ) */


  return mapped_service_domain;

} /* cmph_map_sd_srv_domain_pref_to_cm_domain_pref */


/*===========================================================================

FUNCTION cmph_map_cm_acq_order_pref_to_sd

DESCRIPTION
  This function translates a acquisition order preference to a acq. order
  type used by the SD20.

DEPENDENCIES
  none

RETURN VALUE
  SD acq. order preference.

SIDE EFFECTS
  none

===========================================================================*/
sd_ss_acq_order_pref_e_type  cmph_map_cm_acq_order_pref_to_sd
(
  cm_gw_acq_order_pref_e_type   acq_order_pref
)
{
  sd_ss_acq_order_pref_e_type sd_acq_order_pref;

  if(!INRANGE(acq_order_pref,CM_GW_ACQ_ORDER_PREF_AUTOMATIC,CM_GW_ACQ_ORDER_PREF_WCDMA_GSM ))
  {
    CM_ERR_2("invalid acq order pref %d using %d",acq_order_pref, cmph_ptr()->main_stack_info.pref_info.acq_order_pref);
    acq_order_pref = cmph_ptr()->main_stack_info.pref_info.acq_order_pref;
  }

  switch ( acq_order_pref )
  {

    case CM_GW_ACQ_ORDER_PREF_AUTOMATIC:
          sd_acq_order_pref = SD_SS_ACQ_ORDER_PREF_AUTO;
      break;

    case CM_GW_ACQ_ORDER_PREF_WCDMA_GSM:
          sd_acq_order_pref = SD_SS_ACQ_ORDER_PREF_WCDMA_GSM;
          break;

    case CM_GW_ACQ_ORDER_PREF_GSM_WCDMA:
          sd_acq_order_pref = SD_SS_ACQ_ORDER_PREF_GSM_WCDMA;
          break;

   default:
     CM_ERR_1( "Invalid acq_order_pref %d", acq_order_pref);
         sd_acq_order_pref = SD_SS_ACQ_ORDER_PREF_AUTO;
     break;
  } /* switch ( acq_order_pref ) */


  return sd_acq_order_pref;

} /* cmph_map_cm_acq_order_pref_to_sd */

/*===========================================================================
FUNCTION cmph_map_sd_mode_pref_to_sys_mode_mask

DESCRIPTION
  Map SD mode-preference type to SYS mode-mask type.

DEPENDENCIES
  None

RETURN VALUE
  The SYS mode-mask that corresponds to the input SD mode-preference
  or SYS_SYS_MODE_MASK_NONE if not mapped.

SIDE EFFECTS
  None

===========================================================================*/
sys_sys_mode_mask_e_type cmph_map_sd_mode_pref_to_sys_mode_mask(

    sd_ss_mode_pref_e_type    mode_pref
        /* Mode pref to map */
)
{
  sys_sys_mode_mask_e_type    mode_capability = SYS_SYS_MODE_MASK_NONE;

  /* Map SD mode-preference type to SYS mode-mask type.
  */

  if(SD_MODE_CONTAIN (mode_pref, SD_SS_MODE_PREF_CDMA))
  {
    mode_capability =(sys_sys_mode_mask_e_type)
    ((uint64)mode_capability | (uint64)SYS_SYS_MODE_MASK_CDMA);
  }

  if(SD_MODE_CONTAIN (mode_pref, SD_SS_MODE_PREF_HDR))
  {
    mode_capability =(sys_sys_mode_mask_e_type)
    ((uint64)mode_capability | (uint64)SYS_SYS_MODE_MASK_HDR);
  }

  if(SD_MODE_CONTAIN (mode_pref, SD_SS_MODE_PREF_WCDMA))
  {
    mode_capability =(sys_sys_mode_mask_e_type)
    ((uint64)mode_capability | (uint64)SYS_SYS_MODE_MASK_WCDMA);
  }

  if(SD_MODE_CONTAIN (mode_pref, SD_SS_MODE_PREF_GSM))
  {
    mode_capability =(sys_sys_mode_mask_e_type)
    ((uint64)mode_capability | (uint64)SYS_SYS_MODE_MASK_GSM);
  }

  #ifdef FEATURE_LTE
  if(SD_MODE_CONTAIN (mode_pref, SD_SS_MODE_PREF_LTE))
  {
    mode_capability =(sys_sys_mode_mask_e_type)
    ((uint64)mode_capability | (uint64)SYS_SYS_MODE_MASK_LTE);
  }
  #endif

  #ifdef FEATURE_TDSCDMA
  if(SD_MODE_CONTAIN (mode_pref, SD_SS_MODE_PREF_TDS))
  {
    mode_capability =(sys_sys_mode_mask_e_type)
    ((uint64)mode_capability | (uint64)SYS_SYS_MODE_MASK_TDS);
  }
  #endif

  return (mode_capability);
}

/*===========================================================================
FUNCTION cmph_map_sys_mode_mask_to_sd_mode_pref

DESCRIPTION
  Map SYS mode-mask type to SD mode-preference type

DEPENDENCIES
  None

RETURN VALUE
  sd_ss_mode_pref_e_type

SIDE EFFECTS
  None

===========================================================================*/
sd_ss_mode_pref_e_type   cmph_map_sys_mode_mask_to_sd_mode_pref(

       sys_sys_mode_mask_e_type mode_capability
        /* Mode pref to map */
)
{
  sd_ss_mode_pref_e_type    mode_pref = SD_SS_MODE_PREF_NONE;

  /* First, explicit cast on the current value */
  mode_pref = (sd_ss_mode_pref_e_type)mode_capability;

  /* Then adding on GW / GWL bits */
  if ( SD_MODE_CONTAIN (mode_pref, SD_SS_MODE_PREF_WCDMA) &&
       SD_MODE_CONTAIN (mode_pref, SD_SS_MODE_PREF_GSM) )
  {
    mode_pref = SD_MODE_ADD(mode_pref,SD_SS_MODE_PREF_GW);

    #ifdef FEATURE_LTE
    if ( SD_MODE_CONTAIN (mode_pref, SD_SS_MODE_PREF_LTE))
    {
      mode_pref = SD_MODE_ADD(mode_pref,SD_SS_MODE_PREF_GWL);
    }
    #endif
  }

  return mode_pref;
}

/*===========================================================================
FUNCTION cmph_map_sd_mode_pref_to_cm_mode_pref

DESCRIPTION
  Map SD mode-preference type to CM mode-preference type.

DEPENDENCIES
  None

RETURN VALUE
  The CM mode-preference that corresponds to the input SD mode-preference
  or CM_MODE_PREF_MAX if not mapped.

SIDE EFFECTS
  None

===========================================================================*/
cm_mode_pref_e_type cmph_map_sd_mode_pref_to_cm_mode_pref(

    sd_ss_mode_pref_e_type    mode_pref
        /* Mode pref to map */
)
{
  /* Add GW or GWL bit */
  if (SD_MODE_CONTAIN(mode_pref, SD_SS_MODE_PREF_GSM) &&
     SD_MODE_CONTAIN(mode_pref, SD_SS_MODE_PREF_WCDMA)  )
  {
    mode_pref = SD_MODE_ADD(mode_pref, BM(SD_MODE_GW));

    if (SD_MODE_CONTAIN(mode_pref, SD_SS_MODE_PREF_LTE))
    {
      mode_pref = SD_MODE_ADD(mode_pref, BM(SD_MODE_GWL));
    }
  }

  /* Map CM mode-preference type to SD mode-preference type. Note that
  ** unsupported CM mode-preferences are mapped to CM_MODE_PREF_MAX.
  */

  switch( mode_pref )
  {
    case SD_SS_MODE_PREF_AMPS:
      return CM_MODE_PREF_AMPS_ONLY;

    case SD_SS_MODE_PREF_CDMA :
      return CM_MODE_PREF_CDMA_ONLY;

    case SD_SS_MODE_PREF_HDR :
      return CM_MODE_PREF_HDR_ONLY;

    case SD_SS_MODE_PREF_GSM :
      return CM_MODE_PREF_GSM_ONLY;

    case SD_SS_MODE_PREF_WCDMA :
      return CM_MODE_PREF_WCDMA_ONLY;

    case SD_SS_MODE_PREF_DIGITAL :
      return CM_MODE_PREF_DIGITAL_ONLY;

    case SD_SS_MODE_PREF_DIGITAL_LESS_HDR:
      return CM_MODE_PREF_DIGITAL_LESS_HDR_ONLY;

    case SD_SS_MODE_PREF_CDMA_AMPS:
      return CM_MODE_PREF_CDMA_AMPS_ONLY;

    case SD_SS_MODE_PREF_GPS :
      return CM_MODE_PREF_GPS_ONLY;

    case SD_SS_MODE_PREF_ANY :
    case SD_SS_MODE_PREF_ALL_MODES :
      return CM_MODE_PREF_AUTOMATIC;

    case SD_SS_MODE_PREF_CDMA_HDR_GSM_AMPS:
      return CM_MODE_PREF_CDMA_HDR_GSM_AMPS;

    case SD_SS_MODE_PREF_CDMA_GSM_AMPS:
      return CM_MODE_PREF_CDMA_GSM_AMPS;

    case SD_SS_MODE_PREF_CDMA_HDR_GSM_GPS_AMPS:
      return CM_MODE_PREF_CDMA_HDR_GSM_GPS_AMPS;

    case SD_SS_MODE_PREF_CDMA_GSM_GPS_AMPS:
      return CM_MODE_PREF_CDMA_GSM_GPS_AMPS;

    case SD_SS_MODE_PREF_GSM_GPS:
      return CM_MODE_PREF_GSM_GPS;

    case SD_SS_MODE_PREF_WCDMA_GPS:
      return CM_MODE_PREF_WCDMA_GPS;

    case SD_SS_MODE_PREF_GW_GPS:
      return CM_MODE_PREF_GW_GPS;

    case SD_SS_MODE_PREF_HDR_GSM:
      return CM_MODE_PREF_HDR_GSM;

    case SD_SS_MODE_PREF_ANY_BUT_HDR:
    case SD_SS_MODE_PREF_ALL_MODES_BUT_HDR:
      return CM_MODE_PREF_ANY_BUT_HDR;

    case SD_SS_MODE_PREF_ANY_BUT_CDMA_HDR:
      return CM_MODE_PREF_ANY_BUT_CDMA_HDR;

    case SD_SS_MODE_PREF_ANY_BUT_TDS:
    case SD_SS_MODE_PREF_ALL_MODES_BUT_TDS:
      return CM_MODE_PREF_ANY_BUT_TDS;

    case SD_SS_MODE_PREF_ANY_BUT_HDR_TDS:
    case SD_SS_MODE_PREF_ALL_MODES_BUT_HDR_TDS:
      return CM_MODE_PREF_ANY_BUT_HDR_TDS;

    case SD_SS_MODE_PREF_ANY_BUT_LTE_TDS:
    case SD_SS_MODE_PREF_ALL_MODES_BUT_LTE_TDS:
      return CM_MODE_PREF_ANY_BUT_LTE_TDS;

    case SD_SS_MODE_PREF_ANY_BUT_HDR_LTE_TDS:
    case SD_SS_MODE_PREF_ALL_MODES_BUT_HDR_LTE_TDS:
      return CM_MODE_PREF_ANY_BUT_HDR_LTE_TDS;

    case SD_SS_MODE_PREF_GW:
      return CM_MODE_PREF_GSM_WCDMA_ONLY;

    case SD_SS_MODE_PREF_CDMA_AMPS_HDR:
      return CM_MODE_PREF_CDMA_AMPS_HDR_ONLY;

    case SD_SS_MODE_PREF_NONE:
      return CM_MODE_PREF_NONE;

    case SD_SS_MODE_PREF_CDMA_HDR:
      return CM_MODE_PREF_CDMA_HDR_ONLY;

    case SD_SS_MODE_PREF_LTE:
       return CM_MODE_PREF_LTE_ONLY;

    case SD_SS_MODE_PREF_GWL:
       return CM_MODE_PREF_GWL;

    case SD_SS_MODE_PREF_HDR_LTE:
       return CM_MODE_PREF_HDR_LTE_ONLY;

    case SD_SS_MODE_PREF_CDMA_HDR_LTE:
       return CM_MODE_PREF_CDMA_HDR_LTE_ONLY;

    case SD_SS_MODE_PREF_CDMA_HDR_GW:
       return CM_MODE_PREF_CDMA_HDR_GW;

    case SD_SS_MODE_PREF_CDMA_HDR_GW_TDS:
       return CM_MODE_PREF_CDMA_HDR_GW_TDS;

    case SD_SS_MODE_PREF_CDMA_GW:
       return CM_MODE_PREF_CDMA_GW;

    case SD_SS_MODE_PREF_CDMA_GW_TDS:
       return CM_MODE_PREF_CDMA_GW_TDS;

    case SD_SS_MODE_PREF_CDMA_LTE:
       return CM_MODE_PREF_CDMA_LTE_ONLY;

    case SD_SS_MODE_PREF_ANY_BUT_HDR_LTE:
       return CM_MODE_PREF_ANY_BUT_HDR_LTE;

   case SD_SS_MODE_PREF_ANY_BUT_LTE:
       return CM_MODE_PREF_ANY_BUT_LTE;

    case SD_SS_MODE_PREF_CDMA_HDR_GSM:
       return CM_MODE_PREF_CDMA_HDR_GSM;

    case SD_SS_MODE_PREF_CDMA_GSM:
       return CM_MODE_PREF_CDMA_GSM;

   case SD_SS_MODE_PREF_GSM_LTE:
       return CM_MODE_PREF_GSM_LTE;

   case SD_SS_MODE_PREF_CDMA_GSM_LTE:
       return CM_MODE_PREF_CDMA_GSM_LTE;

   case SD_SS_MODE_PREF_HDR_GSM_LTE:
       return CM_MODE_PREF_HDR_GSM_LTE;

   case SD_SS_MODE_PREF_WCDMA_LTE:
       return CM_MODE_PREF_WCDMA_LTE;

   case SD_SS_MODE_PREF_CDMA_WCDMA_LTE:
       return CM_MODE_PREF_CDMA_WCDMA_LTE;

   case SD_SS_MODE_PREF_HDR_WCDMA_LTE:
       return CM_MODE_PREF_HDR_WCDMA_LTE;

    case SD_SS_MODE_PREF_TDS:
       return CM_MODE_PREF_TDS_ONLY;

    case SD_SS_MODE_PREF_TDS_GSM:
       return CM_MODE_PREF_TDS_GSM;

    case SD_SS_MODE_PREF_TDS_GSM_GPS:
       return CM_MODE_PREF_TDS_GSM_GPS;

    case SD_SS_MODE_PREF_TDS_GSM_LTE:
       return CM_MODE_PREF_TDS_GSM_LTE;

    case SD_SS_MODE_PREF_TDS_LTE:
       return CM_MODE_PREF_TDS_LTE;

    case SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE:
       return CM_MODE_PREF_TDS_GSM_WCDMA_LTE;

    case SD_SS_MODE_PREF_TDS_GSM_WCDMA:
       return CM_MODE_PREF_TDS_GSM_WCDMA;

    case SD_SS_MODE_PREF_TDS_GSM_WCDMA_GPS:
       return CM_MODE_PREF_TDS_GSM_WCDMA_GPS;

    case SD_SS_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE:
       return CM_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE;

    case SD_SS_MODE_PREF_CDMA_GSM_WCDMA_LTE:
       return CM_MODE_PREF_CDMA_GSM_WCDMA_LTE;

    case SD_SS_MODE_PREF_TDS_WCDMA:
      return CM_MODE_PREF_TDS_WCDMA;

    case SD_SS_MODE_PREF_TDS_WCDMA_LTE:
      return CM_MODE_PREF_TDS_WCDMA_LTE;

    case SD_SS_MODE_PREF_CDMA_HDR_GSM_TDS_LTE:
       return CM_MODE_PREF_CDMA_HDR_GSM_TDS_LTE;

    case SD_SS_MODE_PREF_GSM_WCDMA_TDS_AMPS:
       return CM_MODE_PREF_GSM_WCDMA_TDS_AMPS;

    case SD_SS_MODE_PREF_GSM_WCDMA_LTE_AMPS:
       return CM_MODE_PREF_GSM_WCDMA_LTE_AMPS;

    case SD_SS_MODE_PREF_GSM_WCDMA_AMPS:
       return CM_MODE_PREF_GSM_WCDMA_AMPS;

    case SD_SS_MODE_PREF_CDMA_HDR_GSM_LTE:
       return CM_MODE_PREF_CDMA_HDR_GSM_LTE;

    case SD_SS_MODE_PREF_HDR_TDS_WCDMA:
       return CM_MODE_PREF_HDR_TDS_WCDMA;

    case SD_SS_MODE_PREF_HDR_TDS_WCDMA_LTE:
       return CM_MODE_PREF_HDR_TDS_WCDMA_LTE;

    case SD_SS_MODE_PREF_ANY_BUT_GSM:
        return CM_MODE_PREF_ANY_BUT_GSM;

    case SD_SS_MODE_PREF_ANY_BUT_GSM_GPS:
        return CM_MODE_PREF_ANY_BUT_GSM_GPS;

    case SD_SS_MODE_PREF_AMPS_CDMA_HDR_WCDMA_TDS:
        return CM_MODE_PREF_AMPS_CDMA_HDR_WCDMA_TDS;

    case SD_SS_MODE_PREF_AMPS_CDMA_HDR_GSM_TDS:
        return CM_MODE_PREF_AMPS_CDMA_HDR_GSM_TDS;

    default:
      CM_ERR_1( "SD mode_pref not mapped to CM mode pref !!! sd = %0x",mode_pref);
      CM_ASSERT(FALSE);
      return CM_MODE_PREF_MAX;

  } /* switch(mode_pref) */

} /* cmph_map_sd_mode_pref_to_cm_mode_pref() */


/*===========================================================================

FUNCTION cmph_map_cm_avoid_type_to_sd_avoid_type

DESCRIPTION
  This function translates a CM avoid type to SD avoid type.

DEPENDENCIES
  none

RETURN VALUE
  The SD Orig Mode.

SIDE EFFECTS
  none
===========================================================================*/
static sd_ss_avoid_sys_e_type    cmph_map_cm_avoid_type_to_sd_avoid_type
(
  cm_ss_avoid_sys_e_type  cm_avoid_type
)
{

  sd_ss_avoid_sys_e_type sd_avoid_type = SD_SS_AVOID_SYS_IDLE;

  switch ( cm_avoid_type )
  {
    case CM_SS_AVOID_SYS_SRV:
      sd_avoid_type = SD_SS_AVOID_SYS_IDLE;
      break;

    case CM_SS_CLR_AVOID_SYS_LIST:
      sd_avoid_type = SD_SS_CLR_AVOID_SYS_LIST;
      break;

    case CM_SS_AVOID_SYS_NONE:
    case CM_SS_AVOID_SYS_MAX:
    default:
     CM_ERR_1( "Invalid avoid_type %d", cm_avoid_type);
     break;

  } /* switch ( cm_avoid_type ) */


  return sd_avoid_type;

} /* cmph_map_cm_avoid_type_to_sd_avoid_type() */

#ifdef FEATURE_DDTM_CNTL

#if  (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))

/*===========================================================================

@FUNCTION cmph_map_nv_ddtm_act_to_cm_ddtm_act_mask

@DESCRIPTION
  This function Maps the NV DDTM act to DDTM_ACT_MASK

@DEPENDENCIES
  none

@RETURNS
  The DDTM act_mask.

@SIDE_EFFECT
  none

@x
===========================================================================*/
static sys_ddtm_act_mask_e_type cmph_map_nv_ddtm_act_to_cm_ddtm_act_mask(

  nv_ddtm_act ddtm_act
  /* The ddtm_act
  */
)
{
  /*lint -e655 */
  /* 655: bit-wise operation uses (compatible) enum's */

  sys_ddtm_act_mask_e_type sys_ddtm_act=SYS_DDTM_ACT_MASK_EMPTY;

  if( ddtm_act & DDTM_ACT_SUPPRESS_L2ACK )
  {
    sys_ddtm_act |= SYS_DDTM_ACT_MASK_SUPPRESS_L2ACK;
  }

  if( ddtm_act & DDTM_ACT_SUPPRESS_REG )
  {
    sys_ddtm_act |= SYS_DDTM_ACT_MASK_SUPPRESS_REG;
  }

  if( ddtm_act & DDTM_ACT_IGN_SO_PAGES )
  {
    sys_ddtm_act |= SYS_DDTM_ACT_MASK_IGN_SO_PAGES;
  }

  if( ddtm_act & DDTM_ACT_SUPPRESS_MO_DBM )
  {
    sys_ddtm_act |= SYS_DDTM_ACT_MASK_SUPPRESS_MO_DBM;
  }

  if( (ddtm_act == DDTM_ACT_ALL)||(sys_ddtm_act == (SYS_DDTM_ACT_MASK_SUPPRESS_L2ACK |
                                                   SYS_DDTM_ACT_MASK_SUPPRESS_REG |
                                                   SYS_DDTM_ACT_MASK_IGN_SO_PAGES |
                                                   SYS_DDTM_ACT_MASK_SUPPRESS_MO_DBM )))
  {
    sys_ddtm_act = SYS_DDTM_ACT_MASK_ALL;
  }

  /*lint +e655 */

  return (sys_ddtm_act );

} /* cmph_map_nv_ddtm_act_to_cm_ddtm_act_mask */

/*===========================================================================

@FUNCTION cmph_map_nv_ddtm_pref_to_cm_ddtm_pref

@DESCRIPTION
  This function Maps the nv DDTM PREF to cm DDTM PREF

@DEPENDENCIES
  none

@RETURN VALUE
  The NV ddtm_act

@x
===========================================================================*/
static   cm_ddtm_pref_e_type  cmph_map_nv_ddtm_pref_to_cm_ddtm_pref(

  nv_ddtm_pref_type         ddtm_pref
  /* CM ddtm pref
  */
)
{
  switch ( ddtm_pref )
  {
    case DDTM_PREF_OFF:
      return( CM_DDTM_PREF_OFF );

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case DDTM_PREF_ON:
    default:
      return( CM_DDTM_PREF_ON );

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  }

} /* cmph_map_nv_ddtm_pref_to_cm_ddtm_pref */

#endif


/*===========================================================================

@FUNCTION cmph_map_cm_ddtm_act_mask_to_nv_ddtm_act

@DESCRIPTION
  This function Maps the cm DDTM_ACT_MASK to NV DDTM act

@DEPENDENCIES
  none

@RETURNS
  The NV ddtm_act

@SIDE_EFFECT
  none

@x
===========================================================================*/
static   nv_ddtm_act cmph_map_cm_ddtm_act_mask_to_nv_ddtm_act(

  sys_ddtm_act_mask_e_type ddtm_act_mask
  /* The ddtm_act
  */
)
{
  nv_ddtm_act ddtm_act = DDTM_ACT_EMPTY;

  /*lint -e655 */
  /* 655: bit-wise operation uses (compatible) enum's */

  if( ddtm_act_mask & SYS_DDTM_ACT_MASK_SUPPRESS_L2ACK )
  {
    ddtm_act |= DDTM_ACT_SUPPRESS_L2ACK ;
  }

  if( ddtm_act_mask & SYS_DDTM_ACT_MASK_SUPPRESS_REG )
  {
    ddtm_act |= DDTM_ACT_SUPPRESS_REG;
  }

  if( ddtm_act_mask & SYS_DDTM_ACT_MASK_IGN_SO_PAGES )
  {
    ddtm_act |= DDTM_ACT_IGN_SO_PAGES;
  }

  if( ddtm_act_mask & SYS_DDTM_ACT_MASK_SUPPRESS_MO_DBM )
  {
    ddtm_act |= DDTM_ACT_SUPPRESS_MO_DBM;
  }

  if( (ddtm_act_mask == SYS_DDTM_ACT_MASK_ALL )||(ddtm_act == (DDTM_ACT_SUPPRESS_L2ACK  |
                                                   DDTM_ACT_SUPPRESS_REG |
                                                   DDTM_ACT_SUPPRESS_MO_DBM |
                                                   DDTM_ACT_IGN_SO_PAGES )))
  {
    ddtm_act = DDTM_ACT_ALL;
  }

  /*lint +e655 */

  return (ddtm_act );

 } /* cmph_map_cm_ddtm_act_mask_to_nv_ddtm_act */

/*===========================================================================

@FUNCTION cmph_map_cm_ddtm_pref_to_nv_ddtm_pref

@DESCRIPTION
  This function Maps the cm DDTM PREF to NV DDTM PREF

@DEPENDENCIES
  none

@RETURNS
  The NV ddtm_act

@SIDE_EFFECT
  none

@x
===========================================================================*/
static   nv_ddtm_pref_type cmph_map_cm_ddtm_pref_to_nv_ddtm_pref(

  cm_ddtm_pref_e_type         ddtm_pref
  /* CM ddtm pref
  */
)
{
  switch ( ddtm_pref )
  {
    case CM_DDTM_PREF_OFF:
      return( DDTM_PREF_OFF );

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_DDTM_PREF_ON:
    default:
      return( DDTM_PREF_ON );

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  }

} /* cmph_map_cm_ddtm_pref_to_nv_ddtm_pref */

#endif

/*===========================================================================

FUNCTION cmph_map_cm_rat_acq_order_pref_to_sd

DESCRIPTION
  This function translates a CM acquisition order pref to sd acquisition order

DEPENDENCIES
  none

RETURN VALUE
  SD service domain preference.

SIDE EFFECTS
  none

===========================================================================*/
sd_rat_acq_order_s_type cmph_map_cm_rat_acq_order_pref_to_sd
(
  const cm_acq_pri_order_pref_s_type  *acq_order_pref_ptr
)
{
  sd_rat_acq_order_s_type sd_rat_acq_order;
  uint8 i=0;

  memset(&sd_rat_acq_order,0,sizeof(sd_rat_acq_order_s_type));

  if(acq_order_pref_ptr != NULL)
  {
    sd_rat_acq_order.version = 0xFF;
    sd_rat_acq_order.num_rat = acq_order_pref_ptr->num_rat;
    for(i=0; i< SYS_MAX_ACQ_PREF_RAT_LIST_NUM; i++)
    {
      sd_rat_acq_order.acq_sys_mode[i] = acq_order_pref_ptr->acq_order[i];
    }
  }
  else
  {
    sd_rat_acq_order.version = 0xFF;
    sd_rat_acq_order.num_rat = 0;
  }

  return sd_rat_acq_order;

} /* cmph_map_cm_rat_acq_order_pref_to_sd */

/*===========================================================================

FUNCTION cmph_map_ui_base_csg_sel_config_to_sys

DESCRIPTION
  This function translates ui_base_csg_selection_config_e_type
  to sys_csg_selection_config_e_type

DEPENDENCIES
  none

RETURN VALUE
  sys_csg_selection_config_e_type

SIDE EFFECTS
  none

===========================================================================*/
sys_csg_selection_config_e_type cmph_map_ui_base_csg_sel_config_to_sys
(
  ui_base_csg_selection_config_e_type  ui_base_csg
)
{
  switch ( ui_base_csg )
  {
    case UI_BASE_SYS_CSG_SELECTION_CONFIG_NONE:
      return( SYS_CSG_SELECTION_CONFIG_NONE );

    case UI_BASE_SYS_CSG_SELECTION_CONFIG_1:
      return( SYS_CSG_SELECTION_CONFIG_1 );
      
    case UI_BASE_SYS_CSG_SELECTION_CONFIG_MAX:
    default:
      return( SYS_CSG_SELECTION_CONFIG_MAX );
  }
}  /* cmph_map_ui_base_csg_sel_config_to_sys */

/*===========================================================================
FUNCTION cmph_is_mode_cap_mask

DESCRIPTION
  To determine if cmph mode_capability contains the specified sys mode mask.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if sys mode mask is part of cmph mode_capability.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
boolean  cmph_is_mode_cap_mask(
    sys_sys_mode_mask_e_type    mode_mask
)
{
  return ( (sys_sys_mode_mask_e_type)
           ((uint64)(cmph_ptr()->mode_capability) & (uint64)mode_mask)
           != SYS_SYS_MODE_MASK_NONE);
}

/*===========================================================================

FUNCTION cm_is_valid_state_for_sub_proc

DESCRIPTION
  Checks if modem state allows subscription processing. Otherwise, CM needs to
  defer/buffer sub update.

DEPENDENCIES
  none

RETURN VALUE
  TRUE if modem is able to handle sub update
  FALSE otherwise, in which CM needs to be buffer SUB update.

SIDE EFFECTS
  none

===========================================================================*/

boolean cm_is_valid_state_for_sub_proc(sys_oprt_mode_e_type oprt_mode)
{
  CM_MSG_HIGH_1( "Attempt sub proc in %d mode", oprt_mode );

  if(oprt_mode == SYS_OPRT_MODE_ONLINE ||
     oprt_mode == SYS_OPRT_MODE_LPM ||
     oprt_mode == SYS_OPRT_MODE_PWROFF ||
     oprt_mode == SYS_OPRT_MODE_PSEUDO_ONLINE)
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

/*===========================================================================

FUNCTION is_valid_oprt_mode_switch

DESCRIPTION
  Check whether a given operating mode switch is legal.

DEPENDENCIES
  none

RETURN VALUE
  TRUE if operating mode switch is legal, FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
static boolean is_valid_oprt_mode_switch(

    sys_oprt_mode_e_type    from_oprt_mode,
        /* from this operating mode */

    sys_oprt_mode_e_type    to_oprt_mode
        /* to this operating mode */
)
{
  unsigned int i;
      /* loop counter */

  /* Table specifying valid operating mode switches
  */
  static const struct {

      sys_oprt_mode_e_type    from_oprt_mode;
          /* from operating mode */

      sys_oprt_mode_e_type    to_oprt_mode;
          /* to operating mode */

  } oprt_mode_tbl[] = {

        /* from oprt mode */         /* to oprt mode */
      { SYS_OPRT_MODE_PWROFF,        SYS_OPRT_MODE_OFFLINE_CDMA },
      { SYS_OPRT_MODE_PWROFF,        SYS_OPRT_MODE_ONLINE       },
      { SYS_OPRT_MODE_PWROFF,        SYS_OPRT_MODE_PSEUDO_ONLINE},
      { SYS_OPRT_MODE_PWROFF,        SYS_OPRT_MODE_OFFLINE_AMPS },
      { SYS_OPRT_MODE_PWROFF,        SYS_OPRT_MODE_OFFLINE      },
      { SYS_OPRT_MODE_PWROFF,        SYS_OPRT_MODE_LPM          },
      { SYS_OPRT_MODE_PWROFF,        SYS_OPRT_MODE_FTM          },

      { SYS_OPRT_MODE_OFFLINE_CDMA,  SYS_OPRT_MODE_PWROFF       },
      { SYS_OPRT_MODE_OFFLINE_CDMA,  SYS_OPRT_MODE_RESET        },
      { SYS_OPRT_MODE_OFFLINE_CDMA,  SYS_OPRT_MODE_RESET_MODEM  },
      { SYS_OPRT_MODE_OFFLINE_CDMA,  SYS_OPRT_MODE_OFFLINE_AMPS },
      { SYS_OPRT_MODE_OFFLINE_CDMA,  SYS_OPRT_MODE_OFFLINE      },

      { SYS_OPRT_MODE_OFFLINE_AMPS,  SYS_OPRT_MODE_PWROFF       },
      { SYS_OPRT_MODE_OFFLINE_AMPS,  SYS_OPRT_MODE_RESET        },
      { SYS_OPRT_MODE_OFFLINE_AMPS,  SYS_OPRT_MODE_OFFLINE_CDMA },
      { SYS_OPRT_MODE_OFFLINE_AMPS,  SYS_OPRT_MODE_OFFLINE      },

      { SYS_OPRT_MODE_OFFLINE,       SYS_OPRT_MODE_PWROFF       },
      { SYS_OPRT_MODE_OFFLINE,       SYS_OPRT_MODE_RESET        },
      { SYS_OPRT_MODE_OFFLINE,       SYS_OPRT_MODE_RESET_MODEM  },
      { SYS_OPRT_MODE_OFFLINE,       SYS_OPRT_MODE_OFFLINE_CDMA },
      { SYS_OPRT_MODE_OFFLINE,       SYS_OPRT_MODE_OFFLINE_AMPS },

      { SYS_OPRT_MODE_ONLINE,        SYS_OPRT_MODE_OFFLINE_CDMA },
      { SYS_OPRT_MODE_ONLINE,        SYS_OPRT_MODE_OFFLINE_AMPS },
      { SYS_OPRT_MODE_ONLINE,        SYS_OPRT_MODE_OFFLINE      },
      { SYS_OPRT_MODE_ONLINE,        SYS_OPRT_MODE_LPM          },
      { SYS_OPRT_MODE_ONLINE,        SYS_OPRT_MODE_PWROFF       },
      { SYS_OPRT_MODE_ONLINE,        SYS_OPRT_MODE_PSEUDO_ONLINE},
      { SYS_OPRT_MODE_ONLINE,        SYS_OPRT_MODE_RESET        },
      #ifdef CM_GW_SUPPORTED
      #ifdef FEATURE_TC
      { SYS_OPRT_MODE_ONLINE,        SYS_OPRT_MODE_NET_TEST_GW  },

      { SYS_OPRT_MODE_NET_TEST_GW,   SYS_OPRT_MODE_PWROFF       },
      { SYS_OPRT_MODE_NET_TEST_GW,   SYS_OPRT_MODE_ONLINE       },
      { SYS_OPRT_MODE_NET_TEST_GW,   SYS_OPRT_MODE_LPM          },
      #endif /* FEATURE_TC */
      #endif /* FEATURE_WCDMA, FEATURE_GSM */

      { SYS_OPRT_MODE_ONLINE,        SYS_OPRT_MODE_FTM          },
      { SYS_OPRT_MODE_FTM,           SYS_OPRT_MODE_ONLINE       },
      { SYS_OPRT_MODE_FTM,           SYS_OPRT_MODE_PSEUDO_ONLINE},
      { SYS_OPRT_MODE_FTM,           SYS_OPRT_MODE_PWROFF       },
      { SYS_OPRT_MODE_FTM,           SYS_OPRT_MODE_OFFLINE_CDMA },
      { SYS_OPRT_MODE_FTM,           SYS_OPRT_MODE_OFFLINE      },
      { SYS_OPRT_MODE_FTM,           SYS_OPRT_MODE_LPM          },

      { SYS_OPRT_MODE_LPM,           SYS_OPRT_MODE_OFFLINE_CDMA },
      { SYS_OPRT_MODE_LPM,           SYS_OPRT_MODE_OFFLINE_AMPS },
      { SYS_OPRT_MODE_LPM,           SYS_OPRT_MODE_OFFLINE      },
      { SYS_OPRT_MODE_LPM,           SYS_OPRT_MODE_ONLINE       },
      { SYS_OPRT_MODE_LPM,           SYS_OPRT_MODE_PSEUDO_ONLINE},
      { SYS_OPRT_MODE_LPM,           SYS_OPRT_MODE_PWROFF       },
      { SYS_OPRT_MODE_LPM,           SYS_OPRT_MODE_FTM          },

      { SYS_OPRT_MODE_PSEUDO_ONLINE, SYS_OPRT_MODE_OFFLINE_CDMA },
      { SYS_OPRT_MODE_PSEUDO_ONLINE, SYS_OPRT_MODE_OFFLINE_AMPS },
      { SYS_OPRT_MODE_PSEUDO_ONLINE, SYS_OPRT_MODE_OFFLINE      },
      { SYS_OPRT_MODE_PSEUDO_ONLINE, SYS_OPRT_MODE_LPM          },
      { SYS_OPRT_MODE_PSEUDO_ONLINE, SYS_OPRT_MODE_PWROFF       },
      { SYS_OPRT_MODE_PSEUDO_ONLINE, SYS_OPRT_MODE_ONLINE       }

  };

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( INRANGE((int)from_oprt_mode,
                     (int)SYS_OPRT_MODE_NONE,
                     (int)(SYS_OPRT_MODE_MAX-1)));
  CM_ASSERT( BETWEEN(to_oprt_mode, SYS_OPRT_MODE_NONE, SYS_OPRT_MODE_MAX) );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Switching into the same operating mode is always valid.
  */
  if( to_oprt_mode == from_oprt_mode )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If receiving the reset modem operation mode request,and the feature
  ** FEATURE_OPRT_MODE_MODEM_RESET is undefined, return .
  */
  if( to_oprt_mode == SYS_OPRT_MODE_RESET_MODEM )
  {
     #ifndef FEATURE_OPRT_MODE_MODEM_RESET
     return FALSE;
     #endif
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check for a match in the oprt_mode_tbl to decide
  ** whether this is a valid operating mode switch.
  */
  for( i=0; i < ARR_SIZE(oprt_mode_tbl); i++ )
  {
    if( oprt_mode_tbl[i].from_oprt_mode == from_oprt_mode &&
        oprt_mode_tbl[i].to_oprt_mode   == to_oprt_mode )
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, there is no match in the
  ** operating mode table - return FALSE.
  */
  return FALSE;

} /* is_valid_oprt_mode_switch() */



/*===========================================================================

FUNCTION cmph_in_valid_oprt_mode

DESCRIPTION
  This function checks whether a phone command can be accepted based on the
  operating mode.

DEPENDENCIES
  None

RETURN VALUE
  TRUE  = The phone command can be accepted based on the operating mode.
  FALSE = The phone command can not be accepted based on the operating mode.

SIDE EFFECTS
  None
===========================================================================*/
static boolean cmph_in_valid_oprt_mode
(
  const cmph_s_type   *ph_ptr
)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if((ph_ptr->oprt_mode == SYS_OPRT_MODE_ONLINE)||
      (ph_ptr->oprt_mode == SYS_OPRT_MODE_PSEUDO_ONLINE)
    )
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
} /* cmph_in_valid_oprt_mode() */


#ifdef FEATURE_HICPS_STACK_SYNC_UP
/*===========================================================================

FUNCTION cmph_activate_hicps_gwl_avoid_timer

DESCRIPTION
  This function activates the GWL avoidance timer.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void cmph_activate_hicps_gwl_avoid_timer( void )
{

  cmph_s_type  *ph_ptr       = cmph_ptr();

  CM_MSG_HIGH_2( "HICPS: cmph_gwl_avoid_enable %d, avoidance timer %ds",
                 cm_gwl_avoidance_timers.cmph_gwl_avoid_enable, cm_gwl_avoidance_timers.cmph_gwl_avoid_timer_value );

  if( cm_gwl_avoidance_timers.cmph_gwl_avoid_enable == TRUE )
  {
    ph_ptr->hicps_gwl_avoid_timer_active = TRUE;

    ph_ptr->hicps_gwl_avoid_uptime       = time_get_uptime_secs() +
                             cm_gwl_avoidance_timers.cmph_gwl_avoid_timer_value;
  }

} /* cmph_activate_hicps_gwl_avoid_timer */

/*===========================================================================

FUNCTION cmph_deactivate_hicps_gwl_avoid_timer

DESCRIPTION
  This function deactivates the GW avoidance timer.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void cmph_deactivate_hicps_gwl_avoid_timer( void )
{

  cmph_s_type  *ph_ptr       = cmph_ptr();

  ph_ptr->hicps_gwl_avoid_timer_active = FALSE;
  ph_ptr->hicps_gwl_avoid_uptime       = 0;
  CM_MSG_HIGH_0("HICPS: Deactivating GWL avoidance timer");

} /* cmph_deactivate_hicps_gwl_avoid_timer */

#endif /* FEATURE_HICPS_STACK_SYNC_UP */

/*===========================================================================

FUNCTION cmph_activate_ps_service_req_timer

DESCRIPTION
  This function activates the PS service request timer.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void cmph_activate_ps_service_req_timer(

     cm_ss_e_type     ss
       /* stack on which to activate ps service req timer */
)
/*lint -esym(715,ss) */
{
  cmph_s_type  *ph_ptr       = cmph_ptr();

  if( ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
  {
    ph_ptr->hybr_2_stack_info.ps_service_req_timer_active = TRUE;

  /* The uptime is set to 140 seconds in the future.  This is based on the
  ** worst case scenario - mobility managment (GSM) timers expiring after
  ** 120 seconds.
  */
    ph_ptr->hybr_2_stack_info.ps_service_req_uptime
                                        = time_get_uptime_secs() + 140;
  }
  else
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 )
  {
      ph_ptr->hybr_3_stack_info.ps_service_req_timer_active = TRUE;

      /* The uptime is set to 140 seconds in the future.  This is based on the
      ** worst case scenario - mobility managment (GSM) timers expiring after
      ** 120 seconds.
      */
      ph_ptr->hybr_3_stack_info.ps_service_req_uptime
                                       = time_get_uptime_secs() + 140;
  }
  else
  #endif
  {
    ph_ptr->ps_service_req_timer_active = TRUE;

    /* The uptime is set to 140 seconds in the future.  This is based on the
    ** worst case scenario - mobility managment (GSM) timers expiring after
    ** 120 seconds.
    */
    ph_ptr->ps_service_req_uptime       = time_get_uptime_secs() + 140;
  }

} /* cmph_activate_ps_service_req_timer */
/*lint +esym(715,ss) */


/*===========================================================================

FUNCTION cmph_deactivate_ps_service_req_timer

DESCRIPTION
  This function deactivates the PS service request timer.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void cmph_deactivate_ps_service_req_timer(

       cm_ss_e_type      ss
          /* Stack whose timers need to deactivated */
)
/*lint -esym(715,ss) */
{

  cmph_s_type  *ph_ptr       = cmph_ptr();

  if(ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
  {
    ph_ptr->hybr_2_stack_info.ps_service_req_timer_active = FALSE;
    ph_ptr->hybr_2_stack_info.ps_service_req_uptime       = 0;
  }
  else
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(ss == CM_SS_HYBR_3 )
  {
      ph_ptr->hybr_3_stack_info.ps_service_req_timer_active = FALSE;
      ph_ptr->hybr_3_stack_info.ps_service_req_uptime       = 0;

  }
  else
  #endif
  {
    ph_ptr->ps_service_req_timer_active = FALSE;
    ph_ptr->ps_service_req_uptime       = 0;
  }

} /* cmph_deactivate_ps_service_req_timer */
/*lint +esym(715,ss) */


/*===========================================================================

FUNCTION cmph_info_alloc

DESCRIPTION
 Allocate a phone info buffer.

DEPENDENCIES
  none

RETURN VALUE
  Pointer to allocated phone info buffer.

SIDE EFFECTS
  none

===========================================================================*/
cm_ph_info_s_type  *cmph_info_alloc( void )
{
  cm_ph_info_s_type  *ph_info_ptr = NULL;

  /*
  ** Dynamically allocate a ph info object
  */
  ph_info_ptr = (cm_ph_info_s_type *)cm_mem_malloc
                                     (sizeof(cm_ph_info_s_type));
    ph_info_ptr->csg_id  = SYS_CSG_ID_INVALID;
    ph_info_ptr->csg_rat = SYS_RAT_NONE;

  return ph_info_ptr;

} /* cmph_info_alloc() */

/*===========================================================================

FUNCTION cm_pref_ptr

DESCRIPTION
  This function will fetch the pointer to cm_pref_s_type.

DEPENDENCIES
  None.

RETURN VALUE
  cm_pref_s_type* - Pointer to cm_pref_s_type.
  Note! Cannot be NULL

SIDE EFFECTS
  None.
===========================================================================*/
cm_pref_s_type*           cm_pref_ptr (void)
{
  cm_pref_s_type  *pref_ptr = NULL;

  /* Dynamically allocate a cm pref object */
  if (!(pref_ptr = (cm_pref_s_type *)cm_mem_malloc
                                     (sizeof(cm_pref_s_type)))
     )
  {
    sys_err_fatal_null_ptr_exception();
  }

  return pref_ptr;
}

/*===========================================================================

FUNCTION cmph_event_per_subs

DESCRIPTION
  Notify the client list of a specified phone event.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_event_per_subs(

    cmph_s_type     *ph_ptr,
        /* pointer to a phone object.
        */

    cm_ph_event_e_type      ph_event,
        /* notify client list of this phone event */

    cm_ss_e_type            ss
)
/*lint -esym(715,ph_ptr) */
{
  cm_ph_info_s_type *ph_info_ptr = cmph_info_alloc();
      /* Allocate phone info buffer */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( BETWEEN(ph_event, CM_PH_EVENT_NONE, CM_PH_EVENT_MAX) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Copy phone state information into
  ** allocated buffer.
  */
  (void) cmph_info_get( ph_info_ptr, ss );

  /* Update is_in_use_reported as well */
  ph_ptr->is_in_use_reported = ph_ptr->is_in_use;

  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  ph_ptr->hybr2_is_in_use_reported = ph_ptr->hybr2_is_in_use;

  #if defined FEATURE_MMODE_SXLTE_G
  ph_ptr->hybr3_is_in_use_reported = ph_ptr->hybr3_is_in_use;
  #endif
  #endif

  /*
  ** If the phone is in the process of releasing the last call
  ** but not done yet, we still want to set the "in_use" flag
  ** to false.
  **
  ** For GSM/WCDMA call, it might take a while before we get
  ** confirmation of call release from network/lower layers.
  **
  ** This delay might cause phone to look busy while from user
  ** perspective, call has been ended.
  **
  */

  if(cmph_is_dsda())
  {
    if(cmcall_check_each_call_in_call_state_ss(CM_CALL_STATE_IDLE,
                                               cmph_map_cm_ss_to_subs(ss)))
    {
      #if( defined (FEATURE_GPSONE_MSBASED) || defined (FEATURE_GPSONE) )
      if( !cmpd_is_session_active( cmpd_ptr(CMPD_SESSION_OBJ_MAIN)) &&
          !cmpd_is_session_active( cmpd_ptr(CMPD_SESSION_OBJ_DMOD)) )

      #endif /* FEATURE_GPSONE */
      {
        ph_info_ptr->is_in_use= FALSE;

        /* Keep track of clients's knowledge of phone's in_use state in ph
            ** obj
            */
        cmph_set_is_in_use_reported(ss, FALSE);
      }
    }
  }
  else if(cmcall_check_each_call_in_call_state(CM_CALL_STATE_IDLE))
  {
    #if( defined (FEATURE_GPSONE_MSBASED) || defined (FEATURE_GPSONE) )
    if( !cmpd_is_session_active( cmpd_ptr(CMPD_SESSION_OBJ_MAIN)) &&
        !cmpd_is_session_active( cmpd_ptr(CMPD_SESSION_OBJ_DMOD)) )

    #endif /* FEATURE_GPSONE */
    {
      ph_info_ptr->is_in_use= FALSE;

      /* Keep track of clients's knowledge of phone's in_use state in ph
      ** obj
      */
      cmph_set_is_in_use_reported(CM_SS_MAIN, FALSE);
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the is_event_process flag to true before sending event to clients.
  */
  ph_ptr->is_event_process = TRUE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Notify the client list of the phone event.
  */
  cmclient_list_ph_event_ntfy( ph_event, ph_info_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the is_event_process flag to false after PH events have been sent to
  ** clients.
  */
  ph_ptr->is_event_process = FALSE;

  /* Deallocate the memory after sending the ph event. */
  cm_mem_free(ph_info_ptr);

} /* cmph_event_per_subs() */
/*lint +esym(715,ph_ptr) */

/*===========================================================================

FUNCTION cmph_event

DESCRIPTION
  Notify the client list of a specified phone event.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_event(

    cmph_s_type           *ph_ptr,
        /* pointer to a phone object.
        */

    cm_ph_event_e_type    ph_event
        /* notify client list of this phone event */
)
{
  cmph_event_per_subs(ph_ptr, ph_event, CM_SS_MAIN);
        /* notify client list of this phone event */

  if(cmph_is_msim())
  {
    if(!cmph_is_sxlte())
    {
    cmph_event_per_subs(ph_ptr, ph_event, CM_SS_HYBR_2);
    }
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if((cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY) ||
      (cmph_is_sxlte()))
    {
      cmph_event_per_subs(ph_ptr, ph_event, CM_SS_HYBR_3);
    }
    #endif
  }

#if defined(FEATURE_QSH_EVENT_METRIC)
  /* send evt to QSH */
  cmdbg_chk_and_update_srv_metrics(SYS_MODEM_AS_ID_1,CM_QSH_METRICS_CHG_TYPE_PH_EVENT);
#endif
}




/*===========================================================================

FUNCTION cmph_update_act_id_priority_queue_obj_with_1_call_plus

DESCRIPTION
  Updates the priority queue object corresponding to act_id passed
  sets
  1. act_update_reas asact_end
  2. pref_term as call_1_plus.
  3. orig_mode_uptime is set to curr_uptime + 4 seconds
  4. act_priority to act_end

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
void cmph_update_act_id_priority_queue_obj_with_1_call_plus(

  cm_ss_e_type              ss,
    /* SS to use for origination, if hybrid operation is changed,
    ** then ss= CM_SS_MAX.
    */

  cm_act_id_type            act_id
      /* The unique id of the activity */

)
{

  cm_orig_q_s_type  *ph_orig_ptr;
  /* Search the ptr
  */

  CM_ASSERT(BETWEEN(ss, CM_SS_NONE, CM_SS_MAX ) );

  ss = (ss == CM_SS_MAX ? CM_SS_MAIN : ss);

  ph_orig_ptr = cmtask_orig_para_search_act_id(  ss, act_id );

  if( ph_orig_ptr != NULL )
  {
    /* Delete the priority object identified by act_id */
    ph_orig_ptr->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_END;
    ph_orig_ptr->orig->orig_pref_term  = CM_PREF_TERM_CM_1_CALL_PLUS;

    ph_orig_ptr->orig->orig_mode_uptime = time_get_uptime_secs() +
                                                           CMPH_HOLD_MODE_PREF_TIME;
    ph_orig_ptr->orig->act_priority   = CM_ACT_PRIORITY_END;
  }

  return;

} /* cmph_update_act_id_priority_queue_obj_with_1_call_plus */



/*===========================================================================

FUNCTION cmph_delete_update_orig_mode

DESCRIPTION
  Delete the origination parameters from the priority queue.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
void cmph_delete_update_orig_mode(

  cm_ss_e_type              ss,
    /* SS to use for origination, if hybrid operation is changed,
    ** then ss= CM_SS_MAX.
    */

  cm_act_id_type            act_id,
      /* The unique id of the activity */

  boolean                   force_ph_pref_if_top
      /* If the top ptr is the phone ptr force the phone preferences */

)
{

  cm_orig_q_s_type  *ph_orig_ptr;
  /* Search the ptr
  */
  cm_mode_pref_e_type    saved_top_q_user_mode_pref = CM_MODE_PREF_NONE;
  cm_band_pref_e_type    saved_top_q_band_pref = CM_BAND_PREF_NONE;
  sys_lte_band_mask_e_type saved_top_q_lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
  cm_band_pref_e_type    saved_top_q_tds_band_pref = CM_BAND_PREF_NONE;
  cmph_s_type  *ph_ptr = cmph_ptr();
  sys_modem_as_id_e_type asubs_id = SYS_MODEM_AS_ID_NONE;

  CM_ASSERT(BETWEEN(ss, CM_SS_NONE, CM_SS_MAX ) );

  ss = (ss == CM_SS_MAX ? CM_SS_MAIN : ss);

  ph_orig_ptr = cmtask_orig_para_search_act_id(  ss, act_id );

  if( ph_orig_ptr != NULL )
  {
    asubs_id = cmph_map_cm_ss_to_subs(ss); 
    saved_top_q_user_mode_pref = ph_orig_ptr->orig->user_mode_pref;
    saved_top_q_band_pref = ph_orig_ptr->orig->orig_band_pref;
    saved_top_q_lte_band_pref = ph_orig_ptr->orig->orig_lte_band_pref;
    saved_top_q_tds_band_pref = ph_orig_ptr->orig->orig_tds_band_pref;
    
    /* Delete the priority object identified by act_id */
    if( cmtask_orig_para_delete( ss, ph_orig_ptr, TRUE ) )
    {
      ph_orig_ptr = cmtask_orig_para_get_top(ss);
      if( ph_orig_ptr != NULL &&
          ( ph_orig_ptr->orig->act_id != (cm_act_id_type) cmph_ptr() || force_ph_pref_if_top )
        )
      {
        if((ph_orig_ptr->act_type == CM_ACT_TYPE_PH_OBJ)&&
             cmph_ptr()->is_pref_change_pending[asubs_id])
        {
            /* Compare the saved top deleted OBJ with the PH OBJ
                      ** to determine the is_ps_detach_required. */
          ph_ptr->is_ps_detach_required = 
           cmph_cmd_evaluate_is_ps_detach_required(
            asubs_id,
            saved_top_q_user_mode_pref,
            saved_top_q_band_pref,
            saved_top_q_lte_band_pref,
            saved_top_q_tds_band_pref,
            ph_orig_ptr->orig->orig_mode_pref,
            ph_orig_ptr->orig->orig_band_pref,
            ph_orig_ptr->orig->orig_lte_band_pref,
            ph_orig_ptr->orig->orig_tds_band_pref);
            cmph_ptr()->is_pref_change_pending[asubs_id] = FALSE;
            CM_MSG_HIGH_0("Set is_pref_change_pending to FALSE.");
        }
        cmph_force_orig_mode_on_the_fly(ss);
      }
    }
  }

  return;

} /* cmph_delete_update_orig_mode */

/*===========================================================================

FUNCTION cmph_delete_and_evaluate_ps_detach

DESCRIPTION
  Delete the origination parameters from the priority queue and re evaluate the pref changes

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
void cmph_delete_and_evaluate_ps_detach(

  cm_ss_e_type              ss,
    /* SS to use for origination, if hybrid operation is changed,
    ** then ss= CM_SS_MAX.
    */
  cm_orig_q_s_type          *ph_orig_ptr
    /* The buffer to delete from the queue
    */
)
{

  cm_orig_q_s_type  *ph_top_ptr;
  /* Search the ptr
  */
  cm_mode_pref_e_type    saved_top_q_user_mode_pref = CM_MODE_PREF_NONE;
  cm_band_pref_e_type    saved_top_q_band_pref = CM_BAND_PREF_NONE;
  sys_lte_band_mask_e_type    saved_top_q_lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
  cm_band_pref_e_type    saved_top_q_tds_band_pref = CM_BAND_PREF_NONE;
  sys_modem_as_id_e_type asubs_id = cmph_map_cm_ss_to_subs(ss);

  if( ph_orig_ptr != NULL )
  {
    
    saved_top_q_user_mode_pref = ph_orig_ptr->orig->user_mode_pref;
    saved_top_q_band_pref = ph_orig_ptr->orig->orig_band_pref;
    saved_top_q_lte_band_pref = ph_orig_ptr->orig->orig_lte_band_pref;
    saved_top_q_tds_band_pref = ph_orig_ptr->orig->orig_tds_band_pref;
    
    /* Delete the priority object */
    if( cmtask_orig_para_delete( ss, ph_orig_ptr, TRUE ) )
    {
      ph_top_ptr = cmtask_orig_para_get_top(ss);
      if( ph_top_ptr != NULL )
      {
        if((ph_top_ptr->act_type == CM_ACT_TYPE_PH_OBJ) &&
             cmph_ptr()->is_pref_change_pending[asubs_id])
        {
            /* Compare the saved top deleted OBJ with the PH OBJ
                      ** to determine the is_ps_detach_required. */
           cmph_ptr()->is_ps_detach_required = 
           cmph_cmd_evaluate_is_ps_detach_required(
            asubs_id,
            saved_top_q_user_mode_pref,
            saved_top_q_band_pref,
            saved_top_q_lte_band_pref,
            saved_top_q_tds_band_pref,
            ph_top_ptr->orig->orig_mode_pref,
            ph_top_ptr->orig->orig_band_pref,
            ph_top_ptr->orig->orig_lte_band_pref,
            ph_top_ptr->orig->orig_tds_band_pref);
            
            cmph_ptr()->is_pref_change_pending[asubs_id] = FALSE;
            CM_MSG_HIGH_0("Set is_pref_change_pending to FALSE.");
        }
      }
    }
  }

  return;

} /* cmph_delete_and_evaluate_ps_detach */

#ifdef FEATURE_CM_CFM_AVAILABLE
/*===========================================================================

FUNCTION cmph_cfm_thermal_event_proc

DESCRIPTION
  Processes CFM thermal indications.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_cfcm_thermal_event_proc(const cfcm_cmd_msg_type_s *cfcm_ind)
{
  #ifdef FEATURE_CM_THERMAL_EMERGENCY_SUPPORT
  CM_ASSERT(cfcm_ind != NULL);

  CM_MSG_HIGH_2("TH EMERG Recvd CFM Evt %d, Monitor_mask: %d", \
                         cfcm_ind->fc_cmd.cmd, cfcm_ind->fc_cmd.monitors_active);

  cmpmprx_thermal_state_change_policy_update(cfcm_ind);


  switch(cfcm_ind->fc_cmd.cmd)
  {
    case CFCM_CMD_SHUT_DOWN:
      cmac_restrict_to_emergency(CM_AC_REASON_UNSAFE_TEMP);
      break;

    case CFCM_CMD_DOWN:

    #ifdef FEATURE_MMODE_DUAL_ACTIVE
      if(!cmac_is_in_thermal_emergency())
      {
        CM_MSG_HIGH_0("Device entering level 2 from level 0/1");
        
        if(cmph_is_dsda() && cfcm_ind->fc_cmd.monitors_active & CFCM_MONITOR_MASK_THERMAL_PA_EX)
      {
        cmac_enter_thermal_emergency_level_2();
        }
        break;
      }
    #endif

    case CFCM_CMD_FC_OFF:
    case CFCM_CMD_UP:
      cmac_restore_to_normal(CM_AC_REASON_UNSAFE_TEMP);
      break;
      
    default:
      CM_MSG_HIGH_1("Ignored CFM Evt %d", cfcm_ind);
  }

  #else

  SYS_ARG_NOT_USED(cfcm_ind);
  CM_MSG_HIGH_0("FEATURE_CM_THERMAL_EMERGENCY_SUPPORT not enabled");

  #endif /* FEATURE_CM_THERMAL_EMERGENCY_SUPPORT */
}

#endif /* FEATURE_CM_CFM_AVAILABLE */

/*===========================================================================

FUNCTION cmph_get_emergency_cb_pref

DESCRIPTION
  Get a pointer to the emergency_cb preferences

DEPENDENCIES
  None

RETURN VALUE
  Pointer to the strucutre having the emergency call back preferences

SIDE EFFECTS
  None

===========================================================================*/

static cm_act_orig_s_type * cmph_get_emergency_cb_pref( void )
{

  static cm_act_orig_s_type cmph_emer_cb_pref;

  return &cmph_emer_cb_pref;

}

/*===========================================================================

FUNCTION cmph_is_in_emergency_cb

DESCRIPTION
  Check if the phone is in emergency call back mode.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if the phone is in emergency call back mode.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_is_in_emergency_cb
(
        void
)
{
  /* Pointer to phone object.
  */
 cmph_s_type *ph_ptr  = cmph_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT( ph_ptr != NULL );
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if we are in call back mode.
  */

  if(ph_ptr->ph_state == CM_PH_STATE_EMERG_CB)
  {
    CM_MSG_HIGH_1( "Ph State %d", ph_ptr->ph_state);
    return TRUE;
  }
  
  return FALSE;

} /* cmph_is_in_emergency_cb() */



#if defined FEATURE_IP_CALL

/*===========================================================================

FUNCTION cmph_change_volte_call_priority

DESCRIPTION
Move existing VOLTE call obj above/below PH  in MAIN/HYBR2 . Currently this
is down during e911 orig and ECBM Enter/Exit.
1) Move it down below phone object during e911 call orig[Flag set to false]
2)Move it up when e911 call has ended and currently not in ECBM[Flag set to True]

DEPENDENCIES

RETURN VALUE
  NONE

SIDE EFFECTS
  none

===========================================================================*/

 void cmph_change_volte_call_priority
(
  boolean                 volte_priority,
  /* Flag set to alter prioriy */

  sys_modem_as_id_e_type  as_id
)
{
  cm_ss_e_type cm_ss = cmph_map_subs_to_ss(as_id);

  /*check if there is any VOLTE call in progress */
  if( cmcall_is_there_volte_call_sub(CM_CALL_TYPE_VOICE, as_id)!= CM_CALL_ID_INVALID)
  {

   /* Move VOLTE call with below PH priority  */
   if(!volte_priority)
   {
     if (cmph_is_subs_feature_mode_1x_sxlte(as_id))
     {
     (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                  CM_ACT_TYPE_VOICE_CALL,
                                  CM_ACT_PRIORITY_30,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );
     }

     (void)cmtask_orig_para_change_act_priority(cm_ss,
                                  CM_ACT_TYPE_VOICE_CALL,
                                  CM_ACT_PRIORITY_30,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );
    }

    /* Move VOLTE call back to normal VOICE call priority*/
    else
    {
      if (cmph_is_subs_feature_mode_1x_sxlte(as_id))
      {
      (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                  CM_ACT_TYPE_VOICE_CALL,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  CM_ACT_PRIORITY_30,
                                  TRUE );
      }
      (void)cmtask_orig_para_change_act_priority(cm_ss,
                                  CM_ACT_TYPE_VOICE_CALL,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  CM_ACT_PRIORITY_30,
                                  TRUE );


    }
  }

 } /* cmph_change_volte_call_priority*/

#endif

/*===========================================================================

FUNCTION cmph_exit_emergency_cb

DESCRIPTION

  Exit emergency callback mode and notify clients

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void cmph_exit_emergency_cb(

    cmph_s_type             *ph_ptr,
      /* Pointer to a phone object */
    boolean              lte_lmtd_handling,
    cm_ss_e_type             ss,
      /* ss which connects the emerg call */
    boolean 			 is_force_pref
      /*should force preferences*/
)
{

  cm_act_orig_s_type *emer_cb_ptr;

  boolean is_policy_pending = FALSE; 
  
  sys_modem_as_id_e_type  emerg_as_id = SYS_MODEM_AS_ID_1;
  cm_ss_e_type emerg_cm_ss = CM_SS_MAIN;

  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  is_policy_pending = cmpmprx_is_mask_set( SYS_MODEM_AS_ID_MAX, PM_CHG_ALL, NULL );

  /* Return if not in emergency callback mode
  */
  if(!cmph_is_in_emergency_cb())
  {
    return;
  }

  emerg_as_id = cmph_get_sub_in_emg_cb();  
  emerg_cm_ss = cmph_map_as_id_to_cm_ss(emerg_as_id);
  
  /* Need to move concurrent VOLTE call up to VOICE priority
     in case if it was moved below PH during e911 orig
  */
  #ifdef FEATURE_IP_CALL

  /* Move VOLTE call above PH  only when there is no emergency call in progress */
  if(cmcall_is_there_a_call_type(CM_SS_MAX,CM_CALL_TYPE_EMERGENCY,CM_CALL_ID_INVALID) == CM_CALL_ID_INVALID)
  {
    cmph_change_volte_call_priority(TRUE, SYS_MODEM_AS_ID_1);
    if (cmph_is_msim())
    {
      cmph_change_volte_call_priority(TRUE, SYS_MODEM_AS_ID_2);
    }
    
    /* if there is no emergency call in progress the ecbm exit cause is indicated as normal to clients
    */
    ph_ptr->ecbm_exit_reason = CM_ECBM_EXIT_REASON_NORMAL;

    /* Send the emergency mode end status if there is no other emergency call in progress.
    ** On 1X and LTE ECBM exit, send emergency_mode_end status on MAIN stack. SS is used as MAIN as
    ** LTE ECBM is currently required only by verizon.
    */
    if(cmph_is_emerg_mode_on(emerg_as_id))
    {
      cmph_update_send_emerg_status_ind(CM_EMERGENCY_MODE_ENDED, emerg_as_id);
    }
  }
  else
  {
    /* if emergency call is in progress and this triggers ECBM exit, set a flag to notify clients that
    ** this is the reason for ECBM exit. This can be used by clients like IMS to be aware that another
    ** emergency call origination is imminent. Without this indication , as soon as ECBM exit is processed the emergency PDN
    ** is torn down and there is additional delay when originating the next emergency call since UE has to set up a new
    ** emergency PDN.
    */
    ph_ptr->ecbm_exit_reason = CM_ECBM_EXIT_REASON_EMERG_CALL;
  }

  #endif

  CM_MSG_HIGH_0("Exit emergency callback mode");

  if(ph_ptr->ecbm_rat != SYS_SYS_MODE_WLAN)
  {
  emer_cb_ptr = cmph_get_emergency_cb_pref();

  CM_ASSERT( emer_cb_ptr != NULL );

  /* Initialize the emer_cb_ptr with default values
  */
  cmtask_orig_para_init_2( emer_cb_ptr );

  if(lte_lmtd_handling)
  {
    /* buffer ECBM preferences to be forced for 4 seconds */
    if(emerg_as_id == SYS_MODEM_AS_ID_1)
    {
      cmph_update_act_id_priority_queue_obj_with_1_call_plus( CM_SS_MAIN, ( cm_act_id_type )emer_cb_ptr);
      cmph_update_act_id_priority_queue_obj_with_1_call_plus( CM_SS_HDR,  ( cm_act_id_type )emer_cb_ptr);
      #ifdef FEATURE_MMODE_SC_SVLTE
      if (cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) == emerg_as_id)
      {
        cmph_update_act_id_priority_queue_obj_with_1_call_plus( CM_SS_HYBR_2, ( cm_act_id_type )emer_cb_ptr);
      }
      #endif
    }
    else
    {
      cmph_update_act_id_priority_queue_obj_with_1_call_plus(emerg_cm_ss, ( cm_act_id_type )emer_cb_ptr);
    }
  }
  else
  {
  /* Delete the call back entry from the queues
  */
    if(emerg_as_id == SYS_MODEM_AS_ID_1)
    {
      cmph_delete_update_orig_mode( CM_SS_MAIN, ( cm_act_id_type )emer_cb_ptr, is_force_pref);
      cmph_delete_update_orig_mode( CM_SS_HDR,  ( cm_act_id_type )emer_cb_ptr, is_force_pref);
      if (cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) == emerg_as_id)
      {
        cmph_delete_update_orig_mode( CM_SS_HYBR_2, ( cm_act_id_type )emer_cb_ptr, is_force_pref);
      }
    }
    else
    {
      cmph_delete_update_orig_mode( emerg_cm_ss, ( cm_act_id_type )emer_cb_ptr, is_force_pref);
    }
  }
  }

  /* Let clients know that we are exiting emergency callback mode
  */
  ph_ptr->ph_state = CM_PH_STATE_NORMAL;

  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  /* resume other stack if suspended due to emergency */
  if(cmph_is_msim() &&
    cmph_ss_susp_due_to_emerg(cmph_map_subs_to_ss(SYS_MODEM_AS_ID_2)) &&
    (!cmcall_emergency_call_active()) )
  {
    cmmsimc_suspend_or_resume_other_subs(SYS_MODEM_AS_ID_1,FALSE);
  }
  #endif


  /* Update the ECBM RAT to none
  */
  ph_ptr->ecbm_rat = SYS_SYS_MODE_NONE;

  
  if( is_policy_pending && (cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) ||
      (cmpmprx_is_special_volte_e911_calls() == TRUE)))
  {
    cmpmprx_notify_call_end(emerg_as_id, FALSE); //cmph_map_cm_ss_to_as_id(CM_SS_MAIN)
  }

  /* Update the DDTM status.
  */
  cmph_update_ddtm_status(ph_ptr);

  cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, emerg_cm_ss);
  cmlog_exit_emergency_cb();

  cmac_enable_emergency_if_pending();

}

/*===========================================================================

FUNCTION cmph_is_emerg_mode_on

DESCRIPTION
  This function returns the emergency mode status of the corresponding
  subscription.

DEPENDENCIES
  TRUE if UE is in emergency mode
  FALSE if UE is not in emergency mode

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_emerg_mode_on(
   sys_modem_as_id_e_type subs_id
   /* subscription id */
)
{

  boolean is_emerg_mode = FALSE;

  cmph_s_type *ph_ptr = cmph_ptr();

  if(subs_id == ph_ptr->main_stack_info.asubs_id)
  {
    is_emerg_mode = ph_ptr->main_stack_info.is_emergency_mode;
  }
  else if(subs_id == ph_ptr->hybr_2_stack_info.asubs_id && !cmph_is_sxlte())
  {
    is_emerg_mode = ph_ptr->hybr_2_stack_info.is_emergency_mode;
  }
  #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
  else if(subs_id == ph_ptr->hybr_3_stack_info.asubs_id)
  {
    is_emerg_mode = ph_ptr->hybr_3_stack_info.is_emergency_mode;
  }
  #endif
  return(is_emerg_mode);
}

/*===========================================================================

FUNCTION cmph_update_emerg_status_info

DESCRIPTION
  This function updates the emergency mode for the corresponding subscription.

DEPENDENCIES
  None

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_update_emerg_status_info(
   sys_modem_as_id_e_type subs_id,
   /* subscription id */

   boolean          emerg_mode
   /* emergency mode status */
)
{

  cmph_s_type *ph_ptr = cmph_ptr();

  if(subs_id == ph_ptr->main_stack_info.asubs_id)
  {
    ph_ptr->main_stack_info.is_emergency_mode = emerg_mode;
  }
  else if(subs_id == ph_ptr->hybr_2_stack_info.asubs_id && !cmph_is_sxlte())
  {
    ph_ptr->hybr_2_stack_info.is_emergency_mode = emerg_mode;
  }
  #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
  else if(subs_id == ph_ptr->hybr_3_stack_info.asubs_id)
  {
    ph_ptr->hybr_3_stack_info.is_emergency_mode = emerg_mode;
  }
  #endif
  
  CM_MSG_HIGH_2("Update emerg_mode status: subs_id %d, emerg_mode %d ",subs_id, emerg_mode);
}
/*===========================================================================

FUNCTION cmph_update_send_emerg_status_ind

DESCRIPTION
  This function updates the emergency mode in ph_ptr and sends the emergency
  mode status through the message router interface to clients - LTE RRC.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_update_send_emerg_status_ind(
   cm_emerg_mode_status_e_type status,
   /* emergency mode status */

   sys_modem_as_id_e_type subs_id
   /* Subscription on which the call was originated */
)
{

  errno_enum_type msgr_error;
  cm_emerg_mode_status_ind_s_type *emerg_info;


  emerg_info = (cm_emerg_mode_status_ind_s_type *)cm_mem_malloc(
    sizeof(cm_emerg_mode_status_ind_s_type));

  if(emerg_info == NULL)
  {
    sys_err_fatal_null_ptr_exception();
    return;
  }

  if(status == CM_EMERGENCY_MODE_STARTED)
  {
    cmph_update_emerg_status_info(subs_id, TRUE);
  }
  else if(status == CM_EMERGENCY_MODE_ENDED)
  {
    cmph_update_emerg_status_info(subs_id, FALSE);
  }

  memset(emerg_info, 0, sizeof(cm_emerg_mode_status_ind_s_type));

  emerg_info->asubs_id = subs_id;
  emerg_info->emerg_mode_status = status;
  emerg_info->msg_hdr.inst_id = SYS_AS_ID_TO_INST_ID(subs_id);

  msgr_error = cm_msgr_send( MM_CM_EMERGENCY_MODE_STATUS_IND, MSGR_MM_CM,
                           &(emerg_info->msg_hdr), sizeof(cm_emerg_mode_status_ind_s_type) );
  CM_MSG_HIGH_3( "CM->MSGR: EMERGENCY_MODE_STATUS_IND sent: status %d, msgr_err %d subs_id %d",
                 status, msgr_error, emerg_info->asubs_id );
  cm_mem_free(emerg_info);


}

/*===========================================================================

FUNCTION cmph_enter_emergency_cb

DESCRIPTION

  Enter emergency callback mode and notify clients

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void cmph_enter_emergency_cb(

    cmph_s_type             *ph_ptr,
        /* Pointer to a phone object */

    cm_ss_e_type             ss,
        /* ss which connects the emerg call */

    boolean                  is_evt_reqd
        /* Do we need to generate a event */
)
{

  cm_orig_q_s_type   *ph_orig_ptr;
  cm_act_orig_s_type *emer_cb_ptr;
  sys_modem_as_id_e_type  asubs_id = cmph_map_cm_ss_to_subs(ss);

  /* The pointer to the element of the priority queue
  */

  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return if already in emergency callback mode
  */
  if(cmph_is_in_emergency_cb())
  {
    return;
  }

  CM_MSG_HIGH_1("Enter emergency callback mode on ss %d",ss);

  emer_cb_ptr = cmph_get_emergency_cb_pref();

  /* If UE is not in emergency mode, update and send emergency_mode_started
  ** while entering emergency callback mode  */

  if(!cmph_is_emerg_mode_on(asubs_id))
  {
    cmph_update_send_emerg_status_ind(CM_EMERGENCY_MODE_STARTED, asubs_id);
  }
  /* mode pref needs to include both cdma and HDR since callback could be
  ** on either technology. Since in cb mode, the MS is limited to a single
  ** system this does not cause any issue.
  */
  emer_cb_ptr->orig_mode_pref = CM_MODE_PREF_EMERGENCY;
  emer_cb_ptr->orig_pref_term = CM_PREF_TERM_PWR_CYCLE;
  emer_cb_ptr->orig_mode      = SD_SS_ORIG_MODE_EMERG_CB;

  ph_orig_ptr = cmtask_orig_para_search_act_type( ss, CM_ACT_TYPE_EMERG_CALL );

  if( ph_orig_ptr != NULL )
  {
     emer_cb_ptr->orig_band_pref       = ph_orig_ptr->orig->orig_band_pref;
     emer_cb_ptr->orig_lte_band_pref   = ph_orig_ptr->orig->orig_lte_band_pref;
     emer_cb_ptr->orig_tds_band_pref   = ph_orig_ptr->orig->orig_tds_band_pref;
     emer_cb_ptr->orig_prl_pref        = ph_orig_ptr->orig->orig_prl_pref;
     emer_cb_ptr->orig_roam_pref       = ph_orig_ptr->orig->orig_roam_pref;
     emer_cb_ptr->orig_hybr_pref       = ph_orig_ptr->orig->orig_hybr_pref;
     emer_cb_ptr->orig_int_hybr_pref   = ph_orig_ptr->orig->orig_int_hybr_pref;
     emer_cb_ptr->orig_srv_domain_pref  = ph_orig_ptr->orig->orig_srv_domain_pref;
     emer_cb_ptr->csg_id               = ph_orig_ptr->orig->csg_id;
     emer_cb_ptr->csg_rat              = ph_orig_ptr->orig->csg_rat;
  }
  else
  {
     emer_cb_ptr->orig_band_pref       = CMPH_SS_BAND_PREF(asubs_id, ph_ptr);
     emer_cb_ptr->orig_lte_band_pref   = CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr);
     emer_cb_ptr->orig_tds_band_pref   = CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr);
     emer_cb_ptr->orig_prl_pref        = CMPH_SS_PRL_PREF(asubs_id, ph_ptr);
     emer_cb_ptr->orig_roam_pref       = CMPH_SS_ROAM_PREF(asubs_id, ph_ptr);
     emer_cb_ptr->orig_hybr_pref       = CMPH_SS_HYBR_PREF(asubs_id, ph_ptr);
     emer_cb_ptr->orig_int_hybr_pref   = cmph_map_cm_hybr_pref_to_sd_hybr_pref(emer_cb_ptr->orig_hybr_pref);
     emer_cb_ptr->orig_srv_domain_pref  = CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr);
     emer_cb_ptr->csg_id               = ph_ptr->main_stack_info.pref_info.csg_id;
     emer_cb_ptr->csg_rat              = ph_ptr->main_stack_info.pref_info.csg_rat;
     CM_MSG_HIGH_0( "Invalid state in enter cb mode. Emerg Call Obj not in Priority Queue" );
  }

  /* Turn hybrid off if the call gets connected on main stack
  */
  if(ss == CM_SS_MAIN)
  {
     emer_cb_ptr->orig_hybr_pref       = CM_HYBR_PREF_OFF;
     emer_cb_ptr->orig_int_hybr_pref   = SD_SS_HYBR_PREF_NONE;
  }

  (void)cmph_insert_orig_mode (
                                (asubs_id == SYS_MODEM_AS_ID_1? CM_SS_MAX:ss),
                                emer_cb_ptr->orig_mode,
                                CM_ACT_TYPE_EMERG_CB_MODE,
                                emer_cb_ptr->orig_pref_term,
                                emer_cb_ptr->orig_mode_pref,
                                emer_cb_ptr->orig_band_pref,
                                emer_cb_ptr->orig_lte_band_pref,
                                emer_cb_ptr->orig_tds_band_pref,
                                emer_cb_ptr->orig_prl_pref,
                                emer_cb_ptr->orig_roam_pref,
                                emer_cb_ptr->orig_hybr_pref,
                                emer_cb_ptr->orig_int_hybr_pref,
                                emer_cb_ptr->orig_srv_domain_pref,
                                (cm_act_id_type)emer_cb_ptr,
                                CM_ACT_UPDATE_REAS_ACT_START,
                                CM_DEFAULT_VALUE,
                                emer_cb_ptr->csg_id,
                                emer_cb_ptr->csg_rat
                              );

  #ifdef  FEATURE_VOIP_E911_SUPPORT

  /* If call gets connected on a stack other than main
  ** delete emerg call prefs on main and force the emerg cb preferences on it.
  ** Otherwise when the call ends, and both emerg and emerg cb preferences
  ** are on main ,emerg cb prefs will not get forced on main. Emerg cb mode on
  ** main stack with hybrid on will result in shutdown of main stack at SD level
  */
  if(ss != CM_SS_MAIN)
  {
    if ((ph_orig_ptr = cmtask_orig_para_search_act_type( CM_SS_MAIN,
                         CM_ACT_TYPE_EMERG_CALL )) != NULL )
    {
      (void)cmtask_orig_para_delete( CM_SS_MAIN, ph_orig_ptr, TRUE );
    }
    cmph_force_orig_mode_on_the_fly(CM_SS_MAIN);
  }

  #endif //FEATURE_VOIP_E911_SUPPORT

  ph_ptr->ph_state = CM_PH_STATE_EMERG_CB;
  ph_ptr->ecbm_exit_reason = CM_ECBM_EXIT_REASON_NORMAL;

  /* Update the DDTM status.
  */
  cmph_update_ddtm_status(ph_ptr);

  if( is_evt_reqd )
  {
    /*
    ** Notify clients and DIAG
    */
    cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, ss );
    cmlog_enter_emergency_cb();
  }

}

#ifdef FEATURE_DDTM_CNTL

/*===========================================================================

FUNCTION cmph_client_cmd_ddtm_pref_para_check

DESCRIPTION
  Check parameter errors for DDTM preference setting command.

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static cm_ph_cmd_err_e_type       cmph_client_cmd_ddtm_pref_para_check(

       cm_ph_cmd_s_type           *ph_cmd_ptr,
         /* Phone command pointer.
         */

       const cmph_s_type                *ph_ptr
         /* Pointer to phone object.
         */
)
{
  cm_ph_cmd_info_s_type          *cmd_info_ptr = NULL;
  cm_ph_cmd_err_e_type            cmd_err      = CM_PH_CMD_ERR_NOERR;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_cmd_ptr != NULL);
  CM_ASSERT(ph_ptr     != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /* Check if ddtm_pref parameter is within range.
  */
  CM_MSG_HIGH_3("cmd_info_ptr->ddtm_pref %d, cmd_info_ptr->ddtm_act_mask %d, cmd_info_ptr->ddtm_so_list_act %d", 
    cmd_info_ptr->ddtm_pref,
    cmd_info_ptr->ddtm_act_mask,
    cmd_info_ptr->ddtm_so_list_act);
  if(!BETWEEN(cmd_info_ptr->ddtm_pref,
              CM_DDTM_PREF_NONE,
              CM_DDTM_PREF_MAX))
  {

    cmd_err = CM_PH_CMD_ERR_DDTM_PREF_P;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if DDTM action is not NO_CHANGE atleast one valid action
  ** is specified.
  */
  if ( cmd_info_ptr->ddtm_act_mask == SYS_DDTM_ACT_MASK_EMPTY ||
       cmd_info_ptr->ddtm_act_mask >= SYS_DDTM_ACT_MASK_MAX
     )
  {
    cmd_err = CM_PH_CMD_ERR_DDTM_PREF_P;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if ddtm_so_list_act is in range.
  */
  if(!BETWEEN(cmd_info_ptr->ddtm_so_list_act,
              CM_DDTM_SO_LIST_ACT_NONE,
              CM_DDTM_SO_LIST_ACT_MAX ))
  {
    cmd_err = CM_PH_CMD_ERR_DDTM_PREF_P;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if num_srv_opt is in range.
  */
  if ( cmd_info_ptr->ddtm_so_list_act != CM_DDTM_SO_LIST_ACT_NONE &&
       cmd_info_ptr->ddtm_so_list_act != CM_DDTM_SO_LIST_ACT_NO_CHANGE &&
       cmd_info_ptr->ddtm_num_srv_opt > ARR_SIZE(ph_ptr->ddtm_srv_opt_list))
  {
    cmd_err = CM_PH_CMD_ERR_DDTM_NUM_SRV_OPTIONS_P;
  }

  /* check the SVDO and SVLTE capibilities.
  UE should only honor the command if non SVDO is supported regardless of  SVLTE mode.
  UE should reject the command if SVDO is supported regardless of SVLTE mode*/
  if(ph_ptr->is_svdo_supported)
  {
     cmd_err = CM_PH_CMD_ERR_DDTM_SVDO_SUPPORTED;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Remove duplicates from cmd_info_ptr->srv_opt_list if already present
  ** in phone object.
  */
  if (cmd_err == CM_PH_CMD_ERR_NOERR &&
      cmd_info_ptr->ddtm_so_list_act == CM_DDTM_SO_LIST_ACT_ADD )
  {
    int i = 0;
    int j = 0;

    while ( i < ph_ptr->ddtm_num_srv_opt && i < SYS_DDTM_MAX_SO_LIST_SIZE )
    {
      j = 0;
      while ( j < cmd_info_ptr->ddtm_num_srv_opt &&
              j < SYS_DDTM_MAX_SO_LIST_SIZE)
      {
        if ( cmd_info_ptr->ddtm_srv_opt_list[j] == ph_ptr->ddtm_srv_opt_list[i] )
        {
          /* Swap with the last one in the array, and reduce the count.
          */
          --cmd_info_ptr->ddtm_num_srv_opt;
          cmd_info_ptr->ddtm_srv_opt_list[j] =
               cmd_info_ptr->ddtm_srv_opt_list[cmd_info_ptr->ddtm_num_srv_opt];
        }
        else
        {
          j++;
        }
      }
      i++;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Now check if the new srv_opt_list can be added.
    */
    if ( (cmd_info_ptr->ddtm_num_srv_opt + ph_ptr->ddtm_num_srv_opt) >
                 ARR_SIZE( ph_ptr->ddtm_srv_opt_list ))
    {
      /* Exceeded the maximum size.
      */
      CM_MSG_HIGH_1( "Exceed max size ddtm_num_srv_opt %d",
                    cmd_info_ptr->ddtm_num_srv_opt);
      cmd_err = CM_PH_CMD_ERR_DDTM_NUM_SRV_OPTIONS_P;
    }
  }

  return cmd_err;

} /* cmph_client_cmd_ddtm_pref_para_check() */


/*===========================================================================

FUNCTION cmph_ddtm_add_so

DESCRIPTION
  Add the service option to the DDTM service list in the Phone object.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_ddtm_add_so(

    cmph_s_type               *ph_ptr,
        /* Pointer to a phone object.
        */

    sys_srv_opt_type           srv_opt
        /* Service option to be added.
        */
)
{
  unsigned int i;

 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Check for duplicates before adding the srv_opt.
  */
  for ( i = 0;
        i < ph_ptr->ddtm_num_srv_opt &&
          i < ARR_SIZE(ph_ptr->ddtm_srv_opt_list);
        i++
      )
  {
    if ( ph_ptr->ddtm_srv_opt_list[i] == srv_opt )
    {
      /* SO already in the list
      */
      CM_MSG_HIGH_1("SO %d already in list", srv_opt);
      return;
    }
  } /* for () */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if maximum number of srv_opts have already been added.
  */
  if ( i >= ARR_SIZE(ph_ptr->ddtm_srv_opt_list) )
  {
    CM_MSG_HIGH_1("MAX added: Cannot add so %d", srv_opt);
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Add the srv_opt to the DDTM list.
  */
  CM_MSG_HIGH_1("SO %d added in list", srv_opt);
  ph_ptr->ddtm_srv_opt_list[i] = srv_opt;
  ph_ptr->ddtm_num_srv_opt++;
} /* cmph_ddtm_add_so() */




/*===========================================================================

FUNCTION cmph_ddtm_del_so

DESCRIPTION
  Deletes the service option specified from the DDTM service list in the
  Phone object.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_ddtm_del_so(

    cmph_s_type               *ph_ptr,
        /* Pointer to a phone object.
        */

    sys_srv_opt_type          srv_opt
        /* Service option to be added.
        */
)
{
  unsigned int i;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Check for duplicates before adding the srv_opt.
  */
  for ( i = 0;
        i < ph_ptr->ddtm_num_srv_opt &&
          i < ARR_SIZE(ph_ptr->ddtm_srv_opt_list);
        i++
      )
  {
    if ( ph_ptr->ddtm_srv_opt_list[i] == srv_opt )
    {
      /* SO is in the list, delete this entry by swapping with the
      ** last in the list.
      */
      --ph_ptr->ddtm_num_srv_opt;
      CM_MSG_HIGH_1("Deleting srv_opt %d", srv_opt);
      ph_ptr->ddtm_srv_opt_list[i] =
           ph_ptr->ddtm_srv_opt_list[ph_ptr->ddtm_num_srv_opt];
      break;

    }
  } /* for () */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Print debug message if not in list.
  */
  if ( i >= ph_ptr->ddtm_num_srv_opt )
  {

    CM_MSG_HIGH_1("so %d not in list", srv_opt);
    return;
  }

} /* cmph_ddtm_del_so() */


/*===========================================================================

FUNCTION cmph_ddtm_update_so_list

DESCRIPTION
  Update the DDTM srv option list based on the user specified action type.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_ddtm_update_so_list(

    cmph_s_type                 *ph_ptr,
        /* Pointer to a phone object.
        */

    const cm_ph_cmd_info_s_type *cmd_info_ptr
        /* Pointer to a phone command information.
        */
)
{

  int i;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr       != NULL);
  CM_ASSERT(cmd_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Processing based on action type.
  */
  CM_MSG_HIGH_1( "DDTM so list action %d",
               cmd_info_ptr->ddtm_so_list_act);

  switch ( cmd_info_ptr->ddtm_so_list_act )
  {
    case CM_DDTM_SO_LIST_ACT_REPLACE:
      ph_ptr->ddtm_num_srv_opt = 0;
      for ( i = 0; i < cmd_info_ptr->ddtm_num_srv_opt; i++ )
      {
        cmph_ddtm_add_so( ph_ptr,
                          cmd_info_ptr->ddtm_srv_opt_list[i]
                        );
      }
      break;

    case CM_DDTM_SO_LIST_ACT_ADD:
      for ( i = 0; i < cmd_info_ptr->ddtm_num_srv_opt; i++ )
      {
        cmph_ddtm_add_so( ph_ptr,
                          cmd_info_ptr->ddtm_srv_opt_list[i]
                        );
      }
      break;

    case CM_DDTM_SO_LIST_ACT_DELETE:
      for ( i = 0; i < cmd_info_ptr->ddtm_num_srv_opt; i++ )
      {
        cmph_ddtm_del_so( ph_ptr,
                          cmd_info_ptr->ddtm_srv_opt_list[i]
                        );
      }
      break;

    case CM_DDTM_SO_LIST_ACT_NO_CHANGE:
    default:
      break;

  } /* switch ( cmd_info_ptr->ddtm_so_list_act) */

} /* cmph_ddtm_update_so_list */
#endif /* FEATURE_DDTM_CNTL */

/*===========================================================================

FUNCTION cmph_is_valid_pref_plmn_rat_req

DESCRIPTION
  Decides if user pref sent is for preferred PLMN+RAT selection.

RETURN VALUE
  TRUE - Pref PLMN+RAT request
  FALSE - otherwise

===========================================================================*/

static boolean cmph_is_valid_pref_plmn_rat_req(

  const cm_ph_cmd_info_s_type  *cmd_info_ptr
)
{
  boolean is_pref_plmn_rat = FALSE;

  if(cmd_info_ptr->csg_id == SYS_CSG_ID_INVALID &&
     cmd_info_ptr->csg_rat != SYS_RAT_NONE &&
     sys_plmn_id_is_valid(cmd_info_ptr->plmn))
  {
    is_pref_plmn_rat = TRUE;
  }

  return is_pref_plmn_rat;
}

/*===========================================================================

FUNCTION cmph_cmd_copy_fields

DESCRIPTION
  Copy the active fields of a phone command into a phone object.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_copy_hybr_gw_fields(

    cmph_s_type               *ph_ptr,
        /* Pointer to a phone object */

    const cm_ph_cmd_s_type    *cmd_ptr,
        /* Pointer to a phone command */

     cm_ss_e_type              ss
)
{
  #ifndef FEATURE_MMODE_DUAL_SIM
  SYS_ARG_NOT_USED(ph_ptr);
  SYS_ARG_NOT_USED(cmd_ptr);
  return;

  #else

  const cm_ph_cmd_info_s_type    *cmd_info_ptr = NULL;
      /* Point at phone command information */

  cm_pref_s_type                 new_pref;

  dword                          uptime = time_get_uptime_secs();
      /* Get the current uptime */

  sys_radio_access_tech_e_type   pref_rat;

  cm_mode_pref_e_type            tmp_mode_pref = CM_MODE_PREF_NONE;
  cm_hybr_pref_e_type            tmp_hybr_pref = CM_HYBR_PREF_NONE;
  sys_modem_as_id_e_type         asubs_id = cmph_map_cm_ss_to_subs(ss);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(cmd_ptr != NULL);

  /* If non multi-sim, no need to proceed further */
  if (cmph_is_ssim())
  {
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( cmd_ptr);

  /* Initialize the new preferences */
  #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
  if(ss == CM_SS_HYBR_3)
  {
     new_pref  = ph_ptr->hybr_3_stack_info.pref_info;
  }
  else
  #endif
  {
    new_pref  = ph_ptr->hybr_2_stack_info.pref_info;
  }
 
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  tmp_mode_pref = cmd_info_ptr->mode_pref;
  tmp_hybr_pref = cmd_info_ptr->hybr_pref;

  /* Check and update 3GPP2 specific preference */
  cmph_msim_modify_3gpp2_pref(asubs_id,
                                &tmp_mode_pref,
                                &tmp_hybr_pref);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(( cmd_info_ptr->mode_pref     != CM_MODE_PREF_NONE ) ||
     (ph_ptr->is_mode_pref_none == TRUE))
  {
    new_pref.mode_pref            = tmp_mode_pref;
  }

  if(cmd_info_ptr->hybr_pref     != CM_HYBR_PREF_NONE  &&
    cmd_info_ptr->hybr_pref      != CM_HYBR_PREF_NO_CHANGE)
  {
    new_pref.hybr_pref            = tmp_hybr_pref;
  }

  if( cmd_info_ptr->pref_term     != CM_PREF_TERM_NONE )
  {
    new_pref.pref_term            = cmd_info_ptr->pref_term;
    new_pref.mode_uptime          = uptime + cmd_info_ptr->pref_duration;
  }

  if( cmd_info_ptr->band_pref     != CM_BAND_PREF_NONE )
  {
    new_pref.band_pref            = cmd_info_ptr->band_pref;
  }

  if(!SYS_LTE_BAND_MASK_CHK_IF_EMPTY( &cmd_info_ptr->lte_band_pref))
  {
    new_pref.lte_band_pref        = cmd_info_ptr->lte_band_pref;
  }

  if( cmd_info_ptr->tds_band_pref != CM_BAND_PREF_NONE )
  {
    new_pref.tds_band_pref        = cmd_info_ptr->tds_band_pref;
  }

  if( cmd_info_ptr->prl_pref      != CM_PRL_PREF_NONE )
  {
    new_pref.prl_pref             = cmd_info_ptr->prl_pref;
  }

  if( cmd_info_ptr->roam_pref     != CM_ROAM_PREF_NONE )
  {
    new_pref.roam_pref            = cmd_info_ptr->roam_pref;
  }

  if( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_NONE )
  {
    new_pref.network_sel_mode_pref          = cmd_info_ptr->network_sel_mode_pref;
  }

  /* Only cmd_info_ptr->srv_domain_pref can come here with NO_CHANGE,
  ** others like net_sel_mode, acq_order_pref cannot come here with
  ** NO_CHANGE
  */
  if( (cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_NONE ) &&
      (cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_NO_CHANGE)
    )
  {
    #ifdef CM_GW_SUPPORTED

    if( cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ATTACH ||
        cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH
      )
    {
      if( new_pref.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY ||
          new_pref.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS )
      {
        new_pref.srv_domain_pref  = CM_SRV_DOMAIN_PREF_CS_PS;
      }
      else if ( new_pref.srv_domain_pref  == CM_SRV_DOMAIN_PREF_PS_ONLY ||
                new_pref.srv_domain_pref  == CM_SRV_DOMAIN_PREF_NONE )
      {
        new_pref.srv_domain_pref  = CM_SRV_DOMAIN_PREF_PS_ONLY;
      }
    }
    else if(cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_DETACH)
    {
      if( new_pref.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY ||
          new_pref.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS )
      {
        new_pref.srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
      }
      else if ( new_pref.srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY ||
                new_pref.srv_domain_pref == CM_SRV_DOMAIN_PREF_NONE )
      {
        new_pref.srv_domain_pref = CM_SRV_DOMAIN_PREF_NONE;
      }
    }
    else
    #endif /* FEATURE_WCDMA || FEATURE_GSM */
    {
      new_pref.srv_domain_pref                = cmd_info_ptr->srv_domain_pref;
    }
  }

  if( cmd_info_ptr->acq_order_pref != CM_GW_ACQ_ORDER_PREF_NONE )
  {
    new_pref.acq_order_pref                 = cmd_info_ptr->acq_order_pref;
  }

  if( !sys_plmn_id_is_undefined( cmd_info_ptr->plmn ) )
  {
    new_pref.plmn                           = cmd_info_ptr->plmn;
  }

  if( cmd_info_ptr->network_type  != CM_MODE_PREF_NONE )
  {
    #ifdef FEATURE_MMODE_DUAL_ACTIVE
    if(cmph_is_dsda())
    {
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if (cmph_is_sxlte())
      {
        new_pref.network_type = ph_ptr->hybr_3_stack_info.pref_info.network_type     =    cmd_info_ptr->network_type;

      }
      else
      #endif
      {
        new_pref.network_type = ph_ptr->hybr_2_stack_info.pref_info.network_type     =    cmd_info_ptr->network_type;
      }
    }
    else
    #endif
    {
      ph_ptr->main_stack_info.pref_info.network_type     =    cmd_info_ptr->network_type;
    }

  }

  if( cmd_info_ptr->network_list_type          != CM_NETWORK_LIST_NONE )
  {
    ph_ptr->hybrid2_network_list_type     =    cmd_info_ptr->network_list_type;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

 // ph_ptr->hybr_2_stack_info.pref_info = new_pref;

  /* Pref PLMN request is one time, so priority queue shouldn't use it
     force PH pref after higher activities are ended */
  if(cmph_is_valid_pref_plmn_rat_req(cmd_info_ptr))
  {
    pref_rat = SYS_RAT_NONE;
  }
  else
  {
    pref_rat = cmd_info_ptr->csg_rat;
  }

  if(ss == CM_SS_HYBR_2 && !cmph_is_sxlte())
  {
    ph_ptr->hybr_2_stack_info.pref_info = new_pref;
    (void)cmph_insert_orig_mode (
                CM_SS_HYBR_2,
                SD_SS_ORIG_MODE_NONE,
                CM_ACT_TYPE_PH_OBJ,
                new_pref.pref_term,
                new_pref.mode_pref,
                new_pref.band_pref,
                new_pref.lte_band_pref,
                new_pref.tds_band_pref,
                new_pref.prl_pref,
                new_pref.roam_pref,
                new_pref.hybr_pref,
                cmph_map_cm_hybr_pref_to_sd_hybr_pref(new_pref.hybr_pref),
                new_pref.srv_domain_pref,
                (cm_act_id_type)ph_ptr,
                CM_ACT_UPDATE_REAS_ACT_CONT,
                cmd_ptr->info.sys_sel_pref_req_id,
                cmd_ptr->info.csg_id,
                pref_rat
                );
    }
    
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    else
    {
      ph_ptr->hybr_3_stack_info.pref_info = new_pref;
      (void)cmph_insert_orig_mode (
                CM_SS_HYBR_3,
                SD_SS_ORIG_MODE_NONE,
                CM_ACT_TYPE_PH_OBJ,
                new_pref.pref_term,
                new_pref.mode_pref,
                new_pref.band_pref,
                new_pref.lte_band_pref,
                new_pref.tds_band_pref,
                new_pref.prl_pref,
                new_pref.roam_pref,
                new_pref.hybr_pref,
                cmph_map_cm_hybr_pref_to_sd_hybr_pref(new_pref.hybr_pref),
                new_pref.srv_domain_pref,
                (cm_act_id_type)ph_ptr,
                CM_ACT_UPDATE_REAS_ACT_CONT,
                cmd_ptr->info.sys_sel_pref_req_id,
                cmd_ptr->info.csg_id,
                pref_rat
              );
    }
    #endif

  #endif
} /* cmph_cmd_copy_hybr_gw_fields */

/*===========================================================================

FUNCTION cmph_get_acq_pri_order_per_sub

DESCRIPTION
  get the acq priority order by asubs_id

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  acq priority order

SIDE EFFECTS
  none

===========================================================================*/
cm_acq_pri_order_pref_s_type* cmph_get_acq_pri_order_per_sub(
  cm_ss_e_type ss
)
{
  cmph_s_type *ph_ptr = cmph_ptr();
  sys_modem_as_id_e_type asubs_id = cmph_map_cm_ss_to_subs(ss);
  cmph_sub_config_s_type *ph_sub_config_ptr = cmph_get_sub_config_ptr(asubs_id);
  
  CM_ASSERT(ph_sub_config_ptr != NULL);
/*
  if(ph_sub_config_ptr == NULL)
  {
    cm_acq_pri_order_pref_s_type default_acq_pri_order;
    default_acq_pri_order.num_rat = 0;
    CM_MSG_HIGH_1("cmph sub config pointer[%d] is NULL",asubs_id);
    return &default_acq_pri_order;
  }
*/
  return &ph_sub_config_ptr->rat_acq_order_pref;

}

/*===========================================================================

FUNCTION cmph_cmd_copy_fields

DESCRIPTION
  Copy the active fields of a phone command into a phone object.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_copy_fields(

    cmph_s_type               *ph_ptr,
        /* Pointer to a phone object */

    const cm_ph_cmd_s_type    *cmd_ptr
        /* Pointer to a phone command */
)
{
  const cm_ph_cmd_info_s_type    *cmd_info_ptr = NULL;
      /* Point at phone command information */

  dword                          uptime = time_get_uptime_secs();
      /* Get the current uptime */

  cm_mode_pref_e_type            mode_pref = CM_MODE_PREF_NONE;
  boolean                        is_mode_pref_adj    = FALSE;
  cm_mode_pref_e_type         fav_mode_pref       = CM_MODE_PREF_NONE;

  #ifdef FEATURE_HICPS_STACK_SYNC_UP
  cm_orig_q_s_type              *ph_orig_ptr =
                                 cmtask_orig_para_search_act_type( CM_SS_MAIN,
                                                          CM_ACT_TYPE_PH_OBJ);
  boolean                        is_gw_mode          = FALSE;
  boolean                        is_ph_obj_gw_mode   = FALSE;
  boolean                        is_ph_ptr_gw_mode   = FALSE;
  #endif

  cm_ss_e_type                   ss = CM_SS_MAIN;
  sys_radio_access_tech_e_type   pref_rat;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr  != NULL);
  CM_ASSERT(cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( cmd_ptr);

  if (cmph_is_msim())
  {
    if( cmd_info_ptr->cmd_subs != SYS_MODEM_AS_ID_NONE)
    {
      /* Get the SS on which this command is issued, based on the asubs */
      ss = cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);
    }
    else
    {
      ss = CM_SS_MAX;
    }
  }
  else
  {
    ss = CM_SS_MAIN;
  }


  /* Only copy active command fields in order to avoid overwriting
  ** phone fields that are irrelevant to this command.
  */
  if( cmd_info_ptr->oprt_mode             != SYS_OPRT_MODE_NONE )
  {
    ph_ptr->oprt_mode                      = cmd_info_ptr->oprt_mode;
    #ifdef CM_GW_SUPPORTED
    #ifdef FEATURE_TC
    restore_oprt_mode                      = ph_ptr->oprt_mode;
    #endif /* FEATURE_TC */
    #endif /* FEATURE_WCDMA, FEATURE_GSM */
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  #ifdef FEATURE_HICPS_STACK_SYNC_UP
  /* Check the GW mode against the phone's band pref
  */
  #ifdef FEATURE_CM_LTE
  is_gw_mode = cmph_is_valid_mode_pref( CM_MODE_PREF_GWL,
                                        cmph_map_cm_ss_to_subs(CM_SS_MAIN));
  #else
  is_gw_mode = cmph_is_valid_mode_pref( CM_MODE_PREF_GSM_WCDMA_ONLY,
                                        cmph_map_cm_ss_to_subs(CM_SS_MAIN));
  #endif

  /* Check if the phone has GW mode
  */
  if( ph_orig_ptr != NULL )
  {
    is_ph_obj_gw_mode =
              cmcall_misc_is_mode_pref(ph_orig_ptr->orig->orig_mode_pref,
                                       #ifdef FEATURE_CM_LTE
                                       CM_MODE_PREF_GWL);
                                       #else
                                       CM_MODE_PREF_GSM_WCDMA_ONLY);
                                       #endif
  }
  else
  {
    is_ph_obj_gw_mode = FALSE;
  }

  /*
  ** Check if phone ptr has GW.
  */
  is_ph_ptr_gw_mode =
            cmcall_misc_is_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref ,
                                     #ifdef FEATURE_CM_LTE
                                     CM_MODE_PREF_GWL);
                                     #else
                                     CM_MODE_PREF_GSM_WCDMA_ONLY);
                                     #endif

  /* Check if at the current time the mode preference has been adjusted as per
  ** HICPS algorithm. If yes similar adjustment will be required before
  ** updating the phone object at the end of this function.
  */
  if( is_gw_mode && is_ph_ptr_gw_mode && !is_ph_obj_gw_mode )
  {
    CM_MSG_HIGH_3("HICPS: is_gw_mode: %d, is_ph_ptr_gw_mode: %d, is_ph_obj_gw_mode: %d",
                              is_gw_mode,is_ph_ptr_gw_mode,is_ph_obj_gw_mode);  
    /* Don't perform mdoe pref adjustments, if mode pref is none due to DAM
       **In this case, phone pointer mode pref will have LTE only but phone preferences .
       **will have mode pref as NONE
       */

    if (ph_ptr->is_mode_pref_none == FALSE)
    {
      is_mode_pref_adj = TRUE;
    }
  }

  #endif /* FEATURE_HICPS_STACK_SYNC_UP */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if(ss == CM_SS_HYBR_2 || (ss == CM_SS_MAX && !cmph_is_sxlte()))
  {
    cmph_cmd_copy_hybr_gw_fields(ph_ptr, cmd_ptr , CM_SS_HYBR_2);
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(ss == CM_SS_HYBR_3 || ss == CM_SS_MAX)
  {
    cmph_cmd_copy_hybr_gw_fields(ph_ptr, cmd_ptr, CM_SS_HYBR_3);
  }
  #endif

  CM_MSG_HIGH_3("copy cmd fields user_mode_pref=%d,cmd_info_ptr->mode_pref=%d,mode_pref=%d", 
                ph_ptr->main_stack_info.pref_info.user_mode_pref,cmd_info_ptr->mode_pref,
                ph_ptr->main_stack_info.pref_info.mode_pref);
  if( ss == CM_SS_MAIN || ss == CM_SS_MAX)
  {
    if( cmd_info_ptr->mode_pref             != CM_MODE_PREF_NONE )
    {
      ph_ptr->main_stack_info.pref_info.mode_pref                      = cmd_info_ptr->mode_pref;
    }

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    /*lint -save -e774 Boolean within 'if' always evaluates to False */
    if ( is_mode_pref_adj )
    /*lint -restore */
    {
      mode_pref =
            cmcall_remove_mode_pref_components( ph_ptr->main_stack_info.pref_info.mode_pref,
                                                1,
                                                SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE );

      if( mode_pref == CM_MODE_PREF_NONE )
      {
        CM_MSG_HIGH_0(" HICPS: mode_pref evaluated to NONE");
        mode_pref = ph_ptr->main_stack_info.pref_info.mode_pref;
      }
    }
    else
    {
      if (ph_ptr->is_mode_pref_none == FALSE)
      {
        mode_pref = ph_ptr->main_stack_info.pref_info.mode_pref;
      }
    }

    CM_MSG_HIGH_3("HICPS: phcmd: %d, ph_ptr->main_stack_info.pref_info.mode_pref: %d, Inserting mode preference: %d",
                                    cmd_ptr->cmd,ph_ptr->main_stack_info.pref_info.mode_pref,mode_pref);

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    if( cmd_info_ptr->pref_term             != CM_PREF_TERM_NONE )
    {
      ph_ptr->main_stack_info.pref_info.pref_term                      = cmd_info_ptr->pref_term;
      ph_ptr->main_stack_info.pref_info.mode_uptime = uptime + cmd_info_ptr->pref_duration;
    }

    if( cmd_info_ptr->band_pref             != CM_BAND_PREF_NONE )
    {
      ph_ptr->main_stack_info.pref_info.band_pref                      = cmd_info_ptr->band_pref;
    }

    if( !SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&(cmd_info_ptr->lte_band_pref)))
    {
      ph_ptr->main_stack_info.pref_info.lte_band_pref                  = cmd_info_ptr->lte_band_pref;
    }

    if( cmd_info_ptr->tds_band_pref         != CM_BAND_PREF_NONE )
    {
      ph_ptr->main_stack_info.pref_info.tds_band_pref                  = cmd_info_ptr->tds_band_pref;
    }

    if( cmd_info_ptr->prl_pref             != CM_PRL_PREF_NONE )
    {
      ph_ptr->main_stack_info.pref_info.prl_pref                      = cmd_info_ptr->prl_pref;
    }

    if( cmd_info_ptr->roam_pref             != CM_ROAM_PREF_NONE )
    {
      ph_ptr->main_stack_info.pref_info.roam_pref                      = cmd_info_ptr->roam_pref;
    }

    if (cmd_info_ptr->ue_usage_setting      != SYS_UE_USAGE_SETTING_NONE)
    {
      *(CMPH_SS_UE_USAGE_SETTING_PTR(cmd_info_ptr->cmd_subs, ph_ptr))     = cmd_info_ptr->ue_usage_setting;
    }

    if (cmd_info_ptr->voice_domain_pref      != SYS_VOICE_DOMAIN_PREF_NONE &&
        cmph_is_lte_capable_on_sub(cmd_info_ptr->cmd_subs))
    {
      *(CMPH_SS_VOICE_DOMAIN_PREF_PTR(cmd_info_ptr->cmd_subs, ph_ptr))     = cmd_info_ptr->voice_domain_pref;
    }

    #ifdef FEATURE_HDR

    if( cmd_info_ptr->hybr_pref              != CM_HYBR_PREF_NO_CHANGE )
    {
      ph_ptr->main_stack_info.pref_info.hybr_pref                      = cmd_info_ptr->hybr_pref;
    }

    #ifdef FEATURE_FULL_TIME_SHDR
    #error code not present
#endif
    #endif /* FEATURE_HDR */

    if( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_NONE )
    {
      ph_ptr->main_stack_info.pref_info.network_sel_mode_pref          = cmd_info_ptr->network_sel_mode_pref;
    }

    /* Only cmd_info_ptr->srv_domain_pref can come here with NO_CHANGE,
    ** others like net_sel_mode, acq_order_pref cannot come here with
    ** NO_CHANGE
    */
    if( (cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_NONE ) &&
        (cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_NO_CHANGE)
      )
    {

      #ifdef CM_GW_SUPPORTED

        if( cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ATTACH ||
            cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH)
      {
        if( ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY ||
            ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS )
        {
          ph_ptr->main_stack_info.pref_info.srv_domain_pref  = CM_SRV_DOMAIN_PREF_CS_PS;
        }
        else if ( ph_ptr->main_stack_info.pref_info.srv_domain_pref  == CM_SRV_DOMAIN_PREF_PS_ONLY ||
                  ph_ptr->main_stack_info.pref_info.srv_domain_pref  == CM_SRV_DOMAIN_PREF_NONE )
        {
          ph_ptr->main_stack_info.pref_info.srv_domain_pref  = CM_SRV_DOMAIN_PREF_PS_ONLY;
        }
      }
      else if(cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_DETACH)
      {
        if( ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY ||
            ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS )
        {
          ph_ptr->main_stack_info.pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
        }
        else if ( ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY ||
                  ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_NONE )
        {
          ph_ptr->main_stack_info.pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_NONE;
        }
      }
      else if(cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_LOCAL_DETACH)
      {
        CM_MSG_HIGH_1(" PS_LOCAL_DETACH, current domain_pref : %d ",ph_ptr->main_stack_info.pref_info.srv_domain_pref);
      }
      else
      #endif /* FEATURE_WCDMA || FEATURE_GSM */
      {
        ph_ptr->main_stack_info.pref_info.srv_domain_pref                = cmd_info_ptr->srv_domain_pref;
      }
    }

    if( cmd_info_ptr->acq_order_pref != CM_GW_ACQ_ORDER_PREF_NONE )
    {
      ph_ptr->main_stack_info.pref_info.acq_order_pref                 = cmd_info_ptr->acq_order_pref;
    }

    if( !sys_plmn_id_is_undefined( cmd_info_ptr->plmn ) )
    {
      ph_ptr->main_stack_info.pref_info.plmn                           = cmd_info_ptr->plmn;
    }

    if( cmd_info_ptr->network_type          != CM_MODE_PREF_NONE )
    {
      ph_ptr->main_stack_info.pref_info.network_type     =    cmd_info_ptr->network_type;

    }

    if( cmd_info_ptr->network_list_type          != CM_NETWORK_LIST_NONE )
    {
      ph_ptr->network_list_type     =    cmd_info_ptr->network_list_type;
    }

    #ifdef CM_GW_SUPPORTED
    if ( cmd_ptr->cmd == CM_PH_CMD_SET_PREFERRED_NETWORKS )
    {
       ph_ptr->main_stack_info.user_pref_networks            = cmd_info_ptr->user_pref_networks;
    }
    #endif /* FEATURE_WCDMA || FEATURE_GSM */

  } // ss == MAIN

  if( cmd_info_ptr->nam_sel               != CM_NAM_NONE )
  {
    ph_ptr->nam_sel                        = cmd_info_ptr->nam_sel;
    if( ph_ptr->nam_sel != CM_NAM_AUTO )
    {
      ph_ptr->curr_nam = ph_ptr->nam_sel;
    }
  }

  if( cmd_info_ptr->packet_state          != CM_PACKET_STATE_NONE )
  {
    ph_ptr->packet_state                   = cmd_info_ptr->packet_state;
  }

  if(cmd_ptr->info.answer_voice != CM_ANSWER_VOICE_NONE) {

    ph_ptr->answer_voice  = cmd_info_ptr->answer_voice;
    ph_ptr->answer_uptime = uptime + cmd_info_ptr->answer_duration;

  }

  #ifdef FEATURE_DDTM_CNTL
  if( cmd_info_ptr->ddtm_pref      != CM_DDTM_PREF_NONE  &&
      cmd_info_ptr->ddtm_pref      != CM_DDTM_PREF_NO_CHANGE
    )
  {
      ph_ptr->ddtm_pref                   = cmd_info_ptr->ddtm_pref;
  }

  if ( cmd_info_ptr->ddtm_act_mask != SYS_DDTM_ACT_MASK_EMPTY &&
       cmd_info_ptr->ddtm_act_mask != SYS_DDTM_ACT_MASK_NO_CHANGE
     )
  {
    ph_ptr->ddtm_act_mask          =  cmd_info_ptr->ddtm_act_mask;
    ph_ptr->cur_ddtm_act_mask      = SYS_DDTM_ACT_MASK_EMPTY;
  }

  if ( cmd_info_ptr->ddtm_so_list_act != CM_DDTM_SO_LIST_ACT_NONE &&
      (cmd_info_ptr->ddtm_so_list_act != CM_DDTM_SO_LIST_ACT_NO_CHANGE &&
      !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_DDTM_SO_LST_ACT)))
  {
    cmph_ddtm_update_so_list( ph_ptr, cmd_info_ptr );
  }

  //copy the so list action to ph_ptr

  if (!cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_DDTM_SO_LST_ACT))
  {
      ph_ptr->ddtm_so_list_act = cmd_info_ptr->ddtm_so_list_act;
  }
  #endif /* FEATURE_DDTM_CNTL */

  #if (defined FEATURE_ALS) && (defined FEATURE_GSM)
  /*
  ** We don't want to copy the new settings into PH for
  ** CM_PH_CMD_LINE_SWITCHING and CM_PH_CMD_SELECTED_LINE
  ** until we actually hear from GSDI or MMGSDI that SIM write was
  ** successful (ALS custom will take care of that)
  **
  */
  if( cmd_ptr->cmd != CM_PH_CMD_LINE_SWITCHING &&
      cmd_ptr->cmd != CM_PH_CMD_SELECTED_LINE )
  {
    if( cmd_info_ptr->cphs_allowed   != CM_CPHS_PROC_NONE )
    {
      ph_ptr->cphs_allowed   = cmd_info_ptr->cphs_allowed;
    }
    if( cmd_info_ptr->als_allowed    != CM_ALS_PROC_NONE )
    {
      ph_ptr->als_allowed    = cmd_info_ptr->als_allowed;
    }
    if( cmd_info_ptr->line_switching != CM_ALS_LINE_SWITCHING_NONE )
    {
      ph_ptr->line_switching = cmd_info_ptr->line_switching;
    }
    if( cmd_info_ptr->line != CM_ALS_LINE_NONE )
    {
      ph_ptr->line = cmd_info_ptr->line;
    }
  }
  #endif /* #if (defined FEATURE_ALS) && (defined FEATURE_GSM) */

  #ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
  #error code not present
#endif

  if( cmd_info_ptr->rat_acq_order_pref.type == CM_ACQ_ORDER_TYPE_RAT_PRI )
  {
    *cmph_get_acq_pri_order_per_sub(ss) =
      cmd_info_ptr->rat_acq_order_pref.acq_order.rat_acq_pri_order;
  }

  if (cmd_info_ptr->lte_disable_cause != CM_LTE_DISABLE_CAUSE_NONE)
  {
    ph_ptr->lte_disable_cause = cmd_info_ptr->lte_disable_cause;
  }


  if(cmd_info_ptr->standby_pref != SYS_MODEM_DS_PREF_NONE )
  {
    ph_ptr->standby_pref          = cmd_info_ptr->standby_pref;
  }

  if(cmd_info_ptr->default_data_subs != SYS_MODEM_AS_ID_NONE)
  {
    ph_ptr->default_data_subs     = cmd_info_ptr->default_data_subs;
  }

  if(cmd_info_ptr->default_voice_subs != SYS_MODEM_AS_ID_NONE)
  {
    ph_ptr->default_voice_subs    = cmd_info_ptr->default_voice_subs;
  }

  if(cmd_info_ptr->active_subs != SYS_MODEM_AS_ID_NO_CHANGE_MASK)
  {
    ph_ptr->active_subs           = cmd_info_ptr->active_subs;
  }

  if(cmd_info_ptr->priority_subs != SYS_MODEM_AS_ID_NONE)
  {
    ph_ptr->priority_subs         = cmd_info_ptr->priority_subs;
  }

  if(cmd_info_ptr->dds_switch_type != DDS_CAUSE_NONE)
  {
    ph_ptr->dds_switch_type= cmd_info_ptr->dds_switch_type;
  }

  /* Pref PLMN request is one time, so priority queue shouldn't use it
     force PH pref after higher activities are ended */
  if(cmph_is_valid_pref_plmn_rat_req(cmd_info_ptr))
  {
    pref_rat = SYS_RAT_NONE;
  }
  else
  {
    pref_rat = cmd_info_ptr->csg_rat;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  if( ss == CM_SS_MAIN || ss == CM_SS_MAX)
  {
    (void)cmph_insert_orig_mode (
                                  CM_SS_MAIN,
                                  SD_SS_ORIG_MODE_NONE,
                                  CM_ACT_TYPE_PH_OBJ,
                                  ph_ptr->main_stack_info.pref_info.pref_term,
                                  mode_pref,
                                  ph_ptr->main_stack_info.pref_info.band_pref,
                                  ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                  ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                  ph_ptr->main_stack_info.pref_info.prl_pref,
                                  ph_ptr->main_stack_info.pref_info.roam_pref,
                                  ph_ptr->main_stack_info.pref_info.hybr_pref,
                                  ph_ptr->int_hybr_pref,
                                  ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                  (cm_act_id_type)ph_ptr,
                                  CM_ACT_UPDATE_REAS_ACT_CONT,
                                  cmd_info_ptr->sys_sel_pref_req_id,
                                  cmd_info_ptr->csg_id,
                                  pref_rat
                                );

    (void)cmph_insert_orig_mode (
                                  CM_SS_HDR,
                                  SD_SS_ORIG_MODE_NONE,
                                  CM_ACT_TYPE_PH_OBJ,
                                  ph_ptr->main_stack_info.pref_info.pref_term,
                                  ph_ptr->main_stack_info.pref_info.mode_pref,
                                  ph_ptr->main_stack_info.pref_info.band_pref,
                                  ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                  ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                  ph_ptr->main_stack_info.pref_info.prl_pref,
                                  ph_ptr->main_stack_info.pref_info.roam_pref,
                                  ph_ptr->main_stack_info.pref_info.hybr_pref,
                                  ph_ptr->int_hybr_pref,
                                  ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                  (cm_act_id_type)ph_ptr,
                                  CM_ACT_UPDATE_REAS_ACT_CONT,
                                  cmd_info_ptr->sys_sel_pref_req_id,
                                  cmd_info_ptr->csg_id,
                                  cmd_info_ptr->csg_rat
                                );

    if( cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)||
	cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) 
       )
    {
      (void)cmph_insert_orig_mode (
                                    CM_SS_HYBR_2,
                                    SD_SS_ORIG_MODE_NONE,
                                    CM_ACT_TYPE_PH_OBJ,
                                    ph_ptr->main_stack_info.pref_info.pref_term,
                                    ph_ptr->main_stack_info.pref_info.mode_pref,
                                    ph_ptr->main_stack_info.pref_info.band_pref,
                                    ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                    ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                    ph_ptr->main_stack_info.pref_info.prl_pref,
                                    ph_ptr->main_stack_info.pref_info.roam_pref,
                                    ph_ptr->main_stack_info.pref_info.hybr_pref,
                                    ph_ptr->int_hybr_pref,
                                    ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                    (cm_act_id_type)ph_ptr,
                                    CM_ACT_UPDATE_REAS_ACT_CONT,
                                    cmd_info_ptr->sys_sel_pref_req_id,
                                    cmd_info_ptr->csg_id,
                                    cmd_info_ptr->csg_rat
                                  );
    }
  } /* if( ss == CM_SS_MAIN || ss == CM_SS_MAX) */

} /* cmph_cmd_copy_fields() */

/*===========================================================================

FUNCTION cmph_cmd_answer_voice_para_check

DESCRIPTION
  Check parameter errors for answer voice command

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_cmd_answer_voice_para_check(
  cm_ph_cmd_s_type           *ph_cmd_ptr
)
{
  cm_ph_cmd_info_s_type          *cmd_info_ptr = NULL;
  cm_ph_cmd_err_e_type           cmd_err       = CM_PH_CMD_ERR_NOERR;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  if( !BETWEEN(cmd_info_ptr->answer_voice, CM_ANSWER_VOICE_NONE, CM_ANSWER_VOICE_MAX) )
  {
    cmd_err = CM_PH_CMD_ERR_ANSWER_VOICE_P;
    CM_ERR_0( "CM_PH_CMD_ERR_ANSWER_VOICE_P");
  }
  else if( ( cmd_info_ptr->answer_voice == CM_ANSWER_VOICE_AS_FAX_ONCE ||
             cmd_info_ptr->answer_voice == CM_ANSWER_VOICE_AS_MODEM_ONCE  ) &&
           cmd_info_ptr->answer_duration == 0 )
  {
    cmd_err = CM_PH_CMD_ERR_ANSWER_DURATION_P;
    CM_ERR_0( "CM_PH_CMD_ERR_ANSWER_DURATION_P");
  }

  return cmd_err;

} /* cmph_cmd_answer_voice_para_check() */



/*===========================================================================

FUNCTION cmph_cmd_nam_sel_para_check

DESCRIPTION
  Check parameter errors for mode preference command

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_cmd_nam_sel_para_check(
  cm_ph_cmd_s_type           *ph_cmd_ptr
)
{

  cm_ph_cmd_info_s_type          *cmd_info_ptr = NULL;
  cm_ph_cmd_err_e_type           cmd_err       = CM_PH_CMD_ERR_NOERR;

  int max_num_nams = NV_MAX_NAMS;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /* Check integrity of command parameters in increasing order of
  ** priority. This scheme implies that the caller of this function
  ** is always notified of the most critical error.
  */

  if( cmd_info_ptr->nam_sel != CM_NAM_AUTO &&
      !BETWEEN((int)cmd_info_ptr->nam_sel, (int)CM_NAM_NONE, (int)NV_MAX_NAMS) )
  {
    cmd_err  = CM_PH_CMD_ERR_NAM_P;
    CM_ERR_0( "CM_PH_CMD_ERR_NAM_P");
  }
  /*lint -save -e774 Boolean within 'if' always evaluates to False */
  else if( max_num_nams == 1 && cmd_info_ptr->nam_sel == CM_NAM_AUTO )
  /*lint -restore */
  {
    cmd_err  = CM_PH_CMD_ERR_NAM_P;
    CM_ERR_0( "CM_PH_CMD_ERR_NAM_P");
  }

  return cmd_err;
} /* cmph_cmd_nam_sel_para_check() */



/*===========================================================================

FUNCTION cmph_cmd_oprt_mode_para_check

DESCRIPTION
  Check parameter errors for operating mode setting command

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_cmd_oprt_mode_para_check(
  cm_ph_cmd_s_type           *ph_cmd_ptr
)
{
  cm_ph_cmd_info_s_type          *cmd_info_ptr = NULL;
  cm_ph_cmd_err_e_type            cmd_err      = CM_PH_CMD_ERR_NOERR;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /*
  ** The clients can not make a request to set the operating mode to test.
  ** Only the network (WCDMA/GSM) can make this request.
  */
  CM_MSG_HIGH_3("cmd_info_ptr->oprt_mode %d, cmtask_is_stop_sig_rcvd() %d, cmph_ptr()->wd_switch_on %d", 
    cmd_info_ptr->oprt_mode, cmtask_is_stop_sig_rcvd(), cmph_ptr()->wd_switch_on);

  if( ( !BETWEEN(cmd_info_ptr->oprt_mode, SYS_OPRT_MODE_NONE, SYS_OPRT_MODE_MAX ) ||
      ( cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_NET_TEST_GW )))
  {
    cmd_err  = CM_PH_CMD_ERR_OPRT_MODE_P;
  }

  if( (cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_ONLINE) && (cmtask_is_stop_sig_rcvd() == TRUE) )
  {
    cmd_err  = CM_PH_CMD_ERR_OPRT_MODE_S;
  }

  if( cmph_ptr()->wd_switch_on
    && cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_LPM
    && cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_RESET
    && cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_RESET_MODEM
    && cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_PWROFF)
  {
    cmd_err  = CM_PH_CMD_ERR_OPRT_MODE_P;
  }

  return cmd_err;
} /* cmph_cmd_oprt_mode_para_check() */


#ifdef CM_GW_SUPPORTED
/*===========================================================================

FUNCTION cmph_ps_attach_detach_para_check

DESCRIPTION
  Check parameter errors for PS attach detach commands

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_ph_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_ps_attach_detach_para_check
(
  const cm_ph_cmd_info_s_type          *cmd_info_ptr
)
/*lint -esym(715, cmd_info_ptr) */
{
  cm_ph_cmd_err_e_type           cmd_err       = CM_PH_CMD_ERR_NOERR;

  #if ( (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) \
    && !defined(CM_GW_SUPPORTED))
  /*
  ** 1x mode.
  */
  /* command not supported for 1X only mode  */
  cmd_err = CM_PH_CMD_ERR_SERVICE_DOMAIN_P;

  #else
  cmph_s_type                   *ph_ptr = cmph_ptr();
  cm_ss_e_type                  ss = CM_SS_MAIN;
  sys_sim_state_e_type          sim_state;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(cmd_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

   ss = cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);
   sim_state = sd_ss_gw_get_sim_state(ss);

  /* If PS_Invalid or PS_CS_Invalid is set in the SIM, reject PS Attach/detach
  */
  /* If trying to attach when Sim state not available, reject it
  */
  if (sim_state == SYS_SIM_STATE_PS_INVALID ||
      sim_state == SYS_SIM_STATE_CS_PS_INVALID ||
      ( sim_state == SYS_SIM_STATE_NOT_AVAILABLE &&
           cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ATTACH )
         )
     {
       cmd_err = CM_PH_CMD_ERR_OTHER;
       CM_MSG_HIGH_1( "Sim state not avail or PS or CS_PS invalid: %d",sim_state);
     }

  /* Multimode */
  if ( ph_ptr->main_stack_info.pref_info.mode_pref == CM_MODE_PREF_AMPS_ONLY )

  {
    cmd_err  = CM_PH_CMD_ERR_MODE_PREF_P;
    CM_ERR_0( "Invalid phone mode pref");

  }

  if( cmd_info_ptr->pref_term != CM_PREF_TERM_PWR_CYCLE )
  {
    /* currently only this is supported for PS attach */
      cmd_err = CM_PH_CMD_ERR_PREF_TERM_P;
      CM_ERR_1( "Invalid service domain pref parameter:",
                         cmd_info_ptr->pref_term);
  }

  if( cmd_info_ptr->band_pref != CM_BAND_PREF_NO_CHANGE )
  {
    cmd_err  = CM_PH_CMD_ERR_BAND_PREF_P;
    CM_ERR_0( "CM_PH_CMD_ERR_BAND_PREF_P");
  }

  if( cmd_info_ptr->roam_pref != CM_ROAM_PREF_NO_CHANGE )
  {
    cmd_err  = CM_PH_CMD_ERR_ROAM_PREF_P;
    CM_ERR_0( "CM_PH_CMD_ERR_ROAM_PREF_P");
  }

  if( cmd_info_ptr->mode_pref != CM_MODE_PREF_NO_CHANGE )
  {
    cmd_err  = CM_PH_CMD_ERR_MODE_PREF_P;
    CM_ERR_0( "CM_PH_CMD_ERR_MODE_PREF_P");
  }

  if( cmd_info_ptr->hybr_pref != CM_HYBR_PREF_NO_CHANGE )
  {
   cmd_err = CM_PH_CMD_ERR_HYBR_PREF_P;
   CM_ERR_0( "CM_PH_CMD_ERR_HYBR_PREF_P");
  }

  if ( cmd_info_ptr->acq_order_pref != CM_GW_ACQ_ORDER_PREF_NO_CHANGE )
  {
    cmd_err = CM_PH_CMD_ERR_ACQ_ORDER_PREF_P;
    CM_ERR_1( "Invalid acq order pref parameter:",
                      cmd_info_ptr->acq_order_pref);
  }

  if ( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_NO_CHANGE )
  {
    cmd_err = CM_PH_CMD_ERR_NETWORK_SEL_MODE_P;
    CM_ERR_1( "Invalid network sel mode pref parameter:",
                      cmd_info_ptr->network_sel_mode_pref);
  }

  /* PS_LOCAL_DETACH not allowed in CS only mode */
  if ( cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_LOCAL_DETACH &&
       ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY)
  {
    cmd_err = CM_PH_CMD_ERR_SERVICE_DOMAIN_P;
    CM_MSG_HIGH_2( "Invalid srv_domain_pref parameter %d in current domain pref %d",
                      cmd_info_ptr->srv_domain_pref,
                      ph_ptr->main_stack_info.pref_info.srv_domain_pref);
  }

  #endif /* FEATURE_MMODE_CDMA_800) || FEATURE_MMODE_CDMA_1900 && !FEATURE_WCDMA && !FEATURE_GSM */

  #ifdef FEATURE_MMODE_DUAL_SIM
  /* When adding PS to the service domain preference to a subscription
  ** Check whether this is the dedicated data subscription
  */
  if( cmph_is_msim()
      &&
      (cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ATTACH  ||
       cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_DETACH)
    )
  {
    if( (ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY
           #ifdef FEATURE_MMODE_TRIPLE_SIM
           || ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY
           #endif
           )&&
          ph_ptr->default_data_subs != cmd_info_ptr->cmd_subs
          &&
          (cmpmprx_get_num_of_active_data() != 2)
        )
    {
      cmd_err = CM_PH_CMD_ERR_SERVICE_DOMAIN_P;
      CM_MSG_HIGH_1( "Invalid service domain pref parameter: %d",
                        cmd_info_ptr->srv_domain_pref);
    }
  }
  #endif /* FEATURE_MMODE_DUAL_SIM */

   if((cmpm_ptr()->ims_for_nondds) && 
	(cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_DETACH) &&
	(ph_ptr->default_data_subs != cmd_info_ptr->cmd_subs) &&
	(CMPH_SS_SRV_DOMAIN_PREF(cmd_info_ptr->cmd_subs,ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
	  CMPH_SS_SRV_DOMAIN_PREF(cmd_info_ptr->cmd_subs,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS ))
  {
	CM_MSG_HIGH_0("Due to PS_DETACH on ims_for_nondds Sub, reject SYS SEL PREF");
	cmd_err = CM_PH_CMD_ERR_SERVICE_DOMAIN_P;
  } 

  return cmd_err;
}
/*lint +esym(715, cmd_info_ptr) */
#endif /* FEATURE_WCDMA || FEATURE_GSM */


/*===========================================================================

FUNCTION cmph_cmd_avoid_sys_para_check

DESCRIPTION
  Check parameter errors for avoid sys command

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_cmd_avoid_sys_para_check(
  cm_ph_cmd_s_type           *ph_cmd_ptr
)
{
  cm_ph_cmd_info_s_type          *cmd_info_ptr = NULL;
  cm_ph_cmd_err_e_type            cmd_err      = CM_PH_CMD_ERR_NOERR;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  if( !INRANGE(cmd_info_ptr->avoid_type, CM_SS_AVOID_SYS_SRV_IF_UZ,
    CM_SS_AVOID_SYS_MAX) )
  {
    cmd_err  = CM_PH_CMD_ERR_AVOID_SYS_P;
    CM_ERR_0( "CM_CMD_ERR_BAD_AVOID_SYS_P");
  }

  return cmd_err;
} /* cmph_cmd_avoid_sys_para_check() */

/*===========================================================================

FUNCTION  cmph_cmd_hplmn_srch_para_check

DESCRIPTION
  This function checks current CM state for hplmn search request.

DEPENDENCIES
  none

RETURN VALUE
  CM_PH_CMD_ERR_NOERR if no parameter related errors,
  otherwise specific cm_ph_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ph_cmd_err_e_type       cmph_cmd_hplmn_srch_para_check(

  const cm_ph_cmd_info_s_type     *cmd_info_ptr
    /* Pointer to a cmd info object */
)
{
  cm_ph_cmd_err_e_type       cmd_err      = CM_PH_CMD_ERR_NOERR;

  #if ( (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) \
    && !defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) \
    && !defined(FEATURE_GW_ON_DEMAND_HPLMN_SRCH))
  /*
  ** 1x mode.
  */
  /* command not supported for 1X only mode  */
  cmd_err = CM_PH_CMD_ERR_SERVICE_DOMAIN_P;

  /* To suppress lint */
  SYS_ARG_NOT_USED (cmd_info_ptr);

  #else
  cmph_s_type                    *ph_ptr       = cmph_ptr();

  cm_ss_e_type                   ss = CM_SS_MAIN;
  sys_modem_as_id_e_type   asubs_id = SYS_MODEM_AS_ID_1;

  cm_mode_pref_e_type            network_type;
  /*----------------------------------------------------------------------*/

  if (cmph_is_msim())
  {
    asubs_id = cmd_info_ptr->cmd_subs;
    ss = cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);
  }

  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if(cmph_is_dsda() && asubs_id == SYS_MODEM_AS_ID_2)
  {
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if (cmph_is_sxlte())
    {
      network_type = ph_ptr->hybr_3_stack_info.pref_info.network_type;
    }
    else
    #endif
    {
      network_type = ph_ptr->hybr_2_stack_info.pref_info.network_type;
    }
  }
  else
  #endif
  {
    network_type = ph_ptr->main_stack_info.pref_info.network_type;
  }

  /* HPLMN SRCH is not allowed when non-ps calls are present
  */
  if ( !( cmcall_count_calls_with_call_type( CM_CALL_TYPE_PS_DATA ) ==
          cmcall_call_ids_allocated_per_ss(ss)) &&
          cmph_is_msim()
     )
  {
    cmd_err = CM_PH_CMD_ERR_IN_USE_S;
  }
  else if (!( cmcall_count_calls_with_call_type( CM_CALL_TYPE_PS_DATA ) ==
                cmcall_call_ids_allocated()) &&
                cmph_is_ssim()
        )
  {
    cmd_err = CM_PH_CMD_ERR_IN_USE_S;
  }
  else if (network_type != CM_MODE_PREF_NONE)
  {
    /* Get networks is pending, reject the HPLMN srch request
    */
    cmd_err = CM_PH_CMD_ERR_GET_NETWORKS_S;
  }
  else if( CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) !=
         CM_NETWORK_SEL_MODE_PREF_AUTOMATIC)
  {
    cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
  }
  else if( cmd_info_ptr->band_pref != CM_BAND_PREF_NO_CHANGE )
  {
    cmd_err  = CM_PH_CMD_ERR_BAND_PREF_P;
  }
  else if( cmd_info_ptr->roam_pref != CM_ROAM_PREF_NO_CHANGE )
  {
    cmd_err  = CM_PH_CMD_ERR_ROAM_PREF_P;
  }
  else if( cmd_info_ptr->mode_pref != CM_MODE_PREF_NO_CHANGE )
  {
    cmd_err  = CM_PH_CMD_ERR_MODE_PREF_P;
  }
  else if( cmd_info_ptr->hybr_pref != CM_HYBR_PREF_NO_CHANGE )
  {
   cmd_err = CM_PH_CMD_ERR_HYBR_PREF_P;
  }
  else if( cmd_info_ptr->acq_order_pref != CM_GW_ACQ_ORDER_PREF_NO_CHANGE )
  {
    cmd_err = CM_PH_CMD_ERR_ACQ_ORDER_PREF_P;
  }
  else if( cmd_info_ptr->pref_term != CM_PREF_TERM_PWR_CYCLE )
  {
    cmd_err = CM_PH_CMD_ERR_PREF_TERM_P;
  }

  if (cmd_err != CM_PH_CMD_ERR_NOERR)
  {
    CM_MSG_HIGH_1 ( "hplmn_srch_para_check returns %d", cmd_err );
  }

  #endif

  return cmd_err;

} /* cmph_cmd_hplmn_srch_para_check */

/*===========================================================================

FUNCTION  cmph_map_sys_rat_to_sd_mode

DESCRIPTION
  Map RAT selected by user to internal SD sys mode.

  If utility function that is defined in GWL feature is not defined then
  that is an error, so will return an invalid mode pref.

===========================================================================*/
static sd_mode_e_type cmph_map_sys_rat_to_sd_mode(

  sys_radio_access_tech_e_type    rat
    /* RAT that needs to be mapped to internal CM/SD type */
)
{
  sd_mode_e_type sd_mode = SYS_SYS_MODE_NO_SRV;

  #if (defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)||\
       defined(FEATURE_TDSCDMA))
  sd_mode = cmregprx_map_sys_rat_to_sd_mode(rat);
  #endif

  return sd_mode;
}

/*===========================================================================

FUNCTION  cmph_cmd_rat_acq_order_para_check

DESCRIPTION
  This function checks parameter validity for rat_acq_order. It will modify the new rat_acq_order found in 
  cmd_info_ptr to contain only those RATs present in the original list found in ph_ptr. 

DEPENDENCIES
  none

RETURN VALUE
  CM_PH_CMD_ERR_NOERR if no parameter related errors,
  otherwise specific cm_ph_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ph_cmd_err_e_type       cmph_cmd_rat_acq_order_para_check(

  cm_ph_cmd_info_s_type     *cmd_info_ptr
    /* Pointer to a cmd info object */
)
{
  if(cmd_info_ptr->rat_acq_order_pref.type == CM_ACQ_ORDER_TYPE_RAT_PRI)
  {
#ifdef FEATURE_RAT_PRIORITY_LIST
    uint8                      i=0,num_kept=0;
    uint16                     new_sys_mode_mask = 0;
    uint16                     original_sys_mode_mask = 0;
    cmph_s_type                *ph_ptr       = cmph_ptr();
    uint16                      remove_mask=0,add_mask=0;
    
    cm_acq_pri_order_pref_s_type   *acq_pri_order = \
      &cmd_info_ptr->rat_acq_order_pref.acq_order.rat_acq_pri_order;
    cm_acq_pri_order_pref_s_type orig_acq_pri_order = \
      *cmph_get_acq_pri_order_per_sub(cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs));

    /* Create mask for new list */
      for(i=0;i<acq_pri_order->num_rat;i++)
      {
      /* Check if there is any duplicated RAT */
        if(new_sys_mode_mask & BM(acq_pri_order->acq_order[i]))
        {
          /* Duplicated sys_mode, return error */
        CM_MSG_MED_2("Duplicated RAT : acq_order[%d] = %d",
            i, acq_pri_order->acq_order[i]);
        return CM_PH_CMD_ERR_ACQ_ORDER_PREF_P;
        }
        else
        {
        /* Set the new sys_mode mask */
          new_sys_mode_mask |= BM(acq_pri_order->acq_order[i]);
        }
      }

    /* Create mask for original list */
    for(i=0;i<orig_acq_pri_order.num_rat; i++)
      {
      /* Set the original sys_mode mask */
      original_sys_mode_mask |= BM(orig_acq_pri_order.acq_order[i]);
      }

    if(!(original_sys_mode_mask & new_sys_mode_mask))
    {
      CM_MSG_MED_0("No overlap in current RAT list and new RAT list");
      return CM_PH_CMD_ERR_ACQ_ORDER_PREF_P;
    }

    /* Create mask for RATs present in new list that are not present in original list */
    remove_mask = ~original_sys_mode_mask & new_sys_mode_mask;
    
    /* Create mask for RATs present in original list that are not present in new list */
    add_mask = ~new_sys_mode_mask & original_sys_mode_mask;
    
    /* Remove unnecessary RATs from new list */
    for(i=0; i<acq_pri_order->num_rat; i++)
    {
      if(!(BM(acq_pri_order->acq_order[i]) & remove_mask))
      {
        acq_pri_order->acq_order[num_kept] = acq_pri_order->acq_order[i];
        num_kept++;
      }
    }
    new_sys_mode_mask &= ~remove_mask;
    
    /* Add necessary RATs to new list at the end */
    for(i=0; i<orig_acq_pri_order.num_rat; i++)
    {
      if(BM(orig_acq_pri_order.acq_order[i]) & add_mask
        && num_kept < orig_acq_pri_order.num_rat)
    {
        acq_pri_order->acq_order[num_kept] = orig_acq_pri_order.acq_order[i];
        num_kept++;
      }
    }
    acq_pri_order->num_rat = num_kept;
    new_sys_mode_mask |= add_mask;

    if(acq_pri_order->num_rat != orig_acq_pri_order.num_rat
      || new_sys_mode_mask != original_sys_mode_mask)
    {
      CM_MSG_MED_0("New RAT acq order not successfully constructed");
      return CM_PH_CMD_ERR_ACQ_ORDER_PREF_P;
    }

#else
    /* Rat priority list is not supported returning error */
    CM_ERR_0("RAT_PRIORITY_LIST not supported");
    return CM_PH_CMD_ERR_API_NOT_SUPPORTED_S;
#endif
  }

  return CM_PH_CMD_ERR_NOERR;

} /* cmph_cmd_rat_acq_order_para_check */

#if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
/*===========================================================================

FUNCTION cmph_is_mm_busy

DESCRIPTION
  Checks if MM is busy with MO SMS or MT call which mightnot have reached CM

DEPENDENCIES
  None

RETURN VALUE
  TRUE if MM is busy.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
static boolean cmph_is_mm_busy
(
   sys_modem_as_id_e_type asubs_id
)
{
  CM_MSG_HIGH_1( "Checking if MM is busy asubs_id %d", asubs_id );

  return (mm_per_stacks_is_mt_page_in_progress(asubs_id,SYS_MODEM_STACK_ID_1) ||
          mm_per_stacks_is_mt_page_in_progress(asubs_id,SYS_MODEM_STACK_ID_2) ||
          mm_per_stacks_is_mo_sms_in_progress(asubs_id,SYS_MODEM_STACK_ID_1)  ||
          mm_per_stacks_is_mo_sms_in_progress(asubs_id,SYS_MODEM_STACK_ID_2));
}
#endif

/*===========================================================================

FUNCTION cmph_is_sys_in_rat_priority

DESCRIPTION
  Checks to see if a sys_mode is present in rat acq order stored in global
  phone state. Goes through rat priority list and checks if rat selected by
  the user matches any entry in acq order list.

RETURN VALUE
  TRUE - if sys_mode matches for an entry in rat order list
  FALSE - otherwise

===========================================================================*/
static boolean cmph_is_sys_in_rat_priority(

  sys_sys_mode_e_type sys_mode,

  cm_acq_pri_order_pref_s_type *rat_acq_order_ptr
)
{
  boolean is_present = FALSE;
  int index = 0;

  for(index = 0; index < rat_acq_order_ptr->num_rat; index++)
  {
    if(sys_mode == rat_acq_order_ptr->acq_order[index])
    {
      is_present = TRUE;
      break;
    }
  }

  return is_present;
}

/*===========================================================================

FUNCTION cmph_is_3gpp2_mode_in_svlte

DESCRIPTION
  Checks if any of 3gpp2 modes are enabled in SVLTE config.
  If SVLTE config isn't enabled, then this function returns FALSE.

===========================================================================*/
static cm_ph_cmd_err_e_type cmph_is_3gpp2_mode_in_svlte
(
    sys_modem_as_id_e_type                   asubs_id,
        /* Indicates the SS-Instance */
    cm_mode_pref_e_type mode_pref
)
{
  cm_ph_cmd_err_e_type      cmd_err = CM_PH_CMD_ERR_NOERR;

  cmph_s_type *ph_ptr = cmph_ptr();

  /* Exit if non-svlte */
  if (!cmph_is_subs_feature_mode_1x_sxlte(asubs_id))
  {
    return cmd_err;
  }

  if ( mode_pref == CM_MODE_PREF_NO_CHANGE )
  {
    mode_pref = CMPH_SS_MODE_PREF(asubs_id, ph_ptr);
  }
  /*
  ** Check if the phones current mode contains any 3GPP2 mode
  ** and target capability supports 3GPP2.
  */
  if (  sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_CDMA_HDR,
                                            SD_SS_BAND_PREF_ANY,
                                            SYS_LTE_BAND_MASK_CONST_ANY,
                                            SD_SS_BAND_PREF_NONE) &&
          cmcall_misc_is_mode_pref(mode_pref,
                                   CM_MODE_PREF_CDMA_HDR_ONLY)
          &&
          SD_MODE_CONTAIN(cmmsc_get_cm_ss_mode_cap(cmph_map_as_id_to_cm_ss(asubs_id)),SD_SS_MODE_PREF_CDMA_HDR)
      )
  {
    cmd_err = CM_PH_CMD_ERR_NET_TYPE_P;
    CM_MSG_HIGH_2( "Invalid config: ph_ptr->main_stack_info.pref_info.mode_pref= %d, %d",ph_ptr->main_stack_info.pref_info.mode_pref, mode_pref);
  }

  return cmd_err;

}
/*===========================================================================

FUNCTION cmph_pref_plmn_rat_para_check

DESCRIPTION
  Checks if preferred PLMN RAT request can be allowed or not. Its not allowed:
  1. if user rat is not in rat priority list
  2. If user rat is not in any of protocol stack pref
  3. If user pref is not 3GPP only mode

RETURN VALUE
  TRUE - If all CM can forward request to lower layers
  FALSE - otherwise

===========================================================================*/
static cm_ph_cmd_err_e_type cmph_pref_plmn_rat_para_check(

  cm_ph_cmd_info_s_type  *cmd_info_ptr

)
{
  sd_mode_e_type sys_mode;
  sd_ss_mode_pref_e_type sd_mode_pref;
  cm_ph_cmd_err_e_type cmd_err = CM_PH_CMD_ERR_NOERR;
  cmph_s_type *ph_ptr = cmph_ptr();

  sys_mode = cmph_map_sys_rat_to_sd_mode(cmd_info_ptr->csg_rat);
  sd_mode_pref = BM(sys_mode);
  if(!sd_misc_is_mode_pref(sd_mode_pref,
                   cmph_map_cm_mode_pref_to_sd_mode_pref(CMPH_SS_MODE_PREF((cmd_info_ptr->cmd_subs),cmph_ptr()))))
  {
    return CM_PH_CMD_ERR_PREF_RAT_NOT_SUPPORTED;
  }

  if(!cmph_is_sys_in_rat_priority(sys_mode,
     cmph_get_acq_pri_order_per_sub(cmph_map_subs_to_ss(
       cmd_info_ptr->cmd_subs))))
  {
    return CM_PH_CMD_ERR_PREF_RAT_NOT_SUPPORTED;
  }

  cmd_err = cmph_is_3gpp2_mode_in_svlte(cmd_info_ptr->cmd_subs, cmd_info_ptr->mode_pref);
  if(cmd_err != CM_PH_CMD_ERR_NOERR)
  {
    return CM_PH_CMD_ERR_PREF_RAT_NOT_SUPPORTED;
  }

  return cmd_err;
}

/*===========================================================================

FUNCTION cmph_cmd_sys_sel_pref_para_check

DESCRIPTION
  Check parameter errors for system selection preference setting command.

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_cmd_sys_sel_pref_para_check(

  cm_ph_cmd_s_type           *ph_cmd_ptr

)
{
  cm_ph_cmd_info_s_type     *cmd_info_ptr = NULL;
  cm_ph_cmd_err_e_type      cmd_err       = CM_PH_CMD_ERR_NOERR;
  cmph_s_type               *ph_ptr       = cmph_ptr();

  sys_modem_as_id_e_type   asubs_id = SYS_MODEM_AS_ID_1;
  #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  sys_lte_band_mask_e_type  lte_band_pref_no_chg = SYS_LTE_BAND_MASK_CONST_NO_CHG;
  #endif
  sys_lte_band_mask_e_type  lte_band_pref_any = SYS_LTE_BAND_MASK_CONST_ANY;
  #ifdef FEATURE_CM_LTE
  cmss_s_type       *ss_ptr       = cmss_ptr();
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_cmd_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  if (cmph_is_msim())
  {
     asubs_id = cmd_info_ptr->cmd_subs;
  }

  if (!cmph_is_valid_client_asubs_id(asubs_id))
  {
    cmd_err = CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P;
    return cmd_err;
  }

  #ifdef CM_GW_SUPPORTED
  if( ( cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ATTACH ) ||
      ( cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_DETACH ) ||
      ( cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_LOCAL_DETACH ) ||
      ( cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_FORCE_PS_DETACH ))
  {
    cmd_err = cmph_ps_attach_detach_para_check( cmd_info_ptr );

    return cmd_err;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_HPLMN_SRCH)
  {
    cmd_err = cmph_cmd_hplmn_srch_para_check( cmd_info_ptr );

    return cmd_err;
  }
  #endif /* (FEATURE_WCDMA) || (FEATURE_GSM) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( ! BETWEEN(cmd_info_ptr->mode_pref, CM_MODE_PREF_NONE, CM_MODE_PREF_MAX))
  {
    cmd_err  = CM_PH_CMD_ERR_MODE_PREF_P;
    CM_ERR_0( "CM_PH_CMD_ERR_MODE_PREF_P");
  }

  if( cmd_info_ptr->mode_pref != CM_MODE_PREF_NO_CHANGE &&
      ! BETWEEN(cmd_info_ptr->pref_term,
                CM_PREF_TERM_NONE,
                CM_PREF_TERM_CM_1_CALL) )
  {
    cmd_err  = CM_PH_CMD_ERR_PREF_TERM_P;
    CM_ERR_0( "CM_PH_CMD_ERR_PREF_TERM_P");
  }

  if(! BETWEEN(cmd_info_ptr->ue_usage_setting, SYS_UE_USAGE_SETTING_NONE, SYS_UE_USAGE_SETTING_MAX))
  {
    cmd_err  = CM_PH_CMD_ERR_OTHER;
    CM_ERR_0( "CM_PH_CMD_ERR_OTHER: UE USAGE SETTING");
  }

  if(! BETWEEN(cmd_info_ptr->voice_domain_pref, SYS_VOICE_DOMAIN_PREF_NONE, SYS_VOICE_DOMAIN_PREF_MAX))
  {
    cmd_err  = CM_PH_CMD_ERR_OTHER;
    CM_ERR_0( "CM_PH_CMD_ERR_OTHER: VOICE DOMAIN PREF");
  }

  #ifdef FEATURE_DOMAIN_SELECTION
  if ((cmd_info_ptr->voice_domain_pref != SYS_VOICE_DOMAIN_PREF_NO_CHANGE) &&
       cmsds_get_config_ptr(asubs_id)->is_voice_domain_pref_locked )
  {
    cmd_err  = CM_PH_CMD_ERR_OTHER;
    CM_MSG_HIGH_3( "Sub %d CM_PH_CMD_ERR_OTHER: VOICE DOMAIN PREF is locked, cmd_voice_domain_pref=%d",
                   asubs_id,
                   cmsds_get_config_ptr(asubs_id)->is_voice_domain_pref_locked,
                   cmd_info_ptr->voice_domain_pref );
  }
  #endif

  if ((cmd_info_ptr->voice_domain_pref != SYS_VOICE_DOMAIN_PREF_NO_CHANGE) &&
      (cmd_info_ptr->voice_domain_pref != CMPH_SS_VOICE_DOMAIN_PREF(asubs_id, ph_ptr)) &&
      !cmph_is_voice_domain_pref_change_allowed(cmd_info_ptr)
     )
  {
    cmd_err  = CM_PH_CMD_ERR_IN_USE_S;
    CM_MSG_HIGH_3( "Sub %d CM_PH_CMD_ERR_IN_USE_S: cmd_voice_pref = %d, ph_voice_dom_pref = %d",
                   asubs_id,
                   cmd_info_ptr->voice_domain_pref,
                   CMPH_SS_VOICE_DOMAIN_PREF(asubs_id, ph_ptr) );
  }

  if(! BETWEEN(cmd_info_ptr->lte_disable_cause, CM_LTE_DISABLE_CAUSE_NONE, CM_LTE_DISABLE_CAUSE_MAX))
  {
    cmd_err  = CM_PH_CMD_ERR_OTHER;
    CM_ERR_0( "CM_PH_CMD_ERR_OTHER: LTE DISBALE CAUSE");
  }

  if((cmph_ptr()->internal_standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY) &&
     (( cmcall_misc_is_mode_pref(cmd_info_ptr->mode_pref, CM_MODE_PREF_TDS_ONLY)  &&
              (ph_ptr->mode_disabled_in_TSTS & SYS_SYS_MODE_MASK_TDS)) ||
     ( cmcall_misc_is_mode_pref(cmd_info_ptr->mode_pref , CM_MODE_PREF_LTE_ONLY)  &&
              (ph_ptr->mode_disabled_in_TSTS & SYS_SYS_MODE_MASK_LTE)))
   )
  {
    cmd_err  = CM_PH_CMD_ERR_MODE_PREF_P;
    CM_MSG_HIGH_3( "CM_PH_CMD_ERR_MODE_PREF: Reject sys_sel_pref, mode %d, sub %d, in TSTS, add T or L not allowed %d",
                                 cmd_info_ptr->cmd_subs, cmd_info_ptr->mode_pref, ph_ptr->mode_disabled_in_TSTS);
  }

  /*  CM should call NAS API, only if there is no active call except for PS data calls.
  *   CM would reject this request if there is a MT page in progress.
  */
#if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  if( ( cmph_ptr()->is_mode_change_due_to_ef_rat == FALSE )
                              &&
      ( (cmd_info_ptr->mode_pref != CM_MODE_PREF_NO_CHANGE) ||
        (cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_NO_CHANGE) ||
        (cmd_info_ptr->band_pref != CM_BAND_PREF_NO_CHANGE) ||
         !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&(cmd_info_ptr->lte_band_pref),&lte_band_pref_no_chg) ||
        (cmd_info_ptr->tds_band_pref != CM_BAND_PREF_NO_CHANGE) ||
        (cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_NO_CHANGE) )
                              &&
      ((cm_number_of_allocated_calls() ==
       cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_PS_DATA)) ||
      ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VOICE)  > 0) &&
      ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VOICE) ==
             cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_VOICE,CM_CALL_INCOM_SUBST_SETUP_PROCESSED)) ||
            (cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VOICE) ==
             cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_VOICE,CM_CALL_INCOM_SUBST_SETUP)) 
          )
        )
                              ||
    ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_CS_DATA)  > 0) &&
      ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_CS_DATA) ==
             cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_CS_DATA,CM_CALL_INCOM_SUBST_SETUP_PROCESSED)) ||
            (cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_CS_DATA) ==
             cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_CS_DATA,CM_CALL_INCOM_SUBST_SETUP))
          )
        )
                              ||
    ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VT)  > 0) &&
      ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VT) ==
             cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_VT,CM_CALL_INCOM_SUBST_SETUP_PROCESSED)) ||
            (cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VT) ==
             cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_VT,CM_CALL_INCOM_SUBST_SETUP))
          )
        )
      )
                              &&
      (cmph_is_mm_busy(cmd_info_ptr->cmd_subs) == TRUE)
     &&
     (cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH)
    )
    {
      cmd_err  = CM_PH_CMD_ERR_IN_USE_S;
      CM_MSG_HIGH_0( "CM_PH_CMD_ERR_IN_USE_S: Calls in Progress" );
    }
#endif

  SYS_LTE_BAND_MASK_ADD_BAND(&lte_band_pref_any,SYS_SBAND_LTE_EUTRAN_BAND60 ); // NO_CHG

  if((cmd_info_ptr->band_pref == CM_BAND_PREF_NONE &&
       SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&cmd_info_ptr->lte_band_pref)&&
       cmd_info_ptr->tds_band_pref == CM_BAND_PREF_NONE)
      ||
      !SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&lte_band_pref_any,&cmd_info_ptr->lte_band_pref)
      ||
    (cmd_info_ptr->tds_band_pref > CM_BAND_PREF_TDS_ANY &&
       cmd_info_ptr->tds_band_pref != CM_BAND_PREF_NO_CHANGE )
      ||
    (cmd_info_ptr->band_pref == CM_BAND_PREF_MAX))
  {
    cmd_err  = CM_PH_CMD_ERR_BAND_PREF_P;
    CM_MSG_HIGH_0( "CM_PH_CMD_ERR_BAND_PREF_P: Band Pref is NONE or out of bounds" );
  }

  if( !((cmd_info_ptr->roam_pref == CM_ROAM_PREF_HOME) ||
        (cmd_info_ptr->roam_pref == CM_ROAM_PREF_ROAM_ONLY) ||
        (cmd_info_ptr->roam_pref == CM_ROAM_PREF_AFFIL) ||
        (cmd_info_ptr->roam_pref == CM_ROAM_PREF_ANY) ||
        (cmd_info_ptr->roam_pref == CM_ROAM_PREF_NO_CHANGE) ||
        (cmd_info_ptr->roam_pref == CM_ROAM_PREF_PERSISTENT) ))
  {
    cmd_err  = CM_PH_CMD_ERR_ROAM_PREF_P;
    CM_MSG_HIGH_0( "CM_PH_CMD_ERR_ROAM_PREF_P: Invalid Roam Pref" );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(!BETWEEN(cmd_info_ptr->hybr_pref, CM_HYBR_PREF_NONE,CM_HYBR_PREF_MAX))
  {
    cmd_err = CM_PH_CMD_ERR_HYBR_PREF_P;
  }

  #if defined(FEATURE_HDR) && defined(FEATURE_FULL_TIME_SHDR)
  #error code not present
#endif

  /* If hybr GW is not defined and the hybrid preference has WCDMA, reject
  ** the command
  */
  if( cmd_info_ptr->hybr_pref == CM_HYBR_PREF_CDMA__WCDMA ||
      cmd_info_ptr->hybr_pref == CM_HYBR_PREF_CDMA__HDR_WCDMA )
  {
    cmd_err = CM_PH_CMD_ERR_HYBR_PREF_P;
  }

  /* On SC-SVLTE the hybrid pref is determined by TRM cap. So
  ** reject the command to change hybr pref.
  */
  if(cmph_ptr()->main_stack_info.pref_info.hybr_pref == CM_HYBR_PREF_CDMA__LTE__HDR &&
     cmd_info_ptr->hybr_pref != CM_HYBR_PREF_NO_CHANGE &&
     cmd_info_ptr->hybr_pref != CM_HYBR_PREF_CDMA__LTE__HDR &&
     cmph_is_subs_feature_mode_1x_sxlte(asubs_id)
    )
  {
    #ifndef CM_DEBUG
    CM_ERR_0("SC_SVLTE: Rejecting hybr pref change");
    cmd_err = CM_PH_CMD_ERR_HYBR_PREF_P;
    return cmd_err;
    #endif //CM_DEBUG
  }
  /* For SGLTE, only hybrid_pref = NONE is accepted. */
  if(cmd_info_ptr->hybr_pref != CM_HYBR_PREF_NO_CHANGE &&
     cmd_info_ptr->hybr_pref != CM_HYBR_PREF_NONE &&
     cmph_is_subs_feature_mode_sglte(cmd_info_ptr->cmd_subs)
    )
  {
    #ifndef CM_DEBUG
    CM_ERR_0("SC_SGLTE: Rejecting hybr pref change");
    cmd_err = CM_PH_CMD_ERR_HYBR_PREF_P;
    return cmd_err;
    #endif //CM_DEBUG
  }
  /* If FEATURE_MMODE_SC_SVLTE is not defined and the hybrid preference has LTE
  ** reject the command
  */
  if( (cmd_info_ptr->hybr_pref == CM_HYBR_PREF_CDMA__LTE__HDR ||
       cmd_info_ptr->hybr_pref == CM_HYBR_PREF_CDMA__GWL__HDR ) &&
       !cmph_is_subs_feature_mode_1x_sxlte(asubs_id))
  {
    cmd_err = CM_PH_CMD_ERR_HYBR_PREF_P;
    return cmd_err;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef CM_GW_SUPPORTED
  if( !BETWEEN(cmd_info_ptr->acq_order_pref,
               CM_GW_ACQ_ORDER_PREF_NONE,
               CM_GW_ACQ_ORDER_PREF_MAX) )
  #else
  /* If not NO_CHANGE or not PERSISTENT return cmd_err */
  if (!( (cmd_info_ptr->acq_order_pref == CM_GW_ACQ_ORDER_PREF_NO_CHANGE ) ||
         (cmd_info_ptr->acq_order_pref == CM_GW_ACQ_ORDER_PREF_PERSISTENT)
       )
     )
  #endif  /* FEATURE_WCDMA || FEATURE_GSM */
  {
    cmd_err = CM_PH_CMD_ERR_ACQ_ORDER_PREF_P;
    CM_ERR_1( "Invalid acq order pref parameter:",
                      cmd_info_ptr->acq_order_pref);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef CM_GW_SUPPORTED
  if( !BETWEEN(cmd_info_ptr->srv_domain_pref,
               CM_SRV_DOMAIN_PREF_NONE,
               CM_SRV_DOMAIN_PREF_MAX) )
  #else
  if ( cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_NO_CHANGE )
  #endif  /* FEATURE_WCDMA || FEATURE_GSM */
  {
    cmd_err = CM_PH_CMD_ERR_SERVICE_DOMAIN_P;
    CM_ERR_1( "Invalid service domain pref parameter:",
                      cmd_info_ptr->srv_domain_pref);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_MMODE_DUAL_SIM
  /* When adding PS to the service domain preference to a subscription
  ** Check whether this is the dedicated data subscription
  */
  if( cmph_is_msim()
      &&
      (cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY ||
      cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS)
    )
  {
    if( (ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY
           #ifdef FEATURE_MMODE_TRIPLE_SIM
           || ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY
           #endif
           )&&
          ph_ptr->default_data_subs != cmd_info_ptr->cmd_subs
        )
    {
      cmd_err = CM_PH_CMD_ERR_SERVICE_DOMAIN_P;
      CM_MSG_HIGH_1( "Invalid service domain pref parameter: %d",
                        cmd_info_ptr->srv_domain_pref);
    }
  }

  if( cmph_is_msim()
      &&
     cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH
      &&
     (cmpmprx_get_num_of_active_data() != 2)
     )
  {
     cmd_err = CM_PH_CMD_ERR_SERVICE_DOMAIN_P;
    CM_MSG_HIGH_1( "Invalid service domain pref params: %d, on demand PS attach when cmpmprx_get_num_of_active_data is 1",
                        cmd_info_ptr->srv_domain_pref);
    
  }
  #endif /* FEATURE_MMODE_DUAL_SIM */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_HPLMN_SRCH)
  {
    cmd_err = cmph_cmd_hplmn_srch_para_check( cmd_info_ptr );

    return cmd_err;
  }

  /*
  ** For now, do not process a CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV network
  ** selection mode preference
  */
  if (( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_AUTOMATIC ) &&
      ( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_MANUAL    ) &&
      ( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV ) &&
      ( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_PERSISTENT ) &&
      ( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_NO_CHANGE ) &&
      ( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV ) &&
      ( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV ) &&
      ( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY) &&
      ( cmd_info_ptr->network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY)
     )
  {
    cmd_err = CM_PH_CMD_ERR_NETWORK_SEL_MODE_P;
    CM_ERR_1( "Invalid network sel mode pref parameter:",
                      cmd_info_ptr->srv_domain_pref);
  }

  /*
  **  Below CM_NETWORK_SEL_MODE_PREF supported for SGLTE device only
  */
  if (( ph_ptr->is_sglte_device == FALSE)
                                    &&
      (( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV ) ||
      ( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV ) ||
      ( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY) ||
      ( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY) )
     )
  {
    cmd_err = CM_PH_CMD_ERR_NETWORK_SEL_MODE_P;
    CM_ERR_2( "Network sel mode pref parameter: %d, not supported, sglte_device: %d",
                      cmd_info_ptr->srv_domain_pref, ph_ptr->is_sglte_device);
  }


  #ifdef CM_GW_SUPPORTED
  if ( cmd_err == CM_PH_CMD_ERR_NOERR )
  {
    if ((cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
        && (sys_plmn_id_is_undefined(cmd_info_ptr->plmn)))
    {
      /* If Phone is currently in SGLTE limited_only/CAMP_only operation, no
      ** need to generate this error.
      */

      if( !(ph_ptr->is_sglte_device &&
           (ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV ||
            ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY)
           )
        )
      {
        cmd_err = CM_PH_CMD_ERR_PLMN_P;
        CM_ERR_3( "Invalid plmn parameter: %d %d %d",
                        cmd_info_ptr->plmn.identity[0],
                        cmd_info_ptr->plmn.identity[1],
                        cmd_info_ptr->plmn.identity[2] );
      }
      else
      {
        /* Phone is SGLTE and currently transitioning from limited only to full
        ** service in manual mode.
        */
        if( !sys_plmn_id_is_undefined(ph_ptr->main_stack_info.pref_info.plmn))
        {
          cmd_info_ptr->plmn.identity[0] = ph_ptr->main_stack_info.pref_info.plmn.identity[0];
          cmd_info_ptr->plmn.identity[1] = ph_ptr->main_stack_info.pref_info.plmn.identity[1];
          cmd_info_ptr->plmn.identity[2] = ph_ptr->main_stack_info.pref_info.plmn.identity[2];

          CM_MSG_HIGH_3("SGLTE: Input PLMN using current ph_ptr: %d %d %d",
                                          cmd_info_ptr->plmn.identity[0],
                                          cmd_info_ptr->plmn.identity[1],
                                          cmd_info_ptr->plmn.identity[2] );
        }
      }
    }

    #ifdef FEATURE_CM_LTE
    else if((cmd_info_ptr->mode_pref == CM_MODE_PREF_LTE_ONLY)
        && ((ss_ptr->info.mode_info.gw_info.sim_state == SYS_SIM_STATE_PS_INVALID) ||
            (ss_ptr->info.mode_info.gw_info.sim_state == SYS_SIM_STATE_CS_PS_INVALID) )
         && (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL))
    {
      cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
      CM_MSG_HIGH_1 ("LTE Only not supported in sim_state: %d. Invalid mode pref (LTE Only) as sim_state is PS Invalid", ss_ptr->info.mode_info.gw_info.sim_state);
     
    }
    #endif /* FEATURE_CM_LTE */

    else if(( (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY) ||
                (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY) )
                                     &&
             ((ph_ptr->main_stack_info.pref_info.mode_pref != CM_MODE_PREF_LTE_ONLY) &&
              (ph_ptr->main_stack_info.pref_info.mode_pref != CM_MODE_PREF_TDS_LTE) &&
              (ph_ptr->main_stack_info.pref_info.mode_pref != CM_MODE_PREF_TDS_ONLY) ) )
    {
      cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
      CM_MSG_HIGH_1 ("CAMP Only not supported in mode_pref : %d", ph_ptr->main_stack_info.pref_info.mode_pref);
      CM_ERR_1( "Invalid CAMP Only as mode_pref is :", ph_ptr->main_stack_info.pref_info.mode_pref);
    }

    else if(( (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY) ||
              (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY) )
                                   &&
              (ph_ptr->main_stack_info.pref_info.srv_domain_pref != CM_SRV_DOMAIN_PREF_PS_ONLY) )
    {
      cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
      CM_MSG_HIGH_1 ("CAMP Only not supported in domain_pref : %d", ph_ptr->main_stack_info.pref_info.srv_domain_pref);
      CM_ERR_1( "Invalid CAMP Only as domain_pref is :", ph_ptr->main_stack_info.pref_info.srv_domain_pref);
    }


  } /* if ( cmd_err == CM_PH_CMD_ERR_NOERR ) */
  #endif  /* FEATURE_WCDMA || FEATURE_GSM */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( ! BETWEEN(cmd_info_ptr->prl_pref, CM_PRL_PREF_NONE, CM_PRL_PREF_MAX))
  {
    cmd_err  = CM_PH_CMD_ERR_PRL_PREF_P;
    CM_ERR_0( "CM_PH_CMD_ERR_PRL_PREF_P");
  }

  /* Check rat_acq_order parameter */
  if(BETWEEN(cmd_info_ptr->rat_acq_order_pref.type,
             CM_ACQ_ORDER_TYPE_NONE,CM_ACQ_ORDER_TYPE_MAX))
  {
    cm_ph_cmd_err_e_type      tmp_cmd_err;
    tmp_cmd_err = cmph_cmd_rat_acq_order_para_check( cmd_info_ptr );

    if(tmp_cmd_err != CM_PH_CMD_ERR_NOERR)
    {
      cmd_err = tmp_cmd_err;
    }
  }

  /* If CSG ID is specified, the RAT could have been specified.
     In such case, check if the RAT specified is proper one.
  */
  do{/* lint -e{717} */
    if(cmd_info_ptr->csg_id != SYS_CSG_ID_INVALID)
    {
      if(ph_ptr->csg_support == SYS_CSG_SUPPORT_DISABLED )
      {
        /* CSG feature is disabled but CSG ID is provided.
        */
        CM_MSG_HIGH_0( "SYS_CSG_SUPPORT_DISABLED");
        cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
        return cmd_err;
      }

      /* The RAT specified should be either UMTS or LTE.
         For all other RATs, return error.
         More RATs may support CSG in future and hence, this
         condition check is subject to be modified whenever
         such support is available.
      */
      if(cmd_info_ptr->csg_rat == SYS_RAT_UMTS_RADIO_ACCESS ||
         cmd_info_ptr->csg_rat == SYS_RAT_LTE_RADIO_ACCESS
         )
      {
          if(cmd_info_ptr->csg_rat == SYS_RAT_LTE_RADIO_ACCESS &&
             ph_ptr->csg_support != SYS_CSG_SUPPORT_WCDMA_LTE
            )
           {
              CM_MSG_HIGH_1( "CSG operation not supported on LTE  ph_ptr->csg_support: %d", ph_ptr->csg_support);
              cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
              return cmd_err;
           }
           /* If CSG RAT selected is not part of the UE mode preference, return error */
           else if((cmd_info_ptr->csg_rat == SYS_RAT_UMTS_RADIO_ACCESS &&  
                     (!cmcall_misc_is_mode_pref(CMPH_SS_MODE_PREF(asubs_id, ph_ptr),
                                                CM_MODE_PREF_WCDMA_ONLY) ||
                      !sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_WCDMA,
                                                         SD_SS_BAND_PREF_ANY,
                                                         SYS_LTE_BAND_MASK_CONST_NONE,
                                                         SD_SS_BAND_PREF_NONE)))
                   ||
                   (cmd_info_ptr->csg_rat == SYS_RAT_LTE_RADIO_ACCESS &&  
                     (!cmcall_misc_is_mode_pref(CMPH_SS_MODE_PREF(asubs_id, ph_ptr),
                                                CM_MODE_PREF_LTE_ONLY) ||
                      !sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_LTE,
                                                         SD_SS_BAND_PREF_NONE,
                                                         SYS_LTE_BAND_MASK_CONST_ANY,
                                                         SD_SS_BAND_PREF_NONE)))
                  )
           {
              CM_MSG_HIGH_0( "CSG RAT not supported by UE preference/capability");
              cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
              return cmd_err;	   
           }  

      }
      else
      {
        cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
        break; /* No need to check further errors */
      }
     /* If automatic mode support is not enabled for CSG reject the search */
     if (ph_ptr->csg_auto_mode.csg_global_mode_support == CSG_SUPPORT_NONE )
     {
      /* If CSG RAT and CSG ID - both are specified, then check for mode
         preferences....it should only be W&L related. If not, raise error.
         Only a subset is checked here. Remaining checks
         will be done while processing the command.
      */
      if(cmd_info_ptr->mode_pref == CM_MODE_PREF_CDMA_ONLY               ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_HDR_ONLY                ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_CDMA_AMPS_ONLY          ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_GPS_ONLY                ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_CDMA_HDR_ONLY           ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_CDMA_AMPS_HDR_ONLY      ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_WLAN_ONLY               ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_CDMA_WLAN               ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_HDR_WLAN                ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_CDMA_HDR_WLAN           ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_CDMA_AMPS_HDR_WLAN_ONLY ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_CDMA_AMPS_WLAN_ONLY     ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_GSM_ONLY                ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_GSM_WLAN                ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_CDMA_GSM                ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_TDS_ONLY                ||
         cmd_info_ptr->mode_pref == CM_MODE_PREF_TDS_GSM
         )
      {
        cmd_err = CM_PH_CMD_ERR_MODE_PREF_P;
        break;
      }
    }
    }
  }while(0); /* lint -e{717} */


  /* If target support 3gpp2 and 3gpp and manual network select command is
  ** issued 3gpp2 RATs should be removed and compute new mode pref for the cmd_info.
  */
  if(ph_ptr->get_net_auto_mode_enabled.get_net_auto_mode
     && cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs) == CM_SS_MAIN)
  {
    if ( sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_CDMA_HDR,
                                            SD_SS_BAND_PREF_ANY,
                                            SYS_LTE_BAND_MASK_CONST_NONE,
                                            SD_SS_BAND_PREF_NONE))
    {

      CM_MSG_HIGH_1("Manual plmn selection initiated in 3gpp2 and 3gpp target, cmd mode_pref = %d", cmd_info_ptr->mode_pref);
      
      if(((cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
          ||
          ((cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_NO_CHANGE) &&
           (ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL))
          )
         &&
         (is_contain_3GPP_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref) ||
          is_contain_3GPP_mode_pref(cmd_info_ptr->mode_pref))
        )
      {
        if( cmd_info_ptr->mode_pref == CM_MODE_PREF_NO_CHANGE &&
            is_contain_3GPP_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref))
        {
          cmd_info_ptr->mode_pref = cm_remove_mode_pref_components(ph_ptr->main_stack_info.pref_info.mode_pref,
                                                         2,
                                                         SD_SS_MODE_PREF_CDMA_AMPS_HDR,
                                                         SD_SS_MODE_PREF_GPS
                                                         );
        }
        else if(is_contain_3GPP_mode_pref(cmd_info_ptr->mode_pref))
        {
          cmd_info_ptr->mode_pref = cm_remove_mode_pref_components(cmd_info_ptr->mode_pref,
                                                                   2,
                                                                   SD_SS_MODE_PREF_CDMA_AMPS_HDR,
                                                       SD_SS_MODE_PREF_GPS
                                                       );
        }
        else
        {
          CM_MSG_HIGH_1("No change for cmd mode_pref = %d", cmd_info_ptr->mode_pref);
        }

      }
    }
  }
  else /* ! get_net_auto_mode_enabled */
  {
    if ( sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_CDMA_HDR,
                                            SD_SS_BAND_PREF_ANY,
                                            SYS_LTE_BAND_MASK_CONST_NONE,
                                            SD_SS_BAND_PREF_NONE)
         &&
         (is_contain_3GPP2_mode_pref(cmd_info_ptr->mode_pref)
           ||
          (is_contain_3GPP2_mode_pref(CMPH_SS_MODE_PREF(asubs_id, ph_ptr)) &&
           cmd_info_ptr->mode_pref == CM_MODE_PREF_NO_CHANGE)
         )
         &&
         ( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL
           ||
          ( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_NO_CHANGE &&
            CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL)
         )
		 &&
         SD_MODE_CONTAIN(cmmsc_get_cm_ss_mode_cap(cmph_map_as_id_to_cm_ss(asubs_id)),SD_SS_MODE_PREF_CDMA_HDR)
       )
    {
      CM_MSG_HIGH_0( "Invalid NET_SEL_PREF/MODE_PREF combo");
      cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
      return cmd_err;
    }

  }
  CM_MSG_HIGH_2("After ph_ptr->main_stack_info.pref_info.mode_pref %d cmd_info_ptr->mode_pref %d ",
                   ph_ptr->main_stack_info.pref_info.mode_pref,cmd_info_ptr->mode_pref);

  /* Validate pref PLMN RAT request */
  if(cmd_err == CM_PH_CMD_ERR_NOERR &&
     cmph_is_valid_pref_plmn_rat_req(cmd_info_ptr))
  {
    cmd_err = cmph_pref_plmn_rat_para_check(cmd_info_ptr);
  }

  return cmd_err;

} /* cmph_cmd_sys_sel_pref_para_check() */

#ifdef CM_GW_SUPPORTED

/*===========================================================================

FUNCTION cmph_get_efrat_mode_pref

DESCRIPTION
  Check parameter errors for system selection preference setting command.

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static cm_mode_pref_e_type cmph_get_efrat_mode_pref( void )
{
  cm_mode_pref_e_type            cm_mode_pref;

  cmmmgsdi_rat_mode_init(&cm_mode_pref);

  return cm_mode_pref;

} /* cmph_get_efrat_mode_pref */

/*===========================================================================

FUNCTION cmph_read_efrat_mode_pref_subsc_chgd

DESCRIPTION
  This function reads EF RAT mode from MMGSDI_USIM_7F66_PROP1_RAT.
  If this mode is different than one perstistent modes, then EF RAT mode is
  used to send subscription changed to lower layers.

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static  cm_mode_pref_e_type cmph_read_efrat_mode_pref_subsc_chgd(

        boolean             subscription_available

)
{
  cm_mode_pref_e_type fav_mode_pref;
  cmph_s_type         *ph_ptr = cmph_ptr();

  fav_mode_pref = CMPH_PRST_MODE_PREF(ph_ptr);

  if (ph_ptr->main_stack_info.ens_value == TRUE &&
      subscription_available == TRUE)
  {
    cmmmgsdi_rat_mode_init( &fav_mode_pref );

    if (fav_mode_pref == CM_MODE_PREF_NONE)
    {
      /* Could not read EF_RAT. Force persistent mode_pref only
      */
      fav_mode_pref = CMPH_PRST_MODE_PREF(ph_ptr);
      CM_MSG_HIGH_1("<EF_RAT> Forcing persistent_mode_pref %d as EF_RAT could not be read",\
                   fav_mode_pref );
    }
    else
    {
      CM_MSG_HIGH_1 ("<EF_RAT> Forcing mode_pref: %d", fav_mode_pref);
    }

  }
  else /* GW subscription is not available */
  {
    CM_MSG_HIGH_3 ("<EF_RAT> ens: %d gw_sub: %d Using persistent mode_pref : %d", ph_ptr->main_stack_info.ens_value,
                  subscription_available, fav_mode_pref);
    
  }

  return fav_mode_pref;

} /* cmph_read_efrat_mode_pref_subsc_chgd */


/*===========================================================================

FUNCTION cmph_is_valid_mode_pref_change_with_ef_rat

DESCRIPTION
  Checks if the mode_preference supplied is a valid one to be changed
  when EF_RAT file is present.

  Mode preference change to non-GW (EF_RAT compliant) should be allowed.
  Ex: EF_RAT mode_pref is GSM. So ph_ptr->main_stack_info.pref_info.mode_pref is GSM.
      User changes to WLAN or GSM_WLAN. It should be allowed.
      Now user changes the mode_pref to WCDMA_ONLY. It should not be
      allowed because EF_RAT has GSM_ONLY.
      User changes mode_pref from WLAN to WCDMA_ONLY/WCDMA_WLAN_ONLY.
      These are allowed.
  Bottomline - G/W/GW -> non-GW allow. Non-GW -> G/W/GW, allow as per
               EF_RAT preferences.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  TRUE if yes
  FALSE othervise

SIDE EFFECTS
 None

===========================================================================*/
static boolean cmph_is_valid_mode_pref_change_with_ef_rat
(
   cm_mode_pref_e_type   cmd_info_cm_mode_pref,
   /* User supplied mode preference */

   cm_mode_pref_e_type   ef_rat_cm_mode_pref
   /* mode pref present in EF_RAT file */

)
{
  cmph_s_type *ph_ptr = cmph_ptr();
  sd_ss_mode_pref_e_type cmd_info_sd_mode_pref;
  sd_ss_mode_pref_e_type ef_rat_sd_mode_pref;
  sd_ss_mode_pref_e_type cmph_sd_mode_pref;

#if defined FEATURE_LTE
sd_ss_mode_pref_e_type sd_ss_mode_pref_mask = SD_SS_MODE_PREF_GWL;
#else
sd_ss_mode_pref_e_type sd_ss_mode_pref_mask = SD_SS_MODE_PREF_GW;
#endif /* FEATURE_LTE */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_info_sd_mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref(
                                                      cmd_info_cm_mode_pref);
  ef_rat_sd_mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref(
                                                        ef_rat_cm_mode_pref);
  cmph_sd_mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref);

  /*lint -e655 */
  if (((cmph_sd_mode_pref & sd_ss_mode_pref_mask) ==
       (cmd_info_sd_mode_pref & sd_ss_mode_pref_mask)) ||
      ((cmd_info_sd_mode_pref & sd_ss_mode_pref_mask) == SD_SS_MODE_PREF_NONE )
     )
  {
    /* Mode pref changed to *_WLAN_* or non-GWL. Allow.
    */
    return TRUE;
  }
  else if(cmph_is_3GPP_ef_rat_mode_pref_change_allowed(cmd_info_sd_mode_pref,ef_rat_sd_mode_pref))
  {
      /* new mode pref is subset of EF-RAT */
      return TRUE;
  }
  else
  {
    /* Do not allow. Ex: GSM_WLAN to WCDMA_WLAN */
    return FALSE;
  }

  /*lint +e655 */

}

#endif /* CM_GW_SUPPORTED */


/*===========================================================================

FUNCTION cmph_cmd_sys_sel_pref_irat_check

DESCRIPTION
  Check parameter errors for system selection preference setting command.

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
/*lint -esym(818,ph_cmd_ptr) */
static cm_ph_cmd_err_e_type     cmph_cmd_sys_sel_pref_irat_check(

       cm_ph_cmd_s_type   *ph_cmd_ptr

)
{
  #ifdef CM_GW_SUPPORTED

  cm_ph_cmd_info_s_type         *cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  cm_ph_cmd_err_e_type           cmd_err      = CM_PH_CMD_ERR_NOERR;

  cmph_s_type                   *ph_ptr = cmph_ptr();

  sys_modem_as_id_e_type    asubs_id = SYS_MODEM_AS_ID_1;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_cmd_ptr != NULL );

  if (cmph_is_msim())
  {
     asubs_id = cmd_info_ptr->cmd_subs;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* check if RAT balancing feature is enabled and client is not CM itself.
  */

  /* Return if rat balancing is off.
  */

  if (ph_ptr->is_rat_bal != TRUE)
  {
    return CM_PH_CMD_ERR_NOERR;
  }

  /* Block user from changing mode_pref of the phone only if
  ** UIM_USIM_RAT file is present.
  */
  return cmd_err;

  #else
  SYS_ARG_NOT_USED( ph_cmd_ptr );

  return CM_PH_CMD_ERR_NOERR;

  #endif /* CM_GW_SUPPORTED */
} /* cmph_cmd_sys_sel_pref_irat_check() */
/*lint +esym(818,ph_cmd_ptr) */


/*===========================================================================

FUNCTION  cmph_cmd_subscription_available_cmd_para_check

DESCRIPTION
  This function validates the subscription available command parameters.

DEPENDENCIES
  none

RETURN VALUE
  CM_PH_CMD_ERR_NOERR if no parameter related errors,
  otherwise specific cm_ph_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_cmd_subscription_available_cmd_para_check
(
  const cmph_s_type            *ph_ptr,
      /* Pointer to a phone object */

  const cm_ph_cmd_info_s_type  *cmd_info_ptr
      /* Pointer to the phone command */
)
{
  cm_ph_cmd_err_e_type         cmd_err = CM_PH_CMD_ERR_NOERR;


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr       != NULL);
  CM_ASSERT(cmd_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* If hold command queue has subscription command don't process this subsc
  ** command. Instead, put the command to hold command queue(in forward_mmll)
  ** to make sure subsc command are processed sequentially.
  ** Directly return no error here to make sure subsc command won't be rejected
  **
  */
  if(cmph_is_subsc_cmd_on_hold() &&
    cmd_info_ptr->hold_cmd_reason != CM_HOLD_CMD_REAS_EMG)
  {
    return CM_PH_CMD_ERR_NOERR;
  }

  if ((cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE) ||
      (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_CDMA) ||
      (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_AMPS))
  {
    CM_MSG_HIGH_0("Ignore subs change command due to oprt_mode");
    return CM_PH_CMD_ERR_OPRT_MODE_S;
  }

  /*
  ** If the client has indicated that the CDMA subscription information
  ** is now available, verify that it has not already been made available.
  */
  if ( cmd_info_ptr->cdma_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    if ( ph_ptr->is_cdma_subscription_available == TRUE )
    {
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

  /*
  ** If the client has indicated that the GSM/WCDMA/LTE subscription information
  ** is now available, verify that it has not already been made available.
  */
  if ( cmd_info_ptr->gwl_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    if ( ph_ptr->is_gwl_subscription_available == TRUE )
    {
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

  /*
  ** If the client has indicated that the GSM/WCDMA subscription information
  ** is now available, verify that it has not already been made available.
  */
  if ( cmd_info_ptr->gw2_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE &&
     !cmph_is_sxlte())
  {
    if ( ph_ptr->is_hybr_gw_subscription_available == TRUE )
    {
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    /*
    ** If the client has indicated that the GSM/WCDMA subscription information
    ** is now available, verify that it has not already been made available.
    */
    if ( cmd_info_ptr->gw3_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
    {
      if ( ph_ptr->is_hybr_gw3_subscription_available == TRUE )
      {
        cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
      }
    }
    #endif /*feature_mmode-triple_sim */

  if(cmtask_is_stop_sig_rcvd() == TRUE)
  {
    cmd_err  = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    CM_MSG_HIGH_0("CM task is shutting down due to task_stop_sig rcvd. ignore subs a command");
  }

  if ( cmd_err != CM_PH_CMD_ERR_NOERR )
  {
    CM_MSG_HIGH_1( "Invalid subscription available command. Subscription %d is already available",
                   cmd_err );
  }

  return cmd_err;
} /* cmph_cmd_subscription_available_cmd_para_check() */

/*===========================================================================

FUNCTION  cmph_cmd_perso_info_available_cmd_para_check

DESCRIPTION
  This function validates the perso info available command parameters.

DEPENDENCIES
  none

RETURN VALUE
  CM_PH_CMD_ERR_NOERR if no parameter related errors,
  otherwise specific cm_ph_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_cmd_perso_info_available_cmd_para_check
(
  const cmph_s_type            *ph_ptr,
      /* Pointer to a phone object */

  const cm_ph_cmd_info_s_type  *cmd_info_ptr
      /* Pointer to the phone command */
)
{
  cm_ph_cmd_err_e_type         cmd_err = CM_PH_CMD_ERR_NOERR;


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr       != NULL);
  CM_ASSERT(cmd_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if ((cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE) ||
      (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_CDMA) ||
      (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_AMPS))
  {
    CM_MSG_HIGH_0("Ignore subs change command due to oprt_mode");
    return CM_PH_CMD_ERR_OPRT_MODE_S;
  }

  /*
  ** Verify that subscription is not available on the subscription we received the perso lock.
  */
  if ( cmd_info_ptr->cdma_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    if ( ph_ptr->is_cdma_subscription_available == TRUE )
    {
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

  /*
  ** Verify that subscription is not available on the subscription we received the perso lock.
  */
  if ( cmd_info_ptr->gwl_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    if ( ph_ptr->is_gwl_subscription_available == TRUE )
    {
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

  /*
  ** Verify that subscription is not available on the subscription we received the perso lock.
  */
  if ( cmd_info_ptr->gw2_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE  &&
     !cmph_is_sxlte())
  {
    if ( ph_ptr->is_hybr_gw_subscription_available == TRUE )
    {
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

  if ( cmd_info_ptr->gw3_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    if ( ph_ptr->is_hybr_gw3_subscription_available == TRUE )
    {
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

  if ( cmd_err != CM_PH_CMD_ERR_NOERR )
  {
    CM_MSG_HIGH_3( "Subscription is already available, CDMA %d, GW %d, Hybr GW %d",
            ph_ptr->is_cdma_subscription_available,
            ph_ptr->is_gwl_subscription_available,
            ph_ptr->is_hybr_gw_subscription_available);
  }

  return cmd_err;
} /* cmph_cmd_perso_info_available_cmd_para_check() */


/*===========================================================================

FUNCTION  cmph_cmd_subscription_not_available_cmd_para_check

DESCRIPTION
  This function validates the subscription not available command parameters.

DEPENDENCIES
  none

RETURN VALUE
  CM_PH_CMD_ERR_NOERR if no parameter related errors,
  otherwise specific cm_ph_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_cmd_subscription_not_available_cmd_para_check
(
  const cmph_s_type            *ph_ptr,
      /* Pointer to a phone object */

  const cm_ph_cmd_info_s_type  *cmd_info_ptr
      /* Pointer to the phone command */
)
{
  cm_ph_cmd_err_e_type         cmd_err = CM_PH_CMD_ERR_NOERR;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr       != NULL);
  CM_ASSERT(cmd_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* If hold command queue has subscription command don't process this subsc
  ** command. Instead, put the command to hold command queue(in forward_mmll)
  ** to make sure subsc command are processed sequentially.
  ** Directly return no error here to make sure subsc command won't be rejected
  **
  */
  if(cmph_is_subsc_cmd_on_hold() &&
     cmd_info_ptr->hold_cmd_reason != CM_HOLD_CMD_REAS_EMG)
  {
    return CM_PH_CMD_ERR_NOERR;
  }

  if ((cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE) ||
      (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_CDMA) ||
      (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_AMPS))
  {
    CM_MSG_HIGH_0("Ignore subs change command due to oprt_mode");
    return CM_PH_CMD_ERR_OPRT_MODE_S;
  }

  /*
  ** If the client has indicated that the CDMA subscription information
  ** is now not available, verify that it has not already been made not
  ** available.
  */
  if ( cmd_info_ptr->cdma_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
     /* Even if the above if condition is evaluated true, if the following condition
        is true, send an error so that existing behaviour is intact.
     */
    if ( ph_ptr->is_cdma_subscription_available == FALSE )
    {
    #ifdef FEATURE_CM_MMGSDI_PROCEED_WITH_REFRESH
      /* Send ok to refresh so that stage 7 of mmgsdi is satisfied.
      **This code block is getting executed from CM task context.
      */
      if ( TRUE == cm_mmgsdi_is_waiting_to_proceed_with_refresh(MMGSDI_1X_PROV_PRI_SESSION)) /* lint -e746 */
      {
        CM_MSG_HIGH_0("Since CDMA subs is na, proceed with refresh");
        cmmmgsdi_proceed_with_refresh(CM_SS_MAIN);
      }
    #endif
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

  /*
  ** If the client has indicated that the GSM/WCDMA/LTE subscription information
  ** is now not available, verify that it has already been made not available.
  */
  if ( cmd_info_ptr->gwl_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    /* Even if the above if condition is evaluated true, if the following condition
       is true, send an error so that existing behaviour is intact.
     */
    if ( ph_ptr->is_gwl_subscription_available == FALSE )
    {
    #ifdef FEATURE_CM_MMGSDI_PROCEED_WITH_REFRESH
    /* Send ok to refresh so that stage 7 of mmgsdi is satisfied.
     **This code block is getting executed from CM task context.
     */
      /* lint -e746 */
      if ( TRUE == cm_mmgsdi_is_waiting_to_proceed_with_refresh(MMGSDI_GW_PROV_PRI_SESSION)) /* lint -e746 */
      {
        CM_MSG_HIGH_0("Since GW subs is na, proceed with refresh");
        cmmmgsdi_proceed_with_refresh(CM_SS_MAIN);
      }
    #endif
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

  /*
  ** If the client has indicated that the GSM/WCDMA subscription information
  ** is now not available, verify that it has already been made not available (Hybr2 stack).
  */
  else if ( cmd_info_ptr->gw2_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE
            && cmph_is_msim() && !cmph_is_sxlte())
  {
    /* Even if the above if condition is evaluated true, if the following condition
       is true, send an error so that existing behaviour is intact.
     */
    if ( ph_ptr->is_hybr_gw_subscription_available == FALSE )

    {
      #ifdef FEATURE_CM_MMGSDI_PROCEED_WITH_REFRESH
      /* Send ok to refresh so that stage 5/7 of mmgsdi is satisfied.
      This code block is getting executed from CM task context.
      */
      /* lint -e746 */
      if ( TRUE == cm_mmgsdi_is_waiting_to_proceed_with_refresh(MMGSDI_GW_PROV_SEC_SESSION)) /* lint -e746 */
      {
        CM_MSG_HIGH_0("Since hybrid_GW subs is na, proceed with refresh");
        cmmmgsdi_proceed_with_refresh(CM_SS_HYBR_2);
      }

      #endif
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  /*
  ** If the client has indicated that the GSM/WCDMA subscription information
  ** is now not available, verify that it has already been made not available (Hybr2 stack).
  */
  else if ( cmd_info_ptr->gw3_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE &&
            cmph_is_msim())
  {
    /* Even if the above if condition is evaluated true, if the following condition
       is true, send an error so that existing behaviour is intact.
     */
    if ( ph_ptr->is_hybr_gw3_subscription_available == FALSE )

    {
    #ifdef FEATURE_CM_MMGSDI_PROCEED_WITH_REFRESH
      /* Send ok to refresh so that stage 5/7 of mmgsdi is satisfied.
      This code block is getting executed from CM task context.
      */
      /* lint -e746 */
      if (( cmph_is_tsts() && TRUE == cm_mmgsdi_is_waiting_to_proceed_with_refresh(MMGSDI_GW_PROV_TER_SESSION))||
        ( cmph_is_sxlte() && TRUE == cm_mmgsdi_is_waiting_to_proceed_with_refresh(MMGSDI_GW_PROV_SEC_SESSION)))
      {
        CM_MSG_HIGH_0("Since hybrid_GW 3 subs is na, proceed with refresh");
        cmmmgsdi_proceed_with_refresh(CM_SS_HYBR_3);
      }

    #endif
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }
  #endif /*feature_mmode-triple_sim */

  if(cmtask_is_stop_sig_rcvd() == TRUE)
  {
    cmd_err  = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    CM_MSG_HIGH_0("CM task is shutting down due to task_stop_sig rcvd. ignore subs na command");
  }
  /*
  ** If an error has not already occurred, verify that this command
  ** can be processed for the current operating mode.
  */
  if ( cmd_err != CM_PH_CMD_ERR_NOERR )
  {
    CM_MSG_HIGH_1( "Invalid subscription not available command. Subscription  %d is already not available",
                   cmd_err );
  }
  return cmd_err;
} /* cmph_cmd_subscription_not_available_cmd_para_check() */



/*===========================================================================

FUNCTION  cmph_cmd_subscription_changed_cmd_para_check

DESCRIPTION
  This function validates the subscription not available command parameters.

DEPENDENCIES
  none

RETURN VALUE
  CM_PH_CMD_ERR_NOERR if no parameter related errors,
  otherwise specific cm_ph_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_cmd_subscription_changed_cmd_para_check
(
  const cmph_s_type            *ph_ptr,
      /* Pointer to a phone object */

  const cm_ph_cmd_info_s_type  *cmd_info_ptr
      /* Pointer to the phone command */
)
{
  cm_ph_cmd_err_e_type         cmd_err = CM_PH_CMD_ERR_NOERR;

 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr       != NULL);
  CM_ASSERT(cmd_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* If hold command queue has subscription command don't process this subsc
  ** command. Instead, put the command to hold command queue(in forward_mmll)
  ** to make sure subsc command are processed sequentially.
  ** Directly return no error here to make sure subsc command won't be rejected
  **
  */
  if(cmph_is_subsc_cmd_on_hold() &&
    cmd_info_ptr->hold_cmd_reason != CM_HOLD_CMD_REAS_EMG)
  {
    return CM_PH_CMD_ERR_NOERR;
  }

  if ((cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE) ||
      (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_CDMA) ||
      (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_AMPS))
  {
    CM_MSG_HIGH_0("Ignore subs change command due to oprt_mode");
    return CM_PH_CMD_ERR_OPRT_MODE_S;
  }

  /*
  ** If the client has indicated that the CDMA subscription information
  ** is now not available, verify that it has not already been made not
  ** available.
  */
  if ( cmd_info_ptr->cdma_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    if ( ph_ptr->is_cdma_subscription_available == FALSE )
    {
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

  /*
  ** If the client has indicated that the GSM/WCDMA/LTE subscription information
  ** is now not available, verify that it has already been made not available.
  */
  if ( cmd_info_ptr->gwl_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    if ( ph_ptr->is_gwl_subscription_available == FALSE )
    {
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }
  /*
  ** If the client has indicated that the GSM/WCDMA subscription information
  ** is now not available, verify that it has already been made not available.
  */
  if ( cmd_info_ptr->gw2_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE
       && cmph_is_msim() && !cmph_is_sxlte())
  {
    if ( ph_ptr->is_hybr_gw_subscription_available == FALSE )
    {
      cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
    }
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
   /*
   ** If the client has indicated that the GSM/WCDMA subscription information
   ** is now not available, verify that it has already been made not available.
   */
   if ( cmd_info_ptr->gw3_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE )
   {
     if ( ph_ptr->is_hybr_gw3_subscription_available == FALSE )
     {
       cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
     }
   }
 #endif /*feature_mmode-triple_sim */
  /*
  ** If an error has not already occurred, verify that this command
  ** can be processed for the current operating mode.
  */
  if ( cmd_err == CM_PH_CMD_ERR_NOERR )
  {
    if ( !cmph_in_valid_oprt_mode( ph_ptr ) )
    {
      cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
    }
  }
  else
  {
    CM_ERR_0( "Invalid subscription changed command. "
            "Subscription is not available" );
  }
  return cmd_err;
} /* cmph_cmd_subscription_changed_cmd_para_check() */


#if ( defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) )

/*===========================================================================

FUNCTION cmph_cmd_change_rtre_config_para_check

DESCRIPTION
  Check parameter errors for change RTRE config command

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_cmd_change_rtre_config_para_check(

  cm_ph_cmd_s_type           *ph_cmd_ptr

)
{
  cm_ph_cmd_info_s_type          *cmd_info_ptr = NULL;
  cm_ph_cmd_err_e_type           cmd_err       = CM_PH_CMD_ERR_NOERR;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  if( !INRANGE(cmd_info_ptr->rtre_config, CM_RTRE_CONFIG_RUIM_ONLY,
    CM_RTRE_CONFIG__MAX) )
  {
    cmd_err  = CM_PH_CMD_ERR_RTRE_CONFIG_P;
    CM_ERR_0( "CM_PH_CMD_ERR_RTRE_CONFIG_P");
  }

  return cmd_err;
} /* cmph_cmd_change_rtre_config_para_check() */
#endif /* defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */


#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
#error code not present
#endif /* FEATURE_UMTS_1X_HANDOVER_UMTSMSM */


/*===========================================================================

FUNCTION cmph_is_valid_subscription_id

DESCRIPTION
  Check whether a specified pref_term is temporary for call purposes.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if the specified pref_term is temporary.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
static boolean cmph_is_valid_subscription_id(

       sys_modem_as_id_e_type      asubs_id
          /* Subscription id to be validated */

)
{
  if(!BETWEEN(asubs_id,SYS_MODEM_AS_ID_NONE,SYS_MODEM_AS_ID_MAX))
  {
    return FALSE;
  }

  if( cmpmprx_get_device_mode() != SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY &&
                  asubs_id == SYS_MODEM_AS_ID_3)
  {
    return FALSE;
  }

  if( cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_SINGLE_SIM &&
     !(asubs_id == SYS_MODEM_AS_ID_1 || asubs_id == SYS_MODEM_AS_ID_NO_CHANGE))
  {
    return FALSE;
  }

  return TRUE;

} /* cmph_is_valid_subscription_id */


/*===========================================================================

FUNCTION cmph_is_valid_client_asubs_id

DESCRIPTION
  Check whether the asubs_id is valid.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if the asubs_id is valid.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
static boolean cmph_is_valid_client_asubs_id(

       sys_modem_as_id_e_type      asubs_id
          /* Subscription id to be validated */

)
{
  switch(asubs_id)
  {
    case SYS_MODEM_AS_ID_1:
    case SYS_MODEM_AS_ID_2:
    #ifdef FEATURE_MMODE_TRIPLE_SIM
    case SYS_MODEM_AS_ID_3:
    #endif
      return TRUE;

    default:
      return FALSE;
  }
} /* cmph_is_valid_subscription_id */

/*===========================================================================
FUNCTION cmph_is_rf_initialized

  RF should be initialized and GPS RF should be completed before we bring
  phone to ONLINE. If CM receives ONLINE while RF is not initiaized or GPS RF
  cal is not completed, return error

===========================================================================*/
static boolean cmph_is_rf_initialized(sys_oprt_mode_e_type oprt_mode)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  #ifdef FEATURE_MMODE_TARGET_BRINGUP_DISABLE_MODEM_DRIVER
  CM_MSG_HIGH_2( "TARGET BRINGUP: By Pass RF %d and GPS %d Init for ONLINE",
                 ph_ptr->rf_init_status, ph_ptr->is_gps_pgi_init_complete );
  #else
  if(oprt_mode == SYS_OPRT_MODE_ONLINE &&
     (ph_ptr->rf_init_status != CMPH_RF_INIT_READY ||
       ph_ptr->is_gps_pgi_init_complete == FALSE )
     )
  {
    ph_ptr->is_pending_online = TRUE;

    CM_MSG_HIGH_3("RFM state unknown defer ONLINE RF = %d GPS = %d is_pending_online = %d",
                ph_ptr->rf_init_status,
                ph_ptr->is_gps_pgi_init_complete,
                ph_ptr->is_pending_online);

    return FALSE;
  }
  #endif

  return TRUE;
}

/*===========================================================================
FUNCTION cmph_rf_status_oprt_mode_proc

  If RF status is set to indicate buffering of ONLINE and we process
  non ONLINE oprt modes, then drop pending ONLINE request.

===========================================================================*/
static void cmph_rf_status_oprt_mode_proc(sys_oprt_mode_e_type oprt_mode)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  if(oprt_mode != SYS_OPRT_MODE_ONLINE &&
     ph_ptr->is_pending_online )
  {
    ph_ptr->is_pending_online = FALSE;
  }

  CM_MSG_HIGH_2( "proc oprt mode %d when rf status is %d",
             oprt_mode, ph_ptr->rf_init_status);
}

/*===========================================================================

FUNCTION cmph_rf_init_complete_event_proc

DESCRIPTION
  When RFM init is complete, phone is put on OFFLINE/FTM on failure and
  ONLINE on success.

  A phone state is updated to keep track of RFM init status. If
  CM haven't received RFM complete indication, then phone isn't allowed to
  go to ONLINE.

INPUT
  Payload sent from RF.

===========================================================================*/
void cmph_rf_init_complete_event_proc(const rf_init_comp_msg_type *rfm_ind)
{
  cmph_s_type* ph_ptr = cmph_ptr();
  sys_oprt_mode_e_type oprt_mode;

  CM_MSG_HIGH_4("RFM RF init status recvd = %d, curr RF = %d, GPS = %d is_pending_online = %d",
             rfm_ind->rf_init_success,
             ph_ptr->rf_init_status,
                ph_ptr->is_gps_pgi_init_complete,
             ph_ptr->is_pending_online);



  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(rfm_ind->rf_init_success)
  {
    ph_ptr->rf_init_status = CMPH_RF_INIT_READY;

    if( ph_ptr->is_pending_online &&
        ph_ptr->is_gps_pgi_init_complete )
    {
      (void)cm_ph_cmd_oprt_mode(NULL, NULL, CM_CLIENT_ID_ANONYMOUS,
                                SYS_OPRT_MODE_ONLINE);

      ph_ptr->is_pending_online = FALSE;
    }
  }
  else
  {
    //below will take care of moving to FTM mode
    //when NV_FTM_MODE_I is FTM or
    //NV_FTM_MODE_I is inactive and RF cal is invalid
    if( ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM || ph_ptr->nv_ftm_status != NV_DONE_S)
    {
      oprt_mode = SYS_OPRT_MODE_FTM;
    }
    else
    {
      oprt_mode = SYS_OPRT_MODE_OFFLINE;
    }

    ph_ptr->rf_init_status = CMPH_RF_INIT_FAILED;

    (void)cm_ph_cmd_oprt_mode(NULL, NULL, CM_CLIENT_ID_ANONYMOUS,
                              oprt_mode);

    /* reset the pending online flag */
    ph_ptr->is_pending_online = FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_3("RFM RF init status recvd new RF = %d, GPS = %d, is_pending_online = %d",
             ph_ptr->rf_init_status,
             ph_ptr->is_gps_pgi_init_complete,
             ph_ptr->is_pending_online);
}

#ifdef FEATURE_CGPS
/*===========================================================================

FUNCTION cmph_gps_init_complete_event_proc

DESCRIPTION
  When RFM init and GPS init are both complete, move to ONLINE state.

INPUT
  None

===========================================================================*/
void cmph_gps_init_complete_event_proc(void)
{
  cmph_s_type* ph_ptr = cmph_ptr();

  CM_MSG_HIGH_3("RFM GPS init status recvd, curr rf = %d, GPS = %d, is_pending_online = %d",
             ph_ptr->rf_init_status,
             ph_ptr->is_gps_pgi_init_complete,
             ph_ptr->is_pending_online);

  ph_ptr->is_gps_pgi_init_complete = TRUE;

  /* If RFM init has already completed & there is a pending online, move to ONLINE state */
  if( ph_ptr->is_pending_online &&
      ph_ptr->rf_init_status == CMPH_RF_INIT_READY )
  {
    ph_ptr->is_pending_online = FALSE;

    (void)cm_ph_cmd_oprt_mode( NULL, NULL, CM_CLIENT_ID_ANONYMOUS,
                              SYS_OPRT_MODE_ONLINE);
    CM_MSG_HIGH_1("RFM GPS init status recvd,new is_pending_online = %d",
               ph_ptr->is_pending_online);
  }

}
#endif

/*===========================================================================

FUNCTION cmph_sys_m_oprt_mode_proc

DESCRIPTION
  Based on oprt mode processed by CM, call corresponding modem system monitor
  APIs:
    RESET: sys_m_initiate_shutdown
    PWROFF: sys_m_initiate_poweroff
    RESET_MODE: Ignore, this is used only to restore modem from a crash.

  Any moment after calling these APIs, core may be hard-reset.

===========================================================================*/
static void cmph_sys_m_oprt_mode_proc(sys_oprt_mode_e_type oprt_mode)
{

  CM_MSG_HIGH_1("CM >> MODE_RESET|PWROFF %d >> MODEM_SYS_MONITOR", oprt_mode);
  if(oprt_mode == SYS_OPRT_MODE_RESET)
  {
    sys_m_initiate_shutdown();
  }
  if(oprt_mode == SYS_OPRT_MODE_PWROFF)
  {
    sys_m_initiate_poweroff();
  }
}

/*===========================================================================

FUNCTION cmph_rpm_init

DESCRIPTION
  Initializes the RPM object.

  This function must be called before the RPM object
  is being used, in any way, place, or form.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmph_rpm_init(void)
{
  boolean is_rpm     = FALSE;
  boolean is_lte_rpm = FALSE;

  is_rpm = cmrpm_init();

  /* If its not ATT SIM then init LTE RPM */
  if (!is_rpm)
  {
    #ifdef FEATURE_CM_LTE 
    is_lte_rpm = cmrpm_lte_init();
    #endif
  }

  #ifdef FEATURE_MMODE_RPM_TDSCDMA
  /* If its not LTE RPM then init CMCC RPM */
  if (!is_lte_rpm)
  {
    cmrpm_tds_init();
  }
  #endif  
} /* cmph_rpm_init */


/*===========================================================================

FUNCTION cmph_rpm_app_reset_reject_proc

DESCRIPTION
  Processes PH cmd from CM when app reset was rejected 

DEPENDENCIES
  RPM object must have already been initialized with cmph_rpm_init().

RETURN VALUE
None

SIDE EFFECTS
  None
===========================================================================*/

static void cmph_rpm_app_reset_reject_proc(void)
{
  if(TRUE == cmrpm_is_rpm_enabled())
  {
    cmrpm_app_reset_rejected_proc();
  }
  #ifdef FEATURE_CM_LTE
  else if(TRUE == cmrpm_lte_is_rpm_enabled())
  {
    cmrpm_lte_app_reset_rejected_proc();
  }
  #endif
  
} /* cmph_rpm_app_reset_reject_proc */


/*===========================================================================

FUNCTION cmph_rpm_read_efs_sys_time

DESCRIPTION
  This function read system time  from  EFS

DEPENDENCIES
  RPM object must have already been initialized with cmph_rpm_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmph_rpm_read_efs_sys_time(void)
{
  if(cmrpm_is_rpm_enabled() == TRUE)
  {
    cmrpm_read_efs_sys_time(TRUE);
  }
  #ifdef FEATURE_CM_LTE
  else if(cmrpm_lte_is_rpm_enabled() == TRUE)
  {
    cmrpm_lte_read_efs_sys_time(TRUE);
  }
  #endif
  else
  {
    #ifdef FEATURE_MMODE_RPM_TDSCDMA
      cmrpm_tds_read_efs_sys_time();
    #endif
  }
} /* cmph_rpm_read_efs_sys_time */

/*===========================================================================

FUNCTION cmph_rpm_write_efs_sys_time

DESCRIPTION
  This function writes system time at power-down in EFS

DEPENDENCIES
  RPM object must have already been initialized with cmph_rpm_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void  cmph_rpm_write_efs_sys_time(
  sys_oprt_mode_e_type  prev_oprt_mode,

  sys_oprt_mode_e_type  curr_oprt_mode
)
{
  #ifdef FEATURE_CM_LTE
  if(cmrpm_lte_is_rpm_enabled() == TRUE)
  {
    cmrpm_lte_write_efs_sys_time(prev_oprt_mode, curr_oprt_mode);
  }
  else
  #endif
  {
    cmrpm_write_efs_sys_time(prev_oprt_mode, curr_oprt_mode);
  }
} /* cmph_rpm_write_efs_sys_time */

/*===========================================================================
FUNCTION cmph_rpm_process_app_reset

DESCRIPTION
  Process oprt mode change 

DEPENDENCIES
  RPM object must have already been initialized.

RETURN VALUE
  TRUE if reset counter is incremented

SIDE EFFECTS
  None
===========================================================================*/
static void cmph_rpm_process_app_reset(

    cm_ph_cmd_s_type          *ph_cmd_ptr
        /* Point at phone command component */
)
{
  boolean ret_val = FALSE;
  
  if(TRUE == cmrpm_is_rpm_enabled())
  {
    ret_val = cmrpm_process_app_reset( ph_cmd_ptr );
  }
  #ifdef FEATURE_CM_LTE
  else if(TRUE == cmrpm_lte_is_rpm_enabled())
  {
    ret_val = cmrpm_lte_process_app_reset( ph_cmd_ptr );
  }
  #endif

  CM_MSG_HIGH_1("CM RPM process app reset %d",ret_val);
  
} /* cmph_rpm_process_app_reset */

/*===========================================================================

FUNCTION cmph_client_cmd_check

DESCRIPTION
  Check for phone command parameter errors and whether a specified phone
  command is allowed in the current state of the call/phone.


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  CM_PH_CMD_ERR_NOERR if command is allowed in the current state
  of the phone, specific cm_ph_cmd_err_e_type otherwise.

SIDE EFFECTS
  Might change one or more of the command parameters pointed by cmd_ptr.

===========================================================================*/
static cm_ph_cmd_err_e_type  cmph_client_cmd_check
/*lint -esym(818,ph_ptr)
** cmph_cmd_get_networks_para_check() may modify ph_ptr
*/
(

    cmph_s_type            *ph_ptr,
        /* Pointer to a phone object */

    cm_ph_cmd_s_type          *ph_cmd_ptr
        /* Point at phone command component */

)
{
  cm_ph_cmd_info_s_type          *cmd_info_ptr = NULL;
      /* Point at command information component */

  cm_ph_cmd_err_e_type           cmd_err       = CM_PH_CMD_ERR_NOERR;
      /* Initialize command error to NO-ERROR */

  boolean                        is_curr_nam_valid = TRUE;

  cm_client_type_e_type          client_type = CM_CLIENT_TYPE_MAX;
      /* Client type */

  boolean                        *network_sel_mode_pref_changed_ptr =
                            &(ph_cmd_ptr->info.net_sel_mode_pref_chgd);
     /* = TRUE if client changed the network sel mode pref */

  cm_ss_e_type                   ss;
  sys_modem_as_id_e_type   asubs_id;

  #ifdef FEATURE_DOMAIN_SELECTION
  cmsds_s_type        *sds_ptr = cmsds_ptr();
  #endif

  sd_ss_e_type        sd_ss = SD_SS_MAIN;

  boolean cm_pm_dds_switch_allowed = TRUE;
  cmph_sub_config_s_type *ph_sub_config_ptr;

  boolean is_sms_active         = FALSE;

  cm_ss_e_type ss_loop = CM_SS_MAIN;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( network_sel_mode_pref_changed_ptr != NULL );
  CM_ASSERT( ph_cmd_ptr != NULL );
  CM_ASSERT( ph_cmd_ptr->cmd_type == CM_CMD_TYPE_PH );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Validate curr_nam */
  if(!INRANGE(ph_ptr->curr_nam, 0, CM_NAM_AUTO))
  {
    CM_ERR_0( "invalid nam");
    is_curr_nam_valid = FALSE;;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  *network_sel_mode_pref_changed_ptr = FALSE;
  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );


  if (cmph_is_msim())
  {
    asubs_id = cmd_info_ptr->cmd_subs;
    ss = cmph_map_subs_to_ss(asubs_id);
  }
  else
  {
    cmd_info_ptr->cmd_subs = asubs_id = SYS_MODEM_AS_ID_1;
    ss = CM_SS_MAIN;
  }

  ph_sub_config_ptr = cmph_get_sub_config_ptr(asubs_id);

  if(ph_sub_config_ptr == NULL)
  {
    CM_MSG_HIGH_1("cmph sub config pointer[%d] is NULL",asubs_id);
    return CM_PH_CMD_ERR_NONE;
  }

  CM_MSG_HIGH_3("cmph_client_cmd_check(), cmd=%d, asubs_id=%d, ss=%d",
                         ph_cmd_ptr->cmd, asubs_id, ss);

  /* If an error code was already detected while queuing the command, return
  ** this error code now.
  */
  if( cmd_info_ptr->cmd_err != CM_PH_CMD_ERR_NOERR )
  {
      return cmd_info_ptr->cmd_err;
  }

  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  /* If stack is suspeded due to emergency call on other subs, do not allow any command */
  if(cmph_is_dsda() && cmph_ss_susp_due_to_emerg(ss) &&
    (ph_cmd_ptr->cmd != CM_PH_CMD_OPRT_MODE) &&
    (ph_cmd_ptr->cmd != CM_PH_CMD_SUBSCRIPTION_AVAILABLE) &&
    (ph_cmd_ptr->cmd != CM_PH_CMD_SUBSCRIPTION_NOT_AVAILABLE)
    )
  {
    CM_MSG_HIGH_1("Ph cmd %d not allowed due to Emerg call on other subs",ph_cmd_ptr->cmd);
    return CM_PH_CMD_ERR_IN_USE_S;
  }
  #endif/* FEATURE_MMODE_DUAL_ACTIVE */

  sd_ss = cmph_map_subs_to_sd_ss(cmd_info_ptr->cmd_subs);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check whether a specified phone command is allowed in the
  ** current state of the phone.
  */

  switch( ph_cmd_ptr->cmd )
  {

                       /*---------------------------*/
                       /* Change the operating mode */
                       /*---------------------------*/


    case CM_PH_CMD_OPRT_MODE:

      client_type = cmclient_get_client_type( ph_cmd_ptr->client_id );

      /* This trick is used to put phone into appropriate mode if there is a
      ** offline command during power up.
      ** If current operation mode is FTM mode, stay in FTM mode, otherwise goto
      ** offline
      */
      if( cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_OFFLINE_IF_NOT_FTM )
      {
        if( ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM )
        {
          cmd_info_ptr->oprt_mode = SYS_OPRT_MODE_FTM;
        }
        else
        {
          cmd_info_ptr->oprt_mode = SYS_OPRT_MODE_OFFLINE;
        }

      }
      /* Check command parameter errors - stop any further processing if
      ** any errors found.
      */
      cmd_err = cmph_cmd_oprt_mode_para_check( ph_cmd_ptr );

      if( cmd_err != CM_PH_CMD_ERR_NOERR )
      {
        break;
      }

      /* Only able to change the operating mode if this is
      ** a valid operating mode switch.
      */
      if ( ! is_valid_oprt_mode_switch(ph_ptr->oprt_mode,
                                       cmd_info_ptr->oprt_mode) )
      {
        cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
      }

      if(!cmph_is_rf_initialized(cmd_info_ptr->oprt_mode))
      {
        cmd_err = CM_PH_CMD_ERR_RF_NOT_READY;
      }

      #if defined(FEATURE_HDR) && defined(FEATURE_FULL_TIME_SHDR)
      #error code not present
#endif

      /* If RPM is enabled, and RESET command comes in, check if it's allowed
      ** or not before proceed reset process
      */
      if(cmd_err == CM_PH_CMD_ERR_NOERR)
      {
        cmph_rpm_process_app_reset(ph_cmd_ptr);
      }

      break;


    case CM_PH_CMD_WAKEUP_FROM_STANDBY:
      {
        boolean is_wakeup_valid = FALSE;
      /* Only able to change the wake-up if phone is in a
      ** a valid operating mode.
      */
      if ( ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE )
      {
        cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
      }
        if (((ph_cmd_ptr->info.wakeup_service & (CM_WAKEUP_MAIN|CM_WAKEUP_HDR)) &&
            ph_ptr->active_subs & BM(cmph_map_cm_ss_to_as_id(CM_SS_MAIN))) ||
           ((ph_cmd_ptr->info.wakeup_service & CM_WAKEUP_HYBR_GW) &&
            ph_ptr->active_subs & BM(cmph_map_cm_ss_to_as_id(CM_SS_HYBR_2))) ||
           ((ph_cmd_ptr->info.wakeup_service & CM_WAKEUP_HYBR_GW3) &&
           ph_ptr->active_subs & BM(cmph_map_cm_ss_to_as_id(CM_SS_HYBR_3))))
        {
          is_wakeup_valid = TRUE;
        }

        if (!is_wakeup_valid)
        {
          cmd_err = CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P;
          break;
        }
      }
      break;

    case CM_PH_CMD_ACTIVATE_SUBS:
    {

      /* Fail the command if there is no valid subs in the given cmd_subs_mask parameter
      */
      if( (cmd_info_ptr->cmd_subs_mask & SYS_MODEM_AS_ID_1_MASK ) == FALSE &&
          (cmd_info_ptr->cmd_subs_mask & SYS_MODEM_AS_ID_2_MASK ) == FALSE &&
          (cmd_info_ptr->cmd_subs_mask & SYS_MODEM_AS_ID_3_MASK ) == FALSE )
      {
        cmd_err = CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P;
        break;
      }

      if ((cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE) ||
          (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_CDMA) ||
          (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_AMPS))
      {
        CM_MSG_HIGH_0("Ignore subs change command due to oprt_mode");
        cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
        break;
      }
      
      break;
    }

    case CM_PH_CMD_DEACTIVATE_SUBS:
    {

      /* Fail the command if there is no valid subs in the given cmd_subs_mask parameter
      */
      if( (cmd_info_ptr->cmd_subs_mask & SYS_MODEM_AS_ID_1_MASK ) == FALSE &&
          (cmd_info_ptr->cmd_subs_mask & SYS_MODEM_AS_ID_2_MASK ) == FALSE &&
          (cmd_info_ptr->cmd_subs_mask & SYS_MODEM_AS_ID_3_MASK ) == FALSE )
      {
        cmd_err = CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P;
        break;
      }
      /* If 911 call or ECBM is in progress, reject refresh */
      if (cmcall_emergency_call_active() || cmph_is_in_emergency_cb() ||
	      ((cmcall_is_there_a_call_type(CM_SS_MAX,
          CM_CALL_TYPE_VOICE, CM_CALL_ID_INVALID)!= CM_CALL_ID_INVALID) &&
		    (cmph_is_dsds() || cmph_is_sxlte())))
      {
        /* Fail the command if phone is in-use,
        */
        CM_MSG_HIGH_0("reject deact due to emerg or voice call active");
        cmd_err = CM_PH_CMD_ERR_IN_USE_S;
        break;
      }

      if ((cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE) ||
          (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_CDMA) ||
          (cmph_ptr()->true_oprt_mode == SYS_OPRT_MODE_OFFLINE_AMPS))
      {
        CM_MSG_HIGH_0("Ignore subs change command due to oprt_mode");
        cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
        break;
      }
    }
    break;


    #if ( defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) )
    case CM_PH_CMD_CHANGE_RTRE_CONFIG:

      /* Check command parameter errors - stop any further processing if
      ** any errors found.
      */

      cmd_err = cmph_cmd_change_rtre_config_para_check( ph_cmd_ptr );
      if( cmd_err != CM_PH_CMD_ERR_NOERR )
      {
        break;
      }

      if ( ph_ptr->curr_nam != (cm_nam_e_type)NV_RUIM_NAM )
      {
        cmd_err = CM_PH_CMD_ERR_CURRENT_NAM_IS_NOT_RUIM_NAM_S;
        break;
      }

      break;
    #endif /* defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
                       /*---------------------------*/
                       /* Handle avoid sys command  */
                       /*---------------------------*/


    case CM_PH_CMD_AVOID_SYS:

      /* Check command parameter errors - stop any further processing if
      ** any errors found.
      */
      cmd_err = cmph_cmd_avoid_sys_para_check( ph_cmd_ptr );

      if( cmd_err != CM_PH_CMD_ERR_NOERR )
      {
        break;
      }

      if( cmcall_count_on_ss(CM_SS_MAIN) > 0 ||
          cmcall_count_on_ss(CM_SS_HDR) >0 )
      {
        /* Fail the command if phone is in-use,
        */
        cmd_err = CM_PH_CMD_ERR_IN_USE_S;
        break;
      }

      /* Fail the command , if phone is not online
      */
      if (ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE)
      {
        cmd_err = CM_PH_CMD_ERR_ONLINE_S;
        break;
      }
      break;

     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

             /*---------------------------------------------------*/
             /* Change the User network selection mode preference */
             /*---------------------------------------------------*/

     case CM_PH_CMD_SET_USER_NET_SEL_MODE:

       /* Check if net_sel_mode given by user is valid
       */
       if ((!BETWEEN (cmd_info_ptr->user_net_sel_mode,
                      CM_USER_NETWORK_SEL_MODE_PREF_NONE,
                      CM_USER_NETWORK_SEL_MODE_PREF_MAX)))
       {
         cmd_err = CM_PH_CMD_ERR_INVALID_USER_NET_SEL_MODE_S;
       }
       break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                  /*----------------------------------------*/
                  /* Change the Measurement mode preference */
                  /*----------------------------------------*/

    case CM_PH_CMD_MEAS_MODE:

      /* Only able to service this request if phone is ONLINE or LPM,
      */
      if(  ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE &&
           ph_ptr->oprt_mode != SYS_OPRT_MODE_LPM )
      {
        cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
        break;
      }

      if( cmclnup_is_ongoing_subsc(BM(cmd_info_ptr->cmd_subs)))
      {
        cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
        CM_MSG_HIGH_1( "CLNUP in prog. Cmd CM_PH_CMD_MEAS_MODE not allowed. cmd_err %d",
                       cmd_err );
        break;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                  /*----------------------------------------*/
                  /* Change the System Selection preference */
                  /*----------------------------------------*/

    case CM_PH_CMD_SYS_SEL_PREF:
    {
      cm_mode_pref_e_type            cm_mode_pref;
      sd_ss_mode_pref_e_type         sd_mode_pref=SD_SS_MODE_PREF_NONE;
      #ifdef FEATURE_CM_LTE
      sys_lte_band_mask_e_type       lte_band_pref_no_chg = SYS_LTE_BAND_MASK_CONST_NO_CHG;
      sys_lte_band_mask_e_type       lte_band_pref_prst;

      SYS_LTE_BAND_MASK_CLR_ALL_BANDS(&lte_band_pref_prst);
      SYS_LTE_BAND_MASK_ADD_BAND(&lte_band_pref_prst, SYS_SBAND_PERSISTENT);
      #endif
      /*- - - - - - - - - P R E - C O N D I T I O N S - - - - - - - - - - -*/

      /* Don't allow this request if phone is powering off or resetting. */
      if( !cmph_in_valid_oprt_mode( ph_ptr )
          && ph_ptr->oprt_mode != SYS_OPRT_MODE_LPM
          && ph_ptr->oprt_mode != SYS_OPRT_MODE_PWROFF)
      {
        cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
        break;
      }

      if( cmclnup_is_ongoing_subsc(BM(cmd_info_ptr->cmd_subs)))
      {
        cmd_err = CM_PH_CMD_ERR_OTHER;
        CM_MSG_HIGH_2( "CLNUP in prog. CMD %d not allowed. cmd_err = %d",
                       ph_cmd_ptr->cmd,
                       cmd_err );
        break;
      }
      #ifdef FEATURE_MMODE_DUAL_SIM
      /* If device mode is single sim, reject sys_sel_pref cmd sub2 */
      if(cmph_is_ssim() && cmd_info_ptr->cmd_subs == SYS_MODEM_AS_ID_2)
      {
        cmd_err = CM_PH_CMD_ERR_STANDBY_PREF_S;
        break;
      }
      #endif

      /*- - - - - C H E C K - P A R A M E T E R S - - - - - - - - - - - - -*/

      /* Check command parameter errors - stop any further processing if
      ** any errors found.
      */
      cmd_err = cmph_cmd_sys_sel_pref_para_check( ph_cmd_ptr );

      if(ph_cmd_ptr->info.srv_domain_pref == CM_SRV_DOMAIN_PREF_FORCE_PS_DETACH)
      {
        ph_cmd_ptr->info.srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_DETACH;

        CM_MSG_HIGH_2("Change FORCE-Detach to REGULAR-Detach! ims_for_nondds %d dds %d",
          cmpm_ptr()->ims_for_nondds,ph_ptr->default_data_subs);
      }

      /* Check whether it's OK to proceed */
      if( cmd_err != CM_PH_CMD_ERR_NOERR)
      {
        break;
      }

      /*- - - - - - - U P D A T E - P R E F - V A L U E S - - - - - - - - -*/

      /* Initialize cm_mode_pref variable */
      cm_mode_pref = cmd_info_ptr->mode_pref;

      switch(cm_mode_pref)
      {
        /*
        ** If client wishes to remove HDR from current mode preference,
        ** do it here now
        */
        case CM_MODE_PREF_CURRENT_LESS_HDR:
          cm_mode_pref = cm_remove_mode_pref_components(CMPH_SS_MODE_PREF(asubs_id, ph_ptr),
             1,
             SD_SS_MODE_PREF_HDR );
          break;

        /* If client wishes to remove AMPS from current mode preference,
        ** do it here now
        */
        case CM_MODE_PREF_CURRENT_LESS_AMPS:
          cm_mode_pref = cm_remove_mode_pref_components(CMPH_SS_MODE_PREF(asubs_id, ph_ptr),
                                                        1,
                                                        SD_SS_MODE_PREF_AMPS );
          break;

        /* If client wishes to remove HDR and AMPS from current mode preference,
        ** do it here now
        */
        case CM_MODE_PREF_CURRENT_LESS_HDR_AND_AMPS:
          cm_mode_pref = cm_remove_mode_pref_components( CMPH_SS_MODE_PREF(asubs_id, ph_ptr),
                                                         2,
                                                         SD_SS_MODE_PREF_HDR,
                                                         SD_SS_MODE_PREF_AMPS );
          break;


        case CM_MODE_PREF_DISABLE_LTE:
          /* Clear LTE and GWL bits */
          cm_mode_pref = cm_remove_mode_pref_components( CMPH_SS_MODE_PREF(asubs_id, ph_ptr),
                                                         2,
                                                         SD_SS_MODE_PREF_LTE,
                                                         BM( SD_MODE_GWL ));

          if ((cm_mode_pref == CM_MODE_PREF_NONE) &&
             (cmph_is_allow_mode_pref_none_during_lte_disable(cmd_info_ptr)))
          {
            ph_ptr->is_mode_pref_none = TRUE;
          }


          break;

        case CM_MODE_PREF_ENABLE_LTE:
          sd_mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref(
                         CMPH_SS_MODE_PREF(asubs_id, ph_ptr));

          ph_ptr->is_mode_pref_none = FALSE;
          cmd_info_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_NO_VALUE;

          /* If the current mode contains GW, set LTE and GWL bits */
          if (SD_SS_MODE_PREF_GW == sd_misc_get_common_mode_pref(sd_mode_pref,
                              SD_SS_MODE_PREF_GW))
          {
		    sd_mode_pref |= (SD_SS_MODE_PREF_LTE|BM( SD_MODE_GWL ));
            cm_mode_pref = cmph_map_sd_mode_pref_to_cm_mode_pref(sd_mode_pref);
          }
          else /* Set LTE bit */
          {
		    sd_mode_pref |= SD_SS_MODE_PREF_LTE;
            cm_mode_pref = cmph_map_sd_mode_pref_to_cm_mode_pref(sd_mode_pref);
          }

          break;

        /* Any other mode preference value, no processeing required for now */
        default:
          break;
      }

      SYS_ARG_NOT_USED(sd_mode_pref);

      if( cm_mode_pref == CM_MODE_PREF_MAX )
      {
        cmd_err = CM_PH_CMD_ERR_MODE_PREF_P;
        CM_ERR_2( "Not able to update mode pref %d with %d",
                          CMPH_SS_MODE_PREF(asubs_id, ph_ptr), cmd_info_ptr->mode_pref);
      }
      else
      {
        cmd_info_ptr->mode_pref = cm_mode_pref;
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* If client wants to restore the
      ** persistent mode preference, use the persistent mode preference.
      */
      if( cmd_info_ptr->mode_pref == CM_MODE_PREF_PERSISTENT
               && is_curr_nam_valid )
      {
        cmd_info_ptr->mode_pref = CMPH_PRST_SS_MODE_PREF( asubs_id, ph_ptr );
      }

      if((cmd_info_ptr->mode_pref != CM_MODE_PREF_NO_CHANGE) &&
         (cmd_info_ptr->mode_pref != CM_MODE_PREF_WCDMA_ONLY) &&
         ph_sub_config_ptr->wcdma_freq_lock)
      {
        CM_MSG_HIGH_0("Mode change not allowed on W channel locked phone");
        cmd_err  = CM_PH_CMD_ERR_MODE_PREF_P;
        break;
      }
      /*If mode_pref is change, checking if LTE is present in new mode pref,
      ** as it is difficult to differentiate later, if LTE was present in new_mode_pref,
      **as CM_MODE_PREF_NO_CHANGE will be made ph->mode_pref*/
      #ifdef FEATURE_CM_LTE
      if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs))
      {
        if( cmd_info_ptr->mode_pref != CM_MODE_PREF_NO_CHANGE  &&
           !SD_MODE_CONTAIN(cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->mode_pref),SD_SS_MODE_PREF_LTE)
         )
        {
          cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
        }
      }
      #endif /*FEATURE_CM_LTE*/

      /*If mode_pref is change, checking if HDR is present in new mode pref,
      ** as it is difficult to differentiate later, if LTE was present in new_mode_pref,
      **as CM_MODE_PREF_NO_CHANGE will be made ph->mode_pref*/
      if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs) &&
        ss == CM_SS_MAIN)
      {
        if( cmd_info_ptr->mode_pref != CM_MODE_PREF_NO_CHANGE  &&
           !SD_MODE_CONTAIN(cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->mode_pref),SD_SS_MODE_PREF_HDR)
         )
        {
          cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs);
        }
      }

      if (cmd_info_ptr->ue_usage_setting == SYS_UE_USAGE_SETTING_NO_CHANGE)
      {
        cmd_info_ptr->ue_usage_setting = CMPH_SS_UE_USAGE_SETTING(asubs_id, ph_ptr);
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_UE_USAGE_SETTING);
      }

      if (cmd_info_ptr->voice_domain_pref == SYS_VOICE_DOMAIN_PREF_NO_CHANGE)
      {
        cmd_info_ptr->voice_domain_pref = CMPH_SS_VOICE_DOMAIN_PREF(asubs_id, ph_ptr);
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_VOICE_DOMAIN_PREF);
      }

      if (cmd_info_ptr->lte_disable_cause == CM_LTE_DISABLE_CAUSE_NO_CHANGE)
      {
        cmd_info_ptr->lte_disable_cause = ph_ptr->lte_disable_cause;
      }

      /* If client does not want to change the mode preference, use the
      ** existing mode preference. */
      if( cmd_info_ptr->mode_pref == CM_MODE_PREF_NO_CHANGE )
      {
        cmd_info_ptr->mode_pref = CMPH_SS_USER_MODE_PREF( asubs_id, ph_ptr );

        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_MODE_PREF);
      }

      #ifdef FEATURE_MMODE_DUAL_SIM
      /* Multsim specific check - avoid the following on subs other than sub1.
         1. 3GPP2 mode pref.
         2. Hybr pref on.
      */
      if (cmph_is_msim())
      {
        cmph_msim_modify_3gpp2_pref(cmd_info_ptr->cmd_subs,
                                &(cmd_info_ptr->mode_pref),
                                &(cmd_info_ptr->hybr_pref));
      }
      #endif /* FEATURE_MMODE_DUAL_SIM */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If client does not want to change the band preference, use the
      ** current band preference. Else, if client wants to restore the
      ** persistent band preference, use the persistent band preference.
      */
      if( cmd_info_ptr->band_pref == CM_BAND_PREF_NO_CHANGE )
      {
        cmd_info_ptr->band_pref = CMPH_SS_BAND_PREF(asubs_id, ph_ptr );
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_BAND_PREF);
      }
      else if( cmd_info_ptr->band_pref == CM_BAND_PREF_PERSISTENT
               && is_curr_nam_valid )
      {
        cmd_info_ptr->band_pref = CMPH_PRST_SS_BAND_PREF(asubs_id, ph_ptr );
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If client does not want to change the LTE band preference, use the
      ** current LTE band preference. Else, if client wants to restore the
      ** persistent LTE band preference, use the persistent LTE band
      ** preference.
      */
      #ifdef FEATURE_CM_LTE
      if( SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&(cmd_info_ptr->lte_band_pref),&lte_band_pref_no_chg ))
      {
        cmd_info_ptr->lte_band_pref = CMPH_SS_LTE_BAND_PREF( asubs_id, ph_ptr );

        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_LTE_BAND_PREF);
      }
      else if( SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&(cmd_info_ptr->lte_band_pref), &lte_band_pref_prst)
               && is_curr_nam_valid )
      {
        cmd_info_ptr->lte_band_pref = CMPH_PRST_SS_LTE_BAND_PREF( asubs_id, ph_ptr );
      }
      #else
      cmd_info_ptr->lte_band_pref = SYS_LTE_BAND_MASK_CONST_NO_CHG;
      #endif

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If client does not want to change the TD-SCDMA band preference, use the
      ** current TD-SCDMA band preference. Else, if client wants to restore the
      ** persistent TD-SCDMA band preference, use the persistent TD-SCDMA band
      ** preference.
      */
      if( cmd_info_ptr->tds_band_pref == CM_BAND_PREF_NO_CHANGE )
      {
        cmd_info_ptr->tds_band_pref = CMPH_SS_TDS_BAND_PREF( asubs_id, ph_ptr );

        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_TDS_BAND_PREF);
      }
      else if( cmd_info_ptr->tds_band_pref == CM_BAND_PREF_PERSISTENT
               && is_curr_nam_valid )
      {
        cmd_info_ptr->tds_band_pref = CMPH_PRST_SS_TDS_BAND_PREF( asubs_id, ph_ptr );
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If client does not want to change the roam preference, use the
      ** current roam preference. Else, if client wants to restore the
      ** persistent roam preference, use the persistent roam preference.
      */
      if( cmd_info_ptr->roam_pref == CM_ROAM_PREF_NO_CHANGE )
      {
        cmd_info_ptr->roam_pref = CMPH_SS_ROAM_PREF( asubs_id, ph_ptr );
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_ROAM_PREF);
      }
      else if( cmd_info_ptr->roam_pref == CM_ROAM_PREF_PERSISTENT
               && is_curr_nam_valid )
      {
        cmd_info_ptr->roam_pref = CMPH_PRST_SS_ROAM_PREF(asubs_id, ph_ptr );
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If client does not want to change the hybr preference, use the
      ** current hybrid preference. Else, if client wants to restore the
      ** persistent hybrid preference, use the persistent hyrbid preference.
      */
      if( cmd_info_ptr->hybr_pref == CM_HYBR_PREF_NO_CHANGE )
      {
        cmd_info_ptr->hybr_pref = CMPH_SS_HYBR_PREF(asubs_id, ph_ptr);
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_HYBR_PREF);
      }
      else if( cmd_info_ptr->hybr_pref == CM_HYBR_PREF_PERSISTENT
               && is_curr_nam_valid )
      {
        cmd_info_ptr->hybr_pref = CMPH_PRST_SS_HYBR_PREF(asubs_id, ph_ptr);
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If client does not want to change the service domain preference,
      ** use the current service domain preference.
      */
      if( cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_NO_CHANGE )
      {
        /* cmd_info_ptr->srv_domain_pref = CMPH_SS_SRV_DOMAIN_PREF(CM_SS_MAIN, ph_ptr);
        **
        ** cmd_info_ptr is typically updated so that the value can be
        ** used to update NV in mmll_reply. srv_domain_pref between ph_ptr
        ** and NV can be different during PS attach on demand call, PS attach
        ** and PS detach scenarios, so copying srv_domain_pref from ph_ptr
        ** to cmd_info_ptr and then writing to NV will erase correct NV value
        **
        **   - Phone powers us with NV-CS_PS, Ph_ptr-CS_PS
        **   - PS_DETACH is issued  NV-CS_PS, Ph_ptr-CS_ONLY
        **   - Manual net sel is recvd with cmd_info_ptr->srv.. as NO_CHANGE
        **        if cmd_info_ptr->srv.. is copied from ph_ptr and later
        **        written to NV, NV will end up with CS_ONLY.
        **   Our design has been to not update NV with PS_ATTACH, PS_DETACH
        **   requests.
        */

      }
      else if( cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PERSISTENT
               && is_curr_nam_valid )
      {
        cmd_info_ptr->srv_domain_pref = CMPH_PRST_SS_SRV_DOMAIN_PREF( asubs_id, ph_ptr );
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If client does not want to change the network selection mode
      ** preference, use the current network selection mode preference.
      */
      if( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_NO_CHANGE )
      {
        cmd_info_ptr->network_sel_mode_pref = CMPH_SS_NETWORK_SEL_MODE_PREF( asubs_id, ph_ptr );
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_NETWORK_SEL_MODE_PREF);
      }
      else if( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_PERSISTENT
               && is_curr_nam_valid )
      {
        cmd_info_ptr->network_sel_mode_pref = CMPH_PRST_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr );
        cmd_info_ptr->pref_term = CM_PREF_TERM_PERMANENT;
        if ( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
        {
          /* In manual mode, set to TRUE.
          */
          *network_sel_mode_pref_changed_ptr = TRUE;
        }
      }
      /* Check if it is changed from manual to automatic or auto limited to AUTO, then we should
      **still be on RPLMN. So do not set the network_sel_mode_pref_changed_ptr to TRUE
      */
      else if (!((cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC &&
         CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL
                )||
               (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC &&
         CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV )
           ))
      {
        /* No, it is not switch from manual -> auto.
        */
        *network_sel_mode_pref_changed_ptr = TRUE;
      }


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If client does not want to change the acquisition order preference,
      ** use the current network selection mode preference.  Else, if client
      ** wants to restore the persistent acq order preference, use the
      ** persistent acq order preference.
      */
      if( cmd_info_ptr->acq_order_pref == CM_GW_ACQ_ORDER_PREF_NO_CHANGE )
      {
        cmd_info_ptr->acq_order_pref = CMPH_SS_ACQ_ORDER_PREF( asubs_id, ph_ptr );
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_ACQ_ORDER_PREF);
      }
      else if( cmd_info_ptr->acq_order_pref == CM_GW_ACQ_ORDER_PREF_PERSISTENT
               && is_curr_nam_valid )
      {
        cmd_info_ptr->acq_order_pref = CMPH_PRST_SS_ACQ_ORDER_PREF( asubs_id, ph_ptr );
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If client does not want to change the prl preference,
      ** use the current prl preference.
      */
      if( cmd_info_ptr->prl_pref == CM_PRL_PREF_NO_CHANGE )
      {
        cmd_info_ptr->prl_pref = CMPH_SS_PRL_PREF(asubs_id, ph_ptr);
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_PRL_PREF);
      }
      else if( cmd_info_ptr->prl_pref == CM_PRL_PREF_PERSISTENT
               && is_curr_nam_valid )
      {
        cmd_info_ptr->prl_pref = CMPH_PRST_SS_PRL_PREF(asubs_id, ph_ptr );
      }


      if( cmd_err != CM_PH_CMD_ERR_NOERR )
      {
        break;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /*- - - - - C H E C K - S P L - C O N D I T I O N S - - - - - - - - -*/

      /* validate the inter-rat mode changes
      */

      if(ss != CM_SS_HYBR_2
        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        && (ss != CM_SS_HYBR_3)
        #endif
      )
      {
        cmd_err = cmph_cmd_sys_sel_pref_irat_check(ph_cmd_ptr);
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      #ifdef FEATURE_GPSONE

      /* If the GPS session is dormant, abort it and continue
      */
      {
        cmpd_session_s_type *pd_ptr = cmpd_ptr( CMPD_SESSION_OBJ_MAIN);
        cmpd_session_s_type *pd_dmod_ptr = cmpd_ptr( CMPD_SESSION_OBJ_DMOD);

        CM_ASSERT( pd_ptr != NULL );
        CM_ASSERT( pd_dmod_ptr != NULL );

        if( pd_ptr->session_state  == CMPD_SESSION_STATE_GRANTED )
        {
          cmd_err = CM_PH_CMD_ERR_IN_USE_S;
          if( pd_ptr->dormant_status == CM_PD_SESSION_ACTIVE_TO_DORMANT )
          {
            cmpd_session_abort( CM_PD_SESSION_STATUS_ABORT_PHONE_BUSY,
                                pd_ptr->session_type, (dword)0 );
          }
        }
        if( pd_dmod_ptr->session_state  == CMPD_SESSION_STATE_GRANTED )
        {
          cmd_err = CM_PH_CMD_ERR_IN_USE_S;
          if( pd_dmod_ptr->dormant_status == CM_PD_SESSION_ACTIVE_TO_DORMANT )
          {
            cmpd_session_abort( CM_PD_SESSION_STATUS_ABORT_PHONE_BUSY,
                                pd_dmod_ptr->session_type, (dword)0 );
          }
        }

        if( cmd_err == CM_PH_CMD_ERR_IN_USE_S )
        {
          break;
        }
      }

      #endif

      /*- - - - - - V A L I D A T E - P R E F - V A L U E S - - - - - - - -*/

     if (cmd_info_ptr->mode_pref != CM_MODE_PREF_NONE)
     {

      if (!(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs) &&
           cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ATTACH ))
      {
        /* Only able to service this request if this is valid mode and band
             ** preference setting for this target/PRL.
             */
        if(
            #ifdef FEATURE_UICC_RAT_INDICATOR_SUPPORT
            ph_ptr->is_mode_change_due_to_ef_rat == FALSE &&
            #endif
            ! cmph_is_valid_mode_band_pref( cmd_info_ptr->mode_pref,
                                            cmd_info_ptr->band_pref )
            #ifdef FEATURE_CM_LTE
            &&
            ! cmph_is_valid_lte_mode_band_pref( cmd_info_ptr->mode_pref,
                                                cmd_info_ptr->lte_band_pref)
            #endif

            &&
            ! cmph_is_valid_tds_mode_band_pref( cmd_info_ptr->mode_pref,
                                                cmd_info_ptr->tds_band_pref)
          )
        {
          cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
          CM_MSG_HIGH_2 ("Invalid mode band pref, mode_pref=%d, band_pref=%d",
                           cmd_info_ptr->mode_pref, cmd_info_ptr->band_pref );
          break;
        }
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Only able to service this request if this is valid mode and network
      ** selection preference setting for this target/PRL.
      ** - GW Manual network selection is only valid w/ GSM/WCDMA mode pref.
      **
      ** NOTE: Validate only if the network selection pref is changed in this
      ** command. If, network selection mode pref is no change then send
      ** NO_CHANGE so that it is not validated.
      */
      if (!cmph_is_valid_network_selection_mode_pref( cmd_info_ptr->mode_pref,
           ((CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == cmd_info_ptr->network_sel_mode_pref)?
            CM_NETWORK_SEL_MODE_PREF_NO_CHANGE:cmd_info_ptr->network_sel_mode_pref)))
      {
        cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
        CM_MSG_HIGH_0 ("Cannot set mode pref when network selection is manual");
        break;
      }
      cmd_err = cmph_cmd_sys_sel_pref_irat_check(ph_cmd_ptr);
     }
     else if ((cmd_info_ptr->mode_pref == CM_MODE_PREF_NONE) &&
                (ph_ptr->is_mode_pref_none == FALSE) && 
		  !(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs) &&
                    cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ATTACH ))

     {
       cmd_err = CM_PH_CMD_ERR_SYS_SEL_PREF_S;
       CM_MSG_HIGH_2 ("Invalid mode band pref, mode_pref=%d, band_pref=%d",
                        cmd_info_ptr->mode_pref, cmd_info_ptr->band_pref );
       break;
     }

     if(cmd_err == CM_PH_CMD_ERR_NOERR && cmph_is_msim())
      {
       cmd_err = cmpmprx_check_sys_sel_pref_policy_conflict(ph_cmd_ptr);
       if(cmd_err != CM_PH_CMD_ERR_NOERR)
       {
         CM_MSG_HIGH_0( "Policy change not allowed ");
       }
      }
      /* If VoLTE call is ongoing the same SUB and the resultant Mode Pref doesn't have LTE, reject Sys Sel Pref*/
      if((cmd_err == CM_PH_CMD_ERR_NOERR) && 
        (cmcall_is_there_volte_call(CM_CALL_TYPE_VOICE)!= CM_CALL_ID_INVALID) &&
        (cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_PS_DETACH) &&
        (sd_misc_get_common_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->mode_pref),
                                  SD_SS_MODE_PREF_LTE) == SD_SS_MODE_PREF_NONE))
      {
       cmd_err = CM_PH_CMD_ERR_IN_USE_S;
       CM_MSG_HIGH_3("Invalid mode band pref, mode_pref=%d, srv_domain_pref=%d, asubs_id=%d",
                        cmd_info_ptr->mode_pref, cmd_info_ptr->srv_domain_pref,asubs_id);        
      }
    }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_DDTM_CNTL
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                  /*-----------------------------------------*/
                  /* Change the DDTM preference            */
                  /*-----------------------------------------*/

    case CM_PH_CMD_DDTM_PREF:


      /* Check errors.
      */
      cmd_err = cmph_client_cmd_ddtm_pref_para_check( ph_cmd_ptr, ph_ptr );
      if( cmd_info_ptr->ddtm_so_list_act == CM_DDTM_SO_LIST_ACT_NO_CHANGE)
      {

        cmd_info_ptr->ddtm_so_list_act = ph_ptr->ddtm_so_list_act;
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_DDTM_SO_LST_ACT);
      }

      break;
    #endif /* FEATURE_DDTM_CNTL */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                    /*---------------------------------*/
                    /* Change the answer voice setting */
                    /*---------------------------------*/

    case CM_PH_CMD_ANSWER_VOICE:

      /* check command parameter errors */
      cmd_err = cmph_cmd_answer_voice_para_check(ph_cmd_ptr);

      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                        /*--------------------------*/
                        /* Change the NAM selection */
                        /*--------------------------*/

    case CM_PH_CMD_NAM_SEL:

      /* Check command parameter errors - stop any further processing if
      ** any errors found.
      */
      cmd_err = cmph_cmd_nam_sel_para_check( ph_cmd_ptr );
      if( cmd_err != CM_PH_CMD_ERR_NOERR )
      {
        break;
      }

      if( cmcall_count_on_ss(CM_SS_MAIN) > 0 ||
          cmcall_count_on_ss(CM_SS_HDR) > 0 )
      {
        /* Fail the command if phone is in-use,
        */
        cmd_err = CM_PH_CMD_ERR_IN_USE_S;
        break;
      }

      /* Only able to service this request if phone is not powering-off,
      ** resetting or in LPM.
      */
      if( !cmph_in_valid_oprt_mode( ph_ptr ) )
      {
        cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                      /*------------------------------*/
                      /* A CM Client activated itself */
                      /*------------------------------*/

    case CM_PH_CMD_CLIENT_ACT:

       /* check client ID */
      if( ph_cmd_ptr->client_ptr == CM_CLIENT_PTR_NONE )
      {
        cmd_err  = CM_PH_CMD_ERR_CLIENT_ID_P;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*------------------------------------*/
                   /* Get a snapshot of phone information */
                   /*------------------------------------*/

    case CM_PH_CMD_INFO_GET:
      /* check client ID */
      if( ph_cmd_ptr->client_ptr == CM_CLIENT_PTR_NONE )
      {
        cmd_err  = CM_PH_CMD_ERR_CLIENT_ID_P;
      }
      else if ((ph_cmd_ptr->client_ptr)->init_mask != CM_INIT_MASK)
      {
        cmd_err  = CM_PH_CMD_ERR_CLIENT_ID_P;
      }

      break;
    #ifdef FEATURE_MRU_UPDATE
    case CM_PH_CMD_MRU_UPDATE:
      /* check client ID */
      if( ph_cmd_ptr->client_ptr == CM_CLIENT_PTR_NONE )
      {
        cmd_err  = CM_PH_CMD_ERR_CLIENT_ID_P;
      }
      else if ((ph_cmd_ptr->client_ptr)->init_mask != CM_INIT_MASK)
      {
        cmd_err  = CM_PH_CMD_ERR_CLIENT_ID_P;
      }

      break;
  case CM_PH_CMD_READ_MRU:
      /* check client ID */
      if( ph_cmd_ptr->client_ptr == CM_CLIENT_PTR_NONE )
      {
        cmd_err  = CM_PH_CMD_ERR_CLIENT_ID_P;
      }
      else if ((ph_cmd_ptr->client_ptr)->init_mask != CM_INIT_MASK)
      {
        cmd_err  = CM_PH_CMD_ERR_CLIENT_ID_P;
      }

      break;
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
              /*--------------------------------------------*/
              /* Get a snapshot of subscription information */
              /*--------------------------------------------*/

    case CM_PH_CMD_SUBSCRIPTION_INFO_GET:
      /* check client ID */
      if( ph_cmd_ptr->client_ptr == CM_CLIENT_PTR_NONE )
      {
        cmd_err  = CM_PH_CMD_ERR_CLIENT_ID_P;
      }
      else if ((ph_cmd_ptr->client_ptr)->init_mask != CM_INIT_MASK)
      {
        cmd_err  = CM_PH_CMD_ERR_CLIENT_ID_P;
      }

      /* If either of the stacks are not operational, then we dont have
      ** any valid subscription Information
      */
      CM_MSG_HIGH_4("subs_info: main_oper %d hybr_gw_oper %d gw3_oper %d, cmd_subs %d",
                    cmss_ptr()->info.is_main_operational,
                    cmss_ptr()->info.is_hybr_gw_operational,
                    cmss_ptr()->info.is_gw3_operational,
                    ph_cmd_ptr->info.cmd_subs);
      
       #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      CM_MSG_HIGH_3("m_as_id %d, h2_as_id %d, h3_as_id %d",\
        ph_ptr->main_stack_info.asubs_id,\
        ph_ptr->hybr_2_stack_info.asubs_id,\
        ph_ptr->hybr_3_stack_info.asubs_id); 
        #endif
      if(!(cmss_ptr()->info.is_main_operational ||
         cmss_ptr()->info.is_hybr_gw_operational ||
         cmss_ptr()->info.is_gw3_operational ))
      {
        CM_MSG_HIGH_0("CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P");
        cmd_err = CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P;
      }

      /* If the requested subscription id is not operational, then retur an error
      */
      if( ( ph_cmd_ptr->info.cmd_subs == ph_ptr->main_stack_info.asubs_id &&
            !cmss_ptr()->info.is_main_operational
          ) ||
          ( ph_cmd_ptr->info.cmd_subs == ph_ptr->hybr_2_stack_info.asubs_id &&
            !cmss_ptr()->info.is_hybr_gw_operational && !cmph_is_sxlte_any()
          ) 
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
          ||
          ( ph_cmd_ptr->info.cmd_subs == ph_ptr->hybr_3_stack_info.asubs_id &&
            !cmss_ptr()->info.is_gw3_operational && (cmph_is_sxlte() || cmph_is_tsts())
          )
          #endif
        )
      {
        cmd_err = CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P;
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*----------------------------------*/
                   /* Set RSSI change delta threshold  */
                   /* send start full service (WCDMA)  */
                   /*----------------------------------*/

    case CM_PH_CMD_RSSI_DELTA:
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*-------------------------------------------*/
                   /* Set RSSI,ECIO,IO  change delta threshold  */
                   /* send start full service (WCDMA)           */
                   /*-------------------------------------------*/

    case CM_PH_CMD_SIGNAL_STRENGTH_DELTA:
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
    case CM_PH_CMD_PACKET_STATE:

      /* check command parameter errors */

      if((cmd_err = cmph_cmd_packet_state_para_check(ph_cmd_ptr)) != CM_PH_CMD_ERR_NOERR)
      {
        /* stop further processing if any errors found in the command */
        break;
      }

      /* Only able to service this request if phone is not powering-off,
      ** resetting or in LPM.
      */
      if( !cmph_in_valid_oprt_mode( ph_ptr ) )
      {
        cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
      }

      break;
    #endif /*  (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */


    #ifdef FEATURE_JCDMA
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*----------------------------------*/
                   /* Enable/Disable voice activity    */
                   /*----------------------------------*/

    case CM_PH_CMD_VOC_ACTIVITY:

      break;

    #endif /* FEATURE_JCDMA */

     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*------------------------*/
                   /* Subscription available */
                   /*------------------------*/
    case CM_PH_CMD_SUBSCRIPTION_AVAILABLE:

       client_type = cmclient_get_client_type( ph_cmd_ptr->client_id );

      /* In case of GW and CDMA, subscription command only of CM
      ** (self command ) and AT COPS is honoured
      */
      if( client_type == CM_CLIENT_TYPE_NONE ||
          client_type == CM_CLIENT_TYPE_ATCOP)
      {
        cmd_err = cmph_cmd_subscription_available_cmd_para_check( ph_ptr,
                                                                  cmd_info_ptr
                                                                );
      }
      else
      {
        cmd_err = CM_PH_CMD_ERR_API_NOT_SUPPORTED_S;
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*------------------------*/
                   /* Perso info available */
                   /*------------------------*/
    case CM_PH_CMD_PERSO_INFO_AVAILABLE:

       client_type = cmclient_get_client_type( ph_cmd_ptr->client_id );

      /* Only of CM (self command ) is honoured
      */
      if( client_type == CM_CLIENT_TYPE_NONE )
      {
        cmd_err = cmph_cmd_perso_info_available_cmd_para_check( ph_ptr,
                                                                  cmd_info_ptr
                                                                );
      }
      else
      {
        cmd_err = CM_PH_CMD_ERR_API_NOT_SUPPORTED_S;
      }
      break;
                   /*----------------------------*/
                   /* Subscription not available */
                   /*----------------------------*/
    case CM_PH_CMD_SUBSCRIPTION_NOT_AVAILABLE:

      client_type = cmclient_get_client_type(ph_cmd_ptr->client_id);

      /* In case of GW and CDMA, subscription command only of CM
      ** (self command ) and AT COPS is honoured
      */

      if( client_type == CM_CLIENT_TYPE_NONE ||
          client_type == CM_CLIENT_TYPE_ATCOP )
      {

        cmd_err = cmph_cmd_subscription_not_available_cmd_para_check(
                                                                 ph_ptr,
                                                                    cmd_info_ptr
                                                                  );
      }
      else
      {
        cmd_err = CM_PH_CMD_ERR_API_NOT_SUPPORTED_S;
      }
      break;

                   /*----------------------------*/
                   /* Subscription changed       */
                   /*----------------------------*/
    case CM_PH_CMD_SUBSCRIPTION_CHANGED:
      cmd_err = cmph_cmd_subscription_changed_cmd_para_check( ph_ptr,
                                                              cmd_info_ptr
                                                            );
      break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*-----------------------------------------*/
                   /* Client has requested a list of networks */
                   /*-----------------------------------------*/

    case CM_PH_CMD_GET_NETWORKS:

      /*- - - - - - - - - P R E - C O N D I T I O N S - - - - - - - - - - -*/

      /* Only able to service this request if phone is not powering-off,
      ** resetting or in LPM.
      */
      CM_MSG_HIGH_1( "CM_PH_CMD_GET_NETWORKS sys_mode %d", cmss_ptr()->info.sys_mode);
      if ( !cmph_in_valid_oprt_mode( ph_ptr ) )
      {
        cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
      }

      #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
      else if ( cmss_ptr()->info.sys_mode == SYS_SYS_MODE_LTE &&
                cmph_is_mm_busy( cmd_info_ptr->cmd_subs ) )
        {
        CM_MSG_HIGH_0( "MT/MO page in progress" );
          cmd_err = CM_PH_CMD_ERR_IN_USE_S;
        }
      else if(cmregprx_get_stack_info_ptr(sd_ss)->substate \
                             == CMREGPRX_SUBSTATE_WAIT_PS_DETACH_CNF)
        {
        CM_MSG_HIGH_0( "PS_DETACH in progress" );
          cmd_err = CM_PH_CMD_ERR_IN_USE_S;
        }
      #endif
      else
      {
        /*- - - - - C H E C K - P A R A M E T E R S - - - - - - - - - - - - -*/
        cmd_err = cmph_cmd_get_networks_para_check( ph_ptr, ph_cmd_ptr );
      }
      break;

    case CM_PH_CMD_TERMINATE_GET_NETWORKS:
      cmd_err = cmph_cmd_terminate_get_networks_para_check( ph_cmd_ptr );
      break;

                   /*-----------------------------------------------------*/
                   /* Client has requested to save the preferred networks */
                   /*-----------------------------------------------------*/
    #ifdef CM_GW_SUPPORTED
    case CM_PH_CMD_SET_PREFERRED_NETWORKS:
    {
      if(cmph_is_valid_asubs_id_from_client(asubs_id) &&
         cmph_is_msim())
      {
        cmd_err = CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P;
      }

      /*
      ** Write the user preferred PLMN list to the (U)SIM.
      */

      if (!cmmmgsdi_write_preferred_plmn_list(asubs_id,&cmd_info_ptr->user_pref_networks))
      {
        cmd_err = CM_PH_CMD_ERR_USER_PREFERRED_NETWORK_LIST_ACCESS;
      }
    }
    break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_RESET_ACM:
    case CM_PH_CMD_SET_ACMMAX:

      /* If advice of charge is not ready, reject SET and RESET commands.
      */
      if( ss == CM_SS_HYBR_2 &&
          !ph_ptr->hybr_2_stack_info.phone_charge.aoc_ready &&
          cmph_is_msim())
      {
        cmd_err = CM_PH_CMD_ERR_AOC_NOT_READY_S;
      }
      else
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if( ss == CM_SS_HYBR_3 &&
           !ph_ptr->hybr_3_stack_info.phone_charge.aoc_ready &&
           cmph_is_msim())
      {
        cmd_err = CM_PH_CMD_ERR_AOC_NOT_READY_S;
      }
      else
      #endif

      if ( asubs_id == SYS_MODEM_AS_ID_1 && !ph_ptr->main_stack_info.phone_charge.aoc_ready)/*lint !e774 */
      {
        cmd_err = CM_PH_CMD_ERR_AOC_NOT_READY_S;
      }
      break;
    #endif /* FEATURE_WCDMA, FEATURE_GSM */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #if (defined FEATURE_ALS) && (defined FEATURE_GSM)
    case CM_PH_CMD_ALS_SIM_INFO_AVAIL:
    case CM_PH_CMD_LINE_SWITCHING_SAVED:
    case CM_PH_CMD_SELECTED_LINE_SAVED:

      /* Nothing to do here for these commands.
      */
      break;

    case CM_PH_CMD_LINE_SWITCHING:
      if(!cmph_als_supported())
      {
        cmd_err = CM_PH_CMD_ERR_ALS_NOT_SUPPORTED_S;
      }
      break;

    case CM_PH_CMD_SELECTED_LINE:
      if(!cmph_als_supported())
      {
        cmd_err = CM_PH_CMD_ERR_ALS_NOT_SUPPORTED_S;
        break;
      }

      if(ph_ptr->line_switching != CM_ALS_LINE_SWITCHING_ALLOWED)
      {
        cmd_err = CM_PH_CMD_ERR_LINE_SWITCHING_S;
      }
      break;

    #endif /* #if (defined FEATURE_ALS) && (defined FEATURE_GSM) */

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
    #error code not present
#endif

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_CLIENT_RELEASE:

      /* Nothing to check. */

      break;

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_DUAL_STANDBY_PREF:
    {
      boolean asubs_id_valid[SYS_MODEM_AS_ID_NO_CHANGE] = {1, 0, 0};
      sys_modem_as_id_e_type asubs_id = SYS_MODEM_AS_ID_NONE;
      cm_orig_q_s_type  *sms_orig_ptr = cmtask_orig_para_search_act_type( CM_SS_MAIN, CM_ACT_TYPE_SMS_CALL);
      
      if(cmph_is_msim())
      {
        asubs_id_valid[SYS_MODEM_AS_ID_2] = 1;
        asubs_id_valid[SYS_MODEM_AS_ID_3] = 1;
        asubs_id = cmph_get_sub_with_lte_cap();

        if ((cmd_info_ptr->default_data_subs >= SYS_MODEM_AS_ID_1 && cmd_info_ptr->default_data_subs <= SYS_MODEM_AS_ID_3) &&
            (asubs_id != cmd_info_ptr->default_data_subs))
        {
          asubs_id_valid[cmd_info_ptr->default_data_subs] = 0;
        }

        CM_MSG_HIGH_5("cmd_info_ptr->default_data_subs %d, subs id with lte %d asubs_id_valid %d %d %d",
			cmd_info_ptr->default_data_subs,
            asubs_id, 
            asubs_id_valid[0],asubs_id_valid[1],asubs_id_valid[2]);
       
      }
      
   /*- - - - - - - - - P R E - C O N D I T I O N S - - - - - - - - - - -*/



      if(cmph_is_msim()
	   && cmd_info_ptr->default_data_subs == SYS_MODEM_AS_ID_1
	   && cmd_info_ptr->dds_switch_type == DDS_CAUSE_PERMANENT
       && POLICYMAN_SUCCEEDED(policyman_get_boolean_value("cm:1xdata_allowed", &cm_pm_dds_switch_allowed))
       && !cm_pm_dds_switch_allowed)
      {
        CM_MSG_HIGH_0("rejecting dds switch as per cmcc subsidized requirement");
        cmd_err = CM_PH_CMD_ERR_DDS_REJECT_NETWORK_NOT_ALLOWED;
        break;
      }

      /* Check if all the Preferences are in range */
      if(cmph_is_msim() && 
        ((!BETWEEN(cmd_info_ptr->standby_pref,SYS_MODEM_DS_PREF_NONE,SYS_MODEM_DS_PREF_MAX))
             || ( cmpmprx_get_device_mode() != SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY &&
                  (cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY || \
              cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY )))
        )
      {
        cmd_err = CM_PH_CMD_ERR_STANDBY_PREF_P;
        break;
      }
      else if(cmph_is_ssim()
        && (!(cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_NO_STANDBY_PREF ||
              cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY ||
              cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_NO_CHANGE) ||
            !(cmd_info_ptr->default_data_subs == SYS_MODEM_AS_ID_1 ||
              cmd_info_ptr->default_data_subs == SYS_MODEM_AS_ID_NO_CHANGE) ||
            !(cmd_info_ptr->default_voice_subs == SYS_MODEM_AS_ID_1 ||
              cmd_info_ptr->default_voice_subs == SYS_MODEM_AS_ID_NO_CHANGE) ||
            !(cmd_info_ptr->priority_subs == SYS_MODEM_AS_ID_1 ||
              cmd_info_ptr->priority_subs == SYS_MODEM_AS_ID_NO_CHANGE)
          ))
      {
        cmd_err = CM_PH_CMD_ERR_STANDBY_PREF_P;
        break;
      }

     for(ss_loop = CM_SS_MAIN; ss_loop < CM_SS_MAX; ss_loop++)
	 {
       if(cmph_is_msim() && 
		  cmtask_orig_para_search_act_type_act_priority( ss_loop, CM_ACT_TYPE_SMS_CALL, CM_ACT_PRIORITY_70)!= NULL)
       {
         cmd_err = CM_PH_CMD_ERR_IN_USE_S;
		 is_sms_active = TRUE;
         break;
       }
	}
 
	 if(is_sms_active)
	 {
       CM_MSG_HIGH_0("Rejecting standby pref as SMS call is active");
       break;
	 }

      /* Reject CMD if parameters changed for AS_ID_3 in S.SIM or D.SIM targets - Negative testing (QMI test pro) */
      if( cmpmprx_get_device_mode() != SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY &&
          ((cmd_info_ptr->active_subs & SYS_MODEM_AS_ID_3_MASK) &&
            cmd_info_ptr->active_subs != SYS_MODEM_AS_ID_NO_CHANGE_MASK)
        )
      {
         cmd_err = CM_PH_CMD_ERR_STANDBY_PREF_P;
         break;
      }

       /* If stand pref command is received  while voice call is active
              Reject the command with error
         */
      if((ph_cmd_ptr->client_id != CM_CLIENT_ID_ANONYMOUS) &&
         ((cmcall_find_active_voice_call()!= CM_CALL_ID_INVALID) ||
           (cmcall_find_active_cs_data_call() != CM_CALL_ID_INVALID))
        )
      {
        CM_MSG_HIGH_0("Rejecting standby pref, it is already buffered as CS call or cs_data call is active");
        cmd_err = CM_PH_CMD_ERR_IN_USE_S;
        break;
      }

      /* In SRLTE/SVLTE+G, DDS switch to sub2 should be rejected,
      ** when 1X SMS is on-going
      */
      if((ph_cmd_ptr->client_id != CM_CLIENT_ID_ANONYMOUS) &&
          cmph_is_msim() &&
          cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)&&
         (sms_orig_ptr != NULL) &&
         (sms_orig_ptr->orig->act_priority != CM_ACT_PRIORITY_END) &&
         (ph_cmd_ptr->info.default_data_subs == SYS_MODEM_AS_ID_2)
        )
      {
        CM_MSG_HIGH_0("Rejecting DDS change, due to SMS call");
        cmd_err = CM_PH_CMD_ERR_IN_USE_S;
        break;
      }


      if(
          #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
          (asubs_id_valid[SYS_MODEM_AS_ID_1] && cmph_is_mm_busy(SYS_MODEM_AS_ID_1))
          #ifdef FEATURE_MMODE_DUAL_SIM
          || (asubs_id_valid[SYS_MODEM_AS_ID_2] && cmph_is_mm_busy(SYS_MODEM_AS_ID_2))
          #endif
          #ifdef FEATURE_MMODE_TRIPLE_SIM
          || (asubs_id_valid[SYS_MODEM_AS_ID_3] && cmph_is_tsts() && cmph_is_mm_busy(SYS_MODEM_AS_ID_3))
          #endif
          ||
          #endif
          cmclnup_is_ongoing_subsc(SYS_MODEM_AS_ID_ALL_ACTIVE_MASK)
          )
      {
          cmd_err  = CM_PH_CMD_ERR_IN_USE_S;
          CM_MSG_HIGH_0( "CM_PH_CMD_ERR_IN_USE_S mm is busy");
          break;
      }


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* Validate the Dual Standby Prefereces
      */
      if ( cmd_info_ptr->standby_pref != ph_ptr->user_standby_pref &&
           cmd_info_ptr->standby_pref != SYS_MODEM_DS_PREF_NO_CHANGE )
      {
          /* Check if the current active subscription has active calls
          ** before changing.
          */
         if( (cmcall_is_there_a_call_type (CM_SS_MAIN,
                                           CM_CALL_TYPE_VOICE,
                                           CM_CALL_ID_INVALID) != CM_CALL_ID_INVALID
              && cmd_info_ptr->active_subs & SYS_MODEM_AS_ID_1_MASK)
                ||
               (cmcall_is_there_a_call_type (CM_SS_HYBR_2,
                                           CM_CALL_TYPE_VOICE,
                                         CM_CALL_ID_INVALID) != CM_CALL_ID_INVALID
               &&cmd_info_ptr->active_subs & SYS_MODEM_AS_ID_2_MASK)

                ||
                (cmcall_is_there_a_call_type (CM_SS_HYBR_3,
                                           CM_CALL_TYPE_VOICE,
                                         CM_CALL_ID_INVALID) != CM_CALL_ID_INVALID
              && cmd_info_ptr->active_subs & SYS_MODEM_AS_ID_3_MASK)

            )
        {
          CM_ERR_0("Active voice call on either subs. Can't change prefs");
          cmd_err = CM_PH_CMD_ERR_IN_USE_S;
          break;
        }

      }
      /* Continue in Single Standby but update the active subscription
      ** Check if any active calls in current active subscription
      */
      else if ( ph_ptr->standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY &&
                (cmd_info_ptr->standby_pref == ph_ptr->standby_pref ||
                 cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_NO_CHANGE
                ) &&
                ( cmd_info_ptr->active_subs != ph_ptr->active_subs &&
                  cmd_info_ptr->active_subs != SYS_MODEM_AS_ID_NO_CHANGE_MASK
                )
              )
      {
        if( cmcall_overall_call_state_per_subs(cmph_map_subs_to_ss(
                                     ACTIVE_MASK_TO_AS_ID(ph_ptr->active_subs)))
                                                  != CM_OVERALL_CALL_STATE_IDLE
          )
        {
          CM_ERR_1("Active calls on %d",
                        ACTIVE_MASK_TO_AS_ID(ph_ptr->active_subs));
          cmd_err = CM_PH_CMD_ERR_IN_USE_S;
          break;
        }
      }

      /* If the dedicated data, dedicated voice, priority subscription id have changed
      ** check if they match one of the available subscriptions
      */
      if( !cmph_is_valid_subscription_id(cmd_info_ptr->default_data_subs) ||
          !cmph_is_valid_subscription_id(cmd_info_ptr->default_voice_subs) ||
          !cmph_is_valid_subscription_id(cmd_info_ptr->priority_subs)
        )
      {
        CM_MSG_HIGH_3("Invalid data %d / voice %d / priority %d subscription-id",
                cmd_info_ptr->default_data_subs,
                cmd_info_ptr->default_voice_subs,
                cmd_info_ptr->priority_subs);
         
        cmd_err = CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P;
        break;
        
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* If the Dual Standby Preferences are No Change, then
      ** set them to the current values
      */
      if(cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_NO_CHANGE)
      {
        cmd_info_ptr->standby_pref = ph_ptr->user_standby_pref;
      }

      if(cmd_info_ptr->active_subs == SYS_MODEM_AS_ID_NO_CHANGE_MASK)
      {
        cmd_info_ptr->active_subs = ph_ptr->active_subs;
      }

      if(cmd_info_ptr->default_data_subs == SYS_MODEM_AS_ID_NO_CHANGE)
      {
        cmd_info_ptr->default_data_subs = ph_ptr->default_data_subs;
      }

      if(cmd_info_ptr->default_voice_subs == SYS_MODEM_AS_ID_NO_CHANGE)
      {
        cmd_info_ptr->default_voice_subs = ph_ptr->default_voice_subs;
      }

      if(cmd_info_ptr->priority_subs == SYS_MODEM_AS_ID_NO_CHANGE)
      {
        cmd_info_ptr->priority_subs = ph_ptr->priority_subs;
      }

      if(cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_NO_STANDBY_PREF)
      {
        cmd_info_ptr->active_subs = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;
      }

    }
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #ifdef FEATURE_CM_LTE
    case CM_PH_CMD_PLMN_BLOCKING:

     /* Reject PLMN blocking command if not in ONLINE mode */
     if ( !cmph_in_valid_oprt_mode( ph_ptr ) ||
          cmclnup_is_ongoing_subsc(BM(cmd_info_ptr->cmd_subs))
        )
     {
       cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
       CM_MSG_HIGH_2( "CLNUP in prog. CMD %d not allowed. cmd_err = %d",
                       ph_cmd_ptr->cmd,
                       cmd_err );
     }

     /* There is ongoing emergency call or ph is in EMERG_CB */
    if(((cmcall_is_there_a_call_type(CM_SS_MAX,CM_CALL_TYPE_EMERGENCY,
                                      CM_CALL_ID_INVALID) != CM_CALL_ID_INVALID) ||
          (cmph_is_in_emergency_cb() == TRUE) )
           &&
          ((cmd_info_ptr->request_pref == CM_PLMN_BLOCKING_PREF_LTE_DETACH_ONLY) ||
           (cmd_info_ptr->request_pref == CM_PLMN_BLOCKING_PREF_LTE_DETACH_PLMN_BLOCKING )))
     {

        CM_MSG_HIGH_0("Reject the Detach/PLMN blocking cmd as EMERG call is active or PH in EMERG CB mode");
        sds_ptr->is_plmn_blocking_in_progress = FALSE;
        cmd_err = CM_PH_CMD_ERR_IN_USE_S;
      }
      break;
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)
    case CM_PH_CMD_GET_DRX_REQ:
      break;

    case CM_PH_CMD_SET_DRX_REQ:
      break;
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #if defined(FEATURE_TDSCDMA)
    case CM_PH_CMD_SET_TL_IRAT_SEARCH_TIMER_REQ:
      break;

    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case CM_PH_CMD_GET_HPLMN_TIMER:
    case CM_PH_CMD_SET_HPLMN_TIMER:
    case CM_PH_CMD_RPM_APP_RESET_REJECTED:
    case CM_PH_CMD_SET_WD_SWITCH:
    case CM_PH_CMD_RESET_CLNUP_ST_MC:
      break;

    case CM_PH_CMD_DATA_PRIORITY:

    CM_MSG_HIGH_4( "CM_PS_PS_DEBUG: cmd_info_ptr->priority_type %d, cmd_subs %d, priority %d, active_data %d",
      cmd_info_ptr->priority_type, cmd_info_ptr->cmd_subs, cmd_info_ptr->priority_type, cmpmprx_get_num_of_active_data());

    if((cmd_info_ptr->priority_type == SYS_DATA_PRIORITY_HIGH) && cm_is_data_high_priority_sub())
    {
      cmd_err = CM_PH_CMD_ERR_INVALID_DATA_PRIORITY;
      break;
    }

    if(cmpmprx_get_num_of_active_data()!= 2)
    {
      cmd_err = CM_PH_CMD_ERR_FUNCTION_NOT_APPLICABLE;
      break;
    }

    /* Check if priority type and subid is correct
    */
    if ((!BETWEEN (cmd_info_ptr->cmd_subs,
            SYS_MODEM_AS_ID_NONE,
            SYS_MODEM_AS_ID_MAX)))
    {
        cmd_err = CM_PH_CMD_ERR_INVALID_SUBS_ID;
        break;
    }

    if ((!BETWEEN (cmd_info_ptr->priority_type,
            SYS_DATA_PRIORITY_NULL,
            SYS_DATA_PRIORITY_MAX)))
    {
        cmd_err = CM_PH_CMD_ERR_INVALID_DATA_PRIORITY;
    }

     break;

   case CM_PH_CMD_SET_TRM_PRIORITY:
     break;
	 
    case CM_PH_CMD_INFORM_SECURE_CALL_CAPABILITY:
      break;

	case CM_PH_CMD_SET_SRVCC_CAPABILITY:
      
      /* SRVCC update is only allowed in LPM or if the subscription is not active */
      if(ph_ptr->oprt_mode != SYS_OPRT_MODE_LPM &&
         BM(cmd_info_ptr->cmd_subs) & ph_ptr->active_subs)
	  { 
            cmd_err = CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S;
            CM_MSG_HIGH_2("SRVCC update not allowed for active asubs_id=%d. ph_ptr->active_subs=%d",
            cmd_info_ptr->cmd_subs, ph_ptr->active_subs);
	  }
	break;

  #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  
  case CM_PH_CMD_DATA_ROAMING:
    if ((!BETWEEN (cmd_info_ptr->cmd_subs,
            SYS_MODEM_AS_ID_NONE,
            SYS_MODEM_AS_ID_MAX)))
    {
        cmd_err = CM_PH_CMD_ERR_INVALID_SUBS_ID;
        break;
    }

    if ((!BETWEEN (cmd_info_ptr->roam_type,
            SYS_DATA_ROAMING_NULL,
            SYS_DATA_ROAMING_MAX)))
    {
        cmd_err = CM_PH_CMD_ERR_INVALID_DATA_ROAMING;
        break;
    }

    if((((cm_number_of_allocated_calls() ==
       cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_PS_DATA)) ||

      ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VOICE)  > 0) &&
      ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VOICE) ==
        cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_VOICE,CM_CALL_INCOM_SUBST_SETUP_PROCESSED))|| (cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VOICE) ==
        cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_VOICE,CM_CALL_INCOM_SUBST_SETUP))))||

    ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_CS_DATA)  > 0) &&
      ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_CS_DATA) ==
        cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_CS_DATA,CM_CALL_INCOM_SUBST_SETUP_PROCESSED))|| (cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_CS_DATA) ==
        cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_CS_DATA,CM_CALL_INCOM_SUBST_SETUP)))) ||

    ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VT)  > 0) &&
      ((cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VT) ==
        cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_VT,CM_CALL_INCOM_SUBST_SETUP_PROCESSED))|| (cm_number_of_allocated_calls_with_type(CM_CALL_TYPE_VT) ==
        cm_number_of_allocated_calls_with_type_substate(CM_CALL_TYPE_VT,CM_CALL_INCOM_SUBST_SETUP))))
    )&&(cmph_is_mm_busy(cmd_info_ptr->cmd_subs) == TRUE)) || 
    
    cmcall_is_there_a_call_type_per_sub(cmd_info_ptr->cmd_subs,CM_CALL_TYPE_VOICE,NULL) != CM_CALL_ID_INVALID ||
    cmcall_is_there_a_call_type_per_sub(cmd_info_ptr->cmd_subs,CM_CALL_TYPE_CS_DATA,NULL) != CM_CALL_ID_INVALID || 
    cmcall_is_there_a_call_type_per_sub(cmd_info_ptr->cmd_subs,CM_CALL_TYPE_VT,NULL) != CM_CALL_ID_INVALID)
    {
      cmd_err = CM_PH_CMD_ERR_IN_USE_S;
    }

    break;

  case CM_PH_CMD_SET_ROAMING_PREF:
    if ((!BETWEEN (cmd_info_ptr->cmd_subs,
                   SYS_MODEM_AS_ID_NONE,
                   SYS_MODEM_AS_ID_MAX)))
    {
      cmd_err = CM_PH_CMD_ERR_INVALID_SUBS_ID;
      break;
    }

    /* Reject CM_PH_CMD_SET_ROAMING_PREF if Cellular call is ongoing. Command
       will be a allowed in case WLAN call is ongoing */
    if(cmcall_is_there_cellular_call_per_sub(cmd_info_ptr->cmd_subs, 
                                             CM_CALL_TYPE_VOICE_MASK |
                                             CM_CALL_TYPE_EMERG_MASK |
                                             CM_CALL_TYPE_VT_MASK |
                                             CM_CALL_TYPE_VS_MASK) != CM_CALL_ID_INVALID) 
    {
      cmd_err = CM_PH_CMD_ERR_IN_USE_S;
      break;
    }

    break;

  #endif
  case CM_PH_CMD_CHANGE_SRV_OPT:
  #ifdef FEATURE_DDTM_CNTL

   /* Validate the command to unblock SO. 
   ** ddtm_num_blocked_srv_opt should be greater than 0 to unblock 
   ** the list of blocked SOs in ddtm_blocked_srv_opt_list.
   ** Ignore the command when it is 0 or INVALID 
   */
    if((cmd_info_ptr->ddtm_num_blocked_srv_opt == 0) && 
       (ph_ptr->ddtm_num_blocked_srv_opt == CM_INVALID_DDTM_NUM_SRV_OPT ||
       ph_ptr->ddtm_num_blocked_srv_opt == 0))
    {
      CM_MSG_HIGH_0("Duplicate command to unblock SOs");
      cmd_err = CM_PH_CMD_ERR_DDTM_PREF_P;
      return cmd_err;
    }
    /* Check if same list of SOs are already being blocked then ignore the command
    */
    if(cmd_info_ptr->ddtm_num_blocked_srv_opt > 0 && 
      (cmd_info_ptr->ddtm_num_blocked_srv_opt == ph_ptr->ddtm_num_blocked_srv_opt))
    {
      uint16 no_of_SO, i,j = 0;
      boolean is_duplicate;

      no_of_SO = cmd_info_ptr->ddtm_num_blocked_srv_opt;
      for(j = 0; j < no_of_SO; j++)
      {
        is_duplicate = FALSE;
        for(i = 0; i < no_of_SO; i++)
        {
          /* Avoid appending SO which is already being blocked. Find duplicate */
          if(cmd_info_ptr->ddtm_blocked_srv_opt_list[i]  == ph_ptr->ddtm_blocked_srv_opt_list[j])
          {
            is_duplicate = TRUE;
          }
        }
        if (is_duplicate == FALSE)
        {
          /* SOs list passed is different continue with processing the command */
          return cmd_err;// CM_PH_CMD_ERR_NOERR
        }
      }

      /* List of SOs are already blocked ignore the command */
      CM_MSG_HIGH_0("Duplicate command to block SOs");
      cmd_err = CM_PH_CMD_ERR_DDTM_PREF_P;
    }
    #endif
    break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:

      cmd_err = CM_PH_CMD_ERR_OTHER;
      CM_ERR_1( "Bad phone command %d", (uint8) ph_cmd_ptr->cmd);

  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return cmd_err;

} /* cmph_client_cmd_check() */
/*lint +esym(818,ph_ptr) */

/*===========================================================================

FUNCTION cmph_client_cmd_err

DESCRIPTION
  Notify clients of a specified phone command error.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_client_cmd_err(

    const cm_ph_cmd_s_type     *ph_cmd_ptr,
       /* Point at phone command component */

    cm_ph_cmd_err_e_type    cmd_err
        /* Indicate the phone command error */
)
{
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_cmd_ptr != NULL );
  CM_ASSERT( ph_cmd_ptr->cmd_type == CM_CMD_TYPE_PH );
  CM_ASSERT( BETWEEN( cmd_err, CM_PH_CMD_ERR_NONE, CM_PH_CMD_ERR_MAX) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_LOW_3("START cmph_client_cmd_err() ph_cmd=%d, cmd_err=%d, client=%p",
                 ph_cmd_ptr->cmd, cmd_err, ph_cmd_ptr->client_id );

  #if (defined FEATURE_ALS) && (defined FEATURE_GSM)
  /*
  ** We don't want to call the callback for CM_PH_CMD_LINE_SWITCHING and
  ** CM_PH_CMD_SELECTED_LINE when there is no error from command check
  ** function until we actually hear from GSDI or MMGSDI that the SIM write
  ** was successful (ALS custom will take care of that)
  */
  if(( ph_cmd_ptr->cmd == CM_PH_CMD_LINE_SWITCHING ||
       ph_cmd_ptr->cmd == CM_PH_CMD_SELECTED_LINE )&&
       cmd_err == CM_PH_CMD_ERR_NOERR)
  {
    return;
  }
  #endif /* #if (defined FEATURE_ALS) && (defined FEATURE_GSM) */
  
  /* MRU callback will be called after handling command*/
  if(( ph_cmd_ptr->cmd == CM_PH_CMD_READ_MRU   ||
       ph_cmd_ptr->cmd == CM_PH_CMD_MRU_UPDATE  )&&
       cmd_err == CM_PH_CMD_ERR_NOERR)
  {
    return;
  }

  /* If commanding client supplied a callback function,
  ** notify this client of command error status.
  */
  if( ph_cmd_ptr->cmd_cb_func != NULL )
  {
    ph_cmd_ptr->cmd_cb_func( ph_cmd_ptr->data_block_ptr,
                             ph_cmd_ptr->cmd,
                             cmd_err );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If command error is OTHER than NO ERROR,
  ** notify the client list of command error, as well.
  */
  if( cmd_err != CM_PH_CMD_ERR_NOERR )
  {
    CM_MSG_HIGH_3( "Phone cmd err!, cmd=%d, err=%d, client=%ld",
                 ph_cmd_ptr->cmd, cmd_err, ph_cmd_ptr->client_id );

    cmclient_list_ph_cmd_err_ntfy( cmd_err, ph_cmd_ptr );
  }
} /* cmph_client_cmd_err() */


#ifdef FEATURE_CM_SS_MEAS
#error code not present
#endif /* FEATURE_CM_SS_MEAS */


/*===========================================================================

FUNCTION cmph_read_nv_items

DESCRIPTION
  Read items from NV.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_read_nv_items(cmph_s_type *ph_ptr)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  #if !defined( FEATURE_UIM_RUIM ) || defined( FEATURE_UIM_RUN_TIME_ENABLE )
  #if defined( FEATURE_UIM_RUN_TIME_ENABLE )
  /* Determine if the R-UIM is available for this NAM */
  if (!nv_rtre_use_ruim_for_nam((byte) ph_ptr->curr_nam))
  #endif /* FEATURE_UIM_RUN_TIME_ENABLE */
   {
   /* Read from NV the SPC and remember whether the SPC is all zeros.
   */

   cmnv_read_wait( NV_SEC_CODE_I, cmnv_item_ptr );
   {
     byte zeros[NV_SEC_CODE_SIZE];

     if( memcmp((byte*) cmnv_item_ptr->sec_code.digits,
                memset( zeros, '0', NV_SEC_CODE_SIZE ),
                NV_SEC_CODE_SIZE ) == 0 )
     {
       ph_ptr->is_spc_zero = TRUE;
     }
     else
     {
       ph_ptr->is_spc_zero = FALSE;
     }
   }
  }

  cmnv_item_ptr->accolc.nam = (byte) ph_ptr->curr_nam;
  cmnv_read_wait(NV_ACCOLC_I, cmnv_item_ptr);
  ph_ptr->accolc = cmnv_item_ptr->accolc.ACCOLCpClass[NV_CDMA_MIN_INDEX];

  #endif /* !FEATURE_UIM_RUIM || FEATURE_UIM_RUN_TIME_ENABLE */

} /* cmph_read_nv_items() */

/*===========================================================================

FUNCTION cmph_orig_mode_reset_on_ss

DESCRIPTION
  Reset the origination mode to none.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

static  void            cmph_orig_mode_reset_on_ss(

        cmph_s_type     *ph_ptr,
          /* ph_ptr
          */

        cm_ss_e_type    ss,
          /* The ss on which to reset
          */

        boolean         force_top,
          /* Force the top preferences
          */

         uint16         req_id
          /* sys sel pref related request Id
          */

)
{

  boolean is_top_ptr_changed = FALSE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr != NULL);
  CM_ASSERT( ss != CM_SS_MAX );
  CM_MSG_HIGH_1( "cmph_orig_mode_reset_on_ss() ss %d",ss);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmtask_orig_para_reset( ss );

  if(ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
  {
    is_top_ptr_changed = cmph_insert_orig_mode (
                          ss,
                          SD_SS_ORIG_MODE_NONE,
                          CM_ACT_TYPE_PH_OBJ,
                          ph_ptr->hybr_2_stack_info.pref_info.pref_term,
                          ph_ptr->hybr_2_stack_info.pref_info.mode_pref,
                          ph_ptr->hybr_2_stack_info.pref_info.band_pref,
                          ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
                          ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref,
                          ph_ptr->hybr_2_stack_info.pref_info.prl_pref,
                          ph_ptr->hybr_2_stack_info.pref_info.roam_pref,
                          CM_HYBR_PREF_OFF,
                          SD_SS_HYBR_PREF_NONE,
                          ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref,
                          (cm_act_id_type)ph_ptr,
                          CM_ACT_UPDATE_REAS_ACT_START,
                          req_id,
                          ph_ptr->main_stack_info.pref_info.csg_id,
                          ph_ptr->main_stack_info.pref_info.csg_rat
                        );
  }
  else
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(ss == CM_SS_HYBR_3)
  {
    is_top_ptr_changed = cmph_insert_orig_mode (
                            ss,
                            SD_SS_ORIG_MODE_NONE,
                            CM_ACT_TYPE_PH_OBJ,
                            ph_ptr->hybr_3_stack_info.pref_info.pref_term,
                            ph_ptr->hybr_3_stack_info.pref_info.mode_pref,
                            ph_ptr->hybr_3_stack_info.pref_info.band_pref,
                            ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref,
                            ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref,
                            ph_ptr->hybr_3_stack_info.pref_info.prl_pref,
                            ph_ptr->hybr_3_stack_info.pref_info.roam_pref,
                            CM_HYBR_PREF_OFF,
                            SD_SS_HYBR_PREF_NONE,
                            ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref,
                            (cm_act_id_type)ph_ptr,
                            CM_ACT_UPDATE_REAS_ACT_START,
                            req_id,
                            ph_ptr->main_stack_info.pref_info.csg_id,
                            ph_ptr->main_stack_info.pref_info.csg_rat
                          );
  }
  else
  #endif /* FEATURE_MMODE_TRIPLE_SIM */
  {
    is_top_ptr_changed = cmph_insert_orig_mode (
                                    ss,
                                    SD_SS_ORIG_MODE_NONE,
                                    CM_ACT_TYPE_PH_OBJ,
                                    ph_ptr->main_stack_info.pref_info.pref_term,
                                    ph_ptr->main_stack_info.pref_info.mode_pref,
                                    ph_ptr->main_stack_info.pref_info.band_pref,
                                    ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                    ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                    ph_ptr->main_stack_info.pref_info.prl_pref,
                                    ph_ptr->main_stack_info.pref_info.roam_pref,
                                    ph_ptr->main_stack_info.pref_info.hybr_pref,
                                    ph_ptr->int_hybr_pref,
                                    ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                    (cm_act_id_type)ph_ptr,
                                    CM_ACT_UPDATE_REAS_ACT_START,
                                    req_id,
                                    ph_ptr->main_stack_info.pref_info.csg_id,
                                    ph_ptr->main_stack_info.pref_info.csg_rat
                                  );
  }

  if( force_top && is_top_ptr_changed )
  {
    cmph_force_orig_mode_on_the_fly(ss);
  }
}


/*===========================================================================

FUNCTION cmph_notify_mmoc_no_sim

DESCRIPTION
  After an emergency call has ended, we must notify MMOC the
  SIM is missing or failed.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_notify_mmoc_no_sim (

     cm_ss_e_type  ss
      /* SS on which the emergency call has ended */
)
{
  cmph_s_type  *ph_ptr = cmph_ptr();
  sys_modem_as_id_e_type  asubs_id = cmph_map_cm_ss_to_subs(ss);

  /* variables to store the preferences of SS
  */
  sd_ss_orig_mode_e_type        orig_mode;
  sd_ss_mode_pref_e_type        mode_pref;
  sd_ss_srv_domain_pref_e_type  srv_domain_pref;
  sd_ss_acq_order_pref_e_type   acq_order_pref;
  sd_ss_band_pref_e_type        band_pref;
  sd_ss_roam_pref_e_type        roam_pref;
  sd_ss_prl_pref_e_type         prl_pref;



  sys_manual_sys_info_s_type  sys_id;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Validate nam */
  if(!INRANGE(ph_ptr->curr_nam, 0, CM_NAM_AUTO))
  {
    CM_ERR_1( "invlid nam: %d", ph_ptr->curr_nam);
    return;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Get the persistance preferences of this SS */
  orig_mode       = cmph_map_cm_network_sel_mode_pref_to_orig_mode(
                              ph_ptr->is_sglte_device? ph_ptr->main_stack_info.pref_info.network_sel_mode_pref:
                              CMPH_PRST_SS_NETWORK_SEL_MODE_PREF( asubs_id, ph_ptr ));
  mode_pref       = cmph_map_cm_mode_pref_to_sd_mode_pref(
                                        CMPH_PRST_SS_MODE_PREF( asubs_id, ph_ptr));
  srv_domain_pref = cmph_map_cm_srv_domain_pref_to_sd(
                                  CMPH_PRST_SS_SRV_DOMAIN_PREF( asubs_id, ph_ptr));
  acq_order_pref  = cmph_map_cm_acq_order_pref_to_sd(
                                  CMPH_PRST_SS_ACQ_ORDER_PREF( asubs_id, ph_ptr ));
  band_pref       = cmph_map_cm_band_pref_to_sd_band_pref(
                                          CMPH_PRST_SS_BAND_PREF(asubs_id,ph_ptr));
  roam_pref       = cmph_map_cm_roam_pref_to_sd_roam_pref(
                                          CMPH_PRST_SS_ROAM_PREF(asubs_id,ph_ptr));
  prl_pref        = cmph_map_cm_prl_pref_to_sd_prl_pref(
                                           CMPH_PRST_SS_PRL_PREF(asubs_id,ph_ptr));

  sys_id.sys_id.id_type  = SYS_SYS_ID_TYPE_UMTS;
  sys_id.sys_id.id.plmn  = ph_ptr->main_stack_info.pref_info.plmn;
  sys_id.prm.gw.sel_type = SYS_MANUAL_SEL_TYPE_USER_SPECIFIED;

  /* ADD_PROTO with both CDMA and GW makes both protocol stacks reload
  ** NV information
  */
  mmoc_cmd_subscription_chgd3(  MMOC_SUBSC_CHG_SUBSC_AVAIL,
                                (byte) ph_ptr->curr_nam,
                                orig_mode,
                                mode_pref,
                                band_pref,
                                SYS_LTE_BAND_MASK_CONST_NONE,
                                SD_SS_BAND_PREF_NONE,
                                prl_pref,
                                roam_pref,
                                SD_SS_HYBR_PREF_NONE,
                                &sys_id,
                                srv_domain_pref,
                                acq_order_pref,
                                ph_ptr->is_gwl_subscription_available,
                                ph_ptr->is_cdma_subscription_available,
                                ADD_PROTO (PROT_SUBSC_CHG_CDMA,
                                           PROT_SUBSC_CHG_GW)
                              );

} /* cmph_notify_mmoc_no_sim */

/*===========================================================================
FUNCTION cmph_load_prst_phone_pref_on_main

DESCRIPTION
  updates the ph_ptr with persistent values from NV on main stack


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void cmph_load_prst_phone_pref_on_main ( 
           boolean is_oprt_mode_chg_cmd, 
           cm_ph_cmd_s_type          *ph_cmd_ptr
)
{

  cmph_s_type *ph_ptr = cmph_ptr();
  cm_sys_sel_pref_params_s_type *pmprx_pref_ptr = NULL;
  uint8 i = 0;

  boolean ims_for_nondds = cmpmprx_get_volte_allowed_from_pm_on_sub(SYS_MODEM_AS_ID_1);

  /* Reload perstistant values on ONLINE and subscription */
  CM_MSG_HIGH_1("Load peristent user_mode_pref and mode_pref=%d", ph_ptr->prst_main_stack_info[ ph_ptr->curr_nam ].mode_pref);

  ph_ptr->main_stack_info.pref_info.mode_pref = ph_ptr->prst_main_stack_info[ ph_ptr->curr_nam ].mode_pref;
  ph_ptr->main_stack_info.pref_info.user_mode_pref = ph_ptr->prst_main_stack_info[ ph_ptr->curr_nam ].mode_pref;
  ph_ptr->main_stack_info.pref_info.band_pref = ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].band_pref;
  ph_ptr->main_stack_info.pref_info.prl_pref = ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].prl_pref;
  ph_ptr->main_stack_info.pref_info.roam_pref = ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].roam_pref;
  ph_ptr->main_stack_info.pref_info.hybr_pref = ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].hybr_pref;
  ph_ptr->int_hybr_pref = cmph_map_cm_hybr_pref_to_sd_hybr_pref(ph_ptr->main_stack_info.pref_info.hybr_pref);

  if(ph_ptr->default_data_subs == ph_ptr->main_stack_info.asubs_id)
  {
  ph_ptr->main_stack_info.pref_info.srv_domain_pref = CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr);
  }
  else
  {
     if(CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY  || 
        CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr) == CM_SRV_DOMAIN_PREF_NONE
       )
     {
       /*Since 'IMS on nonDDS' would be Primary SUB only, adding this check for MAIN stack only.*/
       if(ims_for_nondds)
       {
         ph_ptr->main_stack_info.pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_ONLY;
         ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_ONLY;
       }
       else
       {
       ph_ptr->main_stack_info.pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_NONE;
       }
     }
     else if(ims_for_nondds) // This would cover when domain is read as CS or CS+PS from PRST
     {
       ph_ptr->main_stack_info.pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_PS;
       ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_PS;
     }
     else
     {
       ph_ptr->main_stack_info.pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
     }
  }

  ph_ptr->main_stack_info.pref_info.acq_order_pref = CMPH_PRST_ACQ_ORDER_PREF( ph_ptr );
  ph_ptr->main_stack_info.pref_info.lte_band_pref = ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].lte_band_pref;
  ph_ptr->main_stack_info.pref_info.tds_band_pref = ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].tds_band_pref;
  ph_ptr->main_stack_info.pref_info.network_sel_mode_pref = CMPH_PRST_NETWORK_SEL_MODE_PREF( ph_ptr );

  /** This is required for Release-7 and beyond. */
  if ((CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( SYS_MODEM_AS_ID_1, ph_ptr ) ==
            CM_USER_NETWORK_SEL_MODE_PREF_AUTOMATIC)
      ||
      (CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( SYS_MODEM_AS_ID_1, ph_ptr ) ==
            CM_USER_NETWORK_SEL_MODE_PREF_MANUAL))
  {
    ph_ptr->main_stack_info.pref_info.network_sel_mode_pref =
           cmph_map_user_to_cm_net_sel_mode_pref (
             CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( SYS_MODEM_AS_ID_1, ph_ptr ));
  }

  /* For SGLTE set network_sel_mode_pref to LIMITED during power up.
  */
  if(ph_ptr->is_sglte_device && is_oprt_mode_chg_cmd)
  {
    if(ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
    {
      ph_ptr->main_stack_info.pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV;
    }
    else
    {
      ph_ptr->main_stack_info.pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV;
    }
  }


  #ifdef FEATURE_CM_LTE
  // Reset Rat Disable Mask
  ph_ptr->rat_disabled_mask[ph_ptr->main_stack_info.asubs_id]= 0;

  if(ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY)
  {
    cm_mode_pref_e_type new_mode_pref;
    new_mode_pref = cm_remove_mode_pref_components(ph_ptr->main_stack_info.pref_info.mode_pref, 1,
                                                   SD_SS_MODE_PREF_GWL_LTE);
    if(new_mode_pref != ph_ptr->main_stack_info.pref_info.mode_pref)
    {
      ph_ptr->main_stack_info.pref_info.mode_pref = new_mode_pref;
      cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_LTE,ph_ptr->main_stack_info.asubs_id);
    }

    #if defined FEATURE_HDR && defined FEATURE_MMODE_DUAL_SIM
    /* For msim, remove HDR if sub0 is not default data sub */
    if (cmph_is_msim() &&
       ph_ptr->default_data_subs != ph_ptr->main_stack_info.asubs_id)
    {
      new_mode_pref = cm_remove_mode_pref_components(
                              ph_ptr->main_stack_info.pref_info.mode_pref, 1,
                              SD_SS_MODE_PREF_HDR);
      if(new_mode_pref != ph_ptr->main_stack_info.pref_info.mode_pref)
      {
        ph_ptr->main_stack_info.pref_info.mode_pref = new_mode_pref;
        cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_HDR, ph_ptr->main_stack_info.asubs_id);
      }
    }
    #endif
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Call into Policy manager and retrieve new policy if needed */
  pmprx_pref_ptr = (cm_sys_sel_pref_params_s_type*)
                         cm_mem_malloc(sizeof(cm_sys_sel_pref_params_s_type));
  pmprx_pref_ptr->mode_pref        = ph_ptr->main_stack_info.pref_info.mode_pref;
  pmprx_pref_ptr->term_pref        = ph_ptr->main_stack_info.pref_info.pref_term;
  pmprx_pref_ptr->pref_duration    = 0;
  pmprx_pref_ptr->band_pref        = ph_ptr->main_stack_info.pref_info.band_pref;
  pmprx_pref_ptr->lte_band_pref    = ph_ptr->main_stack_info.pref_info.lte_band_pref;
  pmprx_pref_ptr->tds_band_pref    = ph_ptr->main_stack_info.pref_info.tds_band_pref;
  pmprx_pref_ptr->prl_pref         = ph_ptr->main_stack_info.pref_info.prl_pref;
  pmprx_pref_ptr->roam_pref        = ph_ptr->main_stack_info.pref_info.roam_pref;
  pmprx_pref_ptr->hybr_pref        = ph_ptr->main_stack_info.pref_info.hybr_pref;
  pmprx_pref_ptr->srv_domain_pref  = ph_ptr->main_stack_info.pref_info.srv_domain_pref;
  pmprx_pref_ptr->network_sel_mode_pref = ph_ptr->main_stack_info.pref_info.network_sel_mode_pref;
  pmprx_pref_ptr->plmn_ptr       = &( ph_ptr->main_stack_info.pref_info.plmn );
  pmprx_pref_ptr->csg_id           = ph_ptr->main_stack_info.pref_info.csg_id ;
  pmprx_pref_ptr->csg_rat          = ph_ptr->main_stack_info.pref_info.csg_rat;
  pmprx_pref_ptr->ue_usage_setting = ph_ptr->main_stack_info.pref_info.ue_usage_setting;
  pmprx_pref_ptr->volte_enable_state = CM_VOLTE_NO_CHANGE;

  cmpmprx_sys_sel_pref_policy_update( ph_ptr->main_stack_info.asubs_id,
                                       pmprx_pref_ptr,ph_cmd_ptr);

  cm_mem_free(pmprx_pref_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  #ifdef FEATURE_RAT_PRIORITY_LIST
  /* Read RAT acquisition order from EFS NV
  */
  for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
  {
    if(!cmpmprx_get_rat_acq_order_pref((sys_modem_as_id_e_type)i,
                                        &ph_ptr->sub_config[i].rat_acq_order_pref))
    {
      CM_MSG_HIGH_1("Fail to get rat_acq_order (TOT) for sub %d from PM", i);
    }
  }
  #else
  /* If rat priority list is not defind, fill the default value
  */
  for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
  {
    ph_ptr->sub_config[i].rat_acq_order_pref.num_rat = 0;
  }
  #endif

  CM_MSG_HIGH_6( "Reload PH settings:mode_pref %d, hybr_pref %d, srv_domain %d, network_sel_mode_pref %d, ims_for_nondds %d prst_srv_domain %d",
                 ph_ptr->main_stack_info.pref_info.mode_pref,
                 ph_ptr->main_stack_info.pref_info.hybr_pref,
                 ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                 ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                 ims_for_nondds,
                 (CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr)));
}

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================
FUNCTION cmph_load_prst_phone_pref_on_hybr3

DESCRIPTION
  updates the ph_ptr with persistent values from NV


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void cmph_load_prst_phone_pref_on_hybr3 ( cm_ph_cmd_s_type          *ph_cmd_ptr )
{

  cmph_s_type *ph_ptr = cmph_ptr();
  cm_sys_sel_pref_params_s_type *pmprx_pref_ptr = NULL;

  if(cmph_is_tsts() || cmph_is_sxlte())
  {
  /* Reload perstistant values on ONLINE and subscription */


  /* Update HYBR_3 preferences */
  ph_ptr->hybr_3_stack_info.pref_info.network_sel_mode_pref =
                      CMPH_PRST_HYBR_3_NETWORK_SEL_MODE_PREF(  ph_ptr );
  ph_ptr->hybr_3_stack_info.pref_info.mode_pref =
                  CMPH_PRST_HYBR_3_MODE_PREF ( ph_ptr);
    ph_ptr->hybr_3_stack_info.pref_info.user_mode_pref =
                  CMPH_PRST_HYBR_3_MODE_PREF ( ph_ptr);
  ph_ptr->hybr_3_stack_info.pref_info.band_pref =
                  CMPH_PRST_HYBR_3_BAND_PREF ( ph_ptr);
  ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref =
                      CMPH_PRST_HYBR_3_TDS_BAND_PREF(ph_ptr);
  ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref =
                      CMPH_PRST_HYBR_3_LTE_BAND_PREF(ph_ptr);
  ph_ptr->hybr_3_stack_info.pref_info.prl_pref =
                  CMPH_PRST_HYBR_3_PRL_PREF ( ph_ptr);
  ph_ptr->hybr_3_stack_info.pref_info.roam_pref =
                      CMPH_PRST_HYBR_3_ROAM_PREF ( ph_ptr);
  ph_ptr->hybr_3_stack_info.pref_info.hybr_pref = CM_HYBR_PREF_OFF;
  ph_ptr->hybr_3_stack_info.pref_info.acq_order_pref =
                      CMPH_PRST_HYBR_3_ACQ_ORDER_PREF ( ph_ptr);
					  
    if(ph_ptr->default_data_subs == ph_ptr->hybr_3_stack_info.asubs_id)
    {
       ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref = CMPH_PRST_HYBR_3_SRV_DOMAIN_PREF(ph_ptr);
    }
    else
    {

        if(CMPH_PRST_HYBR_3_SRV_DOMAIN_PREF( ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY  || 
           CMPH_PRST_HYBR_3_SRV_DOMAIN_PREF( ph_ptr) == CM_SRV_DOMAIN_PREF_NONE
          )
        {
           ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_NONE;
        }
        else
        {
           ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
        }
     }

    #ifdef FEATURE_CM_LTE
    // Reset Rat Disable Mask
    ph_ptr->rat_disabled_mask[ph_ptr->hybr_3_stack_info.asubs_id]= 0;

    if(ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY)
    {
      cm_mode_pref_e_type new_mode_pref;
      new_mode_pref = cm_remove_mode_pref_components(
      ph_ptr->hybr_3_stack_info.pref_info.mode_pref, 1,
      SD_SS_MODE_PREF_GWL_LTE);

      if(new_mode_pref != ph_ptr->hybr_3_stack_info.pref_info.mode_pref)
      {
        ph_ptr->hybr_3_stack_info.pref_info.mode_pref = new_mode_pref;
        cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_LTE, ph_ptr->hybr_3_stack_info.asubs_id);
      }
    }
    #endif

	/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Call into Policy manager and retrieve new policy if needed.
  */
  pmprx_pref_ptr = (cm_sys_sel_pref_params_s_type*)
                         cm_mem_malloc(sizeof(cm_sys_sel_pref_params_s_type));
  pmprx_pref_ptr->mode_pref        = ph_ptr->hybr_3_stack_info.pref_info.mode_pref;
  pmprx_pref_ptr->term_pref        = ph_ptr->hybr_3_stack_info.pref_info.pref_term;
  pmprx_pref_ptr->pref_duration    = 0;
  pmprx_pref_ptr->band_pref        = ph_ptr->hybr_3_stack_info.pref_info.band_pref;
  pmprx_pref_ptr->lte_band_pref    = ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref;
  pmprx_pref_ptr->tds_band_pref    = ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref;
  pmprx_pref_ptr->prl_pref         = ph_ptr->hybr_3_stack_info.pref_info.prl_pref;
  pmprx_pref_ptr->roam_pref        = ph_ptr->hybr_3_stack_info.pref_info.roam_pref;
  pmprx_pref_ptr->hybr_pref        = ph_ptr->hybr_3_stack_info.pref_info.hybr_pref;
  pmprx_pref_ptr->srv_domain_pref  = ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref;
  pmprx_pref_ptr->network_sel_mode_pref = ph_ptr->hybr_3_stack_info.pref_info.network_sel_mode_pref;
  pmprx_pref_ptr->plmn_ptr       = &( ph_ptr->hybr_3_stack_info.pref_info.plmn );
  pmprx_pref_ptr->csg_id           = ph_ptr->hybr_3_stack_info.pref_info.csg_id ;
  pmprx_pref_ptr->csg_rat          = ph_ptr->hybr_3_stack_info.pref_info.csg_rat;
  pmprx_pref_ptr->ue_usage_setting = ph_ptr->hybr_3_stack_info.pref_info.ue_usage_setting;
  pmprx_pref_ptr->volte_enable_state = CM_VOLTE_NO_CHANGE;

  cmpmprx_sys_sel_pref_policy_update( ph_ptr->hybr_3_stack_info.asubs_id,
                                      pmprx_pref_ptr,ph_cmd_ptr);

  cm_mem_free(pmprx_pref_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  }
}
 #endif /* FEATURE_MMODE_TRIPLE_SIM */


#ifdef FEATURE_MMODE_DUAL_SIM
/*===========================================================================
FUNCTION cmph_load_prst_phone_pref_on_hybr2

DESCRIPTION
  updates the ph_ptr with persistent values from NV


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void cmph_load_prst_phone_pref_on_hybr2 ( cm_ph_cmd_s_type          *ph_cmd_ptr )
{

  cmph_s_type *ph_ptr = cmph_ptr();
  cm_sys_sel_pref_params_s_type *pmprx_pref_ptr = NULL;

  /* Reload perstistant values on ONLINE and subscription */

  /* Update HYBR_2 preferences */
  if (cmph_is_msim() && !cmph_is_sxlte() && !cmph_no_hybr2())
  {
    ph_ptr->hybr_2_stack_info.pref_info.network_sel_mode_pref =
                        CMPH_PRST_HYBR_2_NETWORK_SEL_MODE_PREF( ph_ptr );
    ph_ptr->hybr_2_stack_info.pref_info.mode_pref =
                    CMPH_PRST_HYBR_2_MODE_PREF (ph_ptr);
    ph_ptr->hybr_2_stack_info.pref_info.user_mode_pref =
                    CMPH_PRST_HYBR_2_MODE_PREF (ph_ptr);
    ph_ptr->hybr_2_stack_info.pref_info.band_pref =
                    CMPH_PRST_HYBR_2_BAND_PREF (ph_ptr);
    ph_ptr->hybr_2_stack_info.pref_info.prl_pref =
                    CMPH_PRST_HYBR_2_PRL_PREF (ph_ptr);
    ph_ptr->hybr_2_stack_info.pref_info.roam_pref =
                        CMPH_PRST_HYBR_2_ROAM_PREF (ph_ptr);
    ph_ptr->hybr_2_stack_info.pref_info.hybr_pref = CM_HYBR_PREF_OFF;
    ph_ptr->hybr_2_stack_info.pref_info.acq_order_pref =
                        CMPH_PRST_HYBR_2_ACQ_ORDER_PREF (ph_ptr);
    ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref =
                    CMPH_PRST_HYBR_2_TDS_BAND_PREF(ph_ptr);
    ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref =
                        CMPH_PRST_HYBR_2_LTE_BAND_PREF(ph_ptr);

    if(ph_ptr->default_data_subs == ph_ptr->hybr_2_stack_info.asubs_id)
    {
       ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref = CMPH_PRST_HYBR_2_SRV_DOMAIN_PREF(ph_ptr);
    }
    else
    {

        if(CMPH_PRST_HYBR_2_SRV_DOMAIN_PREF( ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY  || 
           CMPH_PRST_HYBR_2_SRV_DOMAIN_PREF( ph_ptr) == CM_SRV_DOMAIN_PREF_NONE
          )
        {
           ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_NONE;
        }
        else
        {
           ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
        }
    }

    #ifdef FEATURE_CM_LTE
    // Reset Rat Disable Mask
    ph_ptr->rat_disabled_mask[ph_ptr->hybr_2_stack_info.asubs_id]= 0;

    if(ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY)
    {
      cm_mode_pref_e_type new_mode_pref;
      new_mode_pref = cm_remove_mode_pref_components(
      ph_ptr->hybr_2_stack_info.pref_info.mode_pref, 1,
      SD_SS_MODE_PREF_GWL_LTE);

      if(new_mode_pref != ph_ptr->hybr_2_stack_info.pref_info.mode_pref)
      {
        ph_ptr->hybr_2_stack_info.pref_info.mode_pref = new_mode_pref;
        cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_LTE, ph_ptr->hybr_2_stack_info.asubs_id);
      }
    }
    #endif
  
	/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
	/* Call into Policy manager and retrieve new policy if needed.
	** Use the same preferences as used in the force_pref_on_fly() below.
	*/
	pmprx_pref_ptr = (cm_sys_sel_pref_params_s_type*)
						 cm_mem_malloc(sizeof(cm_sys_sel_pref_params_s_type));
	pmprx_pref_ptr->mode_pref        = ph_ptr->hybr_2_stack_info.pref_info.mode_pref;
	pmprx_pref_ptr->term_pref        = ph_ptr->hybr_2_stack_info.pref_info.pref_term;
	pmprx_pref_ptr->pref_duration    = 0;
	pmprx_pref_ptr->band_pref        = ph_ptr->hybr_2_stack_info.pref_info.band_pref;
	pmprx_pref_ptr->lte_band_pref    = ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref;
	pmprx_pref_ptr->tds_band_pref    = ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref;
	pmprx_pref_ptr->prl_pref         = ph_ptr->hybr_2_stack_info.pref_info.prl_pref;
	pmprx_pref_ptr->roam_pref        = ph_ptr->hybr_2_stack_info.pref_info.roam_pref;
	pmprx_pref_ptr->hybr_pref        = ph_ptr->hybr_2_stack_info.pref_info.hybr_pref;
	pmprx_pref_ptr->srv_domain_pref  = ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref;
	pmprx_pref_ptr->network_sel_mode_pref = ph_ptr->hybr_2_stack_info.pref_info.network_sel_mode_pref;
	pmprx_pref_ptr->plmn_ptr       = &( ph_ptr->hybr_2_stack_info.pref_info.plmn );
	pmprx_pref_ptr->csg_id           = ph_ptr->hybr_2_stack_info.pref_info.csg_id ;
	pmprx_pref_ptr->csg_rat          = ph_ptr->hybr_2_stack_info.pref_info.csg_rat;
	pmprx_pref_ptr->ue_usage_setting = ph_ptr->hybr_2_stack_info.pref_info.ue_usage_setting;
	pmprx_pref_ptr->volte_enable_state = CM_VOLTE_NO_CHANGE;

	cmpmprx_sys_sel_pref_policy_update( ph_ptr->hybr_2_stack_info.asubs_id,
                                      pmprx_pref_ptr, ph_cmd_ptr);

	cm_mem_free(pmprx_pref_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  
  }
}
#endif /* FEATURE_MMODE_DUAL_SIM */

/*===========================================================================
FUNCTION cmph_load_prst_phone_pref

DESCRIPTION
  updates the ph_ptr with persistent values from NV


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void cmph_load_prst_phone_pref ( cm_ph_cmd_s_type          *ph_cmd_ptr )
{
  cmph_load_prst_dual_standby_pref();
  cmph_load_prst_phone_pref_on_main(TRUE,ph_cmd_ptr);
  #ifdef FEATURE_MMODE_DUAL_SIM
  cmph_load_prst_phone_pref_on_hybr2(ph_cmd_ptr);
  #endif
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  cmph_load_prst_phone_pref_on_hybr3(ph_cmd_ptr);
  #endif
}

/*===========================================================================
FUNCTION cmph_send_vsid_info

DESCRIPTION
  Send VFR ID info to NAS

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_send_vsid_info(
void
)
{
  #ifdef FEATURE_MMODE_DUAL_SIM
  mn_cnm_cmd_type*    mn_ptr = NULL;

  mn_ptr = cm_mn_get_buf_else_err_fatal(CM_ASID_2_VSID_MAPPING_IND);

  /* Set the subscription id on which request is being sent */
  if(cmph_is_lte_capable_on_sub(SYS_MODEM_AS_ID_1))
  {
    mn_ptr->cmd.cm_asid_to_vsid_mapping.asid_to_vsid_map[SYS_MODEM_AS_ID_1]
                = MN_CM_MULTIMODE_SUB_VS_ID;

    mn_ptr->cmd.cm_asid_to_vsid_mapping.asid_to_vsid_map[SYS_MODEM_AS_ID_2]
                = MN_CM_NON_MULTIMODE_SUB_VS_ID;

    #ifdef FEATURE_MMODE_TRIPLE_SIM
    mn_ptr->cmd.cm_asid_to_vsid_mapping.asid_to_vsid_map[SYS_MODEM_AS_ID_3]
                = MN_CM_NON_MULTIMODE_SUB_VS_ID;
    #endif
  }
  else if(cmph_is_lte_capable_on_sub(SYS_MODEM_AS_ID_2))
  {
    mn_ptr->cmd.cm_asid_to_vsid_mapping.asid_to_vsid_map[SYS_MODEM_AS_ID_1]
              = MN_CM_NON_MULTIMODE_SUB_VS_ID;

    mn_ptr->cmd.cm_asid_to_vsid_mapping.asid_to_vsid_map[SYS_MODEM_AS_ID_2]
              = MN_CM_MULTIMODE_SUB_VS_ID;

    #ifdef FEATURE_MMODE_TRIPLE_SIM
   mn_ptr->cmd.cm_asid_to_vsid_mapping.asid_to_vsid_map[SYS_MODEM_AS_ID_3]
              = MN_CM_NON_MULTIMODE_SUB_VS_ID;
    #endif
  }
  #ifdef FEATURE_MMODE_TRIPLE_SIM
    else if(cmph_is_lte_capable_on_sub(SYS_MODEM_AS_ID_3))
    {
      mn_ptr->cmd.cm_asid_to_vsid_mapping.asid_to_vsid_map[SYS_MODEM_AS_ID_1]
                = MN_CM_NON_MULTIMODE_SUB_VS_ID;

      mn_ptr->cmd.cm_asid_to_vsid_mapping.asid_to_vsid_map[SYS_MODEM_AS_ID_2]
                = MN_CM_NON_MULTIMODE_SUB_VS_ID;

      #ifdef FEATURE_MMODE_TRIPLE_SIM
      mn_ptr->cmd.cm_asid_to_vsid_mapping.asid_to_vsid_map[SYS_MODEM_AS_ID_3]
                = MN_CM_MULTIMODE_SUB_VS_ID;
      #endif
    }
  #endif
  cm_mn_send_cmd( mn_ptr );

  #endif
}
/*===========================================================================
FUNCTION cmph_send_subs_info

DESCRIPTION
  Send the subscription info to CM Clients

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_send_subs_info(

     cm_ss_e_type                 ss,
        /* Stack whose subscription Information needs to be sent */

     const cm_client_s_type       *client_ptr
        /* Client who requested this subscription information
        ** If NULL, sent to all registered clients
        */

)
{

  static cm_subs_info_s_type      subs_info;
    /* Subscription Info structure */

  cm_mmgsdi_error_e_type          cm_mmgsdi_status = CM_MMGSDI_SUCCESS;
  cmph_s_type                     *ph_ptr = cmph_ptr();
    /* referece to the ph object */

  #ifndef FEATURE_MMODE_DUAL_SIM
  if (cmph_map_cm_ss_to_subs(ss) != SYS_MODEM_AS_ID_1)
  {
    CM_MSG_HIGH_1("Wrong SS %d",ss);
    SYS_ARG_NOT_USED(client_ptr);
    return;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_3("DSDX: ds%d CM SUBS Event : %d for ss: %d",
    (ss == CM_SS_HYBR_2? 2:\
    (ss == CM_SS_HYBR_3?3:1)),
              CM_PH_EVENT_SUBSCRIPTION_PREF_INFO, ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Fill out the subscription Information from the Ph object and the info
  ** from the session table.
  */
  if( ss == CM_SS_HYBR_2 && !cmph_is_sxlte())
  {
    subs_info.pref_info       = ph_ptr->hybr_2_stack_info.pref_info;
    ph_ptr->hybr_2_stack_info.subs_capability = cmmsc_get_curr_msc_max_cap(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2)); 
    subs_info.subs_capability = ph_ptr->hybr_2_stack_info.subs_capability;
    subs_info.pref_info.user_net_sel_mode = ph_ptr->hybr_2_stack_info.pref_info.user_net_sel_mode;
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  else if( ss == CM_SS_HYBR_3)
  {
    subs_info.pref_info       = ph_ptr->hybr_3_stack_info.pref_info;
    ph_ptr->hybr_3_stack_info.subs_capability = cmmsc_get_curr_msc_max_cap(cmph_map_cm_ss_to_subs(CM_SS_HYBR_3));
    subs_info.subs_capability = ph_ptr->hybr_3_stack_info.subs_capability;
    subs_info.pref_info.user_net_sel_mode = ph_ptr->hybr_3_stack_info.pref_info.user_net_sel_mode;

  }
  #endif
  else
  {
    subs_info.pref_info.acq_order_pref     = ph_ptr->main_stack_info.pref_info.acq_order_pref;
    subs_info.pref_info.band_pref          = ph_ptr->main_stack_info.pref_info.band_pref;
    subs_info.pref_info.hybr_pref          = ph_ptr->main_stack_info.pref_info.hybr_pref;
    subs_info.pref_info.lte_band_pref      = ph_ptr->main_stack_info.pref_info.lte_band_pref;
    subs_info.pref_info.tds_band_pref      = ph_ptr->main_stack_info.pref_info.tds_band_pref;
    subs_info.pref_info.mode_pref          = ph_ptr->main_stack_info.pref_info.mode_pref;
    subs_info.pref_info.mode_uptime        = ph_ptr->main_stack_info.pref_info.mode_uptime;
    subs_info.pref_info.network_sel_mode_pref = ph_ptr->main_stack_info.pref_info.network_sel_mode_pref;

    subs_info.pref_info.plmn = *(&(ph_ptr->main_stack_info.pref_info.plmn));

    subs_info.pref_info.pref_term          = ph_ptr->main_stack_info.pref_info.pref_term;
    subs_info.pref_info.prl_pref           = ph_ptr->main_stack_info.pref_info.prl_pref;
    subs_info.pref_info.roam_pref          = ph_ptr->main_stack_info.pref_info.roam_pref;
    subs_info.pref_info.srv_domain_pref    = ph_ptr->main_stack_info.pref_info.srv_domain_pref;
    subs_info.pref_info.user_net_sel_mode  = ph_ptr->main_stack_info.pref_info.user_net_sel_mode;
    ph_ptr->main_stack_info.subs_capability = cmmsc_get_curr_msc_max_cap(cmph_map_cm_ss_to_subs(CM_SS_MAIN));
    subs_info.subs_capability              = ph_ptr->main_stack_info.subs_capability;
  }
  subs_info.subscription_id   = cmph_map_cm_ss_to_subs(ss);

  subs_info.dds_switch_type =  ph_ptr->dds_switch_type;

  if(subs_info.subscription_id == ph_ptr->default_data_subs)
  {
    subs_info.is_default_data = TRUE;
  }
  else
  {
    subs_info.is_default_data = FALSE;
  }

  if(subs_info.subscription_id == ph_ptr->default_voice_subs)
  {
    subs_info.is_default_voice = TRUE;
  }
  else
  {
    subs_info.is_default_voice = FALSE;
  }

  if(subs_info.subscription_id == ph_ptr->priority_subs)
  {
    subs_info.is_priority_subs = TRUE;
  }
  else
  {
    subs_info.is_priority_subs = FALSE;
  }

  if(subs_info.subscription_id == ph_ptr->main_stack_info.asubs_id)
  {
    subs_info.is_subphone_active =
       ((ph_ptr->active_subs & SYS_MODEM_AS_ID_1_MASK)!=FALSE);
  }
  else if(subs_info.subscription_id == ph_ptr->hybr_2_stack_info.asubs_id)
  {
      subs_info.is_subphone_active =
       ((ph_ptr->active_subs & SYS_MODEM_AS_ID_2_MASK)!=FALSE);
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  else if(subs_info.subscription_id == ph_ptr->hybr_3_stack_info.asubs_id)
  {
      subs_info.is_subphone_active =
       ((ph_ptr->active_subs & SYS_MODEM_AS_ID_3_MASK)!=FALSE);
  }
  #endif
  else
  {
    CM_MSG_HIGH_1("subs id : %d", subs_info.subscription_id);
  }

  if(ss == CM_SS_MAIN && \
    (cmss_ptr()->info.is_main_operational && \
     (ph_ptr->is_cdma_subscription_available || ph_ptr->is_gwl_subscription_available)) \
   )
  {
    subs_info.is_operational = (ph_ptr->is_cdma_subscription_available || ph_ptr->is_gwl_subscription_available);
  }
  else if (ss == CM_SS_HYBR_2 && !cmph_is_sxlte() && \
           (cmss_ptr()->info.is_hybr_gw_operational && ph_ptr->is_hybr_gw_subscription_available) \
          )
  {
    subs_info.is_operational = ph_ptr->is_hybr_gw_subscription_available;
  }
  else if (ss == CM_SS_HYBR_3 && cmss_ptr()->info.is_gw3_operational)
  {
    subs_info.is_operational = ph_ptr->is_hybr_gw3_subscription_available;
  }
  else
  {
    subs_info.is_operational = FALSE;
  }

  subs_info.sub_feature_mode = cmph_get_subs_feature_mode(subs_info.subscription_id);

  CM_MSG_HIGH_5("DSDX: DD: %d, DV: %d, Opr: %d, ds%d mode_pref=%d", subs_info.is_default_data,
                                         subs_info.is_default_voice,
                                         subs_info.is_operational,
              (ss == CM_SS_HYBR_2? 2:\
              (ss == CM_SS_HYBR_3? 3:1)),
              subs_info.pref_info.mode_pref);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  subs_info.priority_type = ph_ptr->data_priority_per_sub[subs_info.subscription_id].priority_type;

  #ifdef FEATURE_MMGSDI_SESSION_LIB
  /* Find the entry in the sessions table using the subscription-id
  */

  /* Get subs info for CSIM/RUIM
   */
  if(ss == CM_SS_MAIN)
  {
    cm_mmgsdi_status = cm_mmgsdi_ssn_tbl_get_subs_info_for_asubs_id_1x(
                      cmph_map_cm_ss_to_subs(ss), &subs_info);

    if( CM_MMGSDI_SUCCESS != cm_mmgsdi_status)
    {
      /* Set Invalid session_type */
      subs_info.session_type_1x = MMGSDI_MAX_SESSION_TYPE_ENUM;
    }
  }
  else
  {
    subs_info.session_type_1x = MMGSDI_MAX_SESSION_TYPE_ENUM;
  }

  /* Get subs info for USIM/SIM
   */
  cm_mmgsdi_status = cm_mmgsdi_ssn_tbl_get_subs_info_for_asubs_id_gw(
                    cmph_map_cm_ss_to_subs(ss), &subs_info);

  if( CM_MMGSDI_SUCCESS != cm_mmgsdi_status)
  {
    /* Set Invalid session_type */
    subs_info.session_type_gw = MMGSDI_MAX_SESSION_TYPE_ENUM;
  }

  #endif /* FEATURE_MMGSDI_SESSION_LIB */

  #ifdef FEATURE_MMODE_DUAL_SIM
  if(cmph_is_lte_capable_on_sub(subs_info.subscription_id))
  {
    memscpy( subs_info.hw_id, sizeof(subs_info.hw_id), cmph_asid2vsid_map[CMPH_SUB_TYPE_MULTIMODE_SUB], sizeof(subs_info.hw_id) );
  }
  else
  {
    memscpy( subs_info.hw_id, sizeof(subs_info.hw_id), cmph_asid2vsid_map[CMPH_SUB_TYPE_NONMULTIMODE_SUB], sizeof(subs_info.hw_id) );
  }
  #else
    memscpy( subs_info.hw_id, sizeof(subs_info.hw_id), cmph_asid2vsid_map[CMPH_SUB_TYPE_MULTIMODE_SUB], sizeof(subs_info.hw_id) );
  #endif


  switch(cmph_map_cm_ss_to_subs(ss))
  {
    case SYS_MODEM_AS_ID_1:

      if (ss == CM_SS_MAIN)
      {
      subs_info.is_available_1x = cmph_ptr()->is_cdma_subscription_available;
      }
      else
      {
        subs_info.is_available_1x = FALSE;
      }

      if (cmph_get_subs_feature_mode(SYS_MODEM_AS_ID_2) == SYS_SUBS_FEATURE_MODE_SVLTE ||
         cmph_get_subs_feature_mode(SYS_MODEM_AS_ID_2) == SYS_SUBS_FEATURE_MODE_SRLTE ||
          cmph_get_subs_feature_mode(SYS_MODEM_AS_ID_2) == SYS_SUBS_FEATURE_MODE_SGLTE)
      {
        subs_info.is_available_gw = cmph_ptr()->is_hybr_gw3_subscription_available;
      }
      else
      {
        subs_info.is_available_gw = cmph_ptr()->is_gwl_subscription_available;
      }
      break;

    case SYS_MODEM_AS_ID_2:
      subs_info.is_available_1x = FALSE;
      if (cmph_get_subs_feature_mode(SYS_MODEM_AS_ID_1) == SYS_SUBS_FEATURE_MODE_SVLTE ||
         cmph_get_subs_feature_mode(SYS_MODEM_AS_ID_1) == SYS_SUBS_FEATURE_MODE_SRLTE ||
         cmph_get_subs_feature_mode(SYS_MODEM_AS_ID_1) == SYS_SUBS_FEATURE_MODE_SGLTE)
      {
        subs_info.is_available_gw = cmph_ptr()->is_hybr_gw3_subscription_available;
      }
      else if (cmph_get_subs_feature_mode(SYS_MODEM_AS_ID_2) == SYS_SUBS_FEATURE_MODE_SGLTE)
      {
        subs_info.is_available_gw = cmph_ptr()->is_gwl_subscription_available;
      }
      else if(cmph_is_sxlte())
      {
        subs_info.is_available_gw = cmph_ptr()->is_hybr_gw3_subscription_available;
      }
      else
      {
        subs_info.is_available_gw = cmph_ptr()->is_hybr_gw_subscription_available;
      }
      break;
    #ifdef FEATURE_MMODE_TRIPLE_SIM
    case SYS_MODEM_AS_ID_3:
      subs_info.is_available_1x = FALSE;
      subs_info.is_available_gw = cmph_ptr()->is_hybr_gw3_subscription_available;
      break;
    #endif

     case SYS_MODEM_AS_ID_NONE:
     #ifndef FEATURE_MMODE_TRIPLE_SIM
     case SYS_MODEM_AS_ID_3:
     #endif
     case SYS_MODEM_AS_ID_NO_CHANGE:
     case SYS_MODEM_AS_ID_MAX:
     default:
       CM_MSG_HIGH_1("Invalid case %d",cmph_map_cm_ss_to_subs(ss));
  }



  CM_MSG_HIGH_4("vs_id %x as_id %d, is_1x %d, is_gw %d",
                subs_info.hw_id[SYS_VSID_APP_CS_VOICE],
                cmph_map_cm_ss_to_subs(ss),
                subs_info.is_available_1x,
                subs_info.is_available_gw);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Notify a specific Client, if the Client_ptr is specified
  ** else, notify all the reqgistered clients
  */
  if(client_ptr != NULL)
  {
    if( client_ptr->subs_event_func )
    {
      CM_MSG_HIGH_3("subs evt %d ct %d cid id %d",
                  CM_PH_EVENT_SUBSCRIPTION_PREF_INFO,
                  cmclient_get_client_type(cmclient_get_client_id(client_ptr)),
                  cmclient_get_client_id(client_ptr));

      client_ptr->subs_event_func( CM_PH_EVENT_SUBSCRIPTION_PREF_INFO,
                                   &subs_info);
    }
    else
    {
      CM_ERR_1(" Client %d doesnt have subsc cb registered",
             cmclient_get_client_id(client_ptr));
    }
  }
  else
  {
    cmclient_list_subs_event_ntfy(&subs_info);
  }
}

/*===========================================================================
FUNCTION cmph_update_curr_priority_sub

DESCRIPTION
  This function should be called when the current priority sub is deactivated so that
  sub having service should be updated with the current priority sub.

DEPENDENCIES
  cmpref2_init() should have been called previously.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
EXTERN  void                           cmph_update_curr_priority_sub
(
  void
)
{
    cmph_s_type           *ph_ptr = cmph_ptr();

    cmss_s_type           *ss_ptr = cmss_ptr();

    sys_modem_as_id_e_type  curr_priority_subs = ph_ptr->curr_priority_subs;


  CM_MSG_HIGH_1( "cmpref2_update_curr_priority_sub: current priority sub:%d",
                 curr_priority_subs);


  if(ph_ptr->curr_priority_subs == SYS_MODEM_AS_ID_1 && \
      ss_ptr->info.is_main_operational == FALSE)
  {
      if( ss_ptr->info.is_hybr_gw_operational == TRUE &&\
           ss_ptr->info.is_gw3_operational== TRUE )
      {
        
        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        /* chk which has higher mode pref , make that as curr priority sub */
        if( ph_ptr->hybr_3_stack_info.pref_info.mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY)
        {
          ph_ptr->curr_priority_subs = ph_ptr->hybr_3_stack_info.asubs_id;
        }
        else
        #endif
        {
          ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
        }
      }
  }
  else if(ph_ptr->curr_priority_subs == SYS_MODEM_AS_ID_2 && \
      ss_ptr->info.is_hybr_gw_operational == FALSE)
  {
      if( ss_ptr->info.is_main_operational == TRUE &&\
           ss_ptr->info.is_gw3_operational == TRUE )
       {
         
         #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
         /* chk which has higher mode pref , make that as curr priority sub */
         if( ph_ptr->hybr_3_stack_info.pref_info.mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY)
         {
           ph_ptr->curr_priority_subs = ph_ptr->hybr_3_stack_info.asubs_id;
         }
         else
         #endif
         {
           ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;
         }
       }
  }
  else if(ph_ptr->curr_priority_subs == SYS_MODEM_AS_ID_3 && \
            ss_ptr->info.is_gw3_operational == FALSE)
  {
    if( ss_ptr->info.is_main_operational == TRUE &&\
           ss_ptr->info.is_hybr_gw_operational == TRUE )
     {
       /* chk which has higher mode pref , make that as curr priority sub */
       if( ph_ptr->hybr_2_stack_info.pref_info.mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY)
       {
         ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
       }
       else
       {
         ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;
       }
     }
  }

  if(curr_priority_subs != ph_ptr->curr_priority_subs)
  {
    CM_MSG_HIGH_1( "After update : current priority sub:%d",
                 ph_ptr->curr_priority_subs);
        /* Update MCS on priority change*/
    cmph_sp_subs_info_update();
  }


}


/*===========================================================================

FUNCTION cmph_sp_subs_info_update

DESCRIPTION
  Updates subs info & priority parameters to MCS

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void cmph_sp_subs_info_update(void)
{
  boolean is_sglte_on = FALSE;
  sp_subscription_info subs_info;
  cmph_s_type *ph_ptr = cmph_ptr();
  sys_modem_as_id_e_type sxlte_as_id = SYS_MODEM_AS_ID_NONE;
  
  memset(&subs_info, 0, sizeof(sp_subscription_info));

  ph_ptr->main_stack_info.subs_capability = cmmsc_get_curr_msc_max_cap(cmph_map_cm_ss_to_subs(CM_SS_MAIN));
  if (!cmph_no_hybr2() && cmph_is_msim())
  {
    ph_ptr->hybr_2_stack_info.subs_capability = cmmsc_get_curr_msc_max_cap(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2)); 
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if((cmph_is_tsts() || cmph_is_sxlte()))
  {
    ph_ptr->hybr_3_stack_info.subs_capability = cmmsc_get_curr_msc_max_cap(cmph_map_cm_ss_to_subs(CM_SS_HYBR_3));
  }
  #endif
  
  subs_info.active_tech_info.active_subscription_mask = 0;

  subs_info.tie_breakers.default_voice_subs = ph_ptr->curr_voice_subs;
  subs_info.tie_breakers.default_data_subs = ph_ptr->default_data_subs;
  subs_info.tie_breakers.priority_subs = ph_ptr->curr_priority_subs;

  if(cmss_ptr()->info.is_main_operational || \
          ((!cmss_ptr()->info.is_hybr_gw_operational) && (!cmss_ptr()->info.is_gw3_operational)))
  {
    subs_info.active_tech_info.active_subscription_mask |= BM(SYS_MODEM_AS_ID_1);
  }

  subs_info.active_tech_info.tech_supported_bitmask[0] = ph_ptr->main_stack_info.subs_capability;

  if(cmss_ptr()->info.is_hybr_gw_operational && !(cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) ||
     cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)) )
  {
    subs_info.active_tech_info.active_subscription_mask |=
                                        BM(SYS_MODEM_AS_ID_2);
  }

  if(!(cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) ||
     cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)) )
  {
    subs_info.active_tech_info.tech_supported_bitmask[1] =
                                ph_ptr->hybr_2_stack_info.subs_capability;
  }


  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(cmss_ptr()->info.is_gw3_operational)
  {
    subs_info.active_tech_info.active_subscription_mask |=
                                        BM(ph_ptr->hybr_3_stack_info.asubs_id);
  }

  if(cmph_is_sxlte())
  {
    subs_info.active_tech_info.tech_supported_bitmask[1] =
                                ph_ptr->hybr_3_stack_info.subs_capability;
  }
  #elif defined(FEATURE_MMODE_TRIPLE_SIM)
  else if(MAX_NUM_OF_SUBSCRIPTIONS > 2) /* Boundary check */
  {
    subs_info.active_tech_info.tech_supported_bitmask[2] =
                                ph_ptr->hybr_3_stack_info.subs_capability;
  }
  #endif

  if(cmpm_ptr()->current_policy[0].service_scan_mode == POLICYMAN_SVC_MODE_ALL &&
     ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE)
  {
    /* 1 indicates FULL RAT SEARCH for SVLTE */
    subs_info.active_tech_info.svc_scan_mode = 1;
  }
  else
  {
    subs_info.active_tech_info.svc_scan_mode = 0;
  }

  /* SXLTE+G changes */

  if((cmmsimc_state_machine_ptr(SYS_MODEM_AS_ID_1)->stack_common_info.ue_mode == SYS_UE_MODE_SGLTE_HOME) ||
      (cmmsimc_state_machine_ptr(SYS_MODEM_AS_ID_1)->stack_common_info.ue_mode == SYS_UE_MODE_SGLTE_TEST_ONLY))
  {
     is_sglte_on = TRUE;
  }

  if(( is_sglte_on && cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1)) || (is_sglte_on &&
      cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_2)))
  {
    subs_info.active_tech_info.simult_cap[SYS_SYS_MODE_GSM] = (1 << SYS_SYS_MODE_LTE) | (1 << SYS_SYS_MODE_TDS);
    subs_info.active_tech_info.simult_cap[SYS_SYS_MODE_LTE] = (1 << SYS_SYS_MODE_GSM);
    subs_info.active_tech_info.simult_cap[SYS_SYS_MODE_TDS] = (1 << SYS_SYS_MODE_GSM);
  }
  else if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
         cmmsc_auto_is_hybr2_on(cmmsimc_state_machine_ptr(SYS_MODEM_AS_ID_1)->op_mode)
  )
  {
    subs_info.active_tech_info.simult_cap[SYS_SYS_MODE_CDMA] |= (1 << SYS_SYS_MODE_LTE);
    subs_info.active_tech_info.simult_cap[SYS_SYS_MODE_LTE]  |= (1 << SYS_SYS_MODE_CDMA);
  }

  if (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1))
  {
    subs_info.tie_breakers.num_active_simul_mode_stacks =
      (cmmsc_auto_is_hybr2_on(
        cmmsimc_state_machine_ptr(ph_ptr->main_stack_info.asubs_id)->op_mode))?2:1;
  }
  else
  {
    subs_info.tie_breakers.num_active_simul_mode_stacks =
      (cmmsc_is_msc_multi_stacks(ph_ptr->main_stack_info.asubs_id))?2:1;
  }



  /* Set multi-sim config */
  if(cmpmprx_get_num_of_sims() == 2)
  {
    subs_info.active_tech_info.multi_sim_config.max_standby_subscriptions = 2;
  }
  #ifdef FEATURE_MMODE_TRIPLE_SIM
  else if(cmpmprx_get_num_of_sims() == 3)
  {
    subs_info.active_tech_info.multi_sim_config.max_standby_subscriptions = 3;
  }
  #endif
  else
  {
    subs_info.active_tech_info.multi_sim_config.max_standby_subscriptions = 1;
  }

  /* Changes to be made as per Policy manager DSDS/DSDA indication */
  if(cmph_is_dsda() && (subs_info.active_tech_info.multi_sim_config.max_standby_subscriptions > 1) )
  {
    subs_info.active_tech_info.multi_sim_config.max_concurrent_active_subscriptions = 2;
  }
  else
  {
    subs_info.active_tech_info.multi_sim_config.max_concurrent_active_subscriptions = 1;
  }

  /* Use PM sfmode instead of CM internal sfmode */
  subs_info.active_tech_info.subs_feature_mode[SYS_MODEM_AS_ID_1] = cmpmprx_get_pm_sfmode(SYS_MODEM_AS_ID_1);

  if(cmph_is_msim()) {
      subs_info.active_tech_info.subs_feature_mode[SYS_MODEM_AS_ID_2] = cmpmprx_get_pm_sfmode(SYS_MODEM_AS_ID_2);
  }

  if(MAX_NUM_OF_SUBSCRIPTIONS > 2){
      subs_info.active_tech_info.subs_feature_mode[SYS_MODEM_AS_ID_2] = cmpmprx_get_pm_sfmode(SYS_MODEM_AS_ID_2);
  }

  
  CM_MSG_HIGH_5("CM->MCS: op_mode:%d device mode: %d active_subsc_mask %d,Set SxLTE simul cap LTE %d GSM %d",\
                 cmmsimc_state_machine_ptr(ph_ptr->main_stack_info.asubs_id)->op_mode,
                 cmpmprx_get_device_mode(),
                 subs_info.active_tech_info.active_subscription_mask,
                 subs_info.active_tech_info.simult_cap[SYS_SYS_MODE_LTE],
                 subs_info.active_tech_info.simult_cap[SYS_SYS_MODE_GSM]);
				 
  if(subs_info.tie_breakers.priority_subs == SYS_MODEM_AS_ID_NONE)
 {
    CM_ERR_FATAL_2("CM sending priority_subs NONE to MCS PHPTR curr_priority_subs %d  priority_subs %d ", 
	                ph_ptr->curr_priority_subs, ph_ptr->priority_subs);
 }  

  sp_subs_info_update(subs_info);
} /* cmph_sp_subs_info_update() */

#ifdef FEATURE_MMODE_DUAL_SIM
/*===========================================================================

FUNCTION cmph_update_vsid_info

DESCRIPTION
  Updates subs info & priority parameters to clients,NAS & MCS

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/


void cmph_update_vsid_info(void)
{
  cmph_send_subs_info(CM_SS_MAIN, NULL);

  if(cmph_is_msim())
  {
    if (!cmph_is_sxlte())
    {
      cmph_send_subs_info(CM_SS_HYBR_2, NULL);
    }
    #if defined(FEATURE_MMODE_TRIPLE_SIM)|| defined(FEATURE_MMODE_SXLTE_G)
    cmph_send_subs_info(CM_SS_HYBR_3, NULL);
    #endif
  }
  cmph_sp_subs_info_update();
  cmph_send_vsid_info();
}
#endif
/*===========================================================================

FUNCTION cmph_update_subscription_to_mmode

DESCRIPTION
  Sends default subscription ( mostly not_avlbl ) to lower layers. So that
  they are ready to acquire limited service in case of ONLINE without
  subscription.

  If there is no card, then CDMA subs is enabled by default in cmph_init.

DEPENDENCIES
  Should be called only after ALL CM initialization is complete.

===========================================================================*/
void cmph_update_subscription_to_mmode( mmoc_subsc_chg_e_type chg_type )
{
  cmph_s_type* ph_ptr = cmph_ptr();
  cm_network_sel_mode_pref_e_type net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_NONE;
  cm_orig_q_s_type *ph_orig_top_ptr =
                            cmtask_orig_para_get_top( CM_SS_MAIN );
  cm_pref_s_type  *hybr_2_pref_ptr = NULL;
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  cm_pref_s_type  *hybr_3_pref_ptr = NULL;
  #endif

  /* Allocate buffer only if multi-sim */
  if (cmph_is_msim() && !cmph_no_hybr2())
  {
    hybr_2_pref_ptr = cm_pref_ptr();
    memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                    &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(cmph_is_tsts() ||cmph_is_sxlte())
  {
    hybr_3_pref_ptr = &(ph_ptr->hybr_3_stack_info.pref_info);
  }
  #endif

  if( ph_orig_top_ptr != NULL &&
      ph_orig_top_ptr->act_type == CM_ACT_TYPE_POLICYMAN_RESTRICT )
  {
    if( ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG )
    {
      net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV;
    }
    else
    {
      switch(CMPH_PRST_NETWORK_SEL_MODE_PREF( ph_ptr ))
      {
         case CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY:
         case CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV:
         case CM_NETWORK_SEL_MODE_PREF_MANUAL:
           net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY;
           break;

         default:
           net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY;
           break;
      }
    }
  }
  else
  {
    net_sel_mode_pref = CMPH_PRST_NETWORK_SEL_MODE_PREF( ph_ptr );
  }

  /* Inform CM Pref & MMOC that subscription changed.
  ** ADD_PROTO with both CDMA and GW makes both protocol stacks reload
  ** NV information
  */
  cmmsimc_proc_cmd_subsc_chgd(chg_type,
      (byte) ph_ptr->curr_nam,
      net_sel_mode_pref,
      CMPH_PRST_MODE_PREF( ph_ptr ),
      CMPH_PRST_BAND_PREF( ph_ptr ),
      CMPH_PRST_LTE_BAND_PREF( ph_ptr ),
      CMPH_PRST_TDS_BAND_PREF( ph_ptr ),
      CMPH_PRST_PRL_PREF( ph_ptr ),
      CMPH_PRST_ROAM_PREF( ph_ptr ),
      ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].hybr_pref,
      ph_ptr->main_stack_info.pref_info.plmn,
      CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr),
      CMPH_PRST_ACQ_ORDER_PREF( ph_ptr ),
      hybr_2_pref_ptr,
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      hybr_3_pref_ptr,
      #endif
      ph_ptr->is_gwl_subscription_available,
      ph_ptr->is_hybr_gw_subscription_available,
      ph_ptr->is_hybr_gw3_subscription_available,
      ph_ptr->is_cdma_subscription_available,
      PROT_SUBSC_CHG_ALL,
      PROT_SUBSC_CHG_GW,
      PROT_SUBSC_CHG_GW );

  CM_MSG_HIGH_3( "nam sel on cm init is sent CDMA %d GWL %d HYBR_GWL %d",
                                ph_ptr->is_gwl_subscription_available,
                                ph_ptr->is_hybr_gw_subscription_available,
                                ph_ptr->is_cdma_subscription_available);

   /* Free allocated buffer */
   if (hybr_2_pref_ptr)
   {
     cm_mem_free (hybr_2_pref_ptr);
   }
}

/*===========================================================================

FUNCTION cmph_map_act_type_to_call_type

DESCRIPTION
  Maps the act_type to call type

DEPENDENCIES
  None

RETURN VALUE
  The call type cm_call_type_e_type

SIDE EFFECTS
  None.

NOTE:

act_type CM_ACT_TYPE_DATA_CALL maps to call_type CM_CALL_TYPE_PS_DATA
act_type CM_ACT_TYPE_DBM  maps to call_type CM_CALL_TYPE_SMS

===========================================================================*/

static cm_call_type_e_type cmph_map_act_type_to_call_type(

  cm_act_type_e_type act_type
    /* Act Type */
)
{

  switch(act_type)
  {

    case  CM_ACT_TYPE_VOICE_CALL:
      return( CM_CALL_TYPE_VOICE );

    #if defined (FEATURE_3GPP_CSFB)
    case  CM_ACT_TYPE_CS_DATA_CALL:
      return( CM_CALL_TYPE_CS_DATA);
    #endif

    case CM_ACT_TYPE_DATA_CALL:
    case CM_ACT_TYPE_GPS:
      return( CM_CALL_TYPE_PS_DATA );

    case CM_ACT_TYPE_SMS_CALL:
    case CM_ACT_TYPE_DBM:
      return(  CM_CALL_TYPE_SMS );

    case CM_ACT_TYPE_OTAPA_CALL :
      return( CM_CALL_TYPE_OTAPA );

    case CM_ACT_TYPE_STD_OTASP:
      return( CM_CALL_TYPE_STD_OTASP );

    case CM_ACT_TYPE_NON_STD_OTASP:
      return( CM_CALL_TYPE_NON_STD_OTASP );

    case CM_ACT_TYPE_EMERG_CALL:
      return( CM_CALL_TYPE_EMERGENCY );

    case CM_ACT_TYPE_TEST_CALL:
      return( CM_CALL_TYPE_TEST );

    case CM_ACT_TYPE_VT_CALL:
      return( CM_CALL_TYPE_VT );

    case CM_ACT_TYPE_VT_LOOPBACK:
      return( CM_CALL_TYPE_VT_LOOPBACK );

    case CM_ACT_TYPE_PD_CALL:
      return( CM_CALL_TYPE_PD );

    case CM_ACT_TYPE_DEFAULT_CALL:
      return( CM_CALL_TYPE_VOICE );

    case CM_ACT_TYPE_NONE:
    default:
      return( CM_CALL_TYPE_NONE );

  }/* switch(call_type) */

} /* cmph_map_act_type_to_call_type */






/*===========================================================================

FUNCTION cmph_force_pref_on_the_fly_hybr_2

DESCRIPTION
  Force the system selection preference on the fly on the HYBR_2 stack.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
dword cmph_force_pref_on_the_fly_hybr_2(

  cm_ss_e_type                     ss,
       /* SS to use for origination, if hybrid operation is changed,
       ** then ss= CM_SS_MAX.
       */

  cmph_s_type                     *ph_ptr,
      /* Pointer to a phone object */

  sd_ss_pref_reas_e_type           force_reason,
      /* Reason for forcing the SS-preference */

  cm_act_type_e_type               act_type,
      /* Call type for which to force the preferences */

  cm_network_sel_mode_pref_e_type  network_sel_mode_pref,
    /* The current network sel mode */

  cm_pref_s_type                   *hybr_2_pref_info_ptr,
      /* Preferences of the MAIN stack */

  cm_activate_code_e_type          otasp_act_code,
      /* OTASP call activation code */

  cm_act_id_type                   act_id,
      /* The uniques id of the activity that is forcing the mode */

  cm_act_update_reas_e_type        act_update_reas,
      /* Reason for the update */

  boolean                          force_top_pref,
      /* Force the top ptreven if the top didn't change */

  const cm_acq_pri_order_pref_s_type   *rat_acq_order_pref_ptr,
    /* Rat acquisition priority order */

  uint16                           req_id,
    /* Sys sel pref req. id */

  sys_csg_id_type                  csg_id,
    /* CSG identifier */

  sys_radio_access_tech_e_type     csg_rat
    /* RAT specified for CSG */

)
/*lint -esym(715,hybr_2_pref_info) */
/*lint -esym(715,int_hybr_pref) */
{



  unsigned int            rescan_time     = 0;
    /* Ballpark estimation for the number of seconds it takes
    ** the phone to reacquire service
    */

  sd_ss_orig_mode_e_type  orig_mode;
    /* Origination mode for main stack
    */

  cm_orig_q_s_type        *ph_hybr_2_orig_top_ptr;
    /* The pointer to the top element of the HYBR_2 priority queue
    */

  cm_orig_q_s_type        *ph_orig_top_ptr;
    /* The pointer to the top element of the priority queue
    */

  boolean                  is_top_ptr_changed        = FALSE;
  boolean                  is_hybr_2_top_ptr_changed = FALSE;

  sd_ss_hybr_pref_e_type   int_hybr_pref   = SD_SS_HYBR_PREF_NONE;
  sys_modem_as_id_e_type   asubs_id = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2);
  cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

  if (hybr_2_pref_info_ptr == NULL)
  {
    CM_MSG_HIGH_0("cmph_force_pref_on_the_fly_hybr_2() hybr_2_pref_info_ptr NULL");
    return rescan_time;
  }

  CM_ASSERT( hybr_2_pref_info_ptr->mode_pref < CM_MODE_PREF_MAX );
  CM_ASSERT(hybr_2_pref_info_ptr->band_pref != CM_BAND_PREF_NONE );
  CM_ASSERT(hybr_2_pref_info_ptr->band_pref != CM_BAND_PREF_MAX );
  CM_ASSERT( BETWEEN(hybr_2_pref_info_ptr->hybr_pref,  CM_HYBR_PREF_NONE, CM_HYBR_PREF_MAX) );
  CM_ASSERT( BETWEEN(hybr_2_pref_info_ptr->prl_pref,   CM_PRL_PREF_NONE,  CM_PRL_PREF_MAX) );
  CM_ASSERT( BETWEEN(hybr_2_pref_info_ptr->roam_pref,  CM_ROAM_PREF_NONE, CM_ROAM_PREF_MAX) );
  CM_ASSERT( INRANGE(hybr_2_pref_info_ptr->srv_domain_pref, CM_SRV_DOMAIN_PREF_NONE,
                                      (CM_SRV_DOMAIN_PREF_MAX-1)));


  network_sel_mode_pref = hybr_2_pref_info_ptr->network_sel_mode_pref;

  /* Map the call type to system determination's origination mode.
  */
  if( network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_NONE )
  {
    orig_mode = cmph_map_cm_call_type_to_sd_orig_mode( cmph_map_act_type_to_call_type(act_type),
                                                       CM_SS_HYBR_2 );
  }
  else
  {
    orig_mode = cmph_map_cm_network_sel_mode_pref_to_orig_mode(
                                                    network_sel_mode_pref );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Lower data call priority
  */
  if( act_update_reas == CM_ACT_UPDATE_REAS_USER ||
      act_update_reas == CM_ACT_UPDATE_REAS_ACT_END )
  {

    /* This is because of a user activity
    ** bump down the priority of all data calls and then insert the
    ** phone object
    */

    (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                  CM_ACT_TYPE_DATA_CALL,
                                  CM_ACT_PRIORITY_80,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );

    (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                  CM_ACT_TYPE_DATA_CALL,
                                  CM_ACT_PRIORITY_END,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );
  }

  /* If there is a activity and we are setting the mode to none or manual_idle,
  ** update the orig mode accordingly
  */
  ph_hybr_2_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_2 );

  if (ph_hybr_2_orig_top_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  ph_orig_top_ptr = ph_hybr_2_orig_top_ptr;

  if ( (act_update_reas ==  CM_ACT_UPDATE_REAS_USER  ) &&
     ( (
          ( ( ph_hybr_2_orig_top_ptr != NULL   &&
              ph_hybr_2_orig_top_ptr->orig->orig_mode != SD_SS_ORIG_MODE_NONE &&
              ph_hybr_2_orig_top_ptr->orig->orig_mode != SD_SS_ORIG_MODE_MANUAL_IDLE
            )
            ||
            ( cmtask_orig_para_count_2( CM_SS_HYBR_2,
                                        CM_ACT_PRIORITY_END,
                                        CM_CMP_CRITERIA_GREATER_THAN) >= 1
            )
          )
       )
     )
     )
  {
    if( orig_mode ==  SD_SS_ORIG_MODE_MANUAL_IDLE )
    {
       orig_mode =  SD_SS_ORIG_MODE_MANUAL_ORIG;
    }
    else
    {
       orig_mode = SD_SS_ORIG_MODE_NORMAL;
    }
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If current origination mode is EMERG_CB and we're originating a call
  ** other than emrgency (for example, PD), set new orig mode to
  ** SD_SS_ORIG_MODE_EMERG_CB
  */
  if( ( act_type                        != CM_ACT_TYPE_EMERG_CALL &&
        act_type                        != CM_ACT_TYPE_PH_OBJ     &&
        ph_hybr_2_orig_top_ptr                 != NULL                   &&
        ph_hybr_2_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_CB
      )
    )
  {
    CM_MSG_HIGH_0("orig_mode (in callback) = SD_SS_ORIG_MODE_EMERG_CB");
    orig_mode = SD_SS_ORIG_MODE_EMERG_CB;
  }

  CM_MSG_HIGH_6( "force_pref_on_the_fly(): ss=%d, act_type=%d, orig_mode(computed new)=%d orig user_mode_pref %d, update_reas %d, mode_pref %d",
                            ss, act_type, orig_mode,ph_orig_top_ptr->orig->user_mode_pref, act_update_reas, hybr_2_pref_info_ptr->mode_pref);
  
  /*
  ** Now figure out whether we need to exit emergency callback mode
  ** or continue in callback but with current preferences
  */
  if((orig_mode != SD_SS_ORIG_MODE_EMERG_CB) && (act_type != CM_ACT_TYPE_PH_OBJ))
  {
    /*
    ** If orig_mode is anything other than SD_SS_ORIG_MODE_EMERG_CB,
    ** exit emergency callback mode
    */
    cmph_exit_emergency_cb(ph_ptr,FALSE,ss,TRUE);
  }

  #ifdef CM_GW_SUPPORTED
  if (act_type == CM_ACT_TYPE_EMERG_CALL )
  {
    cmwcall_set_lmtd_srvc_req ();
  }
  #endif  /* FEATURE_WCDMA || FEATURE_GSM */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the caller of this function wants to use existing system selection
  ** preferences, do so.
  */

  /* Top element of MAIN already accessed
  */
  if( ss != CM_SS_MAX )
  {
    ph_orig_top_ptr = cmtask_orig_para_get_top( ss );
  }
  else
  {
    /* If it's MAX, get the top ptr from MAIN.
    ** This could be due to emergency call or hybr_pref is toggled.
    ** In the back to back emergency call, we will be deleting the orig_top_ptr
    ** acquired above, so we should acquire this back from the MAIN
    */
    ph_orig_top_ptr = cmtask_orig_para_get_top(CM_SS_MAIN);
  }

  if( ( ph_orig_top_ptr != NULL &&
        ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE
      )
      ||
      ph_orig_top_ptr == NULL
    )
  {
    if( hybr_2_pref_info_ptr->mode_pref == CM_MODE_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->mode_pref = CMPH_SS_MODE_PREF(asubs_id, ph_ptr);
    }

    if( hybr_2_pref_info_ptr->band_pref == CM_BAND_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->band_pref = CMPH_SS_BAND_PREF(asubs_id, ph_ptr);
    }

    if( hybr_2_pref_info_ptr->tds_band_pref == CM_BAND_PREF_NO_CHANGE )
    {
       hybr_2_pref_info_ptr->tds_band_pref = CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr );
    }

    if( hybr_2_pref_info_ptr->prl_pref == CM_PRL_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->prl_pref = CMPH_SS_PRL_PREF(asubs_id, ph_ptr);
    }

    if( hybr_2_pref_info_ptr->roam_pref == CM_ROAM_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->roam_pref = CMPH_SS_ROAM_PREF(asubs_id, ph_ptr);
    }

    if( hybr_2_pref_info_ptr->hybr_pref == CM_HYBR_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->hybr_pref = CMPH_SS_HYBR_PREF(asubs_id, ph_ptr);
    }
    int_hybr_pref =
    cmph_map_cm_hybr_pref_to_sd_hybr_pref( hybr_2_pref_info_ptr->hybr_pref );

    if ( hybr_2_pref_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->srv_domain_pref = CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr);
    }
  }
  else
  {
    if( hybr_2_pref_info_ptr->mode_pref == CM_MODE_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->mode_pref =  ph_orig_top_ptr->orig->orig_mode_pref;
    }

    if( hybr_2_pref_info_ptr->band_pref == CM_BAND_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->band_pref = ph_orig_top_ptr->orig->orig_band_pref;
    }

    if( hybr_2_pref_info_ptr->prl_pref == CM_PRL_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->prl_pref = ph_orig_top_ptr->orig->orig_prl_pref;
    }

    if( hybr_2_pref_info_ptr->roam_pref == CM_ROAM_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->roam_pref = ph_orig_top_ptr->orig->orig_roam_pref;
    }

    if( hybr_2_pref_info_ptr->hybr_pref == CM_HYBR_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->hybr_pref = ph_orig_top_ptr->orig->orig_hybr_pref;
    }
    int_hybr_pref = cmph_map_cm_hybr_pref_to_sd_hybr_pref( hybr_2_pref_info_ptr->hybr_pref );

    if ( hybr_2_pref_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_NO_CHANGE )
    {
      hybr_2_pref_info_ptr->srv_domain_pref = ph_orig_top_ptr->orig->orig_srv_domain_pref;
    }
  }

 
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified mode and band preference combination is not valid for this
  ** target or not supported by the currently loaded PRL, use existing mode
  ** and band preferences.
  */
  if( ( SD_SS_ORIG_MODE_EMERG_ORIG != orig_mode || (int)CM_ACT_TYPE_EMERG_CALL!= (int)act_type )
                                                &&
      ( FALSE == cmph_is_valid_mode_band_pref( hybr_2_pref_info_ptr->mode_pref,
                                               hybr_2_pref_info_ptr->band_pref ) &&
        FALSE == cmph_is_valid_tds_mode_band_pref( hybr_2_pref_info_ptr->mode_pref,
                                                   hybr_2_pref_info_ptr->tds_band_pref ) )
    )
  {
    if (hybr_2_pref_info_ptr->mode_pref != CM_MODE_PREF_NONE)
    {
      CM_ERR_2( "Invalid mode/band pref mp=%d, bp=%d", hybr_2_pref_info_ptr->mode_pref,
                                                     hybr_2_pref_info_ptr->band_pref);
      hybr_2_pref_info_ptr->mode_pref = ph_ptr->hybr_2_stack_info.pref_info.mode_pref;
      hybr_2_pref_info_ptr->band_pref = ph_ptr->hybr_2_stack_info.pref_info.band_pref;
      CM_MSG_HIGH_2("Switch to use current mp=%d and bp=%d instead",
                   hybr_2_pref_info_ptr->mode_pref,
                   hybr_2_pref_info_ptr->band_pref);
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if hybrid is toggled for origination, if it is toggled
  ** as a result of sys_pref_change, then clear the HDR Q and send
  ** the sys_pref down
  */

  /* If system selection preference is forced in order to originate a call
  ** (i.e., the origination mode is other than none), only change the
  ** origination mode preference.
  */
  if( act_update_reas != CM_ACT_UPDATE_REAS_USER &&
      act_update_reas != CM_ACT_UPDATE_REAS_ACT_END &&
      act_update_reas != CM_ACT_UPDATE_REAS_ACT_PWR_SAVE )
  {
    /* Insert the origination parameters in the priority queue
    */

    is_top_ptr_changed = cmph_insert_orig_mode( CM_SS_HYBR_2,
                                                orig_mode,
                                                act_type,
                                                hybr_2_pref_info_ptr->pref_term,
                                                hybr_2_pref_info_ptr->mode_pref,
                                                hybr_2_pref_info_ptr->band_pref,
                                                SYS_LTE_BAND_MASK_CONST_NONE,
                                                hybr_2_pref_info_ptr->tds_band_pref,
                                                hybr_2_pref_info_ptr->prl_pref,
                                                hybr_2_pref_info_ptr->roam_pref,
                                                hybr_2_pref_info_ptr->hybr_pref,
                                                int_hybr_pref,
                                                hybr_2_pref_info_ptr->srv_domain_pref,
                                                act_id,
                                                act_update_reas,
                                                req_id,
                                                csg_id,
                                                csg_rat
                                                );

  }
  /* Else, update the phone state to reflect the new preferences.
  */
  else if( act_update_reas == CM_ACT_UPDATE_REAS_USER ||
           act_update_reas == CM_ACT_UPDATE_REAS_ACT_END )
  {
    /* This is because of a user activity
    ** bump down the priority of all data calls and then insert the
    ** phone object
    */

    (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                  CM_ACT_TYPE_DATA_CALL,
                                  CM_ACT_PRIORITY_80,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );

    (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                  CM_ACT_TYPE_DATA_CALL,
                                  CM_ACT_PRIORITY_END,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );

    /* If main Q changed then send pref_sys changed to both MAIN and HDR
    ** If only HDR changed, and Hybrid is toggled, then don't send
    ** pref sys changed down
    ** HYBR_2 is independent of MAIN and HDR, send it down only if
    ** the corresponding preferences changed.
    */

    is_hybr_2_top_ptr_changed = cmph_insert_orig_mode (
                                  CM_SS_HYBR_2,
                                  SD_SS_ORIG_MODE_NONE,
                                  CM_ACT_TYPE_PH_OBJ,
                                  hybr_2_pref_info_ptr->pref_term,
                                  hybr_2_pref_info_ptr->mode_pref,
                                  hybr_2_pref_info_ptr->band_pref,
                                  SYS_LTE_BAND_MASK_CONST_NONE,
                                  hybr_2_pref_info_ptr->tds_band_pref,
                                  hybr_2_pref_info_ptr->prl_pref,
                                  hybr_2_pref_info_ptr->roam_pref,
                                  hybr_2_pref_info_ptr->hybr_pref,
                                  int_hybr_pref,
                                  hybr_2_pref_info_ptr->srv_domain_pref,
                                  (cm_act_id_type)ph_ptr,
                                  act_update_reas,
                                  req_id,
                                  csg_id,
                                  csg_rat
                                );

  }
  else if( act_update_reas == CM_ACT_UPDATE_REAS_ACT_PWR_SAVE )
  {

    /* Insert the origination parameters in the priority queue
    */
    (void) cmph_insert_orig_mode( CM_SS_HYBR_2,
                           orig_mode,
                           act_type,
                           hybr_2_pref_info_ptr->pref_term,
                           hybr_2_pref_info_ptr->mode_pref,
                           hybr_2_pref_info_ptr->band_pref,
                           SYS_LTE_BAND_MASK_CONST_NONE,
                           hybr_2_pref_info_ptr->tds_band_pref,
                           hybr_2_pref_info_ptr->prl_pref,
                           hybr_2_pref_info_ptr->roam_pref,
                           hybr_2_pref_info_ptr->hybr_pref,
                           int_hybr_pref,
                           hybr_2_pref_info_ptr->srv_domain_pref,
                           act_id,
                           act_update_reas,
                           CM_DEFAULT_VALUE,
                           csg_id,
                           csg_rat
                         );

    is_top_ptr_changed = TRUE;
  }

  /* Notify MC of mode preference change.
  */
  CM_MSG_HIGH_2( "is_top_ptr_changed %d, is_hybr_2_top_ptr_changed %d",
               is_top_ptr_changed, is_hybr_2_top_ptr_changed);

  if( is_top_ptr_changed || is_hybr_2_top_ptr_changed )
  {
    cmmsc_pack_cmd_for_pref_sys_chgd_per_pref(
          ss,
          force_reason,
          orig_mode,
          (const cm_pref_s_type*)hybr_2_pref_info_ptr,
          cmph_map_otasp_act_code_to_sd_band( otasp_act_code ),
          cmph_map_otasp_act_code_to_sd_blksys( otasp_act_code ),
          SD_SS_AVOID_SYS_IDLE,
          0,
          rat_acq_order_pref_ptr,
          cmph_map_cm_net_sel_mode_pref_to_camp_pref(network_sel_mode_pref),
          cmph_is_new_policy_apply(ss),
          CM_ACT_UPDATE_REAS_NONE,
          &cmd
          );

    cmmsimc_proc_cmd_pref_sys_chgd(&cmd);


    /* Phone is going to do a rescan, so indicate a ballpark estimation
    ** for the number of seconds it takes the phone to do the rescan and
    ** reacquire service.
    */

    rescan_time = CMPH_RESCAN_TIME;

    /* Search the Q for the phone object and change the update reason to
    ** act_start, if we don't do this, then every time the ph pref are forced
    ** the reason will be user
    */

    if( act_update_reas ==  CM_ACT_UPDATE_REAS_USER )
    {
      cm_orig_q_s_type *queue_entry;

      queue_entry = cmtask_orig_para_search_act_id( CM_SS_HYBR_2, (cm_act_id_type)ph_ptr );
      if(queue_entry != NULL)
      {
        queue_entry->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_START;
      }
      else
      {
        CM_ERR_0( "HYBR_2 queue has no entry for ph!!");
      }
    }
  }
  else if( force_top_pref )
  {

    /* Use the top ptr and force the mode, because we are waiting for OK to orig
    */
    CM_ASSERT( ph_orig_top_ptr != NULL );
    CM_ASSERT( ph_hybr_2_orig_top_ptr != NULL );

    cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue (
       ss,
       force_reason,
       orig_mode,
       cmph_is_new_policy_apply(ss),
       ph_hybr_2_orig_top_ptr,
       CM_ACT_UPDATE_REAS_NONE,
       &cmd
       );

    cmmsimc_proc_cmd_pref_sys_chgd(&cmd);
  }
  else
  {
    CM_MSG_HIGH_0("Didn't force pref, low priority act");
}

  SYS_ARG_NOT_USED(rat_acq_order_pref_ptr);

  return rescan_time;

} /* cmph_force_pref_on_the_fly_hybr_2() */

static void cmph_print_online_ph_info(cmph_s_type *ph)
{
  CM_MSG_HIGH_4( "go online cdma %d, gwl %d hybr_gw %d, hybr_gw3 %d",
                 ph->is_cdma_subscription_available,
                 ph->is_gwl_subscription_available,
    ph->is_hybr_gw_subscription_available,
    ph->is_hybr_gw3_subscription_available);

 
}

static void read_persistent_band_pref(
  cmefs_id_e_type  which_band_pref,
  cm_band_pref_e_type *band_pref,
  sys_modem_as_id_e_type asubs_id
  )
{
  int32               size = sizeof(cm_band_pref_e_type);
  cm_band_pref_e_type default_band_pref = CM_BAND_PREF_NONE;
/*lint -esym(550, log_string) disable not accessed error */
  const char          *log_string = NULL;

  switch (which_band_pref)
  {
    case CMEFS_ID_LTE_BANDPREF:
      default_band_pref = CM_BAND_PREF_LTE_ANY;
      log_string = "prst_lte_band_pref";
      break;

    case CMEFS_ID_TDS_BANDPREF:
      default_band_pref = CM_BAND_PREF_TDS_ANY;
      log_string = "prst_tds_band_pref";
      break;

    default:
      CM_ERR_FATAL_1("Invalid band pref: %d", which_band_pref);
  }

  if(cmefs_get(which_band_pref, (byte *)band_pref, size, asubs_id))
  {
    /* If band pref is invalid
    ** write a valid default band pref value to NV
    */
    CM_MSG_HIGH_3("read successful: %s 0x%x 0x%x",
                log_string,
                QWORD_HIGH(*band_pref),
                QWORD_LOW(*band_pref) );
    if (*band_pref > default_band_pref)
    {
      *band_pref = default_band_pref;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmefs_fs_write(which_band_pref,
                     (byte *) band_pref,
                     sizeof(cm_band_pref_e_type),
                     asubs_id);
      #endif
    }
  }
  else
  {
    *band_pref = default_band_pref;

    #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
    cmefs_fs_write(which_band_pref,
                   (byte *) band_pref,
                   sizeof(cm_band_pref_e_type),
                   asubs_id);
    #endif
  }

  CM_MSG_HIGH_3("%s 0x%x 0x%x",
                log_string,
                QWORD_HIGH(*band_pref),
                QWORD_LOW(*band_pref) );
}

/*===========================================================================

FUNCTION cmph_proc_online_mode_oper

DESCRIPTION
  Performs following on moving to online mode

   - Sets ps_srv_req_sent flag to record that PS attach has been requested
   - Moving from LPM to online should generate

       IF GW is available     :- GW not available followed by ADD_PROTO
                                 (PROT_SUBSC_CHG_CDMA, PROT_SUBSC_CHG_GW)
                                 status
       IF GW is not available :- ADD_PROTO (PROT_SUBSC_CHG_CDMA,
                                 PROT_SUBSC_CHG_GW) status


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void                       cmph_proc_online_mode_oper (

       cmph_s_type                *ph_ptr
    /* Pointer to Ph obj */
)
{
  cm_mode_pref_e_type fav_mode_pref = ph_ptr->main_stack_info.pref_info.user_mode_pref;

  sys_modem_as_id_e_type  asubs_id
      = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2);

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  asubs_id
      = cmph_map_cm_ss_to_subs(CM_SS_HYBR_3);

  if(cmph_is_msim())
  {
    cm_band_pref_e_type               tmp_tds_band_pref;
    read_persistent_band_pref( CMEFS_ID_TDS_BANDPREF,
                             &(tmp_tds_band_pref),
                             asubs_id);
  }
  #endif

  cmph_print_online_ph_info(ph_ptr);

  ph_ptr->is_mode_pref_none = FALSE;
  ph_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_NO_VALUE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*
  ** ONLINE transition would trigger PS_ATTACH procedure. We need to start
  ** PS_SIG_DOWN timer when PS service is acquired.
  **
  ** Set is_ps_Srv_req_sent flag to true now so that when we receive PS
  ** service acquired indication, we can start the PS_SIG_DOWN timer.
  */
  if((ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].srv_domain_pref
                                 == CM_SRV_DOMAIN_PREF_PS_ONLY) ||
     (ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].srv_domain_pref
                                 == CM_SRV_DOMAIN_PREF_CS_PS))
  {
     ph_ptr->is_ps_srv_req_sent = TRUE;
  }

  if(((CMPH_PRST_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr)
                                 == CM_SRV_DOMAIN_PREF_PS_ONLY) ||
       (CMPH_PRST_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr)
                                   == CM_SRV_DOMAIN_PREF_CS_PS))
        &&
        cmph_is_msim() && !cmph_is_sxlte())
  {
     ph_ptr->hybr_2_stack_info.is_ps_srv_req_sent = TRUE;
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if((CMPH_PRST_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr)
                                 == CM_SRV_DOMAIN_PREF_PS_ONLY) ||
     (CMPH_PRST_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr)
                                 == CM_SRV_DOMAIN_PREF_CS_PS))
  {
     ph_ptr->hybr_3_stack_info.is_ps_srv_req_sent = TRUE;
  }
  #endif

  #if (defined FEATURE_CM_LTE) && (defined FEATURE_HDR_HANDOFF)
  ph_ptr->shorten_bsr_timer = 0;
  ph_ptr->is_shorten_bsr = FALSE;
  #endif

    /* Reset flag related to IMS APP registered for subs not available cmd */
  #if defined(FEATURE_IP_CALL)
  ph_ptr->is_ims_cmd_ntfy_sent = FALSE;

  #endif

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  #if (defined(FEATURE_OTASP) || defined (FEATURE_UIM_RUIM))
  diag_otasp_update();              /* Tell Diag to update its cache */
  #endif /* FEATURE_OTASP || FEATURE_UIM_RUIM */
  #endif /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */

  /* Reset the PLMN id of the phone if oprt mode is LPM */
  if ( ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM )
  {
    sys_plmn_undefine_plmn_id( &ph_ptr->main_stack_info.pref_info.plmn );
    ph_ptr->main_stack_info.pref_info.csg_id  = SYS_CSG_ID_INVALID;
    ph_ptr->main_stack_info.pref_info.csg_rat = SYS_RAT_NONE;
  }

CM_MSG_HIGH_1("ph online user_mode_pref=%d", ph_ptr->main_stack_info.pref_info.user_mode_pref);
  /* For RAT balancing feature: Load EF_RAT before ONLINE processing
     when 3GPP subscription is available */
  #ifdef CM_GW_SUPPORTED

  if (ph_ptr->is_rat_bal == TRUE &&
      ph_ptr->is_gwl_subscription_available == TRUE)
  {
    cmmmgsdi_rat_mode_init( &fav_mode_pref );

    if(fav_mode_pref != CM_MODE_PREF_NONE &&
       fav_mode_pref != ph_ptr->main_stack_info.pref_info.user_mode_pref
       && cmph_is_sub1_mm_in_single_standby())
    {
      ph_ptr->is_mode_change_due_to_ef_rat = TRUE;

      fav_mode_pref = cmph_get_intersected_mode_pref_from_efrat_user_mode_pref(ph_ptr->main_stack_info.pref_info.user_mode_pref,fav_mode_pref);
              /* If LTE was marked as disabled add LTE mode and store in NV */
      CM_MSG_HIGH_1("EF_RAT and user_mode_pref intersected=%d is forced", fav_mode_pref);
    }
    else
    {
      fav_mode_pref = ph_ptr->main_stack_info.pref_info.user_mode_pref;
    }
  }
  
  if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, SYS_MODEM_AS_ID_1))
  {
    fav_mode_pref = cm_remove_mode_pref_components(fav_mode_pref,
                                           1,SD_SS_MODE_PREF_LTE);
    }

  /* If HDR was marked as disabled add HDR mode and store in NV */
  if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, SYS_MODEM_AS_ID_1))
  {
    fav_mode_pref = cm_remove_mode_pref_components(fav_mode_pref,
                                                1,SD_SS_MODE_PREF_HDR);
  }

  #endif /* CM_GW_SUPPORTED */

  CM_MSG_HIGH_3("Online pref: mode_pref %d, srv_domain %d, net_sel_mode %d",
              fav_mode_pref, ph_ptr->main_stack_info.pref_info.srv_domain_pref,
              ph_ptr->main_stack_info.pref_info.network_sel_mode_pref);

  {
    cm_pref_s_type *hybr_2_pref_ptr = NULL;

    if (cmph_is_msim() && !cmph_no_hybr2())
    {
      /* Allocate buffer only if multi-sim */
      hybr_2_pref_ptr = cm_pref_ptr();
      memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                      &(CMPH_HYBR_2_PREF(ph_ptr)), sizeof(cm_pref_s_type));

    }

    /* Only pref to MAIN are updated before going ONLINE. Reason for sending
       to MAIN only is that due to HICPS or domain sel. pref in SD may go out
       of sync with CM. But for HYBR_X SD and CM pref are in sync. In future
       if some features introduce out of sync between CM/SD, then pref for those
       stacks also need to sent here
    */
    (void)cmph_force_pref_on_the_fly2(CM_SS_MAX,
                                      ph_ptr,
                                      SD_SS_PREF_REAS_USER, CM_ACT_TYPE_PH_OBJ,
                                      ph_ptr->main_stack_info.pref_info.pref_term,
                                      fav_mode_pref,
                                      ph_ptr->main_stack_info.pref_info.band_pref,
                                      ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                      ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                      ph_ptr->main_stack_info.pref_info.prl_pref,
                                      ph_ptr->main_stack_info.pref_info.roam_pref,
                                      ph_ptr->main_stack_info.pref_info.hybr_pref,
                                      ph_ptr->main_stack_info.pref_info.plmn,
                                      ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                      ph_ptr->main_stack_info.pref_info.acq_order_pref,
                                      ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                                      hybr_2_pref_ptr,
                                      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
                                      &(CMPH_HYBR_3_PREF(ph_ptr)),
                                      #endif
                                      CM_OTASP_ACT_CODE_NONE,
                                      (cm_act_id_type)ph_ptr,
                                      CM_ACT_UPDATE_REAS_USER,
                                      !(cmpmprx_enforce_policy_oprt_mode(SYS_MODEM_AS_ID_MAX)),
                                      cmph_get_acq_pri_order_per_sub(CM_SS_MAX),
                                      CM_DEFAULT_VALUE,
                                      ph_ptr->main_stack_info.pref_info.csg_id,
                                      ph_ptr->main_stack_info.pref_info.csg_rat);

    if(cmph_is_msim() && !cmph_is_sxlte())
    {
      (void)cmph_force_pref_on_the_fly_hybr_2(CM_SS_HYBR_2,
                                      ph_ptr,
                                      SD_SS_PREF_REAS_USER,
                                      CM_ACT_TYPE_PH_OBJ,
                                      ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                                      hybr_2_pref_ptr,
                                      CM_OTASP_ACT_CODE_NONE,
                                      CM_ACT_UPDATE_REAS_USER,
                                      CM_ACT_UPDATE_REAS_USER,
                                      TRUE,
                                      cmph_get_acq_pri_order_per_sub(CM_SS_HYBR_2),
                                      CM_DEFAULT_VALUE,
                                      ph_ptr->main_stack_info.pref_info.csg_id,
                                      ph_ptr->main_stack_info.pref_info.csg_rat);
    }

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if(cmph_is_tsts() || cmph_is_sxlte())
    {
      (void)cmph_force_pref_on_the_fly_ss(CM_SS_HYBR_3,
                                      ph_ptr,
                                      SD_SS_PREF_REAS_USER,
                                      CM_ACT_TYPE_PH_OBJ,
                                      ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                                      hybr_2_pref_ptr,
                                      &(CMPH_HYBR_3_PREF(ph_ptr)),
                                      CM_OTASP_ACT_CODE_NONE,
                                      CM_ACT_UPDATE_REAS_USER,
                                      CM_ACT_UPDATE_REAS_USER,
                                      TRUE,
                                      cmph_get_acq_pri_order_per_sub(CM_SS_HYBR_3),
                                      CM_DEFAULT_VALUE,
                                      ph_ptr->main_stack_info.pref_info.csg_id,
                                      ph_ptr->main_stack_info.pref_info.csg_rat);
    }
    #endif

    /* Free allocated buffer */
    if (hybr_2_pref_ptr)
    {
      cm_mem_free (hybr_2_pref_ptr);
    }
  }

} /* cmph_proc_online_mode_oper () */

/*===========================================================================

FUNCTION cmph_get_supp_mode_pref

DESCRIPTION
  Request for all the available modes and bands supported by the current
  target.

DEPENDENCIES
  None

RETURNS


SIDE_EFFECT
  None

===========================================================================*/
cm_mode_pref_e_type cmph_get_supp_mode_pref(

       cm_mode_pref_e_type     mode_pref,
        /* Current CM mode preference */

       cm_band_pref_e_type     band_pref,
        /* Current CM band preference */

       sys_lte_band_mask_e_type     lte_band_pref,
        /* Current CM LTE band preference */

       cm_band_pref_e_type     tds_band_pref
        /* Current CM TD-SCDMA band preference */

)
{
  /* Get the SD equivalents of the CM preferences */
  sd_ss_mode_pref_e_type sd_mode_pref =
                            cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref);
  sd_ss_band_pref_e_type sd_band_pref =
                            cmph_map_cm_band_pref_to_sd_band_pref(band_pref);

  sd_ss_band_pref_e_type sd_tds_band_pref =
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(tds_band_pref);

  /* Compute the effective mode preference */
  sd_mode_pref = sd_ss_get_supp_mode_pref( sd_mode_pref,
                                           sd_band_pref,
                                           lte_band_pref,
                                           sd_tds_band_pref);

  /* return the CM equivalent of the effective mode preference */
  return cmph_map_sd_mode_pref_to_cm_mode_pref(sd_mode_pref);

} /* cmph_get_supp_mode_pref */

/*===========================================================================

FUNCTION cmph_detach_call_end

DESCRIPTION
  This function processes system selection preferences.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void                        cmph_detach_call_end(

       cm_ss_e_type                ss
)
{
  sys_modem_as_id_e_type  asubs_id = cmph_map_cm_ss_to_subs(ss);

  #if (defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_CM_LTE))
  /*
  ** Check if any PS call exists and if so,Send PDP_ABORT_REQ so
  ** that all PDP calls are locally deactivated by NAS,before CM
  ** unreserves SM connection id.
  */
  cmwcall_send_pdp_abort_req(ss);
  #endif

  if(cmcall_is_no_call_in_gw_ps_per_subs(ss, asubs_id) == FALSE )
  {
  /* Check if a call exists and if so, End the call here
  ** and then delete it from queue
  */
    /* end all PS calls and set the act priority to END.
  */
    cmcall_end_each_call_with_mode_per_sub(CM_CALL_MODE_INFO_GW_PS,
                                 CM_CALL_END_LL_CAUSE,asubs_id);
  }

  /* Remove preferences with priority end on SS where DETACH is happening */
  cmph_remove_orig_mode_with_priority_end(ss);

  /* To take care of data calls below PH in multi mode config and to consider calls which are in END_WAIT state*/
  cmph_remove_orig_mode_data_call_below_ph(ss);

  /* Remove the data calls on the SUB1 with priority end when DETACH is issued. */
  if (ss == CM_SS_MAIN)
  {
    cmph_remove_orig_mode_with_priority_end(CM_SS_HYBR_1);
  }
}


/*===========================================================================

FUNCTION cmph_cmd_evaluate_is_ps_detach_required_per_sub

DESCRIPTION
  This function compares the old mode/band pref and the new mode/band pref, and determines is_ps_detach_requred.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_cmd_evaluate_is_ps_detach_required_per_sub(
  sys_modem_as_id_e_type      asubs_id,
  cm_mode_pref_e_type         mode_pref,
  cm_band_pref_e_type         band_pref,
  sys_lte_band_mask_e_type    lte_band_pref,
  cm_band_pref_e_type         tds_band_pref
)
{
  boolean        is_ps_detach_required = FALSE;
  cm_ss_e_type   ss                    = CM_SS_MAIN;
  cmph_s_type   *ph_ptr                = cmph_ptr();

  if (cmph_is_msim())
  {
    ss = cmph_map_subs_to_ss(asubs_id);
  }

  switch(ss)
  {
  case CM_SS_MAIN:
    {
      is_ps_detach_required = cmph_cmd_evaluate_is_ps_detach_required(asubs_id,
                                                                      ph_ptr->main_stack_info.pref_info.mode_pref,
                                                                      ph_ptr->main_stack_info.pref_info.band_pref,
                                                                      ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                                                      ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                                                      mode_pref,
                                                                      band_pref,
                                                                      lte_band_pref,
                                                                      tds_band_pref);
    }
    break;
  case CM_SS_HYBR_2:
    {
      is_ps_detach_required = cmph_cmd_evaluate_is_ps_detach_required(asubs_id,
                                                                      ph_ptr->hybr_2_stack_info.pref_info.mode_pref,
                                                                      ph_ptr->hybr_2_stack_info.pref_info.band_pref,
                                                                      ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
                                                                      ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref,
                                                                      mode_pref,
                                                                      band_pref,
                                                                      lte_band_pref,
                                                                      tds_band_pref);
    }
    break;
#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  case CM_SS_HYBR_3:
    {
      is_ps_detach_required = cmph_cmd_evaluate_is_ps_detach_required(asubs_id,
                                                                      ph_ptr->hybr_3_stack_info.pref_info.mode_pref,
                                                                      ph_ptr->hybr_3_stack_info.pref_info.band_pref,
                                                                      ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref,
                                                                      ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref,
                                                                      mode_pref,
                                                                      band_pref,
                                                                      lte_band_pref,
                                                                      tds_band_pref);
    }
    break;
#endif
  default:
    CM_ERR_1("Invalid SS %d",ss);
    break;
  }
  return is_ps_detach_required;
}

/*===========================================================================

FUNCTION cmph_cmd_evaluate_is_ps_detach_required

DESCRIPTION
  This function compares the old mode/band pref and the new mode/band pref, and determines is_ps_detach_requred.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_cmd_evaluate_is_ps_detach_required(

  sys_modem_as_id_e_type      as_id,
  cm_mode_pref_e_type         old_cm_mode_pref,
  cm_band_pref_e_type         old_cm_band_pref,
  sys_lte_band_mask_e_type    old_cm_lte_band_pref,
  cm_band_pref_e_type         old_cm_tds_band_pref,
  cm_mode_pref_e_type         new_cm_mode_pref,
  cm_band_pref_e_type         new_cm_band_pref,
  sys_lte_band_mask_e_type    new_cm_lte_band_pref,
  cm_band_pref_e_type         new_cm_tds_band_pref
)
{
  cmph_s_type                 *ph_ptr = cmph_ptr();
  boolean is_ps_detach_required = ph_ptr->is_ps_detach_required;
  #ifdef FEATURE_LTE
  cmmsc_state_machine_s_type   *state_machine_ptr = cmmsimc_state_machine_ptr(as_id);
  cmmsc_stack_s_type           *stack_pointer     = &state_machine_ptr->stack[0];

  /* If current or new mode/band pref has LTE, and sim state is not PS invalid
  ** then a band/mode pref change should be preceded by a PS_DETACH
  */
  /*lint -e655 */

  boolean new_mode_lte = ((int)(sd_ss_get_supp_mode_pref(
                cmph_map_cm_mode_pref_to_sd_mode_pref(new_cm_mode_pref),
                cmph_map_cm_band_pref_to_sd_band_pref(new_cm_band_pref),
                new_cm_lte_band_pref,
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(new_cm_tds_band_pref))
                & SD_SS_MODE_PREF_LTE) != 0);

  boolean old_mode_lte = ((int)(sd_ss_get_supp_mode_pref(
              cmph_map_cm_mode_pref_to_sd_mode_pref(old_cm_mode_pref),
              cmph_map_cm_band_pref_to_sd_band_pref(old_cm_band_pref),
              old_cm_lte_band_pref,
              cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(old_cm_tds_band_pref))
              & SD_SS_MODE_PREF_LTE) != 0);

  boolean old_mode_gwt = ((int)(sd_ss_get_supp_mode_pref(
              cmph_map_cm_mode_pref_to_sd_mode_pref(old_cm_mode_pref),
              cmph_map_cm_band_pref_to_sd_band_pref(old_cm_band_pref),
              old_cm_lte_band_pref,
              cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(old_cm_tds_band_pref))
              & SD_SS_MODE_PREF_TDS_GSM_WCDMA) != 0);

  boolean new_mode_gw = ((int)(sd_ss_get_supp_mode_pref(
                cmph_map_cm_mode_pref_to_sd_mode_pref(new_cm_mode_pref),
                cmph_map_cm_band_pref_to_sd_band_pref(new_cm_band_pref),
                new_cm_lte_band_pref,
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(new_cm_tds_band_pref))
                & SD_SS_MODE_PREF_GW) != 0);

  /* Calculate overall supp mode pref for correct comparison (Automatic = GWL if only GWL bands are selected
  */
  sd_ss_mode_pref_e_type supp_preferred_mode = sd_ss_get_supp_mode_pref(
                cmph_map_cm_mode_pref_to_sd_mode_pref(new_cm_mode_pref),
                cmph_map_cm_band_pref_to_sd_band_pref(new_cm_band_pref),
                new_cm_lte_band_pref,
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(new_cm_tds_band_pref));

  sd_ss_mode_pref_e_type supp_ph_mode_pref = sd_ss_get_supp_mode_pref(
                cmph_map_cm_mode_pref_to_sd_mode_pref(old_cm_mode_pref),
                cmph_map_cm_band_pref_to_sd_band_pref(old_cm_band_pref),
                old_cm_lte_band_pref,
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(old_cm_tds_band_pref));


  mmgsdi_session_type_enum_type  session_type=MMGSDI_MAX_SESSION_TYPE_ENUM;
  cm_mmgsdi_error_e_type cm_mmgsdi_status=CM_MMGSDI_UNSUPPORTED;

  CM_MSG_HIGH_5("PS Detach: new_mode_lte %d, old_mode_lte %d, new_mode_gw %d, supp_preferred_mode %d, supp_ph_mode_pref %d",
                new_mode_lte,
                old_mode_lte,
                new_mode_gw,
                supp_preferred_mode,
                supp_ph_mode_pref);

  /*
   1) 2G card is inserted
   2) user sent GWL using cm_ph_cmd_sys_sel_pref
   3) SD removed L , since card type is 2G
   4) user sent GW only using cm_ph_cmd_sys_sel_pref
   in the above case CM doesnt need to send PS detach , since L was never there      */
    cm_mmgsdi_status = cm_mmgsdi_ssn_tbl_get_type_for_asubs_id_gw(
                                            as_id,
                                            &session_type);
  if(cmph_is_gw_subsc_avail(as_id) == FALSE)
  {
    CM_MSG_HIGH_1("PS_DETACH subs not avail as_id %d",as_id);
    return ph_ptr->is_user_ps_detach_required;
  }
  else if(MMGSDI_MAX_SESSION_TYPE_ENUM != session_type &&
       cm_mmgsdi_status == CM_MMGSDI_SUCCESS)
    {

      if(cm_mmgsdi_ssn_tbl_get_app_type_for_type(session_type)==MMGSDI_APP_SIM )
      {

        CM_MSG_HIGH_2("PS Detach=is_user_ps_detach_required session_type %d %d",
        ph_ptr->is_user_ps_detach_required,
        session_type);
        return ph_ptr->is_user_ps_detach_required;

  }
  }

  if(ph_ptr->is_pref_change_pending[as_id] == FALSE &&
     (cmph_is_msim() &&
      as_id != ph_ptr->default_data_subs &&
      CMPH_SS_SRV_DOMAIN_PREF(as_id,ph_ptr) != CM_SRV_DOMAIN_PREF_CS_PS &&
      CMPH_SS_SRV_DOMAIN_PREF(as_id,ph_ptr) != CM_SRV_DOMAIN_PREF_PS_ONLY
       ))
  {
    is_ps_detach_required = FALSE;
    ph_ptr->is_user_ps_detach_required = FALSE;
    return is_ps_detach_required;

  }

  /*Filtered/Supported LTE,TDS Bands*/
  old_cm_lte_band_pref = SYS_LTE_BAND_MASK_COMMON(&old_cm_lte_band_pref , &stack_pointer->capablity.lte_band);
  new_cm_lte_band_pref = SYS_LTE_BAND_MASK_COMMON(&new_cm_lte_band_pref , &stack_pointer->capablity.lte_band);

  old_cm_band_pref = cmph_map_sd_band_pref_to_cm_band_pref(cmph_map_cm_band_pref_to_sd_band_pref(old_cm_band_pref) & ph_ptr->band_capability);
  new_cm_band_pref = cmph_map_sd_band_pref_to_cm_band_pref(cmph_map_cm_band_pref_to_sd_band_pref(new_cm_band_pref) & ph_ptr->band_capability);

  /* if GWLT has change or when LTE is capable, 1X/HDR has change,
    ** PS detach (and re-attach to inform the NW).
    */
    if( ( ((supp_preferred_mode & SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE) !=
            (supp_ph_mode_pref & SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE) )
           ||
           ((supp_preferred_mode & SD_SS_MODE_PREF_LTE) &&
           ((supp_preferred_mode & SD_SS_MODE_PREF_CDMA_HDR) !=
            (supp_ph_mode_pref & SD_SS_MODE_PREF_CDMA_HDR)) && ph_ptr->is_cdma_subscription_available)
        )
        ||
         new_cm_band_pref != old_cm_band_pref ||
        !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&new_cm_lte_band_pref,&old_cm_lte_band_pref)
    )
  {
    sys_sim_state_e_type                    sim_state = cmss_get_gw_sim_state_ss(cmph_map_as_id_to_cm_ss(as_id));

    CM_MSG_HIGH_2("PS detach: Mode pref change detected. as_id %d SIM state: %d",as_id, sim_state);

    if(( new_mode_lte || old_mode_lte )
         &&
      (cmss_ptr()->info.mode_info.gw_info.sim_state != SYS_SIM_STATE_PS_INVALID  &&
       cmss_ptr()->info.mode_info.gw_info.sim_state != SYS_SIM_STATE_CS_PS_INVALID))
  /*lint +e655 */
    {
      /* Mode or band preference changed, do PS detach first */
      /* If old mode does not have LTE and new mode as G/W then don't set
      ** PS detach to TRUE (eg. GW -> GWL).
      ** Below condition is boolean reduction */
      if(ph_ptr->is_mode_change_due_to_ef_rat == TRUE &&
         (cmss_ptr()->info.sys_mode       == SYS_SYS_MODE_GSM ||
          cmss_ptr()->info.sys_mode       == SYS_SYS_MODE_WCDMA) &&
         old_mode_lte && !new_mode_lte)
      {
        is_ps_detach_required = FALSE;
        CM_MSG_HIGH_0("Marking PS detach required as FALSE due to EF-RAT");
      }
      else if(!old_mode_lte && !old_mode_gwt)
      {
        is_ps_detach_required = FALSE;
      }
      else if(old_mode_lte || !new_mode_gw)
      {
        is_ps_detach_required = TRUE;
      }
      else
      {
        is_ps_detach_required = FALSE;
      }
      CM_MSG_HIGH_4("is_ps_detach_required %d, derrived from old_mode_lte %d, old_mode_gwt %d, new_mode_gw %d",
        is_ps_detach_required,old_mode_lte, old_mode_gwt, new_mode_gw);

    }
  }

  #endif /* FEATURE_LTE */
  return is_ps_detach_required;
}

/*===========================================================================

FUNCTION cmph_is_user_resel_needed

DESCRIPTION
  Decides if system selection need to be forced again as desired by the user.
  Currently, when user changes from AUTO to MANUAL or if AUTO  to AUTO then
  system selection is forced.

RETURN VALUE
  Boolean values indicating if reselection is needed

===========================================================================*/

static boolean cmph_is_user_resel_needed(

  cm_ph_cmd_info_s_type  *cmd_info_ptr
)
{
  boolean is_resel_needed = FALSE;

  /* If network sel mode is changed to manual with a valid PLMN AND not a
     CSG selection request */
  if ( (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL &&
        cmd_info_ptr->csg_id == SYS_CSG_ID_INVALID) &&
        !sys_plmn_id_is_undefined (cmd_info_ptr->plmn))
  {
    is_resel_needed = TRUE;
  }

  /* If user request was to attempt PLMN+RAT combo */
  if(cmph_is_valid_pref_plmn_rat_req(cmd_info_ptr))
  {
    is_resel_needed = TRUE;
  }

  return is_resel_needed;
}

/*===========================================================================

FUNCTION cmph_cmd_sys_sel_pref_proc

DESCRIPTION
  This function processes system selection preferences.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_sys_sel_pref_proc(

  cm_ph_cmd_s_type         *ph_cmd_ptr
)
{

  cm_ph_cmd_info_s_type       *cmd_info_ptr    = NULL;
      /* Point at command information component */

  cm_srv_domain_pref_e_type   srv_domain_tobe_forced =
                                           CM_SRV_DOMAIN_PREF_NONE;
    /* srv domain to be forced on sd */

  boolean                     is_force_top_pref = FALSE;
  sd_ss_pref_reas_e_type      reason = SD_SS_PREF_REAS_USER;

  cm_ss_e_type                  ss = CM_SS_MAIN;
  sys_modem_as_id_e_type  asubs_id = SYS_MODEM_AS_ID_1;

  cmph_s_type                 *ph_ptr = cmph_ptr();

  cm_srv_type_e_type          srv_type;
  sys_sys_mode_e_type         sys_mode;
  cm_mode_pref_e_type         supp_cm_mode_pref;

  cm_act_orig_s_type          *last_pref_ptr;
  cm_mode_pref_e_type         prefered_mode       = CM_MODE_PREF_NONE;
  cm_mode_pref_e_type         fav_mode_pref       = CM_MODE_PREF_NONE;

  sd_ss_mode_pref_e_type      supp_mode_pref      = SD_SS_MODE_PREF_NONE;

  boolean network_sel_mode_pref_changed = ph_cmd_ptr->info.net_sel_mode_pref_chgd;
    /* = TRUE if client changed the network sel mode pref */

  cm_pref_s_type              *hybr_gw_pref_ptr = NULL;
  cm_pref_s_type              *hybr_3_gw_pref_ptr = NULL;

  cm_acq_pri_order_pref_s_type  rat_acq_pri_order;

  #if defined FEATURE_DOMAIN_SELECTION
  cmsds_s_type                *sds_ptr = cmsds_ptr();
  cmsds_sub_config_s_type     *cmsds_config = NULL;  
  #endif

  cm_sys_sel_pref_params_s_type *pmprx_pref_ptr = NULL;
  cm_orig_q_s_type              *ph_orig_ptr =
                                    cmtask_orig_para_search_act_type( CM_SS_MAIN,
                                                             CM_ACT_TYPE_PH_OBJ);
  cmss_s_type         *ss_ptr        = cmss_ptr();
  sys_srv_status_e_type lte_srv_status = SYS_SRV_STATUS_NONE;
  cm_orig_q_s_type*         ph_orig_top_ptr;
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (cmph_is_msim())
  {
    ss = cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);
    asubs_id = cmd_info_ptr->cmd_subs;
  }

  #if defined FEATURE_DOMAIN_SELECTION  
  cmsds_config = cmsds_get_config_ptr(asubs_id);
  #endif

 if(cmph_is_feature_mode_1x_sxlte() &&
    (cmd_info_ptr->csg_id != SYS_CSG_ID_INVALID) && (cmd_info_ptr->csg_rat != SYS_RAT_NONE))
  {

    if(cmd_info_ptr->csg_rat == SYS_RAT_LTE_RADIO_ACCESS)
    {
      ss = cmph_determine_ss_per_rat(cmd_info_ptr->cmd_subs,SYS_SYS_MODE_LTE);
    }
  }
  #ifdef FEATURE_DOMAIN_SELECTION

  /* Rest FPLPMN list during the UE Usage setting change */
  if ((ph_cmd_ptr->info.ue_usage_setting == SYS_UE_USAGE_SETTING_DATA_CENTRIC) &&
      (CMPH_SS_UE_USAGE_SETTING(asubs_id, ph_ptr) == SYS_UE_USAGE_SETTING_VOICE_CENTRIC) &&
      (ph_ptr->is_sglte_device == TRUE))
  {
    cmregprx_cmd_perform_plmn_blocking(SYS_BLOCK_PLMN_RESET, 0, asubs_id);
  }

  cmsds_config->ue_usage_setting = ph_cmd_ptr->info.ue_usage_setting;
  *(CMPH_SS_UE_USAGE_SETTING_PTR(asubs_id, ph_ptr)) = cmsds_config->ue_usage_setting;

  /* Reset VOPS status to send appropriate VOPS support to RM after TAU completion */
  if (cmsds_config->voice_domain_pref != ph_cmd_ptr->info.voice_domain_pref)
  {
    if (cmph_is_lte_capable_on_sub(asubs_id))
    {
      cmph_remove_and_force_orig_mode_with_priority_end(ss, FALSE);

      if (cmph_get_subs_feature_mode(asubs_id) != SYS_SUBS_FEATURE_MODE_NORMAL)
    {
      cmph_remove_and_force_orig_mode_with_priority_end(CM_SS_HYBR_2, FALSE);
    }
    }
    sds_ptr->lte_ims_voice_avail = CMSDS_IMS_VOICE_NONE;
  }
  /* Update voice domain pref only for multimode sub.
  ** Ideally for non multimode sub (non-LTE), we shouldnt get voice domain pref change
  ** request from UI. If we get, we shouldnt be forcing the new voice domain pref
  */
  if(cmph_is_lte_capable_on_sub(asubs_id))
  {
    cmsds_config->voice_domain_pref = ph_cmd_ptr->info.voice_domain_pref;
  }
  *(CMPH_SS_VOICE_DOMAIN_PREF_PTR(asubs_id, ph_ptr)) = cmsds_config->voice_domain_pref;
  
  /* Update local policy here itself as PM will not return the new voice domain pref again */
  cmpm_ptr()->current_policy[asubs_id].voice_domain_pref = cmsds_get_config_ptr(asubs_id)->voice_domain_pref;
  
  #endif

  if ((ph_orig_ptr->orig->orig_mode_pref == CM_MODE_PREF_NONE) &&
      (ph_ptr->is_mode_pref_none == TRUE))
  {
    ph_ptr->is_mode_pref_none = FALSE;
    CM_MSG_HIGH_1 ("Resetting is_mode_pref_none falg %d", ph_ptr->is_mode_pref_none);
  }

  prefered_mode = cmd_info_ptr->mode_pref;
  if(ph_ptr->main_stack_info.pref_info.user_mode_pref != cmd_info_ptr->mode_pref)
  {
    CM_MSG_HIGH_2("Initial user_mode_pref=%d,cmd_info_ptr->mode_pref=%d", ph_ptr->main_stack_info.pref_info.user_mode_pref,cmd_info_ptr->mode_pref);
  }
#ifdef CM_GW_SUPPORTED

  if (ph_ptr->is_rat_bal == TRUE &&
      ph_ptr->is_gwl_subscription_available == TRUE)
  {
    cmmmgsdi_rat_mode_init( &fav_mode_pref );
    
    if(fav_mode_pref != CM_MODE_PREF_NONE &&
       fav_mode_pref != cmd_info_ptr->mode_pref
       && cmph_is_sub1_mm_in_single_standby())
    {
      fav_mode_pref = cmph_get_intersected_mode_pref_from_efrat_user_mode_pref(cmd_info_ptr->mode_pref,fav_mode_pref);

      //Store temporarily contents of user mode pref - EF_RAT preferences.
      cmph_temp_ef_rat_disabled_mask = (cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->mode_pref) & 
                                        ~(cmph_map_cm_mode_pref_to_sd_mode_pref(fav_mode_pref)));
      
      CM_MSG_HIGH_2("EF_RAT and user_mode_pref intersected=%d in sys_sel_pref_proc forced, ef_rat_disable_mask=%d", fav_mode_pref,cmph_temp_ef_rat_disabled_mask);
    }
    else
    {
      fav_mode_pref = cmd_info_ptr->mode_pref;
    }
    
    prefered_mode = fav_mode_pref;

  }
#endif /* CM_GW_SUPPORTED */
   cmd_info_ptr->mode_pref = prefered_mode;

  if(prefered_mode !=cmd_info_ptr->mode_pref)
  {
    CM_MSG_HIGH_3("cmph_cmd_sys_sel_pref_proc fav_mode_pref = %d, prefered_mode=%d, cmd_info_ptr->mode_pref=%d", fav_mode_pref,prefered_mode,cmd_info_ptr->mode_pref);
  }

  /* Update rat_acq_order_pref with the command parameter passed */
  if(cmd_info_ptr->rat_acq_order_pref.type == CM_ACQ_ORDER_TYPE_GW)
  {
    /* update gw acq order pref */
    cmd_info_ptr->acq_order_pref = \
      cmd_info_ptr->rat_acq_order_pref.acq_order.gw_acq_order;

    /* Use existing rat_acq_order */
    CM_MSG_HIGH_1("cmph_cmd_sys_sel_pref_proc: updating rat_acq_order, acq_order type %d",
                     cmd_info_ptr->rat_acq_order_pref.type);
    rat_acq_pri_order
      = *cmph_get_acq_pri_order_per_sub(cmph_map_subs_to_ss(asubs_id));
  }
  else if(cmd_info_ptr->rat_acq_order_pref.type == CM_ACQ_ORDER_TYPE_RAT_PRI)
  {
    /* update rat_acq_pri_order with the command parameter passed */
    CM_MSG_HIGH_1("cmph_cmd_sys_sel_pref_proc: updating rat_acq_order, acq_order type %d",
                     cmd_info_ptr->rat_acq_order_pref.type);
    rat_acq_pri_order = cmd_info_ptr->rat_acq_order_pref.acq_order.rat_acq_pri_order;
  }
  else
  {
    /* Use existing rat_acq_order */
    rat_acq_pri_order
      = *cmph_get_acq_pri_order_per_sub(cmph_map_subs_to_ss(asubs_id));
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  **                    P R E - C O N D I T I O N S
  **- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the phone is in emergency callback mode
  ** come out of callback mode
  */

  /* in case of lte limited service do not remove ECBM priority queue object
  in fact treat it as call end and set the orig uptime by 4 seconds. */

  /* calculate LTE srv status to know if it is limited*/
  if( (ss_ptr->info.is_hybr_gw_operational) && (ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_LTE))
  {
    /* LTE on hybrid-2 stack */
    lte_srv_status = ss_ptr->info.gw_srv_status;
  }
  else if (ss_ptr->info.is_gw3_operational && ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_LTE)
  {
    lte_srv_status = ss_ptr->info.gw3_srv_status;
  }
  else if(ss_ptr->info.sys_mode == SYS_SYS_MODE_LTE)
  {
    lte_srv_status = ss_ptr->info.srv_status;
  }

  if(ph_ptr->ecbm_rat == SYS_SYS_MODE_LTE && lte_srv_status == SYS_SRV_STATUS_LIMITED)
  {
    cmph_exit_emergency_cb(ph_ptr, TRUE,ss,FALSE);
  }
  else
  {
    if( ss == CM_SS_HYBR_3 || ( (ss == CM_SS_HYBR_2) && cmph_is_msim() && !cmph_is_sxlte()))
    {
      cmph_exit_emergency_cb(ph_ptr, FALSE,ss,TRUE);
    }
    else
    {
      cmph_exit_emergency_cb(ph_ptr, FALSE,ss,FALSE);
    }
  }

  /* Due to change in network sel mode pref change, CM need to
  ** send response to registered client. Setting this flag to TRUE
  ** indiactes that client is still waiting for SRV_CHANGED event
  */
  if (((CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC)&&
        ((cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL) ||
         (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY) ))
                                      ||
       ((CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL)&&
         ((cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC) ||
          (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY)))
                                      ||
       ((CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL)&&
       (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL))
                                      ||
       ((CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC)&&
       (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC))
           )
  {
    if(ss == CM_SS_HYBR_2)
    {
      ph_ptr->hybr_2_stack_info.is_sys_sel_pref_rsp_pending = TRUE;
    }
    else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if(ss == CM_SS_HYBR_3)
    {
      ph_ptr->hybr_3_stack_info.is_sys_sel_pref_rsp_pending = TRUE;
    }
    else
    #endif
    {
      cmph_set_sys_sel_pref_rsp_pending();

      if (cmd_info_ptr->sys_sel_pref_req_id != CM_DEFAULT_VALUE)
      {
        cmph_set_req_id_pending();
      }
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* End all the data calls from the corresponding stacks based on the
  ** Mode changes.
  */
  srv_type = cmph_get_srv_type(CM_CALL_TYPE_PS_DATA);

  /* If srv_type is AUTOMATIC, convert it based on sys mode */
  if (srv_type == CM_SRV_TYPE_AUTOMATIC)
  {
    if( ss == CM_SS_HYBR_2 || ss == CM_SS_HYBR_3)
    {
      sys_mode = sd_misc_get_curr_acq_sys_mode();//TODO
    }
    else
    {
      sys_mode = sd_misc_get_curr_acq_sys_mode();
    }

    srv_type = cmph_map_sys_mode_to_srv_type (sys_mode);
  }

  /* Ending all existing Data Calls, if the mode preference
  ** has changed between incompatible RATs.
  */
  if( CMPH_SS_MODE_PREF(asubs_id, ph_ptr) != cmd_info_ptr->mode_pref )
  {
    boolean is_terminate_3gpp2_data = FALSE;
    supp_cm_mode_pref = cmph_get_supp_mode_pref(cmd_info_ptr->mode_pref,
                                                cmd_info_ptr->band_pref,
                                                cmd_info_ptr->lte_band_pref,
                                                cmd_info_ptr->tds_band_pref);

    CM_MSG_HIGH_5( "pref_chgd: mode_pref: %d -> %d, curr band_pref: %d supp cm mode_pref: %d, srv_type: %d",
                 CMPH_SS_MODE_PREF(asubs_id, ph_ptr), cmd_info_ptr->mode_pref,
                   CMPH_SS_BAND_PREF(asubs_id, ph_ptr),
                   supp_cm_mode_pref, srv_type );

    if (supp_cm_mode_pref == CM_MODE_PREF_NONE ||
        cmph_misc_intersect_mode_pref (srv_type, supp_cm_mode_pref)
                                                  == CM_MODE_PREF_NONE
       )
    {
      boolean is_pdp_abort_req_sent = FALSE;

      #ifdef CM_GW_SUPPORTED
      /*
      ** Check if any PS call exists and if so,Send PDP_ABORT_REQ so
      ** that all PDP calls are locally deactivated by NAS,before CM
      ** unreserves SM connection id.
      */
      if(srv_type != CM_SRV_TYPE_NONE)
      {
        /*
        ** new mode pref is incompatible with old one
        */
        cmwcall_send_pdp_abort_req(ss);
        is_pdp_abort_req_sent = TRUE;
      }
      else
      {
        sd_ss_mode_pref_e_type sd_mode_pref =
          cmph_map_cm_mode_pref_to_sd_mode_pref(supp_cm_mode_pref);

        CM_MSG_HIGH_1 ("supp sd mode_pref: %d",sd_mode_pref);
        if ((sd_mode_pref & SD_SS_MODE_PREF_TDS_GSM_WCDMA) == 0)
        {
        /*
        ** New mode pref doesn't have GWT modes,
        ** so we can end the GWT data call
        */
          cmwcall_send_pdp_abort_req(ss);
          is_pdp_abort_req_sent = TRUE;
        }
      }
      #endif

      /* Don't end LTE calls. */
      if (cmcall_is_no_call_in_lte_ps() && is_pdp_abort_req_sent)
      {
        CM_MSG_HIGH_2 ("Ending existing data calls due to mode change from %d to %d",
                   CMPH_SS_MODE_PREF(asubs_id, ph_ptr), cmd_info_ptr->mode_pref);

        is_terminate_3gpp2_data = TRUE;

        cmcall_end_each_call_with_type_per_sub(CM_CALL_TYPE_DATA,
                                     CM_CALL_END_CLIENT_END, cmd_info_ptr->cmd_subs);

        cmph_remove_orig_mode( ss, CM_ACT_TYPE_DATA_CALL, CM_ACT_PRIORITY_MAX );

        if(ss == CM_SS_MAIN)
        {
        cmph_remove_orig_mode( CM_SS_HDR ,
                             CM_ACT_TYPE_DATA_CALL,
                             CM_ACT_PRIORITY_MAX);
        }
      }
    }

    /* As the mode is changing, ending all the call that are in origination states
    ** This prevent the issue that during original, silent redial will unforce the
    ** preference in the call_object, which is no longer a correct preference after
    ** mode pref command.
    */
    cmcall_end_ps_call_in_hold_orig_or_sr(cmd_info_ptr->mode_pref,ss);

    /* If 3gpp2 calls have not been terminated already and there are HDR data calls in
    ** progress , check if the hybrid preferences are being toggled. If so, terminate the HDR data
    ** calls. ( hybrid pref can be toggled either by explicitly changing the hybrid pref  or
    ** by changing the mode pref to HDR only)
    */
     if ( is_terminate_3gpp2_data == FALSE &&
          ( cmcall_hybr_pref_was_toggled_for_origination(cmd_info_ptr->hybr_pref, asubs_id) ||
            CMPH_SS_MODE_PREF(asubs_id, ph_ptr) == CM_MODE_PREF_HDR_ONLY ||
            cmd_info_ptr->mode_pref == CM_MODE_PREF_HDR_ONLY
          ) &&
          (cmcall_is_hdr_call() != CM_CALL_ID_INVALID ) &&
          ss == CM_SS_MAIN
        )
    {

      CM_MSG_HIGH_3 ("Ending existing HDR data calls due to hybr toggle %d %d %d",
                 CMPH_SS_MODE_PREF(asubs_id, ph_ptr),
                 CMPH_SS_HYBR_PREF(asubs_id, ph_ptr),
                 cmd_info_ptr->hybr_pref);

      cmcall_end_each_call_with_type_per_sub(CM_CALL_TYPE_DATA,
                                   CM_CALL_END_CLIENT_END, cmd_info_ptr->cmd_subs);

      cmph_remove_orig_mode( ss, CM_ACT_TYPE_DATA_CALL, CM_ACT_PRIORITY_MAX );

      cmph_remove_orig_mode( CM_SS_HDR ,
                           CM_ACT_TYPE_DATA_CALL,
                           CM_ACT_PRIORITY_MAX);

     }

  } // if mode pref has toggled


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  **                    P R O C E S S - C M D
  **- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Enable HDR acquisitions before sending user pref sys change.
  */

  /* Since we are sending FALSE, we just update the cmpref
  ** mask and don't send the pref sys chgd down
  */
  cmmsimc_proc_enable_hybr_hdr( FALSE );

  ph_orig_top_ptr = cmtask_orig_para_get_top( ss == CM_SS_MAX ? CM_SS_MAIN : ss );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Decide if pref change should trigger fresh system selection. If so, then
     pref reason should indicate that. Currently this applicable to PLMN+RAT
     and auto to auto request. */
  if(network_sel_mode_pref_changed || cmph_is_user_resel_needed(cmd_info_ptr))
  {
    reason = SD_SS_PREF_REAS_USER_RESEL;
    /** Remove all voice, emergency and CS_DATA call objects with priority END , 
    ** It is done to make sure that ending calls would not prevent new user preferences being forced
    ** In manual selection , pre_reas=USER_RESEL is required.
    ** pref_reas is not updated to USER_RESEL when we force preferences after unforcing END prefs.
    */
    cmph_remove_orig_mode( ss, CM_ACT_TYPE_VOICE_CALL, CM_ACT_PRIORITY_END );
    cmph_remove_orig_mode( ss, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_END );
    #if defined (FEATURE_3GPP_CSFB)
      cmph_remove_orig_mode( ss, CM_ACT_TYPE_CS_DATA_CALL, CM_ACT_PRIORITY_END  );
    #endif
  }
  else if( ph_orig_top_ptr != NULL
         && ph_orig_top_ptr->orig->act_priority == CM_ACT_PRIORITY_END
         && prefered_mode != CM_MODE_PREF_GSM_ONLY
         && ph_orig_top_ptr->orig->orig_mode_pref == CM_MODE_PREF_GSM_ONLY)
  {
    cmph_remove_orig_mode( ss, CM_ACT_TYPE_VOICE_CALL, CM_ACT_PRIORITY_END );
    cmph_remove_orig_mode( ss, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_END );
    #if defined (FEATURE_3GPP_CSFB)
    cmph_remove_orig_mode( ss, CM_ACT_TYPE_CS_DATA_CALL, CM_ACT_PRIORITY_END  );
    #endif
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Gather client requested srv domain preference.
  ** Preferred srv domain is initialized to client requested srv dom
  */
  if (cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_NO_CHANGE)
  {
    srv_domain_tobe_forced = CMPH_SS_SRV_DOMAIN_PREF( asubs_id, ph_ptr );
  }
  else
  {
    srv_domain_tobe_forced = cmd_info_ptr->srv_domain_pref;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


#if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)

  /* determine the service domain pref to be sent to REG */

  switch (srv_domain_tobe_forced)
  {
  case CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH:
    {
      if(!cmph_is_subs_feature_mode_1x_sxlte(asubs_id)) 
    {  


       if( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_ONLY ||
          CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS )
       {
         srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_CS_PS;
       }
       else if ( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
                CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_NONE )
       {
         srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_PS_ONLY;
       }

       CM_MSG_HIGH_4("asubs_id %d, srv_domain_tobe_forced %d, rat_disabled_mask 0x%x, prefered_mode %d",
         asubs_id,
         srv_domain_tobe_forced, 
         ph_ptr->rat_disabled_mask[asubs_id],
         prefered_mode);

       cmph_activate_ps_service_req_timer(ss);

       is_force_top_pref                = TRUE;
     break;
      }
  }
    case CM_SRV_DOMAIN_PREF_PS_ATTACH:
    {

      if( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_ONLY ||
          CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS )
      {
        srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_CS_PS;
      }
      else if ( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
                CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_NONE )
      {
        srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_PS_ONLY;
      }

      ph_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_NO_VALUE;

      /* If LTE was disable before enable it now */
      #ifdef FEATURE_CM_LTE
      if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs))
      {
        /* Add mode_pref SD_SS_MODE_PREF_GWL_LTE only if the current mode_pref has
        ** both SD_SS_MODE_PREF_GSM and SD_SS_MODE_PREF_WCDMA for the correct SS
        */
        if ((cmph_is_msim()&&(ss==CM_SS_HYBR_2)&&
           (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(
              ph_ptr->hybr_2_stack_info.pref_info.mode_pref),SD_SS_MODE_PREF_GSM )  &&
                  sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(
                    ph_ptr->hybr_2_stack_info.pref_info.mode_pref),SD_SS_MODE_PREF_WCDMA )))||
           ((ss == CM_SS_MAIN) &&
            (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                                     SD_SS_MODE_PREF_GSM )  &&
                sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                                     SD_SS_MODE_PREF_WCDMA ))) 
          #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
          ||
            ((ss == CM_SS_HYBR_3) &&
            (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
                                     SD_SS_MODE_PREF_GSM )  &&
            sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
                                 SD_SS_MODE_PREF_WCDMA )))
          #endif

        )
        {
          prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_GWL_LTE);
        }
        else
        {
          prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_LTE);
        }
        cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
      }
      #endif /*FEATURE_CM_LTE*/

      #ifdef FEATURE_HDR
      /* If HDR was disabled due to non default data sub, enable it here */
      if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs))
      {
         prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_HDR);
         cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs);
      }
      #endif

      CM_MSG_HIGH_2("prefered_mode %d, srv_domain_tobe_forced %d ",prefered_mode,srv_domain_tobe_forced);
      cmph_activate_ps_service_req_timer(ss);

      is_force_top_pref                = TRUE;
      }
      break;

    /*  Perfrom PS detach on demand. No change in domain pref.
    **  This value of service domain preference is not saved in the NV*/
    case CM_SRV_DOMAIN_PREF_PS_LOCAL_DETACH:

    ph_ptr->is_ps_detach_required = TRUE;
      ph_ptr->is_user_ps_detach_required = TRUE;

    srv_domain_tobe_forced = CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr);
    ph_ptr->main_stack_info.pref_info.pref_term = cmd_info_ptr->pref_term;
    is_force_top_pref                = TRUE;

    CM_MSG_HIGH_2("PS_LOCAL_DETACH: is_ps_detach_required = %d, srv_domain_pref = %d",
                  ph_ptr->is_ps_detach_required,
         CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) );

    cmph_detach_call_end(ss);

    break;

    case CM_SRV_DOMAIN_PREF_PS_DETACH:

      #ifdef FEATURE_CM_LTE
      if (cmph_is_msim() && (ss == CM_SS_HYBR_2) && !cmph_is_sxlte())
      {
        supp_mode_pref = sd_ss_get_supp_mode_pref(
              cmph_map_cm_mode_pref_to_sd_mode_pref(
                ph_ptr->hybr_2_stack_info.pref_info.mode_pref),
              cmph_map_cm_band_pref_to_sd_band_pref(
                ph_ptr->hybr_2_stack_info.pref_info.band_pref),
              ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
              cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref)
              );
      }
      
      #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
      else if (cmph_is_msim() && (ss == CM_SS_HYBR_3))
      {
        supp_mode_pref = sd_ss_get_supp_mode_pref(
              cmph_map_cm_mode_pref_to_sd_mode_pref(
                ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
              cmph_map_cm_band_pref_to_sd_band_pref(
                ph_ptr->hybr_3_stack_info.pref_info.band_pref),
              ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref,
              cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref)
              );
      }
      #endif
      else
      {
          supp_mode_pref = sd_ss_get_supp_mode_pref(
                  cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                  cmph_map_cm_band_pref_to_sd_band_pref(ph_ptr->main_stack_info.pref_info.band_pref),
                  ph_ptr->main_stack_info.pref_info.lte_band_pref,
                  cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(ph_ptr->main_stack_info.pref_info.tds_band_pref)
                  );
      }

      supp_mode_pref = SD_GET_COMMON_MODE ( supp_mode_pref, SD_SS_MODE_PREF_LTE );

     
      /* Disable LTE as PS domain is being removed */
      if (supp_mode_pref != SD_SS_MODE_PREF_NONE)
      {
        prefered_mode = cm_remove_mode_pref_components(prefered_mode,1,
                                                          SD_SS_MODE_PREF_GWL_LTE);
        cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
        ph_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_USER;
      }

      #ifdef FEATURE_HDR
      /* For multisim, add HDR to rat disabled mask as no PS domain for sub1 */
      if(SD_MODE_CONTAIN(cmph_map_cm_mode_pref_to_sd_mode_pref(prefered_mode),SD_SS_MODE_PREF_HDR)
        && cmph_is_msim()
      )
      {
        cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs);
      }
      /* If rat disable mask contains HDR, remove it from mode pref */
      if (cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs) &&
         asubs_id == SYS_MODEM_AS_ID_1)
      {
        prefered_mode = cm_remove_mode_pref_components(prefered_mode,1,
                                                          SD_SS_MODE_PREF_HDR);
        CM_MSG_HIGH_1("NO PS_DOMAIN AND MSIM => remove HDR, preferred_mode=%d",
                           prefered_mode);
      }
      #endif /*FEATURE_HDR*/
      #endif

      if((CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS ) ||
         (CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ))
      {
        ph_ptr->is_ps_detach_required = TRUE;
        ph_ptr->is_user_ps_detach_required = TRUE;
      }
      if( ( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_ONLY ) ||
          ( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS ) )
      {
        srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_CS_ONLY;
      }
      else if ( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
                CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_NONE )
      {
        srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_NONE;
      }

      is_force_top_pref                = TRUE;

    cmph_detach_call_end(ss);

      break;

    case CM_SRV_DOMAIN_PREF_CS_PS:
        /*lint -fallthrough */
    case CM_SRV_DOMAIN_PREF_PS_ONLY:
        /* CM needs to wait to receive the PS_SIG_DOWN event after PS Service is acquired.
        ** When we change the system selection prefernece to acquire a PS service, we need
        ** to start the PS_SIG_DOWN timer.
        **
        ** ps_service_req_sent flag is used to decide if we need to start the PS_SIG_DOWN
        ** timer after PS service is acquired.
        */
        /* Set PS ervice request flag to true only whethen there is change in GW capabilities */
        if (TRUE == cmph_is_change_in_gwl_cap (ph_cmd_ptr))
        {

          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
          if(ss == CM_SS_HYBR_3)
          {
            ph_ptr->hybr_3_stack_info.is_ps_srv_req_sent = TRUE;
          }
          else
          #endif
          if(ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
          {
            ph_ptr->hybr_2_stack_info.is_ps_srv_req_sent = TRUE;
          }
          else
          {
            ph_ptr->is_ps_srv_req_sent = TRUE;
          }
        }


        #ifdef FEATURE_CM_LTE
        {
          if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs))
          {
            /* Add mode_pref SD_SS_MODE_PREF_GWL_LTE only if the current mode_pref has
            ** both SD_SS_MODE_PREF_GSM and SD_SS_MODE_PREF_WCDMA
            */
            if (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(CMPH_SS_MODE_PREF(cmd_info_ptr->cmd_subs,ph_ptr)),
                                     SD_SS_MODE_PREF_GSM )  &&
                sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(CMPH_SS_MODE_PREF(cmd_info_ptr->cmd_subs,ph_ptr)),
                                     SD_SS_MODE_PREF_WCDMA ))
            {
              prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_GWL_LTE);
            }
            else
            {
              prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_LTE);
            }
            cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
            ph_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_NO_VALUE;
          }

          /* If HDR was disabled due to non default data sub, enable it here */
          if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs))
          {
            prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_HDR);
            cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs);
          }
        }
      #endif  /* defined(FEATURE_CM_LTE) */
      break;

    case CM_SRV_DOMAIN_PREF_CS_ONLY:

      /* When MMODE removes PS from srv domain in auto mode ,
      ** NAS will always perfrom PS detach . 
      ** Hence there is no harm in CM sending PS detach . 
      ** BUt NAS will not PS detach when MMODE removes PS domain in LTD mode . 
      ** Although NAS expects PS Detach to be sent by CM in LTD mode . 
      ** Hence below change helps to take care of such scenario . 
      */
      if((CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS ) ||
        (CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ))
      {
        ph_ptr->is_ps_detach_required = TRUE;
        ph_ptr->is_user_ps_detach_required = TRUE;
      }
      #ifdef FEATURE_CM_LTE
      if(SD_MODE_CONTAIN(cmph_map_cm_mode_pref_to_sd_mode_pref(prefered_mode),SD_SS_MODE_PREF_LTE))
      {
        prefered_mode = cm_remove_mode_pref_components(prefered_mode,1,
                                                          SD_SS_MODE_PREF_GWL_LTE);
        ph_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_USER;
        cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
      }

      #ifdef FEATURE_HDR
      /* For multisim, add HDR to rat disabled mask as no PS domain for sub1 */
      if(SD_MODE_CONTAIN(cmph_map_cm_mode_pref_to_sd_mode_pref(prefered_mode),SD_SS_MODE_PREF_HDR)
        && cmph_is_msim()
      )
      {
        cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs);
      }
      /* If rat disable mask contains HDR, remove it from mode pref */
      if (cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs) &&
         asubs_id == SYS_MODEM_AS_ID_1)
      {
        prefered_mode = cm_remove_mode_pref_components(prefered_mode,1,
                                                          SD_SS_MODE_PREF_HDR);
        CM_MSG_HIGH_1("NO PS_DOMAIN AND MSIM => remove HDR, preferred_mode=%d",
                           prefered_mode);
      }
      #endif

      #endif /* defined(FEATURE_CM_LTE) */
      break;

    default:
      CM_MSG_HIGH_1 ("Directly using srv_dom pref given by client %d",
                                   srv_domain_tobe_forced);

      break;

  } /* switch (client_req_srv_domain_pref) */

  /* Update the PS detach flag */
  ph_ptr->is_srv_domain_ps_detach_forced = is_force_top_pref;

  /*Since 'IMS on nonDDS feature' is applicable for SUB1 as of now, checking for MAIN only*/
  if((cmpm_ptr()->change_in_ims_for_nondds) && (ss == CM_SS_MAIN))
  {
    is_force_top_pref = TRUE;
  }

  #ifdef FEATURE_CM_LTE
  cmd_info_ptr->mode_pref = prefered_mode;
#ifdef FEATURE_MMODE_TRIPLE_SIM
  CM_MSG_HIGH_6("prefered_mode = %d is_user_ps_detach_required %d, change_in_ims_for_nondds %d,
                       rat_disabled_mask as_id_0 0x%x, as_id_1 0x%x, as_id_2 0x%x",\
    prefered_mode,
                       ph_ptr->is_user_ps_detach_required, cmpm_ptr()->change_in_ims_for_nondds,\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_1],\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_2],\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_3]);
#else

  CM_MSG_HIGH_5("pref_mode = %d, is_user_ps_detach_req %d, change_in_ims_for_nondds %d,rat_disabled_mask as_id_0 0x%x, as_id_1 0x%x",\
    prefered_mode,
    ph_ptr->is_user_ps_detach_required, cmpm_ptr()->change_in_ims_for_nondds,
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_1],\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_2]);
#endif
  #endif /* defined(FEATURE_CM_LTE) */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Triggers a HPLMN search request
  */
  if (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_HPLMN_SRCH)
  {
    cmregprx_send_hplmn_srch_req (cmph_map_cm_ss_type_to_sd_ss_type(ss));

    /* HPLMN_SRCH request is just used a trigger and is not supposed
    ** to change any phone preferences. So reset to NONE
    */
    cmd_info_ptr->network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_NONE;
    cmd_info_ptr->pref_term             = CM_PREF_TERM_NONE;

    return;
  }

  #endif /* FEATURE_GSM || FEATURE_WCDMA */


  // For Internal SYS SEL PREF commands, don't send Online to MMOC.
  if (( cmph_ptr()->oprt_mode_send_time != CMPH_MAX_UPTIME ) && (ph_cmd_ptr->client_id != CM_CLIENT_ID_ANONYMOUS))
  {
    CM_MSG_HIGH_3("oprt_mode_online: sys_sel_pref_proc(), num_subs_avail %d, oprt_mode_send_time %d, client_id %d",
                  cmutil_num_of_subs_avail(),
                  cmph_ptr()->oprt_mode_send_time,
                  ph_cmd_ptr->client_id);
    cmph_send_oprt_mode_online_to_mmoc();
  }


  #ifdef FEATURE_LTE
  {
    /*lint -e655 */
    boolean new_mode_lte = ((int)(sd_ss_get_supp_mode_pref(
                  cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->mode_pref),
                  cmph_map_cm_band_pref_to_sd_band_pref(cmd_info_ptr->band_pref),
                  cmd_info_ptr->lte_band_pref,
                  cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(cmd_info_ptr->tds_band_pref))
                  & SD_SS_MODE_PREF_LTE) != 0);

    boolean old_mode_lte = FALSE;

  /* Calculate overall supp mode pref for correct comparison (Automatic = GWL if only GWL bands are selected
    */
    sd_ss_mode_pref_e_type supp_preferred_mode = sd_ss_get_supp_mode_pref(
            cmph_map_cm_mode_pref_to_sd_mode_pref(prefered_mode),
            cmph_map_cm_band_pref_to_sd_band_pref(cmd_info_ptr->band_pref),
            cmd_info_ptr->lte_band_pref,
            cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(cmd_info_ptr->tds_band_pref));

    sd_ss_mode_pref_e_type supp_ph_mode_pref = SD_SS_MODE_PREF_NONE;

    if ((cmph_is_msim() && (ss == CM_SS_HYBR_2)) && !cmph_is_sxlte())
    {
      old_mode_lte = ((int)(sd_ss_get_supp_mode_pref(
                cmph_map_cm_mode_pref_to_sd_mode_pref(
                  ph_ptr->hybr_2_stack_info.pref_info.mode_pref),
                cmph_map_cm_band_pref_to_sd_band_pref(
                  ph_ptr->hybr_2_stack_info.pref_info.band_pref),
                ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                  ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref))
                & SD_SS_MODE_PREF_LTE) != 0);

      supp_ph_mode_pref = sd_ss_get_supp_mode_pref(
                  cmph_map_cm_mode_pref_to_sd_mode_pref(
                    ph_ptr->hybr_2_stack_info.pref_info.mode_pref),
                  cmph_map_cm_band_pref_to_sd_band_pref(
                    ph_ptr->hybr_2_stack_info.pref_info.band_pref),
                  ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
                  cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                    ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref));
    }
    #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
    else if (cmph_is_msim() && ss == CM_SS_HYBR_3)
    {
      old_mode_lte = ((int)(sd_ss_get_supp_mode_pref(
          cmph_map_cm_mode_pref_to_sd_mode_pref(
            ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
          cmph_map_cm_band_pref_to_sd_band_pref(
            ph_ptr->hybr_3_stack_info.pref_info.band_pref),
          ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref,
          cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
            ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref))
          & SD_SS_MODE_PREF_LTE) != 0);

      supp_ph_mode_pref = sd_ss_get_supp_mode_pref(
            cmph_map_cm_mode_pref_to_sd_mode_pref(
            ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
            cmph_map_cm_band_pref_to_sd_band_pref(
            ph_ptr->hybr_3_stack_info.pref_info.band_pref),
            ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
            cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
            ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref));
    }
    #endif
    else
    {
      old_mode_lte = ((int)(sd_ss_get_supp_mode_pref(
                cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                cmph_map_cm_band_pref_to_sd_band_pref(ph_ptr->main_stack_info.pref_info.band_pref),
                ph_ptr->main_stack_info.pref_info.lte_band_pref,
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(ph_ptr->main_stack_info.pref_info.tds_band_pref))
                & SD_SS_MODE_PREF_LTE) != 0);

      supp_ph_mode_pref = sd_ss_get_supp_mode_pref(
                  cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                  cmph_map_cm_band_pref_to_sd_band_pref(ph_ptr->main_stack_info.pref_info.band_pref),
                  ph_ptr->main_stack_info.pref_info.lte_band_pref,
                  cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(ph_ptr->main_stack_info.pref_info.tds_band_pref));
    }

    /*lint +e655 */


    /* Evaluate ph_ptr->is_ps_detach_required */
    {
      if (ss == CM_SS_HYBR_2)
      {
        /* we might have already computed ps-detach flag
        ** while we are processing srv_domain_tobe_forced .
        ** Hence make sure wont reset , if it already set .
        */
        ph_ptr->is_ps_detach_required = 
        cmph_cmd_evaluate_is_ps_detach_required(ph_ptr->hybr_2_stack_info.asubs_id,
                                            ph_ptr->hybr_2_stack_info.pref_info.mode_pref,
                                            ph_ptr->hybr_2_stack_info.pref_info.band_pref,
                                            ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
                                            ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref,
                                            cmd_info_ptr->mode_pref,
                                            cmd_info_ptr->band_pref,
                                            cmd_info_ptr->lte_band_pref,
                                            cmd_info_ptr->tds_band_pref);
      }
      #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
      else if (ss == CM_SS_HYBR_3)
      {
      ph_ptr->is_ps_detach_required = 
      cmph_cmd_evaluate_is_ps_detach_required(ph_ptr->hybr_3_stack_info.asubs_id,
                      ph_ptr->hybr_3_stack_info.pref_info.mode_pref,
                                            ph_ptr->hybr_3_stack_info.pref_info.band_pref,
                                            ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref,
                                            ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref,
                                            cmd_info_ptr->mode_pref,
                                            cmd_info_ptr->band_pref,
                                            cmd_info_ptr->lte_band_pref,
											cmd_info_ptr->tds_band_pref);
      }
      #endif
      else
      {
      ph_ptr->is_ps_detach_required = 
      cmph_cmd_evaluate_is_ps_detach_required(ph_ptr->main_stack_info.asubs_id,
                                            ph_ptr->main_stack_info.pref_info.mode_pref,
                                            ph_ptr->main_stack_info.pref_info.band_pref,
                                            ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                            ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                            cmd_info_ptr->mode_pref,
                                            cmd_info_ptr->band_pref,
                                            cmd_info_ptr->lte_band_pref,
                                          cmd_info_ptr->tds_band_pref);
      }

      #ifdef FEATURE_MMODE_DUAL_SIM
      /* Set is_ps_detach_required for DSDS L+G DDS case */
      if (ph_ptr->dds_status == CMPH_DDS_STATUS_PS_DETACH_PENDING)
      {
      ph_ptr->is_ps_detach_required = TRUE;

        /* dds_status is updated in cmpref2 after the PS detach is sent. */
      }
      #endif

    }

  #ifdef FEATURE_LTE_TO_HDR_OH
  /* Deactivate HDR from tunnel mode incase HDR removed from mode pref */
  if( (supp_ph_mode_pref & SD_SS_MODE_PREF_HDR) &&
     !(supp_preferred_mode & SD_SS_MODE_PREF_HDR)
    )
  {
    cmsds_deactivate_hdr_tunnel_req();
  }
  /* if previous mode pref has LTE, but NO HDR and new mode pref has HDR
     we might want to activate HDR in tunnel mode after service confirmation
     corresponding to this client/user sys sel pref cmd  */

  if( !(supp_ph_mode_pref & SD_SS_MODE_PREF_HDR) &&
        old_mode_lte &&
       (supp_preferred_mode & SD_SS_MODE_PREF_HDR) &&
        new_mode_lte
    )
  {
    CM_MSG_HIGH_0("Setting is_act_hdr_on_srv_cnf to true ");
    cmsds_ptr()->is_act_hdr_on_srv_cnf = TRUE;
  }
  #endif

  } /* Code block for PS detach logic implementation & HDRtunnel deact and 1xcsfb deact*/

  #endif

  /* if oprt mode is not ONLINE then PS detach should not mark, otherwise this will lead to
     unnecessary detach during ONLINE.
  */
  if(ph_ptr->is_ps_detach_required &&  ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE)
  {
    CM_MSG_HIGH_0("NOT in ONLINE, Marking PS detach required as FALSE");
    ph_ptr->is_ps_detach_required = FALSE;
    ph_ptr->is_user_ps_detach_required = FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if(ss != CM_SS_HYBR_2
     #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
     && ss != CM_SS_HYBR_3
     #endif
     )
  {
    /* If hybrid preferences are toggled, then wipe out the DO Queue
    */
    last_pref_ptr = cmph_get_last_pref_sent(CM_SS_MAIN);

    CM_ASSERT( last_pref_ptr != NULL );

    if( last_pref_ptr->act_priority == CM_ACT_PRIORITY_PH )
    {
      /* Last pref ptr is valid
      */
      if( last_pref_ptr->orig_hybr_pref != cmd_info_ptr->hybr_pref )
      {
        cmph_orig_mode_reset_on_ss( ph_ptr, CM_SS_HYBR_1, FALSE, cmd_info_ptr->sys_sel_pref_req_id);

        /* Wipe out hybr 2 queue if hybr prefs have toggled
        */
        if( last_pref_ptr->orig_hybr_pref == CM_HYBR_PREF_CDMA__LTE__HDR)
        {
          cmph_orig_mode_reset_on_ss( ph_ptr, CM_SS_HYBR_2, FALSE, cmd_info_ptr->sys_sel_pref_req_id );
        }
      }
      else
      {
        cm_orig_q_s_type *ph_orig_top_ptr =
                                  cmtask_orig_para_get_top( CM_SS_MAIN );
        CM_ASSERT( ph_orig_top_ptr != NULL );

        if(ph_orig_top_ptr != NULL)
        {
          ph_orig_top_ptr->orig->sys_sel_pref_req_id = cmd_info_ptr->sys_sel_pref_req_id;
        }
      }
    }
    else
    {
      /* Get the top ptr from MAIN Q and check if the preferences
      ** are toggled
      */
      cm_orig_q_s_type *ph_orig_top_ptr =
                                  cmtask_orig_para_get_top( CM_SS_MAIN );

      CM_ASSERT( ph_orig_top_ptr != NULL );

      /*lint -save -e774 Boolean within 'if' always evaluates to True
      **                 Not true, If asserts are turned off we need to
      **                 check for NULL pointer
      */

      if( ( ph_orig_top_ptr != NULL ) &&
          ( ph_orig_top_ptr->orig->orig_hybr_pref != cmd_info_ptr->hybr_pref ))
      {
        cmph_orig_mode_reset_on_ss( ph_ptr, CM_SS_HYBR_1, FALSE, cmd_info_ptr->sys_sel_pref_req_id );
      }
      /*lint -restore */
    }
  }

  CM_MSG_HIGH_2 ("pref_sys_chg in common sect pref_srv_domain = %d on ss %d",
                srv_domain_tobe_forced,ss);

  if (cmph_is_msim())
  {
    /* Allocate buffer only if multi-sim
    */
    hybr_gw_pref_ptr = cm_pref_ptr();
    memscpy(hybr_gw_pref_ptr, sizeof(cm_pref_s_type),
                  &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));


    /* Force the preferences based on the ss on which this command was issued
    ** ss = MAIN, new_prefereces will be sent to main stack.
    ** ss = HYBR_2, new preferences will be set to hybrid2 stack.
    ** ss = MAX, new prefereces are sent as ph preferences.
    */
    if(ss == CM_SS_HYBR_2)
    {
      hybr_gw_pref_ptr->pref_term              = cmd_info_ptr->pref_term;
      hybr_gw_pref_ptr->mode_pref              = prefered_mode;
      hybr_gw_pref_ptr->band_pref              = cmd_info_ptr->band_pref;
      hybr_gw_pref_ptr->tds_band_pref          = cmd_info_ptr->tds_band_pref;
      hybr_gw_pref_ptr->lte_band_pref          = cmd_info_ptr->lte_band_pref;
      hybr_gw_pref_ptr->prl_pref               = cmd_info_ptr->prl_pref;
      hybr_gw_pref_ptr->roam_pref              = cmd_info_ptr->roam_pref;
      hybr_gw_pref_ptr->plmn                   = cmd_info_ptr->plmn;
      hybr_gw_pref_ptr->srv_domain_pref        = srv_domain_tobe_forced;
      hybr_gw_pref_ptr->acq_order_pref         = cmd_info_ptr->acq_order_pref;
      hybr_gw_pref_ptr->network_sel_mode_pref  = cmd_info_ptr->network_sel_mode_pref;
      hybr_gw_pref_ptr->hybr_pref              = cmd_info_ptr->hybr_pref;
    }
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    /* Force the preferences based on the ss on which this command was issued
    ** ss = MAIN, new_prefereces will be sent to main stack.
    ** ss = HYBR_2, new preferences will be set to hybrid2 stack
    ** ss = HYBR_3, new preferences will be set to hybrid3 stack.
    ** ss = MAX, new prefereces are sent as ph preferences.
    */
    if(ss == CM_SS_HYBR_3)
    {
      
      hybr_3_gw_pref_ptr = cm_pref_ptr();
      memscpy(hybr_3_gw_pref_ptr, sizeof(cm_pref_s_type),
                    &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
      
      hybr_3_gw_pref_ptr->pref_term              = cmd_info_ptr->pref_term;
      hybr_3_gw_pref_ptr->mode_pref              = prefered_mode;
      hybr_3_gw_pref_ptr->band_pref              = cmd_info_ptr->band_pref;
      hybr_3_gw_pref_ptr->tds_band_pref          = cmd_info_ptr->tds_band_pref;
      hybr_3_gw_pref_ptr->lte_band_pref          = cmd_info_ptr->lte_band_pref;
      hybr_3_gw_pref_ptr->prl_pref               = cmd_info_ptr->prl_pref;
      hybr_3_gw_pref_ptr->roam_pref              = cmd_info_ptr->roam_pref;
      hybr_3_gw_pref_ptr->plmn                   = cmd_info_ptr->plmn;
      hybr_3_gw_pref_ptr->srv_domain_pref        = srv_domain_tobe_forced;
      hybr_3_gw_pref_ptr->acq_order_pref         = cmd_info_ptr->acq_order_pref;
      hybr_3_gw_pref_ptr->network_sel_mode_pref  = cmd_info_ptr->network_sel_mode_pref;
      hybr_3_gw_pref_ptr->hybr_pref              = cmd_info_ptr->hybr_pref;
    }
  #endif /* FEATURE_MMODE_TRIPLE_SIM */
  }

  #if defined (CM_GW_SUPPORTED) || defined (FEATURE_LTE)
  if((cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC ||
     cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL) &&
    (cmd_info_ptr->network_sel_mode_pref != ph_ptr->main_stack_info.pref_info.network_sel_mode_pref))
  {
    sd_ss_orig_mode_e_type      orig_mode;

    if (cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
    {
      orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
    }
    else
    {
      orig_mode =SD_SS_ORIG_MODE_NORMAL;
    }

    /* Update data call orig mode*/
    (void)cmtask_orig_para_change_orig_mode( CM_SS_MAIN,
                                  CM_ACT_TYPE_DATA_CALL,
                                  orig_mode,
                                  TRUE );
    #if defined FEATURE_MMODE_DUAL_SIM || defined FEATURE_MMODE_SC_SVLTE
    (void)cmtask_orig_para_change_orig_mode( CM_SS_HYBR_2,
                                  CM_ACT_TYPE_DATA_CALL,
                                  orig_mode,
                                  TRUE );
    #endif
    #ifdef FEATURE_MMODE_TRIPLE_SIM
        (void)cmtask_orig_para_change_orig_mode( CM_SS_HYBR_3,
                                  CM_ACT_TYPE_DATA_CALL,
                                  orig_mode,
                                  TRUE );

    #endif
  }
  #endif /*(CM_GW_SUPPORTED) || (FEATURE_LTE) */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Call into Policy manager and retrieve new policy if needed.
  ** Use the same preferences as used in the force_pref_on_fly() below.
  */
  pmprx_pref_ptr = (cm_sys_sel_pref_params_s_type*)
                         cm_mem_malloc(sizeof(cm_sys_sel_pref_params_s_type));
  pmprx_pref_ptr->mode_pref        = prefered_mode;
  pmprx_pref_ptr->term_pref        = ph_ptr->main_stack_info.pref_info.pref_term;
  pmprx_pref_ptr->pref_duration    = cmd_info_ptr->pref_duration;
  pmprx_pref_ptr->band_pref        = cmd_info_ptr->band_pref;
  pmprx_pref_ptr->lte_band_pref    = cmd_info_ptr->lte_band_pref;
  pmprx_pref_ptr->tds_band_pref    = cmd_info_ptr->tds_band_pref;
  pmprx_pref_ptr->prl_pref         = cmd_info_ptr->prl_pref;
  pmprx_pref_ptr->roam_pref        = cmd_info_ptr->roam_pref;
  pmprx_pref_ptr->hybr_pref        = cmd_info_ptr->hybr_pref;
  pmprx_pref_ptr->srv_domain_pref  = srv_domain_tobe_forced;
  pmprx_pref_ptr->network_sel_mode_pref = cmd_info_ptr->network_sel_mode_pref;
  pmprx_pref_ptr->volte_enable_state = CM_VOLTE_NO_CHANGE;

   /* this is to avoid sending null PLMN values to PM when network sel mode is set to no_change from manual */
  if((cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL) && ((sys_plmn_id_is_null(cmd_info_ptr->plmn))|| (sys_plmn_id_is_undefined(cmd_info_ptr->plmn))))
  {
    pmprx_pref_ptr->plmn_ptr       = &( ph_ptr->main_stack_info.pref_info.plmn );
  }
  else
  {
  pmprx_pref_ptr->plmn_ptr         = &(cmd_info_ptr->plmn);
  }

  //pmprx_pref_ptr->rat_acq_order_pref_ptr = &rat_acq_pri_order;
  pmprx_pref_ptr->csg_id           = cmd_info_ptr->csg_id;
  pmprx_pref_ptr->csg_rat          = cmd_info_ptr->csg_rat;
  pmprx_pref_ptr->ue_usage_setting = CMPH_SS_UE_USAGE_SETTING(asubs_id, ph_ptr);

  cmpmprx_sys_sel_pref_policy_update( cmd_info_ptr->cmd_subs,
                                      pmprx_pref_ptr, ph_cmd_ptr);

  cm_mem_free(pmprx_pref_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

 #if defined(FEATURE_MMODE_SC_SGLTE) || defined(FEATURE_MMODE_SXLTE_G)
  if (cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) &&
      cmpm_ptr()->current_policy[SYS_MODEM_AS_ID_1].ue_operation_mode == SYS_UE_MODE_SGLTE_HOME &&
      cmd_info_ptr->csg_rat == SYS_RAT_GSM_RADIO_ACCESS)
  {
    cmd_info_ptr->csg_id  = SYS_CSG_ID_INVALID;
    cmd_info_ptr->csg_rat = SYS_RAT_NONE;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  if(cmtask_is_there_a_high_priority_activity(ss, CM_ACT_TYPE_DATA_CALL))
  {
    ph_ptr->is_pref_change_pending[asubs_id] = TRUE;
    CM_MSG_HIGH_0("Set is_pref_change_pending to TRUE");
  }

  (void)cmph_force_pref_on_the_fly2(
                                     ((ss == CM_SS_HYBR_2 || ss == CM_SS_HYBR_3)?ss:CM_SS_MAX),
                                     ph_ptr,
                                     reason,
                                     CM_ACT_TYPE_PH_OBJ,
                                     ph_ptr->main_stack_info.pref_info.pref_term,
                                     prefered_mode,
                                     cmd_info_ptr->band_pref,
                                     cmd_info_ptr->lte_band_pref,
                                     cmd_info_ptr->tds_band_pref,
                                     cmd_info_ptr->prl_pref,
                                     cmd_info_ptr->roam_pref,
                                     cmd_info_ptr->hybr_pref,
                                     cmd_info_ptr->plmn,
                                     srv_domain_tobe_forced,
                                     cmd_info_ptr->acq_order_pref,
                                     cmd_info_ptr->network_sel_mode_pref,
                                     hybr_gw_pref_ptr,
                                     #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
                                     hybr_3_gw_pref_ptr,
                                     #endif
                                     CM_OTASP_ACT_CODE_NONE,
                                     (cm_act_id_type)ph_ptr,
                                     CM_ACT_UPDATE_REAS_USER,
                                     is_force_top_pref,
                                     &rat_acq_pri_order,
                                     cmd_info_ptr->sys_sel_pref_req_id,
                                     cmd_info_ptr->csg_id,
                                     cmd_info_ptr->csg_rat);

  cmpmprx_sys_sel_pref_proc( cmd_info_ptr,
                             prefered_mode,
                             hybr_gw_pref_ptr,
                             #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
                             hybr_3_gw_pref_ptr,
                             #endif
                             &rat_acq_pri_order);

  /* Check if the network selection mode is limited and if it is
  ** then enter emergency call back mode
  */
  if( cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV ||
      cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV ||
      cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV )
  {
    cmph_enter_emergency_cb( ph_ptr, ss, FALSE );
  }

  /* Free allocated buffer */
  if (hybr_gw_pref_ptr)
  {
    cm_mem_free (hybr_gw_pref_ptr);
  }

  if (hybr_3_gw_pref_ptr)
  {
    cm_mem_free (hybr_3_gw_pref_ptr);
  }
} /* cmph_cmd_sys_sel_pref_proc */

/*===========================================================================

FUNCTION cmph_process_domain_pref_chg

DESCRIPTION
  This function processes system selection preferences.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_process_domain_pref_chg(

  cm_ph_cmd_s_type         *ph_cmd_ptr
)
{

  cm_ph_cmd_info_s_type       *cmd_info_ptr    = NULL;
      /* Point at command information component */
  cm_ss_e_type                ss               = CM_SS_MAIN;
  cmph_s_type                *ph_ptr           = cmph_ptr();
  cm_srv_domain_pref_e_type   srv_domain_tobe_forced =
                                           CM_SRV_DOMAIN_PREF_NONE;

  cm_mode_pref_e_type         prefered_mode       = CM_MODE_PREF_NONE;

  sd_ss_mode_pref_e_type      supp_mode_pref      = SD_SS_MODE_PREF_NONE;

  cm_sys_sel_pref_params_s_type *pmprx_pref_ptr = NULL;

  sys_modem_as_id_e_type  asubs_id = SYS_MODEM_AS_ID_1;

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  prefered_mode = cmd_info_ptr->mode_pref;
  srv_domain_tobe_forced =  cmd_info_ptr->srv_domain_pref;

  if (cmph_is_msim())
  {
    ss = cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);
  }

  if(cmph_is_feature_mode_1x_sxlte() &&
    (cmd_info_ptr->csg_id != SYS_CSG_ID_INVALID) && (cmd_info_ptr->csg_rat != SYS_RAT_NONE))
  {

    if(cmd_info_ptr->csg_rat == SYS_RAT_LTE_RADIO_ACCESS)
    {
      ss = cmph_determine_ss_per_rat(cmd_info_ptr->cmd_subs,SYS_SYS_MODE_LTE);
    }
  }

  asubs_id = cmd_info_ptr->cmd_subs;

  /* Remove object from prio queue with priority end */
  cmph_remove_orig_mode( ss, CM_ACT_TYPE_VOICE_CALL, CM_ACT_PRIORITY_END );
  cmph_remove_orig_mode( ss, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_END );
  #if defined (FEATURE_3GPP_CSFB)
  cmph_remove_orig_mode( ss, CM_ACT_TYPE_CS_DATA_CALL, CM_ACT_PRIORITY_END  );
  #endif
      
  switch(srv_domain_tobe_forced)
  {
 	  case CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH:
    {
      if(!cmph_is_subs_feature_mode_1x_sxlte(asubs_id)) 
 	    {  
         if( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_ONLY ||
            CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS )
         {
           srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_CS_PS;
         }
         else if ( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
                  CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_NONE )
         {
           srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_PS_ONLY;
         }
  
         if(cmph_is_as_id_valid(asubs_id))
         {
           CM_MSG_HIGH_4("asubs_id %d, srv_domain_tobe_forced %d, rat_disabled_mask 0x%x, prefered_mode %d",
                         asubs_id,
           srv_domain_tobe_forced, 
                         ph_ptr->rat_disabled_mask[asubs_id],
           prefered_mode);
         }
  
         cmph_activate_ps_service_req_timer(ss);
  
  	   break;
        }
  	}
      case CM_SRV_DOMAIN_PREF_PS_ATTACH:
      {
  
        if( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_ONLY ||
            CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS )
        {
          srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_CS_PS;
        }
        else if ( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
                  CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_NONE )
        {
          srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_PS_ONLY;
        }
  
        ph_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_NO_VALUE;
  
        /* If LTE was disable before enable it now */
        #ifdef FEATURE_CM_LTE
        if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs))
        {
          /* Add mode_pref SD_SS_MODE_PREF_GWL_LTE only if the current mode_pref has
          ** both SD_SS_MODE_PREF_GSM and SD_SS_MODE_PREF_WCDMA for the correct SS
          */
          if ((cmph_is_msim()&&(ss==CM_SS_HYBR_2)&&
             (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(
                ph_ptr->hybr_2_stack_info.pref_info.mode_pref),SD_SS_MODE_PREF_GSM )  &&
                    sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(
                      ph_ptr->hybr_2_stack_info.pref_info.mode_pref),SD_SS_MODE_PREF_WCDMA )))||
             ((ss == CM_SS_MAIN) &&
              (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                                       SD_SS_MODE_PREF_GSM )  &&
                  sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                                       SD_SS_MODE_PREF_WCDMA ))) 
            #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
            ||
              ((ss == CM_SS_HYBR_3) &&
              (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
                                       SD_SS_MODE_PREF_GSM )  &&
              sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
                                   SD_SS_MODE_PREF_WCDMA )))
            #endif
  
          )
          {
            prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_GWL_LTE);
          }
          else
          {
            prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_LTE);
          }
          cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
        }
        #endif /*FEATURE_CM_LTE*/
        CM_MSG_HIGH_2("prefered_mode %d, srv_domain_tobe_forced %d",prefered_mode,srv_domain_tobe_forced);
        cmph_activate_ps_service_req_timer(ss);
        }
        break;
  
      /*  Perfrom PS detach on demand. No change in domain pref.
      **  This value of service domain preference is not saved in the NV*/
      case CM_SRV_DOMAIN_PREF_PS_LOCAL_DETACH:
  
      if (cmph_is_msim() && (ss == CM_SS_HYBR_2) && !cmph_is_sxlte())
      {
        supp_mode_pref = sd_ss_get_supp_mode_pref(
                cmph_map_cm_mode_pref_to_sd_mode_pref(
                  ph_ptr->hybr_2_stack_info.pref_info.mode_pref),
                cmph_map_cm_band_pref_to_sd_band_pref(
                  ph_ptr->hybr_2_stack_info.pref_info.band_pref),
                ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                  ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref)
                );
      }
      
      #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
      else if (cmph_is_msim() && (ss == CM_SS_HYBR_3))
      {
        supp_mode_pref = sd_ss_get_supp_mode_pref(
                cmph_map_cm_mode_pref_to_sd_mode_pref(
                  ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
                cmph_map_cm_band_pref_to_sd_band_pref(
                  ph_ptr->hybr_3_stack_info.pref_info.band_pref),
                ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref,
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                  ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref)
                );
      }
      #endif
      else
      {
        supp_mode_pref = sd_ss_get_supp_mode_pref(
                  cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                  cmph_map_cm_band_pref_to_sd_band_pref(ph_ptr->main_stack_info.pref_info.band_pref),
                  ph_ptr->main_stack_info.pref_info.lte_band_pref,
                  cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(ph_ptr->main_stack_info.pref_info.tds_band_pref)
                  );
      }
  
      supp_mode_pref = SD_GET_COMMON_MODE ( supp_mode_pref, SD_SS_MODE_PREF_TDS_LTE );
  
      if(supp_mode_pref != SD_SS_MODE_PREF_NONE)
      {
        ph_ptr->is_ps_detach_required = TRUE;
      }
  
      srv_domain_tobe_forced = CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr);
      ph_ptr->main_stack_info.pref_info.pref_term = cmd_info_ptr->pref_term;
  
      CM_MSG_HIGH_3("PS_LOCAL_DETACH: is_ps_detach_required = %d, supp_mode_pref = %d, srv_domain_pref = %d",
                    ph_ptr->is_ps_detach_required , supp_mode_pref,
           CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) );
  
      cmph_detach_call_end(ss);
  
      break;
  
      case CM_SRV_DOMAIN_PREF_PS_DETACH:
  
        #ifdef FEATURE_CM_LTE
        if (cmph_is_msim() && (ss == CM_SS_HYBR_2) && !cmph_is_sxlte())
        {
          supp_mode_pref = sd_ss_get_supp_mode_pref(
                cmph_map_cm_mode_pref_to_sd_mode_pref(
                  ph_ptr->hybr_2_stack_info.pref_info.mode_pref),
                cmph_map_cm_band_pref_to_sd_band_pref(
                  ph_ptr->hybr_2_stack_info.pref_info.band_pref),
                ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                  ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref)
                );
        }
        
        #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
        else if (cmph_is_msim() && (ss == CM_SS_HYBR_3))
        {
          supp_mode_pref = sd_ss_get_supp_mode_pref(
                cmph_map_cm_mode_pref_to_sd_mode_pref(
                  ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
                cmph_map_cm_band_pref_to_sd_band_pref(
                  ph_ptr->hybr_3_stack_info.pref_info.band_pref),
                ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref,
                cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                  ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref)
                );
        }
        #endif
        else
        {
            supp_mode_pref = sd_ss_get_supp_mode_pref(
                    cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                    cmph_map_cm_band_pref_to_sd_band_pref(ph_ptr->main_stack_info.pref_info.band_pref),
                    ph_ptr->main_stack_info.pref_info.lte_band_pref,
                    cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(ph_ptr->main_stack_info.pref_info.tds_band_pref)
                    );
        }
  
        supp_mode_pref = SD_GET_COMMON_MODE ( supp_mode_pref, SD_SS_MODE_PREF_LTE );
  
        if(supp_mode_pref != SD_SS_MODE_PREF_NONE &&
           ((CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS ) ||
           (CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY )))
        {
          ph_ptr->is_ps_detach_required = TRUE;
        }
        /* Disable LTE as PS domain is being removed */
        if (supp_mode_pref != SD_SS_MODE_PREF_NONE)
        {
          prefered_mode = cm_remove_mode_pref_components(prefered_mode,1,
                                                            SD_SS_MODE_PREF_GWL_LTE);
          cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
          ph_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_USER;
        }
        #endif
        if( ( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_ONLY ) ||
            ( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS ) )
        {
          srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_CS_ONLY;
        }
        else if ( CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
                  CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr) == CM_SRV_DOMAIN_PREF_NONE )
        {
          srv_domain_tobe_forced = CM_SRV_DOMAIN_PREF_NONE;
        }
  
      cmph_detach_call_end(ss);
  
        break;
  
      case CM_SRV_DOMAIN_PREF_CS_PS:
          /*lint -fallthrough */
      case CM_SRV_DOMAIN_PREF_PS_ONLY:
          #ifdef FEATURE_CM_LTE
          if(ss == CM_SS_MAIN)
          {
            if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs))
            {
              /* Add mode_pref SD_SS_MODE_PREF_GWL_LTE only if the current mode_pref has
              ** both SD_SS_MODE_PREF_GSM and SD_SS_MODE_PREF_WCDMA
              */
              if (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                                       SD_SS_MODE_PREF_GSM )  &&
                  sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                                       SD_SS_MODE_PREF_WCDMA ))
              {
                prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_GWL_LTE);
              }
              else
              {
                prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_LTE);
              }
              cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
              ph_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_NO_VALUE;
            }
  
            /* If HDR was disabled due to non default data sub, enable it here */
            if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs))
            {
              prefered_mode = cm_add_mode_pref_components(prefered_mode,1,SD_SS_MODE_PREF_HDR);
              cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs);
            }
          }
          else
          {
            if(cmph_is_msim() && !cmph_is_sxlte() && (ss == CM_SS_HYBR_2) &&
              (cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs)))
            {
              /* Add mode_pref SD_SS_MODE_PREF_GWL_LTE only if the current mode_pref has
              ** both SD_SS_MODE_PREF_GSM and SD_SS_MODE_PREF_WCDMA for hybr_2 stack
              */
              if (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(
                  ph_ptr->hybr_2_stack_info.pref_info.mode_pref),
                  SD_SS_MODE_PREF_GSM )  &&
                  sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(
                     ph_ptr->hybr_2_stack_info.pref_info.mode_pref),
                     SD_SS_MODE_PREF_WCDMA ))
              {
                prefered_mode = cm_add_mode_pref_components(prefered_mode,1,
                                         SD_SS_MODE_PREF_GWL_LTE);
              }
              else
              {
                prefered_mode = cm_add_mode_pref_components(prefered_mode,1,
                                         SD_SS_MODE_PREF_LTE);
              }
              cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
            }
  
            #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
            else if(cmph_is_msim() && (ss == CM_SS_HYBR_3) &&
                   (cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs)))
            {
              /* Add mode_pref SD_SS_MODE_PREF_GWL_LTE only if the current mode_pref has
              ** both SD_SS_MODE_PREF_GSM and SD_SS_MODE_PREF_WCDMA for hybr_2 stack
              */
              if (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(
                  ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
                  SD_SS_MODE_PREF_GSM )  &&
                  sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(
                     ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
                     SD_SS_MODE_PREF_WCDMA ))
              {
                prefered_mode = cm_add_mode_pref_components(prefered_mode,1,
                                  SD_SS_MODE_PREF_GWL_LTE);
              }
              else
              {
                prefered_mode = cm_add_mode_pref_components(prefered_mode,1,
                                  SD_SS_MODE_PREF_LTE);
              }
              cmph_rat_disabled_mask_delete(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
            }
            #endif
        }
        break;
  
      case CM_SRV_DOMAIN_PREF_CS_ONLY:
        if(SD_MODE_CONTAIN(cmph_map_cm_mode_pref_to_sd_mode_pref(prefered_mode),SD_SS_MODE_PREF_LTE))
        {
          prefered_mode = cm_remove_mode_pref_components(prefered_mode,1,
                                                            SD_SS_MODE_PREF_GWL_LTE);
          ph_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_USER;
          cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs);
        }
  
        #ifdef FEATURE_HDR
        /* For multisim, add HDR to rat disabled mask as no PS domain for sub1 */
        if(SD_MODE_CONTAIN(cmph_map_cm_mode_pref_to_sd_mode_pref(prefered_mode),SD_SS_MODE_PREF_HDR)
          && cmph_is_msim()
        )
        {
          cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs);
        }
        /* If rat disable mask contains HDR, remove it from mode pref */
        if (cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs) &&
           asubs_id == SYS_MODEM_AS_ID_1)
        {
          prefered_mode = cm_remove_mode_pref_components(prefered_mode,1,
                                                            SD_SS_MODE_PREF_HDR);
          CM_MSG_HIGH_1("NO PS_DOMAIN AND MSIM => remove HDR, preferred_mode=%d",
                             prefered_mode);
        }
        #endif
  
        #endif /* defined(FEATURE_CM_LTE) */
        break;
  
      default:
        CM_MSG_HIGH_1 ("Directly using srv_dom pref given by client %d",
                                     srv_domain_tobe_forced);
  
        break;

  }

  #ifdef FEATURE_CM_LTE
  cmd_info_ptr->mode_pref = prefered_mode;
  #ifdef FEATURE_MMODE_TRIPLE_SIM
  CM_MSG_HIGH_4("prefered_mode = %d, rat_disabled_mask as_id_0 0x%x, as_id_1 0x%x, as_id_2 0x%x",\
    prefered_mode,
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_1],\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_2],\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_3]);
  #else
  CM_MSG_HIGH_3("prefered_mode = %d, rat_disabled_mask as_id_0 0x%x, as_id_1 0x%x",\
    prefered_mode,
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_1],\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_2]);
  #endif
  #endif /* defined(FEATURE_CM_LTE) */


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Call into Policy manager and retrieve new policy if needed.
  ** Use the same preferences as used in the force_pref_on_fly() below.
  */
  pmprx_pref_ptr = (cm_sys_sel_pref_params_s_type*)
                         cm_mem_malloc(sizeof(cm_sys_sel_pref_params_s_type));
  pmprx_pref_ptr->mode_pref        = prefered_mode;
  pmprx_pref_ptr->term_pref        = ph_ptr->main_stack_info.pref_info.pref_term;
  pmprx_pref_ptr->pref_duration    = cmd_info_ptr->pref_duration;
  pmprx_pref_ptr->band_pref        = cmd_info_ptr->band_pref;
  pmprx_pref_ptr->lte_band_pref    = cmd_info_ptr->lte_band_pref;
  pmprx_pref_ptr->tds_band_pref    = cmd_info_ptr->tds_band_pref;
  pmprx_pref_ptr->prl_pref         = cmd_info_ptr->prl_pref;
  pmprx_pref_ptr->roam_pref        = cmd_info_ptr->roam_pref;
  pmprx_pref_ptr->hybr_pref        = cmd_info_ptr->hybr_pref;
  pmprx_pref_ptr->srv_domain_pref  = srv_domain_tobe_forced;
  pmprx_pref_ptr->network_sel_mode_pref = cmd_info_ptr->network_sel_mode_pref;
  pmprx_pref_ptr->volte_enable_state = CM_VOLTE_NO_CHANGE;

   /* this is to avoid sending null PLMN values to PM when network sel mode is set to no_change from manual */
  if((cmd_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL) && ((sys_plmn_id_is_null(cmd_info_ptr->plmn))|| (sys_plmn_id_is_undefined(cmd_info_ptr->plmn))))
  {
    pmprx_pref_ptr->plmn_ptr       = &( ph_ptr->main_stack_info.pref_info.plmn );
  }
  else
  {
  pmprx_pref_ptr->plmn_ptr         = &(cmd_info_ptr->plmn);
  }

  //pmprx_pref_ptr->rat_acq_order_pref_ptr = &rat_acq_pri_order;
  pmprx_pref_ptr->csg_id           = cmd_info_ptr->csg_id;
  pmprx_pref_ptr->csg_rat          = cmd_info_ptr->csg_rat;
  pmprx_pref_ptr->ue_usage_setting = CMPH_SS_UE_USAGE_SETTING(asubs_id, ph_ptr);

  CM_MSG_HIGH_1("CM->PM: Polling PM to get new policy mode_pref=%d", pmprx_pref_ptr->mode_pref);
  cmpmprx_sys_sel_pref_policy_update( cmd_info_ptr->cmd_subs,
                                      pmprx_pref_ptr,ph_cmd_ptr);

  cm_mem_free(pmprx_pref_ptr);

  CM_MSG_HIGH_1("DDS/ACTIVE_SS: srv_domain_pref %d", cmd_info_ptr->srv_domain_pref);
  cmph_dds_update_cmd_mode_pref(asubs_id, cmd_info_ptr->mode_pref);

  {
    cm_orig_q_s_type  *ph_orig_top_ptr = cmtask_orig_para_get_top( ss );
    if (ph_orig_top_ptr)
    {
      CM_MSG_HIGH_3("DDS/ACTIVE_SS: before insert top mode_pref %d domain_pref %d, act_type %d ", 
                       ph_orig_top_ptr->orig->orig_mode_pref,
                       ph_orig_top_ptr->orig->orig_srv_domain_pref, 
                       ph_orig_top_ptr->act_type);
    

  /* Update PH object */
  cmph_insert_orig_mode( ss,
                         SD_SS_ORIG_MODE_NONE,
                         CM_ACT_TYPE_PH_OBJ,
                         cmd_info_ptr->pref_term,
                         prefered_mode,
                         cmd_info_ptr->band_pref,
                         cmd_info_ptr->lte_band_pref,
                         cmd_info_ptr->tds_band_pref,
                         cmd_info_ptr->prl_pref,
                         cmd_info_ptr->roam_pref,
                         cmd_info_ptr->hybr_pref,
                         ph_ptr->int_hybr_pref,
                         cmd_info_ptr->srv_domain_pref,
                         (cm_act_id_type)ph_ptr,
                         CM_ACT_UPDATE_REAS_USER,
                         0,
                         cmd_info_ptr->csg_id,
                         cmd_info_ptr->csg_rat
                       );
      if(ph_orig_top_ptr->act_type == CM_ACT_TYPE_POLICYMAN_RESTRICT)
  {
        cmph_insert_orig_mode( ss,
                         SD_SS_ORIG_MODE_NONE,
                         CM_ACT_TYPE_POLICYMAN_RESTRICT,
                         cmd_info_ptr->pref_term,
                         prefered_mode,
                         cmd_info_ptr->band_pref,
                         cmd_info_ptr->lte_band_pref,
                         cmd_info_ptr->tds_band_pref,
                         cmd_info_ptr->prl_pref,
                         cmd_info_ptr->roam_pref,
                         cmd_info_ptr->hybr_pref,
                         ph_ptr->int_hybr_pref,
                         CM_SRV_DOMAIN_PREF_CS_ONLY,
                         (cm_act_id_type)cmpm_ptr(),
                         CM_ACT_UPDATE_REAS_USER,
                         0,
                         cmd_info_ptr->csg_id,
                         cmd_info_ptr->csg_rat
                       );
        if(ss == CM_SS_MAIN)
        {
          cmph_insert_orig_mode( CM_SS_HYBR_1,
                         SD_SS_ORIG_MODE_NONE,
                         CM_ACT_TYPE_POLICYMAN_RESTRICT,
                         cmd_info_ptr->pref_term,
                         prefered_mode,
                         cmd_info_ptr->band_pref,
                         cmd_info_ptr->lte_band_pref,
                         cmd_info_ptr->tds_band_pref,
                         cmd_info_ptr->prl_pref,
                         cmd_info_ptr->roam_pref,
                         cmd_info_ptr->hybr_pref,
                         ph_ptr->int_hybr_pref,
                         cmd_info_ptr->srv_domain_pref,
                         (cm_act_id_type)cmpm_ptr(),
                         CM_ACT_UPDATE_REAS_USER,
                         0,
                         cmd_info_ptr->csg_id,
                         cmd_info_ptr->csg_rat
                       );
          if(cmph_is_sxlte() && !cmph_no_hybr2())
    {
            cmph_insert_orig_mode( CM_SS_HYBR_2,
                         SD_SS_ORIG_MODE_NONE,
                         CM_ACT_TYPE_POLICYMAN_RESTRICT,
                         cmd_info_ptr->pref_term,
                         prefered_mode,
                         cmd_info_ptr->band_pref,
                         cmd_info_ptr->lte_band_pref,
                         cmd_info_ptr->tds_band_pref,
                         cmd_info_ptr->prl_pref,
                         cmd_info_ptr->roam_pref,
                         cmd_info_ptr->hybr_pref,
                         ph_ptr->int_hybr_pref,
                         cmd_info_ptr->srv_domain_pref,
                         (cm_act_id_type)cmpm_ptr(),
                         CM_ACT_UPDATE_REAS_USER,
                         0,
                         cmd_info_ptr->csg_id,
                         cmd_info_ptr->csg_rat
                       );
          }
        }
      }
      CM_MSG_HIGH_3("DDS/ACTIVE_SS: after insert top mode_pref %d domain_pref %d, act_type %d ", 
                       ph_orig_top_ptr->orig->orig_mode_pref,
                       ph_orig_top_ptr->orig->orig_srv_domain_pref, 
                       ph_orig_top_ptr->act_type);
    }
  
  
  if(ss == CM_SS_MAIN)
  {
    cmph_insert_orig_mode( CM_SS_HYBR_1,
                         SD_SS_ORIG_MODE_NONE,
                         CM_ACT_TYPE_PH_OBJ,
                         cmd_info_ptr->pref_term,
                         prefered_mode,
                         cmd_info_ptr->band_pref,
                         cmd_info_ptr->lte_band_pref,
                         cmd_info_ptr->tds_band_pref,
                         cmd_info_ptr->prl_pref,
                         cmd_info_ptr->roam_pref,
                         cmd_info_ptr->hybr_pref,
                         ph_ptr->int_hybr_pref,
                         cmd_info_ptr->srv_domain_pref,
                         (cm_act_id_type)ph_ptr,
                         CM_ACT_UPDATE_REAS_USER,
                         0,
                         cmd_info_ptr->csg_id,
                         cmd_info_ptr->csg_rat
                       );
    if(cmph_is_sxlte() && !cmph_no_hybr2())
    {
      cmph_insert_orig_mode( CM_SS_HYBR_2,
                         SD_SS_ORIG_MODE_NONE,
                         CM_ACT_TYPE_PH_OBJ,
                         cmd_info_ptr->pref_term,
                         prefered_mode,
                         cmd_info_ptr->band_pref,
                         cmd_info_ptr->lte_band_pref,
                         cmd_info_ptr->tds_band_pref,
                         cmd_info_ptr->prl_pref,
                         cmd_info_ptr->roam_pref,
                         cmd_info_ptr->hybr_pref,
                         ph_ptr->int_hybr_pref,
                         cmd_info_ptr->srv_domain_pref,
                         (cm_act_id_type)ph_ptr,
                         CM_ACT_UPDATE_REAS_USER,
                         0,
                         cmd_info_ptr->csg_id,
                         cmd_info_ptr->csg_rat
                       );

}
  }
}
}


/*===========================================================================

FUNCTION cmph_rat_disabled_mask_contain

DESCRIPTION
  Check if the rat disabled mask contains the specified rat.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
 TRUE/FALSE

SIDE EFFECTS
  none

===========================================================================*/
boolean  cmph_rat_disabled_mask_contain(
  cmph_s_type          *ph_ptr,
  sys_sys_mode_e_type   sys_mode,
  sys_modem_as_id_e_type as_id
)
{
  boolean is_rat_disabled = FALSE;

  if (ph_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
    return FALSE;
  }
  if (as_id >= MAX_AS_IDS || as_id < SYS_MODEM_AS_ID_1)
  {
    return FALSE;
  }
  is_rat_disabled = (((ph_ptr->rat_disabled_mask[as_id]) & (1<< ((uint32)sys_mode))) != 0);

  return is_rat_disabled;
}

/*===========================================================================

FUNCTION cmph_rat_disabled_mask_add

DESCRIPTION
  Add the rat to the rat disabled mask.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
 none

SIDE EFFECTS
  none

===========================================================================*/
void  cmph_rat_disabled_mask_add(
  cmph_s_type          *ph_ptr,
  sys_sys_mode_e_type   sys_mode,
  sys_modem_as_id_e_type as_id
)
{
  uint32 orig_rat_disable_mask;

  if (ph_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
    return;
  }

  if (as_id >= MAX_AS_IDS || as_id < SYS_MODEM_AS_ID_1)
  {
    return;
  }

  orig_rat_disable_mask = ph_ptr->rat_disabled_mask[as_id];

  ph_ptr->rat_disabled_mask[as_id] = ( (ph_ptr->rat_disabled_mask[as_id]) | ( 1<< ((uint32)sys_mode)) );

  if(ph_ptr->rat_disabled_mask[as_id] != orig_rat_disable_mask)
  {
  CM_MSG_HIGH_3("RAT_DISABLED_MASK: disable %d, on as_id %d, updated mask 0x%x",
                   sys_mode, as_id, ph_ptr->rat_disabled_mask[as_id]);
  }

  #ifdef FEATURE_MMODE_TRIPLE_SIM
  CM_MSG_HIGH_3("rat_disabled_mask as_id_0 0x%x, as_id_1 0x%x, as_id_2 0x%x",\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_1],\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_2],\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_3]);
  #else
  CM_MSG_HIGH_2("rat_disabled_mask as_id_0 0x%x, as_id_1 0x%x",\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_1],\
    ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_2]);
  #endif
}

/*===========================================================================

FUNCTION cmph_rat_disabled_mask_delete

DESCRIPTION
  Delete the rat from the rat disabled mask.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
 none

SIDE EFFECTS
  none

===========================================================================*/
void  cmph_rat_disabled_mask_delete(
  cmph_s_type          *ph_ptr,
  sys_sys_mode_e_type   sys_mode,
  sys_modem_as_id_e_type as_id
)
{
  uint32 orig_rat_disable_mask;

  if (ph_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
    return;
  }

  if (as_id >= MAX_AS_IDS || as_id < SYS_MODEM_AS_ID_1)
  {
    return;
  }

  if (ph_ptr->rat_disabled_mask[as_id] == 0)
  {
    return;
  }

  orig_rat_disable_mask = ph_ptr->rat_disabled_mask[as_id];

  ph_ptr->rat_disabled_mask[as_id] = ((ph_ptr->rat_disabled_mask[as_id]) & (~(1<< ((uint32)sys_mode))));

  if(ph_ptr->rat_disabled_mask[as_id] != orig_rat_disable_mask)
  {
  CM_MSG_HIGH_3("RAT_DISABLED_MASK: enable %d, updated mask 0x%x on as_id %d",
                   sys_mode, ph_ptr->rat_disabled_mask[as_id], as_id);
}
}


#if defined(FEATURE_IP_CALL)
/*===========================================================================

FUNCTION  cmph_inform_secure_call_capability_proc

DESCRIPTION
 Send secure call capability to IPAPP

DEPENDENCIES
 none

RETURN VALUE

SIDE EFFECTS
  none

===========================================================================*/
void cmph_inform_secure_call_capability_proc(cm_ph_cmd_info_s_type  *cmd_info_ptr)
{
  cmipapp_send_secure_call_capability(cmd_info_ptr->cmd_subs, (cmipapp_secure_call_capability_e_type)cmd_info_ptr->secure_call_capability);
  return ;
} /* cmph_inform_secure_call_capability_proc */

#endif

/*===========================================================================

FUNCTION cmph_is_change_in_gwl_cap

DESCRIPTION
verifies changes in GWL capabilities.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
 TRUE/FALSE

SIDE EFFECTS
  none

===========================================================================*/

boolean cmph_is_change_in_gwl_cap(  cm_ph_cmd_s_type  *ph_cmd_ptr)
{
  sd_ss_mode_pref_e_type     curr_gw_mode_pref = SD_SS_MODE_PREF_NONE;
  sd_ss_mode_pref_e_type     new_gw_mode_pref  = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type     curr_gw_band_pref = SD_SS_BAND_PREF_NONE;
  sd_ss_band_pref_e_type     new_gw_band_pref  = SD_SS_BAND_PREF_NONE;
  sd_ss_band_pref_e_type     curr_tds_band_pref = SD_SS_BAND_PREF_NONE;
  sd_ss_band_pref_e_type     new_tds_band_pref  = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type   curr_lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
  sys_lte_band_mask_e_type   new_lte_band_pref  = SYS_LTE_BAND_MASK_CONST_ANY;

  cm_srv_domain_pref_e_type  srv_domain_tobe_forced =
                                           CM_SRV_DOMAIN_PREF_NONE;
  cmph_s_type                     *ph_ptr = cmph_ptr();
  cm_ph_cmd_info_s_type      *cmd_info_ptr    = NULL;
  sys_modem_as_id_e_type      asubs_id = cmph_map_cm_ss_to_subs(CM_SS_MAIN);


  /*lint -esym(529, ss) not referenced */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /* TDS-CDMA/LTE is supported on HYBR-2 stack in DSDS, add it to subs capabilities */

  new_gw_mode_pref = SD_GET_COMMON_MODE ( cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->mode_pref),
                      SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE );

  curr_gw_mode_pref = SD_GET_COMMON_MODE ( cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                       SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE );

  curr_gw_band_pref = cmph_map_cm_band_pref_to_sd_band_pref(ph_ptr->main_stack_info.pref_info.band_pref) & SD_SS_BAND_PREF_LTE_GWL;

  new_gw_band_pref  = cmph_map_cm_band_pref_to_sd_band_pref(cmd_info_ptr->band_pref) & SD_SS_BAND_PREF_LTE_GWL;

  curr_tds_band_pref = cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(ph_ptr->main_stack_info.pref_info.tds_band_pref) & SD_SS_BAND_PREF_TDS_ANY;

  new_tds_band_pref  = cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(cmd_info_ptr->tds_band_pref) & SD_SS_BAND_PREF_TDS_ANY;

  curr_lte_band_pref = SYS_LTE_BAND_MASK_COMMON(&ph_ptr->main_stack_info.pref_info.lte_band_pref, &new_lte_band_pref);

  new_lte_band_pref  = SYS_LTE_BAND_MASK_COMMON(&cmd_info_ptr->lte_band_pref, &new_lte_band_pref);


  if (cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_NO_CHANGE)
  {
    srv_domain_tobe_forced = CMPH_SS_SRV_DOMAIN_PREF( asubs_id, ph_ptr );
  }
  else
  {
    srv_domain_tobe_forced = cmd_info_ptr->srv_domain_pref;
  }

  if((new_gw_mode_pref != curr_gw_mode_pref) ||
      (curr_gw_band_pref != new_gw_band_pref) ||
      (cmd_info_ptr->network_sel_mode_pref != CMPH_SS_NETWORK_SEL_MODE_PREF( asubs_id, ph_ptr )) ||
      (cmd_info_ptr->acq_order_pref != CMPH_SS_ACQ_ORDER_PREF( asubs_id, ph_ptr )) ||
      (srv_domain_tobe_forced != CMPH_SS_SRV_DOMAIN_PREF( asubs_id, ph_ptr )) ||
       !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&curr_lte_band_pref,&new_lte_band_pref)||
      (curr_tds_band_pref != new_tds_band_pref)
    )
  {
    CM_MSG_LOW_5("is_change_in_gwl_cap(), OLD prefs: mode_pref %d, GW band_pref %d, srv_domain %d, acq_pref %d, net_sel mode %d",
               curr_gw_mode_pref,
               curr_gw_band_pref,
               ph_ptr->main_stack_info.pref_info.srv_domain_pref,
               ph_ptr->main_stack_info.pref_info.acq_order_pref,
               ph_ptr->main_stack_info.pref_info.network_sel_mode_pref);
    CM_MSG_LOW_5("is_change_in_gwl_cap(), NEW prefs: mode_pref %d, GW band_pref %d, srv_domain %d, acq_pref %d, net_sel mode %d",
               new_gw_mode_pref,
               new_gw_band_pref,
               cmd_info_ptr->srv_domain_pref,
               cmd_info_ptr->acq_order_pref,
               cmd_info_ptr->network_sel_mode_pref);

    return TRUE;
  }

  return FALSE;
}
/*lint +esym(529, ss) not referenced */

#if defined CM_GW_SUPPORTED
/*===========================================================================

FUNCTION cmph_determine_ss_for_get_networks

DESCRIPTION
 This function determines in which stack get networks command should be processed
 when in SVLTE mode of operation


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  CM_SS_HYBR_2 -
  If LTE in service on hybrid 2
  If 1x in service and hybrid gw is operational and L only scan
  If in OOS and hybrid gw is operational and L only scan
  else
  CM_SS_MAIN

SIDE EFFECTS
  none

===========================================================================*/

static cm_ss_e_type cmph_determine_ss_for_get_networks(cm_ph_cmd_info_s_type *cmd_info_ptr)
{
  cm_ss_e_type ss = CM_SS_MAIN;

  /* If 3GPP is in service on MAIN stack , choose MAIN
  */
  if ( sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status) &&
           (cmph_map_sys_mode_mask_to_sd_mode_pref(BM(cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode)) & SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE) )
  {
    CM_MSG_HIGH_2("get_net: MAIN srv %d mode %d",cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status,cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode);
    ss = CM_SS_MAIN;
  }
  /*If LTE in service on hybr2 */
  else if (sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status) &&
      (cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode == SYS_SYS_MODE_LTE)  )
  {
    CM_MSG_HIGH_0("get_net:hybr2 srv");
    ss = CM_SS_HYBR_2;
  }

  /* If LTE only scan and MAIN is in service or OOS */
  else if(cmd_info_ptr->network_type == CM_MODE_PREF_LTE_ONLY)
  {
    CM_MSG_HIGH_0("get_net:LTE only scan");
    ss= CM_SS_HYBR_2;
  }
  if ((cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->network_type) &
       (SD_SS_MODE_PREF_WCDMA)) &&
       (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG_USER ||
       cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG_SELECTION_APP))
  {
    ss = CM_SS_MAIN;
  }
  return ss;

}
/*===========================================================================

FUNCTION cmph_suspend_main_for_get_networks

DESCRIPTION
  This function determines whether to suspend MAIN during get networks.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  TRUE - MAIN should be suspended
  FALSE - No need to suspend MAIN

SIDE EFFECTS
  none

===========================================================================*/

static boolean  cmph_suspend_main_for_get_networks(cm_ss_e_type ss, cm_ph_cmd_info_s_type *cmd_info_ptr)
{
  /* If G/W is part of scan and ss is HYBR_2 always suspend MAIN */
  if ((ss == CM_SS_HYBR_2) &&
    (cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->network_type) &
       (SD_SS_MODE_PREF_GW | SD_SS_MODE_PREF_TDS)))
  {
    return TRUE;
  }

  return FALSE;
}


/*===========================================================================

FUNCTION cmph_cmd_get_networks_proc

DESCRIPTION
  This function processes a network list confirmation event reported
  by the lower software layer.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_get_networks_proc(

  cm_ph_cmd_s_type         *ph_cmd_ptr

)
{
  cm_ph_cmd_info_s_type       *cmd_info_ptr    = NULL;
      /* Point at command information component */

  cm_ss_e_type                  ss = CM_SS_MAIN;
  sys_modem_as_id_e_type   asubs_id = SYS_MODEM_AS_ID_1;

  #ifdef CM_GW_SUPPORTED
  cm_mode_pref_e_type         rat_bal_preferred_mode  = CM_MODE_PREF_NONE;
  #endif /* CM_GW_SUPPORTED */

  sd_ss_band_pref_e_type       sd_band_pref        = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type     sd_lte_band_pref    = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type       sd_tds_band_pref    = SD_SS_BAND_PREF_NONE;
  sd_ss_mode_pref_e_type        sd_network_type    = SD_SS_MODE_PREF_NONE;

  cmss_s_type         *ss_ptr        = cmss_ptr();
  cm_orig_q_s_type            *ph_main_orig_top_ptr;
  cm_orig_q_s_type            *ph_hybr_2_orig_top_ptr;
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  cm_orig_q_s_type            *ph_hybr_3_orig_top_ptr;
  #endif
  cm_orig_q_s_type            *ph_hybr_1_orig_top_ptr;

  cmph_s_type                 *ph_ptr;
  boolean                      suspend_main = FALSE;
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );
  CM_MSG_LOW_1("START cmph_cmd_get_networks_proc(),cmd=%d",ph_cmd_ptr->cmd);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ph_ptr = cmph_ptr();
  sd_network_type   = cmph_map_cm_mode_pref_to_sd_mode_pref(
                                                      cmd_info_ptr->network_type);

  sd_band_pref      = cmph_map_cm_band_pref_to_sd_band_pref(
                                           cmd_info_ptr->band_pref_lmt);
  sd_lte_band_pref  = cmd_info_ptr->lte_band_pref_lmt;
  sd_tds_band_pref  = cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                                           cmd_info_ptr->tds_band_pref_lmt);

  if (cmph_is_msim())
  {
    asubs_id = cmd_info_ptr->cmd_subs;
  }
  
 /* In SV when global mode support is enabled for PLMN and CSG search
   */
  if ( cmph_is_subs_feature_mode_1x_sxlte(asubs_id) &&
           (ss_ptr->info.is_hybr_gw_operational) &&
       (ph_ptr->get_net_auto_mode_enabled.get_net_auto_mode ||
       ph_ptr->csg_auto_mode.csg_global_mode_support))
  {
    ss =  cmph_determine_ss_for_get_networks(cmd_info_ptr);
    suspend_main = cmph_suspend_main_for_get_networks(ss, cmd_info_ptr);
    CM_MSG_HIGH_3("cmph_determine_ss_for_get_networks - %d, suspend_main %d, cmd_info_ptr->network_list_type %d",
      ss, suspend_main, cmd_info_ptr->network_list_type);
    if (suspend_main == TRUE)
    {
      CM_MSG_HIGH_1 ("GET_NET on %d suspend MAIN stack till list cnf is received",ss);
      mmoc_cmd_suspend_ss(SD_SS_MAIN, TRUE, FALSE);

    }
  }
  else
  {
    ss = cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);
  }

  /*lint -save -e655 */
  /* Request needs to be sent to mmoc, only if list type is CM_NETWORK_LIST_AVAILABLE or CM_NETWORK_LIST_CSG */
  if ( ((cmd_info_ptr->network_list_type == CM_NETWORK_LIST_AVAILABLE)   ||
        (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG) ||
        (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG_SELECTION_APP) ||
        (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG_USER)         ||
        (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND)   ||
        (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_PCI_SCAN) ||
        (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_WITH_MAX_CAP ))        &&
       (cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->network_type) &
       (SD_SS_MODE_PREF_GWL | SD_SS_MODE_PREF_TDS))
     )
  {
    /*lint -restore */

    /* Forcefully unforce the origination mode preferences.
    */

    /* Check the main orig queue and unforce if the pref_term is
    ** temporary
    ** If we are in the four second window and after we send
    ** the get networks command down, the timer expires and we send a
    ** pref sys change down, the get networks command is terminated
    */
    if( ss == CM_SS_HYBR_2 )
    {
      /* The pointer to the top element of the priority queue
      */
      ph_hybr_2_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_2 );

      if( ph_hybr_2_orig_top_ptr != NULL &&
          cmph_is_pref_term_temporary(
                          ph_hybr_2_orig_top_ptr->orig->orig_pref_term ) &&
          ph_hybr_2_orig_top_ptr->orig->act_update_reas == CM_ACT_UPDATE_REAS_ACT_END
        )
      {
        /* Clear the hybr_2 Q and unforce the modes
        */
        cmph_orig_mode_reset_on_ss(ph_ptr, CM_SS_HYBR_2, TRUE, CM_DEFAULT_VALUE);
      }
    }
    else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if( ss == CM_SS_HYBR_3 )
    {
      /* The pointer to the top element of the priority queue
      */
      ph_hybr_3_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_3 );

      if( ph_hybr_3_orig_top_ptr != NULL &&
          cmph_is_pref_term_temporary(
                          ph_hybr_3_orig_top_ptr->orig->orig_pref_term ) &&
          ph_hybr_3_orig_top_ptr->orig->act_update_reas == CM_ACT_UPDATE_REAS_ACT_END
        )
      {
        /* Clear the hybr_3 Q and unforce the modes
        */
        cmph_orig_mode_reset_on_ss(ph_ptr, CM_SS_HYBR_3, TRUE, CM_DEFAULT_VALUE);
      }
    }
    else
    #endif /* FEATURE_MMODE_TRIPLE_SIM */
    {
      /* The pointer to the top element of the priority queue
      */
      ph_main_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_MAIN );

      ph_hybr_1_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_1 );

      if( ph_main_orig_top_ptr != NULL &&
          cmph_is_pref_term_temporary(
                          ph_main_orig_top_ptr->orig->orig_pref_term ) &&
          ph_main_orig_top_ptr->orig->act_update_reas == CM_ACT_UPDATE_REAS_ACT_END
        )
      {
        /* Clear the main Q and unforce the modes
        */
        cmph_orig_mode_reset_on_ss(ph_ptr, CM_SS_MAIN, TRUE, CM_DEFAULT_VALUE );
      }

      if( ph_hybr_1_orig_top_ptr != NULL &&
          cmph_is_pref_term_temporary(
                          ph_hybr_1_orig_top_ptr->orig->orig_pref_term )&&
          ph_hybr_1_orig_top_ptr->orig->act_update_reas == CM_ACT_UPDATE_REAS_ACT_END
        )
      {
        /* Clear the main Q and unforce the modes
        */
        cmph_orig_mode_reset_on_ss(ph_ptr, CM_SS_HYBR_1, TRUE, CM_DEFAULT_VALUE );
      }
    }

    /* Send get network request.
    */

    /* Whatever user has given as network_type, should be used to
    ** select the available list of PLMNs
    */

    #ifdef CM_GW_SUPPORTED

    /*
    ** If EF-RAT defined and not a CSG search then search should be
    ** performed with EF-RAT preferences.
    */

    if ( ph_ptr->is_rat_bal == TRUE &&
         ph_ptr->is_uim_usim_rat_present == TRUE &&
         (cmd_info_ptr->network_list_type != CM_NETWORK_LIST_CSG ||
          cmd_info_ptr->network_list_type != CM_NETWORK_LIST_CSG_SELECTION_APP ||
          cmd_info_ptr->network_list_type != CM_NETWORK_LIST_CSG_USER
         )
       )
    {
      rat_bal_preferred_mode = cmph_get_efrat_mode_pref();

      if( rat_bal_preferred_mode != CM_MODE_PREF_NONE &&
          rat_bal_preferred_mode != CM_MODE_PREF_AUTOMATIC
        )
      {
        cmd_info_ptr->network_type = rat_bal_preferred_mode;
        CM_MSG_HIGH_1("EF-RAT preference search %d",
                    rat_bal_preferred_mode);
      }
    }
    #endif /* CM_GW_SUPPORTED */

    #ifdef FEATURE_MMODE_SC_SGLTE
    if (cmph_is_subs_feature_mode_sglte(cmd_info_ptr->cmd_subs))
    {
      cmmsc_state_machine_s_type   *state_machine_ptr = cmmsimc_state_machine_ptr(cmd_info_ptr->cmd_subs);
      cmmsc_stack_s_type           *stack_pointer     = &state_machine_ptr->stack[0];



      CM_MSG_HIGH_3("SC_SGLTE: GET_NET ue_mode=%d, network_type=%d, mode_capability=%d",
                  state_machine_ptr->stack_common_info.ue_mode,
                  cmd_info_ptr->network_type, stack_pointer->capablity.mode);

      if(state_machine_ptr->stack_common_info.ue_mode == SYS_UE_MODE_SGLTE_HOME ||
         state_machine_ptr->stack_common_info.ue_mode == SYS_UE_MODE_SGLTE_ROAM ||
         state_machine_ptr->stack_common_info.ue_mode == SYS_UE_MODE_SGLTE_TEST_ONLY )
      {
        CM_MSG_HIGH_4( "old bands(MSB)(LSB): cgw 0x%08x %08x, tds 0x%08x %08x",
                                  QWORD_HIGH(sd_band_pref),
                                  QWORD_LOW(sd_band_pref),
                                  QWORD_HIGH(sd_tds_band_pref),
                                  QWORD_LOW(sd_tds_band_pref));
        cm_print_lte_band_mask(sd_lte_band_pref);


               /* Do not restrict mode and band capabilities to PM restricted capabilities for CM_NETWORK_LIST_WITH_MAX_CAP */
        if(cmd_info_ptr->network_list_type != CM_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND &&
                         cmd_info_ptr->network_list_type != CM_NETWORK_LIST_WITH_MAX_CAP)
        {
         sd_network_type = SD_GET_COMMON_MODE( sd_network_type,
                                               stack_pointer->capablity.mode);
         sd_band_pref = SD_GET_COMMON_BAND(sd_band_pref,
                                           stack_pointer->capablity.band);
          sd_lte_band_pref = SYS_LTE_BAND_MASK_COMMON( &sd_lte_band_pref,
                                                 &stack_pointer->capablity.lte_band );
         sd_tds_band_pref = SD_GET_COMMON_BAND(sd_tds_band_pref,
                                               stack_pointer->capablity.tds_band);
         cmd_info_ptr->network_type = cmph_map_sd_mode_pref_to_cm_mode_pref( sd_network_type );
        }

         CM_MSG_HIGH_2("SC_SGLTE: new_sd_network_type = %d, new_network_type = %d",
                      sd_network_type, cmd_info_ptr->network_type);

        CM_MSG_HIGH_4( "restr. bands(MSB)(LSB): cgw 0x%08x %08x, tds 0x%08x %08x",
                                  QWORD_HIGH(sd_band_pref),
                                  QWORD_LOW(sd_band_pref),
                                  QWORD_HIGH(sd_tds_band_pref),
                                  QWORD_LOW(sd_tds_band_pref));
        cm_print_lte_band_mask(sd_lte_band_pref);

      }
    }
    #endif

    if (!cmph_is_feature_mode_sglte() && (cmd_info_ptr->network_list_type != CM_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND) &&
		(cmd_info_ptr->network_list_type != CM_NETWORK_LIST_WITH_MAX_CAP ))
    {
      cmmsc_state_machine_s_type   *state_machine_ptr = cmmsimc_state_machine_ptr(cmd_info_ptr->cmd_subs);
      int                          stack_idx;

      stack_idx         = cmmsc_mapping_ss_to_stack_idx(cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs));

      /* Get net modes, bands are filtered based on Policy Man settings.
      ** Get mode capability supported from common info
      */

      sd_network_type = SD_GET_COMMON_MODE( sd_network_type,
                     cmph_map_sys_mode_mask_to_sd_mode_pref(state_machine_ptr->stack_common_info.ue_mode_capability));

      cmd_info_ptr->network_type = cmph_map_sd_mode_pref_to_cm_mode_pref( sd_network_type );

        // use common band pref

      sd_band_pref = SD_GET_COMMON_BAND(sd_band_pref, state_machine_ptr->stack_common_info.ue_band_capability);
      sd_lte_band_pref = SYS_LTE_BAND_MASK_COMMON(&sd_lte_band_pref , &(state_machine_ptr->stack_common_info.ue_lte_band_capability));
      sd_tds_band_pref = SD_GET_COMMON_BAND(sd_tds_band_pref, state_machine_ptr->stack_common_info.ue_tds_band_capability);

      if( stack_idx ==2 &&
          cmph_is_subs_feature_mode_1x_sxlte(cmd_info_ptr->cmd_subs))
      {
        CM_MSG_HIGH_0("Filtering Hybrid 2 LTE bands on filter");
        cm_print_lte_band_mask(state_machine_ptr->stack_common_info.svlte_capable_lte_bands);

        sd_lte_band_pref = SYS_LTE_BAND_MASK_COMMON(&sd_lte_band_pref ,&(state_machine_ptr->stack_common_info.svlte_capable_lte_bands));
      }


      CM_MSG_HIGH_2( "GET_NET mode pref %d ue mode capability %d",cmd_info_ptr->network_type,
        cmph_map_sys_mode_mask_to_sd_mode_pref(state_machine_ptr->stack_common_info.ue_mode_capability));
      CM_MSG_HIGH_4( "GET_NET. bands(MSB) (LSB): cgw 0x%08x %08x, tds 0x%08x %08x",
                                  QWORD_HIGH(sd_band_pref),
                                  QWORD_LOW(sd_band_pref),
                                  QWORD_HIGH(sd_tds_band_pref),
                                  QWORD_LOW(sd_tds_band_pref));
      cm_print_lte_band_mask(sd_lte_band_pref);

    }

    /* Do not restrict mode and band capabilities to PM restricted capabilities for CM_NETWORK_LIST_WITH_MAX_CAP */
    if(cmd_info_ptr->network_list_type != CM_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND &&
		cmd_info_ptr->network_list_type != CM_NETWORK_LIST_WITH_MAX_CAP )
     {
       sys_lte_band_mask_e_type ph_ss_lte_band_pref = CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr);
       sd_band_pref = sd_band_pref & cmph_map_cm_band_pref_to_sd_band_pref(CMPH_SS_BAND_PREF(asubs_id, ph_ptr));
       sd_lte_band_pref = SYS_LTE_BAND_MASK_COMMON(&sd_lte_band_pref, &ph_ss_lte_band_pref);
       sd_tds_band_pref = sd_tds_band_pref & cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr));
     }

    /* Save the determined SS in ph_ptr ss_for_get_networks
	    Terminate get_networks will be sent on same ss 
	    Valid till there is an ongoing network_search */
	if( ss == CM_SS_MAX )
    {
      ph_ptr->ss_for_get_networks = CM_SS_MAIN;
    }
    else
    {
      ph_ptr->ss_for_get_networks = ss;
    }

    mmoc_cmd_get_networks_gw(
      cmph_map_cm_mode_pref_to_sd_mode_pref( cmd_info_ptr->network_type),
      sd_band_pref,
      sd_lte_band_pref,
      sd_tds_band_pref,
      cmph_map_cm_ss_type_to_sd_ss_type(ss),
      cmph_map_cm_network_list_type_to_sd_network_list_type(cmd_info_ptr->network_list_type)
      );
  }/* if CM_NETWORK_LIST_AVAILABLE) */

  /*lint -save -e655 */
  /*lint -restore */

} /* cmph_cmd_get_networks_proc */
#endif /* FEATURE_GSM || FEATURE_WCDMA */


/*===========================================================================

FUNCTION cmph_is_hybr2_toggled_on

DESCRIPTION
  The function returns if CM needs to switch on hybr2 stack upon thermal emergency call end.

DEPENDENCIES
  None.

RETURN VALUE
  boolean.

SIDE EFFECTS
  None.

===========================================================================*/
static  boolean  cmph_is_hybr2_toggled_on(

       cm_ss_e_type                     ss
)
{
  cm_orig_q_s_type *ph_orig_top_ptr = cmtask_orig_para_get_top(ss);
  cmmsc_state_machine_s_type *state_machine = cmmsimc_get_msc_ptr_per_cm_ss(ss);

  if(ph_orig_top_ptr == NULL)
  {
    CM_ERR_1("Top ptr is NULL for %d stack", ss);
    return FALSE;
  }

  /* If the sub feature mode is not svlte, return false directly */
  if (!cmph_is_subs_feature_mode_1x_sxlte(cmph_map_cm_ss_to_subs(ss)))
  {
    return FALSE;
  }

  /* Case: hybr2 stack is off and hybr pref is cdma_lte_hdr.  Need to switch on hybr2 stack */
  if(ss == CM_SS_HYBR_2
    &&
    ( cmph_get_last_pref_sent(ss)->orig_hybr_pref == CM_HYBR_PREF_CDMA__LTE__HDR &&
     ph_orig_top_ptr->act_type == CM_ACT_TYPE_PH_OBJ &&
     cmmsc_auto_is_hybr_gwl_allowed(
          state_machine,
          cmph_map_cm_hybr_pref_to_sd_hybr_pref(ph_orig_top_ptr->orig->orig_hybr_pref),
          cmph_ptr()->is_cdma_subscription_available)
     )
    &&
    cmmsimc_get_msc_stack_state(ss) == CMMSC_STACK_STATE_INACTIVE
  )
  {
    return TRUE;
  }

  /* Case: the last hybr pref is off and hybr pref is cdma_lte_hdr.  Need to switch on hybr2 stack */
  else if (ss == CM_SS_HYBR_2 &&
         cmph_get_last_pref_sent(ss)->orig_hybr_pref
           != ph_orig_top_ptr->orig->orig_hybr_pref &&
         ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_VOLTE
  )
  {
    return TRUE;
  }

  return FALSE;
}

#ifdef FEATURE_MMODE_DUAL_SIM
/*===========================================================================
  Takes as_id and checks user ever enabled LTE on that subscription
===========================================================================*/

static boolean cmph_is_user_mode_lte(

  sys_modem_as_id_e_type as_id

)
{
  if(cmcall_misc_is_mode_pref(CMPH_SS_MODE_PREF(as_id, cmph_ptr()),
                              CM_MODE_PREF_LTE_ONLY))
  {
    return TRUE;
  }
  if(cmph_rat_disabled_mask_contain(cmph_ptr(), SYS_SYS_MODE_LTE, as_id))
  {
    return TRUE;
  }

  return FALSE;
}
#endif

/*===========================================================================

FUNCTION cmph_force_orig_mode_on_ss

DESCRIPTION
  Unforce the origination mode on the fly for a particular ss

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

static void cmph_force_orig_mode_on_ss(

       cm_ss_e_type      ss,
         /* The ss on which the mode is to be unforced */

       cmph_s_type      *ph_ptr
         /* Pointer to a phone object */

)
{
  cm_orig_q_s_type *ph_orig_top_ptr =
             cmtask_orig_para_get_top( ss == CM_SS_MAX ? CM_SS_MAIN : ss );
    /* The pointer to the top element of the priority queue
    */
  sd_ss_pref_reas_e_type pref_reas = SD_SS_PREF_REAS_ORIG_END;

  sd_ss_orig_mode_e_type orig_mode = SD_SS_ORIG_MODE_NONE;

  /* Flag to indicate if phone object is at top of the priority queue */
  boolean                is_top_phone = FALSE;

  cm_network_sel_mode_pref_e_type net_sel_mode =
     CMPH_SS_NETWORK_SEL_MODE_PREF(cmph_map_cm_ss_to_subs(ss), ph_ptr);
  cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr != NULL);
  CM_ASSERT(ph_orig_top_ptr != NULL);

  if (ph_orig_top_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* If there is a call pending and we are forcing the phone preferences
  ** set the orig mode accordingly
  */
  if( ph_orig_top_ptr->orig->act_id == (cm_act_id_type)ph_ptr )
  {
    CM_MSG_HIGH_0("ph_orig_top_ptr is ph_ptr");
    is_top_phone = TRUE;

    if( cmtask_orig_para_count_2( ss == CM_SS_MAX ? CM_SS_MAIN : ss,
                                  CM_ACT_PRIORITY_END,
                                  CM_CMP_CRITERIA_GREATER_THAN) >= 1 )
    {
      if( net_sel_mode == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
      }
      else if( (net_sel_mode == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV) ||
                 (net_sel_mode == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV) )
      {
        orig_mode = SD_SS_ORIG_MODE_EMERG_ORIG;
      }
      else
      {
        orig_mode = SD_SS_ORIG_MODE_NORMAL;
      }
    }
    else
    {
      if( (ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE) &&
            net_sel_mode == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
      }
      else if( (net_sel_mode == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV) ||
                 (net_sel_mode == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV) )
      {
        orig_mode = SD_SS_ORIG_MODE_EMERG_ORIG;
      }
      else
      {
        orig_mode = ph_orig_top_ptr->orig->orig_mode;
      }
    }
  } /* If top == phone */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* See if the hybrid preferences were toggled for the origination
  ** Or user changed the preferences and we held sending the pref_sys down
  ** set ss to MAX
  */
  if( (ss == CM_SS_MAIN) &&
       ( ( cmph_get_last_pref_sent(CM_SS_MAIN)->orig_hybr_pref  !=
           ph_orig_top_ptr->orig->orig_hybr_pref ) ||
         ( ph_orig_top_ptr->orig->act_update_reas == CM_ACT_UPDATE_REAS_USER )
       )
    )
  {
    ss = CM_SS_MAX;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */  
  /* if there is a pending switch csfb<->srlte, set ss to MAX
  */
  if( (ss == CM_SS_MAIN) &&
      (ph_orig_top_ptr->act_type == CM_ACT_TYPE_PH_OBJ) &&
      ( ph_orig_top_ptr->orig->pref_update_reason == SD_SS_PREF_UPDATE_REASON_ACTIVATE_HYBR2 ||
      ph_orig_top_ptr->orig->pref_update_reason == SD_SS_PREF_UPDATE_REASON_ACTIVATE_HYBR2_SILENT||
      ph_orig_top_ptr->orig->pref_update_reason == SD_SS_PREF_UPDATE_REASON_SWITCH_SVLTE ||
      ph_orig_top_ptr->orig->pref_update_reason == SD_SS_PREF_UPDATE_REASON_SWITCH_CSFB)
    )
  {
    CM_MSG_HIGH_1("top_ptr is PH_OBJ and pending csfb->srlte switch with pref_update_reason=%d, set ss to MAX",
                   ph_orig_top_ptr->orig->pref_update_reason);
    ss = CM_SS_MAX;
  }

  /* additional fix to handle the case where oprt state is svlte but csfb->srlte switch is still pending and
  ** pref_update_reason is none.
  */
  #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
  if( (ss == CM_SS_MAIN) &&
      (ph_orig_top_ptr->act_type == CM_ACT_TYPE_PH_OBJ) &&
      cmsoa_get_current_sv_oprt_state() == CMSOA_SV_OPRT_MODE_SVLTE &&
      ph_orig_top_ptr->orig->orig_hybr_pref == CM_HYBR_PREF_CDMA__LTE__HDR &&
      cmph_is_oprting_in_csfb_pref(cmph_map_cm_ss_to_subs(ss)) &&
      cmss_is_hybr2_operational() == FALSE
    )
  {
    CM_MSG_HIGH_0("top_ptr is PH_OBJ and pending csfb->srlte switch with pref_update_reason=none, set ss to MAX");
    ss = CM_SS_MAX;
  }
  #endif

  #ifdef FEATURE_HICPS_STACK_SYNC_UP

  /* If the hybrid preference has changed and the new hybrid preference is
  ** CM_HYBR_PREF_CDMA__LTE__HDR and 
  ** If target supports gw mode and main stack mode preference has gw and if 
  ** phone object doesn't contain gw in the mode preference, restore 3gpp
  ** on main stack.
  ** If there is HDR traffic, SD will skip GW records during scans on main stack. 
  ** On hybr2 stack, issuing acq_gwl will be delayed if there is hdr activity.
  */
  if( ( cmph_get_last_pref_sent(CM_SS_MAIN)->orig_hybr_pref  !=
        ph_orig_top_ptr->orig->orig_hybr_pref ) &&
      ( ph_orig_top_ptr->orig->orig_hybr_pref == CM_HYBR_PREF_CDMA__LTE__HDR ) 
    )
  {
    sd_ss_mode_pref_e_type  mode_cap = cmmsc_get_cm_ss_mode_cap(CM_SS_MAIN);
    sd_ss_mode_pref_e_type  sd_mode_pref = sd_misc_get_common_mode_pref(SD_SS_MODE_PREF_GWL, mode_cap);

    cm_orig_q_s_type  *ph_orig_ptr = cmtask_orig_para_search_act_type( CM_SS_MAIN,
                                                               CM_ACT_TYPE_PH_OBJ);


    if( ph_orig_ptr != NULL ){

      boolean is_gw_mode = cmph_is_valid_mode_pref( CM_MODE_PREF_GWL, SYS_MODEM_AS_ID_1);
  
      boolean is_ph_obj_gw_mode = SD_MODE_CONTAIN(sd_mode_pref, 
                           cmph_map_cm_mode_pref_to_sd_mode_pref(
                             ph_orig_ptr->orig->orig_mode_pref));

      boolean is_ph_ptr_gw_mode = SD_MODE_CONTAIN(sd_mode_pref, 
                           cmph_map_cm_mode_pref_to_sd_mode_pref(
                             ph_ptr->main_stack_info.pref_info.mode_pref));

 
      CM_MSG_HIGH_3("HICPS: check restore 3gpp from hybr toggle, is_gw_mode %d is_ph_obj_gw_mode %d is_ph_ptr_gw_mode %d",
                    is_gw_mode, is_ph_obj_gw_mode, is_ph_ptr_gw_mode); 
  
      if( is_gw_mode && is_ph_ptr_gw_mode && !is_ph_obj_gw_mode )
      {

        /* Update ph obj mode pref with the ph ptr mode pref*/
        ph_orig_ptr->orig->orig_mode_pref = ph_ptr->main_stack_info.pref_info.mode_pref;

        *cmph_get_is_kicked_hybr_ptr() = FALSE;

        /* Deactivate the GWL avoidance timer. */
        cmph_deactivate_hicps_gwl_avoid_timer();

      }

    }
  }
  #endif

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* See if the top_ptr is PH_OBJ and user mode pref is HDR only, then
  ** set ss to MAX
  */
  if( (ss == CM_SS_MAIN) &&
      (ph_orig_top_ptr->act_type == CM_ACT_TYPE_PH_OBJ) &&
      ( ph_orig_top_ptr->orig->user_mode_pref == CM_MODE_PREF_HDR_ONLY)
    )
  {
    ss = CM_SS_MAX;
    CM_MSG_HIGH_0("top_ptr is PH_OBJ and user mode pref is HDR only, set ss to MAX");
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_MSG_HIGH_5("cmph_force_orig_mode_on_ss(), ss %d, orig_mode %d, net_sel_mode %d mode_pref=%d, act_update_reas %d",
                          ss, orig_mode, net_sel_mode,
                          ph_orig_top_ptr->orig->orig_mode_pref,
                          ph_orig_top_ptr->orig->act_update_reas);


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* If the top is none or there is only phone object in the queue or
  ** all other activities have ended
  */
  if( cmtask_orig_para_count_2(
                                   (ss==CM_SS_MAX?CM_SS_MAIN:ss),
                                   CM_ACT_PRIORITY_END,
                                   CM_CMP_CRITERIA_GREATER_THAN) < 1 )
  {

    /* pref_update_reason check takes care of usecase
    ** when CSFB -> SRLTE switch happens while 1x call is in progress
    ** switch would be buffered .
    ** and when the call ends we need to force the pref_reas as user
    ** to facilitate the actual switch to SRLTE
    */
    if(ph_orig_top_ptr->orig->act_update_reas == CM_ACT_UPDATE_REAS_USER ||
       ph_orig_top_ptr->orig->act_update_reas == CM_ACT_UPDATE_REAS_ACT_PWR_SAVE ||
       ph_orig_top_ptr->orig->pref_update_reason == SD_SS_PREF_UPDATE_REASON_SWITCH_SVLTE)

    {
      pref_reas = SD_SS_PREF_REAS_USER;
      ph_orig_top_ptr->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_START;
    }

    CM_MSG_HIGH_2("no call activity, ph obj pref_update_reason %d act_update_reas %d",
                  ph_orig_top_ptr->orig->pref_update_reason,
                  ph_orig_top_ptr->orig->act_update_reas);
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    /* Get the handle to the phone object and use it to force preferences,
    ** since all the activities have ended
    */
    ph_orig_top_ptr = cmtask_orig_para_search_act_id(
                                       ( ss == CM_SS_MAX ? CM_SS_MAIN : ss ),
                                       ( cm_act_id_type ) ph_ptr );

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    CM_ASSERT( ph_orig_top_ptr != NULL );

    if(ph_orig_top_ptr == NULL)
    {
      sys_err_fatal_null_ptr_exception();
    }
    /*lint -save -e774 Boolean within 'if' always evaluates to False */
    if (!is_top_phone)
    {
      CM_MSG_HIGH_1("set orig_mode %d based on ph_ptr",orig_mode);
      if( ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE &&
          CMPH_SS_NETWORK_SEL_MODE_PREF(cmph_map_cm_ss_to_subs(ss), ph_ptr)
                                          == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
      }
      else
      {
        orig_mode = ph_orig_top_ptr->orig->orig_mode;
      }
    }

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  }
  else
  {
   
    CM_MSG_HIGH_1("call activity. OPT HO: act_update_reas %d",
      ph_orig_top_ptr->orig->act_update_reas);

    if( ph_orig_top_ptr->orig->act_update_reas ==
                                            CM_ACT_UPDATE_REAS_ACT_PWR_SAVE )
    {
      pref_reas = SD_SS_PREF_REAS_USER;
      ph_orig_top_ptr->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_START;
      orig_mode = SD_SS_ORIG_MODE_NONE;
    }
    else if(ph_orig_top_ptr->orig->act_update_reas ==
                                            CM_ACT_UPDATE_REAS_ACT_END ||
            ph_orig_top_ptr->orig->act_update_reas ==
                                            CM_ACT_UPDATE_REAS_EMERG_ENTER )
    {
      pref_reas = SD_SS_PREF_REAS_ORIG_END;
      orig_mode =  ph_orig_top_ptr->orig->orig_mode;
    }
    else
    {
      pref_reas   = cmph_get_pref_reason( ph_orig_top_ptr->act_type);
      orig_mode =  ph_orig_top_ptr->orig->orig_mode;
    }

    CM_MSG_HIGH_2("cmph_force_orig_mode_on_ss, orig_mode %d, pref_reas %d",
                                                orig_mode, pref_reas);

  } /* ph obj */

  /* Dont expect any user_resel activity on HDR stack */
  if((ss != CM_SS_HYBR_1 && cmph_get_is_user_resel_buffered_ss(ss))
      && is_top_phone)
  {
    pref_reas = SD_SS_PREF_REAS_USER_RESEL;
    cmph_set_is_user_resel_buffered_ss(ss, FALSE);
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if (cmph_is_hybr2_toggled_on(ss))
  {
    ss = CM_SS_MAX;
  }

  CM_MSG_HIGH_3( "Call is to cmmsc_proc_cmd_pref_sys_chgd ss=%d, pref_reas=%d, pref_update_reason=%d",
                 ss, pref_reas,ph_orig_top_ptr->orig->pref_update_reason);

  cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue (
     ss,
     pref_reas,
     orig_mode,
     cmph_is_new_policy_apply(ss),
     ph_orig_top_ptr,
     CM_ACT_UPDATE_REAS_NONE,
     &cmd
     );

  cmmsimc_proc_cmd_pref_sys_chgd(&cmd);

  return;
}/* cmph_force_orig_mode_on_ss */

/*===========================================================================
FUNCTION cmph_calculate_new_srv_domain

DESCRIPTION
   If change in dedicated data/voice, update srv_domain_pref accordingly */
/* If change in default data subscription 
** - remove PS domain from the current default data sub
** - add PS domain to the new default data sub	 
  If required, we can return from this Fn some boolean to decide whether 'IMS for nonDDS feature' needs to be kicked-in

DEPENDENCIES

RETURN VALUE
  None
===========================================================================*/
void cmph_calculate_new_srv_domain
(
  cm_srv_domain_pref_e_type *new_ph_srv_domain_ptr,
  
  cm_srv_domain_pref_e_type *new_cmd_dds_srv_domain_ptr,

  sys_modem_as_id_e_type  cmd_info_dds
)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  if((cmpm_ptr()->ims_for_nondds == TRUE) && 
    ((CMPH_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS)||
    (CMPH_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr) == CM_SRV_DOMAIN_PREF_CS_ONLY)))
  {
    *new_ph_srv_domain_ptr = CM_SRV_DOMAIN_PREF_CS_PS;
  }
  else if(CMPH_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS)
  {
    *new_ph_srv_domain_ptr = CM_SRV_DOMAIN_PREF_CS_ONLY; 
  }
  else if((cmpm_ptr()->ims_for_nondds == TRUE) &&
    (CMPH_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY))
  {
    *new_ph_srv_domain_ptr = CM_SRV_DOMAIN_PREF_PS_ONLY; 
  }
  else if(CMPH_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY)
  {
    *new_ph_srv_domain_ptr = CM_SRV_DOMAIN_PREF_NONE;
  }
  else
  {
    *new_ph_srv_domain_ptr = CMPH_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr);
  }

  
  if(CMPH_SS_SRV_DOMAIN_PREF(cmd_info_dds, ph_ptr) == CM_SRV_DOMAIN_PREF_CS_ONLY)
  {
    *new_cmd_dds_srv_domain_ptr = CM_SRV_DOMAIN_PREF_CS_PS;
  }
  else if(CMPH_SS_SRV_DOMAIN_PREF(cmd_info_dds, ph_ptr) == CM_SRV_DOMAIN_PREF_NONE)
  {
    *new_cmd_dds_srv_domain_ptr = CM_SRV_DOMAIN_PREF_PS_ONLY;
  }
  else
  {
    *new_cmd_dds_srv_domain_ptr = CMPH_SS_SRV_DOMAIN_PREF(cmd_info_dds, ph_ptr);
  }

  return;
}

/*===========================================================================

FUNCTION cmph_force_orig_mode_on_the_fly

DESCRIPTION
  Unforce the origination mode on the fly

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void  cmph_force_orig_mode_on_the_fly(

    cm_ss_e_type      ss
        /* The ss on which the orig_mode is to be unforced */
)
{

   cmph_s_type      *ph_ptr        = cmph_ptr();
        /* Pointer to a phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );



  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Restore the phone preferences.
  */

  CM_MSG_HIGH_3("cmph_force_orig_mode_on_the_fly() ss = %d Restore mode=%d time=%ld",
              ss,CMPH_SS_MODE_PREF(cmph_map_cm_ss_to_subs(ss),
                                                ph_ptr), time_get_uptime_secs());

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (ss)
  {

    case CM_SS_MAIN:

      /* SS_MAIN instance was forced during origination, send the preferences to
      ** ss = SD_SS_MAIN
      */
      cmph_force_orig_mode_on_ss(CM_SS_MAIN, ph_ptr);
      break;

    case CM_SS_HYBR_2:

      /* SS_MAIN instance was forced during origination, send the preferences to
      ** ss = SD_SS_MAIN
      */
      cmph_force_orig_mode_on_ss(CM_SS_HYBR_2, ph_ptr);
      break;

     case CM_SS_HYBR_3:

      /* SS_MAIN instance was forced during origination, send the preferences to
      ** ss = SD_SS_MAIN
      */
      cmph_force_orig_mode_on_ss(CM_SS_HYBR_3, ph_ptr);
      break;

    case CM_SS_HDR:

      /* SS_HDR instance was forced during origination, send the preferences to
      ** ss = SD_SS_HYBR_HDR
      */
      cmph_force_orig_mode_on_ss(CM_SS_HDR, ph_ptr);
      break;


    case CM_SS_MAX:
      cmph_force_orig_mode_on_ss(CM_SS_MAX,  ph_ptr);
      break;

    default:
      CM_ERR_1("ss %d", ss);
      /*lint -save -e527 Unreachable
      **     CM_ERR exits when CM_DEBUG is on
      */
      CM_MSG_LOW_1("cmph_force_orig_mode_on_the_fly() on ss %d", ss);
      /* lint -restore */
      break;

  }/* Switch ss */

} /* cmph_force_orig_mode_on_the_fly() */


/*===========================================================================

FUNCTION cmph_cmd_standby_pref_proc

DESCRIPTION
  This function processes a network list confirmation event reported
  by the lower software layer.

   cmd: Primary cmd received from client which resulted in this procedure
   ret_val: True to force all subs chg


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static boolean cmph_cmd_standby_pref_proc_int(

  cm_ph_cmd_info_s_type       *cmd_info_ptr,

  cm_ph_cmd_e_type             cmd,

  cm_client_id_type            client_id,

  boolean                      is_cdma_subscription_available,

  boolean                      is_gwl_subscription_available,

  boolean                      is_hybr_gw_subscription_available,

  boolean                      is_hybr_gw3_subscription_available

)
{
  cmph_s_type                           *ph_ptr;

  cm_ph_cmd_info_s_type       *cmd_info_ptr1;
  cm_ph_cmd_s_type             *ph_cmd_ptr;

  cm_ss_e_type                          ss = CM_SS_MAX;

  #ifdef FEATURE_CM_DUAL_SIM_TUNEAWAY
  reg_cmd_type                          *reg_ptr;
    /* Pointer to REG command buffer  */

  boolean                               tune_away = FALSE;
  #endif /* FEATURE_CM_DUAL_SIM_TUNEAWAY */

  sys_modem_as_id_e_type          asubs_id = SYS_MODEM_AS_ID_NONE;
  #if defined(FEATURE_MMODE_TRIPLE_SIM)
  sys_modem_as_id_e_type                other_asubs_id = SYS_MODEM_AS_ID_NONE;
  #endif
  sys_modem_dual_standby_pref_e_type    new_standby_pref;

  sys_modem_as_id_e_type                curr_data_subs;
  boolean                               data_call_on_curr_data_subs = FALSE;
  cm_srv_domain_pref_e_type             new_ph_srv_domain = CM_SRV_DOMAIN_PREF_NONE;
  cm_srv_domain_pref_e_type             new_cmd_dds_srv_domain = CM_SRV_DOMAIN_PREF_NONE;

  #ifdef CM_GW_SUPPORTED
  reg_cmd_type                          *reg_ptr_dds_ind;
  #endif
  uint8                   i                 = 0;
  cm_ss_e_type ss_loop = CM_SS_MAIN;
  boolean is_force_pref_on_sub[2] = { TRUE, TRUE };

  boolean is_active_data_call = FALSE;
  boolean ret_status = FALSE;
  boolean int_dds_cmd = FALSE;

  if((cmd == CM_PH_CMD_DUAL_STANDBY_PREF) && (client_id == CM_CLIENT_ID_ANONYMOUS))
  {
    int_dds_cmd = TRUE;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT(cmd_info_ptr != NULL);

  ph_ptr      = cmph_ptr();

  /* Store new standby-pref into user_standby_pref as it is*/
  ph_ptr->user_standby_pref = cmd_info_ptr->standby_pref;

  /* Determine whether DDS switch is permanent and was preceded by a temporary switch */
  if(ph_ptr->dds_switch_type == DDS_CAUSE_TEMPORARY && 
     cmd_info_ptr->dds_switch_type == DDS_CAUSE_PERMANENT)
  {
    ph_ptr->is_dds_switchback_from_temp = TRUE;
  }
  
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Store current active subs into user_active_subs */
  ph_ptr->user_active_subs = ph_ptr->active_subs;

  /* If AUTO is the new standby mode or if MCFG override has to be done, derive the affective preference
  */
  if( cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_AUTO ||
      cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY ||
      ph_ptr->mcfg_deactivate_subs !=  SYS_MODEM_AS_ID_NO_ACTIVE_MASK
    )
  {
    uint8 no_of_active_sims = 0;
    cmd_info_ptr->active_subs = ph_ptr->active_subs;
    if (ph_ptr->mcfg_deactivate_subs)
    {
      CM_MSG_HIGH_3("MCFG: deact_subs %d, standby_pref %d, active_subs %d",
                    ph_ptr->mcfg_deactivate_subs,
                    cmd_info_ptr->standby_pref,
                    cmd_info_ptr->active_subs);
    }

    if( cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_AUTO ||
        cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY)
    {
    cmd_info_ptr->active_subs = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;
    /* When multiple subscriptions are available go into Dual Standby
    */
    #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    if( ( is_cdma_subscription_available ||
          is_gwl_subscription_available
        ) &&
        is_hybr_gw_subscription_available &&
        is_hybr_gw3_subscription_available)
    {
      cmd_info_ptr->active_subs |= BM(ph_ptr->main_stack_info.asubs_id);
      cmd_info_ptr->active_subs |= BM(ph_ptr->hybr_2_stack_info.asubs_id);
      cmd_info_ptr->active_subs |= BM(ph_ptr->hybr_3_stack_info.asubs_id);
    }
    else if (is_hybr_gw_subscription_available &&
             is_hybr_gw3_subscription_available)
    {
      cmd_info_ptr->active_subs |= BM(ph_ptr->hybr_2_stack_info.asubs_id);
      cmd_info_ptr->active_subs |= BM(ph_ptr->hybr_3_stack_info.asubs_id);
    }
    else if (( is_cdma_subscription_available ||
             is_gwl_subscription_available
             ) &&
             (is_hybr_gw3_subscription_available))
    {
      cmd_info_ptr->active_subs |= BM(ph_ptr->main_stack_info.asubs_id);
      cmd_info_ptr->active_subs |= BM(ph_ptr->hybr_3_stack_info.asubs_id);
    }
    /* Only Hybr GW3 subscription available, Go into SS on SUBS3 */
    else if ( is_hybr_gw3_subscription_available )
    {
      cmd_info_ptr->active_subs |= BM(ph_ptr->hybr_3_stack_info.asubs_id);
    }    
    else 
    #endif
    if( ( is_cdma_subscription_available ||
          is_gwl_subscription_available
        ) &&
        is_hybr_gw_subscription_available )
      {
      cmd_info_ptr->active_subs |= BM(ph_ptr->main_stack_info.asubs_id);
      cmd_info_ptr->active_subs |= BM(ph_ptr->hybr_2_stack_info.asubs_id);
    }
    /* Only Main subscription available, Go into SS on SUBS1 */
    else if (is_cdma_subscription_available ||
             is_gwl_subscription_available)
    {
      cmd_info_ptr->active_subs |= BM(ph_ptr->main_stack_info.asubs_id);
    }
    /* Only Hybr GW subscription available, Go into SS on SUBS2 */
    else if ( is_hybr_gw_subscription_available )
    {
      cmd_info_ptr->active_subs |= BM(ph_ptr->hybr_2_stack_info.asubs_id);
    }
    else
    {
      cmd_info_ptr->standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
      cmd_info_ptr->active_subs |= BM(ph_ptr->main_stack_info.asubs_id);
    }
    }// derive the standby pref for AUTO
    /* Update user_active_subs with current active subscription */
    ph_ptr->user_active_subs = cmd_info_ptr->active_subs;

    /* Take out from active_subs, the mcfg_deactivate_subs component */
    if (ph_ptr->mcfg_deactivate_subs )
    {
      cmd_info_ptr->active_subs = cmd_info_ptr->active_subs & ~ph_ptr->mcfg_deactivate_subs;
      CM_MSG_HIGH_1("MCFG: New active_subs %d",cmd_info_ptr->active_subs);
    }


    if(cmd_info_ptr->active_subs & SYS_MODEM_AS_ID_1_MASK)
      {
      no_of_active_sims++;
      }

    if(cmd_info_ptr->active_subs & SYS_MODEM_AS_ID_2_MASK)
      {
      no_of_active_sims++;
      }

    if(cmd_info_ptr->active_subs & SYS_MODEM_AS_ID_3_MASK)
    {
      no_of_active_sims++;
    }

    switch(no_of_active_sims)
    {
      case 1:
        cmd_info_ptr->standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
        break;

      case 2:
      /* Depending on tuneaway, set the standby preference accordingly */
      if( cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY ||
          cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY)
      {
        cmd_info_ptr->standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY;
      }
      else
      {
        cmd_info_ptr->standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
      }
        break;

      case 3:
        /* Depending on tuneaway, set the standby preference accordingly */
        if( cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY )
    {
          cmd_info_ptr->standby_pref = SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY;
    }
    else
    {
          cmd_info_ptr->standby_pref = SYS_MODEM_DS_PREF_TRIPLE_STANDBY;
        }
        break;

      default:
        cmd_info_ptr->standby_pref = SYS_MODEM_DS_PREF_NO_STANDBY_PREF;
        break;
    }
  }
  else
  {
    ph_ptr->user_active_subs = cmd_info_ptr->active_subs;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  new_standby_pref = cmd_info_ptr->standby_pref;

  #ifdef FEATURE_CM_DUAL_SIM_TUNEAWAY
  /* Determine the tune_away status to be sent to Reg */
  if (cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY)
  {
    tune_away = TRUE;
  }
  else if (cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY)
  {
    tune_away = FALSE;
    new_standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
  }
  #ifdef FEATURE_MMODE_TRIPLE_SIM
  else if (cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY)
  {
    tune_away = TRUE;
  }
  else if (cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY)
  {
    tune_away = FALSE;
    new_standby_pref           = SYS_MODEM_DS_PREF_TRIPLE_STANDBY;
  }
  #endif
  #else
  if (cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY)
  {
    new_standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
  }
  #endif /* FEATURE_CM_DUAL_SIM_TUNEAWAY */


    /* If the DDS sub is different from current data sub, end all the data calls */
  curr_data_subs = (ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY || ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY || (cmpmprx_get_num_of_active_data()== 2)) ? \
                            ph_ptr->default_data_subs: (ACTIVE_MASK_TO_AS_ID(ph_ptr->active_subs));

  if( cmd_info_ptr->default_data_subs != curr_data_subs )
  {
    ss = cmph_map_subs_to_ss(curr_data_subs);

  }
  else if(cmph_is_msim() && cmpmprx_get_num_of_active_data() != 2)
  {
    curr_data_subs = (cmd_info_ptr->default_data_subs == SYS_MODEM_AS_ID_1) ? SYS_MODEM_AS_ID_2 : SYS_MODEM_AS_ID_1;
    ss = cmph_map_subs_to_ss(curr_data_subs);
  }


  CM_MSG_HIGH_3("cmd_info_ptr->standby_pref=%d,ph_ptr->standby_pref=%d int_dds_cmd=%d",\
               cmd_info_ptr->standby_pref,ph_ptr->standby_pref,int_dds_cmd );
  CM_MSG_HIGH_3("cmd_info_ptr->internal_standby_pref=%d,ph_ptr->user_standby_pref=%d old_data_subs %d",\
               ph_ptr->internal_standby_pref,ph_ptr->user_standby_pref,curr_data_subs);


  if(ss != CM_SS_MAX)
  {
    if(cmcall_is_there_a_call_type ( ss,
                                     CM_CALL_TYPE_PS_DATA,
                                     CM_CALL_ID_INVALID ) != CM_CALL_ID_INVALID)
    {
      CM_MSG_HIGH_1("Active PS calls on ss %d", ss);
      is_active_data_call = TRUE;

      if(cmcall_is_no_call_in_gw_ps(ss) == FALSE )
      {
        CM_MSG_HIGH_1("Ending active PS calls on ss %d", ss);

        #if defined(FEATURE_GSM) || defined(FEATURE_WCDMA)
        {
          cmwcall_send_pdp_abort_req(ss);
        }
        #endif

      }
      #if (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900))
      /* do not force to SD yet because we do not know if PM will update the max_cap yet */
      cmcall_end_active_1x_datacalls_no_force();
      #endif

      cmcall_end_each_call_with_type_per_sub(CM_CALL_TYPE_DATA,
                                     CM_CALL_END_CLIENT_END,curr_data_subs);

      }
    if(ss == CM_SS_MAIN)
    {
      #if (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900))
      cmcall_end_active_HDR_datacalls();
      #endif
    }
  }

  /* Indicate PM about new DDS and active Subs
  ** This is done after ending the data calls so that the new policy will not be foreced while ending the calls
  */
  CM_MSG_HIGH_3("standby_chgd: Notify DDS/ACTIVE_SUBS to PM, user_active_subs %d, dds %d, dds_cause %d",
                 ph_ptr->user_active_subs,
                   cmd_info_ptr->default_data_subs,
                   cmd_info_ptr->dds_switch_type);

    cmpmprx_msim_subsc_changed(ph_ptr->user_active_subs,cmd_info_ptr->default_data_subs,cmd_info_ptr->dds_switch_type);

  if(ss != CM_SS_MAX)
  {

    /* Delete Data call pref from priority queue, which might be there
    ** for 4 sec after end of data call
    */
    if(cmtask_orig_para_search_act_type(ss,CM_ACT_TYPE_DATA_CALL) != NULL)
    {
       /* Entering here indicates that NAS was previous forced
       ** with CS+PS due to data preferences
       */
       data_call_on_curr_data_subs = TRUE;
       cmph_remove_orig_mode( ss, CM_ACT_TYPE_DATA_CALL, CM_ACT_PRIORITY_MAX );

    }

    cmph_remove_other_subs_act_priority_end(cmd_info_ptr->default_data_subs,FALSE, !cmpmprx_is_device_mask_set(PM_CHG_MAX_MODE_CAP,NULL));


	/* removing SMS act type from the priority queue which was kept in priority queue for 20 secs
	   for TL ACK, this prevents forcing new pref till that duration during MMS transfer and fails 
	   rat expansion */

    for(ss_loop = CM_SS_MAIN; ss_loop < CM_SS_MAX; ss_loop++)
    {
        if(cmtask_orig_para_search_act_type_act_priority( ss_loop, CM_ACT_TYPE_SMS_CALL, CM_ACT_PRIORITY_END)!= NULL)
        {
          CM_MSG_HIGH_1("removing SMS act priority end from subs %d",cmph_map_cm_ss_to_subs(ss_loop));
          cmph_remove_orig_mode_with_priority_end_per_subs(cmph_map_cm_ss_to_subs(ss_loop));
        }
    }


    if(cmtask_orig_para_search_act_type(CM_SS_HDR,CM_ACT_TYPE_DATA_CALL) != NULL)
    {
      cmph_remove_orig_mode( CM_SS_HYBR_1, CM_ACT_TYPE_DATA_CALL, CM_ACT_PRIORITY_MAX );
      /* Force CS_ONLY on the non-DDS sub */
	  CM_MSG_HIGH_0("cmph_force_orig_mode_on_ss on HYBRD1" );
      cmph_force_orig_mode_on_ss(CM_SS_HYBR_1, ph_ptr);
    }
  }

  cmph_calculate_new_srv_domain(&new_ph_srv_domain,&new_cmd_dds_srv_domain,cmd_info_ptr->default_data_subs);

  if( cmd_info_ptr->default_data_subs != ph_ptr->default_data_subs )
  {

    ss = cmph_map_subs_to_ss(ph_ptr->default_data_subs);

    #ifdef FEATURE_HDR
    /* Remove hdr if default data sub is not sub1 */
    if (cmd_info_ptr->default_data_subs != ph_ptr->main_stack_info.asubs_id &&
      cmcall_misc_is_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref,
                                CM_MODE_PREF_HDR_ONLY) &&
      !cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, ph_ptr->main_stack_info.asubs_id))
    {
      cmph_rat_disabled_mask_add(ph_ptr, SYS_SYS_MODE_HDR, ph_ptr->main_stack_info.asubs_id);
    }
    #endif

    if( CMPH_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr)
             == CM_SRV_DOMAIN_PREF_PS_ONLY ||
        CMPH_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr)
             == CM_SRV_DOMAIN_PREF_CS_PS ||
        data_call_on_curr_data_subs == TRUE ||
        (cmpm_ptr()->ims_for_nondds && (new_ph_srv_domain = CM_SRV_DOMAIN_PREF_CS_PS))
      )
    {
      /* For DSDX L+G,issue PS detach on ss if either of the sub has LTE in the mode_pref. */
      #ifdef FEATURE_MMODE_DUAL_SIM
      if (cmph_is_msim() && !cmpmprx_is_device_mask_set(PM_CHG_MAX_MODE_CAP,NULL) &&
          (cmph_is_user_mode_lte(ph_ptr->default_data_subs) ||
          cmph_is_user_mode_lte(cmd_info_ptr->default_data_subs)))
      {
        CM_MSG_HIGH_0( "Set dds_status to PS_DETACH_PENDING" );
        ph_ptr->dds_status = CMPH_DDS_STATUS_PS_DETACH_PENDING;
      }
      #endif

      CM_MSG_HIGH_4("Updating srv domain of curr dds %d to %d, ph_ptr domain_pref=%d, persis domain_pref=%d",
                    ph_ptr->default_data_subs,
                    new_ph_srv_domain,
                    CMPH_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr), 
                    CMPH_PRST_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr));
      ph_cmd_ptr = cm_cmd_alloc_ph_init();
      ph_cmd_ptr->client_id               = CM_CLIENT_ID_ANONYMOUS;
      ph_cmd_ptr->cmd                     = CM_PH_CMD_SYS_SEL_PREF;
      cmd_info_ptr1 = CMD_INFO_PTR( ph_cmd_ptr );
      cmd_info_ptr1->cmd_subs              = ph_ptr->default_data_subs;

      cmd_info_ptr1->mode_pref             = CMPH_SS_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->pref_term             = CM_PREF_TERM_PERMANENT;
      cmd_info_ptr1->pref_duration         = 0;
      cmd_info_ptr1->band_pref             = CMPH_SS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->lte_band_pref         = CMPH_SS_LTE_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->tds_band_pref         = CMPH_SS_TDS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->prl_pref              = CMPH_SS_PRL_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->roam_pref             = CMPH_SS_ROAM_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->hybr_pref             = CMPH_SS_HYBR_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
      cmd_info_ptr1->srv_domain_pref       = new_ph_srv_domain;
      cmd_info_ptr1->network_sel_mode_pref = CMPH_SS_NETWORK_SEL_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->sys_sel_pref_req_id   = 0;
      cmd_info_ptr1->ue_usage_setting = CMPH_SS_UE_USAGE_SETTING(cmd_info_ptr1->cmd_subs, ph_ptr);
      cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_UE_USAGE_SETTING);
      cmd_info_ptr1->csg_id                = SYS_CSG_ID_INVALID;
      cmd_info_ptr1->csg_rat               = SYS_RAT_NONE;
      cmd_info_ptr1->voice_domain_pref = CMPH_SS_VOICE_DOMAIN_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
      cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_VOICE_DOMAIN_PREF);
      cmd_info_ptr1->acq_order_pref = CMPH_SS_ACQ_ORDER_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      sys_plmn_undefine_plmn_id( &cmd_info_ptr1->plmn );

      if(cmpmprx_is_device_mask_set(PM_CHG_MAX_MODE_CAP,NULL))
      {
        cmph_process_domain_pref_chg(ph_cmd_ptr);
      }
      else
      {
        cmph_cmd_sys_sel_pref_proc(ph_cmd_ptr);
      }

      if(ph_ptr->default_data_subs == ph_ptr->main_stack_info.asubs_id)
      {
        ph_ptr->main_stack_info.pref_info.srv_domain_pref = new_ph_srv_domain;
      }
      else if(ph_ptr->default_data_subs == ph_ptr->hybr_2_stack_info.asubs_id)
      {
        ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref
                                        = new_ph_srv_domain;
      }
      #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
      else if(ph_ptr->default_data_subs == ph_ptr->hybr_3_stack_info.asubs_id)
      {
        ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref
                                        = new_ph_srv_domain;
      }
      #endif

      cmph_event_per_subs(ph_ptr,CM_PH_EVENT_SYS_SEL_PREF,
                          cmph_map_subs_to_ss(ph_ptr->default_data_subs));

      cm_cmd_dealloc(ph_cmd_ptr);

    }
    /* If policy change was updated to CM and not handled till now
    ** and there is no max mode capability change, handle it now
    */
    else if( !cmpmprx_is_device_mask_set(PM_CHG_MAX_MODE_CAP,NULL) &&
         cmpmprx_read_cm_policy_consumption_eligibility(ph_ptr->default_data_subs) &&
         cmpmprx_is_mask_set( ph_ptr->default_data_subs, PM_CHG_ALL, cmpm_ptr() )
       )
    {
      cmpmprx_enforce_current_policy(ph_ptr->default_data_subs);
    }
	if(( CMPH_PRST_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr)
             == CM_SRV_DOMAIN_PREF_PS_ONLY ||
        CMPH_PRST_SS_SRV_DOMAIN_PREF(ph_ptr->default_data_subs, ph_ptr)
             == CM_SRV_DOMAIN_PREF_CS_PS)  &&
	    (cmd_info_ptr->dds_switch_type == DDS_CAUSE_PERMANENT))
  { 

      CMPH_SET_PRST_SRV_DOMAIN_PREF( ph_ptr->default_data_subs, ph_ptr, \
                     new_ph_srv_domain);

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_item_ptr->service_domain_pref.srv_domain =
                                         (byte) new_ph_srv_domain;

      cmnv_item_ptr->service_domain_pref.nam        = (byte) ph_ptr->curr_nam;

      cmnv_write_extn( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
              CMPH_SS_NV_CONTEXT(ph_ptr->default_data_subs, ph_ptr));
      #endif

    }

    /* if the current default data subscription doesn't have PS service domain
    ** and the new default data is not same then add PS domain
    */
    if((CMPH_SS_SRV_DOMAIN_PREF(cmd_info_ptr->default_data_subs, ph_ptr)
             == CM_SRV_DOMAIN_PREF_CS_ONLY) || 
       (CMPH_SS_SRV_DOMAIN_PREF(cmd_info_ptr->default_data_subs, ph_ptr)
             == CM_SRV_DOMAIN_PREF_NONE) ||
       (cmpm_ptr()->change_in_ims_for_nondds))
    {
      CM_MSG_HIGH_2("Updating srv domain of asubs_id=%d to %d, adding PS",
                    cmd_info_ptr->default_data_subs,
                    new_cmd_dds_srv_domain);

      ph_cmd_ptr = cm_cmd_alloc_ph_init();
      ph_cmd_ptr->client_id               = CM_CLIENT_ID_ANONYMOUS;
      ph_cmd_ptr->cmd                     = CM_PH_CMD_SYS_SEL_PREF;
      cmd_info_ptr1 = CMD_INFO_PTR( ph_cmd_ptr );
      cmd_info_ptr1->cmd_subs              = cmd_info_ptr->default_data_subs;

      cmd_info_ptr1->mode_pref             = CMPH_SS_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->pref_term             = CM_PREF_TERM_PERMANENT;
      cmd_info_ptr1->pref_duration         = 0;
      cmd_info_ptr1->band_pref             = CMPH_SS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->lte_band_pref         = CMPH_SS_LTE_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->tds_band_pref         = CMPH_SS_TDS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->prl_pref              = CMPH_SS_PRL_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->roam_pref             = CMPH_SS_ROAM_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->hybr_pref             = CMPH_SS_HYBR_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
      cmd_info_ptr1->srv_domain_pref       = new_cmd_dds_srv_domain;
      cmd_info_ptr1->network_sel_mode_pref = CMPH_SS_NETWORK_SEL_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      cmd_info_ptr1->sys_sel_pref_req_id   = 0;
      cmd_info_ptr1->ue_usage_setting = CMPH_SS_UE_USAGE_SETTING(cmd_info_ptr1->cmd_subs, ph_ptr);
      cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_UE_USAGE_SETTING);
      cmd_info_ptr1->csg_id                = SYS_CSG_ID_INVALID;
      cmd_info_ptr1->csg_rat               = SYS_RAT_NONE;
      cmd_info_ptr1->voice_domain_pref = CMPH_SS_VOICE_DOMAIN_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
      cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_VOICE_DOMAIN_PREF);
      cmd_info_ptr1->acq_order_pref = CMPH_SS_ACQ_ORDER_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
      sys_plmn_undefine_plmn_id( &cmd_info_ptr1->plmn );

      if (cmph_is_subs_feature_mode_srlte(cmd_info_ptr1->cmd_subs))
      {
        ph_ptr->is_dds_change_on_svlte_sub = TRUE;
      }

      if(cmpmprx_is_device_mask_set(PM_CHG_MAX_MODE_CAP,NULL))
      {
        cmph_process_domain_pref_chg(ph_cmd_ptr);
      }
      else
      {
        cmph_cmd_sys_sel_pref_proc(ph_cmd_ptr);
        cmph_dds_update_cmd_mode_pref(cmd_info_ptr->default_data_subs, cmd_info_ptr1->mode_pref);
      }

      ph_ptr->is_dds_change_on_svlte_sub = FALSE;
      
      cmph_dds_update_srv_domain(cmd_info_ptr->default_data_subs, new_cmd_dds_srv_domain);
      
	  if(cmd_info_ptr->dds_switch_type == DDS_CAUSE_PERMANENT)
      {
      CMPH_SET_PRST_SRV_DOMAIN_PREF( cmd_info_ptr->default_data_subs, ph_ptr, \
                                     new_cmd_dds_srv_domain);

      CMPH_SET_PRST_MODE_PREF( cmd_info_ptr1->cmd_subs, ph_ptr, cmd_info_ptr1->mode_pref);

      cmnv_item_ptr->service_domain_pref.srv_domain =
                                                   (byte) new_cmd_dds_srv_domain;

      cmnv_item_ptr->service_domain_pref.nam        = (byte) ph_ptr->curr_nam;

      cmnv_write_extn( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
                        CMPH_SS_NV_CONTEXT(cmd_info_ptr->default_data_subs, ph_ptr));
	  }
      
      cmph_event_per_subs(ph_ptr,CM_PH_EVENT_SYS_SEL_PREF,
                          cmph_map_subs_to_ss(cmd_info_ptr->default_data_subs));

      cm_cmd_dealloc(ph_cmd_ptr);
    }
    
    #ifdef CM_GW_SUPPORTED

	/* Get reg cmd. buffer and populate params */
	reg_ptr_dds_ind =  cm_reg_get_buf_else_err_fatal( CM_DDS_SWITCH_IND );
	reg_ptr_dds_ind->cmd.cm_dds_switch_ind.target_dds_sub = cmd_info_ptr->default_data_subs;

	/* Send DDS Sub indication to Reg */
	cm_reg_send_cmd( reg_ptr_dds_ind );
    #endif
  }
  else if (ph_ptr->prst_dual_standby_pref.default_data_subs != cmd_info_ptr->default_data_subs &&
           cmd_info_ptr->dds_switch_type == DDS_CAUSE_PERMANENT)
  {
    // This will cater cases when DDS sub is not changed but only DDS type is changed
    // For ex. DDS switched  to same subs with permanent reason during MMS DOWNLOAD_H

    if(( CMPH_PRST_SS_SRV_DOMAIN_PREF(ph_ptr->prst_dual_standby_pref.default_data_subs, ph_ptr)
           == CM_SRV_DOMAIN_PREF_PS_ONLY ||
      CMPH_PRST_SS_SRV_DOMAIN_PREF(ph_ptr->prst_dual_standby_pref.default_data_subs, ph_ptr)
           == CM_SRV_DOMAIN_PREF_CS_PS))
    {

      CMPH_SET_PRST_SRV_DOMAIN_PREF( ph_ptr->prst_dual_standby_pref.default_data_subs, ph_ptr, \
                     new_ph_srv_domain);
    }

    CM_MSG_HIGH_2("update sub %d srv_domain to %d",cmd_info_ptr->default_data_subs,new_cmd_dds_srv_domain);
    if(( CMPH_PRST_SS_SRV_DOMAIN_PREF(cmd_info_ptr->default_data_subs, ph_ptr)
           == CM_SRV_DOMAIN_PREF_CS_ONLY ||
      CMPH_PRST_SS_SRV_DOMAIN_PREF(cmd_info_ptr->default_data_subs, ph_ptr)
           == CM_SRV_DOMAIN_PREF_NONE))
    {
    
      CMPH_SET_PRST_SRV_DOMAIN_PREF(cmd_info_ptr->default_data_subs, ph_ptr, \
                     new_cmd_dds_srv_domain);
    
      cmnv_item_ptr->service_domain_pref.srv_domain =
                                         (byte) new_cmd_dds_srv_domain;
  
      cmnv_item_ptr->service_domain_pref.nam        = (byte) ph_ptr->curr_nam;
    
      cmnv_write_extn( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
              CMPH_SS_NV_CONTEXT(cmd_info_ptr->default_data_subs, ph_ptr));

    }

  }

  if( cmd_info_ptr->default_voice_subs != ph_ptr->default_voice_subs )
  {
    if( CMPH_SS_SRV_DOMAIN_PREF(cmd_info_ptr->default_voice_subs, ph_ptr)
             != CM_SRV_DOMAIN_PREF_CS_ONLY ||
        CMPH_SS_SRV_DOMAIN_PREF(cmd_info_ptr->default_voice_subs, ph_ptr)
             != CM_SRV_DOMAIN_PREF_CS_PS)
    {
      CM_MSG_HIGH_1("new default voice subs with srv domain %d",
                   CMPH_SS_SRV_DOMAIN_PREF(cmd_info_ptr->default_voice_subs, ph_ptr));
    }
  }

  /*If there are no active voice or emergency call, then update curr voice subs
    else will be taken care at the end of the call*/
  if((cmcall_is_there_a_call_type(CM_SS_MAX,CM_CALL_TYPE_VOICE,
                                 CM_CALL_ID_INVALID) == CM_CALL_ID_INVALID)&&
      (cmcall_is_there_a_call_type(CM_SS_MAX,CM_CALL_TYPE_EMERGENCY,
                                 CM_CALL_ID_INVALID) == CM_CALL_ID_INVALID))
  {
    ph_ptr->curr_voice_subs = cmd_info_ptr->default_voice_subs;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update current priority subs with new one */
  if( BETWEEN(cmd_info_ptr->priority_subs, SYS_MODEM_AS_ID_NONE, SYS_MODEM_AS_ID_MAX) && 
      cmd_info_ptr->priority_subs != ph_ptr->priority_subs)
  {
    ph_ptr->curr_priority_subs = cmd_info_ptr->priority_subs;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the standby preference have changed */
  /* Assuming that the cmd is rejected if standby pref is sent as dual when
  ** only 1 subscription is available.
  */
  if ( new_standby_pref != ph_ptr->internal_standby_pref)
  {
     CM_MSG_HIGH_2("dsds_to_tsts: new_standby_pref  %d, internal_standby_pref %d",new_standby_pref,ph_ptr->internal_standby_pref);
    #ifdef FEATURE_MMODE_TRIPLE_SIM
    if ( (new_standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY && ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY) ||
         (new_standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY && ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY))
    {

         /* Send the PS release indication to NAS
       */
      sm_cmd_type *sm_ptr = cm_sm_get_buf_else_err_fatal(SMREG_PS_SIGNALING_REL_REQ);
      cm_ss_e_type dds_ss = CM_SS_NONE;
      sm_ptr->cmd.ps_signalling_rel_req.as_id = ph_ptr->default_data_subs;
      sm_ptr->cmd.ps_signalling_rel_req.cause = SMREG_DUAL_TRIPLE_STANDBY_CHANGE;

      cm_sm_send_cmd( sm_ptr );

      CM_MSG_HIGH_2("dsds_to_tsts: sending PS rel req: SMREG_DUAL_TRIPLE_STANDBY_CHANGE sent on SubsId %d dds_ss %d", ph_ptr->default_data_subs, dds_ss);

      dds_ss = cmph_map_subs_to_ss(ph_ptr->default_data_subs);

      /* Update the data suspend state in CM
          */
      #ifdef FEATURE_MMODE_TRIPLE_SIM
      if( dds_ss == CM_SS_HYBR_3 )
      {
        cmss_process_hybr_3_data_suspend_rpt(TRUE);
      }
      else
      #endif
      if( dds_ss == CM_SS_HYBR_2 )
      {
        cmss_process_hybr_2_data_suspend_rpt(TRUE);
      }
      else
      {
        cmss_process_data_suspend_rpt(TRUE);
      }

      cmss_ptr()->ue_init_ps_data_suspend = dds_ss;
      cmss_ptr()->ue_init_ps_data_suspend_cause = CM_SMREG_DUAL_TRIPLE_STANDBY_CHANGE;
    }
    #endif

    CM_MSG_HIGH_2("dsds_to_tsts: ue_init_ps_data_suspend_cause %d, ue_init_ps_data_suspend %d",
                                    cmss_ptr()->ue_init_ps_data_suspend_cause,
    cmss_ptr()->ue_init_ps_data_suspend );

    ph_ptr->internal_standby_pref = new_standby_pref;

    /* Update the pref2 state machine based on the standby preferences
    */
    cmmsimc_proc_cmd_standby_pref_chgd( new_standby_pref,
                                        cmd_info_ptr->active_subs,
                                        is_cdma_subscription_available,
                                        is_gwl_subscription_available,
                                        is_hybr_gw_subscription_available,
                                        is_hybr_gw3_subscription_available,
                                        int_dds_cmd
                                      );

    /* if standby preference is Dual Standby, verify if the service domain is
    ** in sync with the Default Voice and Default Data.
    */
    if ((new_standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY || \
        new_standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY)
    && cmd_info_ptr->default_data_subs == ph_ptr->default_data_subs )
    {

      switch(cmd_info_ptr->default_data_subs)
      {
        case SYS_MODEM_AS_ID_1:
          asubs_id = SYS_MODEM_AS_ID_2;
          #ifdef FEATURE_MMODE_TRIPLE_SIM
          other_asubs_id = SYS_MODEM_AS_ID_3;
          #endif
          break;

        case SYS_MODEM_AS_ID_2:
          asubs_id = SYS_MODEM_AS_ID_1;
          #ifdef FEATURE_MMODE_TRIPLE_SIM
          other_asubs_id = SYS_MODEM_AS_ID_3;
          #endif
          break;
        #ifdef FEATURE_MMODE_TRIPLE_SIM
        case SYS_MODEM_AS_ID_3:
          asubs_id = SYS_MODEM_AS_ID_1;
          other_asubs_id = SYS_MODEM_AS_ID_2;
          break;
        #endif
        default:
        CM_MSG_HIGH_1("cmd_info_ptr->default_data_subs= %d",
                   cmd_info_ptr->default_data_subs);
        break;

      }
      /* if the other subscription has PS enabled, remove PS from domain pref
      */
      if( CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
          CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS ||
          CMPH_PRST_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
          CMPH_PRST_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS
        )
      {
        CM_MSG_HIGH_5("DDS %d: SS to DS Updating srv domain of asubs_id %d to %d,ph_ptr domain_pref=%d, persis domain_pref=%d", 
                      ph_ptr->default_data_subs,asubs_id,new_ph_srv_domain,
                      CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr),
                    CMPH_PRST_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr));

        ph_cmd_ptr = cm_cmd_alloc_ph_init();
        ph_cmd_ptr->client_id               = CM_CLIENT_ID_ANONYMOUS;
        ph_cmd_ptr->cmd                     = CM_PH_CMD_SYS_SEL_PREF;
        cmd_info_ptr1 = CMD_INFO_PTR( ph_cmd_ptr );
        cmd_info_ptr1->cmd_subs              = asubs_id;

        cmd_info_ptr1->mode_pref             = CMPH_SS_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->pref_term             = CM_PREF_TERM_PERMANENT;
        cmd_info_ptr1->pref_duration         = 0;
        cmd_info_ptr1->band_pref             = CMPH_SS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->lte_band_pref         = CMPH_SS_LTE_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->tds_band_pref         = CMPH_SS_TDS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->prl_pref              = CMPH_SS_PRL_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->roam_pref             = CMPH_SS_ROAM_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->hybr_pref             = CMPH_SS_HYBR_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);

        /* For no domain change, we can ignore this for SS->DS but let's keep it*/
        if((cmpm_ptr()->ims_for_nondds == TRUE))
        {
          cmd_info_ptr1->srv_domain_pref       = new_ph_srv_domain;
        }
        else if( CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
          CMPH_PRST_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY
        )
        {
          cmd_info_ptr1->srv_domain_pref       = CM_SRV_DOMAIN_PREF_NONE;
        }
        else
        {
          cmd_info_ptr1->srv_domain_pref       = CM_SRV_DOMAIN_PREF_CS_ONLY;
        }
        cmd_info_ptr1->network_sel_mode_pref = CMPH_SS_NETWORK_SEL_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->sys_sel_pref_req_id   = 0;
        cmd_info_ptr1->ue_usage_setting = CMPH_SS_UE_USAGE_SETTING(cmd_info_ptr1->cmd_subs, ph_ptr);
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_UE_USAGE_SETTING);
        cmd_info_ptr1->csg_id                = SYS_CSG_ID_INVALID;
        cmd_info_ptr1->csg_rat               = SYS_RAT_NONE;
        cmd_info_ptr1->voice_domain_pref = CMPH_SS_VOICE_DOMAIN_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_VOICE_DOMAIN_PREF);
        cmd_info_ptr1->acq_order_pref = CMPH_SS_ACQ_ORDER_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        sys_plmn_undefine_plmn_id( &cmd_info_ptr1->plmn );

        if(cmpmprx_is_device_mask_set(PM_CHG_MAX_MODE_CAP,NULL))
        {
          cmph_process_domain_pref_chg(ph_cmd_ptr);
        }
        else
        {
          cmph_cmd_sys_sel_pref_proc(ph_cmd_ptr);
          cmph_dds_update_cmd_mode_pref(asubs_id, cmd_info_ptr1->mode_pref);
        }

        cmph_dds_update_srv_domain(asubs_id, cmd_info_ptr1->srv_domain_pref);

        CMPH_SET_PRST_SRV_DOMAIN_PREF( asubs_id, ph_ptr, \
                                               cmd_info_ptr1->srv_domain_pref);

        #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
        cmnv_item_ptr->service_domain_pref.srv_domain =
                                               (byte) cmd_info_ptr1->srv_domain_pref;

        cmnv_item_ptr->service_domain_pref.nam        = (byte) ph_ptr->curr_nam;

        cmnv_write_extn( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
                  CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr));
        #endif

        cmph_event_per_subs(ph_ptr,CM_PH_EVENT_SYS_SEL_PREF,
                         cmph_map_subs_to_ss(asubs_id));
        cm_cmd_dealloc(ph_cmd_ptr);
      }
      #if defined(FEATURE_MMODE_TRIPLE_SIM)
      if( (CMPH_SS_SRV_DOMAIN_PREF(other_asubs_id, ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY ||
          CMPH_SS_SRV_DOMAIN_PREF(other_asubs_id, ph_ptr) == CM_SRV_DOMAIN_PREF_CS_PS) &&
          cmph_is_tsts()
        )
      {
        CM_MSG_HIGH_1("Updating srv domain of subs id %d to CS_ONLY", other_asubs_id);
        /* Queue a command to CM changing service domain preference to CS */
        ph_cmd_ptr = cm_cmd_alloc_ph_init();
        ph_cmd_ptr->client_id               = CM_CLIENT_ID_ANONYMOUS;
        ph_cmd_ptr->cmd                     = CM_PH_CMD_SYS_SEL_PREF;
        cmd_info_ptr1 = CMD_INFO_PTR( ph_cmd_ptr );
        cmd_info_ptr1->cmd_subs              = other_asubs_id;

        cmd_info_ptr1->mode_pref             = CMPH_SS_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->pref_term             = CM_PREF_TERM_PERMANENT;
        cmd_info_ptr1->pref_duration         = 0;
        cmd_info_ptr1->band_pref             = CMPH_SS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->lte_band_pref         = CMPH_SS_LTE_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->tds_band_pref         = CMPH_SS_TDS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->prl_pref              = CMPH_SS_PRL_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->roam_pref             = CMPH_SS_ROAM_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->hybr_pref             = CMPH_SS_HYBR_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
        if(CMPH_SS_SRV_DOMAIN_PREF(other_asubs_id, ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY)
        {
          cmd_info_ptr1->srv_domain_pref       = CM_SRV_DOMAIN_PREF_NONE;
        }
        else
        {
          cmd_info_ptr1->srv_domain_pref       = CM_SRV_DOMAIN_PREF_CS_ONLY;
        }
        cmd_info_ptr1->network_sel_mode_pref = CMPH_SS_NETWORK_SEL_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->sys_sel_pref_req_id   = 0;
        cmd_info_ptr1->ue_usage_setting = CMPH_SS_UE_USAGE_SETTING(cmd_info_ptr1->cmd_subs, ph_ptr);
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_UE_USAGE_SETTING);
        cmd_info_ptr1->csg_id                = SYS_CSG_ID_INVALID;
        cmd_info_ptr1->csg_rat               = SYS_RAT_NONE;
        cmd_info_ptr1->voice_domain_pref = CMPH_SS_VOICE_DOMAIN_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_VOICE_DOMAIN_PREF);
        cmd_info_ptr1->acq_order_pref = CMPH_SS_ACQ_ORDER_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        sys_plmn_undefine_plmn_id( &cmd_info_ptr1->plmn );

        if(cmpmprx_is_device_mask_set(PM_CHG_MAX_MODE_CAP,NULL))
        {
          cmph_process_domain_pref_chg(ph_cmd_ptr);
        }
        else
        {
          cmph_cmd_sys_sel_pref_proc(ph_cmd_ptr);
          cmph_dds_update_cmd_mode_pref(other_asubs_id, cmd_info_ptr1->mode_pref);
        }

        cmph_dds_update_srv_domain(other_asubs_id, cmd_info_ptr1->srv_domain_pref);

      CMPH_SET_PRST_SRV_DOMAIN_PREF( other_asubs_id, ph_ptr, \
                                               cmd_info_ptr1->srv_domain_pref);

        #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
        cmnv_item_ptr->service_domain_pref.srv_domain =
                                               (byte) cmd_info_ptr1->srv_domain_pref;

        cmnv_item_ptr->service_domain_pref.nam        = (byte) ph_ptr->curr_nam;

        cmnv_write_extn( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
                  CMPH_SS_NV_CONTEXT(other_asubs_id, ph_ptr));
        #endif

        cmph_event_per_subs(ph_ptr,CM_PH_EVENT_SYS_SEL_PREF,
                         cmph_map_subs_to_ss(other_asubs_id));
        cm_cmd_dealloc(ph_cmd_ptr);
      }

      #endif

      /* if the current default data subscription does not have PS service domain
      ** then add PS
      */
      if( CMPH_SS_SRV_DOMAIN_PREF(cmd_info_ptr->default_data_subs, ph_ptr)
               == CM_SRV_DOMAIN_PREF_CS_ONLY 
        || CMPH_SS_SRV_DOMAIN_PREF(cmd_info_ptr->default_data_subs, ph_ptr)
               == CM_SRV_DOMAIN_PREF_NONE)
      {
      CM_MSG_HIGH_2("Updating srv domain of asubs_id=%d to %d, adding PS",
                     cmd_info_ptr->default_data_subs,
                     new_cmd_dds_srv_domain);

        ph_cmd_ptr = cm_cmd_alloc_ph_init();
        ph_cmd_ptr->client_id               = CM_CLIENT_ID_ANONYMOUS;
        ph_cmd_ptr->cmd                     = CM_PH_CMD_SYS_SEL_PREF;
        cmd_info_ptr1 = CMD_INFO_PTR( ph_cmd_ptr );
        cmd_info_ptr1->cmd_subs              = cmd_info_ptr->default_data_subs;

        cmd_info_ptr1->mode_pref             = CMPH_SS_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->pref_term             = CM_PREF_TERM_PERMANENT;
        cmd_info_ptr1->pref_duration         = 0;
        cmd_info_ptr1->band_pref             = CMPH_SS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->lte_band_pref         = CMPH_SS_LTE_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->tds_band_pref         = CMPH_SS_TDS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->prl_pref              = CMPH_SS_PRL_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->roam_pref             = CMPH_SS_ROAM_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->hybr_pref             = CMPH_SS_HYBR_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
        cmd_info_ptr1->srv_domain_pref       = new_cmd_dds_srv_domain;
        cmd_info_ptr1->network_sel_mode_pref = CMPH_SS_NETWORK_SEL_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        cmd_info_ptr1->sys_sel_pref_req_id   = 0;
        cmd_info_ptr1->ue_usage_setting = CMPH_SS_UE_USAGE_SETTING(cmd_info_ptr1->cmd_subs, ph_ptr);
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_UE_USAGE_SETTING);
        cmd_info_ptr1->csg_id                = SYS_CSG_ID_INVALID;
        cmd_info_ptr1->csg_rat               = SYS_RAT_NONE;
        cmd_info_ptr1->voice_domain_pref = CMPH_SS_VOICE_DOMAIN_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
        cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_VOICE_DOMAIN_PREF);
        cmd_info_ptr1->acq_order_pref = CMPH_SS_ACQ_ORDER_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
        sys_plmn_undefine_plmn_id( &cmd_info_ptr1->plmn );

        if (cmph_is_subs_feature_mode_srlte(cmd_info_ptr1->cmd_subs))
        {
          ph_ptr->is_dds_change_on_svlte_sub = TRUE;
        }

        if(cmpmprx_is_device_mask_set(PM_CHG_MAX_MODE_CAP,NULL))
        {
          cmph_process_domain_pref_chg(ph_cmd_ptr);
        }
        else
        {
          cmph_cmd_sys_sel_pref_proc(ph_cmd_ptr);
          cmph_dds_update_cmd_mode_pref(cmd_info_ptr->default_data_subs, cmd_info_ptr1->mode_pref);
        }

        ph_ptr->is_dds_change_on_svlte_sub = FALSE;
        cmph_dds_update_srv_domain(cmd_info_ptr->default_data_subs, new_cmd_dds_srv_domain);
        
         CMPH_SET_PRST_SRV_DOMAIN_PREF( cmd_info_ptr->default_data_subs, ph_ptr, \
                                  new_cmd_dds_srv_domain);

         cmnv_item_ptr->service_domain_pref.srv_domain =
                                               (byte) new_cmd_dds_srv_domain;

         cmnv_item_ptr->service_domain_pref.nam      = (byte) ph_ptr->curr_nam;

         cmnv_write_extn( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
                 CMPH_SS_NV_CONTEXT(cmd_info_ptr->default_data_subs, ph_ptr));

         cmph_event_per_subs(ph_ptr,CM_PH_EVENT_SYS_SEL_PREF,
                         cmph_map_subs_to_ss(cmd_info_ptr->default_data_subs));
         cm_cmd_dealloc(ph_cmd_ptr);

      }
    } /* cmd_info_ptr->default_data_subs == ph_ptr->default_data_subs */
  } /* new_standby_pref != cmpref2_info_ptr->standby_pref */
  /* If the standby preference is Single Standby and the active subs has
  ** changed
  ** Update the hybr_pref to reflect the same
  */
  else if ( new_standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY &&
            cmd_info_ptr->active_subs != ph_ptr->active_subs )
  {
    /* Update default data/voice subscriptions to the active subscription */
    //cmd_info_ptr->default_data_subs = cmd_info_ptr->active_subs;
    //cmd_info_ptr->default_voice_subs = cmd_info_ptr->active_subs;

    /* Send the command to MMOC
    */
    CM_MSG_HIGH_2("Device is in SS, only ss changed, old %d, new %d",cmd_info_ptr->active_subs,
      ph_ptr->active_subs);
    
    cmmsimc_proc_cmd_standby_pref_chgd( new_standby_pref,
                                        cmd_info_ptr->active_subs,
                                        is_cdma_subscription_available,
                                        is_gwl_subscription_available,
                                        is_hybr_gw_subscription_available,
                                        is_hybr_gw3_subscription_available,
                                        int_dds_cmd
                                      );

  }
  #ifdef FEATURE_CM_DUAL_SIM_TUNEAWAY
  /*Tune-away applicable only when in multi-standby*/
  if(new_standby_pref != SYS_MODEM_DS_PREF_SINGLE_STANDBY
   && new_standby_pref != SYS_MODEM_DS_PREF_NO_STANDBY_PREF)
  {
    /* Get reg cmd. buffer and populate params */
    reg_ptr =  cm_reg_get_buf_else_err_fatal( CM_DS_TUNEAWAY_STATUS_CHANGE_IND );
    reg_ptr->cmd.cm_ds_tuneaway_stat_chgd_ind.tuneaway_status = tune_away;
  
    /* Send tune away status to Reg */
    cm_reg_send_cmd( reg_ptr );
  }
  #endif /* FEATURE_CM_DUAL_SIM_TUNEAWAY */
  if( ph_ptr->active_subs & BM(SYS_MODEM_AS_ID_1)
	  &&
	  ((is_gwl_subscription_available != ph_ptr->is_gwl_subscription_available)
	  || 
	  ( is_cdma_subscription_available != ph_ptr->is_cdma_subscription_available))
	 )
    {
	  is_force_pref_on_sub[0] = FALSE;
    }

    if(cmph_is_sxlte())
	{
      if( ( BM(SYS_MODEM_AS_ID_2) & ph_ptr->active_subs )
	  &&
	  (is_hybr_gw3_subscription_available != ph_ptr->is_hybr_gw3_subscription_available)
	  )
      {
	    is_force_pref_on_sub[1] = FALSE;
      }
	}
	else
	{
      if( ( BM(SYS_MODEM_AS_ID_2) & ph_ptr->active_subs )
	       &&
	       (is_hybr_gw_subscription_available != ph_ptr->is_hybr_gw_subscription_available)
	       )
           {
	         is_force_pref_on_sub[1] = FALSE;
           }	
	 }


  /* Handle max capability change */
  if(cmpmprx_is_device_mask_set(PM_CHG_MAX_MODE_CAP,NULL))
  {
    CM_MSG_HIGH_0("DDS/ACTIVE_SS: maxcap mask set");
    /* If standby pref chgd transaction, always force subs chgd here. Otherwise only if DDS only changed */
    /* Use user active subs as MCFG refresh deactivate subs cmd cannot enforce subs changed */
    if(cmd == CM_PH_CMD_DUAL_STANDBY_PREF || ph_ptr->user_active_subs == ph_ptr->active_subs)
    {
      cmpmprx_enforce_device_policy(PM_CHG_MAX_MODE_CAP|PM_CHG_DEVICE_MODE);
    }
    else
    {
      cmpmprx_enforce_device_policy(PM_CHG_DEVICE_MODE);
      ret_status = TRUE;
    }
  }
  else
  {
	
	/* Loop thru the subs_ids (except for sub id for which sub is updated, as for 
     this sub policy will be pushed eventually) 
     and see if any policy changed. If yes then enforce*/

    for ( i=0;i<cmpm_ptr()->device_mode.nSims;i++ )
    {
      if ( cmpmprx_is_mask_set( i, PM_CHG_ALL, cmpm_ptr() ) 
           && (( BM(i) & ph_ptr->active_subs ) || (cmpmprx_is_mask_set( i, PM_CHG_SVC_SCAN, cmpm_ptr() ))))
      {
		  if(i == SYS_MODEM_AS_ID_1)
		  { 
            if(is_force_pref_on_sub[0])
			{
		      CM_MSG_HIGH_1("enforcing policy for sub: %d",i);
		      cmpmprx_enforce_current_policy(i);
			}
		  }
		  else if(i == SYS_MODEM_AS_ID_2)
		  {
			if(is_force_pref_on_sub[1])
			{
		      CM_MSG_HIGH_1("enforcing policy for sub: %d",i);
		      cmpmprx_enforce_current_policy(i);
			}
		  }
      }
    }
  }

  // Reset it after enforcing device and current policies if any.
  cmpm_ptr()->change_in_ims_for_nondds = FALSE;

  return ret_status;
} /* cmph_cmd_standby_pref_proc */
/*===========================================================================

FUNCTION cmph_cmd_standby_pref_proc

DESCRIPTION
  This function processes a network list confirmation event reported
  by the lower software layer.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_standby_pref_proc(

  cm_ph_cmd_s_type            *ph_cmd_ptr

)
{
  cm_ph_cmd_info_s_type       *cmd_info_ptr    = NULL;
      /* Point at command information component */

  cmph_s_type                 *ph_ptr;

  CM_MSG_LOW_1("START cmph_cmd_standby_pref_proc(),cmd=%d",ph_cmd_ptr->cmd);


  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );
  ph_ptr      = cmph_ptr();

  cmph_cmd_standby_pref_proc_int(cmd_info_ptr,
                ph_cmd_ptr->cmd,
                ph_cmd_ptr->client_id,
                ph_ptr->is_cdma_subscription_available,
                ph_ptr->is_gwl_subscription_available,
                ph_ptr->is_hybr_gw_subscription_available,
                ph_ptr->is_hybr_gw3_subscription_available

        );

}

#ifdef FEATURE_MRU_UPDATE
/*===========================================================================

FUNCTION cmph_cmd_sdprl_mru_update_proc

DESCRIPTION
  This function processes a command to update the indexth record of MRU buffer.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_sdprl_mru_update_proc(

  const cm_ph_cmd_s_type            *ph_cmd_ptr
  /* Pointer to Ph obj */

)
{

  cmph_s_type              *ph_ptr     = cmph_ptr();
  boolean                  updated;
      /* Point at phone object */

  CM_ASSERT( ph_cmd_ptr != NULL );
  CM_ASSERT( ph_ptr  != NULL );

  CM_MSG_LOW_1("START cmph_cmd_sdprl_mru_update_proc(),cmd=%d",ph_cmd_ptr->cmd);

  if( ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE)
  {
    updated = sd_misc_mru_update((sd_mmode_mru_table_entry_u_type *)&(ph_cmd_ptr->info.mru_table),
                              ph_cmd_ptr->info.index,
                              ph_cmd_ptr->info.mode,
                              (sd_mru_update_e_type)ph_cmd_ptr->info.mru_update_e_type
                             );

    if(ph_cmd_ptr->cmd_cb_func != NULL)
    {
    if(!updated)
  {
    ph_cmd_ptr->cmd_cb_func(NULL,CM_PH_CMD_MRU_UPDATE,CM_PH_CMD_ERR_BAND_PREF_P);
    }
  else
  {
    ph_cmd_ptr->cmd_cb_func(NULL,CM_PH_CMD_MRU_UPDATE,CM_PH_CMD_ERR_NOERR);
  }
    }
  }
}
/*===========================================================================

FUNCTION cmph_cmd_sdprl_read_mru

DESCRIPTION
  This function processes a command to Read the indexth record form MRU buffer & update the client with data.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_sdprl_read_mru_proc(

  const cm_ph_cmd_s_type            *ph_cmd_ptr
  /* Pointer to Ph obj */

)
{

  CM_ASSERT( ph_cmd_ptr != NULL );

  CM_MSG_LOW_1("START cmph_cmd_sdprl_read_mru_proc(),cmd=%d",ph_cmd_ptr->cmd);

  sd_misc_read_mru((sd_mmode_mru_table_entry_u_type*)ph_cmd_ptr->data_block_ptr,ph_cmd_ptr->info.index);

  if(ph_cmd_ptr->cmd_cb_func != NULL)
  {
     ph_cmd_ptr->cmd_cb_func((void *)ph_cmd_ptr->data_block_ptr,CM_PH_CMD_READ_MRU,CM_PH_CMD_ERR_NOERR);
  }


}


#endif
#ifdef FEATURE_CM_LTE
/*===========================================================================

FUNCTION cmph_cmd_plmn_blocking_proc

DESCRIPTION
  This function processes a command to do detach, and/or PLMN blocking, or PLMN unblocking.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_plmn_blocking_proc(

  cm_ph_cmd_s_type            *ph_cmd_ptr

)
{
  cm_ph_cmd_info_s_type       *cmd_info_ptr    = NULL;
    /* Point at command information component */

  cmph_s_type                 *ph_ptr;

  cmss_s_type                 *ss_ptr          = cmss_ptr();

  cm_ss_e_type                ss               = CM_SS_MAIN;
  /* SS on which to send the detach request */
  sys_modem_as_id_e_type      asubs_id = cmph_map_cm_ss_to_subs(ss);

  reg_cmd_type                *reg_ptr;
    /* Pointer to REG command buffer*/
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_cmd_ptr != NULL );

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_MSG_LOW_1("START cmph_cmd_plmn_blocking_proc(),cmd=%d",ph_cmd_ptr->cmd);

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );
  ph_ptr           = cmph_ptr();

  #ifdef FEATURE_MMODE_DUAL_SIM
  ss = cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);
  #endif

  if(  cmph_is_subs_feature_mode_1x_sxlte(asubs_id) &&
      ss_ptr->info.is_hybr_gw_operational 
      #if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE) || defined(FEATURE_TDSCDMA)
       && cmregprx_get_info_ptr()->stack_info[1].state == CMREGPRX_STATE_ACTIVE
      #endif
    )
  {
    ss = CM_SS_HYBR_2;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_6( "PLMN_BLOCK: request_type %d, blocking_interval %d ss %d plmn %d %d %d",
                          cmd_info_ptr->request_pref,
                          cmd_info_ptr->blocking_interval,
                          ss,
                          cmd_info_ptr->plmn.identity[0],
                          cmd_info_ptr->plmn.identity[1],
                          cmd_info_ptr->plmn.identity[2]);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch(cmd_info_ptr->request_pref)
  {
    case CM_PLMN_BLOCKING_PREF_LTE_DETACH_ONLY:
      /* Send detach request to NAS */
      ph_ptr->is_ps_detach_required = TRUE;

      /* This call fakes the user sending the current phone preferences down.
      ** When this happens, the detach request will be sent to NAS.
      */
    (void)cmph_force_pref_on_the_fly2( ss,
                                    ph_ptr,
                                    SD_SS_PREF_REAS_USER,
                                    CM_ACT_TYPE_PH_OBJ,
                                    ph_ptr->main_stack_info.pref_info.pref_term,
                                    ph_ptr->main_stack_info.pref_info.mode_pref,
                                    ph_ptr->main_stack_info.pref_info.band_pref,
                                    ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                    ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                    ph_ptr->main_stack_info.pref_info.prl_pref,
                                    ph_ptr->main_stack_info.pref_info.roam_pref,
                                    ph_ptr->main_stack_info.pref_info.hybr_pref,
                                    ph_ptr->main_stack_info.pref_info.plmn,
                                    ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                    ph_ptr->main_stack_info.pref_info.acq_order_pref,
                                    ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                                    &(CMPH_HYBR_2_PREF(ph_ptr)),
                                    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
                                    &(CMPH_HYBR_3_PREF(ph_ptr)),
                                    #endif
                                    CM_OTASP_ACT_CODE_NONE,
                                    (cm_act_id_type)ph_ptr,
                                    CM_ACT_UPDATE_REAS_USER,
                                    #if defined(FEATURE_MMODE_SC_SGLTE) || defined(FEATURE_MMODE_SC_SVLTE)
                                    !(cmpmprx_enforce_policy_oprt_mode(SYS_MODEM_AS_ID_1)),//cmd_info_ptr->cmd_subs)),
                                    #else
                                    TRUE,
                                    #endif
                                    cmph_get_acq_pri_order_per_sub(ss),
                                    CM_DEFAULT_VALUE,
                                    ph_ptr->main_stack_info.pref_info.csg_id,
                                    ph_ptr->main_stack_info.pref_info.csg_rat);
      break;

    case CM_PLMN_BLOCKING_PREF_PLMN_BLOCKING_ONLY:
      /* Get reg cmd. buffer and populate params.*/
      reg_ptr =  cm_reg_get_buf_else_err_fatal( CM_BLOCK_PLMN_REQ );

      /* Fill in parameters. */
      reg_ptr->cmd.cm_block_plmn_req.type = SYS_BLOCK_PLMN_BLOCK;
      reg_ptr->cmd.cm_block_plmn_req.plmn = cmd_info_ptr->plmn;
      reg_ptr->cmd.cm_block_plmn_req.timer_count = \
        cmd_info_ptr->blocking_interval;
      reg_ptr->cmd.cm_block_plmn_req.as_id = cmd_info_ptr->cmd_subs;
      reg_ptr->cmd.cm_block_plmn_req.cause = cmd_info_ptr->plmn_block_cause;

      CM_MSG_HIGH_1("as_id=%d, Send SYS_BLOCK_PLMN_BLOCK",
                     reg_ptr->cmd.cm_block_plmn_req.as_id );

      /* Send the request to NAS */
      cm_reg_send_cmd( reg_ptr );

      /* If UE is activtaed in 1XCSFB mode, csfb_status will be reset in CSFB_DEACT_CNF
      ** so only reset parameters which need to be reset during detach
      */
      #ifdef FEATURE_DOMAIN_SELECTION

      #ifdef FEATURE_LTE_TO_1X
      if(cmsds_is_1xcsfb_activated())
      {
        cmsds_reset_during_detach();
      }
      else
      #endif
      {
        /* If 1XCP is not activated in csfb mode, reset all domain selection globals
        ** including csfb-status
        */
        cmsds_reset();
      }
      #endif

      break;

    case CM_PLMN_BLOCKING_PREF_LTE_DETACH_PLMN_BLOCKING:
      /* Send detach request to NAS */
      ph_ptr->is_ps_detach_required = TRUE;

      /* Buffer the info, and send it when detach cnf comes. */
      ph_ptr->main_stack_info.plmn_blocking_info.request_pref = cmd_info_ptr->request_pref;
      ph_ptr->main_stack_info.plmn_blocking_info.plmn = cmd_info_ptr->plmn;
      ph_ptr->main_stack_info.plmn_blocking_info.blocking_interval = \
        cmd_info_ptr->blocking_interval;
      ph_ptr->main_stack_info.plmn_blocking_info.asubs_id = cmd_info_ptr->cmd_subs;
      ph_ptr->main_stack_info.plmn_blocking_info.cause= cmd_info_ptr->plmn_block_cause;

      /* This call fakes the user sending the current phone preferences down.
      ** When this happens, the detach request will be sent to NAS.
      */
      (void)cmph_force_pref_on_the_fly2( ss,
                                    ph_ptr,
                                    SD_SS_PREF_REAS_USER,
                                    CM_ACT_TYPE_PH_OBJ,
                                    ph_ptr->main_stack_info.pref_info.pref_term,
                                    ph_ptr->main_stack_info.pref_info.mode_pref,
                                    ph_ptr->main_stack_info.pref_info.band_pref,
                                    ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                    ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                    ph_ptr->main_stack_info.pref_info.prl_pref,
                                    ph_ptr->main_stack_info.pref_info.roam_pref,
                                    ph_ptr->main_stack_info.pref_info.hybr_pref,
                                    ph_ptr->main_stack_info.pref_info.plmn,
                                    ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                    ph_ptr->main_stack_info.pref_info.acq_order_pref,
                                    ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                                    &(CMPH_HYBR_2_PREF(ph_ptr)),
                                    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
                                    &(CMPH_HYBR_3_PREF(ph_ptr)),
                                    #endif
                                    CM_OTASP_ACT_CODE_NONE,
                                    (cm_act_id_type)ph_ptr,
                                    CM_ACT_UPDATE_REAS_USER,
                                    #if defined(FEATURE_MMODE_SC_SGLTE) || defined(FEATURE_MMODE_SC_SVLTE)
                                    !(cmpmprx_enforce_policy_oprt_mode(SYS_MODEM_AS_ID_1)),//cmd_info_ptr->cmd_subs)),
                                    #else
                                    TRUE,
                                    #endif
                                    cmph_get_acq_pri_order_per_sub(ss),
                                    CM_DEFAULT_VALUE,
                                    ph_ptr->main_stack_info.pref_info.csg_id,
                                    ph_ptr->main_stack_info.pref_info.csg_rat);

      break;

    case CM_PLMN_BLOCKING_PREF_PLMN_UNBLOCKING_ONLY:
      /* Send PLMN unblocking cmd to reg.*/
	  cmph_reg_send_unblock_plmn_req(cmd_info_ptr->plmn, cmd_info_ptr->cmd_subs, 
	                                 cmd_info_ptr->plmn_block_cause);
      break;

    case CM_PLMN_BLOCKING_PREF_PLMN_RESET:
      /* Get reg cmd. buffer and populate params.*/
      reg_ptr =  cm_reg_get_buf_else_err_fatal( CM_BLOCK_PLMN_REQ );

      /* Fill in parameters. */
      reg_ptr->cmd.cm_block_plmn_req.type = SYS_BLOCK_PLMN_RESET;
      reg_ptr->cmd.cm_block_plmn_req.as_id = cmd_info_ptr->cmd_subs;

      CM_MSG_HIGH_1("as_id=%d, Send SYS_BLOCK_PLMN_RESET",
                     reg_ptr->cmd.cm_block_plmn_req.as_id );

      /* Send the request to NAS */
      cm_reg_send_cmd( reg_ptr );

      break;

    case CM_PLMN_BLOCKING_PREF_PLMN_UNBLOCKING_FORCE_PREF:

      /* Send PLMN unblocking cmd to reg.*/
      cmph_reg_send_unblock_plmn_force_pref_req(cmd_info_ptr->plmn, cmd_info_ptr->cmd_subs, 
	                                 cmd_info_ptr->plmn_block_cause);
		
      break;

    case CM_PLMN_BLOCKING_PREF_NONE:
    case CM_PLMN_BLOCKING_PREF_MAX:
    default:
      CM_ERR_1("Unexpected PLMN request_pref %d",
                    cmd_info_ptr->request_pref);

  } // end of switch


}
#endif /* FEATURE_CM_LTE */

#if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)
/*===========================================================================

FUNCTION cmph_cmd_get_drx_req_proc

DESCRIPTION
  This function sends request to NAS to get DRX.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_get_drx_req_proc(
  cm_ph_cmd_s_type            *ph_cmd_ptr
)
{
  cm_ph_cmd_info_s_type       *cmd_info_ptr    = NULL;
    /* Point at command information component */

  reg_cmd_type                *reg_ptr;
    /* Pointer to REG command buffer*/

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_cmd_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /* Get reg cmd. buffer and populate params.*/
  reg_ptr =  cm_reg_get_buf_else_err_fatal( CM_GET_DRX_REQ );

  /* Fill in parameters. */
  reg_ptr->cmd.cm_get_drx_req.as_id = cmd_info_ptr->cmd_subs;

  CM_MSG_HIGH_1( "as_id=%d, Send CM_GET_DRX_REQ",
                 reg_ptr->cmd.cm_set_drx_req.as_id );

  /* Send the request to NAS */
  cm_reg_send_cmd( reg_ptr );

}

/*===========================================================================

FUNCTION cmph_cmd_set_drx_req_proc

DESCRIPTION
  This function sends request to NAS to set DRX.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_set_drx_req_proc(
  cm_ph_cmd_s_type            *ph_cmd_ptr
)
{
  reg_cmd_type                *reg_ptr;
    /* Pointer to REG command buffer*/

  cm_ph_cmd_info_s_type       *cmd_info_ptr    = NULL;
    /* Point at command information component */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_cmd_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /* Get reg cmd. buffer and populate params.*/
  reg_ptr =  cm_reg_get_buf_else_err_fatal( CM_SET_DRX_REQ );

  /* Fill in parameters. */
  reg_ptr->cmd.cm_set_drx_req.drx_coefficient = cmd_info_ptr->drx_coefficient;
  reg_ptr->cmd.cm_set_drx_req.as_id = cmd_info_ptr->cmd_subs;

  CM_MSG_HIGH_2( "drx = %d, as_id = %d, Send CM_SET_DRX_REQ",
             (int)reg_ptr->cmd.cm_set_drx_req.drx_coefficient,
             reg_ptr->cmd.cm_set_drx_req.as_id);

  /* Send the request to NAS */
  cm_reg_send_cmd( reg_ptr );

}
#endif

#if defined(FEATURE_TDSCDMA)
/*===========================================================================

FUNCTION cmph_cmd_set_tl_irat_search_timer_req_proc

DESCRIPTION
  This function sends request to NAS to set timer value for TDS to LTE IRAT
  search.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_cmd_set_tl_irat_search_timer_req_proc(
  cm_ph_cmd_s_type            *ph_cmd_ptr
)
{
  reg_cmd_type                *reg_ptr;
    /* Pointer to REG command buffer*/
  cm_ph_cmd_info_s_type       *cmd_info_ptr    = NULL;
    /* Point at command information component */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_cmd_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  /* Get reg cmd. buffer and populate params.*/
  reg_ptr =  cm_reg_get_buf_else_err_fatal(
               CM_SET_HPLMN_IRAT_SEARCH_TIMER_REQ );

  /* Fill in parameters. */
  reg_ptr->cmd.cm_set_hplmn_irat_search_timer_req.timer_value = \
    cmd_info_ptr->tl_irat_search_timer_value;
  reg_ptr->cmd.cm_set_hplmn_irat_search_timer_req.as_id       = \
    cmd_info_ptr->cmd_subs;

  CM_MSG_HIGH_2( "cm_set_hplmn_irat_search_timer_req.timer_value = %d, as_id=%d",
             reg_ptr->cmd.cm_set_hplmn_irat_search_timer_req.timer_value,
             reg_ptr->cmd.cm_set_hplmn_irat_search_timer_req.as_id);

  /* Send the request to NAS */
  cm_reg_send_cmd( reg_ptr );

}
#endif

/*===========================================================================

FUNCTION cmph_abort_cc_cnf_hdlr

DESCRIPTION
  This function handles the ABORT_CC_CONF expected from NAS. In oprt_mode
  change command CM needs to wait for this response before proceeding with
  the command to MMOC.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_abort_cc_cnf_hdlr( void )
{

  cmph_s_type *ph_ptr = cmph_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If this is a reply to an earlier command we sent to MC,
  ** also do reply processing.
  */
  if( cm_reply_check(&ph_ptr->reply, CM_ABORT_CC_CONF ))
  {
    /* Point at client command waiting for reply
    */
    cm_ph_cmd_s_type  *reply_cmd_ptr = (cm_ph_cmd_s_type*)cm_reply_get(&ph_ptr->reply);
    CM_ASSERT( reply_cmd_ptr != NULL );

    if (!cmph_client_cmd_forward_mmll (ph_ptr, reply_cmd_ptr))
    {
      /* Invoke the reply function with the appropriate error code.
      */
      cmph_client_cmd_mmll_reply( ph_ptr,
                                  reply_cmd_ptr,
                                  CM_PH_CMD_ERR_NOERR );

      /* We are done with processing the command that was waiting
      ** for reply - deallocate its command buffer.
      */
      cm_cmd_dealloc( reply_cmd_ptr );

      /* reset the reply info */
      cm_reply_init( &ph_ptr->reply );

      /* Turn on the signal that causes us to process any pending
      ** clients commands. This is necessary since we were NOT
      ** processing any clients commands while waiting for a reply
      ** from MC.
      */
      (void) rex_set_sigs( rex_self(), CM_CLIENT_CMD_Q_SIG );
    }
  }
}


/*===========================================================================

FUNCTION cmph_reset

DESCRIPTION
  Reverts the phone preferences to persistent values.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void  cmph_reset(

  cmph_s_type *ph_ptr,
  /* Pointer to Ph obj */
  prot_subsc_chg_e_type  main_subsc_chg,
  /*Main subsc change*/
prot_subsc_chg_e_type  hybr2_subsc_chg,
  /*Hybr2 subsc change*/
  prot_subsc_chg_e_type  hybr3_subsc_chg,
  /* ph command pointer*/
  cm_ph_cmd_s_type          *ph_cmd_ptr
)
{
  cm_policy_config_s_type *pm_ptr = (cm_policy_config_s_type *)cmpm_ptr();
  /* If Hybrid stacks are suspended resume during subscription change */

  CM_MSG_HIGH_3("Resetting the ph_ptr to persistent values. Before: ph_ptr->main_stack_info.pref_info.mode_pref = %d,user_mode_pref=%d, ph_ptr->main_stack_info.pref_info.hybr_pref = %d",
                                                            ph_ptr->main_stack_info.pref_info.mode_pref,
                                                            ph_ptr->main_stack_info.pref_info.user_mode_pref,
                                                            ph_ptr->main_stack_info.pref_info.hybr_pref);
   /* Incase emergency call is present on subsc changed sub,
   ** no need to force preferences after removing as forcing preferences happens
   ** as part of subsc change handling
   */
  ph_ptr->is_prl_load_complete   =  FALSE;
  if(main_subsc_chg != PROT_SUBSC_CHG_NONE)
  {
     cmph_resume_hybrid_opr_without_activating_prot();
     cmph_load_prst_phone_pref_on_main(FALSE,ph_cmd_ptr);
     cmph_remove_orig_mode( CM_SS_MAIN, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_MAX );
     cmph_remove_orig_mode( CM_SS_HYBR_1, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_MAX );	 
     CM_MSG_LOW_0("Removing emergency call preferences from main and hybr1 if present");
     ph_ptr->network_list_type = CM_NETWORK_LIST_NONE;
  }

  #ifdef FEATURE_MMODE_DUAL_SIM
  if(hybr2_subsc_chg != PROT_SUBSC_CHG_NONE)
  {
    cmph_load_prst_phone_pref_on_hybr2(ph_cmd_ptr);
    cmph_remove_orig_mode( CM_SS_HYBR_2, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_MAX );
    
    ph_ptr->hybrid2_network_list_type = CM_NETWORK_LIST_NONE;
  }
  #else
  SYS_ARG_NOT_USED(hybr2_subsc_chg);
  #endif

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(hybr3_subsc_chg != PROT_SUBSC_CHG_NONE)
  {
    cmph_load_prst_phone_pref_on_hybr3(ph_cmd_ptr);
    cmph_remove_orig_mode( CM_SS_HYBR_3, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_MAX );
  }
  #else
  SYS_ARG_NOT_USED(hybr3_subsc_chg);
  #endif

  CM_MSG_HIGH_2("After: ph main stack mode_pref %d, hybr_pref %d",
                                                           ph_ptr->main_stack_info.pref_info.mode_pref,
                                                           ph_ptr->main_stack_info.pref_info.hybr_pref);

  if(main_subsc_chg == PROT_SUBSC_CHG_NONE
     && cmtask_orig_para_search_act_type( CM_SS_MAIN,CM_ACT_TYPE_EMERG_CALL))
  {
    CM_MSG_HIGH_0("Removing emergency call preferences from main/hybr1 and forcing preferences");
    cmph_remove_orig_mode( CM_SS_MAIN, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_MAX );
    cmph_remove_orig_mode( CM_SS_HYBR_1, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_MAX );	
    (void) cmph_unforce_mode_on_the_fly( ph_ptr, CM_SS_MAIN );
  }

  #ifdef FEATURE_MMODE_DUAL_SIM
  if(cmph_is_msim())
  {
    if(hybr2_subsc_chg == PROT_SUBSC_CHG_NONE
       && cmtask_orig_para_search_act_type( CM_SS_HYBR_2,CM_ACT_TYPE_EMERG_CALL))
    {
      CM_MSG_HIGH_0("Removing emergency call preferences from HYBR2 and forcing preferences");
      cmph_remove_orig_mode( CM_SS_HYBR_2, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_MAX );
      (void) cmph_unforce_mode_on_the_fly( ph_ptr, CM_SS_HYBR_2 );
    }
  }
  #endif /*FEATURE_MMODE_DUAL_SIM*/


  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(cmph_is_msim())
  {
    if(hybr3_subsc_chg == PROT_SUBSC_CHG_NONE
       && cmtask_orig_para_search_act_type( CM_SS_HYBR_3,CM_ACT_TYPE_EMERG_CALL))
    {
      CM_MSG_HIGH_0("Removing emergency call preferences from HYBR2 and forcing preferences");
      cmph_remove_orig_mode( CM_SS_HYBR_3, CM_ACT_TYPE_EMERG_CALL, CM_ACT_PRIORITY_MAX );
      (void) cmph_unforce_mode_on_the_fly( ph_ptr, CM_SS_HYBR_3 );
    }
  }
  #endif /*FEATURE_MMODE_DUAL_SIM*/


}

/*===========================================================================

FUNCTION cmph_is_subs_buffered

DESCRIPTION
  Checks if subscription buffering is needed. If yes, then buffers
  the subscription.

===========================================================================*/

static boolean cmph_is_subs_buffered(

  cm_ph_cmd_s_type       *ph_cmd_ptr
)
{
  cm_ph_cmd_info_s_type *cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );
  boolean is_deferred = FALSE;


  /* If there is emergency call ongoing, put the cmd in hold cmd queue.
  Or if subscripton command is received from cm_cmd_q and hold_cmd_q
  already has subsc command waiting for processing, add this command to
  hold command to make sure subsc command will be processed sequentially */

  if( cmcall_is_there_a_call_type(CM_SS_MAX,CM_CALL_TYPE_EMERGENCY,
     CM_CALL_ID_INVALID) != CM_CALL_ID_INVALID ||
     cmph_is_in_emergency_cb() ||
     ( cmd_info_ptr->hold_cmd_reason != CM_HOLD_CMD_REAS_EMG &&
        cmph_is_subsc_cmd_on_hold()
     )
   )
  {
    CM_MSG_HIGH_2( "subsc update %d enqueue, hold_uptime=%d",
                            ph_cmd_ptr->cmd, cmd_info_ptr->hold_cmd_uptime);
    is_deferred = TRUE;
  }

  /* If phone in thermal emergency, then also treat it as emergency */
  if(cmac_is_in_thermal_emergency())
  {
    CM_MSG_HIGH_1( "Subsc chg %d bufferred due to thermal emergency",
                                                      ph_cmd_ptr->cmd );
    is_deferred = TRUE;
  }

  if(is_deferred)
  {
    cmd_info_ptr->is_command_on_hold = TRUE;
    cmd_info_ptr->hold_cmd_reason = CM_HOLD_CMD_REAS_EMG;

    /* Set is_reused to TRUE to make sure cmd buffer won't be de-allocated
    ** upon function exit. same cmd buffer will be enqueued
    */
    ph_cmd_ptr->is_reused = TRUE;
    CM_MSG_HIGH_2 ("ph_cmd_ptr->is_reused = %d,  ph_cmd_ptr = 0x%x",
                                        ph_cmd_ptr->is_reused, ph_cmd_ptr);

    if(!cm_hold_cmd_q_same_cmd((void*)ph_cmd_ptr))
    {
      cmd_info_ptr->hold_cmd_uptime = time_get_uptime_secs()+CM_HOLD_CMD_TIME;
      cm_hold_cmd_q_put((cm_cmd_type*)ph_cmd_ptr);
    }
  }

  return is_deferred;

}



/*===========================================================================

FUNCTION cmph_send_mmoc_perso_subsc_chgd

DESCRIPTION
  Send perso lock subs change to MMOC.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void cmph_send_mmoc_perso_subsc_chgd(

  prot_subsc_chg_e_type prot_subsc_chg,

  prot_subsc_chg_e_type hybr_2_prot_subsc_chg,

  prot_subsc_chg_e_type  hybr_3_prot_subsc_chg,

  boolean is_cdma_perso_lock,

  boolean is_gwl_perso_lock,

  boolean is_hybr_gw_perso_lock,

  boolean is_hybr_3_perso_lock

)
{
  cmph_s_type                       *ph_ptr           = cmph_ptr();
  sys_manual_sys_info_s_type        sys_id;

  mmoc_subs_data_s_type             cdma_subsc_info = {0};
    /* variable to store the cdma subscription info */

  mmoc_subs_data_s_type             gw_subsc_info = {0};
    /* variable to store the gw subscription info */

  mmoc_subs_data_s_type             *hybr_gw_subsc_info_ptr = NULL;
    /* variable to store the hybr gw subscription info */

  mmoc_subs_data_s_type             *hybr_3_subsc_info_ptr = NULL;

  cm_orig_q_s_type  *ph_hybr_2_orig_top_ptr
                                   = cmtask_orig_para_get_top( CM_SS_HYBR_2 );
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  cm_orig_q_s_type  *ph_hybr_3_orig_top_ptr
                                   = cmtask_orig_para_get_top( CM_SS_HYBR_3 );
  #endif
  cm_orig_q_s_type  *ph_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_MAIN );
  uint8                             active_ss = ACTIVE_SS_MAIN;
  mmgsdi_session_type_enum_type     session_type;
  sys_modem_as_id_e_type            asubs_id = SYS_MODEM_AS_ID_1;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Nothing has changed */
  if( prot_subsc_chg == PROT_SUBSC_CHG_NONE &&
      hybr_2_prot_subsc_chg == PROT_SUBSC_CHG_NONE &&
      hybr_3_prot_subsc_chg == PROT_SUBSC_CHG_NONE)
  {

    CM_MSG_HIGH_0("No change in the subs due to perso lock");
    return;
  }

  if(ph_orig_top_ptr == NULL)
  {
    CM_ERR_0("Top ptr is NULL for MAIN stack");
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Initialize SYS_ID for the SS_MAIN.
  */
  sys_id.sys_id.id_type  = SYS_SYS_ID_TYPE_UMTS;
  sys_id.prm.gw.sel_type = SYS_MANUAL_SEL_TYPE_USER_SPECIFIED;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Fill GW Subscription Information */

  //gw_subsc_info.mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref(ph_orig_top_ptr->orig->orig_mode_pref);
  if(cm_mmgsdi_ssn_tbl_get_type_for_asubs_id_gw(cmph_ptr()->main_stack_info.asubs_id,&session_type) != CM_MMGSDI_SUCCESS)
  {
    session_type = MMGSDI_GW_PROV_PRI_SESSION;
  }

  gw_subsc_info.mode_pref = SD_GET_COMMON_MODE(
                      cmph_map_cm_mode_pref_to_sd_mode_pref(ph_orig_top_ptr->orig->orig_mode_pref),
                      cmmsc_get_cm_ss_mode_cap(CM_SS_MAIN));

  gw_subsc_info.band_pref = cmph_map_cm_band_pref_to_sd_band_pref(ph_orig_top_ptr->orig->orig_band_pref);
  gw_subsc_info.tds_band_pref = cmph_map_cm_band_pref_to_sd_band_pref(ph_orig_top_ptr->orig->orig_tds_band_pref);
  gw_subsc_info.lte_band_pref = ph_orig_top_ptr->orig->orig_lte_band_pref;
  gw_subsc_info.hybr_pref = cmph_map_cm_hybr_pref_to_sd_hybr_pref(ph_orig_top_ptr->orig->orig_hybr_pref);

  /* Update the Hybrid preference based on hybrid mode */
  asubs_id = cmph_map_cm_ss_to_subs(CM_SS_MAIN);
  gw_subsc_info.hybr_pref = cmmsc_auto_is_hybr_allowed(gw_subsc_info.mode_pref,
                                                      gw_subsc_info.hybr_pref,
                                                      asubs_id) ?
                              gw_subsc_info.hybr_pref: SD_SS_HYBR_PREF_NONE;

  gw_subsc_info.orig_mode =
        cmph_map_cm_network_sel_mode_pref_to_orig_mode(CMPH_SS_NETWORK_SEL_MODE_PREF(SYS_MODEM_AS_ID_1,ph_ptr));

  /*gw_subsc_info.orig_mode =
        cmph_map_cm_network_sel_mode_pref_to_orig_mode(ph_orig_top_ptr->orig->orig_mode);*/

  gw_subsc_info.prm.gw.acq_order_pref =
                            cmph_map_cm_acq_order_pref_to_sd(CMPH_SS_ACQ_ORDER_PREF(SYS_MODEM_AS_ID_1, ph_ptr) );
  gw_subsc_info.prm.gw.srv_domain_pref =
                          cmph_map_cm_srv_domain_pref_to_sd(ph_orig_top_ptr->orig->orig_srv_domain_pref);

  gw_subsc_info.roam_pref = cmph_map_cm_roam_pref_to_sd_roam_pref(ph_orig_top_ptr->orig->orig_roam_pref);
  gw_subsc_info.nv_context = ph_ptr->main_stack_info.nv_context;
  sys_id.sys_id.id.plmn    = ph_ptr->main_stack_info.pref_info.plmn;
  gw_subsc_info.prm.gw.manual_sys_info  = sys_id;
  gw_subsc_info.ss            = SD_SS_MAIN;
  gw_subsc_info.as_id         = ph_ptr->main_stack_info.asubs_id;
  gw_subsc_info.session_type  = session_type;

  if(is_gwl_perso_lock)
  {
    gw_subsc_info.is_perso_locked = TRUE;
    gw_subsc_info.is_subs_avail = FALSE;
  }

  gw_subsc_info.subs_capability = cmpmprx_fetch_max_mode_capability(cmph_ptr()->main_stack_info.asubs_id);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Fill Hybrid GW Subscription information*/

  if(ph_hybr_2_orig_top_ptr && cmph_is_msim() && !cmph_is_sxlte())
  {
    /* Dynamically allocate buffer */
    if ((hybr_gw_subsc_info_ptr = (mmoc_subs_data_s_type *)cm_mem_malloc
                                            (sizeof(mmoc_subs_data_s_type))))
    {
     /* If HYBR GW subscription is available, populate the gw_subsc_info structure
     */
     if(cm_mmgsdi_ssn_tbl_get_type_for_asubs_id_gw(cmph_ptr()->hybr_2_stack_info.asubs_id,&session_type) != CM_MMGSDI_SUCCESS)
     {
       session_type = MMGSDI_GW_PROV_SEC_SESSION;
     }

      hybr_gw_subsc_info_ptr->mode_pref = SD_GET_COMMON_MODE(
                          cmph_map_cm_mode_pref_to_sd_mode_pref(ph_hybr_2_orig_top_ptr->orig->orig_mode_pref),
                          cmmsc_get_cm_ss_mode_cap(CM_SS_HYBR_2));

      hybr_gw_subsc_info_ptr->band_pref = cmph_map_cm_band_pref_to_sd_band_pref(ph_hybr_2_orig_top_ptr->orig->orig_band_pref);
      hybr_gw_subsc_info_ptr->hybr_pref = cmph_map_cm_hybr_pref_to_sd_hybr_pref(ph_hybr_2_orig_top_ptr->orig->orig_hybr_pref);
      hybr_gw_subsc_info_ptr->prm.gw.srv_domain_pref = cmph_map_cm_srv_domain_pref_to_sd(ph_hybr_2_orig_top_ptr->orig->orig_srv_domain_pref);
      hybr_gw_subsc_info_ptr->roam_pref = cmph_map_cm_roam_pref_to_sd_roam_pref(ph_hybr_2_orig_top_ptr->orig->orig_roam_pref);;

      hybr_gw_subsc_info_ptr->orig_mode = cmph_map_cm_network_sel_mode_pref_to_orig_mode(CMPH_SS_NETWORK_SEL_MODE_PREF(SYS_MODEM_AS_ID_2,ph_ptr));
      hybr_gw_subsc_info_ptr->prm.gw.acq_order_pref = cmph_map_cm_acq_order_pref_to_sd(CMPH_SS_ACQ_ORDER_PREF(SYS_MODEM_AS_ID_2, ph_ptr) );
      hybr_gw_subsc_info_ptr->nv_context = ph_ptr->hybr_2_stack_info.nv_context;
      sys_id.sys_id.id.plmn  = ph_ptr->hybr_2_stack_info.pref_info.plmn;
      hybr_gw_subsc_info_ptr->prm.gw.manual_sys_info  = sys_id;
      hybr_gw_subsc_info_ptr->ss = SD_SS_HYBR_2;
      hybr_gw_subsc_info_ptr->as_id = ph_ptr->hybr_2_stack_info.asubs_id;
      hybr_gw_subsc_info_ptr->session_type = session_type;
      hybr_gw_subsc_info_ptr->subs_capability = cmpmprx_fetch_max_mode_capability(cmph_ptr()->hybr_2_stack_info.asubs_id);

      if(is_hybr_gw_perso_lock)
      {
        hybr_gw_subsc_info_ptr->is_perso_locked = TRUE;
        hybr_gw_subsc_info_ptr->is_subs_avail = FALSE;
      }
    }
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(ph_hybr_3_orig_top_ptr && (cmph_is_tsts() || cmph_is_sxlte()))
  {
    /* Dynamically allocate buffer */
    if ((hybr_3_subsc_info_ptr = (mmoc_subs_data_s_type *)cm_mem_malloc
                                            (sizeof(mmoc_subs_data_s_type))))
    {

      hybr_3_subsc_info_ptr->mode_pref = SD_GET_COMMON_MODE(
                          (cmph_map_cm_mode_pref_to_sd_mode_pref(ph_hybr_3_orig_top_ptr->orig->orig_mode_pref)),
                          (cmmsc_get_cm_ss_mode_cap(CM_SS_HYBR_3)));

      /* If HYBR GW subscription is available, populate the gw_subsc_info structure
      */

      if(cm_mmgsdi_ssn_tbl_get_type_for_asubs_id_gw(cmph_ptr()->hybr_3_stack_info.asubs_id,&session_type) != CM_MMGSDI_SUCCESS)
      {
        if (cmph_is_sxlte())
        {
          session_type = MMGSDI_GW_PROV_SEC_SESSION;
        }
        else
        {
          session_type = MMGSDI_GW_PROV_TER_SESSION;
        }
      }

      hybr_3_subsc_info_ptr->band_pref = cmph_map_cm_band_pref_to_sd_band_pref(ph_hybr_3_orig_top_ptr->orig->orig_band_pref);
      hybr_3_subsc_info_ptr->hybr_pref = cmph_map_cm_hybr_pref_to_sd_hybr_pref(ph_hybr_3_orig_top_ptr->orig->orig_hybr_pref);
      hybr_3_subsc_info_ptr->prm.gw.srv_domain_pref = cmph_map_cm_srv_domain_pref_to_sd(ph_hybr_3_orig_top_ptr->orig->orig_srv_domain_pref);
      hybr_3_subsc_info_ptr->roam_pref = cmph_map_cm_roam_pref_to_sd_roam_pref(ph_hybr_3_orig_top_ptr->orig->orig_roam_pref);;

      hybr_3_subsc_info_ptr->orig_mode = cmph_map_cm_network_sel_mode_pref_to_orig_mode(CMPH_SS_NETWORK_SEL_MODE_PREF(ph_ptr->hybr_3_stack_info.asubs_id,ph_ptr));
      hybr_3_subsc_info_ptr->prm.gw.acq_order_pref = cmph_map_cm_acq_order_pref_to_sd(CMPH_SS_ACQ_ORDER_PREF(ph_ptr->hybr_3_stack_info.asubs_id, ph_ptr) );
      hybr_3_subsc_info_ptr->nv_context = ph_ptr->hybr_3_stack_info.nv_context;
      sys_id.sys_id.id.plmn  = ph_ptr->hybr_2_stack_info.pref_info.plmn;
      hybr_3_subsc_info_ptr->prm.gw.manual_sys_info  = sys_id;
        hybr_3_subsc_info_ptr->ss = SD_SS_HYBR_3;
        hybr_3_subsc_info_ptr->as_id = ph_ptr->hybr_3_stack_info.asubs_id;
        hybr_3_subsc_info_ptr->session_type = session_type;
        hybr_3_subsc_info_ptr->subs_capability = cmpmprx_fetch_max_mode_capability(cmph_ptr()->hybr_3_stack_info.asubs_id);
		
      if(is_hybr_3_perso_lock)
      {
        hybr_3_subsc_info_ptr->is_perso_locked = TRUE;
        hybr_3_subsc_info_ptr->is_subs_avail = FALSE;
      }
    }
  }
  #endif

  if (cmph_is_msim())
  {
    active_ss = ACTIVE_SS_NONE;

    if(ph_ptr->active_subs & SYS_MODEM_AS_ID_1_MASK)
    {
      active_ss |= BM(cmph_map_as_id_to_cm_ss(SYS_MODEM_AS_ID_1));
    }

    if(ph_ptr->active_subs & SYS_MODEM_AS_ID_2_MASK)
    {
      active_ss |= BM(cmph_map_as_id_to_cm_ss(SYS_MODEM_AS_ID_2));
    }

    #if defined(FEATURE_MMODE_TRIPLE_SIM)
    if(ph_ptr->active_subs & SYS_MODEM_AS_ID_3_MASK)
    {
      active_ss |= BM(cmph_map_as_id_to_cm_ss(SYS_MODEM_AS_ID_3));
    }
    #endif
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* CDMA Subscription Information */
  cdma_subsc_info.mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref(ph_orig_top_ptr->orig->orig_mode_pref);
  cdma_subsc_info.band_pref = cmph_map_cm_band_pref_to_sd_band_pref(ph_orig_top_ptr->orig->orig_band_pref);
  cdma_subsc_info.hybr_pref = cmph_map_cm_hybr_pref_to_sd_hybr_pref(ph_orig_top_ptr->orig->orig_hybr_pref);

  /* Update the Hybrid preference based on hybrid mode */
  cdma_subsc_info.hybr_pref = cmmsc_auto_is_hybr_allowed(cdma_subsc_info.mode_pref,
                                                        cdma_subsc_info.hybr_pref,
                                                        asubs_id) ?
                              cdma_subsc_info.hybr_pref: SD_SS_HYBR_PREF_NONE;

  cdma_subsc_info.orig_mode =
        cmph_map_cm_network_sel_mode_pref_to_orig_mode(CMPH_SS_NETWORK_SEL_MODE_PREF(SYS_MODEM_AS_ID_1,ph_ptr));
  cdma_subsc_info.prm.cdma.prl_pref = cmph_map_cm_prl_pref_to_sd_prl_pref(ph_orig_top_ptr->orig->orig_prl_pref);
  cdma_subsc_info.roam_pref = cmph_map_cm_roam_pref_to_sd_roam_pref( ph_orig_top_ptr->orig->orig_roam_pref);
  cdma_subsc_info.nv_context = ph_ptr->main_stack_info.nv_context;
  cdma_subsc_info.ss            = SD_SS_MAIN;
  cdma_subsc_info.as_id         = SYS_MODEM_AS_ID_1;
  cdma_subsc_info.session_type  = MMGSDI_1X_PROV_PRI_SESSION;
  /* If CDMA subscription is available, populate the cdma_subsc_info structure
  */
  if(is_cdma_perso_lock)
  {
    cdma_subsc_info.is_perso_locked = TRUE;
    cdma_subsc_info.is_subs_avail = FALSE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Send the subscription change to MMOC
  */
  mmoc_cmd_subscription_chgd_new( MMOC_SUBSC_CHG_SUBSC_AVAIL,
                                  prot_subsc_chg,
                                  (hybr_2_prot_subsc_chg == PROT_SUBSC_CHG_GW?TRUE:FALSE),
                                  (hybr_3_prot_subsc_chg == PROT_SUBSC_CHG_GW?TRUE:FALSE),
                                  (byte)ph_ptr->curr_nam,
                                  &cdma_subsc_info,
                                  &gw_subsc_info,
                                  hybr_gw_subsc_info_ptr,
                                  hybr_3_subsc_info_ptr,
                                  active_ss,
                                  cmpmprx_get_device_mode()
                                 );

  /* Free allocated buffer */
  if (hybr_gw_subsc_info_ptr)
  {
    cm_mem_free (hybr_gw_subsc_info_ptr);
  }
  if (hybr_3_subsc_info_ptr)
  {
    cm_mem_free (hybr_3_subsc_info_ptr);
  }
}

/*===========================================================================

FUNCTION cmph_updt_is_oprt_mode_change_ongoing

DESCRIPTION
  Updates the Flag when Operating mode change to LPM, FTM, OFFLINE is ongoing.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  void

SIDE EFFECTS
  none

===========================================================================*/
void cmph_updt_is_oprt_mode_change_ongoing(boolean set_status, sys_oprt_mode_e_type   oprt_mode)
{
    cmph_s_type         *ph_ptr = cmph_ptr();

      switch( oprt_mode )
      {
        case SYS_OPRT_MODE_OFFLINE:
        case SYS_OPRT_MODE_OFFLINE_CDMA:
        case SYS_OPRT_MODE_FTM:
        case SYS_OPRT_MODE_LPM:
        case SYS_OPRT_MODE_PWROFF:
        case SYS_OPRT_MODE_RESET:

        if(set_status == TRUE)
        {
        CM_MSG_HIGH_1("Operating Mode change %d started: ongoing flag set TRUE", oprt_mode);
        ph_ptr->is_oprt_mode_change_ongoing = TRUE;
        break;
    }
    else
    {
        CM_MSG_HIGH_1("Operating Mode change %d completed: ongoing flag set FALSE", oprt_mode);
        ph_ptr->is_oprt_mode_change_ongoing = FALSE;
            break;
        }

        default:
        break;
    }
}


/*===========================================================================

FUNCTION cmph_client_cmd_forward_mmll

DESCRIPTION
  Forward a client phone commands to mmoc/ll.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  TRUE if CM needs to wait for a replay from LL before continuing
  processing this command, FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_client_cmd_forward_mmll(

    cmph_s_type         *ph_ptr,
        /* Pointer to a phone object */

    cm_ph_cmd_s_type       *ph_cmd_ptr
        /* Point at phone command component */

)
{

  cm_ph_cmd_info_s_type    *cmd_info_ptr    = NULL;
      /* Point at command information component */
      
  cmss_s_type                *ss_ptr = cmss_ptr();

  #ifdef CM_GW_SUPPORTED
  #endif /* FEATURE_GSM ||  FEATURE_WCDMA */

  #ifdef FEATURE_GPSONE
  boolean is_session_ended = FALSE;
  #endif

  #if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)
  reg_cmd_type                *reg_ptr;
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr  != NULL );
  CM_ASSERT( ph_cmd_ptr != NULL );
  CM_ASSERT( ph_cmd_ptr->cmd_type == CM_CMD_TYPE_PH );

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  #ifdef FEATURE_CM_DEBUG_BUFFER
  cmdbg_add_to_dbg_buffer(CM_BUFF_PH_CMD_TYPE, ph_cmd_ptr->cmd, (void*)ph_cmd_ptr);
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( ph_cmd_ptr->cmd )
  {

                       /*---------------------------*/
                       /* Change the operating mode */
                       /*---------------------------*/

    case CM_PH_CMD_OPRT_MODE:

      if(!ph_ptr->is_oprt_mode_change_ongoing)
      {
          cmph_updt_is_oprt_mode_change_ongoing(TRUE, cmd_info_ptr->oprt_mode);
      }

      /* If cleanup needs to be initiated, initiate it.
      */
      if( cmclnup_is_clnup_needed(CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_NONE, cmd_info_ptr->oprt_mode))
      {
        /* If cleanup is needed, current operating mode is ONLINE.*/
        if( cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE )
        {
          cmcall_end_all_non_emerg_non_data_calls(
                                              SYS_MODEM_AS_ID_ALL_ACTIVE_MASK,
                                              CM_CALL_END_OFFLINE
                                              );
        }
        /* Cleanup not currently underway. Initiate it.*/
        cmclnup_initiate_cleanup(ph_cmd_ptr);

        /* If this new cleanup activity requires CM to wait for response,
        ** the command is already on the buffer queue. So end the processing.
        */
        if(cmclnup_is_ongoing_oprt_mode())
        {
          return TRUE;
        }
      }

      /* Is wait required for oprt mode request or 
       * IMS clean up on task stop, no need to send cmd to MMOC
      */
      if (cmph_is_wait_on_oprt_mode (ph_cmd_ptr))
      {
        return TRUE;
      }

      if( cmd_info_ptr->oprt_mode == ph_ptr->oprt_mode &&
          cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_PWROFF)
      {
        /* this is the same oprt mode transition and the current oprt
           mode is not poweroff (the cmph initial condition
           so do not send the command to MC.
           Sometimes MC is suspended for a long period. If we keep
           sending the same operating mode change command to MC,
           MC can run out of buffers.
        */

        /* For ONLINE - ONLINE transition, be sure to set the rtre information */
        ph_cmd_ptr->info.rtre_control = ph_ptr->rtre_control;
        ph_cmd_ptr->info.rtre_config = ph_ptr->rtre_config;

        CM_MSG_HIGH_1("Dup cmd: same oprt mode(%d) switching", cmd_info_ptr->oprt_mode);
        break;
      }

      ph_ptr->true_oprt_mode = cmd_info_ptr->oprt_mode;
      /* When the ph is moving into LPM, check to make sure that all
      ** the active calls are ended.
      */
      if( cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_LPM)
      {
        /* ending all the active calls
        */
        cmcall_offline(SYS_OPRT_MODE_LPM);
      }

      if( cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE)
      {
        /* Reset the oprt mode hold uptime flag */
        ph_ptr->oprt_mode_send_time = CMPH_MAX_UPTIME;
      }
      /* If the oprt_mode is not ONLINE , and there is an 911 call going on,
      ** bring the phone out of EMERG_CB
      */
      if ( cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE &&
           cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_PSEUDO_ONLINE
         )
      {
        cmph_exit_emergency_cb(ph_ptr, FALSE,CM_SS_MAIN,FALSE);
      }


      switch( cmd_info_ptr->oprt_mode )
      {
        case SYS_OPRT_MODE_OFFLINE:
        case SYS_OPRT_MODE_OFFLINE_CDMA:
        case SYS_OPRT_MODE_OFFLINE_AMPS:

          mmoc_cmd_oprt_mode_chgd( cmd_info_ptr->oprt_mode );

                    *cmph_get_is_kicked_hybr_ptr() = FALSE;

          cm_reply_set( &ph_ptr->reply,
                        (cm_cmd_type*)ph_cmd_ptr,
                        CM_OFFLINE_OK_F,
                        CMPH_MAX_MC_REPLY_TIME );

          break;

        case SYS_OPRT_MODE_ONLINE:

          /* Check if there is a PD session and the mode that we are going
          ** online has GW component. If it has, then end the PD session
          */
          #ifdef FEATURE_GPSONE
          if(!INRANGE(ph_ptr->curr_nam, 0, NV_MAX_NAMS))
          {
            CM_ERR_1( "invlid nam: %d", ph_ptr->curr_nam);
            break;
          }
          is_session_ended = cmpd_process_oprt_mode_change( cmd_info_ptr->oprt_mode,
                                  ph_ptr->prst_main_stack_info[ ph_ptr->curr_nam ].mode_pref );

          if( is_session_ended )
          {
            /* Hold on to this command, put this on the hold Q and process it
            ** later when we get the session end or the timer expires
            */
            cmd_info_ptr->is_command_on_hold = TRUE;
            cmd_info_ptr->hold_cmd_reason = CM_HOLD_CMD_REAS_GPS;
            cmd_info_ptr->hold_cmd_uptime = time_get_uptime_secs() + CM_HOLD_CMD_TIME;
            cm_hold_cmd_q_add( (cm_cmd_type*)ph_cmd_ptr, sizeof(cm_ph_cmd_s_type) );
            break;

          }
          #endif

          #ifdef FEATURE_CM_SS_MEAS
          #error code not present
#endif //FEATURE_CM_SS_MEAS

          #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
          if(cmsoa_state_info_ptr() != NULL)
          {
            boolean is_enabled = cmsoa_state_info_ptr()->config.is_switch_enabled;

            /* Update SD again about the switch enable or disabled */
            CM_MSG_HIGH_1("MMSOA: Notify SD - dynamic switch_enabled=%d", is_enabled);
            sd_ss_set_sv_oprt_enable_switch(
               cmsoa_state_info_ptr()->config.is_switch_enabled );

          }
          #endif

          /* Before going ONLINE, all prst user pref need to be loaded
          ** and sent to SD */
          cmph_load_prst_phone_pref(ph_cmd_ptr);
          cmph_proc_online_mode_oper (ph_ptr);

          /* Check if Operating mode command to MMOC need to be buffered */
          if ( (cmpsm_pwr_up_uim_opt_enabled_and_no_subs_avail() || 
            cmmmgsdi_count_given_state(CMMMGSDI_STATE_SESSION_CHANGED) )&&
            cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_ONLINE)
          {
            ph_ptr->oprt_mode_send_time = time_get_uptime_secs() + CMPH_WAIT_OPRT_MODE_TIME;
            CM_MSG_HIGH_2("oprt_mode_online: forward_mmll(), buffer online cmd, uptime_secs %d, oprt_mode_send_time %d",
              time_get_uptime_secs(), ph_ptr->oprt_mode_send_time );
          }
          /* Check if currently in any online mode.
          */
          if ( ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE &&
               ph_ptr->oprt_mode != SYS_OPRT_MODE_PSEUDO_ONLINE &&
               ph_ptr->oprt_mode_send_time == CMPH_MAX_UPTIME
             )
          {
            /* No, send online command.
            */
            CM_MSG_HIGH_0("oprt_mode_online: Sending operating mode online to MMOC");
            mmoc_cmd_oprt_mode_chgd( SYS_OPRT_MODE_ONLINE );
          }
          /* If Hybrid stacks are suspended resume during subscription change */
          cmph_resume_hybrid_opr_without_activating_prot();

          /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

          /* Check if the new mode is pseudo online
          */
          switch ( cmd_info_ptr->oprt_mode )
          {
            case SYS_OPRT_MODE_PSEUDO_ONLINE:
              /* Disable 1x TX using DDTM.
              */
              cmph_ddtm_disable_cdma_tx( ph_ptr );
              break;

            case SYS_OPRT_MODE_ONLINE:
              #if defined(FEATURE_DDTM_CNTL) && defined(FEATURE_MMGSDI_SESSION_LIB)
               /* lint -save -e746 call not made in the presence of a prototype */
              if(!(cm_is_jcdma_enable() && cmmmgsdi_is_jcdma_card_white_equiv()))
              /* lint -restore */
              #endif
              {
                /* restore current DDTM settings.
                ** SK: The above comment should probably read, turn off DDTM.
                */

                cmph_send_ddtm_status( ph_ptr, FALSE, SYS_DDTM_ACT_MASK_EMPTY,
                                       ph_ptr->cur_ddtm_srv_opt_list,
                                       ph_ptr->cur_ddtm_num_srv_opt );
              }
              break;

            default:
              break;

          } /* switch( cmd_info_ptr->oprt_mode) */
          if( cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_ONLINE)
          {
            ph_ptr->pwr_up_done = TRUE;
          }
          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SYS_OPRT_MODE_LPM:

          *cmph_get_is_kicked_hybr_ptr() = FALSE;

          mmoc_cmd_oprt_mode_chgd( SYS_OPRT_MODE_LPM );

          /* For LPM we need to wait for a reply command from MC
          ** in the from of CM_LPM_OK_F, so setup the reply object
          ** to indicate that we are now waiting for CM_LPM_OK_F reply.
          */
          cm_reply_set( &ph_ptr->reply,
                        (cm_cmd_type*)ph_cmd_ptr,               /* command waiting on reply */
                        CM_LPM_OK_F,           /* wait for this UI command */
                        CMPH_MAX_MC_REPLY_TIME );    /* wait for this long */

          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SYS_OPRT_MODE_RESET:
          mmoc_cmd_oprt_mode_chgd( SYS_OPRT_MODE_RESET );

          /* In Fusion, on MSM, wait for TMC error handling to be disabled
          ** before propagating the oprt_mode to MDM.
          */
          cm_reply_set( &ph_ptr->reply,
                        (cm_cmd_type*)ph_cmd_ptr,               /* command waiting on reply */
                        CM_RESET_OK_F,         /* wait for this UI command */
                        CMPH_MAX_MC_REPLY_TIME );    /* wait for this long */

          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SYS_OPRT_MODE_PWROFF:
          mmoc_cmd_oprt_mode_chgd( SYS_OPRT_MODE_PWROFF );
          /* need to wait for report, so that efs_sync can work properly */
          cm_reply_set( &ph_ptr->reply,
            (cm_cmd_type*)ph_cmd_ptr,               /* command waiting on reply */
            CM_PWROFF_OK_F,         /* wait for this UI command */
            CMPH_MAX_MC_REPLY_TIME );    /* wait for this long */
          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        case SYS_OPRT_MODE_FTM:
          *cmph_get_is_kicked_hybr_ptr() = FALSE;
          *cmph_get_is_kicked_hybr_2_ptr() = FALSE;
          mmoc_cmd_oprt_mode_chgd( SYS_OPRT_MODE_FTM );

          /* For FTM we need to wait for a reply command from MC
          ** in the from of CM_OFFLINE_OK_F, so setup the reply object
          ** to indicate that we are now waiting for CM_FTM_OK_F reply.
          */
          CM_MSG_HIGH_0( "Setting ph ptr reply to CM_OFFLINE_OK_F");
          cm_reply_set( &ph_ptr->reply,
                        (cm_cmd_type*)ph_cmd_ptr,  /* command waiting on reply */
                        CM_OFFLINE_OK_F,               /* wait for this UI command */
                        CMPH_MAX_MC_REPLY_TIME );  /* wait for this long */

          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        case SYS_OPRT_MODE_RESET_MODEM:
          mmoc_cmd_oprt_mode_chgd( SYS_OPRT_MODE_RESET_MODEM );
          break;

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        default:
          CM_ERR_1( "Unexpected oprt mode=%d",
                         (uint8)cmd_info_ptr->oprt_mode);
      }

      /* CM needs to update subscription here, as CM can't send it while in FTM.
      **If we send in FTM, then RF calibration is interrupted as subscription
      **processing in MMOC results in deactivating of all stacks including FTM
      */
      if(ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM &&
        (cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_ONLINE||
         cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_PSEUDO_ONLINE ||
     cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_LPM)
      && !cmtask_is_stop_sig_rcvd()
     )
      {
        cmph_update_subscription_to_mmode(MMOC_SUBSC_CHG_SUBSC_AVAIL);
      }

      if( !cmd_info_ptr->is_command_on_hold &&
          ph_ptr->oprt_mode_send_time == CMPH_MAX_UPTIME)
      {
        if(cmd_info_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE)
        {
          ph_ptr->is_dds_switchback_from_temp = FALSE;
        }
        
          cmmsimc_proc_cmd_oprt_mode_chgd(cmd_info_ptr->oprt_mode );

        /* Reset the origination throttle table
        */
        cmss_orig_thr_table_reset( cmss_ptr()->cmss_orig_thr_tbl_ptr );

        /* Clear the is hybr kicked flag
        */
        *cmph_get_is_kicked_hybr_ptr() = FALSE;
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /*-----------------------------*/
      /* Update the Measurement Mode */
      /*-----------------------------*/

    case CM_PH_CMD_MEAS_MODE:
      #ifdef FEATURE_CM_SS_MEAS
      #error code not present
#endif /* FEATURE_CM_SS_MEAS */
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                  /*-------------------------------------------*/
                  /* Change the System Selection preference */
                  /*-------------------------------------------*/

    case CM_PH_CMD_SYS_SEL_PREF:
      cmph_cmd_sys_sel_pref_proc(ph_cmd_ptr);
      break;

    #ifdef FEATURE_DDTM_CNTL
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                /*-----------------------------------------*/
                /* Change the DDTM preference            */
                /*-----------------------------------------*/

    case CM_PH_CMD_DDTM_PREF:
      break;

    #endif /* FEATURE_DDTM_CNTL */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                /*-----------------------------------------*/
                    /* Block service option            */
                    /*-----------------------------------------*/
    

    case CM_PH_CMD_CHANGE_SRV_OPT:
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                /*-----------------------------------------*/
                /* Change the answer voice setting */
                /*-----------------------------------------*/

    case CM_PH_CMD_ANSWER_VOICE:

      /* NO need to notify MC of this one.
      */

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                        /*--------------------------*/
                        /* Change the NAM selection */
                        /*--------------------------*/

    case CM_PH_CMD_NAM_SEL:

      /* No need to notify MC of AUTO-NAM selection
      */
      if( cmd_info_ptr->nam_sel == CM_NAM_AUTO )
      {
        break;
      }

      if( !cm_is_valid_state_for_sub_proc(ph_ptr->oprt_mode))
      {
        break;
      }

      /* Inform CM Pref & MMOC that subscription changed.
      ** ADD_PROTO with both CDMA and GWL makes both protocol stacks reload
      ** NV information
      */
      if(!INRANGE(cmd_info_ptr->nam_sel, 0, NV_MAX_NAMS))
      {
        CM_ERR_1( "invalid nam: %d",cmd_info_ptr->nam_sel);
        break;
      }

      {
        cm_network_sel_mode_pref_e_type net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_NONE;
        cm_orig_q_s_type *ph_orig_top_ptr =
                                  cmtask_orig_para_get_top( CM_SS_MAIN );

        if( ph_orig_top_ptr != NULL &&
            ph_orig_top_ptr->act_type == CM_ACT_TYPE_POLICYMAN_RESTRICT )
        {
          if( ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG )
          {
            net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV;
          }
          else
          {
            switch(CMPH_PRST_NETWORK_SEL_MODE_PREF( ph_ptr ))
            {
               case CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY:
               case CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV:
               case CM_NETWORK_SEL_MODE_PREF_MANUAL:
                 net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY;
                 break;

               default:
                 net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY;
                 break;
            }
          }
        }
        else
        {
          net_sel_mode_pref = CMPH_PRST_NETWORK_SEL_MODE_PREF( ph_ptr );
        }

        {
          cm_pref_s_type  *hybr_2_pref_ptr = NULL;

          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
          cm_pref_s_type  *hybr_3_pref_ptr = NULL;

          if(cmph_is_tsts() ||cmph_is_sxlte())
          {
            hybr_3_pref_ptr = &(ph_ptr->hybr_3_stack_info.pref_info);
          }
          #endif

          /* Allocate buffer only if multi-sim */
          if (cmph_is_msim() && !cmph_no_hybr2())
          {
            hybr_2_pref_ptr = cm_pref_ptr();
            memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
          }

          /* Use the cmmsc function if multi stack frame work is used */
          cmmsimc_proc_cmd_subsc_chgd(MMOC_SUBSC_CHG_NAM_SEL,
             (byte) ph_ptr->curr_nam,
             net_sel_mode_pref,
             CMPH_PRST_MODE_PREF( ph_ptr ),
             CMPH_PRST_BAND_PREF( ph_ptr ),
             CMPH_PRST_LTE_BAND_PREF( ph_ptr ),
             CMPH_PRST_TDS_BAND_PREF( ph_ptr ),
             CMPH_PRST_PRL_PREF( ph_ptr ),
             CMPH_PRST_ROAM_PREF( ph_ptr ),
             ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].hybr_pref,
             ph_ptr->main_stack_info.pref_info.plmn,
             CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr),
             CMPH_PRST_ACQ_ORDER_PREF( ph_ptr ),
             hybr_2_pref_ptr,
             #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
             hybr_3_pref_ptr,
             #endif
             ph_ptr->is_gwl_subscription_available,
             ph_ptr->is_hybr_gw_subscription_available,
             ph_ptr->is_hybr_gw3_subscription_available,
             ph_ptr->is_cdma_subscription_available,
             PROT_SUBSC_CHG_ALL,
             PROT_SUBSC_CHG_GW,
             PROT_SUBSC_CHG_GW
           );


           /* Free allocated buffer */
           if (hybr_2_pref_ptr)
           {
             cm_mem_free (hybr_2_pref_ptr);
           }
         }
      }

      /* Reset the origination throttle table
      */
      cmss_orig_thr_table_reset( cmss_ptr()->cmss_orig_thr_tbl_ptr );

      /* Clear the is hybr kicked flag
      */
      *cmph_get_is_kicked_hybr_ptr() = FALSE;
      *cmph_get_is_kicked_hybr_2_ptr() = FALSE;

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                      /*------------------------------*/
                      /* A CM Client activated itself */
                      /*------------------------------*/

    case CM_PH_CMD_CLIENT_ACT:

      /* NO need to notify MC of this one.
      */

      break;



    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                     /*-------------------------------------*/
                     /* Get a snapshot of subscription information */
                     /*-------------------------------------*/

    case CM_PH_CMD_SUBSCRIPTION_INFO_GET:

      /* do nothing - this request terminated at CM */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                     /*------------------------------------*/
                     /* Get a snapshot of subscription information */
                     /*------------------------------------*/

    case CM_PH_CMD_INFO_GET:

      /* do nothing - this request terminated at CM */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                     /*------------------------------------*/
                     /*     Get user network sel mode      */
                     /*------------------------------------*/

    case CM_PH_CMD_SET_USER_NET_SEL_MODE:
     {
       cmefs_id_e_type                    efs_id;
       cm_ss_e_type cmd_ss = cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);

       /* Validate curr_nam */
       if(!INRANGE(ph_ptr->curr_nam, 0, CM_NAM_AUTO))
       {
         CM_ERR_1( "invalid curr_nam, PH_CMD:%d",CM_PH_CMD_SET_USER_NET_SEL_MODE);
         break;
       }

       /* Get the EFS id corresponding to current NAM */
       efs_id = cmefs_get_efs_id_for_curr_nam (ph_ptr->curr_nam);

       /* Write to EFS file */
       if( cmefs_fs_write( efs_id,
                         (byte*)(&(cmd_info_ptr->user_net_sel_mode)),
                          sizeof(cm_user_net_sel_mode_pref_e_type),
                          cmd_info_ptr->cmd_subs)
          )
       {
         /* Store this value in ph_ptr as well */
         CM_MSG_HIGH_1 ("Updating user_net_sel_mode EFS & ph_ptr with %d",
                      cmd_info_ptr->user_net_sel_mode);
         if(cmd_ss == CM_SS_MAIN)
         {
         ph_ptr->main_stack_info.pref_info.user_net_sel_mode = cmd_info_ptr->user_net_sel_mode;
       }
         else if(cmd_ss == CM_SS_HYBR_2)
         {
           ph_ptr->hybr_2_stack_info.pref_info.user_net_sel_mode = cmd_info_ptr->user_net_sel_mode;
         }
         #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
         else if(cmd_ss == CM_SS_HYBR_3)
         {
           ph_ptr->hybr_3_stack_info.pref_info.user_net_sel_mode = cmd_info_ptr->user_net_sel_mode;
         }
         #endif
       }
       else
       {
         CM_MSG_HIGH_0 ("EFS write fail, Can't update user_net_sel_mode" ) ;
       }

     }

     break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                     /*----------------------------------*/
                     /* Set RSSI change delta threshold  */
                     /*----------------------------------*/

    case CM_PH_CMD_RSSI_DELTA:

      /* do nothing - this request terminated at CM */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                     /*------------------------------------------*/
                     /* Set RSSI,ECIO,IO change delta threshold  */
                     /*------------------------------------------*/

    case CM_PH_CMD_SIGNAL_STRENGTH_DELTA:

      /* do nothing - this request terminated at CM */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                     /*----------------------------------*/
                     /*         Set Packet State         */
                     /*----------------------------------*/
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
    case CM_PH_CMD_PACKET_STATE:

      if( cmd_info_ptr->packet_state == CM_PACKET_STATE_NULL )
      {
        /* There is no PPP session - phone can restore regular
          hybrid operation */
        if( ph_ptr->main_stack_info.pref_info.pref_term != CM_PREF_TERM_1_CALL &&
            ph_ptr->main_stack_info.pref_info.pref_term != CM_PREF_TERM_CM_1_CALL_PLUS &&
            ph_ptr->main_stack_info.pref_info.pref_term != CM_PREF_TERM_CM_MO_SMS )
        {
          /* Restore normal Hybrid HDR operation */
          CM_MSG_HIGH_0("Reselect - got CM_PACKET_STATE_NULL");

          /* This will send a pref sys chgd down to the HDR
          ** instance if no HDR call is going on, this bypasses the
          ** Q mechanism.
          */
          cmmsimc_proc_enable_hybr_hdr( TRUE );
        }
      }
      break;
    #endif


    #ifdef FEATURE_JCDMA
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*----------------------------------*/
                   /* Enable/Disable voice activity    */
                   /*----------------------------------*/

    case CM_PH_CMD_VOC_ACTIVITY:
         #ifndef FEATURE_MMODE_REMOVE_1X
        /* not really the most appropriate function to do this in
        ** but this seemed to be the best fit without being more kludgy
        */
        txc_set_voc_activity( cmd_info_ptr->voc_act_enable,
                              cmd_info_ptr->voc_act_voc_1,
                              cmd_info_ptr->voc_act_voc_2,
                              cmd_info_ptr->voc_act_voc_8 );
        #else
        #error code not present
#endif
     break;

    #endif /* FEATURE_JCDMA */


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_AVOID_SYS:

      /* Only notify MC if phone is currently online.
      */
      if( ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE )
      {
        break;
      }

      /*
      ** Command the MMoC to perform the avoid system.
      */
      {
        cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

        cmmsc_pack_cmd_for_pref_sys_chgd_per_ph_pref(
          CM_SS_MAIN,
          SD_SS_PREF_REAS_AVOID_SYS,
          FALSE,
          &cmd
         );

        (cmd.pref_info)->avoid_type = cmph_map_cm_avoid_type_to_sd_avoid_type(
                                 cmd_info_ptr->avoid_type);
        (cmd.pref_info)->avoid_time = cmd_info_ptr->avoid_time;

        cmmsimc_proc_cmd_pref_sys_chgd(&cmd);
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_WAKEUP_FROM_STANDBY:
    {
      sys_modem_as_id_e_type asubs_id = SYS_MODEM_AS_ID_1;
      CM_MSG_HIGH_2("wakeup_service %d, active_subs %d", cmd_info_ptr->wakeup_service,ph_ptr->active_subs  );
      if (cmph_is_msim())
      {
        asubs_id = ph_cmd_ptr->info.cmd_subs;
      }

      if( CM_CONTAIN ( cmd_info_ptr->wakeup_service,CM_WAKEUP_MAIN ))
      {
        #if (defined(FEATURE_OOSC_USER_ACTION) && defined(FEATURE_WCDMA))
        if(ss_ptr->is_connected_mode_oos)
        {
          CM_MSG_HIGH_0(" wake up from pwr save with oosc Flag True");
          cmregprx_send_exit_from_pwr_save_ind(SD_SS_MAIN);
          /* if UE is in OOSC mode and user press a key, we need not to send
          ** wake up from power save cmd to mmoc, this would be handle by RRC
          */
        }
        else
        #endif
        /* No need to check the call state before sending Wakeup to MMOC from Power Save.
        ** as CM was not allowing to wake-up from stand-by when there is a call in Conv state.
        ** instead checking for Serving Status to avoid buffer overflow at MMOC.
        */

        if(ss_ptr->info.srv_status == SYS_SRV_STATUS_PWR_SAVE &&
           (ph_ptr->active_subs & BM(cmph_map_cm_ss_to_as_id(CM_SS_MAIN))))
        {
          mmoc_cmd_wakeup_from_pwr_save(SD_SS_MAIN);
        }

        /* If HYBR2 stack is operational and there is no service on both MAIN and
           HDR stack, proceed to restart HYBR2. If either MAIN or HDR has service
           hybr 2 will be in BSR timeline and should not be restarted.
        */
        if(ss_ptr->info.is_hybr_gw_operational &&
           !sys_srv_status_is_srv(ss_ptr->info.srv_status) &&
           !sys_srv_status_is_srv(ss_ptr->info.hdr_srv_status) &&
           cmph_is_subs_feature_mode_1x_sxlte(asubs_id))
        {
          if( ss_ptr->info.gw_srv_status == SYS_SRV_STATUS_PWR_SAVE &&
             (ph_ptr->active_subs & BM(cmph_map_cm_ss_to_as_id(CM_SS_HYBR_2))))
          {
            mmoc_cmd_wakeup_from_pwr_save(SD_SS_HYBR_2);
          }
        }

      }


      if( CM_CONTAIN ( cmd_info_ptr->wakeup_service,CM_WAKEUP_HDR )&&
          (ss_ptr->info.hdr_srv_status == SYS_SRV_STATUS_PWR_SAVE) &&
          (ph_ptr->active_subs & BM(cmph_map_cm_ss_to_as_id(CM_SS_MAIN))))
      {
         mmoc_cmd_wakeup_from_pwr_save(SD_SS_HYBR_HDR);
      }

      if( CM_CONTAIN ( cmd_info_ptr->wakeup_service,CM_WAKEUP_HYBR_GW ) &&
         cmph_is_msim())
      {
        #if (defined(FEATURE_OOSC_USER_ACTION) && defined(FEATURE_WCDMA))
        if(ss_ptr->hybr_gw_is_connected_mode_oos)
        {
          CM_MSG_HIGH_0(" wake up from pwr save with oosc Flag True");
          cmregprx_send_exit_from_pwr_save_ind(SD_SS_HYBR_2);
          /* if UE is in OOSC mode and user press a key, we need not to send
          ** wake up from power save cmd to mmoc, this would be handle by RRC
          */
        }
        else
        #endif
          if( ss_ptr->info.gw_srv_status == SYS_SRV_STATUS_PWR_SAVE &&
             (ph_ptr->active_subs & BM(cmph_map_cm_ss_to_as_id(CM_SS_HYBR_2))))
        {
          mmoc_cmd_wakeup_from_pwr_save(SD_SS_HYBR_2);
        }
      }


      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if( CM_CONTAIN ( cmd_info_ptr->wakeup_service,CM_WAKEUP_HYBR_GW3 ))
      {
        #if (defined(FEATURE_OOSC_USER_ACTION) && defined(FEATURE_WCDMA))
        if(ss_ptr->hybr_3_gw_is_connected_mode_oos)
        {
          CM_MSG_HIGH_0(" wake up from pwr save with oosc Flag True");
          cmregprx_send_exit_from_pwr_save_ind(SD_SS_HYBR_3);
          /* if UE is in OOSC mode and user press a key, we need not to send
          ** wake up from power save cmd to mmoc, this would be handle by RRC
          */
        }
        else
        #endif
        if( ss_ptr->info.gw3_srv_status == SYS_SRV_STATUS_PWR_SAVE &&
           (ph_ptr->active_subs & BM(cmph_map_cm_ss_to_as_id(CM_SS_HYBR_3))))
        {
          mmoc_cmd_wakeup_from_pwr_save(SD_SS_HYBR_3);
        }
      }
      #endif

      break;
    }
   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_DEACTIVATE_SUBS:
    {

      /* If CM is not waiting on any standby pref change and if the Subs has already been deactivated,
         inform MCFG of success immediately
      */
      if( (ph_ptr->active_subs & cmd_info_ptr->cmd_subs_mask ) == SYS_MODEM_AS_ID_NO_ACTIVE_MASK &&
           ph_ptr->num_standby_requests_processing == 0)
      {
        CM_MSG_HIGH_2("MCFG: Already deactivated: deact_subs %d, active_subs %d",
                    ph_ptr->mcfg_deactivate_subs,
                    ph_ptr->active_subs);
        
        ph_ptr->mcfg_deactivate_subs = cmd_info_ptr->cmd_subs_mask;
        break;
      }
      /* process the new standby pref change
      */
      /* If cleanup needs to be initiated, initiate it.
      */
      if( cmclnup_is_clnup_needed(CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_NONE, SYS_OPRT_MODE_NONE))
      {

        /* Cleanup not currently underway. Initiate it.*/
        cmclnup_initiate_cleanup(ph_cmd_ptr);

        /* If this new cleanup activity requires CM to wait for response,
        ** the command is already on the buffer queue. So end the processing.
        */
        if(cmclnup_is_ongoing_subsc(cmd_info_ptr->cmd_subs_mask))
        {
          return TRUE;
        }
      }

      cmd_info_ptr->standby_pref = ph_ptr->user_standby_pref;
      cmd_info_ptr->active_subs = ph_ptr->active_subs;
      ph_ptr->mcfg_deactivate_subs = cmd_info_ptr->cmd_subs_mask;
      cmd_info_ptr->default_voice_subs = ph_ptr->default_voice_subs ;
      cmd_info_ptr->default_data_subs = ph_ptr->default_data_subs;
      cmd_info_ptr->priority_subs = ph_ptr->priority_subs;
      cmd_info_ptr->dds_switch_type    = ph_ptr->dds_switch_type;
 
      ph_ptr->is_standby_pref_buffered = TRUE;
      cmph_cmd_standby_pref_proc(ph_cmd_ptr);

      /* If CM has sent a standby pref change to MMOC, wait for response
      */
      if(ph_ptr->num_standby_requests_processing > 0)
      {
        CM_MSG_HIGH_1("MCFG: wait for MMOC reply %d",ph_ptr->num_standby_requests_processing);
        cm_reply_set( &ph_ptr->reply,
                      (cm_cmd_type*)ph_cmd_ptr,               /* command waiting on reply */
                      CM_STANDBY_PREF_CHG_OK_F,           /* wait for this UI command */
                      CMPH_WAIT_DEACTIVATE_SUBS_TIME );    /* wait for this long */

      }

      break;
    }
   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_ACTIVATE_SUBS:
      /* Send subscription changed command.
      */
      {
        boolean is_valid_oprt_mode  = TRUE;

        prot_subsc_chg_e_type prot_subsc_chg = PROT_SUBSC_CHG_NONE;
        prot_subsc_chg_e_type hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_NONE;
        prot_subsc_chg_e_type hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_NONE;

        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

        /* Only notify MMOC if phone is currently online or powerup
        */
        if( !cm_is_valid_state_for_sub_proc(ph_ptr->oprt_mode))
        {
          is_valid_oprt_mode  = FALSE;
        }

        /* Check which subscriptions need to be activated */
        if ( cmd_info_ptr->cmd_subs_mask & SYS_MODEM_AS_ID_1_MASK)
        {
          prot_subsc_chg = ADD_PROTO (prot_subsc_chg, PROT_SUBSC_CHG_GW);
          prot_subsc_chg = ADD_PROTO (prot_subsc_chg, PROT_SUBSC_CHG_CDMA);

          if( ph_ptr->is_cdma_subscription_available &&
              cm_get_operator_info(SYS_MODEM_AS_ID_1) == OPERATOR_CT &&
		  	  !cmmmgsdi_read_cdma_imsi())
          {
            CM_ERR_0("CDMA IMSI Read Failed.");
          }      
		  
        }
        if ( cmd_info_ptr->cmd_subs_mask & SYS_MODEM_AS_ID_2_MASK)
        {
          /* When device is not in sxlte mode map the subscription change to hybrid 2
                 */
          if(!cmph_is_sxlte())
          {
          hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
        }
          else
          {
            /* When device is in sxlte mode and there is activate command for sub2 mapp
                    ** the subscription change for hybrid 3. Make sure sub 3 is not active
                    */
            if(!(cmd_info_ptr->cmd_subs_mask & SYS_MODEM_AS_ID_3_MASK))
            {
              hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
            }
          }
        }
        if ( cmd_info_ptr->cmd_subs_mask & SYS_MODEM_AS_ID_3_MASK)
    {
          hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
        }

        cmph_reset(ph_ptr,prot_subsc_chg,hybr_gw_prot_subsc_chg ,hybr_3_gw_prot_subsc_chg,ph_cmd_ptr);


        /* Clear the is hybr kicked flag and throttle table
        */
        if (prot_subsc_chg != PROT_SUBSC_CHG_NONE)
        {
          /* Reset the origination throttle table
          */
          cmss_orig_thr_table_reset( cmss_ptr()->cmss_orig_thr_tbl_ptr );
          *cmph_get_is_kicked_hybr_ptr() = FALSE;
          *cmph_get_is_kicked_hybr_2_ptr() = FALSE;
        }


        /* Queue a standby pref change indication to MMOC and update the active subs as given by MCFG
        */
      cmd_info_ptr->standby_pref = ph_ptr->user_standby_pref;

        /* update the active subs mask and mcfg_deactivate_subs mask as per the command*/
      CM_MSG_HIGH_3 ("MCFG: prev mcfg_deactivate_subs %d prev active_subs %d user_active_subs %d",
         ph_ptr->mcfg_deactivate_subs, ph_ptr->active_subs, ph_ptr->user_active_subs);
      cmd_info_ptr->active_subs = ph_ptr->user_active_subs;
      ph_ptr->mcfg_deactivate_subs &=  ~cmd_info_ptr->cmd_subs_mask;
      CM_MSG_HIGH_3("MCFG: new mcfg_deactivate_subs %d, active_subs %d cmd_subs_mask %d",
        ph_ptr->mcfg_deactivate_subs, ph_ptr->active_subs,cmd_info_ptr->cmd_subs_mask);
      cmd_info_ptr->default_voice_subs = ph_ptr->default_voice_subs ;
      cmd_info_ptr->default_data_subs = ph_ptr->default_data_subs;
      cmd_info_ptr->priority_subs = ph_ptr->priority_subs;
      cmd_info_ptr->dds_switch_type    = ph_ptr->dds_switch_type;

      /* If sub is not active earlier and not expected to be activated now ignore the activate command
        */
      if((ph_ptr->user_active_subs & cmd_info_ptr->cmd_subs_mask) != SYS_MODEM_AS_ID_NO_ACTIVE_MASK)
      {
      ph_ptr->active_subs |= cmd_info_ptr->cmd_subs_mask;
      ph_ptr->is_mmoc_standby_pref_not_req = TRUE;
      cmph_cmd_standby_pref_proc(ph_cmd_ptr);
      ph_ptr->is_mmoc_standby_pref_not_req = FALSE;
      }      

        /*If oprt mode is not valid, return now*/
        if (is_valid_oprt_mode  == FALSE)
        {
      break;
    }

          /* Inform CM Pref & MMOC that subscription changed.
          */
          {
            cm_pref_s_type  *hybr_2_pref_ptr = NULL;

            #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
            cm_pref_s_type  *hybr_3_pref_ptr = NULL;
  
            if(cmph_is_tsts() ||cmph_is_sxlte())
            {
              hybr_3_pref_ptr = &(ph_ptr->hybr_3_stack_info.pref_info);
            }
            #endif
            
            /* Allocate buffer only if multi-sim */
            if (cmph_is_msim() && !cmph_no_hybr2())
            {
              hybr_2_pref_ptr = cm_pref_ptr();
              memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
            }

            cmmsimc_proc_cmd_subsc_chgd(  MMOC_SUBSC_CHG_SUBSC_AVAIL,
              (byte) ph_ptr->curr_nam,
              ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
              ph_ptr->main_stack_info.pref_info.mode_pref,
              ph_ptr->main_stack_info.pref_info.band_pref,
              ph_ptr->main_stack_info.pref_info.lte_band_pref,
              ph_ptr->main_stack_info.pref_info.tds_band_pref,
              CMPH_PRST_PRL_PREF( ph_ptr ),
              CMPH_PRST_ROAM_PREF( ph_ptr ),
              ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].hybr_pref,
              ph_ptr->main_stack_info.pref_info.plmn,
              ph_ptr->main_stack_info.pref_info.srv_domain_pref,
              ph_ptr->main_stack_info.pref_info.acq_order_pref,
              hybr_2_pref_ptr,
              #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
              hybr_3_pref_ptr,
              #endif
              ph_ptr->is_gwl_subscription_available,
              ph_ptr->is_hybr_gw_subscription_available,
              ph_ptr->is_hybr_gw3_subscription_available,
              ph_ptr->is_cdma_subscription_available,
              prot_subsc_chg,
              hybr_gw_prot_subsc_chg,
              hybr_3_gw_prot_subsc_chg
             );

             /* Free allocated buffer */
             if (hybr_2_pref_ptr)
             {
               cm_mem_free (hybr_2_pref_ptr);
             }
           }
        }

      break;
   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #if ( defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) )
    case CM_PH_CMD_CHANGE_RTRE_CONFIG:
    {
      /*
      ** Send RTRE command to NV.
      */
      #if defined( FEATURE_UIM_RUIM )
      #if defined( FEATURE_UIM_RUN_TIME_ENABLE )
      /*
      ** RTRE enabled.
      */
      nv_rtre_control_type  rtre_control_val;
      /* Read the RTRE Config item from NV */
      switch ( ph_cmd_ptr->info.rtre_config )
      {
        case CM_RTRE_CONFIG_RUIM_ONLY:
          cmnv_item_ptr->rtre_config = NV_RTRE_CONFIG_RUIM_ONLY;
          break;

        case CM_RTRE_CONFIG_NV_ONLY:
          cmnv_item_ptr->rtre_config = NV_RTRE_CONFIG_NV_ONLY;
          break;

        case CM_RTRE_CONFIG_RUIM_OR_DROP_BACK:
          cmnv_item_ptr->rtre_config = NV_RTRE_CONFIG_RUIM_OR_DROP_BACK;
          break;

        case CM_RTRE_CONFIG_SIM_ACCESS:
          cmnv_item_ptr->rtre_config = NV_RTRE_CONFIG_SIM_ACCESS;
          break;

        default:
          CM_ERR_1("Unexpected config value %d",
                 ph_cmd_ptr->info.rtre_config);
          break;
      }

      if((cmclient_get_client_type(ph_cmd_ptr->client_id) != CM_CLIENT_TYPE_GSDI) ||
         ((cmclient_get_client_type(ph_cmd_ptr->client_id) == CM_CLIENT_TYPE_GSDI) &&
         (ph_cmd_ptr->info.rtre_config == CM_RTRE_CONFIG_RUIM_OR_DROP_BACK )))
      {
        cmnv_write_wait( NV_RTRE_CONFIG_I, cmnv_item_ptr ); /* Write to NV */
      }
      cmnv_send_rtre_command( cmnv_item_ptr ); /* Send RTRE config to NV */

      rtre_control_val = nv_rtre_control();

      switch ( rtre_control_val ) {
        case NV_RTRE_CONTROL_USE_RUIM:
          ph_cmd_ptr->info.rtre_control = CM_RTRE_CONTROL_RUIM;
          break;
        case NV_RTRE_CONTROL_NO_RUIM:
          ph_cmd_ptr->info.rtre_control = CM_RTRE_CONTROL_NV;
          /* Since CDMA subscription is from NV, instead of waiting for card
          ** events, send CDMA subscription available staright away.
          */
          #if defined(FEATURE_MMODE_CDMA) || defined(FEATURE_JCDMA)
          /* if target supports cdma then only make the cdma subs available */
          if(sd_misc_is_target_supp_mode_band(SD_SS_MODE_PREF_CDMA,
                                               SD_SS_BAND_PREF_ANY,
                                               SYS_LTE_BAND_MASK_CONST_ANY,
                                               SD_SS_BAND_PREF_NONE))
          {
            if( !cm_ph_cmd_subscription_available_new(
              NULL,
              NULL,
              CM_CLIENT_ID_ANONYMOUS,
              CM_SUBSCRIPTION_STATUS_CHANGE,
              CM_SUBSCRIPTION_STATUS_NO_CHANGE
              )
              )
            {
              CM_ERR_0("CDMA subs na RTRE nv");
            }
            else
            {
              CM_MSG_HIGH_0("CDMA subs a RTRE nv");
            }
          }
          else
          {
            CM_MSG_HIGH_0("Target does not support CDMA,not making CDMA subs available ");
          }
          #endif /* FEATURE_MMODE_CDMA || FEATURE_JCDMA */
          break;
        #ifdef FEATURE_UIM_RUIM_W_GSM_ACCESS
        case NV_RTRE_CONTROL_SIM_ACCESS:
          ph_cmd_ptr->info.rtre_control = CM_RTRE_CONTROL_SIM;
          break;
        #endif  /* FEATURE_UIM_RUIM_W_GSM_ACCESS */
        default:
        {
          CM_ERR_1("Unexpected nv rtre control value %d",
              rtre_control_val);
        }
      }
      #else /* defined( FEATURE_UIM_RUN_TIME_ENABLE ) */
      /*
      ** RUIM only
      */
      ph_cmd_ptr->info.rtre_control = CM_RTRE_CONTROL_RUIM;
      #endif /* else of defined( FEATURE_UIM_RUN_TIME_ENABLE ) */
      #else /* defined( FEATURE_UIM_RUIM ) */
      /*
      ** NV only
      */
      ph_cmd_ptr->info.rtre_control = CM_RTRE_CONTROL_NV;
      #endif /* else of defined( FEATURE_UIM_RUIM ) */
      break;
    }

    #endif /* defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                      /*------------------------*/
                      /* Perso info available */
                      /*------------------------*/

    case CM_PH_CMD_PERSO_INFO_AVAILABLE:
    {
      boolean is_gwl_perso_lock          = FALSE;
      boolean is_hybr_gw_perso_lock      = FALSE;
      boolean is_cdma_perso_lock         = FALSE;
      boolean is_hybr_3_perso_lock       = FALSE;

      prot_subsc_chg_e_type prot_subsc_chg = PROT_SUBSC_CHG_NONE;
      prot_subsc_chg_e_type hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_NONE;
      prot_subsc_chg_e_type hybr_3_prot_subsc_chg = PROT_SUBSC_CHG_NONE;

      CM_MSG_HIGH_0("CM_PH_CMD_PERSO_INFO_AVAILABLE is being processed");

      if( !cm_is_valid_state_for_sub_proc(ph_ptr->oprt_mode) && ph_ptr->oprt_mode != SYS_OPRT_MODE_FTM)
      {
        break;
      }

      if(cmph_is_subs_buffered(ph_cmd_ptr))
      {
        break;
      }

      if ( cmd_info_ptr->gwl_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
          is_gwl_perso_lock = TRUE;
          prot_subsc_chg = ADD_PROTO (prot_subsc_chg, PROT_SUBSC_CHG_GW);
      }

      if ( cmd_info_ptr->gw2_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
          is_hybr_gw_perso_lock = TRUE;
          hybr_gw_prot_subsc_chg = ADD_PROTO (hybr_gw_prot_subsc_chg, PROT_SUBSC_CHG_GW);
      }

      if ( cmd_info_ptr->cdma_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
          is_cdma_perso_lock = TRUE;
          prot_subsc_chg = ADD_PROTO (prot_subsc_chg, PROT_SUBSC_CHG_CDMA);
      }

      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if ( cmd_info_ptr->gw3_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
          is_hybr_3_perso_lock = TRUE;
          hybr_3_prot_subsc_chg = ADD_PROTO (hybr_3_prot_subsc_chg, PROT_SUBSC_CHG_GW);
      }
      #endif

      CM_MSG_HIGH_4 ("perso lock: gwl %d, hybr_gw %d cdma %d perso lock: hybr_gw_3 %d",
               is_gwl_perso_lock, is_hybr_gw_perso_lock, is_cdma_perso_lock, is_hybr_3_perso_lock);
      

      cmph_send_mmoc_perso_subsc_chgd(prot_subsc_chg,
                                      hybr_gw_prot_subsc_chg,
                                      hybr_3_prot_subsc_chg,
                                      is_cdma_perso_lock,
                                      is_gwl_perso_lock,
                                      is_hybr_gw_perso_lock,
                                      is_hybr_3_perso_lock);

      break;
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                      /*------------------------*/
                      /* Subscription Available */
                      /*------------------------*/

    case CM_PH_CMD_SUBSCRIPTION_AVAILABLE:
    {
      boolean gwl_available     = ph_ptr->is_gwl_subscription_available;
      boolean hybr_gw_available = ph_ptr->is_hybr_gw_subscription_available;
      boolean hybr_3_gw_available = ph_ptr->is_hybr_gw3_subscription_available;
      boolean cdma_available    = ph_ptr->is_cdma_subscription_available;

      prot_subsc_chg_e_type prot_subsc_chg = PROT_SUBSC_CHG_NONE;
      prot_subsc_chg_e_type hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_NONE;
      prot_subsc_chg_e_type hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_NONE;

      sys_modem_as_id_e_type    sub_asub_id = SYS_MODEM_AS_ID_NONE;

      cm_mode_pref_e_type   mode_pref;

      boolean               force_all = FALSE;
      cm_mmgsdi_session_id_table_entry_s_type* entry;

      #ifdef CM_GW_SUPPORTED

      #ifdef FEATURE_GSTK
      mmgsdi_refresh_file_list_type      rat_bal_file_info; /* File info */
      mmgsdi_file_enum_type              rat_bal_file_list =
                                                   MMGSDI_USIM_7F66_PROP1_RAT;

      CM_MSG_HIGH_0("CM_PH_CMD_SUBSCRIPTION_AVAILABLE is being processed");

      #endif /* FEATURE_GSTK */

      #endif /* FEATURE_WCDMA || FEATURE_GSM */

      /*Return true if subsc is buffered as well
      ** since cmd reused it not checked while freeing*/

      if(cmph_is_subs_buffered(ph_cmd_ptr))
      {
        return TRUE;
      }

      /* Abort indication will be sent to the sub:
             WHose subscription is getting changed*/
      if(cmd_info_ptr->gw2_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        sub_asub_id = ph_ptr->hybr_2_stack_info.asubs_id;
      }
      #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
      else if(cmd_info_ptr->gw3_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        sub_asub_id = ph_ptr->hybr_3_stack_info.asubs_id;
      }
      #endif
      else if(cmd_info_ptr->gwl_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE ||
              cmd_info_ptr->cdma_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        sub_asub_id = ph_ptr->main_stack_info.asubs_id;
      }
      else
      {
        sub_asub_id = SYS_MODEM_AS_ID_1;
      }
      CM_MSG_LOW_1("CM_PH_CMD_SUBSCRIPTION_AVAILABLE: calling cmph_is_abort_wait() with %d", sub_asub_id);

      if( cmph_is_abort_wait(ph_cmd_ptr,SYS_STOP_MODE_REASON_MODE_CHANGE, sub_asub_id))
      {
        return TRUE;
      }


      mode_pref = CMPH_PRST_MODE_PREF(ph_ptr);

      if ( cmd_info_ptr->gwl_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        gwl_available = TRUE;

        if (!ph_ptr->is_gwl_subscription_available)
        {
          prot_subsc_chg = ADD_PROTO (prot_subsc_chg, PROT_SUBSC_CHG_GW);

          cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->main_stack_info.asubs_id,
                                                                  CMPMPRX_SUBSC_AVAIL,
                                                                  CMPMPRX_SUBSC_NO_CHANGE);
        }

        /* Set a flag to indicate subscription processing in progress
        */
        cmph_subsc_cmd_proccessing_in_progress = TRUE;

        entry = cm_mmgsdi_ssn_tbl_get_entry_by_type(MMGSDI_GW_PROV_PRI_SESSION);
        cmpmprx_session_chgd(MMGSDI_GW_PROV_PRI_SESSION, TRUE, entry->app_info.app_data.app_type);

        #ifdef CM_GW_SUPPORTED

        cmwaoc_init_using_mmgsdi(CM_SS_MAIN);

        /* initialize RPM */
        cmph_rpm_init();

        #ifdef FEATURE_GSTK

        /* Read EF_RAT file */
        rat_bal_file_info.file_list_ptr = &rat_bal_file_list;
        rat_bal_file_info.num_files = 1;

        
        CM_MSG_HIGH_2 ("ENS enabled: %d, Rat_bal enabled: %d", ph_ptr->main_stack_info.ens_value, ph_ptr->is_rat_bal);

        if ( ph_ptr->is_rat_bal == TRUE && cmph_is_sub1_mm_in_single_standby())
        {
          cmmmgsdi_refresh_files_read_proc( CM_SS_MAIN, &rat_bal_file_info,
                                            CM_CLIENT_ID_ANONYMOUS
                                          );
          if ( gwl_available == TRUE)
          {
            mode_pref = cmph_read_efrat_mode_pref_subsc_chgd(gwl_available);
          }
          /* Remove LTE from the mode pref for CS_ONLY domain */
          #ifdef FEATURE_CM_LTE
          if(ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY)
          {
            cm_mode_pref_e_type new_mode_pref;
            new_mode_pref = cm_remove_mode_pref_components(mode_pref, 1,
                                                           SD_SS_MODE_PREF_GWL_LTE);
            if(new_mode_pref != mode_pref)
            {
              mode_pref = new_mode_pref;
            }
          }
          #endif

          #if defined FEATURE_HDR && defined FEATURE_MMODE_DUAL_SIM
          /* For msim, remove HDR if sub0 is not default data sub */
          if (cmph_is_msim() &&
             ph_ptr->default_data_subs != ph_ptr->main_stack_info.asubs_id)
          {
            cm_mode_pref_e_type new_mode_pref;
            new_mode_pref = cm_remove_mode_pref_components(
                                    mode_pref, 1,
                                    SD_SS_MODE_PREF_HDR);
            if(new_mode_pref != mode_pref)
            {
              mode_pref = new_mode_pref;
            }
          }
          #endif


        }

        #endif /* FEATURE_GSTK */
        #endif /* FEATURE_WCDMA || FEATURE_GSM */
      }

      if (cmd_info_ptr->gw2_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        hybr_gw_available = TRUE;
        entry = cm_mmgsdi_ssn_tbl_get_entry_by_type(MMGSDI_GW_PROV_SEC_SESSION);
        cmpmprx_session_chgd(MMGSDI_GW_PROV_SEC_SESSION, TRUE, entry->app_info.app_data.app_type);

        if (!ph_ptr->is_hybr_gw_subscription_available)
        {
          hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
          cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->hybr_2_stack_info.asubs_id,
                                                                  CMPMPRX_SUBSC_AVAIL,
                                                                  CMPMPRX_SUBSC_NO_CHANGE);
        }

        #ifdef CM_GW_SUPPORTED
        cmwaoc_init_using_mmgsdi(CM_SS_HYBR_2);
        #endif /* WCDMA || GSM */
      }


      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if ( cmd_info_ptr->gw3_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        hybr_3_gw_available = TRUE;

        #ifdef FEATURE_MMODE_TRIPLE_SIM
        if(cmph_is_tsts())
        {
          entry = cm_mmgsdi_ssn_tbl_get_entry_by_type(MMGSDI_GW_PROV_TER_SESSION);
          cmpmprx_session_chgd(MMGSDI_GW_PROV_TER_SESSION, TRUE, entry->app_info.app_data.app_type);
        }
        else
        #endif
        {
          entry = cm_mmgsdi_ssn_tbl_get_entry_by_type(MMGSDI_GW_PROV_SEC_SESSION);
          cmpmprx_session_chgd(MMGSDI_GW_PROV_SEC_SESSION, TRUE, entry->app_info.app_data.app_type);
        }

        if (!ph_ptr->is_hybr_gw3_subscription_available)
        {
          hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
          cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->hybr_3_stack_info.asubs_id,
                                                                  CMPMPRX_SUBSC_AVAIL,
                                                                  CMPMPRX_SUBSC_NO_CHANGE);
        }

        #ifdef CM_GW_SUPPORTED
        cmwaoc_init_using_mmgsdi(CM_SS_HYBR_3);
        #endif /* WCDMA || GSM */
      }
      #endif /* FEATURE_MMODE_DUAL_SIM */

      if ( cmd_info_ptr->cdma_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        cdma_available = TRUE;

        if (!ph_ptr->is_cdma_subscription_available)
        {
          entry = cm_mmgsdi_ssn_tbl_get_entry_by_type(MMGSDI_1X_PROV_PRI_SESSION);
          cmpmprx_session_chgd(MMGSDI_1X_PROV_PRI_SESSION, TRUE, entry->app_info.app_data.app_type);
          prot_subsc_chg = ADD_PROTO (prot_subsc_chg, PROT_SUBSC_CHG_CDMA);
          cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->main_stack_info.asubs_id,
                                                                  CMPMPRX_SUBSC_NO_CHANGE,
                                                                  CMPMPRX_SUBSC_AVAIL);

          #if defined(FEATURE_DDTM_CNTL) && defined(FEATURE_MMGSDI_SESSION_LIB)

          if(cm_is_jcdma_enable() && cmmmgsdi_is_jcdma_card_white_equiv())
          {

            sys_ddtm_act_mask_e_type ddtm_mask;
            mc_msg_type                    *mc_ptr;
                /* MC command pointer */
            sys_srv_opt_type so_list[] = {CAI_SO_NULL};

            ddtm_mask = SYS_DDTM_ACT_MASK_SUPPRESS_REG;

            mc_ptr                                = cm_mc_get_buf_else_err_fatal();
            mc_ptr->hdr.cmd                       = MC_DDTM_CNTL_F;
            mc_ptr->ddtm_cntl.status              = TRUE;
            mc_ptr->ddtm_cntl.ddtm_act_mask       = ddtm_mask;
            mc_ptr->ddtm_cntl.num_srv_opt         = ARR_SIZE(so_list);
            mc_ptr->ddtm_cntl.srv_opt_list[0]     = so_list[0];

            ph_ptr->cur_ddtm_act_mask = ddtm_mask;
            ph_ptr->cur_ddtm_status = TRUE;
            ph_ptr->cur_ddtm_num_srv_opt = ARR_SIZE(so_list);
            ph_ptr->cur_ddtm_srv_opt_list[0] = so_list[0];

            CM_MSG_HIGH_3( "Send DDTM status=%d mask 0x%x num_srv_opt %d",
                         mc_ptr->ddtm_cntl.status,
                         mc_ptr->ddtm_cntl.ddtm_act_mask,
                         mc_ptr->ddtm_cntl.num_srv_opt);
            cm_mc_send_cmd( mc_ptr );

          }
          #endif

        }
      }

      if ( cmd_info_ptr->cdma_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE &&
          !ph_ptr->is_cdma_subscription_available && 
          cm_get_operator_info(ph_ptr->main_stack_info.asubs_id) == OPERATOR_CT)
      {
        if(!cmmmgsdi_read_cdma_imsi())
        {
          CM_ERR_0("CDMA IMSI Read Failed.");
        }
      }

      #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
      #if (defined(FEATURE_OTASP) || defined (FEATURE_UIM_RUIM))
      diag_otasp_update();              /* Tell Diag to update its cache */
      #endif   /* FEATURE_OTASP || FEATURE_UIM_RUIM */
      #endif   /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */

      cmph_reset(ph_ptr,prot_subsc_chg, hybr_gw_prot_subsc_chg,hybr_3_gw_prot_subsc_chg,ph_cmd_ptr);

      #ifdef CM_GW_SUPPORTED
      if ( ph_ptr->is_rat_bal == FALSE){
          mode_pref = ph_ptr->main_stack_info.pref_info.mode_pref;
      }
      #endif

      /* Reset the origination throttle table
      */
      cmss_orig_thr_table_reset( cmss_ptr()->cmss_orig_thr_tbl_ptr );

      /* Clear the is hybr kicked flag
      */
      if (prot_subsc_chg != PROT_SUBSC_CHG_NONE)
      {
      *cmph_get_is_kicked_hybr_ptr() = FALSE;
      *cmph_get_is_kicked_hybr_2_ptr() = FALSE;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Validate curr_nam */
      if(!INRANGE(ph_ptr->curr_nam, 0, CM_NAM_AUTO))
      {
        CM_ERR_0( "curr_nam is invalid!!!, no subsc cmd sent");
        break;
      }

     #ifdef FEATURE_MMODE_DUAL_SIM

      if(!ph_ptr->is_standby_pref_buffered && \
          (cmph_is_msim())
        )
      {
        ph_ptr->is_standby_pref_buffered = (cmcall_is_there_a_call_type(CM_SS_MAX,
          CM_CALL_TYPE_VOICE, CM_CALL_ID_INVALID)!= CM_CALL_ID_INVALID);
        CM_MSG_HIGH_1("ph_ptr->is_standby_pref_buffered=%d", ph_ptr->is_standby_pref_buffered);

      }
      /* Once the subscription change is sent, if the standby pref is AUTO
          ** Kick CM to re-evaluate the preferences.
          */
      if((ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO ||
          ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY)
          && !ph_ptr->is_standby_pref_buffered && cmph_is_msim())
      {
        cm_ph_cmd_info_s_type       *cmd_info_ptr1 = (cm_ph_cmd_info_s_type*) cm_mem_malloc
                                    (sizeof (cm_ph_cmd_info_s_type));
        cmd_info_ptr1->standby_pref       = ph_ptr->user_standby_pref;
        cmd_info_ptr1->active_subs        = ph_ptr->active_subs;
        cmd_info_ptr1->default_data_subs  = ph_ptr->default_data_subs;
        cmd_info_ptr1->default_voice_subs = ph_ptr->default_voice_subs;
        cmd_info_ptr1->priority_subs = ph_ptr->priority_subs;
        cmd_info_ptr1->oprt_mode = ph_ptr->oprt_mode;
        cmd_info_ptr1->dds_switch_type    = ph_ptr->dds_switch_type;

        #ifndef FEATURE_CM_DUAL_SIM_TUNEAWAY
        if(cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY)
        {
          cmd_info_ptr->standby_pref = SYS_MODEM_DS_PREF_AUTO;
        }
        #endif

        force_all = cmph_cmd_standby_pref_proc_int(cmd_info_ptr1,
                                       ph_cmd_ptr->cmd,
                                       ph_cmd_ptr->client_id,
                                       cdma_available,
                                       gwl_available,
                                       hybr_gw_available,
                                       hybr_3_gw_available
                                       );
        ph_ptr->standby_pref          = cmd_info_ptr1->standby_pref;
        ph_ptr->active_subs           = cmd_info_ptr1->active_subs;
        if(SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY == cmd_info_ptr1->standby_pref)
        {
          ph_ptr->internal_standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
        }
        else
        {
          ph_ptr->internal_standby_pref = cmd_info_ptr1->standby_pref;
        }

                  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
                  /* Send the PH Event that Standby Preferences have changed */
        cmph_event( ph_ptr, CM_PH_EVENT_DUAL_STANDBY_PREF );

         /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        cm_mem_free(cmd_info_ptr1);
      }
      #endif /* FEATURE_MMODE_DUAL_SIM */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	  
      if( !cm_is_valid_state_for_sub_proc(ph_ptr->oprt_mode) )
      {
        break;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      {
        cm_network_sel_mode_pref_e_type net_sel_mode_pref[MAX_AS_IDS] = {CM_NETWORK_SEL_MODE_PREF_NONE};
        sys_modem_as_id_e_type          as_id_i                       = SYS_MODEM_AS_ID_1;
        cm_orig_q_s_type *ph_orig_top_ptr = NULL;
        

      cm_pref_s_type  *hybr_2_pref_ptr = NULL;

        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        cm_pref_s_type  *hybr_3_pref_ptr = NULL;
        #endif

        #ifdef FEATURE_MMODE_DUAL_SIM
        for (; as_id_i < MAX_AS_IDS; as_id_i++)
        #endif
        {
          #ifdef FEATURE_MMODE_DUAL_SIM
          if (!cmph_is_msim() && as_id_i != SYS_MODEM_AS_ID_1)
          {
            continue;
          }
          #endif
          ph_orig_top_ptr = cmtask_orig_para_get_top( cmph_map_as_id_to_cm_ss(as_id_i) );
        if( ph_orig_top_ptr != NULL &&
            ph_orig_top_ptr->act_type == CM_ACT_TYPE_POLICYMAN_RESTRICT )
        {
          if( ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG )
          {
              net_sel_mode_pref[as_id_i] = CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV;
          }
          else
          {
              switch(CMPH_SS_NETWORK_SEL_MODE_PREF(as_id_i,ph_ptr))
            {
               case CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY:
               case CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV:
               case CM_NETWORK_SEL_MODE_PREF_MANUAL:
                   net_sel_mode_pref[as_id_i] = CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY;
                 break;

               default:
                   net_sel_mode_pref[as_id_i] = CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY;
                 break;
            }
          }
        }
        else
        {
            net_sel_mode_pref[as_id_i] = CMPH_SS_NETWORK_SEL_MODE_PREF(as_id_i,ph_ptr);
          }
        }
        /* Inform CM Pref & MMOC that subscription changed.
        */
        {
         if (cmph_is_msim())
          {
          if (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1))
          {
            #ifdef FEATURE_MMODE_DUAL_SIM
            hybr_2_pref_ptr = cm_pref_ptr();
            memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
            hybr_2_pref_ptr->network_sel_mode_pref = net_sel_mode_pref[SYS_MODEM_AS_ID_1];
          #endif
            #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
            hybr_3_pref_ptr = cm_pref_ptr();
            memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
            hybr_3_pref_ptr->network_sel_mode_pref = net_sel_mode_pref[SYS_MODEM_AS_ID_2];
            #endif
          }
          else
          {
            #ifdef FEATURE_MMODE_DUAL_SIM
            hybr_2_pref_ptr = cm_pref_ptr();
            memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
            hybr_2_pref_ptr->network_sel_mode_pref = net_sel_mode_pref[SYS_MODEM_AS_ID_2];
            #endif

            #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
            hybr_3_pref_ptr = cm_pref_ptr();
            memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
            #endif
          }

          }
        CM_MSG_HIGH_3("net_sel_mode %d %d %d",net_sel_mode_pref[CM_SS_MAIN],net_sel_mode_pref[CM_SS_HYBR_2],net_sel_mode_pref[CM_SS_HYBR_3]);

          if(force_all)
          {
            prot_subsc_chg |= PROT_SUBSC_CHG_GW;
            if(!cmph_is_sxlte())
            {
              hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
            }

            if(cmph_is_tsts() || cmph_is_sxlte())
            {
              hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
            }
                        
          }
          
          cmmsimc_proc_cmd_subsc_chgd(  MMOC_SUBSC_CHG_SUBSC_AVAIL,
             (byte) ph_ptr->curr_nam,
              net_sel_mode_pref[SYS_MODEM_AS_ID_1],
              mode_pref,
              ph_ptr->main_stack_info.pref_info.band_pref,
              ph_ptr->main_stack_info.pref_info.lte_band_pref,
              ph_ptr->main_stack_info.pref_info.tds_band_pref,
              CMPH_PRST_PRL_PREF( ph_ptr ),
              CMPH_PRST_ROAM_PREF( ph_ptr ),
              ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].hybr_pref,
              ph_ptr->main_stack_info.pref_info.plmn,
              ph_ptr->main_stack_info.pref_info.srv_domain_pref,
              ph_ptr->main_stack_info.pref_info.acq_order_pref,
              hybr_2_pref_ptr,
              #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
              hybr_3_pref_ptr,
              #endif
              gwl_available,
              hybr_gw_available,
              hybr_3_gw_available,
              cdma_available,
              prot_subsc_chg,
              hybr_gw_prot_subsc_chg,
              hybr_3_gw_prot_subsc_chg
           );

           /* Free allocated buffer */
           if (hybr_2_pref_ptr)
           {
             cm_mem_free (hybr_2_pref_ptr);
           }
         }
      }

    }
    break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                      /*----------------------------*/
                      /* Subscription Not Available */
                      /*----------------------------*/

    case CM_PH_CMD_SUBSCRIPTION_NOT_AVAILABLE:
    {
      boolean gwl_available = ph_ptr->is_gwl_subscription_available;
      boolean hybr_gw_available = ph_ptr->is_hybr_gw_subscription_available;
      boolean hybr_3_gw_available = ph_ptr->is_hybr_gw3_subscription_available;
      boolean cdma_available = ph_ptr->is_cdma_subscription_available;
      prot_subsc_chg_e_type prot_subsc_chg = PROT_SUBSC_CHG_NONE;
      prot_subsc_chg_e_type hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_NONE;
      prot_subsc_chg_e_type hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_NONE;

      sys_modem_as_id_e_type    sub_asub_id = SYS_MODEM_AS_ID_NONE;
      sys_modem_dual_standby_pref_e_type prev_standby_pref = ph_ptr->internal_standby_pref;
      boolean               force_all = FALSE;
      cm_mmgsdi_session_id_table_entry_s_type* entry;

      CM_MSG_HIGH_0("CM_PH_CMD_SUBSCRIPTION_NOT_AVAILABLE is being processed");

      /*Return true if subsc is buffered as well
      ** since cmd reused it not checked while freeing*/

      if(cmph_is_subs_buffered(ph_cmd_ptr))
      {
        return TRUE;
      }


      if( cmclnup_is_clnup_needed(cmd_info_ptr->sub_not_avail_cause, SYS_OPRT_MODE_NONE))
      {
        cm_ph_cmd_info_s_type const * cmd_info_ptr = CMD_INFO_PTR(ph_cmd_ptr);
        uint8 subs_bm = cmph_compute_subs_bitmask(
                                      cmd_info_ptr->cdma_sub_not_avail_status,
                                      cmd_info_ptr->gwl_sub_not_avail_status,
                                      cmd_info_ptr->gw2_sub_not_avail_status,
                                      cmd_info_ptr->gw3_sub_not_avail_status);

        /* Cleanup not currently underway. Initiate it.*/
        cmclnup_initiate_cleanup(ph_cmd_ptr);

        /* If this new cleanup activity requires CM to wait for response,
        ** the command is already on the buffer queue. So end the processing.
        */
        if(cmclnup_is_ongoing_subsc(subs_bm))
        {
          return TRUE;
        }
      }

      /* Abort indication will be sent to the sub:
             WHose subscription is getting changed */
      if(cmd_info_ptr->gw2_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        sub_asub_id = ph_ptr->hybr_2_stack_info.asubs_id;
      }
      #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
      else if(cmd_info_ptr->gw3_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        sub_asub_id = ph_ptr->hybr_3_stack_info.asubs_id;
      }
      #endif
      else if(cmd_info_ptr->gwl_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE ||
              cmd_info_ptr->cdma_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        sub_asub_id = ph_ptr->main_stack_info.asubs_id;
      }
      else
      {
        sub_asub_id = SYS_MODEM_AS_ID_1;
      }
      CM_MSG_LOW_1("CM_PH_CMD_SUBSCRIPTION_NOT_AVAILABLE: calling cmph_is_abort_wait() with %d", sub_asub_id);

      if( cmph_is_abort_wait(ph_cmd_ptr,SYS_STOP_MODE_REASON_MODE_CHANGE, sub_asub_id))
      {
        return TRUE;
      }

      if ( cmd_info_ptr->gwl_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        gwl_available = FALSE;
        entry = cm_mmgsdi_ssn_tbl_get_entry_by_type(MMGSDI_GW_PROV_PRI_SESSION);
        cmpmprx_session_chgd(MMGSDI_GW_PROV_PRI_SESSION, FALSE, entry->app_info.app_data.app_type);

        /* GW subscription information has changed, so record protocol
        */
        if (ph_ptr->is_gwl_subscription_available)
        {
          prot_subsc_chg = ADD_PROTO (prot_subsc_chg, PROT_SUBSC_CHG_GW);

          cmpmprx_update_cm_policy_consumption_eligibility_subsc(SYS_MODEM_AS_ID_1,
                                                                  CMPMPRX_SUBSC_NOT_AVAIL,
                                                                  CMPMPRX_SUBSC_NO_CHANGE);
          }

        #ifdef CM_GW_SUPPORTED
        /* GW subscription not available, so mark EF-RAT present as FALSE */
        /* This will become TRUE again when correct USIM is present. */
        ph_ptr->is_uim_usim_rat_present = FALSE;
        #endif

      }

      if ( cmd_info_ptr->gw2_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        hybr_gw_available = FALSE;
        entry = cm_mmgsdi_ssn_tbl_get_entry_by_type(MMGSDI_GW_PROV_SEC_SESSION);
        cmpmprx_session_chgd(MMGSDI_GW_PROV_SEC_SESSION, FALSE, entry->app_info.app_data.app_type);

        if (ph_ptr->is_hybr_gw_subscription_available)
        {
          hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
          cmpmprx_update_cm_policy_consumption_eligibility_subsc(SYS_MODEM_AS_ID_2,
                                                                  CMPMPRX_SUBSC_NOT_AVAIL,
                                                                  CMPMPRX_SUBSC_NO_CHANGE);
        }
      }

      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if ( cmd_info_ptr->gw3_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        hybr_3_gw_available = FALSE;

        if (ph_ptr->is_hybr_gw3_subscription_available)
        {
          if (cmph_is_tsts())
          {
            cmpmprx_update_cm_policy_consumption_eligibility_subsc(SYS_MODEM_AS_ID_3,
                                                                  CMPMPRX_SUBSC_NOT_AVAIL,
                                                                  CMPMPRX_SUBSC_NO_CHANGE);
            entry = cm_mmgsdi_ssn_tbl_get_entry_by_type(MMGSDI_GW_PROV_TER_SESSION);
            cmpmprx_session_chgd(MMGSDI_GW_PROV_TER_SESSION, FALSE, entry->app_info.app_data.app_type);

          }
          else
          {
            cmpmprx_update_cm_policy_consumption_eligibility_subsc(SYS_MODEM_AS_ID_2,
                                                                  CMPMPRX_SUBSC_NOT_AVAIL,
                                                                  CMPMPRX_SUBSC_NO_CHANGE);
            entry = cm_mmgsdi_ssn_tbl_get_entry_by_type(MMGSDI_GW_PROV_SEC_SESSION);
            cmpmprx_session_chgd(MMGSDI_GW_PROV_SEC_SESSION, FALSE, entry->app_info.app_data.app_type);

          }
          hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
        }
      }
      #endif

      if ( cmd_info_ptr->cdma_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        cdma_available = FALSE;

        /* CDMA subscription information has changed, so record protocol.
        */
        if (ph_ptr->is_cdma_subscription_available)
        {
          entry = cm_mmgsdi_ssn_tbl_get_entry_by_type(MMGSDI_1X_PROV_PRI_SESSION);
          cmpmprx_session_chgd(MMGSDI_1X_PROV_PRI_SESSION, FALSE, entry->app_info.app_data.app_type);
          prot_subsc_chg = ADD_PROTO (prot_subsc_chg, PROT_SUBSC_CHG_CDMA);
          cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->main_stack_info.asubs_id,
                                                                  CMPMPRX_SUBSC_NO_CHANGE,
                                                                  CMPMPRX_SUBSC_NOT_AVAIL);
        }
        #if defined(FEATURE_MMGSDI_SESSION_LIB) && defined(FEATURE_CM_MMGSDI_PROCEED_WITH_REFRESH)
        /*send ok_to_proceed to MMGSDI */
        if(cm_mmgsdi_is_waiting_to_proceed_with_refresh(MMGSDI_1X_PROV_PRI_SESSION))
        {
          cmmmgsdi_proceed_with_refresh(CM_SS_MAIN);
        }
        #endif

      }

      // end all ps calls which are in hold or active or silent redail
      if(ph_ptr->is_gwl_subscription_available && !gwl_available)
      {
        cmcall_end_gw_ps_calls_on_subsc_not_avail(CM_SS_MAIN);
      }

	  /* Unforce policy on MAIN stack when no subscription is available */
      if( (ph_ptr->is_gwl_subscription_available && !gwl_available && !ph_ptr->is_cdma_subscription_available) ||
	  	  (ph_ptr->is_cdma_subscription_available && !cdma_available && !ph_ptr->is_gwl_subscription_available) ||
	  	  (ph_ptr->is_gwl_subscription_available && !gwl_available && ph_ptr->is_cdma_subscription_available && !cdma_available) )
      {
        cmpmprx_unforce_policy(cmph_map_cm_ss_to_subs(CM_SS_MAIN));
      }

      if(ph_ptr->is_hybr_gw_subscription_available && !hybr_gw_available)
      {
        cmcall_end_gw_ps_calls_on_subsc_not_avail(CM_SS_HYBR_2);
		
        cmpmprx_unforce_policy(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2));		
      }

      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if(ph_ptr->is_hybr_gw3_subscription_available && !hybr_3_gw_available)
      {
        cmcall_end_gw_ps_calls_on_subsc_not_avail(CM_SS_HYBR_3);
		
        cmpmprx_unforce_policy(cmph_map_cm_ss_to_subs(CM_SS_HYBR_3));		
      }
      #endif

      cmph_remove_orig_mode_with_priority_end_per_subs(sub_asub_id);

      /* Reset the origination throttle table
      */
      cmss_orig_thr_table_reset( cmss_ptr()->cmss_orig_thr_tbl_ptr );

      /* Clear the is hybr kicked flag
      */
      if (prot_subsc_chg != PROT_SUBSC_CHG_NONE)
      {
      *cmph_get_is_kicked_hybr_ptr() = FALSE;
      *cmph_get_is_kicked_hybr_2_ptr() = FALSE;
      }

      if( ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE  &&
        ph_ptr->oprt_mode != SYS_OPRT_MODE_PSEUDO_ONLINE)
      {
        if(cmd_info_ptr->gwl_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          #if defined(FEATURE_MMGSDI_SESSION_LIB) && defined(FEATURE_CM_MMGSDI_PROCEED_WITH_REFRESH)
          cmmmgsdi_proceed_with_refresh(CM_SS_MAIN);
          #endif
        }
        else if (cmd_info_ptr->gw2_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          #if defined(FEATURE_MMGSDI_SESSION_LIB) && defined(FEATURE_CM_MMGSDI_PROCEED_WITH_REFRESH)
          cmmmgsdi_proceed_with_refresh(CM_SS_HYBR_2);
          #endif
        }
        else if (cmd_info_ptr->gw3_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          #if defined(FEATURE_MMGSDI_SESSION_LIB) && defined(FEATURE_CM_MMGSDI_PROCEED_WITH_REFRESH)
          cmmmgsdi_proceed_with_refresh(CM_SS_HYBR_3);
          #endif
        }
      }

        #if defined(FEATURE_MMGSDI_SESSION_LIB) && defined(FEATURE_CM_MMGSDI_PROCEED_WITH_REFRESH)
          if(((!gwl_available && (prot_subsc_chg & PROT_SUBSC_CHG_GW)) ||
             (!cdma_available && (prot_subsc_chg & PROT_SUBSC_CHG_CDMA))) &&
          !(ph_ptr->active_subs & BM(ph_ptr->main_stack_info.asubs_id)) )
          {
            cmmmgsdi_proceed_with_refresh_subs(ph_ptr->main_stack_info.asubs_id);
          }

      if((!hybr_gw_available && (hybr_gw_prot_subsc_chg & PROT_SUBSC_CHG_GW)) &&
         !(ph_ptr->active_subs & BM(ph_ptr->hybr_2_stack_info.asubs_id)) )
          {
            cmmmgsdi_proceed_with_refresh_subs(ph_ptr->hybr_2_stack_info.asubs_id);
          }
      #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
      if((!hybr_3_gw_available && (hybr_3_gw_prot_subsc_chg & PROT_SUBSC_CHG_GW)) &&
         !(ph_ptr->active_subs & BM(ph_ptr->hybr_3_stack_info.asubs_id)) )
          {
            cmmmgsdi_proceed_with_refresh_subs(ph_ptr->hybr_3_stack_info.asubs_id);
          }
       #endif /*defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)*/
       #endif

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      cmph_reset(ph_ptr,prot_subsc_chg, hybr_gw_prot_subsc_chg,hybr_3_gw_prot_subsc_chg,ph_cmd_ptr);

      #ifdef CM_GW_SUPPORTED
      /* Only notify MMOC of SIM removal if we are NOT in an emergency call */
      if ( !cmcall_emergency_call_active() )
      #endif /* FEATURE_WCDMA || FEATURE_GSM */
      {
        #ifdef CM_GW_SUPPORTED
        cmwcall_set_emergency_call_no_sim ( FALSE );
        #endif /* FEATURE_WCDMA || FEATURE_GSM */

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        /* Validate curr_nam */
        if(!INRANGE(ph_ptr->curr_nam, 0, CM_NAM_AUTO))
        {
          CM_ERR_0( "curr_nam is invalid!!!, no subsc cmd sent");
          break;
        }
        #ifdef FEATURE_MMODE_DUAL_SIM
        if(!ph_ptr->is_standby_pref_buffered && \
          (cmph_is_msim())
         )
        {
          ph_ptr->is_standby_pref_buffered = (cmcall_is_there_a_call_type(CM_SS_MAX,
            CM_CALL_TYPE_VOICE, CM_CALL_ID_INVALID)!= CM_CALL_ID_INVALID);
          CM_MSG_HIGH_1("Subs Nt Avail:ph_ptr->is_standby_pref_buffered=%d", ph_ptr->is_standby_pref_buffered);
        }

        /* Once the subscription change is sent, if the standby pref is AUTO
            ** Kick CM to re-evaluate the preferences.
            */
        if((ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO||
            ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY)
            && !ph_ptr->is_standby_pref_buffered
            && cmph_is_msim())
        {
          cm_ph_cmd_info_s_type       *cmd_info_ptr1 = (cm_ph_cmd_info_s_type*) cm_mem_malloc
                                      (sizeof (cm_ph_cmd_info_s_type));
          cmd_info_ptr1->standby_pref       = ph_ptr->user_standby_pref;
          cmd_info_ptr1->active_subs        = ph_ptr->active_subs;
                    cmd_info_ptr1->default_data_subs = ph_ptr->default_data_subs;
                    cmd_info_ptr1->default_voice_subs = ph_ptr->default_voice_subs;
                    cmd_info_ptr1->priority_subs = ph_ptr->priority_subs;
                    cmd_info_ptr1->oprt_mode = ph_ptr->oprt_mode;
          cmd_info_ptr1->dds_switch_type    = ph_ptr->dds_switch_type;

          #ifndef FEATURE_CM_DUAL_SIM_TUNEAWAY
          if(cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY)
          {
            cmd_info_ptr->standby_pref = SYS_MODEM_DS_PREF_AUTO;
          }
          #endif

          force_all = cmph_cmd_standby_pref_proc_int(cmd_info_ptr1,
                                         ph_cmd_ptr->cmd,
                                         ph_cmd_ptr->client_id,
                                         cdma_available,
                                         gwl_available,
                                         hybr_gw_available,
                                         hybr_3_gw_available
                                         );
          ph_ptr->standby_pref          = cmd_info_ptr1->standby_pref;
          ph_ptr->active_subs           = cmd_info_ptr1->active_subs;
          if(SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY == cmd_info_ptr1->standby_pref)
          {
            ph_ptr->internal_standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
          }
          else
          {
            ph_ptr->internal_standby_pref = cmd_info_ptr1->standby_pref;
          }

                    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
                    /* Send the PH Event that Standby Preferences have changed */
          cmph_event( ph_ptr, CM_PH_EVENT_DUAL_STANDBY_PREF );

          cm_mem_free(cmd_info_ptr1);
        }
        #endif /* FEATURE_MMODE_DUAL_SIM */

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
				
         if( !cm_is_valid_state_for_sub_proc(ph_ptr->oprt_mode) )
         {
           break;
         }

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        {
        cm_network_sel_mode_pref_e_type net_sel_mode_pref[MAX_AS_IDS] = {CM_NETWORK_SEL_MODE_PREF_NONE};
        sys_modem_as_id_e_type          as_id_i                       = SYS_MODEM_AS_ID_1;
        cm_orig_q_s_type *ph_orig_top_ptr = NULL;
        
		
      cm_pref_s_type  *hybr_2_pref_ptr = NULL;

        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        cm_pref_s_type  *hybr_3_pref_ptr = NULL;
        #endif

        #ifdef FEATURE_MMODE_DUAL_SIM
        for (; as_id_i < MAX_AS_IDS; as_id_i++)
        #endif
        {
          #ifdef FEATURE_MMODE_DUAL_SIM
          if (!cmph_is_msim() && as_id_i != SYS_MODEM_AS_ID_1)
          {
            continue;
          }
          #endif
          ph_orig_top_ptr = cmtask_orig_para_get_top( cmph_map_as_id_to_cm_ss(as_id_i) );
        if( ph_orig_top_ptr != NULL &&
            ph_orig_top_ptr->act_type == CM_ACT_TYPE_POLICYMAN_RESTRICT )
        {
          if( ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG )
          {
              net_sel_mode_pref[as_id_i] = CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV;
          }
          else
          {
              switch(CMPH_SS_NETWORK_SEL_MODE_PREF(as_id_i,ph_ptr))
            {
               case CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY:
               case CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV:
               case CM_NETWORK_SEL_MODE_PREF_MANUAL:
                   net_sel_mode_pref[as_id_i] = CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY;
                 break;

               default:
                   net_sel_mode_pref[as_id_i] = CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY;
                 break;
            }
          }
        }
        else
        {
            net_sel_mode_pref[as_id_i] = CMPH_SS_NETWORK_SEL_MODE_PREF(as_id_i,ph_ptr);
          }
        }
        /* Inform CM Pref & MMOC that subscription changed.
        */
        {
         if (cmph_is_msim())
        {
          if (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1))
          {
            #ifdef FEATURE_MMODE_DUAL_SIM
            hybr_2_pref_ptr = cm_pref_ptr();
            memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
            hybr_2_pref_ptr->network_sel_mode_pref = net_sel_mode_pref[SYS_MODEM_AS_ID_1];
            #endif
            #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
            hybr_3_pref_ptr = cm_pref_ptr();
            memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
            hybr_3_pref_ptr->network_sel_mode_pref = net_sel_mode_pref[SYS_MODEM_AS_ID_2];
            #endif
          }
          else
          {
            #ifdef FEATURE_MMODE_DUAL_SIM
            hybr_2_pref_ptr = cm_pref_ptr();
            memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
            hybr_2_pref_ptr->network_sel_mode_pref = net_sel_mode_pref[SYS_MODEM_AS_ID_2];
            #endif

            #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
            hybr_3_pref_ptr = cm_pref_ptr();
            memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
            #endif
          }

        }
        CM_MSG_HIGH_3("net_sel_mode %d %d %d",net_sel_mode_pref[CM_SS_MAIN],net_sel_mode_pref[CM_SS_HYBR_2],net_sel_mode_pref[CM_SS_HYBR_3]);

          if(force_all)
          {
            prot_subsc_chg |= PROT_SUBSC_CHG_GW;
            if(!cmph_is_sxlte())
            {
              hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
            }

            if(cmph_is_tsts() || cmph_is_sxlte())
            {
              hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
            }

          }

          cmmsimc_proc_cmd_subsc_chgd(  MMOC_SUBSC_CHG_SUBSC_AVAIL,
             (byte) ph_ptr->curr_nam,
              net_sel_mode_pref[SYS_MODEM_AS_ID_1],
              ph_ptr->main_stack_info.pref_info.mode_pref,
              ph_ptr->main_stack_info.pref_info.band_pref,
              ph_ptr->main_stack_info.pref_info.lte_band_pref,
              ph_ptr->main_stack_info.pref_info.tds_band_pref,
              CMPH_PRST_PRL_PREF( ph_ptr ),
              CMPH_PRST_ROAM_PREF( ph_ptr ),
              ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].hybr_pref,
              ph_ptr->main_stack_info.pref_info.plmn,
              ph_ptr->main_stack_info.pref_info.srv_domain_pref,
              ph_ptr->main_stack_info.pref_info.acq_order_pref,
              hybr_2_pref_ptr,
              #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
              hybr_3_pref_ptr,
              #endif
              gwl_available,
              hybr_gw_available,
              hybr_3_gw_available,
              cdma_available,
              prot_subsc_chg,
              hybr_gw_prot_subsc_chg,
              hybr_3_gw_prot_subsc_chg
           );

           /* Free allocated buffer */
           if (hybr_2_pref_ptr)
           {
             cm_mem_free (hybr_2_pref_ptr);
           }
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
           if (hybr_3_pref_ptr)
           {
             cm_mem_free (hybr_3_pref_ptr);
           }
           #endif
         }
      }

        /* If we are moving from triple standby to dual/single standby,
         ** add modes to multimode sub */
        if((prev_standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY && ph_ptr->internal_standby_pref != SYS_MODEM_DS_PREF_TRIPLE_STANDBY) &&
            ph_ptr->is_standby_pref_buffered == FALSE )
        {
          cmph_add_mode_in_DSDX();
        }

      }
      #ifdef CM_GW_SUPPORTED
      else
      {
        cmwcall_set_emergency_call_no_sim ( TRUE );
      }
      #endif /* FEATURE_WCDMA || FEATURE_GSM */

    }
    break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_SUBSCRIPTION_CHANGED:
      /* Send subscription changed command.
      */
      {
        boolean gwl_available     = ph_ptr->is_gwl_subscription_available;
        boolean hybr_gw_available = ph_ptr->is_hybr_gw_subscription_available;
  boolean hybr_3_gw_available = ph_ptr->is_hybr_gw3_subscription_available;
        boolean cdma_available    = ph_ptr->is_cdma_subscription_available;

        prot_subsc_chg_e_type prot_subsc_chg = PROT_SUBSC_CHG_NONE;
        prot_subsc_chg_e_type hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_NONE;
  prot_subsc_chg_e_type hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_NONE;

        sys_modem_as_id_e_type    sub_asub_id = SYS_MODEM_AS_ID_NONE;

        cm_mode_pref_e_type  fav_mode_pref;

        boolean               force_all = FALSE;        

        #ifdef CM_GW_SUPPORTED

        #ifdef FEATURE_GSTK
        mmgsdi_refresh_file_list_type file_info;

        /* File info */
        mmgsdi_file_enum_type         rat_file_name = MMGSDI_USIM_7F66_PROP1_RAT;

        file_info.file_list_ptr = &rat_file_name;
        file_info.num_files = 1;

        #endif /* FEATURE_GSTK */

        #endif /* FEATURE_WCDMA || FEATURE_GSM */

        

        if(cmph_is_subs_buffered(ph_cmd_ptr))
        {
          break;
        }

        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

        /* Abort indication will be sent to the sub:
             WHose subscription is getting changed */
        if(cmd_info_ptr->gw2_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          sub_asub_id = ph_ptr->hybr_2_stack_info.asubs_id;
        }
        #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
        else if(cmd_info_ptr->gw3_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          sub_asub_id = ph_ptr->hybr_3_stack_info.asubs_id;
        }
        #endif
        else if(cmd_info_ptr->gwl_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE ||
                cmd_info_ptr->cdma_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          sub_asub_id = ph_ptr->main_stack_info.asubs_id;
        }
        else
        {
          sub_asub_id = SYS_MODEM_AS_ID_1;
        }
        CM_MSG_LOW_1("CM_PH_CMD_SUBSCRIPTION_CHANGED:  calling cmph_is_abort_wait() with %d", sub_asub_id);

        if( cmph_is_abort_wait(ph_cmd_ptr,SYS_STOP_MODE_REASON_MODE_CHANGE, sub_asub_id))
        {
          return TRUE;
        }

        fav_mode_pref = CMPH_PRST_MODE_PREF(ph_ptr);

        if ( cmd_info_ptr->gwl_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          gwl_available = TRUE;

          prot_subsc_chg = ADD_PROTO (prot_subsc_chg, PROT_SUBSC_CHG_GW);

          if(ph_ptr->is_gwl_subscription_available)
          {
            cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->main_stack_info.asubs_id,
                                                                    CMPMPRX_SUBSC_NOT_AVAIL,
                                                                    CMPMPRX_SUBSC_NO_CHANGE);
          }
          else
          {
            cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->main_stack_info.asubs_id,
                                                                    CMPMPRX_SUBSC_AVAIL,
                                                                    CMPMPRX_SUBSC_NO_CHANGE);
          }

          #ifdef CM_GW_SUPPORTED

          cmwaoc_init_using_mmgsdi(CM_SS_MAIN);

          CM_MSG_HIGH_1 ("ENS enabled: %d", ph_ptr->main_stack_info.ens_value);

          #ifdef FEATURE_GSTK

          /* Read EF_RAT file */
          if (ph_ptr->main_stack_info.ens_value == TRUE)
          {
            cmmmgsdi_refresh_files_read_proc( CM_SS_MAIN, &file_info,
                                              CM_CLIENT_ID_ANONYMOUS
                                              );
          }

          if ( ph_ptr->is_rat_bal == TRUE && cmph_is_sub1_mm_in_single_standby())
          {
            fav_mode_pref =
                    cmph_read_efrat_mode_pref_subsc_chgd(gwl_available);
          }

          #endif /* FEATURE_GSTK */

          #endif /* FEATURE_WCDMA || FEATURE_GSM */
        }

        if ( cmd_info_ptr->gw2_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          hybr_gw_available = TRUE;

          hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;

          if(ph_ptr->is_hybr_gw_subscription_available)
          {
            cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->hybr_2_stack_info.asubs_id,
                                                                    CMPMPRX_SUBSC_NOT_AVAIL,
                                                                    CMPMPRX_SUBSC_NO_CHANGE);
          }
          else
          {
            cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->hybr_2_stack_info.asubs_id,
                                                                    CMPMPRX_SUBSC_AVAIL,
                                                                    CMPMPRX_SUBSC_NO_CHANGE);
          }

          #ifdef CM_GW_SUPPORTED
          cmwaoc_init_using_mmgsdi(CM_SS_HYBR_2);
          #endif /* WCDMA || GSM */
        }
        #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
        if ( cmd_info_ptr->gw3_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          hybr_3_gw_available = TRUE;

          hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;

          if(ph_ptr->is_hybr_gw3_subscription_available)
          {
            cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->hybr_3_stack_info.asubs_id,
                                                                    CMPMPRX_SUBSC_NOT_AVAIL,
                                                                    CMPMPRX_SUBSC_NO_CHANGE);
          }
          else
          {
            cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->hybr_3_stack_info.asubs_id,
                                                                    CMPMPRX_SUBSC_AVAIL,
                                                                    CMPMPRX_SUBSC_NO_CHANGE);
          }

          #ifdef CM_GW_SUPPORTED
          cmwaoc_init_using_mmgsdi(CM_SS_HYBR_3);
          #endif /* WCDMA || GSM */
        }
        #endif
        if ( cmd_info_ptr->cdma_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          cdma_available = TRUE;
          prot_subsc_chg = ADD_PROTO (prot_subsc_chg, PROT_SUBSC_CHG_CDMA);

          if(ph_ptr->is_cdma_subscription_available)
          {
            cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->main_stack_info.asubs_id,
                                                                    CMPMPRX_SUBSC_NO_CHANGE,
                                                                    CMPMPRX_SUBSC_NOT_AVAIL);
          }
          else
          {
            cmpmprx_update_cm_policy_consumption_eligibility_subsc(ph_ptr->main_stack_info.asubs_id,
                                                                    CMPMPRX_SUBSC_NO_CHANGE,
                                                                    CMPMPRX_SUBSC_AVAIL);
          }

        #if defined(FEATURE_DDTM_CNTL) && defined(FEATURE_MMGSDI_SESSION_LIB)

        if(cm_is_jcdma_enable() && cmmmgsdi_is_jcdma_card_white_equiv())
        {
          sys_ddtm_act_mask_e_type ddtm_mask;
          mc_msg_type                    *mc_ptr;
              /* MC command pointer */
          sys_srv_opt_type so_list[] = {CAI_SO_NULL};

          ddtm_mask = SYS_DDTM_ACT_MASK_SUPPRESS_REG;

          mc_ptr                                = cm_mc_get_buf_else_err_fatal();
          mc_ptr->hdr.cmd                       = MC_DDTM_CNTL_F;
          mc_ptr->ddtm_cntl.status              = TRUE;
          mc_ptr->ddtm_cntl.ddtm_act_mask       = ddtm_mask;
          mc_ptr->ddtm_cntl.num_srv_opt         = ARR_SIZE(so_list);
          mc_ptr->ddtm_cntl.srv_opt_list[0]     = so_list[0];

          ph_ptr->cur_ddtm_act_mask = ddtm_mask;
          ph_ptr->cur_ddtm_status = TRUE;
          ph_ptr->cur_ddtm_num_srv_opt = ARR_SIZE(so_list);
          ph_ptr->cur_ddtm_srv_opt_list[0] = so_list[0];

          CM_MSG_HIGH_3( "Send DDTM status=%d mask 0x%x num_srv_opt %d",
                       mc_ptr->ddtm_cntl.status,
                       mc_ptr->ddtm_cntl.ddtm_act_mask,
                       mc_ptr->ddtm_cntl.num_srv_opt);
          cm_mc_send_cmd( mc_ptr );

        }
        #endif


        }

        cmph_reset(ph_ptr,prot_subsc_chg,hybr_gw_prot_subsc_chg ,hybr_3_gw_prot_subsc_chg,ph_cmd_ptr);

        /* Reset the origination throttle table
        */
        cmss_orig_thr_table_reset( cmss_ptr()->cmss_orig_thr_tbl_ptr );

        /* Clear the is hybr kicked flag
        */
        if (prot_subsc_chg != PROT_SUBSC_CHG_NONE)
        {
        *cmph_get_is_kicked_hybr_ptr() = FALSE;
        *cmph_get_is_kicked_hybr_2_ptr() = FALSE;
        }

        #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
        #if (defined(FEATURE_OTASP) || defined(FEATURE_UIM_RUIM))
        diag_otasp_update();              /* Tell Diag to update its cache */
        #endif /* FEATURE_OTASP || FEATURE_UIM_RUIM */
        #endif /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */


        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        /* Validate curr_nam */
        if(!INRANGE(ph_ptr->curr_nam, 0, CM_NAM_AUTO))
        {
          CM_ERR_0( "curr_nam is invalid!!!, no subsc cmd sent");
          break;
        }

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

        #ifdef FEATURE_MMODE_DUAL_SIM
        /* Once the subscription change is sent, if the standby pref is AUTO
            ** Kick CM to re-evaluate the preferences.
            */
        if((ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO||
            ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY)
            && cmph_is_msim())
        {
          cm_ph_cmd_info_s_type       *cmd_info_ptr1 = (cm_ph_cmd_info_s_type*) cm_mem_malloc
                                      (sizeof (cm_ph_cmd_info_s_type));
          cmd_info_ptr1->standby_pref       = ph_ptr->user_standby_pref;
          cmd_info_ptr1->active_subs        = ph_ptr->active_subs;
                    cmd_info_ptr1->default_data_subs = ph_ptr->default_data_subs;
                    cmd_info_ptr1->default_voice_subs = ph_ptr->default_voice_subs;
                    cmd_info_ptr1->priority_subs = ph_ptr->priority_subs;
          cmd_info_ptr1->dds_switch_type      = ph_ptr->dds_switch_type;

          #ifndef FEATURE_CM_DUAL_SIM_TUNEAWAY
          if(cmd_info_ptr->standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY)
          {
            cmd_info_ptr->standby_pref = SYS_MODEM_DS_PREF_AUTO;
          }
          #endif

          force_all = cmph_cmd_standby_pref_proc_int(cmd_info_ptr1,
                                         ph_cmd_ptr->cmd,
                                         ph_cmd_ptr->client_id,
                                         cdma_available,
                                         gwl_available,
                                         hybr_gw_available,
                                         hybr_3_gw_available
                                         );

          ph_ptr->standby_pref          = cmd_info_ptr1->standby_pref;
          ph_ptr->active_subs           = cmd_info_ptr1->active_subs;

          if(SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY == cmd_info_ptr1->standby_pref)
          {
            ph_ptr->internal_standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
          }
          else
          {
            ph_ptr->internal_standby_pref = cmd_info_ptr1->standby_pref;
          }

                    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
                    /* Send the PH Event that Standby Preferences have changed */
          cmph_event( ph_ptr, CM_PH_EVENT_DUAL_STANDBY_PREF );

         /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
          cm_mem_free(cmd_info_ptr1);
        }
        #endif /* FEATURE_MMODE_DUAL_SIM */

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

       /* Only notify MMOC if phone is currently online or powerup
       */
        if( !cm_is_valid_state_for_sub_proc(ph_ptr->oprt_mode))
        {
          break;
        }

        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        {
        cm_network_sel_mode_pref_e_type net_sel_mode_pref[MAX_AS_IDS] = {CM_NETWORK_SEL_MODE_PREF_NONE};
        sys_modem_as_id_e_type          as_id_i                       = SYS_MODEM_AS_ID_1;
        cm_orig_q_s_type *ph_orig_top_ptr = NULL;
        
		
      cm_pref_s_type  *hybr_2_pref_ptr = NULL;

        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        cm_pref_s_type  *hybr_3_pref_ptr = NULL;
        #endif

        #ifdef FEATURE_MMODE_DUAL_SIM
        for (; as_id_i < MAX_AS_IDS; as_id_i++)
        #endif
        {
          #ifdef FEATURE_MMODE_DUAL_SIM
          if (!cmph_is_msim() && as_id_i != SYS_MODEM_AS_ID_1)
          {
            continue;
          }
          #endif
          ph_orig_top_ptr = cmtask_orig_para_get_top( cmph_map_as_id_to_cm_ss(as_id_i) );
        if( ph_orig_top_ptr != NULL &&
            ph_orig_top_ptr->act_type == CM_ACT_TYPE_POLICYMAN_RESTRICT )
        {
          if( ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG )
          {
              net_sel_mode_pref[as_id_i] = CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV;
          }
          else
          {
              switch(CMPH_SS_NETWORK_SEL_MODE_PREF(as_id_i,ph_ptr))
            {
               case CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY:
               case CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV:
               case CM_NETWORK_SEL_MODE_PREF_MANUAL:
                   net_sel_mode_pref[as_id_i] = CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY;
                 break;

               default:
                   net_sel_mode_pref[as_id_i] = CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY;
                 break;
            }
          }
        }
        else
        {
            net_sel_mode_pref[as_id_i] = CMPH_SS_NETWORK_SEL_MODE_PREF(as_id_i,ph_ptr);
          }
        }
        /* Inform CM Pref & MMOC that subscription changed.
        */
        {
         if (cmph_is_msim())
        {
          if (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1))
          {
            #ifdef FEATURE_MMODE_DUAL_SIM
            hybr_2_pref_ptr = cm_pref_ptr();
            memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
            hybr_2_pref_ptr->network_sel_mode_pref = net_sel_mode_pref[SYS_MODEM_AS_ID_1];
            #endif
            #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
            hybr_3_pref_ptr = cm_pref_ptr();
            memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
            hybr_3_pref_ptr->network_sel_mode_pref = net_sel_mode_pref[SYS_MODEM_AS_ID_2];
            #endif
          }
          else
          {
            #ifdef FEATURE_MMODE_DUAL_SIM
            hybr_2_pref_ptr = cm_pref_ptr();
            memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
            hybr_2_pref_ptr->network_sel_mode_pref = net_sel_mode_pref[SYS_MODEM_AS_ID_2];
            #endif

            #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
            hybr_3_pref_ptr = cm_pref_ptr();
            memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
            #endif
          }

        }
        CM_MSG_HIGH_3("net_sel_mode %d %d %d",net_sel_mode_pref[CM_SS_MAIN],net_sel_mode_pref[CM_SS_HYBR_2],net_sel_mode_pref[CM_SS_HYBR_3]);

          if(force_all)
          {
            prot_subsc_chg |= PROT_SUBSC_CHG_GW;
            if(!cmph_is_sxlte())
            {
              hybr_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
            }

            if(cmph_is_tsts() || cmph_is_sxlte())
            {
              hybr_3_gw_prot_subsc_chg = PROT_SUBSC_CHG_GW;
            }

          }

          cmmsimc_proc_cmd_subsc_chgd(  MMOC_SUBSC_CHG_SUBSC_AVAIL,
             (byte) ph_ptr->curr_nam,
              net_sel_mode_pref[SYS_MODEM_AS_ID_1],
              fav_mode_pref,
              ph_ptr->main_stack_info.pref_info.band_pref,
              ph_ptr->main_stack_info.pref_info.lte_band_pref,
              ph_ptr->main_stack_info.pref_info.tds_band_pref,
              CMPH_PRST_PRL_PREF( ph_ptr ),
              CMPH_PRST_ROAM_PREF( ph_ptr ),
              ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].hybr_pref,
              ph_ptr->main_stack_info.pref_info.plmn,
              ph_ptr->main_stack_info.pref_info.srv_domain_pref,
              ph_ptr->main_stack_info.pref_info.acq_order_pref,
              hybr_2_pref_ptr,
              #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
              hybr_3_pref_ptr,
              #endif
              gwl_available,
              hybr_gw_available,
              hybr_3_gw_available,
              cdma_available,
              prot_subsc_chg,
              hybr_gw_prot_subsc_chg,
              hybr_3_gw_prot_subsc_chg
           );

           /* Free allocated buffer */
           if (hybr_2_pref_ptr)
           {
             cm_mem_free (hybr_2_pref_ptr);
           }
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
           if (hybr_3_pref_ptr)
           {
             cm_mem_free (hybr_3_pref_ptr);
           }
           #endif
         }
      }
      }
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


                      /*-----------------------------------------*/
                      /* Client has requested a list of networks */
                      /*-----------------------------------------*/

    #if defined CM_GW_SUPPORTED ||  defined(FEATURE_CM_LTE)
    case CM_PH_CMD_GET_NETWORKS:

      cmph_cmd_get_networks_proc(ph_cmd_ptr);
      break;

    case CM_PH_CMD_TERMINATE_GET_NETWORKS:
      {
        mmoc_cmd_term_get_networks_gw(cmph_map_cm_ss_type_to_sd_ss_type(ph_ptr->ss_for_get_networks));
      }
      break;
    #endif /* FEATURE_GSM || FEATURE_WCDMA ||  FEATURE_CM_LTE */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                /*-----------------------------------------------------*/
                /* Client has requested to save the preferred networks */
                /*-----------------------------------------------------*/

    case CM_PH_CMD_SET_PREFERRED_NETWORKS:

      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_RESET_ACM:
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_SET_ACMMAX:
      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #if (defined FEATURE_ALS) && (defined FEATURE_GSM)
    case CM_PH_CMD_LINE_SWITCHING:

      /* Write to the SIM new setting for line switching
      */

      cmals_ptr_mmgsdi()->mmgsdi_write_line_switching_func(
                                        ph_cmd_ptr->info.line_switching,
                                        ph_cmd_ptr);


      break;

    case CM_PH_CMD_SELECTED_LINE:
      /* Write to the SIM new setting for selected line
      */

      cmals_ptr_mmgsdi()->mmgsdi_write_selected_line_func(
                                            ph_cmd_ptr->info.line,
                                            ph_cmd_ptr);


      break;

    case CM_PH_CMD_LINE_SWITCHING_SAVED:
    case CM_PH_CMD_SELECTED_LINE_SAVED:
    case CM_PH_CMD_ALS_SIM_INFO_AVAIL:

      /* Nothing to do here for these commands.
      */
      break;

    #endif /* #if (defined FEATURE_ALS) && (defined FEATURE_GSM) */


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
    #error code not present
#endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_CLIENT_RELEASE:
      /* No need to notify MC of this one.
      */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_DUAL_STANDBY_PREF:
    {
      uint8 new_sub_mask =0;
      boolean is_sub_avail;
      uint8 sub_deactivated_mask;

      /* find new standby pref/subs mask based subcription made active from AP*/
      sys_modem_dual_standby_pref_e_type new_standby_pref 
              = cmph_find_standby_pref(ph_cmd_ptr->info, &new_sub_mask);

      /* find deactivated sub from AP*/
      sub_deactivated_mask =  ph_ptr->active_subs ^ new_sub_mask;

      is_sub_avail = (sub_deactivated_mask!=SYS_MODEM_AS_ID_NO_ACTIVE_MASK? cmph_is_subscription_available(sub_deactivated_mask):0);

      /* Does standby pref cleanup if
         1)Dual->Single, Single->No Standby mode.
         2)subscription is available on the deactivated sub. 
      */
      if( ((new_standby_pref == SYS_MODEM_DS_PREF_NO_STANDBY_PREF &&
           ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY) ||
           (new_standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY &&
           ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY)) &&
           is_sub_avail 
          )
      {
             
        CM_MSG_HIGH_2("standby pref changed, clnup needed on sub: %d, new_standby_pref:%d",
           sub_deactivated_mask,new_standby_pref);
    
        if( cmclnup_is_clnup_needed(CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_NONE, SYS_OPRT_MODE_NONE))
        {
          cmclnup_initiate_cleanup(ph_cmd_ptr);

          /* If this new cleanup activity requires CM to wait for response,
           ** the command is already on the buffer queue. So end the processing.
           */
          if(cmclnup_is_ongoing_subsc(sub_deactivated_mask))
          {
            return TRUE;
          }

        }
      }
      if(ph_cmd_ptr->info.default_data_subs != ph_ptr->default_data_subs)
      {
        ph_ptr->dds_change_in_progress = TRUE;
      }     
      cmph_cmd_standby_pref_proc(ph_cmd_ptr);
      ph_ptr->dds_change_in_progress = FALSE;
     }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_CM_LTE
    case CM_PH_CMD_PLMN_BLOCKING:
      cmph_cmd_plmn_blocking_proc(ph_cmd_ptr);
      break;
    #endif /* FEATURE_CM_LTE */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_GET_DRX_REQ:
      #if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)
      cmph_cmd_get_drx_req_proc(ph_cmd_ptr);
      break;
      #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_SET_DRX_REQ:
      #if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)
      cmph_cmd_set_drx_req_proc(ph_cmd_ptr);
      break;
      #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_SET_TL_IRAT_SEARCH_TIMER_REQ:
      #if defined(FEATURE_TDSCDMA)
      cmph_cmd_set_tl_irat_search_timer_req_proc(ph_cmd_ptr);
      break;
      #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


    #ifdef FEATURE_MRU_UPDATE
    case CM_PH_CMD_MRU_UPDATE:
    case CM_PH_CMD_READ_MRU:
     /* Nothing to do here for these commands.
     */
    break;
    #endif /* FEATURE_MRU_UPDATE */

    #if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)
    case CM_PH_CMD_GET_HPLMN_TIMER:
      /* Get reg cmd. buffer and populate params.*/
      reg_ptr =  cm_reg_get_buf_else_err_fatal( CM_GET_HPLMN_SEARCH_TIMER_REQ );

    /* Fill in parameters. */
      reg_ptr->cmd.cm_get_hplmn_search_timer_req.as_id = cmd_info_ptr->cmd_subs;

      /* print the cmd details
      */
      CM_MSG_HIGH_1( "Sending GET_HPLMN_SEARCH_TIMER_REQ as_id=%d",
                  reg_ptr->cmd.cm_get_hplmn_search_timer_req.as_id);

      /* Send the request to NAS */
      cm_reg_send_cmd( reg_ptr );
      break;

    case CM_PH_CMD_SET_HPLMN_TIMER:
       /* Get reg cmd. buffer and populate params.*/
      reg_ptr =  cm_reg_get_buf_else_err_fatal( CM_SET_HPLMN_SEARCH_TIMER_REQ );

      /* Fill in parameters. */
      reg_ptr->cmd.cm_set_hplmn_search_timer_req.timer_value = cmd_info_ptr->hplmn_timer;
    reg_ptr->cmd.cm_set_hplmn_search_timer_req.as_id = cmd_info_ptr->cmd_subs;

      /* print the cmd details
      */
      CM_MSG_HIGH_2("Sending SET_HPLMN_SEARCH_TIMER_REQ timer=%d, as_id=%d",
                  reg_ptr->cmd.cm_set_hplmn_search_timer_req.timer_value,
                  reg_ptr->cmd.cm_set_hplmn_search_timer_req.as_id);

      /* Send the request to NAS */
      cm_reg_send_cmd( reg_ptr );

      break;
    #endif

    case CM_PH_CMD_RPM_APP_RESET_REJECTED:
      /* If rpm is enabled handled ph cmd rpm app reset rejected to update counters */
      cmph_rpm_app_reset_reject_proc();      
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case CM_PH_CMD_SET_WD_SWITCH:
      ph_ptr->wd_switch_on = ph_cmd_ptr->info.wd_switch_on;
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

     case CM_PH_CMD_RESET_CLNUP_ST_MC:
       cmclnup_st_mc_init();
       cmac_enable_emergency_if_pending();
       cmpmprx_clnup_complete_ind();
       break;
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case CM_PH_CMD_DATA_PRIORITY:

    /* Nothing to do here for this command, PRIORITY_DATA_IND will be forwarded in different priority DS-CM API */

    break; 

    
	case CM_PH_CMD_SET_SRVCC_CAPABILITY:
		cmph_send_srvcc_capability_to_reg(&ph_cmd_ptr->info);
	break;
	
     case CM_PH_CMD_SET_TRM_PRIORITY:

      #ifdef FEATURE_HDR
      cmph_send_trm_priority_req_non_lte(ph_cmd_ptr->info.tune_away_req);
      #endif

      #ifdef FEATURE_LTE
      {
        lte_trm_priority_e trm_priority;

        trm_priority = (ph_cmd_ptr->info.tune_away_req == TRUE)?LTE_TRM_PRIORITY_HIGH:\
                                  LTE_TRM_PRIORITY_LOW;
        
        cmph_send_trm_priority_req(trm_priority,  cmd_info_ptr->cmd_subs);
      }
      #endif

  #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  
  case CM_PH_CMD_DATA_ROAMING:
    
    cmregprx_send_data_roaming_ind(cmd_info_ptr->roam_type,
                                   cmd_info_ptr->cmd_subs);
    
    break;

  case CM_PH_CMD_SET_ROAMING_PREF:
    cmregprx_send_roaming_req(&(cmd_info_ptr->roaming_pref),
                                   cmd_info_ptr->cmd_subs);
    break;

  #endif

  case CM_PH_CMD_INFORM_SECURE_CALL_CAPABILITY:
    #if defined(FEATURE_IP_CALL)
    cmph_inform_secure_call_capability_proc(&ph_cmd_ptr->info);
    #endif
    break;
	
    default:

      CM_ERR_1( "Bad phone command %d", (uint8) ph_cmd_ptr->cmd);


  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Inform the caller of this function to whether
  ** the phone object is now waiting for reply from MC.
  */
  return cm_reply_is_waiting( &ph_ptr->reply );
} /* cmph_client_cmd_forward_mmll() */

/*===========================================================================

FUNCTION cmph_get_srv_type_ext

DESCRIPTION
  Returns srv_type for the particular call_type that
  has been given as input.
  If such an object does not exist returns NONE.

DEPENDENCIES
  CM must be initialized

RETURN VALUE
  srv_type of teh call, else NONE
  from_call will set to TRUE if call of call_type is found otherwise FALSE.

SIDE EFFECTS
  None

===========================================================================*/
cm_srv_type_e_type cmph_get_srv_type_ext(
  cm_call_type_e_type call_type,
  boolean *is_srv_type_from_call
)
{
  cmcall_s_type   *call_ptr = NULL;
  cm_iterator_type call_itr;


  cmcall_obj_iterator_init(&call_itr);

  call_ptr = cmcall_obj_get_next(&call_itr);

  while(call_ptr != NULL)
  {
    if(call_ptr->call_type == call_type && call_ptr->srv_type != CM_SRV_TYPE_NONE)
    {
      if(is_srv_type_from_call != NULL)
      {
        *is_srv_type_from_call = TRUE;
      }
      return (call_ptr->srv_type);
    }
    call_ptr = cmcall_obj_get_next(&call_itr);
  }

  return CM_SRV_TYPE_NONE;
}

/*===========================================================================

FUNCTION cmph_get_srv_type

DESCRIPTION
  Returns srv_type for the particular call_type that
  has been given as input.
  If such an object does not exist returns NONE.

DEPENDENCIES
  CM must be initialized

RETURN VALUE
  srv_type of teh call, else NONE

SIDE EFFECTS
  None

===========================================================================*/

cm_srv_type_e_type cmph_get_srv_type(

    cm_call_type_e_type  call_type
)
{
  return cmph_get_srv_type_ext(call_type, NULL);
}


/*===========================================================================

FUNCTION cmph_remove_all_orig_mode

DESCRIPTION
  Remove all entries of orig queue except for ph obj

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/


static void cmph_remove_all_orig_mode(void)
{
  cm_orig_q_s_type      *q_ptr;

  cm_orig_q_s_type      *q_next_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  q_ptr = cmtask_orig_para_get_first(CM_SS_MAIN);

  while(q_ptr != NULL)
  {
    q_next_ptr = cmtask_orig_para_get_next(q_ptr, CM_SS_MAIN);

    if(q_ptr->act_type != CM_ACT_TYPE_PH_OBJ)
    {
      CM_MSG_HIGH_1( "Deleting act type %d", q_ptr->act_type);

      if (q_ptr->act_type == CM_ACT_TYPE_EMERG_CALL)
      {
        cmpmprx_notify_call_end(cmph_map_cm_ss_to_as_id(CM_SS_MAIN), TRUE);
      }
      /* This is because previous function call could
      ** change q_next_ptr */
      q_next_ptr = cmtask_orig_para_get_next(q_ptr, CM_SS_MAIN);

      /* Remove this q_ptr from the queue
      */
      (void)cmtask_orig_para_delete( CM_SS_MAIN, q_ptr, TRUE);

    }/* if q_ptr ... */

    q_ptr = q_next_ptr;

  }/* while q_ptr ... */

  q_ptr = cmtask_orig_para_get_first(CM_SS_HDR);

  while(q_ptr != NULL)
  {
    q_next_ptr = cmtask_orig_para_get_next(q_ptr, CM_SS_HDR);

    if(q_ptr->act_type != CM_ACT_TYPE_PH_OBJ)
    {
      CM_MSG_HIGH_1( "Deleting act type %d", q_ptr->act_type);

      /* Remove this q_ptr from the queue
      */
        
      if (q_ptr->act_type == CM_ACT_TYPE_EMERG_CALL)
      {
        cmpmprx_notify_call_end(cmph_map_cm_ss_to_as_id(CM_SS_HDR), TRUE);
      }

      (void)cmtask_orig_para_delete( CM_SS_HDR, q_ptr, TRUE);

    }/* if q_ptr ... */

    q_ptr = q_next_ptr;

  }/* while q_ptr ... */

  q_ptr = cmtask_orig_para_get_first(CM_SS_HYBR_2);

  while(q_ptr != NULL)
  {
    q_next_ptr = cmtask_orig_para_get_next(q_ptr, CM_SS_HYBR_2);

    if(q_ptr->act_type != CM_ACT_TYPE_PH_OBJ)
    {
      CM_MSG_HIGH_1( "Deleting act type %d", q_ptr->act_type);

      if (q_ptr->act_type == CM_ACT_TYPE_EMERG_CALL)
      {
        cmpmprx_notify_call_end(cmph_map_cm_ss_to_as_id(CM_SS_HYBR_2), TRUE);
      }

      /* Remove this q_ptr from the queue
      */
      (void)cmtask_orig_para_delete( CM_SS_HYBR_2, q_ptr, TRUE);

    }/* if q_ptr ... */

    q_ptr = q_next_ptr;

  }/* while q_ptr ... */

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  q_ptr = cmtask_orig_para_get_first(CM_SS_HYBR_3);

  while(q_ptr != NULL)
  {
    q_next_ptr = cmtask_orig_para_get_next(q_ptr, CM_SS_HYBR_3);

    if(q_ptr->act_type != CM_ACT_TYPE_PH_OBJ)
    {
      CM_MSG_HIGH_1( "Deleting act type %d", q_ptr->act_type);
      if (q_ptr->act_type == CM_ACT_TYPE_EMERG_CALL)
      {
        cmpmprx_notify_call_end(cmph_map_cm_ss_to_as_id(CM_SS_HYBR_3), TRUE);
      }

      /* Remove this q_ptr from the queue
      */
      (void)cmtask_orig_para_delete( CM_SS_HYBR_3, q_ptr, TRUE);

    }/* if q_ptr ... */

    q_ptr = q_next_ptr;

  }/* while q_ptr ... */
  #endif

  return;
} /* cmph_remove_all_orig_mode() */

/*===========================================================================

FUNCTION cmnv_ftm_write

DESCRIPTION
  Write an item to NV_FTM_MODE_I.


DEPENDENCIES
  CM NV queue must have already been initialized with
  cmnv_q_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmnv_ftm_write(

boolean ftm_mode

)
{
  cmnv_item_ptr->ftm_mode = ftm_mode;
  cmnv_write( NV_FTM_MODE_I, cmnv_item_ptr );
}
/*===========================================================================

FUNCTION cmph_err_fatal_if_ps_srv_domain_on_multiple_subs

DESCRIPTION
  ERROR FATAL if PS is part of service domain preference of multiple subs.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_err_fatal_if_ps_srv_domain_on_multiple_subs()
{
  #ifdef FEATURE_MMODE_SXLTE_G
  cmph_s_type             *ph_ptr       = cmph_ptr();
  /* Point at phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT( ph_ptr != NULL );

  if( ph_ptr->internal_standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY &&
    !cmph_is_dsda() && cmph_is_sxlte() && 
    (cmpmprx_get_num_of_active_data() != 2))
  {
    cm_orig_q_s_type      *q_ptr;
    if(ph_ptr->default_data_subs == SYS_MODEM_AS_ID_2)
    {
      q_ptr = cmtask_orig_para_get_top(cmph_map_subs_to_ss(SYS_MODEM_AS_ID_1));
      if(q_ptr != NULL && q_ptr->act_type == CM_ACT_TYPE_PH_OBJ &&
        (ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS ||
         ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY))
      {
        CM_ERR_FATAL_1("dds on sub 2, but srv domain on the other sub is %d, has PS",
          ph_ptr->main_stack_info.pref_info.srv_domain_pref);
      }
    }
    if(ph_ptr->default_data_subs == SYS_MODEM_AS_ID_1)
    {
      q_ptr = cmtask_orig_para_get_top(cmph_map_subs_to_ss(SYS_MODEM_AS_ID_2));
      if(q_ptr != NULL && q_ptr->act_type == CM_ACT_TYPE_PH_OBJ &&
        (ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS ||
         ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY))
      {
        CM_ERR_FATAL_1("dds on sub 1, but srv domain on the other sub is %d, has PS",
          ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref);
      }
    }

  }
  #endif
}
/*===========================================================================

FUNCTION cmph_client_cmd_mmll_reply

DESCRIPTION
  Process MC replies to clients phone commands.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
 void cmph_client_cmd_mmll_reply(

    cmph_s_type             *ph_ptr,
        /* Pointer to a phone object */

    const cm_ph_cmd_s_type     *ph_cmd_ptr,
        /* Pointer to a CM command */

    cm_ph_cmd_err_e_type    cmd_err
        /* Indicate phone command error */
)
/*lint -esym(715, cmd_err) */
{
  const cm_ph_cmd_info_s_type  *cmd_info_ptr = NULL;
      /* Point at command information component */

  cm_ph_info_s_type    *ph_info_ptr;
      /* pointer for phone info */

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  db_items_value_type  db_item;
      /* Item to do db_get() and db_put() */
  #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

  sys_oprt_mode_e_type prev_oprt_mode;
    /* Previous operating mode */

  cm_ss_e_type                 ss = CM_SS_MAIN;
  sys_modem_as_id_e_type  asubs_id = SYS_MODEM_AS_ID_1;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( ph_cmd_ptr != NULL );
  CM_ASSERT( BETWEEN( cmd_err, CM_PH_CMD_ERR_NONE, CM_PH_CMD_ERR_MAX));
  CM_ASSERT( ph_cmd_ptr->cmd_type == CM_CMD_TYPE_PH );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  if (cmph_is_msim())
  {
    ss      =  cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);
    asubs_id = cmd_info_ptr->cmd_subs;
  }

  /* If the command is on Hold, return
  */
  if( ph_cmd_ptr->info.is_command_on_hold )
  {
    return;
  }

  /*
  ** 1. Update phone fields.
  ** 2. If necessary write to NV or DB the new setting.
  ** 3. Notify clients of phone event.
  */

  /* Update phone fields by copying relevant
  ** command fields into phone struct.
  */
  prev_oprt_mode = ph_ptr->oprt_mode;         /* copy previous oprt mode.*/

  cmph_cmd_copy_fields( ph_ptr, ph_cmd_ptr );

  cmph_err_fatal_if_ps_srv_domain_on_multiple_subs();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If necessary, copy specific command fields into phone struct,
  ** and notify clients of event.
  */

  switch( ph_cmd_ptr->cmd )
  {
                     /*---------------------------*/
                     /* Change the operating mode */
                     /*---------------------------*/

    case CM_PH_CMD_OPRT_MODE:

      switch(cmd_info_ptr->oprt_mode)
      {
       case SYS_OPRT_MODE_LPM:
       
	   cmss_reset_sys_id_info(); 
	   /*Intentional fall through - as we need additional resetting of plmn in LPM mode*/

       case SYS_OPRT_MODE_PWROFF:
       case SYS_OPRT_MODE_RESET:
       case SYS_OPRT_MODE_OFFLINE:
       case SYS_OPRT_MODE_OFFLINE_CDMA:
       {
         /* Clearing all call objs from queue*/
         cmph_remove_all_orig_mode();

          /* 1. We don't want to call efs_prepare_shutdown() only from PWROFF state which is bootup stage
          ** 2. We don't want to call efs_prepare_shutdown() for back-2-back LPM commands
          */
          if ( prev_oprt_mode == SYS_OPRT_MODE_PWROFF ||
               prev_oprt_mode == SYS_OPRT_MODE_LPM )
         {
           CM_MSG_HIGH_2( "From mode %d to mode %d, skip efs_prepare_shutdown()",
                          prev_oprt_mode,cmd_info_ptr->oprt_mode );
         }
         else
         {
           CM_MSG_HIGH_1( "Calling efs_prepare_shutdown in mode %d",
                          cmd_info_ptr->oprt_mode );

           if(efs_prepare_shutdown() != 0)
           {
             CM_MSG_HIGH_1("efs_prepare_shutdown return error=%d", mcfg_fs_errno(MCFG_FS_TYPE_EFS));
           }
         }

         #ifdef CM_GW_SUPPORTED
         cmss_reset_gwl_signal_status();
         #endif

#if (defined(FEATURE_LTE_TO_1X) && defined(FEATURE_MMODE_SC_SVLTE)) || defined(FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH)
         cmsoa_arm_timer(CMSOA_SV_OPRT_MODE_NONE,
                         CMSOA_SV_SWITCH_DELAY_REAS_NONE);
#endif
       }
         break;

       default:
         break;
      }

      cmph_event( ph_ptr, CM_PH_EVENT_OPRT_MODE );

      /* IMS relies on this callback to know the current oprt_mode instead of
      ** the phone event.
      ** So call it unconditionally.
      */
      #ifdef FEATURE_IP_CALL
      cmipapp_send_oprt_mode (cmd_info_ptr->oprt_mode, FALSE);
      #endif

      if( ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM )
      {
        cmpsm_process_lpm();
      }
      if(ph_ptr->is_ds_cmd_ntfy_sent)
      {
        ph_ptr->is_ds_cmd_ntfy_sent = FALSE;
      }
      if(ph_ptr->is_wait_on_data_end)
      {
        ph_ptr->is_wait_on_data_end = FALSE;
      }

      if(ph_ptr->is_ims_cmd_ntfy_sent)
      {
         ph_ptr->is_ims_cmd_ntfy_sent = FALSE;
      }


      if(ph_ptr->abort_ss_bitmask)
      {
        ph_ptr->abort_ss_bitmask = 0;
      }

      if( cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_ONLINE)
      {
        /* Send the subscription event on all stacks
        */
        cmph_send_subs_info(CM_SS_MAIN, NULL);
        if(cmph_is_msim())
        {
          if (!cmph_is_sxlte())
          {
            cmph_send_subs_info(CM_SS_HYBR_2, NULL);
          }
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
          if(cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY ||
            cmph_is_sxlte())
          {
             cmph_send_subs_info(CM_SS_HYBR_3, NULL);
          }
          #endif
          cmph_sp_subs_info_update();
          cmph_send_vsid_info();
        }
      }

      /* Update nv ftm flag whenever there is a operation mode change.*/
         /*
         1. Upon receiving power down request/TASK_STOP_SIGNAL from RCINT and operation mode is in FTM mode,
                MMODE will performs the reset as if it is in the other operation mode and keep NV_FTM_MODE_I intact.
         2. NV_FTM_MODE_I is expected to be reset to 0 (DMSS_MODE) when operation mode is transition to online mode
         3. NV_FTM_MODE_I is expected to be set to 1 (FTM_MODE) when operation mode is transition to FTM mode.
         4. The NV_FTM_MODE value should remain intact for the other operation mode (LPM/offline/Power off ect) */

      if ( prev_oprt_mode == SYS_OPRT_MODE_FTM
           && ph_ptr->oprt_mode != SYS_OPRT_MODE_FTM)
      {
        if (  ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE)
        {
          ph_ptr->moved_from_ftm = TRUE;
        }
        else if(ph_ptr->oprt_mode == SYS_OPRT_MODE_ONLINE)
        {
          cmnv_ftm_write(DMSS_MODE);
        }
      }
      if (  ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM)
      {
        cmnv_ftm_write(FTM_MODE);
      }
      if (ph_ptr->oprt_mode == SYS_OPRT_MODE_ONLINE &&
          ph_ptr->moved_from_ftm == TRUE)
      {
        cmnv_ftm_write(DMSS_MODE);
        ph_ptr->moved_from_ftm = FALSE;
      }

      #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
      /* activate arbitration if all conditions met */
      cmsoa_activate_arbitration();
      #endif /* FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH */

      /* Clear if rf status is set to ONLINE pending */
      cmph_rf_status_oprt_mode_proc(cmd_info_ptr->oprt_mode);

      cmph_sys_m_oprt_mode_proc(cmd_info_ptr->oprt_mode);

      /* Read default system time from EFS for CMRPM in case we are moving to
      ** ONLINE and subscription for MAIN is already available
      */
      if(cmd_info_ptr->oprt_mode == SYS_OPRT_MODE_ONLINE &&
         ph_ptr->is_gwl_subscription_available)
      {
        cmph_rpm_read_efs_sys_time();
      }

      /* Call Cmrpm API to write system time during power-down in EFS */
      cmph_rpm_write_efs_sys_time(prev_oprt_mode, cmd_info_ptr->oprt_mode);
		
      cmph_updt_is_oprt_mode_change_ongoing(FALSE, cmd_info_ptr->oprt_mode);

      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
                     /*---------------------------- */
                     /* Change the measurement mode */
                     /*---------------------------- */

    case CM_PH_CMD_MEAS_MODE:
      #ifdef FEATURE_CM_SS_MEAS
      #error code not present
#endif /* FEATURE_CM_SS_MEAS */
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


                 /*-----------------------------------*/
                 /*     Change the mode preference    */
                 /*-----------------------------------*/

    case CM_PH_CMD_SYS_SEL_PREF:
    {
      /* Validate curr_nam */
      if(!INRANGE(ph_ptr->curr_nam, 0, CM_NAM_AUTO))
      {
        CM_ERR_1( "invalid curr_nam, PH_CMD:%d",CM_PH_CMD_SYS_SEL_PREF);
        return;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If the mode-preference is changed and the change is permanent,
      ** change the persistent mode preference and also write it to NV.
      */
      {
        cm_mode_pref_e_type new_mode_pref = cmd_info_ptr->mode_pref;

        /* If LTE was marked as disabled add LTE mode and store in NV */
        if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, cmd_info_ptr->cmd_subs))
        {
          if (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(new_mode_pref),
                                SD_SS_MODE_PREF_GSM )  &&
              sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(new_mode_pref),
                                SD_SS_MODE_PREF_WCDMA ))
          {
          new_mode_pref = cm_add_mode_pref_components(new_mode_pref,
                                                  1,SD_SS_MODE_PREF_GWL_LTE);
        }
          else
          {
            new_mode_pref = cm_add_mode_pref_components(new_mode_pref,
                                                  1,SD_SS_MODE_PREF_LTE);
          }

        }

        /* If HDR was marked as disabled add HDR mode and store in NV */
        if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, cmd_info_ptr->cmd_subs) &&
          ss == CM_SS_MAIN)
        {
          new_mode_pref = cm_add_mode_pref_components(new_mode_pref,
                                                  1,SD_SS_MODE_PREF_HDR);
        }
        CM_MSG_HIGH_1("new_mode_pref %d",new_mode_pref);
        CM_MSG_HIGH_2("Before adding EF_rat disable mask to new_mode_pref=%d,ef_rat_disable_mask=%d",new_mode_pref, cmph_temp_ef_rat_disabled_mask);

        if(cmph_temp_ef_rat_disabled_mask != SD_SS_MODE_PREF_NONE)
        {
          new_mode_pref = cm_add_mode_pref_components(new_mode_pref,1,cmph_temp_ef_rat_disabled_mask);
        }
        cmph_temp_ef_rat_disabled_mask = SD_SS_MODE_PREF_NONE;

        cmph_update_user_mode_pref(ss,new_mode_pref);

       if( cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
          !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_MODE_PREF))
       {

        CMPH_SET_PRST_MODE_PREF( asubs_id, ph_ptr, new_mode_pref);

        CM_MSG_HIGH_2("Writing NV_PREF_MODE_I: user mode pref=%d with cmd mode_pref=%d,resetted ef_rat_disable_mask",new_mode_pref, cmd_info_ptr->mode_pref);

          cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv(
                                          new_mode_pref);
          cmnv_item_ptr->pref_mode.nam  = (byte) ph_ptr->curr_nam;

          cmnv_write_extn( NV_PREF_MODE_I, cmnv_item_ptr,
                           CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr) );

          cmstats_ptr()->prm.cm_info.ph_info.mode_pref =
                    (sys_stats_mode_pref_e_type) ( cmd_info_ptr->mode_pref );
          cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK );
       }
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If the band-preference is changed, change the persistent band
      ** preference and also write it to NV.
      */
      if( CMPH_PRST_SS_BAND_PREF(asubs_id, ph_ptr) != cmd_info_ptr->band_pref &&
          cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
          !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_BAND_PREF))
      {
        cm_nv_band_pref_u_type temp;

        temp.dummy =  (uint32)cmd_info_ptr->band_pref;

        CMPH_SET_PRST_BAND_PREF( asubs_id, ph_ptr, cmd_info_ptr->band_pref);
        cmnv_item_ptr->band_pref.nam   = (byte) ph_ptr->curr_nam;

        cmnv_item_ptr->band_pref.band  = (nv_band_pref_enum_type)
                                                     temp.nv_band_pref[0];
        cmnv_write_extn( NV_BAND_PREF_I, cmnv_item_ptr,
                         CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr));

        cmnv_item_ptr->band_pref.band  = (nv_band_pref_enum_type)
                                                     temp.nv_band_pref[1];
        cmnv_write_extn( NV_BAND_PREF_16_31_I, cmnv_item_ptr,
                         CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr) );

        /* Move Bits 32-63 into a 32 bit variable so it can be stored.
        */
        cmnv_item_ptr->band_pref_32_63.band  = (uint32) (cmd_info_ptr->band_pref >> 32);

        cmnv_write_extn( NV_BAND_PREF_32_63_I, cmnv_item_ptr,
                         CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr) );
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      #ifdef FEATURE_CM_LTE
      /* If the LTE band-preference is changed, change the persistent band
      ** preference and also write it to EFS
      */
      {      
      sys_lte_band_mask_e_type ss_lte_band_pref = CMPH_PRST_SS_LTE_BAND_PREF(asubs_id,ph_ptr);
      if( !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&ss_lte_band_pref, &(cmd_info_ptr->lte_band_pref)) &&
          cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
          !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_LTE_BAND_PREF))
      {
        CMPH_SET_PRST_LTE_BAND_PREF( asubs_id, ph_ptr, cmd_info_ptr->lte_band_pref);
        #if ( LTE_BAND_NUM == 256 )
        {
          bit_mask_192_ext_s_type efs_lte_band_pref;

          /* Write the lower 64 bits in the legacy EFS location. */
          cmefs_fs_write( CMEFS_ID_LTE_BANDPREF,
                        (byte*)&(cmd_info_ptr->lte_band_pref.bits_1_64),
                        sizeof(cm_band_pref_e_type),
                        asubs_id);

          /* Write the extended 192 bits in the new EFS location. */
          efs_lte_band_pref.bits_65_128  = cmd_info_ptr->lte_band_pref.bits_65_128;
          efs_lte_band_pref.bits_129_192 = cmd_info_ptr->lte_band_pref.bits_129_192;
          efs_lte_band_pref.bits_193_256 = cmd_info_ptr->lte_band_pref.bits_193_256;
          cmefs_fs_write( CMEFS_ID_LTE_BANDPREF_65_256,
                          (byte*)&(efs_lte_band_pref),
                          sizeof(bit_mask_192_ext_s_type),
                          asubs_id);
        }
        #else
        cmefs_fs_write( CMEFS_ID_LTE_BANDPREF,
                        (byte*)&(cmd_info_ptr->lte_band_pref),
                        sizeof(cm_band_pref_e_type),
                        asubs_id);
        #endif
      }
      }
      #endif // FEATURE_CM_LTE

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* If the TDS band-preference is changed, change the persistent band
      ** preference and also write it to EFS
      */
      if( CMPH_PRST_SS_TDS_BAND_PREF(asubs_id,ph_ptr) != cmd_info_ptr->tds_band_pref &&
          cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
          !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_TDS_BAND_PREF))
      {
        CMPH_SET_PRST_TDS_BAND_PREF( asubs_id, ph_ptr, cmd_info_ptr->tds_band_pref);

        cmefs_fs_write( CMEFS_ID_TDS_BANDPREF,
                        (byte*)&(cmd_info_ptr->tds_band_pref),
                        sizeof(cm_band_pref_e_type),
                        asubs_id);
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* If the UE usage setting is changed, change the persistent persistant
      ** ue usage setting and also write it to EFS
      */
      if( CMPH_PRST_UE_USAGE_SETTING(asubs_id, ph_ptr) != cmd_info_ptr->ue_usage_setting &&
          cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
          !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_UE_USAGE_SETTING))
      {

        *(CMPH_PRST_UE_USAGE_SETTING_PTR( asubs_id, ph_ptr ))  = cmd_info_ptr->ue_usage_setting;

        cmefs_fs_write(CMEFS_UE_USAGE_SETTING,
                       (byte*)&cmd_info_ptr->ue_usage_setting,
                       sizeof(sys_ue_usage_setting_e_type),
                       asubs_id);
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      if( CMPH_PRST_VOICE_DOMAIN_PREF(asubs_id, ph_ptr) != cmd_info_ptr->voice_domain_pref &&
          cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
          !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_VOICE_DOMAIN_PREF))
      {

        *(CMPH_PRST_VOICE_DOMAIN_PREF_PTR( asubs_id, ph_ptr ))  = cmd_info_ptr->voice_domain_pref;

        cmefs_fs_write(CMEFS_VOICE_DOMAIN_PREF,
                       (byte*)&cmd_info_ptr->voice_domain_pref,
                       sizeof(sys_voice_domain_pref_e_type),
                       asubs_id);
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /*
      ** If the prl preference was changed, change the persistent
      ** network selection mode preference and also write it to NV.
      */
      if ( CMPH_PRST_SS_PRL_PREF( asubs_id, ph_ptr ) != cmd_info_ptr->prl_pref &&
           cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
           !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_PRL_PREF)
         )
      {
        CMPH_SET_PRST_PRL_PREF( asubs_id, ph_ptr, cmd_info_ptr->prl_pref);

        cmnv_item_ptr->prl_pref.prl = (uint32) cmd_info_ptr->prl_pref;

        cmnv_item_ptr->prl_pref.nam = (byte) ph_ptr->curr_nam;

        cmnv_write_extn( NV_PRL_PREF_I, cmnv_item_ptr,
                         CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr));

        cmstats_ptr()->prm.cm_info.ph_info.pref_sys =
            cmstats_map_cm_prl_pref_to_sys_prl_pref ( cmd_info_ptr->prl_pref );
        cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK );

      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* If the roam-preference is changed, change the persistent roam
      ** preference and also write it to NV.
      */
      if( CMPH_PRST_SS_ROAM_PREF( asubs_id, ph_ptr) != cmd_info_ptr->roam_pref &&
          cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
          !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_ROAM_PREF))
      {
        CMPH_SET_PRST_ROAM_PREF( asubs_id, ph_ptr, cmd_info_ptr->roam_pref);

        cmnv_item_ptr->roam_pref.roam  = (nv_roam_pref_enum_type)
                                                     cmd_info_ptr->roam_pref;

        cmnv_item_ptr->roam_pref.nam   = (byte) ph_ptr->curr_nam;

        cmnv_write_extn( NV_ROAM_PREF_I, cmnv_item_ptr,
                         CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr));
      }

      #if defined (FEATURE_HDR)
      /* If the hybr-preference is changed and the change is permanent,
      ** change the persistent mode preference and also write it to NV.
      */
      if( CMPH_PRST_SS_HYBR_PREF( asubs_id, ph_ptr) != cmd_info_ptr->hybr_pref &&
          cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
          !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_HYBR_PREF))
      {
        CMPH_SET_PRST_HYBR_PREF(asubs_id, ph_ptr, cmd_info_ptr->hybr_pref);
        cmnv_item_ptr->hybrid_pref =
           (byte)(cmph_map_cm_hybr_pref_to_sd_hybr_pref( cmd_info_ptr->hybr_pref));

        cmnv_write_extn( NV_HYBRID_PREF_I, cmnv_item_ptr,
                 CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr));
      }
      #endif // #ifdef FEATURE_HDR

      /*
      ** If the network selection mode preference was changed, change the persistent
      ** network selection mode preference and also write it to NV.
      */
      if ( CMPH_PRST_SS_NETWORK_SEL_MODE_PREF( asubs_id, ph_ptr ) != cmd_info_ptr->network_sel_mode_pref &&
           cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
           !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_NETWORK_SEL_MODE_PREF)
         )
      {
        CMPH_SET_PRST_NETWORK_SEL_MODE_PREF( asubs_id, ph_ptr, cmd_info_ptr->network_sel_mode_pref);

        cmnv_item_ptr->net_sel_mode_pref.net_sel_mode = (byte) cmd_info_ptr->network_sel_mode_pref;

        cmnv_item_ptr->net_sel_mode_pref.nam          = (byte) ph_ptr->curr_nam;

        cmnv_write_extn( NV_NET_SEL_MODE_PREF_I, cmnv_item_ptr,
                         CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr));
      }

      /*
      ** If the acquisition order preference was changed, change the persistent
      ** acquisition order preference and also write it to NV.
      */
      if ( CMPH_PRST_SS_ACQ_ORDER_PREF( asubs_id, ph_ptr ) != cmd_info_ptr->acq_order_pref &&
           cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT &&
           !cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_ACQ_ORDER_PREF))
      {
        CMPH_SET_PRST_ACQ_ORDER_PREF( asubs_id, ph_ptr, cmd_info_ptr->acq_order_pref );

        cmnv_item_ptr->acq_order_pref.acq_order = (byte) cmd_info_ptr->acq_order_pref;

        cmnv_item_ptr->acq_order_pref.nam       = (byte) ph_ptr->curr_nam;

        cmnv_write_extn( NV_ACQ_ORDER_PREF_I, cmnv_item_ptr,
                         CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr));
      }

      if( ( cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_PS_ATTACH ) &&
		  ( cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH ) &&
          ( cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_PS_DETACH)  &&
          ( cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_PS_LOCAL_DETACH)  &&
          ( cmd_info_ptr->srv_domain_pref != CM_SRV_DOMAIN_PREF_NO_CHANGE)
        )
      {
        /*
        ** If the service domain preference was changed, change the persistent
        ** service domain preference and also write it to NV.
        */
        if ( CMPH_PRST_SS_SRV_DOMAIN_PREF( asubs_id, ph_ptr ) != cmd_info_ptr->srv_domain_pref &&
             cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT )
        {
          CMPH_SET_PRST_SRV_DOMAIN_PREF( asubs_id, ph_ptr, cmd_info_ptr->srv_domain_pref);

          cmnv_item_ptr->service_domain_pref.srv_domain = (byte) cmd_info_ptr->srv_domain_pref;

          cmnv_item_ptr->service_domain_pref.nam        = (byte) ph_ptr->curr_nam;

          cmnv_write_extn( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
                           CMPH_SS_NV_CONTEXT(asubs_id, ph_ptr));
        }
      }

      #ifdef FEATURE_CM_LTE
      /* Update UE mode of operation preference */
      cmph_update_lte_ue_mode_of_operation (asubs_id);
      #endif


      /* Update the rat_acq_order list if the pref_term is permanent
      */
      if ( cmd_info_ptr->rat_acq_order_pref.type == CM_ACQ_ORDER_TYPE_RAT_PRI &&
           cmd_info_ptr->pref_term == CM_PREF_TERM_PERMANENT)
      {
        #ifdef FEATURE_RAT_PRIORITY_LIST
        /* Store rat acquisition order pref in NV */
        if(!cmph_write_rat_acq_order(
           &cmd_info_ptr->rat_acq_order_pref.acq_order.rat_acq_pri_order,
           asubs_id))
        {
          CM_ERR_0("Can't update rat_acq_order(TOT)");
        }
        #else
        CM_ERR_0("Rat priority list not supported, no rat_acq_order (TOT) update");
        #endif
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Notify clients of phone event.
      */
      #ifdef FEATURE_RAT_PRIORITY_LIST
      if ( cmd_info_ptr->rat_acq_order_pref.type == CM_ACQ_ORDER_TYPE_RAT_PRI )
      {
        cmph_event( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF );
      }
      else
      #endif
      {
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, ss );
      }

      cmph_send_subs_info(CM_SS_MAIN, NULL);
      if(cmph_is_msim())
      {

        /* Send the subscription Info to the clients as the prefereces
        ** have chaged.
        */
        if (cmph_is_sxlte() || \
                cmph_is_tsts())
        {
          cmph_send_subs_info(CM_SS_HYBR_3, NULL);
        }
        else
        {
          cmph_send_subs_info(CM_SS_HYBR_2, NULL);
        }

        cmph_sp_subs_info_update();
        cmph_send_vsid_info();

	    if(cmd_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH
			&&  cmph_is_msim()
	      )
	    {
           cmss_evaluate_effect_srv_domain_send_ss_event();
	    }

      }

    }

    break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                 /*-----------------------------------*/
                 /*     Change the DDTM preference  */
                 /*-----------------------------------*/

    case CM_PH_CMD_DDTM_PREF:

      {
        int i=0;

        SYS_ARG_NOT_USED(i);
        /* update the DDTM status */
        cmph_update_ddtm_status(ph_ptr);

        #ifdef FEATURE_DDTM_CNTL
        /* Write the new settings to NV
        */

        cmnv_item_ptr->ddtm_settings.ddtm_act    =
              cmph_map_cm_ddtm_act_mask_to_nv_ddtm_act( ph_ptr->ddtm_act_mask );

        cmnv_item_ptr->ddtm_settings.ddtm_pref   =
                     cmph_map_cm_ddtm_pref_to_nv_ddtm_pref( ph_ptr->ddtm_pref );

        cmnv_item_ptr->ddtm_settings.num_srv_opt = ph_ptr->ddtm_num_srv_opt;

        /* Initialize the list of service option pages to none
        */

        /* Cast is to prevent "implicit cast of pointer loses '__packed' qualifier"
        ** compiler error  C2906E
        */
        memset( (void*)cmnv_item_ptr->ddtm_settings.srv_opt_list, 0,
                sizeof(cmnv_item_ptr->ddtm_settings.srv_opt_list) );

        for( i=0; i<ph_ptr->ddtm_num_srv_opt; i++ )
        {
          cmnv_item_ptr->ddtm_settings.srv_opt_list[i] =
                                                ph_ptr->ddtm_srv_opt_list[i];
        }
        cmnv_write( NV_DDTM_SETTINGS_I, cmnv_item_ptr );
        #endif

        /* Notify clients of phone event */
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_DDTM_PREF, CM_SS_MAIN );
        CM_MSG_HIGH_1("CM_PH_EVENT_DDTM_PREF %d",ph_ptr->ddtm_pref);

      }

      break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        
                        /*-----------------------------------------*/
                        /* Block service option            */
                        /*-----------------------------------------*/
        
      
    case CM_PH_CMD_CHANGE_SRV_OPT:
    
      #ifdef FEATURE_DDTM_CNTL

      /* update the DDTM status */
      /* If num blocked srv opt is 0 means clients wants to unblock all the SOs 
          ** which was blocked earlier by calling change_sr_opt api
          */
      if((cmd_info_ptr->ddtm_num_blocked_srv_opt == 0) && 
         (ph_ptr->ddtm_num_blocked_srv_opt > 0) && 
         (ph_ptr->ddtm_num_blocked_srv_opt != CM_INVALID_DDTM_NUM_SRV_OPT))
      {
        /* Set ddtm num blocked srv op to 0 to unblock the SOs */
        ph_ptr->ddtm_num_blocked_srv_opt = 0;
        CM_MSG_HIGH_1("DDTM: Unblock SOs from client, ddtm_num_blocked_srv_opt %d",
          ph_ptr->ddtm_num_blocked_srv_opt );
        
      }
      else if(cmd_info_ptr->ddtm_num_blocked_srv_opt > 0)
      {
        CM_MSG_HIGH_1("DDTM: Block %d SOs ",cmd_info_ptr->ddtm_num_blocked_srv_opt);

        ph_ptr->ddtm_num_blocked_srv_opt = cmd_info_ptr->ddtm_num_blocked_srv_opt;
        /* Copy list of service options to be blocked into cmph ptr */
        memscpy(ph_ptr->ddtm_blocked_srv_opt_list, ph_ptr->ddtm_num_blocked_srv_opt * sizeof(sys_srv_opt_type),
              cmd_info_ptr->ddtm_blocked_srv_opt_list, ph_ptr->ddtm_num_blocked_srv_opt * sizeof(sys_srv_opt_type) );
 
      }

      /* Do not block SOs 
          ** 1. when in emerg call or mode 
          ** 2. When all the SOs are currently blocked
          */
      if(ph_ptr->ddtm_num_blocked_srv_opt > 0)
      {
        boolean is_emerg_call_or_mode = FALSE;
        if((ph_ptr->cur_ddtm_act_mask & SYS_DDTM_ACT_IGN_SO_PAGES) && (ph_ptr->cur_ddtm_srv_opt_list[0] == CAI_SO_NULL))
        {
          ph_ptr->ddtm_num_blocked_srv_opt = CM_INVALID_DDTM_NUM_SRV_OPT;
          CM_MSG_HIGH_0("All SOs are currently ignored.");
          break;
        }

        
        is_emerg_call_or_mode = cmph_is_in_emergency_cb();

        CMCALL_FOR_EACH_CALL_DO
         
        if( this_call->call_type == CM_CALL_TYPE_EMERGENCY )
        {
          is_emerg_call_or_mode = TRUE;
        }
        CMCALL_END_FOR

        /* If in emerg call or mode ignore the command */  
        if(is_emerg_call_or_mode)
        {
          ph_ptr->ddtm_num_blocked_srv_opt = CM_INVALID_DDTM_NUM_SRV_OPT;
          CM_MSG_HIGH_0("In emerg call or mode reset num blocked srv op ");
          break;
        }
      }
      
      /* Block/Unblock SO if ddtm_num_blocked_srv_opt is valid. 
      ** 0 - indicate the SO to be unblocked
      ** else unblock the given no of SOs 
      */
      
      /*---------------------------------------------------------------------------------
      */
      /* When curr DDTM status is TRUE and there are list of SOs being blocked
      ** use curr_ddtm_srv_opt to compute the list of SOs to be
      ** sent to MC
      */
      if ((ph_ptr->ddtm_num_blocked_srv_opt != CM_INVALID_DDTM_NUM_SRV_OPT) &&
        (ph_ptr->cur_ddtm_status == TRUE ) && 
        (ph_ptr->cur_ddtm_act_mask & SYS_DDTM_ACT_MASK_IGN_SO_PAGES))
      {
      cmph_update_ddtm_status(ph_ptr);
      }
      /* When DDTM pref is OFF or no SOs are currently blocked just pass the SO list provided by DS 
      */
      else if((ph_ptr->ddtm_pref == CM_DDTM_PREF_OFF) ||
        (ph_ptr->cur_ddtm_status == FALSE))
      {
         mc_msg_type                    *mc_ptr;
         uint8 i;
     
        mc_ptr                                = cm_mc_get_buf_else_err_fatal();
        mc_ptr->hdr.cmd                       = MC_DDTM_CNTL_F;
        mc_ptr->ddtm_cntl.status              = TRUE;
        mc_ptr->ddtm_cntl.ddtm_act_mask       = SYS_DDTM_ACT_MASK_IGN_SO_PAGES;

        mc_ptr->ddtm_cntl.num_srv_opt         = ph_ptr->ddtm_num_blocked_srv_opt;
        for( i=0; i < mc_ptr->ddtm_cntl.num_srv_opt; i++ )
        {
          mc_ptr->ddtm_cntl.srv_opt_list[i] =  ph_ptr->ddtm_blocked_srv_opt_list[i];
        }

        CM_MSG_HIGH_1( "Send DDTM to MC, num_srv_opt %d blocked ",    
               ph_ptr->ddtm_num_blocked_srv_opt );

        cm_mc_send_cmd( mc_ptr );
        /* If command is to unblock SOs, reset the ddtm_num_blocked_srv_opt
        ** after sending the command to MC as it is one time operation
        */
        if(ph_ptr->ddtm_num_blocked_srv_opt == 0)
        {
          ph_ptr->ddtm_num_blocked_srv_opt = CM_INVALID_DDTM_NUM_SRV_OPT;
        }
      }
      #endif
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

              /*-----------------------------------------*/
              /* Change the answer-voice-as-data setting */
              /*-----------------------------------------*/

    case CM_PH_CMD_ANSWER_VOICE:

      /* Put the new answer-voice setting in the data base.
      ** MC consults it upon receiving a page.
      */
      #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
      db_item.voice_as_data = cmph_map_voice_answer_cm2db( cmd_info_ptr->answer_voice );
      db_put( DB_VOICE_AS_DATA, &db_item );

      cmph_event( ph_ptr, CM_PH_EVENT_ANSWER_VOICE );
      #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                      /*--------------------------*/
                      /* Change the NAM selection */
                      /*--------------------------*/

    case CM_PH_CMD_NAM_SEL:

      /* Update the NAM dependent variables, such as
      ** the mode preference and the system preference
      ** in accordance with the new NAM selection.
      */
      if(!INRANGE(ph_ptr->curr_nam, 0, NV_MAX_NAMS))
      {
        CM_ERR_1( "invlid nam: %d", ph_ptr->curr_nam);
        break;
      }
      ph_ptr->main_stack_info.pref_info.mode_pref = CMPH_PRST_MODE_PREF( ph_ptr );
      ph_ptr->main_stack_info.pref_info.band_pref  = CMPH_PRST_BAND_PREF( ph_ptr );
      ph_ptr->main_stack_info.pref_info.roam_pref  = CMPH_PRST_ROAM_PREF( ph_ptr );

      /* If new selection is AUTO-NAM write to NV
      ** and notify clients of NAM-SELECTION event.
      */
      if( cmd_info_ptr->nam_sel == CM_NAM_AUTO )
      {
        cmnv_item_ptr->auto_nam = TRUE;
        cmnv_write( NV_AUTO_NAM_I, cmnv_item_ptr );

        cmph_event( ph_ptr, CM_PH_EVENT_NAM_SEL );
      }

      /* Else, write the new NAM selection to NV, and notify
      ** clients of NAM-SELECTION, as well as, CURR-NAM events.
      */
      else
      {
        cmnv_item_ptr->auto_nam = FALSE;
        cmnv_write( NV_AUTO_NAM_I, cmnv_item_ptr );

        cmnv_item_ptr->curr_nam = (byte) cmd_info_ptr->nam_sel;
        cmnv_write( NV_CURR_NAM_I, cmnv_item_ptr );

        cmph_event( ph_ptr, CM_PH_EVENT_NAM_SEL );
        cmph_event( ph_ptr, CM_PH_EVENT_CURR_NAM );
      }


      /* Read NV items for the new NAM
      */
      cmph_read_nv_items(ph_ptr);

      (void)cmph_insert_orig_mode (
                                    CM_SS_MAIN,
                                    SD_SS_ORIG_MODE_NONE,
                                    CM_ACT_TYPE_PH_OBJ,
                                    ph_ptr->main_stack_info.pref_info.pref_term,
                                    ph_ptr->main_stack_info.pref_info.mode_pref,
                                    ph_ptr->main_stack_info.pref_info.band_pref,
                                    ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                    ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                    ph_ptr->main_stack_info.pref_info.prl_pref,
                                    ph_ptr->main_stack_info.pref_info.roam_pref,
                                    ph_ptr->main_stack_info.pref_info.hybr_pref,
                                    ph_ptr->int_hybr_pref,
                                    ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                    (cm_act_id_type)ph_ptr,
                                    CM_ACT_UPDATE_REAS_ACT_START,
                                    CM_DEFAULT_VALUE,
                                    ph_ptr->main_stack_info.pref_info.csg_id,
                                    ph_ptr->main_stack_info.pref_info.csg_rat
                                  );
      /* Add in the orig Q the ph_ptr values
      */

      (void)cmph_insert_orig_mode (
                                    CM_SS_HDR,
                                    SD_SS_ORIG_MODE_NONE,
                                    CM_ACT_TYPE_PH_OBJ,
                                    ph_ptr->main_stack_info.pref_info.pref_term,
                                    ph_ptr->main_stack_info.pref_info.mode_pref,
                                    ph_ptr->main_stack_info.pref_info.band_pref,
                                    ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                    ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                    ph_ptr->main_stack_info.pref_info.prl_pref,
                                    ph_ptr->main_stack_info.pref_info.roam_pref,
                                    ph_ptr->main_stack_info.pref_info.hybr_pref,
                                    ph_ptr->int_hybr_pref,
                                    ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                    (cm_act_id_type)ph_ptr,
                                    CM_ACT_UPDATE_REAS_ACT_START,
                                    CM_DEFAULT_VALUE,
                                    ph_ptr->main_stack_info.pref_info.csg_id,
                                    ph_ptr->main_stack_info.pref_info.csg_rat
                                  );
      /* Add in the orig Q the ph_ptr values
      */

      break;



    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*------------------------------------------*/
                   /* Send phone info to the requesting client */
                   /*------------------------------------------*/

    case CM_PH_CMD_INFO_GET:

      /* get a buffer for phone info */

      ph_info_ptr = cmph_info_alloc();

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Copy phone information into
      ** allocated phone info buffer.
      */
      (void) cmph_info_get( ph_info_ptr, ss );

      CM_MSG_HIGH_3("ph evt %d ct %d cid id %d",
                    CM_PH_EVENT_INFO,
                    cmclient_get_client_type(ph_info_ptr->requesting_client_id),
                    ph_info_ptr->requesting_client_id);

      /* notify only the requesting client
         Note: Client ID is set to the beginning address
               of the client object during the client initialization
      */
      cm_client_ph_event_ntfy(ph_cmd_ptr->client_ptr,
                              CM_PH_EVENT_INFO,
                              ph_info_ptr );

      /* Deallocate the memory after sending the ph event. */
      cm_mem_free(ph_info_ptr);

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*-------------------------------------------------*/
                   /* Send subscription info to the requesting client */
                   /*-------------------------------------------------*/

    case CM_PH_CMD_SUBSCRIPTION_INFO_GET:
      /* Populate the subscription Info and send it to
      ** the particular client who requested.
      */
      cmph_send_subs_info( ss , ph_cmd_ptr->client_ptr);
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /*----------------------------------*/
      /* Set RSSI change delta threshold  */
      /*----------------------------------*/

    case CM_PH_CMD_RSSI_DELTA:

      /* get the phone object pointer */

      ph_ptr                = cmph_ptr();
      ph_ptr->rssi_delta    = cmd_info_ptr->rssi_delta;

      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


      /*------------------------------------------ */
      /* Set RSSI,ECIO,IO change delta threshold   */
      /*-------------------------------------------*/

    case CM_PH_CMD_SIGNAL_STRENGTH_DELTA:

      /* get the phone object pointer */

      ph_ptr                = cmph_ptr();

      /* Update the thresholds if applicable
      */
      if( cmd_info_ptr->rssi_delta != CM_SIG_STRENGTH_DELTA_NO_CHANGE )
      {
        ph_ptr->rssi_delta    = cmd_info_ptr->rssi_delta;
      }

      if( cmd_info_ptr->ecio_delta != CM_SIG_STRENGTH_DELTA_NO_CHANGE )
      {
        ph_ptr->ecio_delta    = cmd_info_ptr->ecio_delta;
      }

      if( cmd_info_ptr->io_delta != CM_SIG_STRENGTH_DELTA_NO_CHANGE )
      {
        ph_ptr->io_delta    = cmd_info_ptr->io_delta;
      }

      if( cmd_info_ptr->sir_delta != CM_SIG_STRENGTH_DELTA_NO_CHANGE )
      {
        ph_ptr->sir_delta          = cmd_info_ptr->sir_delta;
      }

      if( cmd_info_ptr->pathloss_delta != CM_SIG_STRENGTH_DELTA_NO_CHANGE )
      {
        ph_ptr->pathloss_delta          = cmd_info_ptr->pathloss_delta;
      }

      if( cmd_info_ptr->cqi_delta != CM_SIG_STRENGTH_DELTA_NO_CHANGE )
      {
        ph_ptr->cqi_delta          = cmd_info_ptr->cqi_delta;
      }

      if( cmd_info_ptr->rsrp_delta != CM_SIG_STRENGTH_DELTA_NO_CHANGE )
      {
        ph_ptr->rsrp_delta          = cmd_info_ptr->rsrp_delta;
      }

      if( cmd_info_ptr->rsrq_delta != CM_SIG_STRENGTH_DELTA_NO_CHANGE )
      {
        ph_ptr->rsrq_delta          = cmd_info_ptr->rsrq_delta;
      }

      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_DEACTIVATE_SUBS:
    {
      if(ph_ptr->num_standby_requests_processing > 0)
      {
         CM_MSG_HIGH_1("MCFG: num_standby_proc %d",ph_ptr->num_standby_requests_processing);
         break;
      }
      #ifdef FEATURE_MODEM_CONFIG_REFRESH
      if(!mcfg_notify_deactivate_success(ph_ptr->mcfg_deactivate_subs))
      {
        CM_MSG_HIGH_0("MCFG:notify fail");
      }
      #endif
      /* Send the PH Event that Standby Preferences have changed
      */
      cmph_event( ph_ptr, CM_PH_EVENT_DUAL_STANDBY_PREF );
      cmph_event( ph_ptr, CM_PH_EVENT_DEACTIVATE_SUBS );
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* Send the subscription event on all stacks
      */
      cmph_send_subs_info(CM_SS_MAIN, NULL);

      if (!cmph_is_sxlte() && cmph_is_msim())
      {
        cmph_send_subs_info(CM_SS_HYBR_2, NULL);
      }

      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if(cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY ||
        cmph_is_sxlte() )
      {
        cmph_send_subs_info(CM_SS_HYBR_3, NULL);
      }
      #endif

      cmph_sp_subs_info_update();
      cmph_send_vsid_info();

      break;
    }
   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_ACTIVATE_SUBS:
    {
    
      /* Send the PH Event that Standby Preferences have changed
      */
      cmph_event( ph_ptr, CM_PH_EVENT_DUAL_STANDBY_PREF );

      cmph_event( ph_ptr, CM_PH_EVENT_ACTIVATE_SUBS );
      /* Send the subscription event on all stacks
      */
      cmph_send_subs_info(CM_SS_MAIN, NULL);

      if (!cmph_is_sxlte() && cmph_is_msim())
      {
        cmph_send_subs_info(CM_SS_HYBR_2, NULL);
      }

      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if(cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY ||
        cmph_is_sxlte() )
      {
        cmph_send_subs_info(CM_SS_HYBR_3, NULL);
      }
      #endif

      cmph_sp_subs_info_update();
      cmph_send_vsid_info();

      break;
    }
   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
                     /*---------------------*/
                     /* Change packet state */
                     /*---------------------*/

    case CM_PH_CMD_PACKET_STATE:
      cmph_event_per_subs( ph_ptr, CM_PH_EVENT_PACKET_STATE, CM_SS_MAIN);
      break;



    #ifdef FEATURE_JCDMA
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*----------------------------------*/
                   /* Enable/Disable voice activity    */
                   /*----------------------------------*/

      case CM_PH_CMD_VOC_ACTIVITY:

        /* do nothing - this request terminated at CM */
      break;

    #endif /* FEATURE_JCDMA */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_AVOID_SYS:
      /* do nothing - this request terminated at CM */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_WAKEUP_FROM_STANDBY:
      cmph_event( ph_ptr, CM_PH_EVENT_WAKEUP_FROM_STANDBY );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #if ( defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) )
    case CM_PH_CMD_CHANGE_RTRE_CONFIG:
      ph_ptr->rtre_control = ph_cmd_ptr->info.rtre_control;
      ph_ptr->rtre_config = ph_cmd_ptr->info.rtre_config;

      /* Update spc
      */
      cmph_read_nv_items( ph_ptr );

      cmph_event( ph_ptr, CM_PH_EVENT_NVRUIM_CONFIG_CHANGED );

      break;
    #endif /* defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*----------------------------------*/
                   /* Personalization information Available  */
                   /*----------------------------------*/

    case CM_PH_CMD_PERSO_INFO_AVAILABLE:

        /* do nothing  */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

              /*------------------------*/
              /* Subscription Available */
              /*------------------------*/

    case CM_PH_CMD_SUBSCRIPTION_AVAILABLE:
    {
      cmmsc_state_machine_s_type     *state_machine = NULL;

      if ( cmd_info_ptr->gwl_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_gwl_subscription_available = TRUE;

        TTLBOOTUP(GWL_SUBSCRIP_AVAIL);

        CM_MSG_HIGH_0("gwl sub a");

      }

      if ( cmd_info_ptr->gw2_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_hybr_gw_subscription_available = TRUE;

        TTLBOOTUP(HYBR_GWL_SUBSCRIP_AVAIL);

        CM_MSG_HIGH_0("hybr_gw2 sub a");

      }

      #if defined(FEATURE_MMODE_SXLTE_G)
      if(cmph_is_sxlte() &&
         cmd_info_ptr->gw3_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        ph_ptr->is_hybr_gw3_subscription_available = TRUE;

        TTLBOOTUP(HYBR_GWL_SUBSCRIP_AVAIL);

        CM_MSG_HIGH_0("hybr_gw3 sub a");

      }
      #endif

      #if defined(FEATURE_MMODE_TRIPLE_SIM)
      if ( cmd_info_ptr->gw3_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_hybr_gw3_subscription_available = TRUE;
        //TTLBOOTUP(HYBR3_GWL_SUBSCRIP_AVAIL);
        
        CM_MSG_HIGH_0("hybr_gw3 sub a");
      }
      #endif

      if ( cmd_info_ptr->cdma_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_cdma_subscription_available = TRUE;

        TTLBOOTUP(CDMA_SUBSCRIP_AVAIL);

        CM_MSG_HIGH_0("cdma sub a");

      }

      if(ph_ptr->abort_ss_bitmask)
      {
        ph_ptr->abort_ss_bitmask = 0;
      }

      /* Update spc
      */
      cmph_read_nv_items( ph_ptr );

      #if (defined FEATURE_ALS) && (defined FEATURE_GSM)
      if((cmd_info_ptr->gwl_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE) &&
         (ph_ptr->is_gwl_subscription_available) )
      {

        /*
        ** GW subscription became available.
        ** Reset ALS settings
        */
        cmals_reset();
        cmph_als_reset();

        CM_MSG_LOW_0("ALS - queue CPHS read request to MMGSDI ...");

        /*
        ** Reread ALS settings from the SIM.
        ** Send CM_PH_EVENT_SUBSCRIPTION_AVAILABLE event
        ** only after all ALS information is read from the SIM
        */
        if(!cmals_mmgsdi_read_cphs(ss, CM_PH_EVENT_SUBSCRIPTION_AVAILABLE))
        {
          CM_ERR_0("ALS - failed to queue CPHS request to MMGSDI!!!");
          cmph_event( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_AVAILABLE );
          cmph_event( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF );
        }

      }
      else
      {
        cmph_event( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_AVAILABLE );
        cmph_event( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF );
      }
      #else
      /* CM needs to send sys sel pref event as well for clients to update new preferences which could
         ** changed due to picking preferences from persistent upon subsc changed*/
         
      if( cmd_info_ptr->gwl_sub_avail_status  == CM_SUBSCRIPTION_STATUS_CHANGE ||
          cmd_info_ptr->cdma_sub_avail_status  == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_AVAILABLE, CM_SS_MAIN );
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_MAIN );
      }
      else if(cmd_info_ptr->gw2_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_AVAILABLE, CM_SS_HYBR_2 );
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_HYBR_2 );
      }

      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      else if(cmd_info_ptr->gw3_sub_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_AVAILABLE, CM_SS_HYBR_3 );
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_HYBR_3 );
      }
      #endif /* FEATURE_MMODE_TRIPLE_SIM */
      #endif /* #if (defined FEATURE_ALS) && (defined FEATURE_GSM) */

      cmph_send_subs_info(CM_SS_MAIN, NULL);
      if(cmph_is_msim())
      {
        /* Send the subscription event on all stacks
           */
        if (!cmph_is_sxlte())
        {
          cmph_send_subs_info(CM_SS_HYBR_2, NULL);
        }
        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        if(cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY ||
          cmph_is_sxlte())
        {
          cmph_send_subs_info(CM_SS_HYBR_3, NULL);
        }
        #endif

        cmph_sp_subs_info_update();
        cmph_send_vsid_info();
      }

      /* If subscriptions become available and we have decided to bring hybr-2 up,
      ** then start hybr-2 stack in SD
      */
        if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1))
    {
      state_machine = cmmsimc_get_msc_ptr_per_cm_ss(CM_SS_HYBR_2);
          if (cmmsc_auto_is_kick_hybr2_pending(state_machine))
          {
            cmph_kick_hybr_2_if_pending(TRUE);
          }
    }

      #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
      /* activate arbitration if all conditions met */
      cmsoa_activate_arbitration();
      #endif /* FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH */
      if (!cmmmgsdi_count_given_state (CMMMGSDI_STATE_SESSION_CHANGED))
      {
        cmph_send_oprt_mode_online_to_mmoc();
      }
      /* Reset the flag to indicate subscription cmd processing is done.
      */
      cmph_subsc_cmd_proccessing_in_progress = FALSE;
      break;
    }

     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
              /*----------------------------*/
              /* Subscription Not Available */
              /*----------------------------*/

    case CM_PH_CMD_SUBSCRIPTION_NOT_AVAILABLE:
    {

      if ( cmd_info_ptr->gwl_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_gwl_subscription_available = FALSE;
        CM_MSG_HIGH_0("gwl sub na");
      }
      if ( cmd_info_ptr->gw2_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_hybr_gw_subscription_available = FALSE;
        CM_MSG_HIGH_0("hybr_gw2 sub na");
      }
      if ( cmd_info_ptr->gw3_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_hybr_gw3_subscription_available = FALSE;
        CM_MSG_HIGH_0("hybr_gw3 sub na");
      }
      if ( cmd_info_ptr->cdma_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_cdma_subscription_available = FALSE;
        CM_MSG_HIGH_0("cdma sub na");
      }

      if(ph_ptr->is_ims_cmd_ntfy_sent)
      {
        ph_ptr->is_ims_cmd_ntfy_sent = FALSE;
      }

      if(ph_ptr->is_ds_cmd_ntfy_sent)
      {
        ph_ptr->is_ds_cmd_ntfy_sent = FALSE;
      }

      if(ph_ptr->abort_ss_bitmask)
      {
        ph_ptr->abort_ss_bitmask = 0;
      }

      #if (defined FEATURE_ALS) && (defined FEATURE_GSM)
      if((cmd_info_ptr->gwl_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE ) &&
         (!ph_ptr->is_gwl_subscription_available))
      {
        /*
        ** GWL subscription changed and became not available
        ** Reset ALS settings
        */
        cmals_reset();
        cmph_als_reset();
      }
      #endif /* #if (defined FEATURE_ALS) && (defined FEATURE_GSM) */

      #ifdef CM_GW_SUPPORTED
      cmwaoc_reset();

      #if (defined FEATURE_CM_RESET_MANUAL_PLMN_ON_SIM_REFRESH)

      /* Undefine the plmn.
      */
      if( (cmd_info_ptr->gwl_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE ) &&
           (!ph_ptr->is_gwl_subscription_available) &&
           (ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ))
      {
          sys_plmn_undefine_plmn_id( &ph_ptr->main_stack_info.pref_info.plmn );
      }
      #endif /* FEATURE_CM_RESET_MANUAL_PLMN_ON_SIM_REFRESH */

      /* aoc_ready should be set to FALSE
      */
      /*lint -e{730} This is intentional so it is readable */
      CM_ASSERT (ph_ptr->main_stack_info.phone_charge.aoc_ready == FALSE);
      #endif

      cmph_send_subs_info(CM_SS_MAIN, NULL);
      if(cmph_is_msim())
      {
        /* Send the subscription event on all stacks
           */

        if (!cmph_is_sxlte())
        {
          cmph_send_subs_info(CM_SS_HYBR_2, NULL);
        }

        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        if(cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY || cmph_is_sxlte())
        {
          cmph_send_subs_info(CM_SS_HYBR_3, NULL);
        }
        #endif

        cmph_sp_subs_info_update();
        cmph_send_vsid_info();
      }
      /* CM needs to send sys sel pref event as well for clients to update new preferences which could
         ** changed due to picking preferences from persistent upon subsc changed*/

      if( cmd_info_ptr->gwl_sub_not_avail_status  == CM_SUBSCRIPTION_STATUS_CHANGE ||
          cmd_info_ptr->cdma_sub_not_avail_status  == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_NOT_AVAILABLE, CM_SS_MAIN );
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_MAIN );
      }
      else if(cmd_info_ptr->gw2_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_NOT_AVAILABLE, CM_SS_HYBR_2 );
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_HYBR_2 );
      }
      else if(cmd_info_ptr->gw3_sub_not_avail_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_NOT_AVAILABLE, CM_SS_HYBR_3 );
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_HYBR_3 );
      }

      #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
      /* activate arbitration if all conditions met */
      cmsoa_activate_arbitration();
      #endif /* FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH */

      break;
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
              /*------------------------*/
              /* Subscription Changed */
              /*------------------------*/

    case CM_PH_CMD_SUBSCRIPTION_CHANGED:
    {
      if ( cmd_info_ptr->gwl_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_gwl_subscription_available = TRUE;
        CM_MSG_HIGH_0("gwl sub ch -> a");
      }
      if ( cmd_info_ptr->gw2_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_hybr_gw_subscription_available = TRUE;
        CM_MSG_HIGH_0("hybr_gw2 sub ch -> a");
      }
      if ( cmd_info_ptr->gw3_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_hybr_gw3_subscription_available = TRUE;
        CM_MSG_HIGH_0("hybr_gw3 sub ch -> a");
      }
      if ( cmd_info_ptr->cdma_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE )
      {
        ph_ptr->is_cdma_subscription_available = TRUE;
        CM_MSG_HIGH_0("cdma sub ch -> a");
      }

      if(ph_ptr->abort_ss_bitmask)
      {
        ph_ptr->abort_ss_bitmask = 0;
      }

      /* Update spc
      */
      cmph_read_nv_items( ph_ptr );

      #if (defined FEATURE_ALS) && (defined FEATURE_GSM)
      if((cmd_info_ptr->gwl_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE) &&
         (ph_ptr->is_gwl_subscription_available))
      {

        /*
        ** GWL subscription changed and is still available
        ** Reset ALS settings
        */
        cmals_reset();
        cmph_als_reset();

        /*
        ** Reread ALS settings from the SIM
        ** Send CM_PH_EVENT_SUBSCRIPTION_CHANGED event
        ** only after all ALS information is read from the SIM
        */
        CM_MSG_LOW_0("ALS - queue CPHS read request...");

        if(!cmals_mmgsdi_read_cphs(ss, CM_PH_EVENT_SUBSCRIPTION_CHANGED))
        {
          cmph_event( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_CHANGED );
          cmph_event( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF );
        }
      }
      else
      {
        cmph_event( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_CHANGED );
        cmph_event( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF );
      }
      #else
      if (cmph_is_msim())
      {
        if( cmd_info_ptr->gwl_sub_changed_status  == CM_SUBSCRIPTION_STATUS_CHANGE ||
            cmd_info_ptr->cdma_sub_changed_status  == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_CHANGED, CM_SS_MAIN );
          cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_MAIN );
        }
        else if(cmd_info_ptr->gw2_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE)
        {
          cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_CHANGED, CM_SS_HYBR_2 );
          cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_HYBR_2 );
        }
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      else if(cmd_info_ptr->gw3_sub_changed_status == CM_SUBSCRIPTION_STATUS_CHANGE)
      {
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_CHANGED, CM_SS_HYBR_3 );
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_HYBR_3 );
      }
      #endif
      }
      else
      {
        cmph_event( ph_ptr, CM_PH_EVENT_SUBSCRIPTION_CHANGED );
      }
      #endif /* #if (defined FEATURE_ALS) && (defined FEATURE_GSM) */

      #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
      /* activate arbitration if all conditions met */
      cmsoa_activate_arbitration();
      #endif /* FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH */

      break;
    }
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
              /*-----------------------------------------*/
              /* Client has requested a list of networks */
              /*-----------------------------------------*/


    case CM_PH_CMD_GET_NETWORKS:
      if ( cmd_info_ptr->network_list_type == CM_NETWORK_LIST_USER_PREFERRED ||
           cmd_info_ptr->network_list_type == CM_NETWORK_LIST_USER_PREFERRED_UNPACKED)
      {

        cmph_set_net_lists_present_flag(TRUE);

        /* Sending an event to the client notifying that the SIM values are available */
        if (ss == CM_SS_HYBR_2 && cmph_is_msim())
        {
          cmph_event_per_subs(ph_ptr, CM_PH_EVENT_PREFERRED_NETWORKS_CONF, CM_SS_HYBR_2);
        }
        else
        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        if (ss == CM_SS_HYBR_3)
        {
          cmph_event_per_subs(ph_ptr, CM_PH_EVENT_PREFERRED_NETWORKS_CONF, CM_SS_HYBR_3);
        }
        else
        #endif /* FEATURE_MMODE_TRIPLE_SIM */
        {
          cmph_event_per_subs(ph_ptr, CM_PH_EVENT_PREFERRED_NETWORKS_CONF, CM_SS_MAIN);
        }

        cmph_set_net_lists_present_flag(FALSE);
        #ifdef FEATURE_MMODE_DUAL_ACTIVE
        if(cmph_is_dsda() && asubs_id == SYS_MODEM_AS_ID_2)
        {
          #if defined(FEATURE_MMODE_SXLTE_G)
          if (cmph_is_sxlte())
          {
            ph_ptr->hybr_3_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
          }
          else
          #endif
          {
            ph_ptr->hybr_2_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
          }
        }
        else
        #endif
        {
          ph_ptr->main_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
        }
        ph_ptr->ss_for_get_networks = CM_SS_NONE;
      }
      break;

     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
              /*-----------------------------------------*/
              /* Client has requested to terminate the   */
              /* acquisition of the available networks   */
              /*-----------------------------------------*/

    case CM_PH_CMD_TERMINATE_GET_NETWORKS:
      cmph_term_pending_get_networks_req_client_only(ph_ptr->ss_for_get_networks);
      break;

     #ifdef CM_GW_SUPPORTED
              /*-----------------------------------------------------*/
              /* Client has requested to save the preferred networks */
              /*-----------------------------------------------------*/

    case CM_PH_CMD_SET_PREFERRED_NETWORKS:

      cmph_set_net_lists_present_flag(TRUE);

      cmph_event (ph_ptr, CM_PH_EVENT_PREFERRED_NETWORKS_SET);

      cmph_set_net_lists_present_flag(FALSE);
      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_RESET_ACM:
      /* reset acm */

      cmwaoc_reset_acm_mmgsdi(ss);

      /* send ph event */
      cmph_event_per_subs( ph_ptr, CM_PH_EVENT_RESET_ACM_COMPLETED, ss );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_SET_ACMMAX:
      /* set the max acm */

      cmwaoc_set_acmmax_mmgsdi( ss, cmd_info_ptr->new_acmmax);


      /* sent the corresponding ph event */
      cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SET_ACMMAX_COMPLETED, ss );
      break;
      #endif /* (defined CM_GW_SUPPORTED) */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #if (defined FEATURE_ALS) && (defined FEATURE_GSM)
    case CM_PH_CMD_LINE_SWITCHING:
    case CM_PH_CMD_SELECTED_LINE:
      break;

    case CM_PH_CMD_LINE_SWITCHING_SAVED:
      cmph_event( ph_ptr, CM_PH_EVENT_LINE_SWITCHING );
      break;

    case CM_PH_CMD_SELECTED_LINE_SAVED:
      cmph_event( ph_ptr, CM_PH_EVENT_SELECTED_LINE );
      break;

    case CM_PH_CMD_ALS_SIM_INFO_AVAIL:
      /*
      ** Now that all ALS-related info has been read from the SIM,
      ** send CM_PH_EVENT_SUBSCRIPTION_AVAILABLE / CM_PH_EVENT_SUBSCRIPTION_CHANGED
      ** as passed to CM from CM ALS custom
      */
      cmph_event( ph_ptr, *((cm_ph_event_e_type*)ph_cmd_ptr->data_block_ptr));
      break;

    #endif /* #if (defined FEATURE_ALS) && (defined FEATURE_GSM) */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


    #ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
    #error code not present
#endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                   /*----------------------------------*/
                   /* Set user selected net_sel_mode   */
                   /*----------------------------------*/

    case CM_PH_CMD_SET_USER_NET_SEL_MODE:

        /* do nothing - this request terminated at CM */
      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PH_CMD_DUAL_STANDBY_PREF:

      if(ph_ptr->dds_switch_type == DDS_CAUSE_PERMANENT)
      {
        /* updated Prst DDS */
        ph_ptr->prst_dual_standby_pref.default_data_subs = cmd_info_ptr->default_data_subs;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* If DS pref at bootup was not NO_STANDBY, write new pref to NV
      */
      if(!ph_ptr->is_bootup_no_standby)
      {
        /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        /* Write the Dual Standby Preference to NV
        */
        cmnv_item_ptr->dual_standby_cfg_items.dedicated_data_subs   = (uint8)ph_ptr->prst_dual_standby_pref.default_data_subs;
        cmnv_item_ptr->dual_standby_cfg_items.dedicated_voice_subs  = (uint8)ph_ptr->default_voice_subs;
        cmnv_item_ptr->dual_standby_cfg_items.active_subs           = (uint8)ph_ptr->active_subs;
        cmnv_item_ptr->dual_standby_cfg_items.priority_subs         = (uint8)ph_ptr->priority_subs;
        cmnv_item_ptr->dual_standby_cfg_items.dual_standby_pref     = (uint8)ph_ptr->user_standby_pref;
        cmnv_write( NV_DUAL_STANDBY_CFG_ITEMS_I, cmnv_item_ptr );
      }
      // This should have been reset already but keeping it as it is
      ph_ptr->is_standby_pref_buffered = FALSE;

      /* Sending subsc_cap & tie-breakers info to TRM*/
      cmph_sp_subs_info_update();

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* Send the PH Event that Standby Preferences have changed
      */
      cmph_event( ph_ptr, CM_PH_EVENT_DUAL_STANDBY_PREF );


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* Send the subscription event on all stacks
      */
      cmph_send_subs_info(CM_SS_MAIN, NULL);

      if (!cmph_is_sxlte() && cmph_is_msim())
      {
        cmph_send_subs_info(CM_SS_HYBR_2, NULL);
      }

      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if(cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY ||
        cmph_is_sxlte() )
      {
        cmph_send_subs_info(CM_SS_HYBR_3, NULL);
      }
      #endif

      #ifdef FEATURE_MMODE_DUAL_SIM
      cmph_send_vsid_info();
      #endif

	  if(cmph_is_msim())
	  {
        cmss_evaluate_effect_srv_domain_send_ss_event();
	  }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

               /*--------------------------------------------------*/
               /* Detach, and/or PLMN blocking, or PLMN unblocking */
               /* or PLMN forbidden list reset                     */
               /*--------------------------------------------------*/

      case CM_PH_CMD_PLMN_BLOCKING:

        /* do nothing - CM has already send request to NAS. */
        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)
    case CM_PH_CMD_GET_DRX_REQ:
    case CM_PH_CMD_SET_DRX_REQ:
      /* do nothing - CM has already send request to NAS. */
      break;
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #if defined(FEATURE_TDSCDMA)
    case CM_PH_CMD_SET_TL_IRAT_SEARCH_TIMER_REQ:
      /* do nothing - CM has already send request to NAS. */
      break;
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_MRU_UPDATE
    case CM_PH_CMD_MRU_UPDATE:
    cmph_cmd_sdprl_mru_update_proc(ph_cmd_ptr);
    break;

    case CM_PH_CMD_READ_MRU:
    cmph_cmd_sdprl_read_mru_proc(ph_cmd_ptr);
    break;
    #endif /* FEATURE_MRU_UPDATE */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case CM_PH_CMD_SET_HPLMN_TIMER:
    case CM_PH_CMD_GET_HPLMN_TIMER:
    case CM_PH_CMD_RPM_APP_RESET_REJECTED:
    case CM_PH_CMD_RESET_CLNUP_ST_MC:
    case CM_PH_CMD_SET_TRM_PRIORITY:
      break;

  case CM_PH_CMD_SET_WD_SWITCH:
    cmph_event(ph_ptr, CM_PH_EVENT_WD_STATE_CHANGED);
    break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case CM_PH_CMD_DATA_PRIORITY:


    cmph_event_per_subs(ph_ptr,CM_PH_EVENT_DATA_PRIORITY,
                          cmph_map_subs_to_ss(ph_cmd_ptr->info.cmd_subs));

    cmph_send_subs_info(ss, NULL);

    break;
	
	case CM_PH_CMD_SET_SRVCC_CAPABILITY:
	 
	break;

  #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  
  case CM_PH_CMD_DATA_ROAMING:
    break;

  case CM_PH_CMD_SET_ROAMING_PREF:
    break;
    
  #endif

  case CM_PH_CMD_INFORM_SECURE_CALL_CAPABILITY:
    break;

    default:
      CM_ERR_1( "Bad phone command %d", (uint8) ph_cmd_ptr->cmd);

  } /* switch */

  /* clear all pref_no_chg flag */
  cmph_clr_all_pref_nochg_flag();
  cmac_ph_cmd_proc(ph_cmd_ptr);

} /* cmph_client_cmd_mmll_reply() */
/*lint +esym(715, cmd_err) */


/*===========================================================================

FUNCTION cmph_get_last_pref_sent

DESCRIPTION
  Gets a pointer to the last pref sent to SD

DEPENDENCIES


RETURN VALUE
 Pointer to the last origination pref sent to SD

SIDE EFFECTS
  None.

===========================================================================*/
cm_act_orig_s_type* cmph_get_last_pref_sent(

      cm_ss_e_type    ss
        /* SS to get the previous orig preferences */

)
{
  static cm_act_orig_s_type    last_orig_pref_sent;
    /* Last MAIN origination parameters sent to SD
    */
  #if defined FEATURE_MMODE_DUAL_SIM || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
  static cm_act_orig_s_type    last_hybr_2_orig_pref_sent;
    /* Last HYBR2 origination parameters sent to SD
    */
  #endif


  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  static cm_act_orig_s_type    last_hybr_3_orig_pref_sent;
    /* Last HYBR3 origination parameters sent to SD
    */
  #endif

  switch(ss)
  {
    case CM_SS_MAIN:
      return &last_orig_pref_sent;

    case CM_SS_HYBR_2:
      #if defined FEATURE_MMODE_DUAL_SIM || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
      return &last_hybr_2_orig_pref_sent;
      #else
      return NULL;
    #endif

    case CM_SS_HYBR_3:
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      return &last_hybr_3_orig_pref_sent;
      #else
      return NULL;
      #endif

    default:
      return &last_orig_pref_sent;
  }

}


/*===========================================================================

FUNCTION cmph_is_new_policy_apply

DESCRIPTION
  Only apply the new policy if both stacks are idle.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
boolean                          cmph_is_new_policy_apply(

       cm_ss_e_type                     ss
)
{
  /* Invalid values for enforcing policy */
  if(ss == CM_SS_HYBR_1 || ss == CM_SS_NONE)
  {
    return FALSE;
  }

  if( (CMPH_SS_FEATURE_MODE(ss,cmph_ptr()) != SYS_SUBS_FEATURE_MODE_SGLTE) &&
      ss == CM_SS_MAX )
  {
    ss = CM_SS_MAIN;
  }

  if( ss == CM_SS_MAX )
  {
    /* Check both Main and Hybrid2 */
    cm_orig_q_s_type *ph_orig_top_ptr_main = cmtask_orig_para_get_top(
                                                                 CM_SS_MAIN );
    cm_orig_q_s_type *ph_orig_top_ptr_hybr = cmtask_orig_para_get_top(
                                                               CM_SS_HYBR_2 );

    if(ph_orig_top_ptr_main == NULL || ph_orig_top_ptr_hybr == NULL)
    {
      CM_ERR_0("Top ptr is NULL for MAIN or HYBR2 stack");
      return FALSE;
    }

    CM_MSG_HIGH_2( "cmph_is_new_policy_apply(): top act type MAIN %d HYBR_2 %d",
                 ph_orig_top_ptr_main->act_type,
                 ph_orig_top_ptr_hybr->act_type);

    if( ( ph_orig_top_ptr_main->act_type == CM_ACT_TYPE_POLICYMAN_RESTRICT ||
          ph_orig_top_ptr_main->act_type == CM_ACT_TYPE_PH_OBJ             ||
          ph_orig_top_ptr_main->act_type == CM_ACT_TYPE_DATA_CALL )
        &&
        ( ph_orig_top_ptr_hybr->act_type == CM_ACT_TYPE_POLICYMAN_RESTRICT ||
          ph_orig_top_ptr_hybr->act_type == CM_ACT_TYPE_PH_OBJ             ||
          ph_orig_top_ptr_hybr->act_type == CM_ACT_TYPE_DATA_CALL          ||
          ph_orig_top_ptr_hybr->act_type == CM_ACT_TYPE_AC_EMERG_MODE)
      )
    {
      return( cmpmprx_read_cm_policy_consumption_eligibility(SYS_MODEM_AS_ID_1)      &&
              cmpmprx_is_mask_set( SYS_MODEM_AS_ID_1, PM_CHG_ALL, NULL )  && /* Need to know which subs being used here */
              cmpmprx_is_ok_to_enforce_policy( NULL, SYS_MODEM_AS_ID_1));
    }
  }
  else /* ss == CM_SS_MAIN || ss == CM_SS_HYBR_2*/
  {
    cm_orig_q_s_type *ph_orig_top_ptr = cmtask_orig_para_get_top( ss );

    if((ph_orig_top_ptr != NULL) && ( ph_orig_top_ptr->act_type == CM_ACT_TYPE_POLICYMAN_RESTRICT ||
        ph_orig_top_ptr->act_type == CM_ACT_TYPE_PH_OBJ             ||
        ph_orig_top_ptr->act_type == CM_ACT_TYPE_DATA_CALL ))
    {
      sys_modem_as_id_e_type asubs_id = cmph_map_cm_ss_to_subs(ss);
      return( cmpmprx_read_cm_policy_consumption_eligibility(asubs_id)  &&
              cmpmprx_is_mask_set( asubs_id,PM_CHG_ALL, NULL ) &&
              cmpmprx_is_ok_to_enforce_policy( NULL, asubs_id ) );
    }
  }
  CM_MSG_HIGH_1( "No MATCH - ss: %d", ss);
  return FALSE;
}

#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))

/**--------------------------------------------------------------------------
** Functions - internal, cdma
** --------------------------------------------------------------------------
*/


/*===========================================================================

FUNCTION cmph_map_voice_answer_cm2db

DESCRIPTION
  Translates CM enum to DB enum for mode preference

DEPENDENCIES
  none

RETURN VALUE
  DB enum

SIDE EFFECTS
  none

===========================================================================*/
static db_voice_as_data_type cmph_map_voice_answer_cm2db
(
  cm_answer_voice_e_type cm_voice
)
{
  db_voice_as_data_type db_voice;

  if ( cm_voice == CM_ANSWER_VOICE_AS_VOICE )
  {
    db_voice = DB_VOICE_AS_DATA_NEVER;
  }
  else if ( cm_voice == CM_ANSWER_VOICE_AS_FAX_ONCE )
  {
    db_voice = DB_VOICE_AS_FAX_ONCE;
  }
  else if ( cm_voice == CM_ANSWER_VOICE_AS_FAX_ALWAYS )
  {
    db_voice = DB_VOICE_AS_FAX_ALWAYS;
  }
  else if ( cm_voice == CM_ANSWER_VOICE_AS_MODEM_ONCE )
  {
    db_voice = DB_VOICE_AS_MODEM_ONCE;
  }
  else if ( cm_voice == CM_ANSWER_VOICE_AS_MODEM_ALWAYS )
  {
    db_voice = DB_VOICE_AS_MODEM_ALWAYS;
  }
  else
  {
    db_voice = ( db_voice_as_data_type ) cm_voice;
  }

  return( db_voice );

} /* cmph_map_voice_answer_cm2db() */



/*===========================================================================

FUNCTION REMOVE_AMPS_FROM_CM_MODE_PREF

DESCRIPTION
  This function remove the AMPS component from the CM mode preference
  setting

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  SD mode preference

SIDE EFFECTS
  none

===========================================================================*/
static cm_mode_pref_e_type remove_amps_from_cm_mode_pref(

  cm_mode_pref_e_type cm_mode_pref
   /* mode preference */
)
{

  switch( cm_mode_pref)
  {
    case CM_MODE_PREF_AMPS_ONLY:
    case CM_MODE_PREF_CDMA_AMPS_ONLY:

      return CM_MODE_PREF_CDMA_ONLY;

    default:
      return cm_mode_pref;
  }


} /* remove_amps_from_cm_mode_pref() */

#ifdef FEATURE_HDR_HYBRID




/*===========================================================================

FUNCTION send_hdrmc_idle_pgslot_changed

DESCRIPTION
  This function sends a CDMA idle pgslot changed command to HDRMC

DEPENDENCIES
  The HDRMC tasks must have been started up already.

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/

static void  send_hdrmc_idle_pgslot_changed(void)
{
  hdrcp_msg_req_u      *hdrcp_req;

  hdrcp_req = (hdrcp_msg_req_u*) cm_mem_malloc(sizeof(hdrcp_msg_req_u));

  CM_MSG_HIGH_0("CM->MSGR: send HDR_CP_IDLE_PGSLOT_CHANGED_REQ");
  (void) cm_msgr_send( HDR_CP_IDLE_PGSLOT_CHANGED_REQ, MSGR_MM_CM,
                       (msgr_hdr_struct_type*)hdrcp_req, sizeof(hdrcp_msg_req_u) );

  cm_mem_free(hdrcp_req);

} /* send_hdrmc_idle_pgslot_changed() */
#endif /* FEATURE_HDR_HYBRID */


/*===========================================================================

FUNCTION cmph_cmd_packet_state_para_check

DESCRIPTION
  Check parameter errors for packet state setting command

DEPENDENCIES
  None

RETURN VALUE
  CM_PH_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_call_cmd_err_e_type.

SIDE EFFECTS
  None
===========================================================================*/
static cm_ph_cmd_err_e_type   cmph_cmd_packet_state_para_check(

       cm_ph_cmd_s_type       *ph_cmd_ptr

)
{
  cm_ph_cmd_info_s_type          *cmd_info_ptr = NULL;
  cm_ph_cmd_err_e_type           cmd_err       = CM_PH_CMD_ERR_NOERR;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  if( !BETWEEN(cmd_info_ptr->packet_state,
               CM_PACKET_STATE_NONE, CM_PACKET_STATE_MAX) )
  {
    CM_ERR_0( "CM_CMD_ERR_PACKET_STATE_P");
    return CM_PH_CMD_ERR_PACKET_STATE_P;
  }


  return cmd_err;
} /* cmph_cmd_packet_state_para_check() */

#ifdef FEATURE_DDTM_CNTL

/*===========================================================================
FUNCTION cmph_misc_add_ddtm_act_mask

DESCRIPTION

  Add given DDTM act mask to given DDTM act mask.

  Example:

  The below will add all single mode pref components from
  CM_MODE_PREF_AUTOMATIC and end up with CM_MODE_PREF_NONE.

  ph_orig_ddtm_act = cmph_misc_add_ddtm_act_mask(
                                           SYS_DDTM_ACT_MASK_EMPTY,
                                           2,// because 2 components follow
                                           SYS_DDTM_ACT_MASK_SUPPRESS_MO_DBM,
                                           SYS_DDTM_ACT_MASK_SUPPRESS_REG,
                                           );

DEPENDENCIES
  sd_misc_add_mode_pref()

RETURN VALUE
  Return new preference or SYS_DDTM_ACT_MASK_MAX if any of the mapping
  functions failed.

SIDE EFFECTS
  None

===========================================================================*/
static sys_ddtm_act_mask_e_type cmph_misc_add_ddtm_act_mask( sys_ddtm_act_mask_e_type ddtm_act_mask,
                                                      int number_of_components_to_add,
                                                        ... )
{

  va_list arg_list;
  sys_ddtm_act_mask_e_type temp_mask = ddtm_act_mask;
  sys_ddtm_act_mask_e_type mask_to_add = SYS_DDTM_ACT_MASK_EMPTY;

  /*
  ** Initialize arg_list and make an internal pointer point
  ** at the first variable function argument.
  ** This will be the second parameter
  */
  /*lint -e{662} -e{64} -e{718} -e{746} -e{530} -e{516} */
  va_start(arg_list, number_of_components_to_add);

  /*
  ** Process second and subsequent function arguments.
  ** These are the DDTM act mask that are to be added to the current ddtm
  ** act mask
  */

  while(number_of_components_to_add--)
  {

    /* Point at next function argument */
    /*lint -e{10} -e{662} -e{78} -e{718} -e{746} -e{530} -e{826} -e{662} -e{124}*/
    mask_to_add = (sys_ddtm_act_mask_e_type)va_arg(arg_list, int);

    if( mask_to_add >= SYS_DDTM_ACT_MASK_MAX)
    {
      CM_ERR_1( "Bad ddtm_mask to add = %d",mask_to_add);
      CM_ASSERT(FALSE);
    }
    /*lint -e{655} bit-wise operation uses (compatible) enum's */
    temp_mask |= mask_to_add;
  }
   /* Clean up */
  va_end(arg_list);

  if( temp_mask >= SYS_DDTM_ACT_MASK_MAX )
  {
    CM_ERR_1( "Bad final ddtm_mask = %d",temp_mask);
    return SYS_DDTM_ACT_MASK_MAX;
  }

  return temp_mask;

} /* cmph_misc_add_ddtm_act_mask */

#endif /* FEATURE_DDTM_CNTL */

#endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */


#if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE) || defined(FEATURE_TDSCDMA)

/**--------------------------------------------------------------------------
** Functions - internal, gsm/wcdma
** --------------------------------------------------------------------------
*/

#ifdef FEATURE_TC

/*===========================================================================

FUNCTION cmph_send_change_mode_rsp
DESCRIPTION
  This function sends a change mode response to Test Control.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_send_change_mode_rsp
(
  cmtc_change_test_mode_status_T       status
      /* the status being returned to Test Control */
)
{
  /*
  ** Allocate a Test Control command buffer
  */
  tc_cmd_type   *tc_ptr  = cm_tc_get_buf_else_err_fatal
                             ( CMTC_CHANGE_TEST_MODE_RSP );


  CM_ASSERT( tc_ptr != NULL );

  tc_ptr->cmd.cm_change_test_mode_rsp.status = status;

  /*
  ** Send the response to Test Control.
  */
  cm_tc_send_cmd( tc_ptr );

} /* cmphs_send_change_mode_rsp */
#endif /* FEATURE_TC */


/*===========================================================================

FUNCTION cmph_process_network_list_cnf

DESCRIPTION
  This function processes a network list confirmation event reported
  by the lower software layer.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_process_network_list_cnf
(
  const cm_rpt_type             *cm_rpt_ptr
    /* Pointer to lower level report data */
)
{
  /* Pointer to phone object.
  */
  cmph_s_type                *ph_ptr = cmph_ptr();
  const cm_si_network_list_cnf_s_type   *net_list_cnf_ptr = NULL;

  cm_ss_e_type               ss;
  sys_modem_as_id_e_type   asubs_id;
  cmmsc_state_machine_s_type *state_machine = NULL;
  cm_orig_q_s_type        *ph_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_2 );
  cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(cm_rpt_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  net_list_cnf_ptr = &cm_rpt_ptr->cmd.si_net_list_cnf;

  /* networks_type was added to delay ps call when there
  ** is a get net request pending. This flag need not be checked before
  ** sending NETWORKS_CONF event to clients. Any time SD sends a net list
  ** cnf, CM sends the corresp client event out.
  **
  ** In cases where SD gives back an acq action and posts a net list cnf,
  ** net list cnf would not get posted to CM clients because acq action
  ** will clear network_type flag, that's why removing network_type check.
  */
  if (cmph_is_msim())
  {
    asubs_id = cm_rpt_ptr->asubs_id;
    ss = cmph_map_subs_to_ss(cm_rpt_ptr->asubs_id);
  }
  else
  {
    asubs_id = SYS_MODEM_AS_ID_1;
    ss = CM_SS_MAIN;
  }

  if( cmph_is_get_networks_ongoing(asubs_id) == TRUE )
  {
    state_machine = cmmsimc_get_msc_ptr_per_cm_ss(ss);
  }
  	
  /*Verify MAIN stack been suspended and resume on list cnf */
  #ifdef FEATURE_MMODE_SC_SVLTE
  if (cmph_is_subs_feature_mode_1x_sxlte(asubs_id) && ph_ptr->ss_susp_info[CM_SS_MAIN].is_suspend == TRUE)
  {
    mmoc_cmd_suspend_ss(SD_SS_MAIN, FALSE, FALSE);
  }
  #endif

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(cmph_map_subs_to_ss(asubs_id) == CM_SS_HYBR_3)
  {
    if(ph_ptr->network_list_type == CM_NETWORK_LIST_PCI_SCAN )
    {
      ph_ptr->hybr_3_stack_info.plmn_list.pci_plmn_list = net_list_cnf_ptr->found_plmn_list.pci_plmn_list;
    }
    else
    {
      ph_ptr->hybr_3_stack_info.plmn_list.plmn_list = net_list_cnf_ptr->found_plmn_list.plmn_list;
    }
  }
  else
  #endif
  if(cmph_map_subs_to_ss(asubs_id) == CM_SS_HYBR_2)
  {
    if(ph_ptr->network_list_type == CM_NETWORK_LIST_PCI_SCAN )
    {
      ph_ptr->hybr_2_stack_info.plmn_list.pci_plmn_list = net_list_cnf_ptr->found_plmn_list.pci_plmn_list;
    }
    else
    {
      ph_ptr->hybr_2_stack_info.plmn_list.plmn_list = net_list_cnf_ptr->found_plmn_list.plmn_list;
    }
  }
  else
  {
    if(ph_ptr->network_list_type == CM_NETWORK_LIST_PCI_SCAN )
    {
      ph_ptr->main_stack_info.plmn_list.pci_plmn_list = net_list_cnf_ptr->found_plmn_list.pci_plmn_list;
    }
    else
    {
      ph_ptr->main_stack_info.plmn_list.plmn_list = net_list_cnf_ptr->found_plmn_list.plmn_list;
    }
  }
  /* Check if get net status is partial , dnt update the ss_for_get_networks to None */
  if (net_list_cnf_ptr->status != SYS_PLMN_LIST_PARTIAL)
  {
    ph_ptr->ss_for_get_networks   = CM_SS_NONE;
  }

  /* Gives the status of plmn list req (Success/Abort) */

  CM_MSG_HIGH_3("Before::ph_ptr->main_stack_info.net_type=%d,hybr2_net_type=%d, net_list_cnf_ptr->status=%d",\
                       ph_ptr->main_stack_info.pref_info.network_type,\
                       ph_ptr->hybr_2_stack_info.pref_info.network_type,
                       net_list_cnf_ptr->status);

  #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
  CM_MSG_HIGH_1("hybr3_net_type=%d",ph_ptr->hybr_3_stack_info.pref_info.network_type );
  #endif
  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if(cmph_is_dsda() && asubs_id == SYS_MODEM_AS_ID_2)
  {
    #if defined(FEATURE_MMODE_SXLTE_G)
    if (cmph_is_sxlte())
    {
      ph_ptr->hybr3_available_networks_list_cnf = net_list_cnf_ptr->status;
      if (net_list_cnf_ptr->status != SYS_PLMN_LIST_PARTIAL) /* TBDone :  is it required in sxlte */
      {
      ph_ptr->hybr_3_stack_info.pref_info.network_type            = CM_MODE_PREF_NONE;
    }
    }
    else
    #endif
    {
      ph_ptr->hybr2_available_networks_list_cnf = net_list_cnf_ptr->status;
      if (net_list_cnf_ptr->status != SYS_PLMN_LIST_PARTIAL) /* TBDone :  is it required in DSDA */
      {
      ph_ptr->hybr_2_stack_info.pref_info.network_type            = CM_MODE_PREF_NONE;
    }
  }
  }
  else
  #endif
  {
    ph_ptr->available_networks_list_cnf = net_list_cnf_ptr->status;

    /* Check if get net status is partial , dnt update the network type to None */
    if (net_list_cnf_ptr->status != SYS_PLMN_LIST_PARTIAL)
    {
    ph_ptr->main_stack_info.pref_info.network_type          = CM_MODE_PREF_NONE;
  }
  }

    CM_MSG_HIGH_2("After::ph_ptr->main_stack_info.net_type=%d,hybr2_net_type=%d",\
                       ph_ptr->main_stack_info.pref_info.network_type,\
                       ph_ptr->hybr_2_stack_info.pref_info.network_type);
  
  #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
  CM_MSG_HIGH_1("hybr3_net_type=%d",ph_ptr->hybr_3_stack_info.pref_info.network_type );
  #endif

  cmph_set_net_lists_present_flag(TRUE);

  CM_MSG_HIGH_2( "network_list_type=%d,hybrid2_network_list_type=%d",
                 (int)ph_ptr->network_list_type,
                 ph_ptr->hybrid2_network_list_type );

  cmph_event_per_subs(ph_ptr, CM_PH_EVENT_AVAILABLE_NETWORKS_CONF, ss);

  ph_ptr->network_list_type = CM_NETWORK_LIST_NONE;
  ph_ptr->hybrid2_network_list_type = CM_NETWORK_LIST_NONE;
  cmph_set_net_lists_present_flag(FALSE);

  /* if  STACK_SYNC_UP_BSR is pending due to this network search list
        force pref on HYBR_2 with STACK_SYNC_UP_BSR */
  if( net_list_cnf_ptr->status != SYS_PLMN_LIST_PARTIAL &&
  	state_machine != NULL &&
  	cmmsc_auto_is_stack_sync_bsr_pending(state_machine) )
  {

    CM_MSG_HIGH_0("Restoring STACK_SYNC_UP_BSR after net_list_cnf");
	
    if( ph_orig_top_ptr == NULL )
    {
      CM_MSG_HIGH_1("stack_sync_up_bsr not forced top_ptr=%d",ph_orig_top_ptr);
      return;
    }

    cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue (
 				                 CM_SS_HYBR_2,
 				                 SD_SS_PREF_REAS_STACK_SYNC_UP_BSR,
       SD_SS_ORIG_MODE_NONE,
       FALSE,
       ph_orig_top_ptr,
       CM_ACT_UPDATE_REAS_NONE,
       &cmd
								);
	
    cmmsimc_proc_cmd_pref_sys_chgd(&cmd);

    cmmsc_auto_update_is_stack_sync_bsr_pending(state_machine, FALSE);
    cmmsc_auto_update_is_kick_hybr2_pending(state_machine, FALSE);
    *cmph_get_is_kicked_hybr_2_ptr()               = TRUE;

  }
} /* cmph_process_network_list_cnf() */

/*===========================================================================

FUNCTION cmph_process_get_drx_cnf

DESCRIPTION
  This function processes a get drx confirmation event reported
  by the lower software layer.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_process_get_drx_cnf
(
  const cm_rpt_type             *cm_rpt_ptr
    /* Pointer to lower level report data */
)
{
  /* Pointer to phone object.
  */
  cmph_s_type                *ph_ptr = cmph_ptr();
  cm_ss_e_type                ss = CM_SS_NONE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(cm_rpt_ptr != NULL);

  CM_MSG_MED_2("get_drx_cnf drx=%d, as_id=%d",
             (int)cm_rpt_ptr->cmd.get_drx_cnf.drx_coefficient,
             cm_rpt_ptr->cmd.get_drx_cnf.as_id);

  ph_ptr->drx_coefficient    = cm_rpt_ptr->cmd.get_drx_cnf.drx_coefficient;

  ss = cmph_map_subs_to_ss(cm_rpt_ptr->cmd.get_drx_cnf.as_id);

  cmph_event_per_subs(ph_ptr, CM_PH_EVENT_GET_DRX_CNF, ss);

} /* cmph_process_get_drx_cnf() */


/*===========================================================================

FUNCTION cmph_process_set_drx_cnf

DESCRIPTION
  This function processes a set drx confirmation event reported
  by the lower software layer.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_process_set_drx_cnf
(
  const cm_rpt_type             *cm_rpt_ptr
    /* Pointer to lower level report data */
)
{
  /* Pointer to phone object.
  */
  cmph_s_type                *ph_ptr = cmph_ptr();
  cm_ss_e_type                ss = CM_SS_NONE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(cm_rpt_ptr != NULL);

  CM_MSG_MED_2("set_drx_result=%d, as_id=%d",
             (int)cm_rpt_ptr->cmd.set_drx_cnf.result,
             cm_rpt_ptr->cmd.set_drx_cnf.as_id);

  ph_ptr->set_drx_result    = cm_rpt_ptr->cmd.set_drx_cnf.result;

  ss = cmph_map_subs_to_ss(cm_rpt_ptr->cmd.set_drx_cnf.as_id);

  cmph_event_per_subs(ph_ptr, CM_PH_EVENT_SET_DRX_CNF, ss);

} /* cmph_process_set_drx_cnf() */
/*===========================================================================

FUNCTION cmph_process_get_hplmn_timer_cnf

DESCRIPTION
  This function processes a get hplmn timer reported
  by the lower software layer.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_process_get_hplmn_timer_cnf
(
  const cm_rpt_type             *cm_rpt_ptr
    /* Pointer to lower level report data */
)
{
  /* Pointer to phone object.
  */
  cmph_s_type                *ph_ptr = cmph_ptr();
  cm_ss_e_type                ss = CM_SS_NONE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(cm_rpt_ptr != NULL);

  CM_MSG_HIGH_2("get_hplmn_timer=%d as_id=%d",
             (int)cm_rpt_ptr->cmd.get_hplmn_timer_cnf.timer_value,
             cm_rpt_ptr->cmd.get_hplmn_timer_cnf.as_id);

  ph_ptr->hplmn_timer = cm_rpt_ptr->cmd.get_hplmn_timer_cnf.timer_value;

  ss = cmph_map_subs_to_ss(cm_rpt_ptr->cmd.get_hplmn_timer_cnf.as_id);

  cmph_event_per_subs(ph_ptr, CM_PH_EVENT_GET_HPLMN_TIMER, ss);

} /* cmph_process_get_hplmn_timer_cnf() */

/*===========================================================================

FUNCTION cmph_process_ps_attach_failed_ind

DESCRIPTION
  This function processes attach failure indication from lower layers.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_process_ps_attach_failed_ind
(
  const cm_ps_attach_failed_ind_s_type  *ps_attach_failed_ind_ptr
)
{
  cmph_s_type      *ph_ptr         = cmph_ptr();
  cm_ss_e_type      ss;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ps_attach_failed_ind_ptr != NULL);
  CM_ASSERT(ph_ptr                != NULL);

  ss = cmph_map_subs_to_ss(ps_attach_failed_ind_ptr->as_id);

  cmph_event_per_subs(ph_ptr, CM_PH_EVENT_PS_ATTACH_FAILED, ss );
  cmph_deactivate_ps_service_req_timer(ss);

} /* cmph_process_ps_attach_failed_ind */


/*===========================================================================

FUNCTION cmph_service_transfer

DESCRIPTION
  This function transfer calls from source stack to target stack.

  IRAT/SPLIT/MERGE: As per NAS requirement for SGLTE, when there's service
  ** transfer happens from one stack to another, for example: HYBR-2 --> MAIN
  ** or vice versa, CM has to copy the Hybr-2 database to main.
  **
  ** It's particularly tricky in CM because SD also needs to be in synch.
  ** Hence, NAS will be sending STAT_IND (which is mapped to Service_Ind
  ** to synch up CM/SD for most of the data. However, copy is required for data
  ** which cannot be broadcast through STAT_IND.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_service_transfer
(
  cm_ss_e_type      source_ss,
  cm_ss_e_type      target_ss
)
{

  cmss_s_type *cmss = cmss_ptr();
  boolean     is_act_merge = FALSE;

  sys_modem_as_id_e_type  subId          = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;

  uint8                   stk_id_main   = cmss_map_ss_to_stack_info(CM_SS_MAIN);
  uint8                   stk_id_hybr2 = cmss_map_ss_to_stack_info(CM_SS_HYBR_2);
  
  if (!cmph_is_as_id_valid(subId))
  {
    CM_MSG_HIGH_0("cmph_service_transfer subs id is not valid");
    return ;
  }

  
  /* Copying from Hybr-2 to MAIN (in case MERGE) for SGLTE. Note that these are
  ** the data which we analyzed that are required to be copied. Not all the data
  ** are required to be copied during iRAT.
  */
  if(source_ss == CM_SS_HYBR_2 && target_ss == CM_SS_MAIN)
  {
    CM_MSG_HIGH_0("SGLTE: Service transfer HYBR-2 --> MAIN");

    is_act_merge = TRUE;

    /* Copy in cmss_s_type */
    cmss->bit_err_rate = cmss->hybr_gw_bit_err_rate;
    cmss->gw_rssi = cmss->hybr_gw_rssi;
    cmss->gw_ecio = cmss->hybr_gw_ecio;
    cmss->gw_pathloss = cmss->hybr_gw_pathloss;
    cmss->gw_sir = cmss->hybr_gw_sir;
    cmss->gw_rscp = cmss->hybr_gw_rscp;
    cmss->gw_ecio_for_display = cmss->hybr_gw_ecio_for_display;
    cmss->gw_cell_info = cmss->hybr_gw_cell_info;

    /* Copy in cmss_s_type->info */
    cmss->info.rssi = cmss->info.gw_rssi;
    cmss->info.io = cmss->info.gw_io;
    cmss->info.sinr = cmss->info.gw_sinr;
    cmss->info.pathloss = cmss->info.gw_pathloss;
    cmss->info.sir = cmss->info.gw_sir;
    cmss->info.rssi2 = cmss->info.gw_rssi2;
    cmss->info.rscp = cmss->info.gw_rscp;
    cmss->info.ecio_for_display = cmss->info.gw_ecio_for_display;
    cmss->info.cell_info = cmss->info.gw_cell_info;

    cmss->info.mode_info = cmss->info.gw_mode_info;
    cmss->info.cell_srv_ind = cmss->info.gw_cell_srv_ind;
    cmss->info.cipher_domain = cmss->info.gw_cipher_domain;
    cmss->info.emerg_num_list = cmss->info.gw_emerg_num_list;
    cmss->info.cell_bc_info = cmss->info.gw_cell_bc_info;

    /* Copy in cmss_s_type->new_info */
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].rssi             = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].rssi;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].io               = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].io;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].sinr             = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].sinr;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].pathloss         = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].pathloss;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].sir              = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].sir;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].rssi2            = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].rssi2;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].rscp             = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].rscp;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].ecio_for_display = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].ecio_for_display;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].cell_info        = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].cell_info;

    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].mode_info      = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].mode_info;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].cell_srv_ind   = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].cell_srv_ind;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].cipher_domain  = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].cipher_domain;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].emerg_num_list = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].emerg_num_list;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_main].cell_bc_info   = cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].cell_bc_info;

    /* Print debugging information after copy */
    CM_MSG_HIGH_2("SGLTE: after-copy: DTM=%d, GW_DTM=%d", cmss->info.cell_srv_ind.dtm_supp,
                cmss->info.gw_cell_srv_ind.dtm_supp);

  }
  else if(source_ss == CM_SS_MAIN && target_ss == CM_SS_HYBR_2)
  {
    CM_MSG_HIGH_0("SGLTE: Service transfer MAIN --> HYBR-2");

    /* Copy in cmss_s_type */
    /* Copy in cmss_s_type */
    cmss->hybr_gw_bit_err_rate = cmss->bit_err_rate;
    cmss->hybr_gw_rssi = cmss->gw_rssi;
    cmss->hybr_gw_ecio = cmss->gw_ecio;
    cmss->hybr_gw_pathloss = cmss->gw_pathloss;
    cmss->hybr_gw_sir = cmss->gw_sir;
    cmss->hybr_gw_rscp = cmss->gw_rscp;
    cmss->hybr_gw_ecio_for_display = cmss->gw_ecio_for_display;
    cmss->hybr_gw_cell_info = cmss->gw_cell_info;

    /* Copy in cmss_s_type->info */
    cmss->info.gw_rssi = cmss->info.rssi;
    cmss->info.gw_io = cmss->info.io;
    cmss->info.gw_sinr = cmss->info.sinr;
    cmss->info.gw_pathloss = cmss->info.pathloss;
    cmss->info.gw_sir = cmss->info.sir;
    cmss->info.gw_rssi2 = cmss->info.rssi2 ;
    cmss->info.gw_rscp = cmss->info.rscp;
    cmss->info.gw_ecio_for_display = cmss->info.ecio_for_display;
    cmss->info.gw_cell_info = cmss->info.cell_info;

    cmss->info.gw_mode_info = cmss->info.mode_info;
    cmss->info.gw_cell_srv_ind = cmss->info.cell_srv_ind;
    cmss->info.gw_cipher_domain = cmss->info.cipher_domain;
    cmss->info.gw_emerg_num_list = cmss->info.emerg_num_list;
    cmss->info.gw_cell_bc_info = cmss->info.cell_bc_info;

    /* Copy in cmss_s_type->new_info */
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].rssi             = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].rssi;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].io               = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].io;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].sinr             = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].sinr;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].pathloss         = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].pathloss;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].sir              = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].sir;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].rssi2            = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].rssi2;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].rscp             = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].rscp;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].ecio_for_display = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].ecio_for_display;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].cell_info        = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].cell_info;

    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].mode_info      = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].mode_info;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].cell_srv_ind   = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].cell_srv_ind;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].cipher_domain  = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].cipher_domain;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].emerg_num_list = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].emerg_num_list;
    cmss->new_srv_avl_info[subId].stack_info[stk_id_hybr2].cell_bc_info   = cmss->new_srv_avl_info[subId].stack_info[stk_id_main].cell_bc_info;

    /* Print debugging information after copy */
    CM_MSG_HIGH_2("SGLTE: after-copy: DTM=%d, GW_DTM=%d", cmss->info.cell_srv_ind.dtm_supp,
                cmss->info.gw_cell_srv_ind.dtm_supp);
  }

  /* Right now, we only interested in transfer the CS calls */
  cmcall_transfer_cs_calls(source_ss, target_ss, is_act_merge);
}

/*===========================================================================

FUNCTION cmph_process_stack_deact_ind

DESCRIPTION
  This function processes stack deactivation indication from NAS.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_process_stack_deact_ind
(
  const cm_rpt_type             *cm_rpt_ptr
    /* Pointer to lower level report data */
)
{

  cm_ss_e_type                ss;
  cmmsc_state_machine_op_mode_e_type cmmsc_op_mode =
                        cmmsimc_state_machine_ptr(cm_rpt_ptr->cmd.stack_deact_ind.as_id)->op_mode;
  cmph_s_type                 *ph_ptr        = cmph_ptr();
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(cm_rpt_ptr != NULL);


  #ifdef FEATURE_CM_DEBUG_BUFFER
  cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_STACK_DEACT_IND, ((void*)&(cm_rpt_ptr->cmd.stack_deact_ind)));
  #endif

  if (ph_ptr->is_oprt_mode_change_ongoing == TRUE)
  {
    CM_MSG_HIGH_0("SC_SGLTE: Discarding CM_STACK_DEACT_IND");
    return;
  }


  //SGLTE+G NEED CHANGE
  //use the as_id to determine which sub has SGLTE. Then forward the command
  //to that particular sub with the particular ss (that were get deactivated)
  ss = cmph_map_subs_stack_to_ss(cm_rpt_ptr->cmd.stack_deact_ind.as_id,
                                  cm_rpt_ptr->cmd.stack_deact_ind.stack_id);

  /*stack de-act ind expected only in dual stack sglte mode
    if comes while UE is moving to csfb and ps-xfer happening, ignore */
  if(!(cmmsc_op_mode == CMMSC_OP_MODE_SGLTE_DUAL_STACK))
  {
    CM_MSG_HIGH_1("SC_SGLTE: DEACT_IND not expected in %d mode.donot proc",cmmsc_op_mode);
    return;
  }

  /* cmph should process the service transfer from HYBR-2 (ss) to MAIN.
  ** This would copy the service from HYBR-2 to MAIN
  */
  cmph_service_transfer(ss, CM_SS_MAIN);

  /* Reset CMREGPRX Service Req Header
  */
  cmregprx_reset_last_service_req_buffer( SD_SS_HYBR_2 );

  /* Now process the stack-deactivation indication
  ** This would including forcing the stacks with new call objs, orig_mode, if any
  */
  cmmsc_proc_stack_deact_ind(ss);

}

/*===========================================================================

FUNCTION cmph_process_stack_act_ind

DESCRIPTION
  This function processes stack deactivation indication from NAS.


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_process_stack_act_ind
(
  const cm_rpt_type             *cm_rpt_ptr
    /* Pointer to lower level report data */
)
{

  cmph_s_type                 *ph_ptr        = cmph_ptr();
  cm_ss_e_type                ss = CM_SS_MAX;
  //SGLTE NEED CHANGE (with correct as_id)
  cmmsc_state_machine_op_mode_e_type cmmsc_op_mode =
                       cmmsimc_state_machine_ptr(cm_rpt_ptr->cmd.stack_act_ind.as_id)->op_mode;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(cm_rpt_ptr != NULL);

  #ifdef FEATURE_CM_DEBUG_BUFFER
  cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_STACK_ACT_IND, ((void*)&(cm_rpt_ptr->cmd.stack_act_ind)));
  #endif

  
  if (ph_ptr->is_oprt_mode_change_ongoing == TRUE)
  {
    CM_MSG_HIGH_0("SC_SGLTE: Discarding CM_STACK_ACT_IND");
    return;
  }

  if (cm_rpt_ptr == NULL)
  {
    CM_ERR_0("SC_SGLTE: cm_rpt_ptr null ptr");
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /*stack act ind expected only in single stack sglte mode
    if comes while UE is moving to csfb and IRAT happening, ignore */
  if(!(cmmsc_op_mode == CMMSC_OP_MODE_SGLTE_SINGLE_STACK))
  {
    CM_MSG_HIGH_1("SC_SGLTE: ACT_IND not expected in %d mode do not proc",cmmsc_op_mode);
    return;
  }

  ss = cmph_map_subs_stack_to_ss(cm_rpt_ptr->cmd.stack_act_ind.as_id,
                                  cm_rpt_ptr->cmd.stack_act_ind.stack_id);

  /* Perform service transfer */
  cmph_service_transfer(CM_SS_MAIN, CM_SS_HYBR_2);

  /* Now process the stack-activation indication */
  cmmsc_proc_stack_act_ind(ss);
}

#endif /* defined CM_GW_SUPPORTED ||defined(FEATURE_CM_LTE) || defined(FEATURE_TDSCDMA)*/

#ifdef CM_GW_SUPPORTED

#ifdef FEATURE_TC

/*===========================================================================

FUNCTION cmph_process_change_test_mode_ind

DESCRIPTION
  This function processes a change test mode indication message
  originating from the Test Control.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_process_change_test_mode_ind
(
  const cm_change_test_mode_ind_T  *change_test_mode_ind_ptr
)
{
  sys_oprt_mode_e_type               new_oprt_mode;
  cmtc_change_test_mode_status_T     status         = CMTC_REJECT;
  cmph_s_type                       *ph_ptr         = cmph_ptr();

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(change_test_mode_ind_ptr != NULL);
  CM_ASSERT(ph_ptr                   != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /*
  ** Translate the test mode to an operating mode.
  */

  switch ( change_test_mode_ind_ptr->mode_type )
  {
    case CMTC_UE_LB_MODE1:
      ph_ptr->test_control_type = CM_TEST_CONTROL_TYPE_LB_MODE1;
      /* No need to change operting mode but need to update oprt mode type
      ** TC uses mode_type to carry information of oprt mode and type.
      */
      new_oprt_mode = ph_ptr->oprt_mode;

      /* let client know what type of oprt mode is */
      cmph_event( ph_ptr, CM_PH_EVENT_TEST_CONTROL_TYPE );
      break;

    case CMTC_UE_LB_MODE2:
      ph_ptr->test_control_type = CM_TEST_CONTROL_TYPE_LB_MODE2;
      new_oprt_mode = ph_ptr->oprt_mode;
      cmph_event( ph_ptr, CM_PH_EVENT_TEST_CONTROL_TYPE );
      break;

    case CMTC_UE_LB_MODE1_WITH_DUMMY_SIGNALLING:
      ph_ptr->test_control_type = CM_TEST_CONTROL_TYPE_LB_MODE1_WITH_DUMMY_SIGNALLING;
      new_oprt_mode = ph_ptr->oprt_mode;
      cmph_event( ph_ptr, CM_PH_EVENT_TEST_CONTROL_TYPE );
      break;

    case CMTC_UE_LB_MODE2_WITH_DUMMY_SIGNALLING:
      ph_ptr->test_control_type = CM_TEST_CONTROL_TYPE_LB_MODE2_WITH_DUMMY_SIGNALLING;
      new_oprt_mode = ph_ptr->oprt_mode;
      cmph_event( ph_ptr, CM_PH_EVENT_TEST_CONTROL_TYPE );
      break;

   case CMTC_UE_NORMAL_MODE:
      ph_ptr->test_control_type = CM_TEST_CONTROL_TYPE_NO_TEST;
      new_oprt_mode = restore_oprt_mode;
      break;

    case CMTC_UE_TEST_SETUP_IN_PROGRESS:
      new_oprt_mode = SYS_OPRT_MODE_NET_TEST_GW;
      break;

    default:
      CM_ERR_1( "Received unknown mode type %d",
              change_test_mode_ind_ptr->mode_type);
      new_oprt_mode = SYS_OPRT_MODE_NONE;
      break;
  } /* switch ( change_test_mode_ind_ptr->mode_type ) */


  /*
  ** If there were no errors in translating the mode...
  */
  if ( new_oprt_mode != SYS_OPRT_MODE_NONE )
  {
    /*
    ** Determine if the operating mode has changed.
    */
    if ( new_oprt_mode != ph_ptr->oprt_mode )
    {
       /*
       ** Only able to change the operating mode if this is
       ** a valid operating mode switch.
       */
      if ( is_valid_oprt_mode_switch( ph_ptr->oprt_mode,
                                      new_oprt_mode) )
      {
        if ( new_oprt_mode == SYS_OPRT_MODE_NET_TEST_GW )
        {
          /*
          ** Test Control is making a request to initiate a test.
          **
          */
            restore_oprt_mode = ph_ptr->oprt_mode;
        }
        status            = CMTC_CONFIRM;

      } /* if ( is_valid_oprt_mode_switch ) */

      if ( status == CMTC_CONFIRM )
      {
        /*
        ** The operating mode is changing, inform the clients.
        */
        ph_ptr->oprt_mode = new_oprt_mode;
        cmph_event( ph_ptr, CM_PH_EVENT_OPRT_MODE );
      }
    } /* if ( new_oprt_mode != ph_ptr->oprt_mode ) */
    else
    {
      /*
      ** CM is already in the requested state.
      */
      status = CMTC_CONFIRM;
    }
  } /* if ( new_oprt_mode != SYS_OPRT_MODE_NONE ) */

  /*
  ** Always send a response to Test Control.
  */
  cmph_send_change_mode_rsp( status );
} /* cmph_process_change_test_mode_ind */
#endif /* FEATURE_TC */

/*===========================================================================

FUNCTION cmph_clear_ccbs_entries

DESCRIPTION

  Clears current list of ccbs indexes in phone object

DEPENDENCIES

  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE

  None

SIDE EFFECTS
  ccbs_indx_store

===========================================================================*/
void cmph_clear_ccbs_entries(void)
{
  int ccbs_count = 0;

  cmph_s_type                *ph_ptr  = cmph_ptr();
  /* Pointer to a phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Clear all the entries in ccbs indx store
  */
  for (ccbs_count = 0; ccbs_count < (int)ARR_SIZE(ph_ptr->ccbs_indx_store);
                                                 ++ccbs_count)
  {
    ph_ptr->ccbs_indx_store[ccbs_count].ccbs_index = CM_CCBS_INDX_INVALID;
  }

} /* cmph_clear_ccbs_entries */

#endif /* defined CM_GW_SUPPORTED */



/**--------------------------------------------------------------------------
** Functions - external, common
** --------------------------------------------------------------------------
*/


/*===========================================================================

FUNCTION cmph_ptr

DESCRIPTION
  Return a pointer to the one and only phone object.

  The phone object is responsible for:
  1. Processing clients' phone commands.
  2. Processing MC replies for clients' phone commands.
  3. Processing MC phone related notifications.
  4. Notifying the client list of phone events.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
cmph_s_type  *cmph_ptr( void )
{

  static cmph_s_type cmph_local;
    /* The one and only phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return &cmph_local;

} /* cmph_ptr() */

/*===========================================================================
FUNCTION cmph_dem_ptr

DESCRIPTION
  Return a pointer to the dem object


DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static cm_dem_s_type  *cmph_dem_ptr( void )
{

  static cm_dem_s_type cmdem_local;
  return &cmdem_local;

} /* cmph_dem_ptr() */

/*===========================================================================
FUNCTION cmph_volte_ptr

DESCRIPTION
  Return a pointer to the VOLTE functionality control object


DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
cm_volte_ctrl_s_type  *cmph_volte_ptr( void )
{

  static cm_volte_ctrl_s_type cmvolte_local;
  return &cmvolte_local;

} /* cmph_volte_ptr() */

/*===========================================================================

FUNCTION cmph_get_volte_sub_info_ptr

DESCRIPTION
  Helper function to get a pointer to cmph_volte_ptr->volte_sub_info[] for a given sub_id.
  Checks that sub_id is in range of cmph_volte_ptr->volte_sub_info[] array.

DEPENDENCIES
  none

RETURN VALUE
  volte_sub_info_s_type* config

SIDE EFFECTS
  none

===========================================================================*/
volte_sub_info_s_type* cmph_get_volte_sub_info_ptr(
  sys_modem_as_id_e_type sub_id
)
{
  cm_volte_ctrl_s_type *volte_ptr = cmph_volte_ptr();

  if(!(sub_id >= SYS_MODEM_AS_ID_1 && 
      sub_id < MAX_SIMS &&
      sub_id < SYS_MODEM_AS_ID_NO_CHANGE))
  {
    CM_MSG_HIGH_1("cmsds_get_volte_sub_info_ptr: invalid sub_id %d", sub_id);
    sub_id = SYS_MODEM_AS_ID_1;
  }

  return &(volte_ptr->volte_sub_info[sub_id]);
}

/*===========================================================================

FUNCTION cmph_dem_get_apps_pwr_status

DESCRIPTION
  Return the current apps power state

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

cm_apps_pwr_status_e_type cmph_dem_get_apps_pwr_status(void)
{
  return cmph_dem_ptr()->apps_pwr_status;
}

/*===========================================================================

FUNCTION cmdem_init

DESCRIPTION
  Initialize the dem object

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_dem_init( void )
{

  cm_dem_s_type *dem_ptr = cmph_dem_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( dem_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  dem_ptr->apps_pwr_status = CM_APPS_PWR_STATUS_PWR_RESTORE;

  return;


} /* cmdem_init() */

/*===========================================================================

FUNCTION cmph_volte_ctrl_init

DESCRIPTION
  Initialize the VOLTE feature control object

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_volte_ctrl_init(
  uint8             refresh_subs_mask
)
{

  cm_volte_ctrl_s_type *volte_ptr = cmph_volte_ptr();
  cm_ssac_hvolte_s_type ssac_hvolte_control;
  int32 read_size;
  uint8 i = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( volte_ptr != NULL );

  memset(volte_ptr,0,sizeof(cm_volte_ctrl_s_type));

  /*Read hvolte ssac config from NV */
  read_size = sizeof(cm_ssac_hvolte_s_type);
  for(i = 0; i < MIN(ARR_SIZE(volte_ptr->volte_sub_info), cmpm_ptr()->device_mode.nSims); i++)
  {
    if(refresh_subs_mask & BM(i))
    {
    if(cmefs_get(CMEFS_SSAC_HVOLTE,
                   (byte*)&ssac_hvolte_control,
                    read_size,
                   (sys_modem_as_id_e_type)i))
  {
      CM_MSG_HIGH_3("Sub %d read CMEFS_SSAC_HVOLTE, is_ssac_hvolte = %d, t_ssac=%d",
                      i,
                      ssac_hvolte_control.is_ssac_hvolte,
                      ssac_hvolte_control.t_ssac);

      volte_ptr->volte_sub_info[i].is_hvolte = ssac_hvolte_control.is_hvolte;
      volte_ptr->volte_sub_info[i].is_ssac_hvolte = ssac_hvolte_control.is_ssac_hvolte;
      volte_ptr->volte_sub_info[i].volte_ssac_sr_control = ssac_hvolte_control.volte_ssac_sr_control;
      volte_ptr->volte_sub_info[i].volte_acb_sr_control = ssac_hvolte_control.volte_acb_sr_control;
      volte_ptr->volte_sub_info[i].t_ssac = ssac_hvolte_control.t_ssac;
    /*Tssac is between 0-512 seconds, default 60s*/
      if(volte_ptr->volte_sub_info[i].t_ssac > 512)
    {
        volte_ptr->volte_sub_info[i].t_ssac = 60;
    }
  }
  else
  {
      CM_MSG_HIGH_1("Sub %d can't read CMEFS_SSAC_HVOLTE", i);
    }
  }
  }

  /*Read UE based call waiting config from EFS */
  read_size = sizeof(cm_ue_based_cw_s_type);
  for(i = 0; i < MIN(ARR_SIZE(volte_ptr->volte_sub_info), cmpm_ptr()->device_mode.nSims); i++)
  {
    if(refresh_subs_mask & BM(i))
  {
  if ( cmefs_get( CMEFS_UE_BASED_CW,
                    (byte*)&volte_ptr->volte_sub_info[i].ue_based_cw,
                   read_size,
                    (sys_modem_as_id_e_type)i) )
  {
      CM_MSG_HIGH_3 ("Sub %d read CMEFS_UE_BASED_CW = %d %d", i,
                       volte_ptr->volte_sub_info[i].ue_based_cw.is_enabled,
                       volte_ptr->volte_sub_info[i].ue_based_cw.use_ue_based_cw);
  }
   else
  {
      CM_MSG_HIGH_1("Sub %d can't read CMEFS_UE_BASED_CW", i);
      volte_ptr->volte_sub_info[i].ue_based_cw.is_enabled = FALSE;
      volte_ptr->volte_sub_info[i].ue_based_cw.use_ue_based_cw = FALSE;
    }
  }
  }

  return;
} /* cmph_volte_ctrl_init() */

#if(LTE_BAND_NUM == 256)
static void read_persistent_lte_extn_band_pref
(
  sys_lte_band_mask_e_type *band_pref,
  sys_modem_as_id_e_type asubs_id
)
{
  int32               size = sizeof(bit_mask_192_ext_s_type);
  sys_lte_band_mask_e_type default_band_pref = SYS_LTE_BAND_MASK_CONST_ANY;
  bit_mask_192_ext_s_type def_band_pref_65_256, efs_lte_band_pref_ext;
  boolean read_success = FALSE;

  def_band_pref_65_256.bits_65_128  = default_band_pref.bits_65_128;
  def_band_pref_65_256.bits_129_192 = default_band_pref.bits_129_192;
  def_band_pref_65_256.bits_193_256 = default_band_pref.bits_193_256;

  read_success = cmefs_get(CMEFS_ID_LTE_BANDPREF_65_256, (byte *)&efs_lte_band_pref_ext, size, asubs_id);

  band_pref->bits_65_128  = efs_lte_band_pref_ext.bits_65_128;
  band_pref->bits_129_192 = efs_lte_band_pref_ext.bits_129_192;
  band_pref->bits_193_256 = efs_lte_band_pref_ext.bits_193_256;

  /* If read failed (size <= 0 ) or band pref is invalid
  ** write a valid default band pref value to NV
  */
  if ( !SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&default_band_pref,band_pref)  ||
       !read_success )
  {
    *band_pref = default_band_pref;

    #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
    cmefs_fs_write(CMEFS_ID_LTE_BANDPREF_65_256,
                   (byte *) &def_band_pref_65_256,
                   sizeof(bit_mask_192_ext_s_type),
                   asubs_id);
    #endif
  }
  cm_print_lte_band_mask(*band_pref);
}
#endif

/*===========================================================================

FUNCTION cmph_trm_get_info

DESCRIPTION
  Get TRM cap whether it supports svlte/svdo/etc.

DEPENDENCIES
  none

RETURN VALUE
  trm_simul_cap_return_data 

SIDE EFFECTS
  none

===========================================================================*/
static trm_simul_cap_return_data cmph_trm_get_info( void )
{
  trm_get_info_input_type input;
  trm_get_info_return_type output;
  trm_simul_cap_return_data mode_info;
  
  input.client_id = TRM_CM;
  input.info_type = TRM_SIMUL_CAPABILITY;
  
  trm_get_info(&input, &output);
  mode_info = output.info.simul_cap_info;

  return mode_info;
}

/*===========================================================================
  This function enables MSIM ESR if:
  MSIM ESR isn't enabled & 1xSRLTE+G is the device type.
===========================================================================*/

static void cmph_init_config_msim_esr(void)
{
  boolean is_msim_esr_active = FALSE;
  boolean is_1xSRLTE_plus_g = FALSE;
  int32   efs_read_size = sizeof (uint8);
  cmph_s_type *ph_ptr = cmph_ptr();

  is_msim_esr_active = cmefs_read(CMEFS_MSIM_STANDBY_ESR_SUPPORT,
                      (byte*)&ph_ptr->is_msim_esr_enabled, &efs_read_size);
  is_1xSRLTE_plus_g = (cmph_is_feature_mode_msim() &&
                       cmph_is_subs_feature_mode_srlte(SYS_MODEM_AS_ID_1));

  if(!is_msim_esr_active && is_1xSRLTE_plus_g)
  {
    /* If NV/EFS isn't active & SRLTE, enable by default */
    ph_ptr->is_msim_esr_enabled = TRUE;
  }
}

/*===========================================================================

  This function determines hybr_pref based on:
   1. RF capability if SVLTE/SVDO is supported
   2. Dynamic switch state between SVLTE and CSFB
   3. 1xSRLTE UE-MODE

  Also make sure that hybr_pref for secondary subscription is NONE.

===========================================================================*/
static void cmph_init_config_hybr_pref( void )
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Give TRM capability preference over the Hybrid pref value set in NV
  */
  trm_simul_cap_return_data trm_cap = cmph_trm_get_info();
  
  sd_ss_hybr_pref_e_type new_hybr_pref = SD_SS_HYBR_PREF_NONE;
  sys_ue_mode_e_type   curr_ue_mode = SYS_UE_MODE_NONE;
  #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
  /* CMSOA state info. pointer */
  cmsoa_state_info_s_type           *cmsoa_state = cmsoa_state_info_ptr();
  #endif

  CM_MSG_HIGH_3("TRM cap: svlte %d svdo %d shdr %d",
      SYS_IS_BIT_CONTAIN(TRM_SVLTE_IS_ENABLED,trm_cap),
      SYS_IS_BIT_CONTAIN(TRM_SVDO_IS_ENABLED,trm_cap),
      SYS_IS_BIT_CONTAIN(TRM_SHDR_IS_ENABLED,trm_cap));
      
  #ifdef FEATURE_HDR_HYBRID
  cmnv_read_wait( NV_HYBRID_PREF_I, cmnv_item_ptr );
  #endif
  if(SYS_IS_BIT_CONTAIN(TRM_SVDO_IS_ENABLED,trm_cap))
  {
    ph_ptr->is_svdo_supported = TRUE;
  }

  /* Handle for SVLTE feature mode */
  if(SYS_IS_BIT_CONTAIN(TRM_SVLTE_IS_ENABLED,trm_cap) &&
     ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE)
  {
    ph_ptr->is_svlte_supported = TRUE;

    #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
    /* If SVLTE is supported and last SV-oprt state is SVLTE */
    if(cmsoa_state->config.is_switch_enabled)
    {
      if(cmsoa_state->curr_sv_oprt_mode == CMSOA_SV_OPRT_MODE_SVLTE)
      {
        new_hybr_pref = SD_SS_HYBR_PREF_CDMA__LTE__HDR;
      }
      /* If svlte_supported, however, the last SV-opr state is CSFB
      ** then we will default the current state as CSFB.
      */
      else
      {
        new_hybr_pref = SD_SS_HYBR_PREF_CDMA_HDR;
      }
    }
    else
    {
      new_hybr_pref = SD_SS_HYBR_PREF_CDMA__LTE__HDR;
    }
    #else
    new_hybr_pref = SD_SS_HYBR_PREF_CDMA__LTE__HDR;
    #endif
  }
  /* SVLTE is not supported & HYBR isn't disabled */
  else if((ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE ||
          ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_NORMAL) &&
          BETWEEN(cmnv_item_ptr->hybrid_pref, (byte)SD_SS_HYBR_PREF_NONE,
                                           (byte)SD_SS_HYBR_PREF_MAX))
  {
    new_hybr_pref = SD_SS_HYBR_PREF_CDMA_HDR;
  }

  /* Handle for SRLTE feature mode */
  else if(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] ==
                                                  SYS_SUBS_FEATURE_MODE_SRLTE)
  {
    cmpmprx_read_ue_mode(SYS_MODEM_AS_ID_1, &curr_ue_mode);
    ph_ptr->dbg_info.init_ue_mode = curr_ue_mode;
    if(curr_ue_mode == SYS_UE_MODE_1XSRLTE_ONLY
    #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
      || (cmsoa_state->is_pwrup_from_last_submode == TRUE &&
          cmsoa_state->curr_sv_oprt_mode == CMSOA_SV_OPRT_MODE_SVLTE)
    #endif
        )
    {
      #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
      CM_MSG_HIGH_1 ("is_pwrup_from_last_submode = %d", cmsoa_state->is_pwrup_from_last_submode);
      #endif
      new_hybr_pref = SD_SS_HYBR_PREF_CDMA__LTE__HDR;
    }
    else
    {
      new_hybr_pref = SD_SS_HYBR_PREF_CDMA_HDR;
    }
  }
  /* SGLTE, disable hybr pref */
  else if(cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) ||
          cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_2))
  {
    ph_ptr->is_svdo_supported = FALSE;
    new_hybr_pref = SD_SS_HYBR_PREF_NONE;
  }
  /* Handle for SVDO & non-SGLTE case */
  else if(ph_ptr->is_svdo_supported &&
          BETWEEN(cmnv_item_ptr->hybrid_pref, (byte)SD_SS_HYBR_PREF_NONE,
                                           (byte)SD_SS_HYBR_PREF_MAX))
  {
    new_hybr_pref = SD_SS_HYBR_PREF_CDMA_HDR;
  }
  else
  {
    new_hybr_pref = cmnv_item_ptr->hybrid_pref;
  }

  if(!BETWEEN(new_hybr_pref, (byte)SD_SS_HYBR_PREF_NONE,
                               (byte)SD_SS_HYBR_PREF_MAX))
  {
    new_hybr_pref = SD_SS_HYBR_PREF_NONE;
  }
  cmnv_item_ptr->hybrid_pref = new_hybr_pref;
  CM_MSG_HIGH_1("NV hybr pref set to %d", cmnv_item_ptr->hybrid_pref);

  #ifdef FEATURE_HDR_HYBRID
  cmnv_write_wait( NV_HYBRID_PREF_I, cmnv_item_ptr );
  #endif

  ph_ptr->main_stack_info.pref_info.hybr_pref =
  ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].hybr_pref =
                     cmph_map_sd_hybr_pref_to_cm_hybr_pref(new_hybr_pref);
  ph_ptr->int_hybr_pref = new_hybr_pref;
  ph_ptr->dbg_info.init_hybr_pref = new_hybr_pref;

  #ifdef FEATURE_FULL_TIME_SHDR
  #error code not present
#endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Force hybr pref to be off for subs other than sub1 */
  if (cmph_is_msim())
  {
    if(!cmph_is_sxlte())
    {
      ph_ptr->hybr_2_stack_info.pref_info.hybr_pref
        = ph_ptr->prst_hybr_2_stack_info[ph_ptr->curr_nam].hybr_pref
        = CM_HYBR_PREF_OFF;
    }

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    ph_ptr->hybr_3_stack_info.pref_info.hybr_pref
      = ph_ptr->prst_hybr_3_stack_info[ph_ptr->curr_nam].hybr_pref
      = CM_HYBR_PREF_OFF;
    #endif
  }
}

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================

FUNCTION cmph_hybr_3_gw_init

DESCRIPTION
  Initializing the phone object.

  This function must be called before the phone object
  is being used, in any way, place, or form.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_hybr_3_gw_init( void )
{
  #ifdef FEATURE_MMODE_DUAL_SIM
  cmph_s_type                           *ph_ptr  =  cmph_ptr();
      /* Point at phone object to be initialized */

  unsigned int                          i;
      /* loop counter */

  cm_user_net_sel_mode_pref_e_type  user_net_sel_mode_pref;

  int32                             efs_read_size;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    /* Read Hybr2 stack mode preference */
    cmnv_item_ptr->pref_mode.nam = (byte) i;
    cmnv_read_wait_extn( NV_PREF_MODE_I,
                         cmnv_item_ptr,
                         ph_ptr->hybr_3_stack_info.nv_context );
    ph_ptr->prst_hybr_3_stack_info[i].mode_pref = cmph_map_mode_pref_nv2cm( cmnv_item_ptr->pref_mode.mode );

    /* Remove the mode pref validation for sxlte.  PM will ensure to set the proper 
    ** max allowed capability for all multi-sim configurations.
    */
    if (!cmph_is_sxlte())
    {
    /* This is for GW only, not multimode
    */
    #if ( defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) )
    /*
    ** Single mode WCDMA or Single mode TDSCDMA.
    */
    if ( ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_WCDMA_ONLY )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_3_stack_info[i].mode_pref     = CM_MODE_PREF_WCDMA_ONLY;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_3_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I,
                               ph_ptr->hybr_3_stack_info.nv_context,
                               cmnv_item_ptr);
      #endif
    } /* if ! CM_MODE_PREF_WCDMA_ONLY */
    #elif ( defined(FEATURE_TDSCDMA) && !defined(FEATURE_GSM) )
    if ( ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_TDS_ONLY )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_3_stack_info[i].mode_pref     = CM_MODE_PREF_TDS_ONLY;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_3_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I,
                               ph_ptr->hybr_3_stack_info.nv_context,
                               cmnv_item_ptr);
      #endif
    } /* if ! CM_MODE_PREF_TDS_ONLY */
    #endif /* ( FEATURE_WCDMA && !FEATURE_GSM ) || ( FEATURE_TDSCDMA && !FEATURE_GSM ) */

    #if ( ( defined(FEATURE_GSM) && !defined(FEATURE_WCDMA) ) && ( defined(FEATURE_GSM) && !defined(FEATURE_TDSCDMA) ) )
    /*
    ** Single mode GSM.
    **/
    if ( ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_GSM_ONLY )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_3_stack_info[i].mode_pref     = CM_MODE_PREF_GSM_ONLY;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_3_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I, cmnv_item_ptr,
                           ph_ptr->hybr_3_stack_info.nv_context);
      #endif
    } /* if ! CM_MODE_PREF_GSM_ONLY */
    #endif /* FEATURE_GSM, FEATURE_WCDMA, FEATURE_TDSCDMA */

    #if ( defined(FEATURE_GSM) && defined(FEATURE_WCDMA) )
    /*
    ** Dual mode GSM/WCDMA.
    ** G, W, GW are the only allowed values.
    **/
    if ( ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_GSM_ONLY &&
         ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_WCDMA_ONLY &&
         ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_GSM_WCDMA_ONLY &&
   ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_TDS_GSM &&
         ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_TDS_ONLY
       )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_3_stack_info[i].mode_pref     = CM_MODE_PREF_GSM_WCDMA_ONLY;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_3_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I,
                           cmnv_item_ptr,
                           ph_ptr->hybr_3_stack_info.nv_context);
      #endif
    }
    #elif ( defined(FEATURE_GSM) && defined(FEATURE_TDSCDMA) )
    /*
    ** Dual mode GSM/TDSCDMA.
    ** G, T, GT are the only allowed values.
    **/
    if ( ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_GSM_ONLY &&
         ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_TDS_ONLY &&
         ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_TDS_GSM &&
         ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_GSM_WCDMA_ONLY &&
         ph_ptr->prst_hybr_3_stack_info[i].mode_pref != CM_MODE_PREF_WCDMA_ONLY
       )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_3_stack_info[i].mode_pref     = CM_MODE_PREF_TDS_GSM;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_3_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I,
                           cmnv_item_ptr,
                           ph_ptr->hybr_3_stack_info.nv_context);
      #endif
    }
    /*lint -restore */
    #endif /* FEATURE_GSM, FEATURE_WCDMA */
  }

  }

  ph_ptr->hybr_3_stack_info.pref_info.mode_pref = CMPH_PRST_HYBR_3_PREF(ph_ptr).mode_pref;
  ph_ptr->hybr_3_stack_info.pref_info.user_mode_pref = CMPH_PRST_HYBR_3_PREF(ph_ptr).mode_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ph_ptr->hybr_3_stack_info.pref_info.hybr_pref = CM_HYBR_PREF_OFF;
  ph_ptr->prst_hybr_3_stack_info[ph_ptr->curr_nam].hybr_pref =
                                ph_ptr->hybr_3_stack_info.pref_info.hybr_pref;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cm_nv_band_pref_u_type  temp;
    uint64                  band_pref_32_63;
    uint64                  temp1;

    /* Read the Band Preference from NV for subscription 2
    */
    cmnv_item_ptr->band_pref.nam = (byte) i;
    cmnv_read_wait_extn( NV_BAND_PREF_I,
                         cmnv_item_ptr,
                         ph_ptr->hybr_3_stack_info.nv_context);
    temp.nv_band_pref[0] = (uint16)cmnv_item_ptr->band_pref.band;

    cmnv_read_wait_extn( NV_BAND_PREF_16_31_I,
                         cmnv_item_ptr,
                         ph_ptr->hybr_3_stack_info.nv_context);
    temp.nv_band_pref[1] = (uint16)cmnv_item_ptr->band_pref.band;

    cmnv_read_wait_extn( NV_BAND_PREF_32_63_I,
                         cmnv_item_ptr,
                         ph_ptr->hybr_3_stack_info.nv_context);
    band_pref_32_63 = (uint32)cmnv_item_ptr->band_pref_32_63.band;

    /* Copy Bits 0-31 in temporary variable.
    */
    temp1 = temp.dummy;

    /* Move bits 32-63 to its desired position and insert bits 0-31.
    */
    ph_ptr->prst_hybr_3_stack_info[i].band_pref =  temp1 | (uint64)(band_pref_32_63 << 32);

    /* If the band pref is not a valid value, write a valid value into NV (ANY) */
    if (ph_ptr->prst_hybr_3_stack_info[i].band_pref >= CM_BAND_PREF_MAX)
    {
       ph_ptr->prst_hybr_3_stack_info[i].band_pref = CM_BAND_PREF_ANY;
       cmnv_item_ptr->band_pref.nam  = (byte) i;
       cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)CM_BAND_PREF_ANY;
                                      //NV_BAND_PREF_ANY;
       #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
       cmnv_write_wait_extn(NV_BAND_PREF_I,
                            cmnv_item_ptr,
                            ph_ptr->hybr_3_stack_info.nv_context);
       #endif

       cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)(CM_BAND_PREF_ANY >> 16);
                                      //((word)NV_BAND_PREF_ANY & 0x7FFF);
       #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
       cmnv_write_wait_extn(NV_BAND_PREF_16_31_I,
                            cmnv_item_ptr,
                            ph_ptr->hybr_3_stack_info.nv_context);
       #endif

       cmnv_item_ptr->band_pref_32_63.band = (uint32)(CM_BAND_PREF_ANY >> 32);
                                      //((word)NV_BAND_PREF_ANY & 0x3FFF);
       #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
       cmnv_write_wait_extn(NV_BAND_PREF_32_63_I,
                            cmnv_item_ptr,
                            ph_ptr->hybr_3_stack_info.nv_context);
       #endif
    }

    /* Read the persistent TDS band preference. */

    read_persistent_band_pref( CMEFS_ID_TDS_BANDPREF,
                               &(ph_ptr->prst_hybr_3_stack_info[i].tds_band_pref),
                               ph_ptr->hybr_3_stack_info.asubs_id);
    ph_ptr->dbg_info.init_sub2_tds_bandpref = ph_ptr->prst_hybr_3_stack_info[i].tds_band_pref;

    #ifdef FEATURE_CM_LTE
    if (cmph_is_sxlte())
    {
      cm_band_pref_e_type lte_bands_1_64 = CM_BAND_PREF_NONE;
      #if(LTE_BAND_NUM == 256)
      sys_lte_band_mask_e_type lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
      read_persistent_lte_extn_band_pref( &lte_band_pref, ph_ptr->hybr_3_stack_info.asubs_id);
      #endif
      read_persistent_band_pref(CMEFS_ID_LTE_BANDPREF,
                              &lte_bands_1_64,
                              ph_ptr->hybr_3_stack_info.asubs_id);

      #if(LTE_BAND_NUM == 256)
      lte_band_pref.bits_1_64 = lte_bands_1_64;
      ph_ptr->prst_hybr_3_stack_info[i].lte_band_pref = lte_band_pref;
      #else
      ph_ptr->prst_hybr_3_stack_info[i].lte_band_pref = lte_bands_1_64;
      #endif
    }
    else 
    #endif
    {
      ph_ptr->prst_hybr_3_stack_info[i].lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
    }

    /* If target or PRL oes not support the specified mode and band preference
    ** combination, set the mode and band preference to their default
    ** values.
    */
    if( ! sd_misc_is_supp_pref(
          cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->prst_hybr_3_stack_info[i].mode_pref),
          cmph_map_cm_band_pref_to_sd_band_pref(ph_ptr->prst_hybr_3_stack_info[i].band_pref))

        &&

        ! sd_misc_is_supp_pref_tds(
           cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->prst_hybr_3_stack_info[i].mode_pref),
           cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(ph_ptr->prst_hybr_3_stack_info[i].band_pref))
        #ifdef FEATURE_CM_LTE
        &&
        ! sd_misc_is_supp_pref_lte(
           cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->prst_hybr_3_stack_info[i].mode_pref),
           ph_ptr->prst_hybr_3_stack_info[i].lte_band_pref)
        #endif
      )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_3_stack_info[i].mode_pref     = CM_MODE_PREF_AUTOMATIC;
      cmnv_item_ptr->pref_mode.nam  = (byte) i;
      cmnv_item_ptr->pref_mode.mode = NV_MODE_AUTOMATIC;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I, cmnv_item_ptr,
                           ph_ptr->hybr_3_stack_info.nv_context);
      #endif

      /* Default the band preference and write it back to NV.
      */
      ph_ptr->prst_hybr_3_stack_info[i].band_pref     = CM_BAND_PREF_ANY;
      cmnv_item_ptr->band_pref.nam  = (byte) i;
      cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)CM_BAND_PREF_ANY;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_BAND_PREF_I, cmnv_item_ptr,
                           ph_ptr->hybr_3_stack_info.nv_context);
      #endif
      cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)(CM_BAND_PREF_ANY >> 16 );
      cmnv_write_wait_extn(NV_BAND_PREF_16_31_I, cmnv_item_ptr,
                           ph_ptr->hybr_3_stack_info.nv_context );
      cmnv_item_ptr->band_pref_32_63.band = (uint32)(CM_BAND_PREF_ANY >> 32 );
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_BAND_PREF_32_63_I, cmnv_item_ptr,
                           ph_ptr->hybr_3_stack_info.nv_context);
      #endif

      /*Set default value of LTE/TDS band pref and write it back to NV
      */
      #ifdef FEATURE_CM_LTE
      ph_ptr->prst_hybr_3_stack_info[i].lte_band_pref  = SYS_LTE_BAND_MASK_CONST_ANY;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmefs_fs_write(CMEFS_ID_LTE_BANDPREF,
                     (byte *)&(ph_ptr->prst_hybr_3_stack_info[i].lte_band_pref),
                     sizeof(cm_band_pref_e_type),
                     ph_ptr->hybr_3_stack_info.asubs_id);
      #endif

      #else
      ph_ptr->prst_hybr_3_stack_info[i].lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
      #endif

      ph_ptr->prst_hybr_3_stack_info[i].tds_band_pref = CM_BAND_PREF_TDS_ANY;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_efs_write(CMEFS_ID_TDS_BANDPREF,
                     (byte *)&(ph_ptr->prst_hybr_3_stack_info[i].tds_band_pref),
                     sizeof(cm_band_pref_e_type));
      #endif
      
    }
    efs_read_size = sizeof(cm_user_net_sel_mode_pref_e_type);
    if(cmefs_get ( cmefs_get_efs_id_for_curr_nam ((cm_nam_e_type)i),
                          (byte*)&user_net_sel_mode_pref,
                          efs_read_size,
                          cmph_map_cm_ss_to_subs(CM_SS_HYBR_3)))
    {
      ph_ptr->prst_hybr_3_stack_info[i].user_net_sel_mode = user_net_sel_mode_pref;
    }
  }
  ph_ptr->hybr_3_stack_info.pref_info.user_net_sel_mode =
    CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( cmph_map_cm_ss_to_subs(CM_SS_HYBR_3), ph_ptr );
  if ((CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( cmph_map_cm_ss_to_subs(CM_SS_HYBR_3), ph_ptr )
                                      == CM_USER_NETWORK_SEL_MODE_PREF_AUTOMATIC)
      ||
      (CMPH_PRST_USER_NETWORK_SEL_MODE_PREF(cmph_map_cm_ss_to_subs(CM_SS_HYBR_3), ph_ptr )
                                      == CM_USER_NETWORK_SEL_MODE_PREF_MANUAL))
  {
    ph_ptr->hybr_3_stack_info.pref_info.network_sel_mode_pref =
      cmph_map_user_to_cm_net_sel_mode_pref (
        CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( cmph_map_cm_ss_to_subs(CM_SS_HYBR_3), ph_ptr ));
    CM_MSG_HIGH_1 ("phone's hybr3 stack net_sel_mode updated with user_net_sel_mode - %d",
                  ph_ptr->hybr_3_stack_info.pref_info.network_sel_mode_pref);
  }

  ph_ptr->hybr_3_stack_info.pref_info.band_pref = CMPH_PRST_HYBR_3_BAND_PREF( ph_ptr );
  ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref = CMPH_PRST_HYBR_3_TDS_BAND_PREF(  ph_ptr );
  ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref = CMPH_PRST_HYBR_3_LTE_BAND_PREF(ph_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_item_ptr->prl_pref.nam = (byte) i;
    cmnv_read_wait_extn(NV_PRL_PREF_I, cmnv_item_ptr,
                            ph_ptr->hybr_3_stack_info.nv_context);
    ph_ptr->prst_hybr_3_stack_info[i].prl_pref =
                            (cm_prl_pref_e_type) (cmnv_item_ptr->prl_pref.prl);

    /* If the prl preference is out of bound, set the prl preference to its
    ** deflate value.
    */

     if( ph_ptr->prst_hybr_3_stack_info[i].prl_pref != CM_PRL_PREF_AVAIL_BC0_A &&
         ph_ptr->prst_hybr_3_stack_info[i].prl_pref != CM_PRL_PREF_AVAIL_BC0_B &&
         ph_ptr->prst_hybr_3_stack_info[i].prl_pref != CM_PRL_PREF_ANY )
    {
      ph_ptr->prst_hybr_3_stack_info[i].prl_pref     = CM_PRL_PREF_ANY;
      cmnv_item_ptr->prl_pref.nam  = (byte) i;
      cmnv_item_ptr->prl_pref.prl =  (uint32) CM_PRL_PREF_ANY;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PRL_PREF_I, cmnv_item_ptr,
                           ph_ptr->hybr_3_stack_info.nv_context);
      #endif
    }
  }

  ph_ptr->hybr_3_stack_info.pref_info.prl_pref = CMPH_PRST_HYBR_3_PRL_PREF( ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_item_ptr->roam_pref.nam = (byte) i;
    cmnv_read_wait_extn(NV_ROAM_PREF_I, cmnv_item_ptr,
                            ph_ptr->hybr_3_stack_info.nv_context);
    ph_ptr->prst_hybr_3_stack_info[i].roam_pref =
                         (cm_roam_pref_e_type) (cmnv_item_ptr->roam_pref.roam);

    /* If the roam preference is out of bound, set the roam preference to its
    ** deflate value.
    */
    if( ! BETWEEN(ph_ptr->prst_hybr_3_stack_info[i].roam_pref, CM_ROAM_PREF_NONE,
                  CM_ROAM_PREF_NO_CHANGE) )
    {
      ph_ptr->prst_hybr_3_stack_info[i].roam_pref     = CM_ROAM_PREF_ANY;
      cmnv_item_ptr->roam_pref.nam  = (byte) i;
      cmnv_item_ptr->roam_pref.roam = (nv_roam_pref_enum_type)
                                      SD_SS_ROAM_PREF_ANY;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_ROAM_PREF_I, cmnv_item_ptr,
                           ph_ptr->hybr_3_stack_info.nv_context);
      #endif
    }
  }

  ph_ptr->hybr_3_stack_info.pref_info.roam_pref = CMPH_PRST_HYBR_3_ROAM_PREF(  ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_item_ptr->acq_order_pref.nam = (byte) i;
    cmnv_read_wait_extn(NV_ACQ_ORDER_PREF_I, cmnv_item_ptr,
                        ph_ptr->hybr_3_stack_info.nv_context);

    ph_ptr->prst_hybr_3_stack_info[i].acq_order_pref =
       acq_order_pref_nv2cm( cmnv_item_ptr->acq_order_pref.acq_order );

    if( ( ph_ptr->prst_hybr_3_stack_info[i].acq_order_pref != CM_GW_ACQ_ORDER_PREF_AUTOMATIC ) &&
      ( ph_ptr->prst_hybr_3_stack_info[i].acq_order_pref != CM_GW_ACQ_ORDER_PREF_WCDMA_GSM ) &&
      ( ph_ptr->prst_hybr_3_stack_info[i].acq_order_pref != CM_GW_ACQ_ORDER_PREF_GSM_WCDMA )    )
    {
      /*
      ** Default the acquistion order preference and write it back to NV.
      */
      #ifdef FEATURE_WCDMA
      ph_ptr->prst_hybr_3_stack_info[i].acq_order_pref          = CM_GW_ACQ_ORDER_PREF_WCDMA_GSM;
      #else
      ph_ptr->prst_hybr_3_stack_info[i].acq_order_pref          = CM_GW_ACQ_ORDER_PREF_GSM_WCDMA;
      #endif  /* FEATURE_WCDMA */
      cmnv_item_ptr->acq_order_pref.acq_order =
      acq_order_pref_cm2nv( ph_ptr->prst_hybr_3_stack_info[i].acq_order_pref );
      cmnv_item_ptr->acq_order_pref.nam       = (byte) i;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn( NV_ACQ_ORDER_PREF_I, cmnv_item_ptr,
                            ph_ptr->hybr_3_stack_info.nv_context);
      #endif
    } /* if not valid acquisition order */
  }

  ph_ptr->hybr_3_stack_info.pref_info.acq_order_pref = CMPH_PRST_HYBR_3_ACQ_ORDER_PREF(  ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_item_ptr->net_sel_mode_pref.nam = (byte) i;
    cmnv_read_wait_extn(NV_NET_SEL_MODE_PREF_I, cmnv_item_ptr,
                        ph_ptr->hybr_3_stack_info.nv_context);

    ph_ptr->prst_hybr_3_stack_info[i].network_sel_mode_pref =
     cmph_map_net_sel_mode_pref_nv2cm( cmnv_item_ptr->net_sel_mode_pref.net_sel_mode );

    if ( ( ph_ptr->prst_hybr_3_stack_info[i].network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_AUTOMATIC   &&
           ph_ptr->prst_hybr_3_stack_info[i].network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_MANUAL      &&
           ph_ptr->prst_hybr_3_stack_info[i].network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV ) ||
         ( !cmph_is_valid_network_selection_mode_pref( ph_ptr->prst_hybr_3_stack_info[i].mode_pref,
                                                       ph_ptr->prst_hybr_3_stack_info[i].network_sel_mode_pref
                                                     )
         )
       )
    {
      /*
      ** Default the network selection mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_3_stack_info[i].network_sel_mode_pref         = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
      cmnv_item_ptr->net_sel_mode_pref.net_sel_mode =
        cmph_map_net_sel_mode_pref_cm2nv( ph_ptr->prst_hybr_3_stack_info[i].network_sel_mode_pref );
      cmnv_item_ptr->net_sel_mode_pref.nam          = (byte) i;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn( NV_NET_SEL_MODE_PREF_I, cmnv_item_ptr,
                            ph_ptr->hybr_3_stack_info.nv_context);
      #endif
    } /* if not valid network selection mode */
  }

  ph_ptr->hybr_3_stack_info.pref_info.network_sel_mode_pref =
                    CMPH_PRST_HYBR_3_NETWORK_SEL_MODE_PREF(  ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_item_ptr->service_domain_pref.nam = (byte) i;
    cmnv_read_wait_extn(NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
                        ph_ptr->hybr_3_stack_info.nv_context);

    ph_ptr->prst_hybr_3_stack_info[i].srv_domain_pref =
     cmph_map_srv_domain_pref_nv2cm( cmnv_item_ptr->service_domain_pref.srv_domain );

    if (( ph_ptr->prst_hybr_3_stack_info[i].srv_domain_pref != CM_SRV_DOMAIN_PREF_CS_ONLY ) &&
      ( ph_ptr->prst_hybr_3_stack_info[i].srv_domain_pref != CM_SRV_DOMAIN_PREF_PS_ONLY ) &&
      ( ph_ptr->prst_hybr_3_stack_info[i].srv_domain_pref != CM_SRV_DOMAIN_PREF_CS_PS   )    )
    {
      /*
      ** Default the service domain preference and write it back to NV.
      */
      ph_ptr->prst_hybr_3_stack_info[i].srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
      cmnv_item_ptr->service_domain_pref.srv_domain     =
      cmph_map_srv_domain_pref_cm2nv( ph_ptr->prst_hybr_3_stack_info[i].srv_domain_pref );
      cmnv_item_ptr->service_domain_pref.nam            = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
                            ph_ptr->hybr_3_stack_info.nv_context);
      #endif
    } /* if not valid service domain */
  }

  ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref =
                          CMPH_PRST_HYBR_3_SRV_DOMAIN_PREF(  ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  rex_def_timer(&ph_ptr->hybr_3_stack_info.phone_charge.acm_timer, get_cm_tcb(), CM_ACM_TIMER_SIG);
  rex_def_timer(&ph_ptr->hybr_3_stack_info.phone_charge.ccm_timer, get_cm_tcb(), CM_CCM_TIMER_SIG);

  ph_ptr->hybr_3_stack_info.user_pref_networks.length = 0;


  ph_ptr->hybr_3_stack_info.plmn_list.plmn_list.length = 0;
  

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read preferences for packet switched data calls on subs2
  */
  cmnv_read_wait_extn( NV_PS_DATA_ORIG_PREF_I, cmnv_item_ptr,
                       ph_ptr->hybr_3_stack_info.nv_context);
  ph_ptr->hybr_3_stack_info.ps_data_orig_pref = (cm_ps_data_orig_prefs_e_type)
                                              cmnv_item_ptr->ps_data_orig_pref;

  if( ! BETWEEN(ph_ptr->hybr_3_stack_info.ps_data_orig_pref,
                CM_PS_DATA_ORIG_PREF_NONE,
                CM_PS_DATA_ORIG_PREF_MAX)
    )
  {
    /*
    ** Default the ps data orig preference and write it back to NV.
    */
    ph_ptr->hybr_3_stack_info.ps_data_orig_pref = CM_PS_DATA_ORIG_PREF_ANY;
    cmnv_item_ptr->ps_data_orig_pref = NV_PS_DATA_ORIG_PREF_ANY;
    #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
    cmnv_write_wait_extn (NV_PS_DATA_ORIG_PREF_I, cmnv_item_ptr,
                          ph_ptr->hybr_3_stack_info.nv_context);
    #endif
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmnv_read_wait_extn(NV_DISABLE_CM_CALL_TYPE_I, cmnv_item_ptr,
                      ph_ptr->hybr_3_stack_info.nv_context);

  ph_ptr->hybr_3_stack_info.disable_call_type_mask = (cm_disable_call_type)
                                          cmnv_item_ptr->disable_cm_call_type;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmph_deactivate_ps_service_req_timer(CM_SS_HYBR_3);
  cmph_set_ps_sig_down_wait_time(CMPH_GW_PKT_WAIT_TIME_NONE, CM_SS_HYBR_3);
  ph_ptr->hybr_3_stack_info.is_ps_srv_req_sent = FALSE;
  ph_ptr->hybr_3_stack_info.is_sys_sel_pref_rsp_pending = FALSE;
#endif

}
  #endif

/*===========================================================================

FUNCTION cmph_hybr_gw_init

DESCRIPTION
  Initializing the phone object.

  This function must be called before the phone object
  is being used, in any way, place, or form.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_hybr_gw_init(

   uint8             refresh_subs_mask ,
    /* Subs mask whose NVs need to be refreshed
    */
   boolean           is_pwr_on
    /* is this a power on refresh or MCFG triggered refresh
    */
                              )
{
  #ifdef FEATURE_MMODE_DUAL_SIM
  cmph_s_type                           *ph_ptr  =  cmph_ptr();
      /* Point at phone object to be initialized */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize hybr_2 stack only if required */
  if (!cmph_no_hybr2() && !cmph_is_sxlte_any())
    {
    cmph_hybr_2_gw_init(refresh_subs_mask, is_pwr_on);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if (cmph_is_sxlte())
  {
    ph_ptr->hybr_3_stack_info.nv_context = 1;
  }
  else
  {
    ph_ptr->hybr_3_stack_info.nv_context = 2;
  }
  if (is_pwr_on)
  {
    sys_plmn_undefine_plmn_id( &ph_ptr->hybr_3_stack_info.pref_info.plmn );
    ph_ptr->hybr_3_stack_info.pref_info.csg_id  = SYS_CSG_ID_INVALID;
    ph_ptr->hybr_3_stack_info.pref_info.csg_rat = SYS_RAT_NONE;
  }
  if ( is_pwr_on ||
      ( BM(ph_ptr->hybr_3_stack_info.nv_context) & refresh_subs_mask))
  {
    cmph_hybr_3_gw_init();
  }
  else
  {
    CM_MSG_HIGH_0("mcfgrefresh:no hybr3 init");
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    if (is_pwr_on)
    {
  /* Read the Dual-standby preferences from NV
  */
  cmnv_read_wait( NV_DUAL_STANDBY_CFG_ITEMS_I, cmnv_item_ptr );
  ph_ptr->default_data_subs  = (sys_modem_as_id_e_type)cmnv_item_ptr->dual_standby_cfg_items.dedicated_data_subs;
  ph_ptr->default_voice_subs = (sys_modem_as_id_e_type)cmnv_item_ptr->dual_standby_cfg_items.dedicated_voice_subs;
  ph_ptr->active_subs        =  cmnv_item_ptr->dual_standby_cfg_items.active_subs;
  ph_ptr->priority_subs      = (sys_modem_as_id_e_type)cmnv_item_ptr->dual_standby_cfg_items.priority_subs;
  ph_ptr->curr_priority_subs = ph_ptr->priority_subs;
  ph_ptr->user_standby_pref       = (sys_modem_dual_standby_pref_e_type)cmnv_item_ptr->dual_standby_cfg_items.dual_standby_pref;

  /* If AUTO is the new standby mode, derive the affective preference
  */
  if( ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO ||
      ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY
    )
  {
    ph_ptr->active_subs = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;
    /* When multiple subscriptions are available go into Dual Standby
    */
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if( ( ph_ptr->is_cdma_subscription_available ||
          ph_ptr->is_gwl_subscription_available
        ) &&
        ph_ptr->is_hybr_gw_subscription_available &&
        ph_ptr->is_hybr_gw3_subscription_available)
    {
      /* Depending on tuneaway, set the standby preference accordingly */
      if( ph_ptr->standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY )
      {
        if (cmph_is_sxlte())
        {
          ph_ptr->standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY;
        }
        else
        {
          ph_ptr->standby_pref = SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY;
        }
      }
      else
      {
        if (cmph_is_sxlte())
        {
          ph_ptr->standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
        }
        else
        {
          ph_ptr->standby_pref = SYS_MODEM_DS_PREF_TRIPLE_STANDBY;
        }
      }
      if (cmph_is_sxlte())
      {
        ph_ptr->active_subs = (SYS_MODEM_AS_ID_1_MASK | \
              SYS_MODEM_AS_ID_2_MASK);
      }
      else
      {
        ph_ptr->active_subs = (SYS_MODEM_AS_ID_1_MASK | \
              SYS_MODEM_AS_ID_2_MASK| SYS_MODEM_AS_ID_3_MASK);
      }
    }
    else if( ( ph_ptr->is_cdma_subscription_available ||
          ph_ptr->is_gwl_subscription_available
        ) &&
        ph_ptr->is_hybr_gw3_subscription_available )
    {
      /* Depending on tuneaway, set the standby preference accordingly */
      if( ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY )
      {
        ph_ptr->standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY;
      }
      else
      {
        ph_ptr->standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
      }

      ph_ptr->active_subs = (BM(ph_ptr->main_stack_info.asubs_id) | BM(ph_ptr->hybr_3_stack_info.asubs_id));
    }
    else
    #endif
    /* SXLTE_Q */
    if( ( ph_ptr->is_cdma_subscription_available ||
          ph_ptr->is_gwl_subscription_available
        ) &&
        ph_ptr->is_hybr_gw_subscription_available )
    {
      /* Depending on tuneaway, set the standby preference accordingly */
      if( ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY )
      {
        ph_ptr->standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY;
      }
      else
      {
        ph_ptr->standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
      }
      ph_ptr->active_subs = (SYS_MODEM_AS_ID_1_MASK | SYS_MODEM_AS_ID_2_MASK);

    }
    #if defined(FEATURE_MMODE_SXLTE_G)
    else if ( ( ph_ptr->is_cdma_subscription_available ||
             ph_ptr->is_gwl_subscription_available
            ) &&
        ph_ptr->is_hybr_gw3_subscription_available )
    {
      /* Depending on tuneaway, set the standby preference accordingly */
      if( ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY )
      {
        ph_ptr->standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY;
      }
      else
      {
        ph_ptr->standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
      }
      ph_ptr->active_subs |= BM(ph_ptr->main_stack_info.asubs_id);
      ph_ptr->active_subs |= BM(ph_ptr->hybr_3_stack_info.asubs_id);
    }
    #endif
    /* Only Main subscription available, Go into SS on SUBS1 */
    else if (ph_ptr->is_cdma_subscription_available ||
             ph_ptr->is_gwl_subscription_available)
    {
      ph_ptr->standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
      ph_ptr->active_subs |= BM(ph_ptr->main_stack_info.asubs_id);
      ph_ptr->default_data_subs = ph_ptr->main_stack_info.asubs_id;
      ph_ptr->default_voice_subs = ph_ptr->main_stack_info.asubs_id;
    }
    /* Only Hybr GW subscription available, Go into SS on SUBS2 */
    else if ( ph_ptr->is_hybr_gw_subscription_available )
    {
      ph_ptr->standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
      ph_ptr->active_subs |= BM(ph_ptr->hybr_2_stack_info.asubs_id);
      ph_ptr->default_data_subs = ph_ptr->hybr_2_stack_info.asubs_id;
      ph_ptr->default_voice_subs = ph_ptr->hybr_2_stack_info.asubs_id;
    }
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    else if ( ph_ptr->is_hybr_gw3_subscription_available )
    {
        ph_ptr->standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
        ph_ptr->active_subs |= BM(ph_ptr->hybr_3_stack_info.asubs_id);
        ph_ptr->default_data_subs = ph_ptr->hybr_3_stack_info.asubs_id;
        ph_ptr->default_voice_subs = ph_ptr->hybr_3_stack_info.asubs_id;
    }
    #endif
    else
    {
      ph_ptr->standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
      ph_ptr->active_subs |= SYS_MODEM_AS_ID_1_MASK;
    }
    ph_ptr->is_bootup_no_standby = FALSE;
  }
  else
  {
    if(ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_NO_STANDBY_PREF)
    {
      ph_ptr->is_bootup_no_standby = TRUE;
    }
    ph_ptr->user_standby_pref = SYS_MODEM_DS_PREF_NO_STANDBY_PREF;
    ph_ptr->standby_pref = ph_ptr->user_standby_pref;
  }

  ph_ptr->user_active_subs = ph_ptr->active_subs;

  if(SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY == ph_ptr->standby_pref)
  {
    ph_ptr->internal_standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
  }
  #ifdef FEATURE_MMODE_TRIPLE_SIM
  else if(SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY == ph_ptr->standby_pref)
  {
    ph_ptr->internal_standby_pref = SYS_MODEM_DS_PREF_TRIPLE_STANDBY;
  }
  #endif
  else
  {
    ph_ptr->internal_standby_pref = ph_ptr->standby_pref;
  }

  /* Validate the Dual-standby Preferences
  */
  if( !BETWEEN(ph_ptr->default_data_subs, SYS_MODEM_AS_ID_NONE,
                                          SYS_MODEM_AS_ID_MAX))
  {
    ph_ptr->default_data_subs = SYS_MODEM_AS_ID_1;
  }

  if( !BETWEEN(ph_ptr->default_voice_subs, SYS_MODEM_AS_ID_NONE,
                                           SYS_MODEM_AS_ID_MAX))
  {
    ph_ptr->default_voice_subs = SYS_MODEM_AS_ID_1;
  }

  if( !BETWEEN(ph_ptr->priority_subs, SYS_MODEM_AS_ID_NONE,
                                      SYS_MODEM_AS_ID_MAX))
  {
    ph_ptr->priority_subs = SYS_MODEM_AS_ID_1;
    ph_ptr->curr_priority_subs = SYS_MODEM_AS_ID_1;
  }
  if( !BETWEEN(ph_ptr->internal_standby_pref, SYS_MODEM_DS_PREF_NONE, SYS_MODEM_DS_PREF_MAX) &&
      !BETWEEN(ph_ptr->standby_pref,  SYS_MODEM_DS_PREF_NONE, SYS_MODEM_DS_PREF_MAX))
  {
    ph_ptr->standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
    ph_ptr->internal_standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
  }

   /* Update prst DDS */
  ph_ptr->prst_dual_standby_pref.default_data_subs = ph_ptr->default_data_subs;

  ph_ptr->mcfg_deactivate_subs = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;
  ph_ptr->num_standby_requests_processing = 0;

  ph_ptr->curr_voice_subs = ph_ptr->default_voice_subs;
  ph_ptr->hybr_2_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;

  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if (!cmph_no_hybr2())
  {
  /* status of plmn list request (success/abort) */
  ph_ptr->hybr2_available_networks_list_cnf = SYS_PLMN_LIST_NONE;
  }
  #endif

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  ph_ptr->hybr_3_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
  /* status of plmn list request (success/abort) */
  ph_ptr->hybr3_available_networks_list_cnf = SYS_PLMN_LIST_NONE;
  #endif

  ph_ptr->is_standby_pref_buffered = FALSE;
  } //if is power on

  /* if default data is not equal to a stack subs_id, remove PS from the preference of that subs */
  if(ph_ptr->default_data_subs != ph_ptr->main_stack_info.asubs_id &&
      (ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS ||
       ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY))
    {
      if(cmpm_ptr()->ims_for_nondds == FALSE)
      {

      ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].srv_domain_pref
                                                    = CM_SRV_DOMAIN_PREF_CS_ONLY;
      ph_ptr->main_stack_info.pref_info.srv_domain_pref
                                                    = CM_SRV_DOMAIN_PREF_CS_ONLY;
      }
      else if (!is_pwr_on)
      {
        CM_MSG_HIGH_3("Due to ims_for_nondds, retain srv_domain/prst_srv_domain %d/%d: maxActiveData %d",
          ph_ptr->main_stack_info.pref_info.srv_domain_pref,
          ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].srv_domain_pref,
          cmpm_ptr()->device_mode.nMaxActiveData);
      }

    }

  if(ph_ptr->default_data_subs != ph_ptr->hybr_2_stack_info.asubs_id &&
      (ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS ||
       ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY) &&
    !cmph_no_hybr2())
  {
    ph_ptr->prst_hybr_2_stack_info[ph_ptr->curr_nam].srv_domain_pref
                                                = CM_SRV_DOMAIN_PREF_CS_ONLY;
    ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref
                                                = CM_SRV_DOMAIN_PREF_CS_ONLY;
  }
  #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
  if(ph_ptr->default_data_subs != ph_ptr->hybr_3_stack_info.asubs_id &&
      (ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS ||
       ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY))
    {
      ph_ptr->prst_hybr_3_stack_info[ph_ptr->curr_nam].srv_domain_pref
                                                    = CM_SRV_DOMAIN_PREF_CS_ONLY;
      ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref
                                                    = CM_SRV_DOMAIN_PREF_CS_ONLY;
    }
  #endif
  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  {
    unsigned int                          i;

    for(i=0;i<MAX_AS_IDS;i++)
    {
      ph_ptr->call_state_info.subs_st[i][0].state  = SP_NO_CALL_STATE;
      ph_ptr->call_state_info.subs_st[i][0].mode = SYS_SYS_MODE_NO_SRV;
      ph_ptr->call_state_info.subs_st[i][1].state  = SP_NO_CALL_STATE;
      ph_ptr->call_state_info.subs_st[i][1].mode = SYS_SYS_MODE_NO_SRV;
    }
  }
  #endif

  #endif /* FEATURE_MMODE_DUAL_SIM */
} /* cmph_hybr_gw_init */


/*===========================================================================

FUNCTION cmph_init_rtre_settings

DESCRIPTION
  Initializing the rtre config and control based on nv 855.
  rtre_config will be read from NV_RTRE_CONFIG_I.
  rtre_config will be from nv_rtre_control().

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmph_init_rtre_settings(cm_rtre_config_e_type *rtre_config,
                                cm_rtre_control_e_type *rtre_control)
{
  #ifdef FEATURE_UIM_RUN_TIME_ENABLE
  nv_rtre_control_type  rtre_control_val;
  #endif

  #if ( defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) )

  #if defined( FEATURE_UIM_RUIM )
  #if defined( FEATURE_UIM_RUN_TIME_ENABLE )

  /* Read the RTRE Config item from NV */
  /** RTRE config settings are read from NV 855. CM Clients will
    ** receive the appropriate values set in NV 855.
    */
  cmnv_read_wait( NV_RTRE_CONFIG_I, cmnv_item_ptr );

  switch ( cmnv_item_ptr->rtre_config ) {
    case NV_RTRE_CONFIG_RUIM_ONLY:
      *rtre_config = CM_RTRE_CONFIG_RUIM_ONLY;
      break;

    case NV_RTRE_CONFIG_NV_ONLY:
      *rtre_config   = CM_RTRE_CONFIG_NV_ONLY;
      break;

    case NV_RTRE_CONFIG_RUIM_OR_DROP_BACK:
      *rtre_config   = CM_RTRE_CONFIG_RUIM_OR_DROP_BACK;
      break;

    case NV_RTRE_CONFIG_SIM_ACCESS:
      *rtre_config   = CM_RTRE_CONFIG_SIM_ACCESS;
      break;

    default:
      CM_ERR_1("Unexpected config value %d",
             cmnv_item_ptr->rtre_config);
      break;
  }

  /* Read the RTRE control item from NV */
  rtre_control_val = nv_rtre_control();

  CM_MSG_HIGH_2("NV_RTRE_CONFIG_I val %d, rtre control from nv_rtre_control() %d",rtre_control_val, cmnv_item_ptr->rtre_config);

  switch ( rtre_control_val ) {
    case NV_RTRE_CONTROL_USE_RUIM:
      *rtre_control = CM_RTRE_CONTROL_RUIM;
      break;
    case NV_RTRE_CONTROL_NO_RUIM:
      *rtre_control = CM_RTRE_CONTROL_NV;

      break;
    #ifdef FEATURE_UIM_RUIM_W_GSM_ACCESS
    case NV_RTRE_CONTROL_SIM_ACCESS:
      *rtre_control = CM_RTRE_CONTROL_SIM;
      break;
    #endif  /* FEATURE_UIM_RUIM_W_GSM_ACCESS */
    default:
      break;
  }
  #else /* else of defined( FEATURE_UIM_RUN_TIME_ENABLE ) */
    /*
      ** RUIM only
      */
    *rtre_control = CM_RTRE_CONTROL_RUIM;
  #endif /* defined( FEATURE_UIM_RUN_TIME_ENABLE ) */
  #else /* else of defined( FEATURE_UIM_RUIM ) */
    /*
      ** NV only
      */
    *rtre_control = CM_RTRE_CONTROL_NV;
  #endif /*  defined( FEATURE_UIM_RUIM ) */

  #else /* else of defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)*/
    /* Initializing to defaults */
    *rtre_config  = CM_RTRE_CONFIG_NV_ONLY;
    *rtre_control = CM_RTRE_CONTROL_NV;

  #endif /* defined(FEATURE_UIM_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */

}
/*===========================================================================

FUNCTION cmph_nv_refresh

DESCRIPTION
  Refresh all CM PH NV items for the subs specified in the refresh_subs_mask

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_nv_refresh(

   uint8             refresh_subs_mask ,
    /* Subs mask whose NVs need to be refreshed
    */
   boolean           is_pwr_on
    /* is this at power up / device reset
    */
   )
{

  cmph_s_type    *ph_ptr  =  cmph_ptr();
      /* Point at phone object to be initialized */
  int32           read_size = sizeof(uint16);
      /* Size of EFS file read */

  unsigned int    i;
      /* loop counter */

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  db_items_value_type  db_item;
      /* Item to do db_get() and db_put() */
  #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

  cm_user_net_sel_mode_pref_e_type  user_net_sel_mode_pref;
  int32                             efs_read_size;
  #ifdef FEATURE_HICPS_STACK_SYNC_UP
  int32                             size_of_gwl_avoid_timers;
  #endif
  uint16                            wcdma_freq_lock = 0;

  int32 get_net_auto_mode_size = sizeof(cmph_efs_get_net_auto_mode);

  cmph_cdma_call_collision_s_type   mo_call_event_info;

  #ifdef CM_GW_SUPPORTED
  mmgsdi_ens_sub_features_status_list_type ens_subfeatures;
  /* MMGSDI type for getting RAT Balancing feature flag. */
  #endif /* CM_GW_SUPPORTED */
  sys_overall_feature_t       old_feature_mode;
  sys_subs_feature_t          old_sfmode_sub1;
  boolean                     old_sub2_map_to_hybr3;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );


  /* Verify object was not already initialized.
  ** and then mark object as initialized.
  */
  if(is_pwr_on)
  {
    CM_ASSERT( ! CM_INIT_CHECK(ph_ptr->init_mask) );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  old_feature_mode = ph_ptr->feature_mode;
  old_sfmode_sub1 = ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1];
  old_sub2_map_to_hybr3 = cmph_is_sub2_map_to_hybr3();
  /* Get feature_mode configuration */
  ph_ptr->feature_mode = cmpmprx_get_overall_featuremode();

  /* Get subs feature mode */
  if(!cmpmprx_get_subs_feature_mode(SYS_MODEM_AS_ID_1,&(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1])))
  {
    ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] = SYS_SUBS_FEATURE_MODE_NORMAL;
  }

  if(!cmpmprx_get_subs_feature_mode(SYS_MODEM_AS_ID_2,&(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_2])))
  {
    ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_2] = SYS_SUBS_FEATURE_MODE_NORMAL;
  }

  #ifdef FEATURE_MMODE_TRIPLE_SIM
  ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_3] = SYS_SUBS_FEATURE_MODE_NORMAL;
  #endif

  /* Store the power up (sub)feature mode for debug purpose */   
  if(is_pwr_on)
  {
    ph_ptr->dbg_info.mcfg_refresh = FALSE;
    ph_ptr->dbg_info.init_feature_mode = ph_ptr->feature_mode;
    ph_ptr->dbg_info.init_subs_feature_mode[SYS_MODEM_AS_ID_1] 
      = ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1];
    ph_ptr->dbg_info.init_subs_feature_mode[SYS_MODEM_AS_ID_2] 
      = ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_2];
  }
  else
  {
    ph_ptr->dbg_info.mcfg_refresh = TRUE;
  } 
    
  /* Init values to NONE */
  {
    int i,j;
  i=0;
  do{
    j=0;
    do{
      ph_ptr->subs_stack_map[i][j]=CM_SS_NONE;
    }while(++j<MAX_STACK_PER_SUB);
    }while(++i<MAX_AS_IDS);
  }

  if(ph_ptr->feature_mode == SYS_OVERALL_FEATURE_MODE_SGLTE)
  {
    ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] = SYS_SUBS_FEATURE_MODE_SGLTE;
  }
  else if(ph_ptr->feature_mode == SYS_OVERALL_FEATURE_MODE_SVLTE)
  {
    ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] = SYS_SUBS_FEATURE_MODE_SVLTE;
  }
  else if(ph_ptr->feature_mode == SYS_OVERALL_FEATURE_MODE_SRLTE)
  {
    ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] = SYS_SUBS_FEATURE_MODE_SRLTE;
  }

  /* At this point, fmode and sfmode have been determined. 
  ** Set is_sub2_map_to_hybr3 if required 
  */
  cmph_set_is_sub2_map_to_hybr3();

  if(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SGLTE)
  {
    ph_ptr->main_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_SGLTE;
    ph_ptr->hybr_2_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_SGLTE;
	#if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    ph_ptr->hybr_3_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_NORMAL;
    #endif
  }
  else if(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE)
  {
    ph_ptr->main_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_SVLTE;
    ph_ptr->hybr_2_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_SVLTE;
	#if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    ph_ptr->hybr_3_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_NORMAL;
    #endif 
  }
  else if(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SRLTE)
  {
    ph_ptr->main_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_SRLTE;
    ph_ptr->hybr_2_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_SRLTE;
	#if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    ph_ptr->hybr_3_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_NORMAL;
    #endif
  }
  else if (cmph_no_hybr2())
  {
    ph_ptr->main_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_NORMAL;
	#if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    ph_ptr->hybr_3_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_NORMAL;
    #endif
  }
  else
  {
    ph_ptr->main_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_NORMAL;
    ph_ptr->hybr_2_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_NORMAL;
    #ifdef FEATURE_MMODE_TRIPLE_SIM
  ph_ptr->hybr_3_stack_info.feature_mode = SYS_SUBS_FEATURE_MODE_NORMAL;
  #endif
  }


  ph_ptr->ss_subs_map[CM_SS_MAIN].stack_id = 0;

  if(ph_ptr->feature_mode == SYS_OVERALL_FEATURE_MODE_SGLTE)
  {
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_MAIN;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][1] = CM_SS_HYBR_2;

    ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 0;
    ph_ptr->ss_subs_map[CM_SS_HYBR_2].stack_id = 1;

  ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
  ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
	#if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
    #endif
  }
  else if(ph_ptr->feature_mode == SYS_OVERALL_FEATURE_MODE_SVLTE ||
        ph_ptr->feature_mode == SYS_OVERALL_FEATURE_MODE_SRLTE
  )
  {
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_MAIN;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][1] = CM_SS_HYBR_1;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][2] = CM_SS_HYBR_2;

    ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 1;
    ph_ptr->ss_subs_map[CM_SS_HYBR_2].stack_id = 2;

    ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
    ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
	#if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
    #endif
  }
  else if(ph_ptr->feature_mode == SYS_OVERALL_FEATURE_MODE_MULTISIM)
  {
    if(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SGLTE)
    {
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_MAIN;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][1] = CM_SS_HYBR_2;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][0] = CM_SS_HYBR_3;

      ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 0;/* shld not be accessed */
      ph_ptr->ss_subs_map[CM_SS_HYBR_2].stack_id = 1;
      ph_ptr->ss_subs_map[CM_SS_HYBR_3].stack_id = 0;

      ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
      ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
      #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
      ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
      #endif
    }
    else if(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_2] == SYS_SUBS_FEATURE_MODE_SGLTE)
    {
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][0] = CM_SS_MAIN;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][1] = CM_SS_HYBR_2;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_HYBR_3;

      ph_ptr->ss_subs_map[CM_SS_MAIN].stack_id = 0;
      ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 0;
      ph_ptr->ss_subs_map[CM_SS_HYBR_2].stack_id = 1;
      ph_ptr->ss_subs_map[CM_SS_HYBR_3].stack_id = 0;

      ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
      ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
      #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
      ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
      #endif 
    }
    else if(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE ||
          ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SRLTE
    )
    {
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_MAIN;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][1] = CM_SS_HYBR_1;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][2] = CM_SS_HYBR_2;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][0] = CM_SS_HYBR_3;

      ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 1;
      ph_ptr->ss_subs_map[CM_SS_HYBR_2].stack_id = 2;
      ph_ptr->ss_subs_map[CM_SS_HYBR_3].stack_id = 0;

      ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
      ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
      #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
      ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
      #endif
    }
    /* normal+normal with max allowed cap != any+G */
    else if (cmph_is_sub2_map_to_hybr3())
    {
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_MAIN;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][1] = CM_SS_HYBR_1;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][0] = CM_SS_HYBR_3;

      ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 1;
      ph_ptr->ss_subs_map[CM_SS_HYBR_3].stack_id = 0;

      ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
      ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_NONE;
      #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
      ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
    #endif      
    }
    else
    {
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_MAIN;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][1] = CM_SS_HYBR_1;
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][0] = CM_SS_HYBR_2;
      #if defined(FEATURE_MMODE_TRIPLE_SIM)
      ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_3][0] = CM_SS_HYBR_3;
      #endif

      ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 1;
      ph_ptr->ss_subs_map[CM_SS_HYBR_2].stack_id = 0;
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      ph_ptr->ss_subs_map[CM_SS_HYBR_3].stack_id = 0;
      #endif

      ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
      ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_3;
      #endif
    }
  }
  else
  {
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_MAIN;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][1] = CM_SS_HYBR_1;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][0] = CM_SS_HYBR_2;
    #ifdef FEATURE_MMODE_TRIPLE_SIM
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_3][0] = CM_SS_HYBR_3;
    #endif
    ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 1;
    ph_ptr->ss_subs_map[CM_SS_HYBR_2].stack_id = 0;
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    ph_ptr->ss_subs_map[CM_SS_HYBR_3].stack_id = 0;
    #endif

    ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
    ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_3;
    #endif
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (refresh_subs_mask & SYS_MODEM_AS_ID_1_MASK)
  {
  ph_ptr->main_stack_info.pref_info.csg_id  = SYS_CSG_ID_INVALID;
  ph_ptr->main_stack_info.pref_info.csg_rat = SYS_RAT_NONE;

  read_size = sizeof(ph_ptr->csg_support);
  if ( cmefs_get2( "/nv/item_files/modem/nas/csg_support_configuration",
                    (byte*)&ph_ptr->csg_support,
                   read_size,
                   SYS_MODEM_AS_ID_1)
     )
  {
    CM_MSG_HIGH_1 ("EFS read succ. csg_support= %d",
                  ph_ptr->csg_support);
  }
  else
  {
    #ifdef FEATURE_DISABLE_CSG_BYDEFAULT
    ph_ptr->csg_support = SYS_CSG_SUPPORT_DISABLED;
    #else
    ph_ptr->csg_support = SYS_CSG_SUPPORT_WCDMA;
    #endif
  }
  } //as_id_1


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (is_pwr_on)
  {
  /* Initially the phone is powered off/FTM.
  **
  ** Note that UI needs to tell CM its decision during power-up -
  ** i.e. offline, online or LPM. If UI says online, MC can still
  ** come and say offline.
  */
  ph_ptr->oprt_mode      = SYS_OPRT_MODE_PWROFF;
  ph_ptr->true_oprt_mode = SYS_OPRT_MODE_PWROFF;

  /* Put the phone in FTM if nv says so
  */
  ph_ptr->nv_ftm_status = cmnv_read_wait( NV_FTM_MODE_I, cmnv_item_ptr );

  if (ph_ptr->nv_ftm_status == NV_DONE_S
              && cmnv_item_ptr->ftm_mode )
  {
    ph_ptr->oprt_mode = SYS_OPRT_MODE_FTM;
    mmoc_cmd_oprt_mode_chgd( SYS_OPRT_MODE_FTM );
  }

  #ifdef FEATURE_CM_DETECT_HW

  /* Force low power mode if there is no modem used */
  if (CMPH_HW_HAS_NO_MODEM)
  {
    ph_ptr->oprt_mode = SYS_OPRT_MODE_LPM;
    mmoc_cmd_oprt_mode_chgd( SYS_OPRT_MODE_LPM );
  }

  #endif /* FEATURE_CM_DETECT_HW */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* When CM comes up it doesn't know RF initialization status. so initialize
  ** to unknown. On off targets where this sync with RF isn't supported just
  ** initialize to ready so that rest of processing remains same.
  */
  ph_ptr->rf_init_status = CMPH_RF_INIT_UNKNOWN;

  ph_ptr->is_pending_online = FALSE;

  #ifdef FEATURE_CGPS
  ph_ptr->is_gps_pgi_init_complete = FALSE;
  #else
  ph_ptr->is_gps_pgi_init_complete = TRUE;
  #endif


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef CM_GW_SUPPORTED
  /* valid card/slot for subscription id 1 */
  ph_ptr->valid_card_1     = (mmgsdi_slot_id_enum_type)FALSE;

  /* valid card/slot for subscription id 2 */
  ph_ptr->valid_card_2     = (mmgsdi_slot_id_enum_type)FALSE;

  #ifdef FEATURE_TC
  restore_oprt_mode      = ph_ptr->oprt_mode;
  #endif /* FEATURE_TC */
  ph_ptr->test_control_type   = CM_TEST_CONTROL_TYPE_NO_TEST;
  #endif /* FEATURE_WCDMA, FEATURE_GSM */

  }//is_pwr_on
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (cmph_is_msim())
  {
      cmph_hybr_gw_init(refresh_subs_mask,is_pwr_on);
  }
  else if(is_pwr_on)
  {
    cmph_init_single_sim_mode();
  }

  
  for(i=0;i<MAX_AS_IDS;i++)
  {
    ph_ptr->call_state_info.subs_st[i][0].state  = SP_NO_CALL_STATE;
    ph_ptr->call_state_info.subs_st[i][0].mode = SYS_SYS_MODE_NO_SRV;
    ph_ptr->call_state_info.subs_st[i][1].state  = SP_NO_CALL_STATE;
    ph_ptr->call_state_info.subs_st[i][1].mode = SYS_SYS_MODE_NO_SRV;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ph_ptr->itc_aux_val_to_use = cmefs_get_itc_aux_val();
  CM_MSG_HIGH_1("ITC AUX Val %d",ph_ptr->itc_aux_val_to_use);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Undefine the plmn.
  */
  sys_plmn_undefine_plmn_id( &ph_ptr->main_stack_info.pref_info.plmn );
  /* Undefine PLMN for Persistent Hybr Stack Info */
  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    sys_plmn_undefine_plmn_id( &ph_ptr->prst_hybr_2_stack_info[i].plmn );
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  for( i=0; i < NV_MAX_NAMS; i++ )
  {
      sys_plmn_undefine_plmn_id( &ph_ptr->prst_hybr_3_stack_info[i].plmn );
  }

  #endif

  /* QMSS Parameters
  */
  cmph_read_qmss_enabled();
  for(i=0; i<cmph_get_ph_sub_config_size(); i++)
  {
    if(refresh_subs_mask & BM(i))
    {
      cmph_read_operator_name((sys_modem_as_id_e_type)i);

    }
  }

  cmph_read_operator_imsi();

  /*Device Model Info*/
  cmph_device_model_init();



  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (is_pwr_on)
  {
  /* Set the initial report delta threshold to 5dBm
  */
  ph_ptr->rssi_delta     = CMPH_DEFAULT_RSSI_DELTA;

  /* Set the initial report ecio delta threshold to 2dBm
  */
  ph_ptr->ecio_delta     = CMPH_DEFAULT_ECIO_DELTA;

  /* Set the initial report io delta threshold to 5dBm
  */
  ph_ptr->io_delta       = CMPH_DEFAULT_IO_DELTA;

  /* Set the initial report sir delta threshold to 3db
  */
  ph_ptr->sir_delta      = CMPH_DEFAULT_SIR_DELTA;

  /* Set the initial report pathloss delta threshold to 5db
  */
  ph_ptr->pathloss_delta = CMPH_DEFAULT_PATHLOSS_DELTA;

  /* Set the initial report cqi delta threshold to 1 dbm
  */
  ph_ptr->cqi_delta = CMPH_DEFAULT_CQI_DELTA;

  /* Set the initial report cqi delta threshold to 5 dbm
  */
  ph_ptr->rsrp_delta = CMPH_DEFAULT_RSRP_DELTA;

  /* Set the initial report cqi delta threshold to 5 dbm
  */
  ph_ptr->rsrq_delta = CMPH_DEFAULT_RSRQ_DELTA;
  /* Set the is_prl_load_complete flag to FALSE
  */
   ph_ptr->is_prl_load_complete   =  FALSE;

  /* Set the is_sys_sel_pref_rsp_pending/2 flag to FALSE
  ** Set the is_req_id_pending flag/2 to FALSE
  */
  ph_ptr->is_sys_sel_pref_rsp_pending = FALSE;
  ph_ptr->is_sys_sel_pref_rsp_pending2= FALSE;
  ph_ptr->is_req_id_pending  = FALSE;
  ph_ptr->is_req_id_pending2 = FALSE;
  ph_ptr->oprt_mode_send_time       = CMPH_MAX_UPTIME;
  ph_ptr->pwr_up_done               = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initially phone is not in use.
  */
  ph_ptr->is_in_use      = FALSE;
  ph_ptr->is_in_use_reported      = FALSE;
  ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_1]= 0;
  ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_2]= 0;
  #ifdef FEATURE_MMODE_TRIPLE_SIM
  ph_ptr->rat_disabled_mask[SYS_MODEM_AS_ID_3]= 0;
  #endif
  ph_ptr->is_sglte_device         = FALSE;

  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  ph_ptr->hybr2_is_in_use      = FALSE;
  ph_ptr->hybr2_is_in_use_reported      = FALSE;

  #if defined FEATURE_MMODE_SXLTE_G
  ph_ptr->hybr3_is_in_use      = FALSE;
  ph_ptr->hybr3_is_in_use_reported = FALSE;
  #endif
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef CM_GW_SUPPORTED
  /*
  ** The curr_nam field is a CDMA mode specific field.  However, the mode_pref
  ** field is dependent on the curr_name field.  A Curr Nam of CM_NAM_1 will
  ** always be used.
  */
  ph_ptr->curr_nam = CM_NAM_1;
  ph_ptr->nam_sel  = ph_ptr->curr_nam;
  #endif /* defined CM_GW_SUPPORTED */

  } //is_pwr_on

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initially phone is not CDMA locked until power-off
  */
  ph_ptr->cdma_lock_mode = CM_CDMA_LOCK_MODE_OFF;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initially we answer incoming voice calls as voice.
  ** Also update the answer-voice setting in the database
  ** to reflect this setting - MC consults it upon receiving
  ** a page.
  */
  ph_ptr->answer_voice     = CM_ANSWER_VOICE_AS_VOICE;
  db_item.voice_as_data    = DB_VOICE_AS_DATA_NEVER;
  db_put( DB_VOICE_AS_DATA, &db_item );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read from NV the current NAM selection.
  */
  cmnv_read_wait( NV_CURR_NAM_I, cmnv_item_ptr );
  ph_ptr->nam_sel = ph_ptr->curr_nam =(cm_nam_e_type)cmnv_item_ptr->curr_nam;

  /* If AUTO-NAM is selected, update the NAM SELECTION appropriately.
  */
  cmnv_read_wait( NV_AUTO_NAM_I, cmnv_item_ptr );
  if( cmnv_item_ptr->auto_nam )
  {
    ph_ptr->nam_sel = CM_NAM_AUTO;
  }
  #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Validate curr_nam */
  if(!INRANGE(ph_ptr->curr_nam, 0, (NV_MAX_NAMS-1)))
  {
    CM_ERR_1( "curr_nam is invalid, curr_nam:%d",ph_ptr->curr_nam);
    ph_ptr->curr_nam = CM_NAM_1;
    ph_ptr->nam_sel  = ph_ptr->curr_nam;
  }

    for(i=0; i<cmph_get_ph_sub_config_size(); i++)
    {
    if(refresh_subs_mask & BM(i))
    {
  /* Default set this to 0 */
      ph_ptr->sub_config[i].wcdma_freq_lock = 0;

  if ( cmefs_get( CMEFS_WCDMA_FREQ_LOCK,
                    (byte*)&wcdma_freq_lock,
                      sizeof(wcdma_freq_lock),
                      (sys_modem_as_id_e_type)i)
     )
  {
        ph_ptr->sub_config[i].wcdma_freq_lock = wcdma_freq_lock;
        CM_MSG_HIGH_2 ("EFS read succ. wcdma_freq_lock[%d]= %d",
                      i, ph_ptr->sub_config[i].wcdma_freq_lock);
      }
  }
  }

  /* Default set this to 0 */
  ph_ptr->refresh_vote_ok = FALSE;
  read_size = sizeof(ph_ptr->refresh_vote_ok);
  if ( cmefs_get2( "/nv/item_files/modem/uim/mmgsdi/refresh_vote_ok",
                    (byte*)&ph_ptr->refresh_vote_ok,
                   read_size,
                   SYS_MODEM_AS_ID_1)
     )
  {
    CM_MSG_HIGH_1 ("EFS read succ. refresh_vote_ok= %d",
                  ph_ptr->refresh_vote_ok);
  }

   /* set the manual plmn search in connected mode */
  read_size = sizeof(boolean);
  if( cmefs_get2("/nv/item_files/modem/nas/conn_mode_manual_search",
             &ph_ptr->mm_nv_conn_mode_manual_search,
                 read_size,
                 SYS_MODEM_AS_ID_1) )
  {
    CM_MSG_HIGH_1(" NV conn_mode_manual_search set to %d",ph_ptr->mm_nv_conn_mode_manual_search);
  }
  else
  {
    ph_ptr->mm_nv_conn_mode_manual_search = FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the NV Context of the Stacks
  */
  ph_ptr->main_stack_info.nv_context = 0;
  if(cmph_is_sxlte())
  {
    ph_ptr->hybr_2_stack_info.nv_context = 0;
  }
  else
  {
  ph_ptr->hybr_2_stack_info.nv_context = 1;
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  /* SXLTE_Q */
  if (cmph_is_sxlte())
  {
    ph_ptr->hybr_3_stack_info.nv_context = 1;
  }
  else
  {
    ph_ptr->hybr_3_stack_info.nv_context = 2;
  }
  #endif

  #ifdef CM_GW_SUPPORTED

  for(i=0; i<cmph_get_ph_sub_config_size(); i++)
  {
    if(refresh_subs_mask & BM(i))
    {
      cmnv_read_wait_extn (NV_GSM_AMR_CALL_CONFIG_I, cmnv_item_ptr, i);
      if(cmnv_item_ptr->gsm_amr_call_config)
      {
        ph_ptr->sub_config[i].is_gsm_amr_call_config_on = TRUE;
      }
      else
      {
        ph_ptr->sub_config[i].is_gsm_amr_call_config_on = FALSE;
      }
      cmnv_read_wait_extn (NV_UMTS_CALL_VT_CODEC_LIST_I, cmnv_item_ptr, i);
      if(cmnv_item_ptr->umts_call_vt_codec_list)
      {
      ph_ptr->sub_config[i].is_umts_call_vt_codec_list_on = TRUE;
      }
      else
      {
      ph_ptr->sub_config[i].is_umts_call_vt_codec_list_on = FALSE;
      }
    }
  }

  #endif

  for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
  {
    if(refresh_subs_mask & BM(i))
    {
      if(cmefs_get(CMEFS_IMS_ENABLE,
                   (byte*)&ph_ptr->sub_config[i].active_ims_stack,
                   sizeof(boolean),
                   (sys_modem_as_id_e_type)i) )
      {
        CM_MSG_HIGH_2("Sub %d EFS read succ. active_ims_stack= %d",
                    i, ph_ptr->sub_config[i].active_ims_stack);
      }
      else
      {
        ph_ptr->sub_config[i].active_ims_stack = SYS_IMS_STACK_STATUS_DISABLED;
        CM_MSG_HIGH_2("Sub %d default active_ims_stack = %d ", i, ph_ptr->sub_config[i].active_ims_stack);
      }
    }
  }

  /* Read information related to e911 customization EFS */
  {
    cmph_custom_emerg_call_info_s_type  e911_info;

    for(i=0; i<cmph_get_ph_sub_config_size(); i++)
    {
      if(refresh_subs_mask & BM(i))
      {
        if ( cmefs_get ( CMEFS_CUSTOM_EMERG_INFO,
                     (byte*)&e911_info,
                     sizeof(cmph_custom_emerg_call_info_s_type),
                      (sys_modem_as_id_e_type)i)
       )
        {
          ph_ptr->sub_config[i].is_ecbm_required = e911_info.is_ecbm_required;
          ph_ptr->sub_config[i].is_alternate_redial_algorithm = e911_info.is_alternate_redial_algorithm;
          ph_ptr->sub_config[i].hold_concurrent_voicecall_during_emergency =
                          e911_info.hold_concurrent_voicecall_during_emergency;
          ph_ptr->sub_config[i].is_wlan_e911_call_supp = e911_info.is_wlan_e911_call_supp;
          ph_ptr->sub_config[i].twwan_timer = e911_info.twwan_timer;
          CM_MSG_HIGH_3 ("e911: ecbm %d hold_call %d= %d", ph_ptr->sub_config[i].is_ecbm_required,
                     ph_ptr->sub_config[i].hold_concurrent_voicecall_during_emergency,
                     ph_ptr->sub_config[i].is_alternate_redial_algorithm );
          CM_MSG_HIGH_2("e911: wlan_e911_call_supp %d twwan_timer %d", ph_ptr->sub_config[i].is_wlan_e911_call_supp,
                   ph_ptr->sub_config[i].twwan_timer);
        }
        else
        {
          ph_ptr->sub_config[i].is_ecbm_required = FALSE;
          ph_ptr->sub_config[i].hold_concurrent_voicecall_during_emergency = FALSE;
          ph_ptr->sub_config[i].is_alternate_redial_algorithm = FALSE;
          ph_ptr->sub_config[i].is_wlan_e911_call_supp = FALSE;
          ph_ptr->sub_config[i].twwan_timer = 40;
        }
      }
    }
  }

  #if defined(FEATURE_IP_CALL) && defined(FEATURE_CM_LTE)
  /* Read information related to mid call SRVCC support */
  {
    for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
    {
      if(refresh_subs_mask & BM(i))
      {
        cmph_mid_call_srvcc_info_s_type mid_srvcc_info;

        if ( cmefs_get ( CMEFS_MID_SRVCC,
                           (byte*)&mid_srvcc_info,
                           sizeof(cmph_mid_call_srvcc_info_s_type),
                           (sys_modem_as_id_e_type)i)
           )
        {
          CM_MSG_HIGH_1("Sub %d read CMEFS_MID_SRVCC success", i);

          ph_ptr->sub_config[i].mid_call_support = mid_srvcc_info.mid_call_support;
          ph_ptr->sub_config[i].ims_cache_expiry_duration = mid_srvcc_info.ims_cache_expiry_duration;

          /* if timer value is out of range (>5000 ms) , set default timer of 1000 ms */
          if(ph_ptr->sub_config[i].mid_call_support &&
                   ph_ptr->sub_config[i].ims_cache_expiry_duration > 5000 )
          {
            ph_ptr->sub_config[i].ims_cache_expiry_duration = 1000;
          }
          /* Safe to set timer expiry even if it is not set */
          else if(!ph_ptr->sub_config[i].mid_call_support)
          {
            ph_ptr->sub_config[i].ims_cache_expiry_duration = 0;
          }

          if(mid_srvcc_info.version >= 2)
          {
           if(mid_srvcc_info.srvcc_sync_support == TRUE)
           {
             /* For UT purpose if value is set properly then take that value, else set it to false */
             ph_ptr->sub_config[i].srvcc_sync_support = TRUE;
           }
           else
           {
             /* srvcc_sync: for test purpose */
             ph_ptr->sub_config[i].srvcc_sync_support = FALSE;
           }
          }
           /* mid_srvcc_info.version < 2 */
          else
          {
            ph_ptr->sub_config[i].srvcc_sync_support = TRUE; /* sync_srvcc functionality is now by default TRUE;  EFS file version is old */
          }

        }
        /* NV not set */
        else
        {
          CM_MSG_HIGH_1("Sub %d read CMEFS_MID_SRVCC failed, set default to FALSE", i);
          ph_ptr->sub_config[i].mid_call_support =FALSE;
          ph_ptr->sub_config[i].srvcc_sync_support = TRUE; /* sync_srvcc functionality is now by default TRUE*/
        }
      }
      CM_MSG_HIGH_3("Mid call SRVCC cache expiry duration is %d, mid call support present %d, srvcc_sync_support %d",
                      ph_ptr->sub_config[i].ims_cache_expiry_duration,
                      ph_ptr->sub_config[i].mid_call_support,
                      ph_ptr->sub_config[i].srvcc_sync_support);
    }
  }
  #endif

  cmph_volte_ctrl_init(refresh_subs_mask);

  #if defined(FEATURE_IP_CALL) && defined(FEATURE_CM_LTE)
  /* Read information related to wifi configuration */
  for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
  {
    if(refresh_subs_mask & BM(i))
    {
      cmph_custom_vowifi_config_s_type wifi_config;
      cm_volte_ctrl_s_type            *volte_ptr   = cmph_volte_ptr();

      if(cmefs_get(CMEFS_CUSTOM_VOWIFI_CONFIG,
                       (byte*)&wifi_config,
                       sizeof(cmph_custom_vowifi_config_s_type),
                       (sys_modem_as_id_e_type)i)
        )
      {
        CM_MSG_HIGH_3("Sub %d read CMEFS_CUSTOM_VOWIFI_CONFIG success, wifi_e911_support %d, voice_in_wifi_only %d",
                          i,
                          ph_ptr->sub_config[i].wifi_e911_support,
                          ph_ptr->sub_config[i].voice_in_wifi_only);

        ph_ptr->sub_config[i].wifi_e911_support = wifi_config.is_e911_over_wifi;
        ph_ptr->sub_config[i].voice_in_wifi_only = wifi_config.is_wifi_only_mode_for_voice;
        ph_ptr->sub_config[i].wifi_cs_scan_timer = wifi_config.wifi_cs_scan_timer;
        ph_ptr->sub_config[i].wifi_e911_wwan_full_srv = wifi_config.wifi_e911_wwan_full_srv;
        volte_ptr->volte_sub_info[i].volte_special_pref_setting = wifi_config.volte_special_pref_setting;

      }
      else /* NV not set */
      {
        CM_MSG_HIGH_3("Sub %d read CMEFS_CUSTOM_VOWIFI_CONFIG failed, set defualt wifi_e911_support %d, voice_in_wifi_only %d",
                          i,
                          ph_ptr->sub_config[i].wifi_e911_support,
                          ph_ptr->sub_config[i].voice_in_wifi_only);

        ph_ptr->sub_config[i].wifi_e911_support = FALSE;
        ph_ptr->sub_config[i].voice_in_wifi_only = FALSE;
        ph_ptr->sub_config[i].wifi_cs_scan_timer = 5; /* time in secs */
        ph_ptr->sub_config[i].wifi_e911_wwan_full_srv = FALSE;
        volte_ptr->volte_sub_info[i].volte_special_pref_setting = FALSE;
      }
    }
  }
  /* Read information related to EMCALL_TO_NORMAL_VOICECALL configuration */
  {
    for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
    {
      if(refresh_subs_mask & BM(i))
      {
        boolean emcall_to_voice;
        if ( cmefs_get(CMEFS_EMCALL_TO_NORMAL_VOICECALL,
                        (byte*)&emcall_to_voice,
                        sizeof(boolean),
                        (sys_modem_as_id_e_type)i)
          )
        {
          ph_ptr->sub_config[i].emcall_to_voicecall = emcall_to_voice;
          CM_MSG_HIGH_2("Sub %d read Success: e911 call to normal voice call = %d",
                       i, ph_ptr->sub_config[i].emcall_to_voicecall);
        }
        else /* NV not set */
        {
          emcall_to_voice = FALSE;
          ph_ptr->sub_config[i].emcall_to_voicecall = emcall_to_voice;
  
          CM_MSG_HIGH_2("Sub %d read failed.  Default: e911 call to normal voice call = %d",
                       i, ph_ptr->sub_config[i].emcall_to_voicecall);
  
        }
      }
    }
  }

  #endif

  #ifdef FEATURE_RAT_PRIORITY_LIST
  /* Read RAT acquisition order from EFS NV
  */
  for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
  {
    if(refresh_subs_mask & BM(i))
    {
      if(!cmpmprx_get_rat_acq_order_pref((sys_modem_as_id_e_type)i,
                                          &ph_ptr->sub_config[i].rat_acq_order_pref))
      {
        CM_MSG_HIGH_1("Fail to get rat_acq_order (TOT) for sub %d from PM", i);
      }
    }
  }
  #else
  /* If rat priority list is not defind, fill the default value
  */
  for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
  {
    if(refresh_subs_mask & BM(i))
    {
      ph_ptr->sub_config[i].rat_acq_order_pref.num_rat = 0;
    }
  }
  #endif /* FEATURE_RAT_PRIORITY_LIST */

  /* Currently 1x is supported only on sub 1 on MAIN stack. Hence NV is read
  **  from MAIN stack. When 1x is made availabled on sub 2 also NV should be
  ** be read and stored in corresponding stack's nv context
  */
  for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
  {
    if(refresh_subs_mask & BM(i))
    {
      if(cmefs_get( CMEFS_ALLOW_SMS_IN_ECBM,
                    (byte*)&(ph_ptr->sub_config[i].is_allow_sms_in_ecbm_enabled),
                    sizeof(boolean),
                    (sys_modem_as_id_e_type)i))
      {
        CM_MSG_HIGH_2("Sub %d EFS read for CMEFS_ALLOW_SMS_IN_ECBM success is_allow_sms_in_ecbm_enabled - %d",
                      i, ph_ptr->sub_config[i].is_allow_sms_in_ecbm_enabled);
      }
      else
      {
        CM_MSG_HIGH_1("Sub %d CMEFS_ALLOW_SMS_IN_ECBM efs read failed", i);
        ph_ptr->sub_config[i].is_allow_sms_in_ecbm_enabled = FALSE;
      }
    }
  }
  {
    read_size = sizeof(boolean);
    for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
    {
      if(refresh_subs_mask & BM(i))
      {
        if ( cmefs_get ( CMEFS_VOLTE_SR_CONTROL,
                         (byte*)&(ph_ptr->sub_config[i].volte_sr_control),
                         read_size,
                         (sys_modem_as_id_e_type)i) )
        {
          CM_MSG_HIGH_2("Domsel: Sub %d read CMEFS_VOLTE_SR_CONTROL success, volte_sr_control = %d",\
                          i, ph_ptr->sub_config[i].volte_sr_control );
        }
        else
        {
          CM_MSG_HIGH_1("Domsel: Sub %d read CMEFS_VOLTE_SR_CONTROL failed, set default to FALSE", i);
          ph_ptr->sub_config[i].volte_sr_control = FALSE;
        }
      }
    }
  }

  for(i=0; i<cmph_get_ph_sub_config_size(); i++)
  {
    cmph_skip_gw_scan_during_rlf skip_gw_scan;
    if(refresh_subs_mask & BM(i))
    {
      if(cmefs_get( CMEFS_SKIP_GWT_SCAN_DURING_RLF,
                        (byte*)&skip_gw_scan,
                         sizeof(cmph_skip_gw_scan_during_rlf),
                             (sys_modem_as_id_e_type)i))
      {
        ph_ptr->sub_config[i].skip_gw_scan_during_rlf = skip_gw_scan.skip_gwt_scan;
        CM_MSG_HIGH_1("EFS read for GW scan skip during RLF -  %d",
                      ph_ptr->sub_config[i].skip_gw_scan_during_rlf);
      }
      else
      {
        ph_ptr->sub_config[i].skip_gw_scan_during_rlf = FALSE;
        CM_MSG_HIGH_0("efs  read failed for skipping GW scan  ");
      }
    }
  }
  {
    cmph_emerg_lte_redial lte_emerg_redial;
    for(i = 0; i < cmph_get_ph_sub_config_size(); i++)
    {
      if(refresh_subs_mask & BM(i))
      {
        if(cmefs_get(CMEFS_ALLOW_CS_TO_PS_EMERG_REDIAL,
                     (byte*)&lte_emerg_redial,
                     sizeof(cmph_emerg_lte_redial),
                     (sys_modem_as_id_e_type)i))
        {
          ph_ptr->sub_config[i].redial_emerg_on_lte = lte_emerg_redial.redial_on_lte;
          if(lte_emerg_redial.cs_favoured_retry_count!=0)
          {
	        ph_ptr->sub_config[i].cs_favoured_redial_counter =lte_emerg_redial.cs_favoured_retry_count;
          }
          else
          {
            ph_ptr->sub_config[i].cs_favoured_redial_counter =CMPH_MAX_CS_REDIAL_COUNT_FOR_EMERG;
          }
          CM_MSG_HIGH_3("E911 redial over LTE enabled -  %d, cs_fav_redial_counter:%d,version:%d",
                  ph_ptr->sub_config[i].redial_emerg_on_lte,ph_ptr->sub_config[i].cs_favoured_redial_counter,
		  lte_emerg_redial.version );

        }
        else
        {
          ph_ptr->sub_config[i].redial_emerg_on_lte = FALSE;
	      ph_ptr->sub_config[i].cs_favoured_redial_counter =CMPH_MAX_CS_REDIAL_COUNT_FOR_EMERG;
          CM_MSG_HIGH_1(" Sub %d efs  read failed for e911 redial on LTE, setting default", i);
        }
      }
    }
  }
  if(refresh_subs_mask & BM(SYS_MODEM_AS_ID_1))
  {
    if(cmefs_get(CMEFS_CDMA_HOLD_SRV_TIMER,
               (byte *)&(ph_ptr->cdma_hold_srv_timer),
               sizeof(ph_ptr->cdma_hold_srv_timer),
               SYS_MODEM_AS_ID_1))
    {
      CM_MSG_HIGH_1("CDMA hold srv duration %d", ph_ptr->cdma_hold_srv_timer);
    }
    else
    {
      ph_ptr->cdma_hold_srv_timer = CMSS_CDMA_HOLD_SRV_TIMER;
    }
  }
  {
    boolean is_cdma_less_device;
    for(i=0; i<cmph_get_ph_sub_config_size(); i++)
    {
      if(refresh_subs_mask & BM(i))
      {
        /* Default set this to 0 */
        ph_ptr->sub_config[i].is_cdma_less_device = FALSE;

        if ( cmefs_get( CMEFS_CDMA_LESS_DEVICE,
                        (byte*)&is_cdma_less_device,
                          sizeof(boolean),
                          (sys_modem_as_id_e_type)i)
           )
        {
          ph_ptr->sub_config[i].is_cdma_less_device = is_cdma_less_device;
          CM_MSG_HIGH_2 ("EFS read succ. is_cdma_less_device[%d]= %d",
                        i, ph_ptr->sub_config[i].is_cdma_less_device);
        }
      }
    }
  }
  #ifdef  FEATURE_VOIP_E911_SUPPORT
  /* Read voip_cancel_retry_timer from NV
  */
  for(i=0; i<cmph_get_ph_sub_config_size(); i++)
  {
    if(refresh_subs_mask & BM(i))
    {
      cmnv_read_wait_extn( NV_VOIP_CANCEL_RETRY_TIMER_I, cmnv_item_ptr, i);
      ph_ptr->sub_config[i].voip_cancel_retry_period = cmnv_item_ptr->voip_cancel_retry_timer;
      if(ph_ptr->sub_config[i].voip_cancel_retry_period > CM_MAX_VOIP_CANCEL_RETRY_TIME)
      {
        ph_ptr->sub_config[i].voip_cancel_retry_period= CM_DEFAULT_VOIP_CANCEL_RETRY_TIME;
      }
    }
  }
  #endif //  FEATURE_VOIP_E911_SUPPORT

  if ( !is_pwr_on &&
       !( BM(ph_ptr->main_stack_info.nv_context) & refresh_subs_mask))
  {
    CM_MSG_HIGH_0("MCFGrefresh: no Main init");
    return;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read from NV the persistent mode preference
  ** for each NAM.
  */
  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Read Main stack mode preference */
    cmnv_item_ptr->pref_mode.nam = (byte) i;
    cmnv_read_wait( NV_PREF_MODE_I, cmnv_item_ptr );
    ph_ptr->prst_main_stack_info[i].mode_pref = cmph_map_mode_pref_nv2cm( cmnv_item_ptr->pref_mode.mode );

    /* For targets that DO not support Analog Call Processing (ACP),
    ** always default the mode to DIGITAL ONLY.
    */
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))

    /* This is for 1x only or multimode
    */
    ph_ptr->prst_main_stack_info[i].mode_pref= remove_amps_from_cm_mode_pref(ph_ptr->prst_main_stack_info[i].mode_pref);

    #else /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

    /* This is for GW only, not multimode
    */
    #if defined(FEATURE_WCDMA) && !defined(FEATURE_GSM)
    /*
    ** Single mode WCDMA.
    */

    if ( ph_ptr->prst_main_stack_info[i].mode_pref != CM_MODE_PREF_WCDMA_ONLY &&
         ph_ptr->prst_main_stack_info[i].mode_pref != CM_MODE_PREF_TDS_ONLY)
    {
      /*
      ** Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_main_stack_info[i].mode_pref     = CM_MODE_PREF_WCDMA_ONLY;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_main_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait(NV_PREF_MODE_I, cmnv_item_ptr);
      #endif
    } /* if ! CM_MODE_PREF_WCDMA_ONLY */
    #endif /* FEATURE_WCDMA && !FEATURE_GSM */

    #if defined(FEATURE_GSM) && !defined(FEATURE_WCDMA)
    /*
    ** Single mode GSM.
    **/
    if ( ph_ptr->prst_main_stack_info[i].mode_pref!= CM_MODE_PREF_GSM_ONLY &&
         ph_ptr->prst_main_stack_info[i].mode_pref!= CM_MODE_PREF_TDS_ONLY    )
    {
      /*
      ** Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_main_stack_info[i].mode_pref     = CM_MODE_PREF_GSM_ONLY;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_main_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait(NV_PREF_MODE_I, cmnv_item_ptr);
      #endif
    } /* if ! CM_MODE_PREF_GSM_ONLY */
    #endif /* FEATURE_GSM, & !FEATURE_WCDMA &!FEATURE_TDSCDMA */

    #ifdef CM_GW_SUPPORTED
    /*
    ** Dual mode GSM/WCDMA.
    **/
    /*lint -save -e655 -e525 */


    if ( (ph_ptr->prst_main_stack_info[i].mode_pref != CM_MODE_PREF_TDS_ONLY) &&
        !(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->prst_main_stack_info[i].mode_pref) &
          SD_SS_MODE_PREF_GWL ))
    {
      /*
      ** Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_main_stack_info[i].mode_pref    = CM_MODE_PREF_AUTOMATIC;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_main_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait(NV_PREF_MODE_I, cmnv_item_ptr);
      #endif
    }
    /*lint -restore */
    #endif /* FEATURE_GSM, FEATURE_WCDMA */
    #endif /* else of (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

    if(ph_ptr->sub_config[0].wcdma_freq_lock)
    {
      CM_MSG_HIGH_1("W locked, ph mode pref was = %d, now WCDMA only",
                     ph_ptr->prst_main_stack_info[i].mode_pref);
      /*
      ** Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_main_stack_info[i].mode_pref    = CM_MODE_PREF_WCDMA_ONLY;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_main_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait(NV_PREF_MODE_I, cmnv_item_ptr);
      #endif
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize svlte and svdo */
  ph_ptr->is_svlte_supported = FALSE;
  ph_ptr->is_svdo_supported = FALSE;

  cmph_init_config_hybr_pref();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read from NV the persistent band preference
  ** for each NAM.
  */
  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cm_nv_band_pref_u_type  temp;
    uint64                  band_pref_32_63;
    uint64                  temp1;

    /* Read the Band Preference from NV for subscription 1
    */
    cmnv_item_ptr->band_pref.nam = (byte) i;
    cmnv_read_wait( NV_BAND_PREF_I, cmnv_item_ptr );
    temp.nv_band_pref[0] = (uint16)cmnv_item_ptr->band_pref.band;

    cmnv_read_wait( NV_BAND_PREF_16_31_I, cmnv_item_ptr );
    temp.nv_band_pref[1] = (uint16)cmnv_item_ptr->band_pref.band;

    cmnv_read_wait( NV_BAND_PREF_32_63_I, cmnv_item_ptr );
    band_pref_32_63 = (uint32)cmnv_item_ptr->band_pref_32_63.band;

    /* Copy Bits 0-31 in temporary variable.
    */
    temp1 = temp.dummy;

    /* Move bits 32-63 to its desired position and insert bits 0-31.
    */
    ph_ptr->prst_main_stack_info[i].band_pref =  temp1 | (uint64)(band_pref_32_63 << 32);

    /* If the band pref is not a valid value, write a valid value into NV (ANY) */
    if (ph_ptr->prst_main_stack_info[i].band_pref >= CM_BAND_PREF_MAX)
    {
       ph_ptr->prst_main_stack_info[i].band_pref= CM_BAND_PREF_ANY;
       cmnv_item_ptr->band_pref.nam  = (byte) i;
       cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)CM_BAND_PREF_ANY;
                                      //NV_BAND_PREF_ANY;
       #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
       cmnv_write_wait (NV_BAND_PREF_I, cmnv_item_ptr);
       #endif

       cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)(CM_BAND_PREF_ANY >> 16);
                                      //((word)NV_BAND_PREF_ANY & 0x7FFF);
       #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
       cmnv_write_wait (NV_BAND_PREF_16_31_I, cmnv_item_ptr);
       #endif

       cmnv_item_ptr->band_pref_32_63.band = (uint32)(CM_BAND_PREF_ANY >> 32);
                                      //((word)NV_BAND_PREF_ANY & 0x3FFF);
       #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
       cmnv_write_wait (NV_BAND_PREF_32_63_I, cmnv_item_ptr);
       #endif

    }

   /* Read from EFS the persistent LTE band preference. It is currently not
   ** on a per NAM basis. There is a single file for all NAMs
   */
    #ifdef FEATURE_CM_LTE
    { 
      cm_band_pref_e_type lte_bands_1_64;
      #if(LTE_BAND_NUM == 256)
      sys_lte_band_mask_e_type lte_band_pref;
      read_persistent_lte_extn_band_pref( &lte_band_pref, ph_ptr->main_stack_info.asubs_id);
      #endif
      read_persistent_band_pref(CMEFS_ID_LTE_BANDPREF,
                              &lte_bands_1_64,
                              ph_ptr->main_stack_info.asubs_id);

      #if(LTE_BAND_NUM == 256)
      lte_band_pref.bits_1_64 = lte_bands_1_64;
      ph_ptr->prst_main_stack_info[i].lte_band_pref = lte_band_pref;
      #else
      ph_ptr->prst_main_stack_info[i].lte_band_pref = lte_bands_1_64;
      #endif
    }
    #else
    ph_ptr->prst_main_stack_info[i].lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
    #endif

    read_persistent_band_pref(CMEFS_ID_TDS_BANDPREF,
                              &(ph_ptr->prst_main_stack_info[i].tds_band_pref),
                              ph_ptr->main_stack_info.asubs_id);

    /* If target or PRL oes not support the specified mode and band preference
    ** combination, set the mode and band preference to their default
    ** values.
    */
    if( ! sd_misc_is_supp_pref(
          cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->prst_main_stack_info[i].mode_pref),
             cmph_map_cm_band_pref_to_sd_band_pref(ph_ptr->prst_main_stack_info[i].band_pref ))
        &&
        ! sd_misc_is_supp_pref_tds(
             cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->prst_main_stack_info[i].mode_pref),
             cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(ph_ptr->prst_main_stack_info[i].tds_band_pref))

        #ifdef FEATURE_CM_LTE
        &&
        ! sd_misc_is_supp_pref_lte(
          cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->prst_main_stack_info[i].mode_pref),
          ph_ptr->prst_main_stack_info[i].lte_band_pref)
        #endif
      )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_main_stack_info[i].mode_pref     = CM_MODE_PREF_AUTOMATIC;
      cmnv_item_ptr->pref_mode.nam  = (byte) i;
      cmnv_item_ptr->pref_mode.mode = NV_MODE_AUTOMATIC;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait(NV_PREF_MODE_I, cmnv_item_ptr);
      #endif

      /* Default the band preference and write it back to NV.
      */
      ph_ptr->prst_main_stack_info[i].band_pref    = CM_BAND_PREF_ANY;
      cmnv_item_ptr->band_pref.nam  = (byte) i;
      cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)CM_BAND_PREF_ANY;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait(NV_BAND_PREF_I, cmnv_item_ptr);
      #endif
      cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)(CM_BAND_PREF_ANY >> 16 );
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait(NV_BAND_PREF_16_31_I, cmnv_item_ptr);
      #endif
      cmnv_item_ptr->band_pref_32_63.band = (uint32)(CM_BAND_PREF_ANY >> 32 );
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait (NV_BAND_PREF_32_63_I, cmnv_item_ptr);
      #endif

      /*Set default value of LTE band pref and write it back to NV
      */
      #ifdef FEATURE_CM_LTE
      ph_ptr->prst_main_stack_info[i].lte_band_pref  = SYS_LTE_BAND_MASK_CONST_ANY;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      {
        #if( LTE_BAND_NUM == 256 )
        bit_mask_192_ext_s_type lte_band_pref_65_256;

        lte_band_pref_65_256.bits_65_128  = ph_ptr->prst_main_stack_info[i].lte_band_pref.bits_65_128;
        lte_band_pref_65_256.bits_129_192 = ph_ptr->prst_main_stack_info[i].lte_band_pref.bits_129_192;
        lte_band_pref_65_256.bits_193_256 = ph_ptr->prst_main_stack_info[i].lte_band_pref.bits_193_256;
        cmefs_fs_write(CMEFS_ID_LTE_BANDPREF_65_256,
                       (byte *)&lte_band_pref_65_256,
                       sizeof(bit_mask_192_ext_s_type),
                       ph_ptr->main_stack_info.asubs_id);

        cmefs_fs_write(CMEFS_ID_LTE_BANDPREF,
                       (byte *)&(ph_ptr->prst_main_stack_info[i].lte_band_pref.bits_1_64),
                       sizeof(cm_band_pref_e_type),
                       ph_ptr->main_stack_info.asubs_id);
        #else
        cmefs_fs_write(CMEFS_ID_LTE_BANDPREF,
                     (byte *)&(ph_ptr->prst_main_stack_info[i].lte_band_pref),
                     sizeof(cm_band_pref_e_type),
                     ph_ptr->main_stack_info.asubs_id);
        #endif
      }
      #endif

      #else
      ph_ptr->prst_main_stack_info[i].lte_band_pref  = SYS_LTE_BAND_MASK_CONST_NONE;
      #endif

      ph_ptr->prst_main_stack_info[i].tds_band_pref = CM_BAND_PREF_TDS_ANY;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmefs_fs_write(CMEFS_ID_TDS_BANDPREF,
                     (byte *)&(ph_ptr->prst_main_stack_info[i].tds_band_pref),
                     sizeof(cm_band_pref_e_type),
                     ph_ptr->main_stack_info.asubs_id);
      #endif

    }
        
    /* Store the mode pref as prst_main_stack_info[i].mode_pref is determined */
    ph_ptr->prst_main_stack_info[i].init_mode_pref= ph_ptr->prst_main_stack_info[i].mode_pref;

    if (cmph_is_msim())
    {
      if(!cmph_is_sxlte())
      {
        /* If WCDMA or TDSCDMA or LTE is already set on main, set hybr2 stack to GSM Only
         */
        if ( cmph_is_multimode_pref(ph_ptr->prst_main_stack_info[i].mode_pref) &&
           cmph_is_multimode_pref(ph_ptr->prst_hybr_2_stack_info[i].mode_pref))
        {
          ph_ptr->prst_hybr_2_stack_info[i].mode_pref     = CM_MODE_PREF_GSM_ONLY;
          
          cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_2_stack_info[i].mode_pref );
          cmnv_item_ptr->pref_mode.nam  = (byte) i;
          cmnv_write_wait_extn(NV_PREF_MODE_I, cmnv_item_ptr,
                               ph_ptr->hybr_2_stack_info.nv_context);
        }

        /* Store the mode pref as prst_hybr_2_stack_info[i].mode_pref is determined */
        ph_ptr->prst_hybr_2_stack_info[i].init_mode_pref= ph_ptr->prst_hybr_2_stack_info[i].mode_pref;

        /* 3GPP2 is only supported on sub1 */
        cmph_msim_remove_3gpp2_mode_pref(&(ph_ptr->prst_hybr_2_stack_info[i].mode_pref));
      }

      #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
      /* Store the mode pref as prst_hybr_3_stack_info[i].mode_pref is determined */
      ph_ptr->prst_hybr_3_stack_info[i].init_mode_pref= ph_ptr->prst_hybr_3_stack_info[i].mode_pref;

      /* 3GPP2 is only supported on sub1 */
      cmph_msim_remove_3gpp2_mode_pref(&(ph_ptr->prst_hybr_3_stack_info[i].mode_pref));
      #endif

    }

  /* Copy the persistent mode preference of the current NAM
  ** to our mode preference variable.
  */
  ph_ptr->main_stack_info.pref_info.mode_pref = CMPH_PRST_MODE_PREF( ph_ptr );
  ph_ptr->main_stack_info.pref_info.user_mode_pref = CMPH_PRST_MODE_PREF( ph_ptr );
  if (cmph_is_msim())
  {
    if (!cmph_no_hybr2())
    {
    ph_ptr->hybr_2_stack_info.pref_info.mode_pref =
                    ph_ptr->prst_hybr_2_stack_info[ph_ptr->curr_nam].mode_pref;
    }
                    
    #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
    ph_ptr->hybr_3_stack_info.pref_info.mode_pref =
                      ph_ptr->prst_hybr_3_stack_info[ph_ptr->curr_nam].mode_pref;
    #endif
    }

    /*Mode_pref in init should not be changed beyond this point*/
  }

  /* Copy the persistent mode and band preferences of the current NAM
  ** to our mode and band preference variables.
  */
  ph_ptr->main_stack_info.pref_info.mode_pref = CMPH_PRST_MODE_PREF( ph_ptr );
  ph_ptr->main_stack_info.pref_info.band_pref = CMPH_PRST_BAND_PREF( ph_ptr );
  ph_ptr->main_stack_info.pref_info.lte_band_pref = CMPH_PRST_LTE_BAND_PREF( ph_ptr );
  ph_ptr->main_stack_info.pref_info.tds_band_pref = CMPH_PRST_TDS_BAND_PREF( ph_ptr );

  cmstats_ptr()->prm.cm_info.ph_info.mode_pref =
                (sys_stats_mode_pref_e_type) ( ph_ptr->main_stack_info.pref_info.mode_pref );
  cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read from NV the persistent prl preference
  ** for each NAM.
  */
  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_item_ptr->prl_pref.nam = (byte) i;
    cmnv_read_wait( NV_PRL_PREF_I, cmnv_item_ptr );
    ph_ptr->prst_main_stack_info[i].prl_pref =
     (cm_prl_pref_e_type) (cmnv_item_ptr->prl_pref.prl);

    /* If the prl preference is out of bound, set the prl preference to its
    ** default value.
    */
    if( ph_ptr->prst_main_stack_info[i].prl_pref != CM_PRL_PREF_AVAIL_BC0_A &&
        ph_ptr->prst_main_stack_info[i].prl_pref != CM_PRL_PREF_AVAIL_BC0_B &&
        ph_ptr->prst_main_stack_info[i].prl_pref != CM_PRL_PREF_ANY )
    {
      ph_ptr->prst_main_stack_info[i].prl_pref     = CM_PRL_PREF_ANY;
      cmnv_item_ptr->prl_pref.nam  = (byte) i;
      cmnv_item_ptr->prl_pref.prl =  (uint32) CM_PRL_PREF_ANY;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait(NV_PRL_PREF_I, cmnv_item_ptr);
      #endif
    }
  }

  /* Copy the persistent prl preference of the current NAM
  ** to our prl preference variable.
  */
  ph_ptr->main_stack_info.pref_info.prl_pref = CMPH_PRST_PRL_PREF( ph_ptr );

  cmstats_ptr()->prm.cm_info.ph_info.pref_sys =
       cmstats_map_cm_prl_pref_to_sys_prl_pref ( ph_ptr->main_stack_info.pref_info.prl_pref );
  cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read from NV the persistent roam preference
  ** for each NAM.
  */
  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_item_ptr->roam_pref.nam = (byte) i;
    cmnv_read_wait( NV_ROAM_PREF_I, cmnv_item_ptr );
    ph_ptr->prst_main_stack_info[i].roam_pref =
     (cm_roam_pref_e_type) (cmnv_item_ptr->roam_pref.roam);

    /* If the roam preference is out of bound, set the roam preference to its
    ** deflate value.
    */
    if( ! BETWEEN(ph_ptr->prst_main_stack_info[i].roam_pref, CM_ROAM_PREF_NONE,
      CM_ROAM_PREF_NO_CHANGE) )
    {
      ph_ptr->prst_main_stack_info[i].roam_pref     = CM_ROAM_PREF_ANY;
      cmnv_item_ptr->roam_pref.nam  = (byte) i;
      cmnv_item_ptr->roam_pref.roam = (nv_roam_pref_enum_type)
                                      SD_SS_ROAM_PREF_ANY;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait(NV_ROAM_PREF_I, cmnv_item_ptr);
      #endif
    }
  }

  /* Copy the persistent roam preference of the current NAM
  ** to our roam preference variable.
  */
  ph_ptr->main_stack_info.pref_info.roam_pref = CMPH_PRST_ROAM_PREF( ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize is_spc_zero.
  */
  ph_ptr->is_spc_zero  = FALSE;

  /* Initialize RTRE settings. */

  cmph_init_rtre_settings( &ph_ptr->rtre_config, &ph_ptr->rtre_control);


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initially packet state is NULL.
  */
  ph_ptr->packet_state = CM_PACKET_STATE_NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize suspend status to FALSE at power up for all stacks
  */

  for( i = 0 ; i < (int)CM_SS_MAX ; i++)
  {
    ph_ptr->ss_susp_info[i].num_requests = 0;
    ph_ptr->ss_susp_info[i].is_suspend = FALSE;
  }
  #ifdef FEATURE_MMODE_SC_SVLTE
  ph_ptr->is_1x_await_response = FALSE;
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read mob_cai_rev (p_rev) from NV
  */
  cmnv_read_wait( NV_MOB_CAI_REV_I, cmnv_item_ptr );
  ph_ptr->mob_cai_rev = cmnv_item_ptr->mob_cai_rev;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef  FEATURE_VOIP_E911_SUPPORT
  /* Read the values of voip cancel retry timer and 1x completion timer from
  ** NV. To be used for voip redial of emergency calls. Both timers can
  ** have values in the range (0,120).
  ** 0 indicates that the timer is disabled
  ** If NV read is unsuccessful, the default value is 10s for both timers
  ** Any value greater than 120 is also defaulted to 10.
  */
  /* Read cs_to_voip_fallback_timer from NV
  */
  cmnv_read_wait( NV_CS_TO_VOIP_FALLBACK_TIMER_I, cmnv_item_ptr );
  ph_ptr->cs_to_voip_fallback_period =
                                    cmnv_item_ptr->cs_to_voip_fallback_timer;
  if(ph_ptr->cs_to_voip_fallback_period > CM_MAX_CS_TO_VOIP_FALLBACK_TIME)
  {
    ph_ptr->cs_to_voip_fallback_period = CM_DEFAULT_CS_TO_VOIP_FALLBACK_TIME;
  }

  #endif //  FEATURE_VOIP_E911_SUPPORT
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef CM_GW_SUPPORTED

  /* Initialize both ens and rat_bal flags to 0 */
  ph_ptr->main_stack_info.ens_value = 0;
  ph_ptr->is_rat_bal = 0;

  /* Read the NV_ENS_ENABLED_I from NV */
  cmnv_read_wait( NV_ENS_ENABLED_I, cmnv_item_ptr );
  ph_ptr->main_stack_info.ens_value = cmnv_item_ptr->ens_enabled;

  /* If ENS is enabled, also attempt to read the RAT Balancing value
  ** from EFS.
  */
  if ( ph_ptr->main_stack_info.ens_value ){
    if (cmefs_get ( CMEFS_ENS_SUB_FEATURES,
                    (byte*)&ens_subfeatures,
                    sizeof(mmgsdi_ens_sub_features_status_list_type),
                    SYS_MODEM_AS_ID_1))
    {
      ph_ptr->is_rat_bal = ens_subfeatures.rat_balancing_support;
    }
    else
    {
      /* If ens_value is TRUE, default RAT balancing value is true */
      ph_ptr->is_rat_bal = TRUE;
    }
  }

  CM_MSG_HIGH_2("RAT Balancing [ens]:%d [rat-bal]:%d\n",
              ph_ptr->main_stack_info.ens_value, ph_ptr->is_rat_bal);

  /* Initialize is_uim_usim_rat_present to FALSE.
  ** While reading SIM card, if UIM_USIM_RAT is present,
  ** set this value to TRUE
  */
  ph_ptr->is_uim_usim_rat_present = FALSE;

  #endif /* CM_GW_SUPPORTED */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read from NV the persistent acquisition order preference
  ** for each NAM.
  */
  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    #ifdef CM_GW_SUPPORTED
    cmnv_item_ptr->acq_order_pref.nam = (byte) i;
    cmnv_read_wait( NV_ACQ_ORDER_PREF_I, cmnv_item_ptr );

    ph_ptr->prst_main_stack_info[i].acq_order_pref =
       acq_order_pref_nv2cm( cmnv_item_ptr->acq_order_pref.acq_order );

    if( ( ph_ptr->prst_main_stack_info[i].acq_order_pref  != CM_GW_ACQ_ORDER_PREF_AUTOMATIC ) &&
        ( ph_ptr->prst_main_stack_info[i].acq_order_pref  != CM_GW_ACQ_ORDER_PREF_WCDMA_GSM ) &&
        ( ph_ptr->prst_main_stack_info[i].acq_order_pref  != CM_GW_ACQ_ORDER_PREF_GSM_WCDMA )    )
    {
      /*
      ** Default the acquistion order preference and write it back to NV.
      */
      #ifdef FEATURE_WCDMA
      ph_ptr->prst_main_stack_info[i].acq_order_pref           = CM_GW_ACQ_ORDER_PREF_WCDMA_GSM;
      #else
      ph_ptr->prst_main_stack_info[i].acq_order_pref           = CM_GW_ACQ_ORDER_PREF_GSM_WCDMA;
      #endif  /* FEATURE_WCDMA */
      cmnv_item_ptr->acq_order_pref.acq_order =
      acq_order_pref_cm2nv( ph_ptr->prst_main_stack_info[i].acq_order_pref  );
      cmnv_item_ptr->acq_order_pref.nam       = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait( NV_ACQ_ORDER_PREF_I, cmnv_item_ptr );
      #endif
    } /* if not valid acquisition order */

    #else /* #ifdef CM_GW_SUPPORTED */
    ph_ptr->prst_main_stack_info[i].acq_order_pref  = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
    #endif /* FEATURE_WCDMA || FEATURE_GSM */
  } /* for */

  /* Copy the persistent acquisition order preference of the current NAM
  ** to our acquisition order preference variable.
  */
  ph_ptr->main_stack_info.pref_info.acq_order_pref = CMPH_PRST_ACQ_ORDER_PREF( ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read from NV the persistent network selection mode preference
  ** for each NAM.
  */
  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    #ifdef CM_GW_SUPPORTED
    cmnv_item_ptr->net_sel_mode_pref.nam = (byte) i;
    cmnv_read_wait( NV_NET_SEL_MODE_PREF_I, cmnv_item_ptr );

    ph_ptr->prst_main_stack_info[i].network_sel_mode_pref =
     cmph_map_net_sel_mode_pref_nv2cm( cmnv_item_ptr->net_sel_mode_pref.net_sel_mode );

    if ( ( ph_ptr->prst_main_stack_info[i].network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_AUTOMATIC   &&
           ph_ptr->prst_main_stack_info[i].network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_MANUAL      &&
           ph_ptr->prst_main_stack_info[i].network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV ) ||
         ( !cmph_is_valid_network_selection_mode_pref (ph_ptr->prst_main_stack_info[i].mode_pref,
                                                       ph_ptr->prst_main_stack_info[i].network_sel_mode_pref))
       )
    {
      /*
      ** Default the network selection mode preference and write it back to NV.
      */
      ph_ptr->prst_main_stack_info[i].network_sel_mode_pref         = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
      cmnv_item_ptr->net_sel_mode_pref.net_sel_mode =
        cmph_map_net_sel_mode_pref_cm2nv( ph_ptr->prst_main_stack_info[i].network_sel_mode_pref );
      cmnv_item_ptr->net_sel_mode_pref.nam          = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait( NV_NET_SEL_MODE_PREF_I, cmnv_item_ptr );
      #endif
    } /* if not valid network selection mode */

    #else
    ph_ptr->prst_main_stack_info[i].network_sel_mode_pref         = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
    #endif
  } /* for */


  /* Copy the persistent network selection mode preference of the current NAM
  ** to our network selection mode preference variable.
  */
  ph_ptr->main_stack_info.pref_info.network_sel_mode_pref = CMPH_PRST_NETWORK_SEL_MODE_PREF( ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read from EFS the persistent user network selection mode preference
  ** for each NAM.
  */
  for ( i=0; i < NV_MAX_NAMS; i++ )
  {
    /* Initiliase the value to None */
    user_net_sel_mode_pref = CM_USER_NETWORK_SEL_MODE_PREF_NONE;
    efs_read_size = sizeof(cm_user_net_sel_mode_pref_e_type);

    /* Read the EFS file */
      if ( cmefs_get ( cmefs_get_efs_id_for_curr_nam ((cm_nam_e_type)i),
                      (byte*)&user_net_sel_mode_pref,
                      efs_read_size,
                      cmph_map_cm_ss_to_subs(CM_SS_MAIN))
         )
      {
          ph_ptr->prst_main_stack_info[i].user_net_sel_mode = user_net_sel_mode_pref;
        }
  }

  ph_ptr->main_stack_info.pref_info.user_net_sel_mode = 
    CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( cmph_map_cm_ss_to_subs(CM_SS_MAIN), ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If user_net_sel_mode is AUTOMATIC or MANUAL,
  ** overwrite phone's network sel mode_pref with user net_sel_mode_pref.
  ** This is required for Release-7 and beyond.
  */
  if ((CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( cmph_map_cm_ss_to_subs(CM_SS_MAIN), ph_ptr )
                                      == CM_USER_NETWORK_SEL_MODE_PREF_AUTOMATIC)
      ||
      (CMPH_PRST_USER_NETWORK_SEL_MODE_PREF(cmph_map_cm_ss_to_subs(CM_SS_MAIN), ph_ptr )
                                      == CM_USER_NETWORK_SEL_MODE_PREF_MANUAL))
  {
    ph_ptr->main_stack_info.pref_info.network_sel_mode_pref =
           cmph_map_user_to_cm_net_sel_mode_pref (
        CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( cmph_map_cm_ss_to_subs(CM_SS_MAIN),ph_ptr ));
    CM_MSG_HIGH_1 ("phone's main stack net_sel_mode updated with user_net_sel_mode - %d",
                  ph_ptr->main_stack_info.pref_info.network_sel_mode_pref);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read from NV the persistent service domain preference for each NAM.
  */
  for( i=0; i < NV_MAX_NAMS; i++ )
  {

    #if (defined CM_GW_SUPPORTED || defined(FEATURE_CM_LTE))
    cmnv_item_ptr->service_domain_pref.nam = (byte) i;
    cmnv_read_wait( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr );

    ph_ptr->prst_main_stack_info[i].srv_domain_pref =
     cmph_map_srv_domain_pref_nv2cm( cmnv_item_ptr->service_domain_pref.srv_domain );

    if (( ph_ptr->prst_main_stack_info[i].srv_domain_pref != CM_SRV_DOMAIN_PREF_CS_ONLY ) &&
        ( ph_ptr->prst_main_stack_info[i].srv_domain_pref != CM_SRV_DOMAIN_PREF_PS_ONLY ) &&
        ( ph_ptr->prst_main_stack_info[i].srv_domain_pref != CM_SRV_DOMAIN_PREF_CS_PS   )    )
    {
      /*
      ** Default the service domain preference and write it back to NV.
      */
      ph_ptr->prst_main_stack_info[i].srv_domain_pref              = CM_SRV_DOMAIN_PREF_CS_ONLY;
      cmnv_item_ptr->service_domain_pref.srv_domain =
       cmph_map_srv_domain_pref_cm2nv( ph_ptr->prst_main_stack_info[i].srv_domain_pref );
      cmnv_item_ptr->service_domain_pref.nam        = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr );
      #endif
    } /* if not valid service domain */

    if(ph_ptr->default_data_subs == ph_ptr->main_stack_info.asubs_id)
    {
       ph_ptr->main_stack_info.pref_info.srv_domain_pref = CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr);
    }
    else if(cmpmprx_get_num_of_active_data()== 1)
    {
       if(CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr) == CM_SRV_DOMAIN_PREF_PS_ONLY  || 
          CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr) == CM_SRV_DOMAIN_PREF_NONE
         )
       {
         ph_ptr->prst_main_stack_info[i].srv_domain_pref = CM_SRV_DOMAIN_PREF_NONE;
       }
       else
       {
         ph_ptr->prst_main_stack_info[i].srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
       }
    }	
    #else
    ph_ptr->prst_main_stack_info[i].srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
    #endif /* FEATURE_WCDMA || FEATURE_GSM || FEATURE_CM_LTE*/
  } /* for */

  /* Copy the persistent service domain preference of the current NAM
  ** to our service domain preference variable.
  */
  ph_ptr->main_stack_info.pref_info.srv_domain_pref = CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr );

  #ifdef CM_GW_SUPPORTED

  rex_def_timer(&ph_ptr->main_stack_info.phone_charge.acm_timer, get_cm_tcb(), CM_ACM_TIMER_SIG);
  rex_def_timer(&ph_ptr->main_stack_info.phone_charge.ccm_timer, get_cm_tcb(), CM_CCM_TIMER_SIG);

  ph_ptr->main_stack_info.user_pref_networks.length = 0;

  ph_ptr->main_stack_info.plmn_list.plmn_list.length = 0;
  
  
  ph_ptr->signaling_conn_rel_req    = FALSE;

  /* Clear all the entries in ccbs indx store
  */
  cmph_clear_ccbs_entries();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read GPRS Anite GCF flag to set silent redial time interval
  */
  cmnv_read_wait (NV_GPRS_ANITE_GCF_I, cmnv_item_ptr);

  if (cmnv_item_ptr->gprs_anite_gcf)
  {
    cmph_set_gprs_anite_gcf (TRUE);
  }
  else
  {
    cmph_set_gprs_anite_gcf (FALSE);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_GRACEFUL_PDP_DEACTIVATION_B4_DETACH
  /* Read pdp_deactivate_before_detach_supported flag.
  ** Graceful pdp deactivation before detach is not supported for GCF
  */
  if(*(cmph_get_gprs_anite_gcf_ptr()) == FALSE)
  {
    cmnv_read_wait(NV_PDP_DEACTIVATE_BEFORE_DETACH_SUPPORTED_I,cmnv_item_ptr);

    if (cmnv_item_ptr->pdp_deactivate_before_detach_supported)
    {
      cmph_set_pdp_deactivate_before_detach_supported (TRUE);
    }
    else
    {
      cmph_set_pdp_deactivate_before_detach_supported (FALSE);
    }
  }
  else
  {
    cmph_set_pdp_deactivate_before_detach_supported (FALSE);
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize AOC parameters */
  cmwaoc_reset();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #endif  /* FEATURE_WCDMA, FEATURE_GSM */

  ph_ptr->cur_ddtm_status   = FALSE;

  ph_ptr->ddtm_num_blocked_srv_opt = CM_INVALID_DDTM_NUM_SRV_OPT;

  memset(ph_ptr->ddtm_blocked_srv_opt_list, 0, sizeof(ph_ptr->ddtm_blocked_srv_opt_list));
  #if  (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) \
      && defined(FEATURE_DDTM_CNTL)

  cmnv_read_wait( NV_DDTM_SETTINGS_I, cmnv_item_ptr );

  /* If NV read failed, use default values and write the new values to NV
  */

  if( cmnv_item_ptr->ddtm_settings.num_srv_opt == CM_INVALID_DDTM_NUM_SRV_OPT )
  {
    ph_ptr->ddtm_act_mask     = SYS_DDTM_ACT_MASK_IGN_SO_PAGES;
    ph_ptr->ddtm_num_srv_opt  = 5;
    ph_ptr->ddtm_pref         = CM_DDTM_PREF_ON;
    ph_ptr->ddtm_srv_opt_list[0] = (sys_srv_opt_type)CAI_SO_ASYNC_DATA_PRE707;
    ph_ptr->ddtm_srv_opt_list[1] = (sys_srv_opt_type)CAI_SO_G3_FAX_PRE707;
    ph_ptr->ddtm_srv_opt_list[2] = (sys_srv_opt_type)CAI_SO_ASYNC_DATA_13K_PRE707;
    ph_ptr->ddtm_srv_opt_list[3] = (sys_srv_opt_type)CAI_SO_G3_FAX_13K_PRE707;
    ph_ptr->ddtm_srv_opt_list[4] = (sys_srv_opt_type)CAI_SO_PPP_PKT_DATA_3G;

    /* Initialize the list of service option pages to none
    */

    /* Cast is to prevent "implicit cast of pointer loses '__packed' qualifier"
    ** compiler error  C2906E
    */
    memset( (void*)cmnv_item_ptr->ddtm_settings.srv_opt_list, 0,
            sizeof(cmnv_item_ptr->ddtm_settings.srv_opt_list) );

    cmnv_item_ptr->ddtm_settings.ddtm_act             = DDTM_ACT_IGN_SO_PAGES;
    cmnv_item_ptr->ddtm_settings.ddtm_pref            = DDTM_PREF_ON;
    cmnv_item_ptr->ddtm_settings.num_srv_opt          = 5;
    cmnv_item_ptr->ddtm_settings.srv_opt_list[0] = (sys_srv_opt_type)CAI_SO_ASYNC_DATA_PRE707;
    cmnv_item_ptr->ddtm_settings.srv_opt_list[1] = (sys_srv_opt_type)CAI_SO_G3_FAX_PRE707;
    cmnv_item_ptr->ddtm_settings.srv_opt_list[2] = (sys_srv_opt_type)CAI_SO_ASYNC_DATA_13K_PRE707;
    cmnv_item_ptr->ddtm_settings.srv_opt_list[3] = (sys_srv_opt_type)CAI_SO_G3_FAX_13K_PRE707;
    cmnv_item_ptr->ddtm_settings.srv_opt_list[4] = (sys_srv_opt_type)CAI_SO_PPP_PKT_DATA_3G;

    #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
    cmnv_write_wait (NV_DDTM_SETTINGS_I, cmnv_item_ptr);
    #endif
  }
  else
  {

    ph_ptr->ddtm_act_mask      = cmph_map_nv_ddtm_act_to_cm_ddtm_act_mask(
                                  cmnv_item_ptr->ddtm_settings.ddtm_act );
    ph_ptr->ddtm_pref          = cmph_map_nv_ddtm_pref_to_cm_ddtm_pref(
                                  cmnv_item_ptr->ddtm_settings.ddtm_pref );

    if( cmnv_item_ptr->ddtm_settings.num_srv_opt > SYS_DDTM_MAX_SO_LIST_SIZE )
    {
      ph_ptr->ddtm_num_srv_opt = SYS_DDTM_MAX_SO_LIST_SIZE;
    }
    else
    {
      ph_ptr->ddtm_num_srv_opt = cmnv_item_ptr->ddtm_settings.num_srv_opt;
    }

    for( i=0; i<ph_ptr->ddtm_num_srv_opt; i++ )
    {
      ph_ptr->ddtm_srv_opt_list[i] =
              (sys_srv_opt_type)cmnv_item_ptr->ddtm_settings.srv_opt_list[i];

    }

  }

  /* Read the DDTM Allow List */
  cmnv_read_wait( NV_DDTM_ALLOW_SO_PAGES_I, cmnv_item_ptr );

  /* If the Read Failed or the NV item says that we allow no service options
  ** In this case, it's likely a incorrect setting, therefore we should fail-safe and
  ** fall back to legacy behavior.
  */
  if (( cmnv_item_ptr->ddtm_allow_so_pages.allow_num_srv_opt == CM_INVALID_DDTM_NUM_SRV_OPT ) ||
      ( cmnv_item_ptr->ddtm_allow_so_pages.allow_num_srv_opt == 0))
  {
    /* We should allow all service options and set the ph_ptr to reflect that */
    ph_ptr->ddtm_num_allow_srv_opt = CM_INVALID_DDTM_NUM_SRV_OPT;
  }
  else
  {
    if( cmnv_item_ptr->ddtm_allow_so_pages.allow_num_srv_opt > SYS_DDTM_MAX_ALLOW_SO_LIST_SIZE )
    {
      ph_ptr->ddtm_num_allow_srv_opt = SYS_DDTM_MAX_ALLOW_SO_LIST_SIZE;
    }
    else
    {
      ph_ptr->ddtm_num_allow_srv_opt = cmnv_item_ptr->ddtm_allow_so_pages.allow_num_srv_opt;
    }

    for( i=0; i < ph_ptr->ddtm_num_allow_srv_opt; i++ )
    {
      ph_ptr->ddtm_allow_srv_opt_list[i] =
              (sys_srv_opt_type)cmnv_item_ptr->ddtm_allow_so_pages.allow_srv_opt_list[i];

    }
  }

  #else
  ph_ptr->ddtm_act_mask     = SYS_DDTM_ACT_MASK_IGN_SO_PAGES;
  ph_ptr->ddtm_num_srv_opt  = 0;
  ph_ptr->ddtm_pref         = CM_DDTM_PREF_OFF;
  #endif

  ph_ptr->cur_ddtm_status   = FALSE;
  ph_ptr->cur_ddtm_act_mask = SYS_DDTM_ACT_MASK_EMPTY;
  ph_ptr->cur_ddtm_num_srv_opt = 0;

  /* Read preferences for packet switched data calls.
  */
  cmnv_read_wait( NV_PS_DATA_ORIG_PREF_I, cmnv_item_ptr );
  ph_ptr->ps_data_orig_pref = (cm_ps_data_orig_prefs_e_type)
                                  cmnv_item_ptr->ps_data_orig_pref;

  if( ! BETWEEN(ph_ptr->ps_data_orig_pref, CM_PS_DATA_ORIG_PREF_NONE,
      CM_PS_DATA_ORIG_PREF_MAX) )
  {
    /*
    ** Default the ps data orig preference and write it back to NV.
    */
    ph_ptr->ps_data_orig_pref = CM_PS_DATA_ORIG_PREF_ANY;
    cmnv_item_ptr->ps_data_orig_pref = NV_PS_DATA_ORIG_PREF_ANY;
    #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
    cmnv_write_wait (NV_PS_DATA_ORIG_PREF_I, cmnv_item_ptr);
    #endif
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Read disabled call type
  */
  cmnv_read_wait( NV_DISABLE_CM_CALL_TYPE_I, cmnv_item_ptr );

  ph_ptr->main_stack_info.disable_call_type_mask = (cm_disable_call_type)
                                  cmnv_item_ptr->disable_cm_call_type;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Read LU reject Auto enable NV
  */

  cmnv_read_wait( NV_LU_REJECT_AUTO_ENABLED_I, cmnv_item_ptr );

  ph_ptr->lu_reject_auto_enabled = (boolean)
                                       cmnv_item_ptr->lu_reject_auto_enabled;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* set the PS service request timer to inactive */
  cmph_deactivate_ps_service_req_timer(CM_SS_MAIN);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(FEATURE_UMTS_1X_HANDOVER_1XMSM) || \
      defined(FEATURE_UMTS_1X_HANDOVER_UMTSMSM)
  #error code not present
#endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize command reply object.
  */
  if (is_pwr_on)
  {
    cm_reply_init( &ph_ptr->reply );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*
  ** Set the PS Signaling wait time to none and PS signaling down needed to
  ** FALSE.
  */
  cmph_set_ps_sig_down_wait_time(CMPH_GW_PKT_WAIT_TIME_NONE, CM_SS_MAIN);


  /* Initialize the DEM object
  */
  cmph_dem_init();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize last pref sys changed pointer
  */
  cmph_get_last_pref_sent(CM_SS_MAIN)->orig_mode = SD_SS_ORIG_MODE_NONE;
  cmph_get_last_pref_sent(CM_SS_MAIN)->orig_hybr_pref = ph_ptr->main_stack_info.pref_info.hybr_pref;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (is_pwr_on)
  {
    /* Mark object as initialized.
    */
    CM_INIT_MARK( ph_ptr->init_mask );

    /* reset subsc values only at power on
    */
    ph_ptr->is_gwl_subscription_available       = FALSE;
    ph_ptr->is_hybr_gw_subscription_available   = FALSE;
    ph_ptr->is_hybr_gw3_subscription_available   = FALSE;
    ph_ptr->is_cdma_subscription_available      = FALSE;

    ph_ptr->main_stack_info.subs_capability = 0;

    cmph_als_reset();

    cmph_gw_subs_from_card_sent = FALSE;
    cmph_cdma_subs_from_card_sent = FALSE;
    cmph_received_card_init_completed_evt = FALSE;


    #ifdef FEATURE_MMGSDI_SESSION_LIB
    cmph_sessoin_open_sent = FALSE;
    #endif


  } //is_pwr_on
  else
  {
    /* For 7+5 mode changes below logic should be ignored as 
    ** SUB2 is always mapped to hybrid3
    ** For legacy support use old_sub2_map_to_hybr3 that indicates
    ** the stack mapping based on the feature mode
    */
    if(old_sub2_map_to_hybr3 == FALSE)
    {
    /* Update appropriate subcriptions
    ** when PM changes SRLTE + NORMAL => NORMAL + NORMAL
    */    
    if(old_feature_mode == SYS_OVERALL_FEATURE_MODE_MULTISIM &&
       old_sfmode_sub1 == SYS_SUBS_FEATURE_MODE_SRLTE &&
       cmph_is_subs_feature_mode_normal(SYS_MODEM_AS_ID_1))
    {
      ph_ptr->is_hybr_gw_subscription_available   = 
           ph_ptr->is_hybr_gw3_subscription_available;
      ph_ptr->is_hybr_gw3_subscription_available   = FALSE;   
#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      cmph_hybr_gw_subs_from_card_sent = 
         cmph_hybr_3_gw_subs_from_card_sent;
      cmph_hybr_3_gw_subs_from_card_sent = FALSE;
#endif
    }    
    /* Update appropriate subcriptions
    ** when PM changes NORMAL + NORMAL <=> SRLTE + NORMAL
    */    
    else if(old_feature_mode == SYS_OVERALL_FEATURE_MODE_MULTISIM &&
       old_sfmode_sub1 == SYS_SUBS_FEATURE_MODE_NORMAL &&
       cmph_is_sxlte())
    {
      ph_ptr->is_hybr_gw3_subscription_available   = 
           ph_ptr->is_hybr_gw_subscription_available;
      ph_ptr->is_hybr_gw_subscription_available   = FALSE;    
#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      cmph_hybr_3_gw_subs_from_card_sent = 
         cmph_hybr_gw_subs_from_card_sent;
      cmph_hybr_gw_subs_from_card_sent = FALSE;
#endif
    }    
  }
  }
  CM_MSG_HIGH_3("old_feature_mode %d old_sfmode_sub1 %d cmph_is_sxlte %d",
                old_feature_mode,old_sfmode_sub1,cmph_is_sxlte());
  CM_MSG_HIGH_3("hybr_gw_subsc %d hybr_gw3_subsc %d hybr_gw_subs_from_card_sent %d",
                ph_ptr->is_hybr_gw_subscription_available,
                ph_ptr->is_hybr_gw3_subscription_available,
                cmph_hybr_gw_subs_from_card_sent);

  ph_ptr->is_ps_srv_req_sent = FALSE;

  /* Initialize the network type request to none for
  ** use in cm_ph_cmd_get_networks() API.
  */
  ph_ptr->main_stack_info.pref_info.network_type  = CM_MODE_PREF_NONE;
  //TODO: Review if this is needed
  ph_ptr->ss_for_get_networks = CM_SS_NONE;

  cmph_set_net_lists_present_flag(FALSE);

  ph_ptr->ph_state = CM_PH_STATE_NORMAL;
  ph_ptr->ecbm_exit_reason = CM_ECBM_EXIT_REASON_NORMAL;

  /* Initialize the privacy setting to standard
  */
  ph_ptr->privacy_pref = CM_PRIVACY_PREF_STANDARD;

  /* Initialize the is_privacy to false
  */
  ph_ptr->is_privacy      = FALSE;

  /* CDMA is not Tx disabled during init.
  */
  ph_ptr->is_cdma_tx_disabled = FALSE;

  /* Add in the orig Q the ph_ptr values
  */
  (void)cmph_insert_orig_mode (
                                CM_SS_MAIN,
                                SD_SS_ORIG_MODE_NONE,
                                CM_ACT_TYPE_PH_OBJ,
                                ph_ptr->main_stack_info.pref_info.pref_term,
                                ph_ptr->main_stack_info.pref_info.mode_pref,
                                ph_ptr->main_stack_info.pref_info.band_pref,
                                ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                ph_ptr->main_stack_info.pref_info.prl_pref,
                                ph_ptr->main_stack_info.pref_info.roam_pref,
                                ph_ptr->main_stack_info.pref_info.hybr_pref,
                                ph_ptr->int_hybr_pref,
                                ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                (cm_act_id_type)ph_ptr,
                                CM_ACT_UPDATE_REAS_ACT_START,
                                CM_DEFAULT_VALUE,
                                ph_ptr->main_stack_info.pref_info.csg_id,
                                ph_ptr->main_stack_info.pref_info.csg_rat
                              );

  if (cmph_is_msim())
  {
    if (cmph_is_sxlte())
    {
      /* Insert only if the stack is required by the configuration */
      if (!cmph_no_hybr2())
      {
      (void)cmph_insert_orig_mode (
                                    CM_SS_HYBR_2,
                                    SD_SS_ORIG_MODE_NONE,
                                    CM_ACT_TYPE_PH_OBJ,
                                    ph_ptr->main_stack_info.pref_info.pref_term,
                                    ph_ptr->main_stack_info.pref_info.mode_pref,
                                    ph_ptr->main_stack_info.pref_info.band_pref,
                                    ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                    ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                    ph_ptr->main_stack_info.pref_info.prl_pref,
                                    ph_ptr->main_stack_info.pref_info.roam_pref,
                                    ph_ptr->main_stack_info.pref_info.hybr_pref,
                                    ph_ptr->int_hybr_pref,
                                    ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                    (cm_act_id_type)ph_ptr,
                                    CM_ACT_UPDATE_REAS_ACT_START,
                                    CM_DEFAULT_VALUE,
                                    ph_ptr->main_stack_info.pref_info.csg_id,
                                    ph_ptr->main_stack_info.pref_info.csg_rat
                                  );
    }
    }

    else if (cmph_is_dsds() || \
           cmph_is_tsts() || \
           cmph_is_dsda() )
    {
      (void)cmph_insert_orig_mode (
                              CM_SS_HYBR_2,
                              SD_SS_ORIG_MODE_NONE,
                              CM_ACT_TYPE_PH_OBJ,
                              ph_ptr->hybr_2_stack_info.pref_info.pref_term,
                              ph_ptr->hybr_2_stack_info.pref_info.mode_pref,
                              ph_ptr->hybr_2_stack_info.pref_info.band_pref,
                              ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
                              ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref,
                              ph_ptr->hybr_2_stack_info.pref_info.prl_pref,
                              ph_ptr->hybr_2_stack_info.pref_info.roam_pref,
                              ph_ptr->hybr_2_stack_info.pref_info.hybr_pref,
                              cmph_map_cm_hybr_pref_to_sd_hybr_pref(
                                 ph_ptr->hybr_2_stack_info.pref_info.hybr_pref),
                              ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref,
                              (cm_act_id_type)ph_ptr,
                              CM_ACT_UPDATE_REAS_ACT_START,
                              CM_DEFAULT_VALUE,
                              ph_ptr->main_stack_info.pref_info.csg_id,
                              ph_ptr->main_stack_info.pref_info.csg_rat
                            );
   }

   #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
   /* Insert phone object in HYBR3 as well if just feature is ON*/
    (void)cmph_insert_orig_mode ( CM_SS_HYBR_3,
                           SD_SS_ORIG_MODE_NONE,
                           CM_ACT_TYPE_PH_OBJ,
                           ph_ptr->hybr_3_stack_info.pref_info.pref_term,
                           ph_ptr->hybr_3_stack_info.pref_info.mode_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.band_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.prl_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.roam_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.hybr_pref,
                           cmph_map_cm_hybr_pref_to_sd_hybr_pref(
                              ph_ptr->hybr_3_stack_info.pref_info.hybr_pref),
                           ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref,
                           (cm_act_id_type)ph_ptr,
                           CM_ACT_UPDATE_REAS_ACT_START,
                           CM_DEFAULT_VALUE,
                           ph_ptr->main_stack_info.pref_info.csg_id,
                           ph_ptr->main_stack_info.pref_info.csg_rat
                           );

   #endif
  }

  if (cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK_SSIM))
  {
    (void)cmph_insert_orig_mode (
                                  CM_SS_HYBR_2,
                                  SD_SS_ORIG_MODE_NONE,
                                  CM_ACT_TYPE_PH_OBJ,
                                  ph_ptr->main_stack_info.pref_info.pref_term,
                                  ph_ptr->main_stack_info.pref_info.mode_pref,
                                  ph_ptr->main_stack_info.pref_info.band_pref,
                                  ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                  ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                  ph_ptr->main_stack_info.pref_info.prl_pref,
                                  ph_ptr->main_stack_info.pref_info.roam_pref,
                                  ph_ptr->main_stack_info.pref_info.hybr_pref,
                                  ph_ptr->int_hybr_pref,
                                  ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                  (cm_act_id_type)ph_ptr,
                                  CM_ACT_UPDATE_REAS_ACT_START,
                                  CM_DEFAULT_VALUE,
                                  ph_ptr->main_stack_info.pref_info.csg_id,
                                  ph_ptr->main_stack_info.pref_info.csg_rat
                                );
  }

  /* Add in the orig Q the ph_ptr values
  */
  (void)cmph_insert_orig_mode (
                                CM_SS_HDR,
                                SD_SS_ORIG_MODE_NONE,
                                CM_ACT_TYPE_PH_OBJ,
                                ph_ptr->main_stack_info.pref_info.pref_term,
                                ph_ptr->main_stack_info.pref_info.mode_pref,
                                ph_ptr->main_stack_info.pref_info.band_pref,
                                ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                ph_ptr->main_stack_info.pref_info.prl_pref,
                                ph_ptr->main_stack_info.pref_info.roam_pref,
                                ph_ptr->main_stack_info.pref_info.hybr_pref,
                                ph_ptr->int_hybr_pref,
                                ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                (cm_act_id_type)ph_ptr,
                                CM_ACT_UPDATE_REAS_ACT_START,
                                CM_DEFAULT_VALUE,
                                ph_ptr->main_stack_info.pref_info.csg_id,
                                ph_ptr->main_stack_info.pref_info.csg_rat
                              );

  /* Add in the orig Q the ph_ptr values
  */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the energency call back ptr to default values
  */

  cmtask_orig_para_init_2( cmph_get_emergency_cb_pref() );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* status of plmn list request (success/abort) */
  ph_ptr->available_networks_list_cnf = SYS_PLMN_LIST_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize the hdr kicked ptr
  */
  *cmph_get_is_kicked_hybr_ptr() = FALSE;
  *cmph_get_is_kicked_hybr_2_ptr() = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ph_ptr->is_otasp_commit_pending = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*initialize the mode capability and band capability
  */
  ph_ptr->mode_capability = SYS_SYS_MODE_MASK_NONE;
  ph_ptr->band_capability = SYS_BAND_MASK_EMPTY;
  SYS_LTE_BAND_MASK_CLR_ALL_BANDS(&ph_ptr->lte_band_capability);
  ph_ptr->tds_band_capability = SYS_BAND_MASK_EMPTY;

  cmph_get_mode_band_capability(  &(ph_ptr->mode_capability),
                                  &(ph_ptr->band_capability),
                                  &(ph_ptr->lte_band_capability),
                                  &(ph_ptr->tds_band_capability));

  CM_MSG_HIGH_0( "lte_band_capability");
  cm_print_lte_band_mask(ph_ptr->lte_band_capability);

  /* if RUIM is not defined CDMA subscription is available from NV,
  ** instead of waiting for card event or RTRE control,
  ** CDMA subscription is sent to MMOC.
  */
  #if !( defined(FEATURE_UIM_RUIM)) && \
         (defined(FEATURE_MMODE_CDMA) || defined(FEATURE_JCDMA))
    ph_ptr->is_cdma_subscription_available = TRUE;
  #endif /* !FEATURE_UIM_RUIM && (FEATURE_MMODE_CDMA || FEATURE_JCDMA) */

  cmstats_ptr()->prm.cm_info.ph_info.band_cap = ph_ptr->band_capability;
  cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK );

  cmph_clr_all_pref_nochg_flag();

  /* Initialize measurement mode to OFF
  */
  #ifdef FEATURE_CM_SS_MEAS
  #error code not present
#endif



  #ifdef FEATURE_HICPS_STACK_SYNC_UP
  ph_ptr->hicps_gwl_avoid_timer_active = FALSE;
  ph_ptr->is_hdr_activity              = FALSE;
  ph_ptr->hicps_gwl_avoid_uptime       = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  size_of_gwl_avoid_timers = sizeof( cm_gwl_avoidance_timers_s_type );

  if ( cmefs_read ( CMEFS_HICPS_GWL_AVOIDANCE_PARAM,
                    (byte*)&cm_gwl_avoidance_timers,
                    &size_of_gwl_avoid_timers)
     )
  {
    CM_MSG_HIGH_3 ("HICPS: EFS read succ. gwl_avoid_enable = %d, gwl_avoid_timer = %d, gwl_avoid_exten = %d",
                  cm_gwl_avoidance_timers.cmph_gwl_avoid_enable,
                  cm_gwl_avoidance_timers.cmph_gwl_avoid_timer_value,
                  cm_gwl_avoidance_timers.cmph_gwl_avoid_exten_value);
  }
  else
  {
    /* Enable GWL avoidance by default. */
    cm_gwl_avoidance_timers.cmph_gwl_avoid_enable      = 1;
    cm_gwl_avoidance_timers.cmph_gwl_avoid_timer_value = 170;
    cm_gwl_avoidance_timers.cmph_gwl_avoid_exten_value = 60;
    CM_MSG_HIGH_3 ("HICPS: EFS read fail. gwl_avoid_enable = %d, gwl_avoid_timer = %d, gwl_avoid_exten = %d",
                 cm_gwl_avoidance_timers.cmph_gwl_avoid_enable,
                 cm_gwl_avoidance_timers.cmph_gwl_avoid_timer_value,
                 cm_gwl_avoidance_timers.cmph_gwl_avoid_exten_value);

  }

  #endif
  ph_ptr->is_ds_cmd_ntfy_sent = FALSE;
  ph_ptr->abort_ss_bitmask = 0;
  /* Initialize voice_drs_bit */
  ph_ptr->voice_drs_bit = TRUE;
    ph_ptr->ecbm_rat = SYS_SYS_MODE_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read the SGLTE setting from EFS */
  {
    int32 sglte_device_size = sizeof(ph_ptr->is_sglte_device);

    if ( cmefs_read ( CMEFS_SGLTE_DEVICE,
                      (byte*)&ph_ptr->is_sglte_device,
                      &sglte_device_size)
       )
    {
      CM_MSG_HIGH_1 ("EFS is_sglte_device = %d", ph_ptr->is_sglte_device);
    }
    else
    {
      ph_ptr->is_sglte_device = FALSE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/



  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) && \
               defined(FEATURE_IP_CALL) && defined(FEATURE_CM_LTE) && defined(FEATURE_1X_SRVCC)

  read_size = sizeof(boolean);
  if( cmefs_get2("/nv/item_files/modem/nas/l21xsrvcc_support",
             &ph_ptr->cdma_srvcc_enabled,
                 read_size,
                 SYS_MODEM_AS_ID_1) )
  {
    CM_MSG_HIGH_1 ("EFS read succ. cdma_srvcc_enabled= %d",
                  ph_ptr->cdma_srvcc_enabled);
  }
  else
  {
      ph_ptr->cdma_srvcc_enabled = FALSE;
    }


  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialise is_mode_change_due_to_ef_rat to FALSE.
  ** When EF_RAT is read and mode pref is required this will be set
  ** to TRUE.
  */
  ph_ptr->is_mode_change_due_to_ef_rat = FALSE;
  ph_ptr->is_ps_detach_required = FALSE;
  ph_ptr->is_user_ps_detach_required = FALSE;

  #ifdef FEATURE_CM_LTE
  /* Initialize the PLMN blocking buffer.
  */
  ph_ptr->main_stack_info.plmn_blocking_info.request_pref = CM_PLMN_BLOCKING_PREF_NONE;
  sys_plmn_undefine_plmn_id( &(ph_ptr->main_stack_info.plmn_blocking_info.plmn) );
  ph_ptr->main_stack_info.plmn_blocking_info.blocking_interval = 0;
  #endif

 #if (defined FEATURE_CM_LTE) && (defined FEATURE_HDR_HANDOFF)
  ph_ptr->shorten_bsr_timer = 0;
  ph_ptr->is_shorten_bsr = FALSE;
  #endif /* FEATURE_CM_LTE && FEATURE_HDR_HANDOFF */

  #if defined(FEATURE_IP_CALL)
  ph_ptr->is_ims_cmd_ntfy_sent = FALSE;

  #endif /* FEATURE_IP_CALL */


  ph_ptr->drx_coefficient = SYS_DRX_CN_COEFFICIENT_S1_NONE;
  ph_ptr->set_drx_result  = FALSE;
  ph_ptr->wd_switch_on  = FALSE;


  ph_ptr->is_hold_user_act = FALSE;

  ph_ptr->is_srv_domain_ps_detach_forced = FALSE;
  for(i = 0; i < MAX_SIMS; i++)
  {
    if(refresh_subs_mask && BM(i))
    {
      ph_ptr->is_pref_change_pending[i] =  FALSE ;
    }
  }
  ph_ptr->is_oprt_mode_change_ongoing = FALSE;
  ph_ptr->lte_do_redir = FALSE;
  ph_ptr->is_mode_pref_none = FALSE;
  ph_ptr->lte_disable_cause = CM_LTE_DISABLE_CAUSE_NO_VALUE;

  cmph_set_is_user_resel_buffered_ss(CM_SS_MAIN, FALSE);
  cmph_set_is_user_resel_buffered_ss(CM_SS_HYBR_2, FALSE);
  cmph_set_is_user_resel_buffered_ss(CM_SS_HYBR_3, FALSE);



  if(cmefs_get( CMEFS_GET_NET_AUTO_MODE,
                      (byte*)&(ph_ptr->get_net_auto_mode_enabled),
                       get_net_auto_mode_size,
                       SYS_MODEM_AS_ID_1))
  {
    CM_MSG_HIGH_1("EFS read for GET_NET_AUTO_MODE success get_net_auto_mode_enabled - %d",
                  ph_ptr->get_net_auto_mode_enabled.get_net_auto_mode);
  }

  if(cmefs_get(  CMEFS_3GPP2_PS_CALL_OPTIMIZATION,
                 (byte*)&(ph_ptr->ps_call_optimized),
                 sizeof(cmxcall_ps_call_optimize_s_type),
                 SYS_MODEM_AS_ID_1))
  {
    CM_MSG_HIGH_1("EFS read for 3GPP2_PS_CALL_OPTIMIZATION success : %d",
                 ph_ptr->ps_call_optimized.allowed);
  }
  else{
    ph_ptr->ps_call_optimized.version = 0;
    ph_ptr->ps_call_optimized.allowed = CMXCALL_PS_OPT_ENABLED_ROAM_ONLY;
    ph_ptr->ps_call_optimized.timer_value = 120;
  }


  #ifdef FEATURE_MMODE_DUAL_SIM
  ph_ptr->dds_status = CMPH_DDS_STATUS_NONE;
  #endif

  #ifdef FEATURE_SEGMENT_LOADING

  if(create_instance(CLSID_TDSCDMA, &pi_mmode_tdscdma)!=E_SUCCESS)
  {
    CM_ERR_0("Failed to create instance of CLSID_TDSCDMA");
  }

  if(create_instance(CLSID_WCDMA, &pi_mmode_wcdma)!=E_SUCCESS)
  {
    CM_ERR_0("Failed to create instance of CLSID_WCDMA");
  }

  #endif

  ph_ptr->network_list_type = CM_NETWORK_LIST_NONE;
  ph_ptr->hybrid2_network_list_type = CM_NETWORK_LIST_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* initialize msim esr config */
  cmph_init_config_msim_esr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(cmefs_get( CMEFS_CSG_AUTO_MODE,
                      (byte*)&(ph_ptr->csg_auto_mode),
                       sizeof(cmph_efs_get_global_mode_csg),
                       SYS_MODEM_AS_ID_1))
  {
    CM_MSG_HIGH_2("EFS read for CMEFS_CSG_AUTO_MODE success csg support %d, bsr %d",
                  ph_ptr->csg_auto_mode.csg_global_mode_support,
                  ph_ptr->csg_auto_mode.disable_bsr_global_csg);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(cmefs_get ( CMEFS_CDMA_VOICE_CALL_COLLISION,
              (byte*)&mo_call_event_info,
              sizeof(cmph_cdma_call_collision_s_type ),
              SYS_MODEM_AS_ID_1))
  {
  if( mo_call_event_info.is_AWIM == 1 )
  {
    ph_ptr->is_awim_mo_call_end_event = TRUE;
  }
  else
  {
    ph_ptr->is_awim_mo_call_end_event = FALSE;
  }
  }
  else
  {
    ph_ptr->is_awim_mo_call_end_event = FALSE;
  }

  cmnv_efs_read( CMNV_EFS_ID_MODE_DISABLED_IN_TSTS,
                 (byte*)&ph_ptr->mode_disabled_in_TSTS,
                  &read_size);
  if ( read_size > 0 )
  {
    CM_MSG_HIGH_1 ("EFS read succ. mode_disabled_in_TSTS= %d",
                   ph_ptr->mode_disabled_in_TSTS);
  }
  else
  {
    ph_ptr->mode_disabled_in_TSTS = SYS_SYS_MODE_MASK_NONE;
  }

  ph_ptr->main_stack_info.is_emergency_mode = FALSE;
  ph_ptr->hybr_2_stack_info.is_emergency_mode = FALSE;
  #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
  ph_ptr->hybr_3_stack_info.is_emergency_mode = FALSE;
  #endif


  /*- - - - - - - - - - -VSID INITIALISATION - - - - - - - - -*/

  //Multimode SUB VSID for voice, lte, wlan
  cmph_asid2vsid_map[CMPH_SUB_TYPE_MULTIMODE_SUB][SYS_VSID_APP_CS_VOICE] = 0x10C01000;
  cmph_asid2vsid_map[CMPH_SUB_TYPE_MULTIMODE_SUB][SYS_VSID_APP_IMS_LTE]  = 0x10C02000;
  cmph_asid2vsid_map[CMPH_SUB_TYPE_MULTIMODE_SUB][SYS_VSID_APP_IMS_WLAN] = 0x10002000;


  //Non-Multimode SUB VSID for voice, lte, wlan
  cmph_asid2vsid_map[CMPH_SUB_TYPE_NONMULTIMODE_SUB][SYS_VSID_APP_CS_VOICE] = 0x10C01000;
  cmph_asid2vsid_map[CMPH_SUB_TYPE_NONMULTIMODE_SUB][SYS_VSID_APP_IMS_LTE]  = 0x10C02000;
  cmph_asid2vsid_map[CMPH_SUB_TYPE_NONMULTIMODE_SUB][SYS_VSID_APP_IMS_WLAN] = 0x10002000;
  for(i=SYS_MODEM_AS_ID_1;i<SYS_MODEM_AS_ID_MAX;i++)
  {
   ph_ptr->data_priority_per_sub[i].priority_type = SYS_DATA_PRIORITY_LOW;
  }
  

  ph_ptr->is_mmoc_standby_pref_not_req = FALSE;

  if(refresh_subs_mask & BM(SYS_MODEM_AS_ID_1))
  {
    if(cmefs_get(CMEFS_CDMA_HOLD_SRV_TIMER,
               (byte *)&(ph_ptr->cdma_hold_srv_timer),
               sizeof(ph_ptr->cdma_hold_srv_timer),
               SYS_MODEM_AS_ID_1))
    {
      CM_MSG_HIGH_1("CDMA hold srv duration %d", ph_ptr->cdma_hold_srv_timer);
    }
    else
    {
      ph_ptr->cdma_hold_srv_timer = CMSS_CDMA_HOLD_SRV_TIMER;
      CM_MSG_HIGH_0("Default CDMA hold srv duration set");
    }

    if(cmefs_get(CMEFS_PS_SIGNALLING_WAIT_TIMER,
               (byte *)&(ph_ptr->ps_signaling_max_wait_timer),
               sizeof(ph_ptr->ps_signaling_max_wait_timer),
               SYS_MODEM_AS_ID_1))
    {
      CM_MSG_HIGH_1("PS signalling down wait timer %d", ph_ptr->ps_signaling_max_wait_timer);
    }
    else
    {
      ph_ptr->ps_signaling_max_wait_timer = CMPH_GW_PKT_SIGNALING_DOWN_WAIT_TIME;
      CM_MSG_HIGH_0("Default PS signalling down wait timer");
    }
  
  }

  {
    boolean self_activation_support;
    for(i=0; i<cmph_get_ph_sub_config_size(); i++)
    {
      /* Default set this to 0 */
      ph_ptr->sub_config[i].self_activation_support = FALSE;

      if ( cmefs_get( CMEFS_SELF_ACTIVATION_SUPPORT,
                        (byte*)&self_activation_support,
                          sizeof(boolean),
                          (sys_modem_as_id_e_type)i)
         )
      {
        ph_ptr->sub_config[i].self_activation_support = self_activation_support;
        CM_MSG_HIGH_2 ("EFS read succ. self_activation_support[%d]= %d",
                      i, ph_ptr->sub_config[i].self_activation_support);
      }
    }
  }
  ph_ptr->is_dds_switchback_from_temp = FALSE;

} /* cmph_nv_refresh() */

/*===========================================================================

FUNCTION cmph_init

DESCRIPTION
  Initializing the phone object.

  This function must be called before the phone object
  is being used, in any way, place, or form.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_init( void )
{
  cmph_nv_refresh(SYS_MODEM_AS_ID_ALL_ACTIVE_MASK , TRUE);
}
/*===========================================================================

FUNCTION cmph_post_init_proc

DESCRIPTION
  Perform procedure post init of all entities of CM

  This function must be called before the phone object
  is being used, in any way, place, or form.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cmph_post_init_proc()
{
  cmph_s_type* ph_ptr =  cmph_ptr();

  #if 0
  if(cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1))
  {
    if(cmcall_misc_is_mode_pref((ph_ptr->hybr_3_stack_info.pref_info.mode_pref), CM_MODE_PREF_TDS_WCDMA_LTE))
    {
      /* Initiate multimode switch */
      /* No need to initiate subscription change now */
      cmph_initiate_sxlte_multimode_switch(FALSE);
    }
  }
  #endif

  /* Sending standby pref to MultiSIM Coordinator / MMOC 
  ** Updating the condition with more operating modes to allow for customer 
  ** modifications which caused UE to initialize in LPM.
  */
  if ( cm_is_valid_state_for_sub_proc(ph_ptr->oprt_mode) )
  {
    /* Send the Standy Preferences to MMOC based on the preferences in NV
    */
    cmmsimc_proc_cmd_standby_pref_chgd( ph_ptr->internal_standby_pref,
                                        ph_ptr->active_subs,
                                        ph_ptr->is_cdma_subscription_available,
                                        ph_ptr->is_gwl_subscription_available,
                                        ph_ptr->is_hybr_gw_subscription_available,
                                        ph_ptr->is_hybr_gw3_subscription_available,
                                        FALSE
                                      );

    cmph_sp_subs_info_update();

    ph_ptr->curr_priority_subs = ph_ptr->priority_subs;

  }
  else if(ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM)
  {
     cmph_sp_subs_info_update();
  }

  CM_MSG_HIGH_1("Post init possible pm_subs_notify oprt_mode = %d",
                                                           ph_ptr->oprt_mode);
  /* Send subscription after completely initializing CM 
  ** Updating the condition with more operating modes to allow for customer 
  ** modifications which caused UE to initialize in LPM.
  */
  if(cm_is_valid_state_for_sub_proc(ph_ptr->oprt_mode))
  {
    cmpmprx_msim_subsc_changed(ph_ptr->active_subs, ph_ptr->default_data_subs, ph_ptr->dds_switch_type);
    cmmsc_init_max_mode_capability();
    cmph_update_subscription_to_mmode(MMOC_SUBSC_CHG_NAM_SEL);
  }

  cmph_ptr()->dds_change_in_progress = FALSE;
  cmpm_ptr()->change_in_ims_for_nondds = FALSE;

}

/*===========================================================================

FUNCTION cmph_is_pref_term_temporary

DESCRIPTION
  Check whether a specified pref_term is temporary for call purposes.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if the specified pref_term is temporary.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_is_pref_term_temporary(

       cm_pref_term_e_type       pref_term
        /* pref_term to check for temporary */

)
{
  boolean is_pref_term_temp = FALSE;


  switch ( pref_term )
  {
    case CM_PREF_TERM_1_CALL:
    case CM_PREF_TERM_1_CALL_OR_TIME:
    case CM_PREF_TERM_CM_1_CALL:
    case CM_PREF_TERM_CM_1_CALL_PLUS:
    case CM_PREF_TERM_CM_MO_SMS:
      is_pref_term_temp = TRUE;
      break;

    #ifdef FEATURE_RPC
    case CM_PREF_TERM_BIG:
    #endif
    case CM_PREF_TERM_NONE:
    case CM_PREF_TERM_PERMANENT:
    case CM_PREF_TERM_PWR_CYCLE:
    case CM_PREF_TERM_MAX:
    default:
      break;
  } /* switch ( ph_ptr->orig_pref_term ) */


  return is_pref_term_temp;

} /* cmph_is_pref_term_temporary() */

/*===========================================================================

FUNCTION cmph_is_valid_mode_band_pref

DESCRIPTION
  Check whether a specified combination of mode and band preference is
  supported by the current target and the PRL that is associated with the
  currently selected NAM.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if the specified combination of mode and band preference is supported.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_is_valid_mode_band_pref(

    cm_mode_pref_e_type    mode_pref,
        /* Mode pref to check for validity */

    cm_band_pref_e_type    band_pref
        /* Band pref to check for validity */
)
{
  sd_ss_mode_pref_e_type  sd_mode_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* No need to validate CM_MODE_PREF_AUTOMATIC.
  */
  if (( mode_pref == CM_MODE_PREF_AUTOMATIC &&
        band_pref == CM_BAND_PREF_ANY ) ||
        mode_pref == CM_MODE_PREF_EMERGENCY)
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return a boolean indicating whether specified combination of mode and
  ** band preference is supported.
  */
  sd_mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref( mode_pref );
  return (sd_misc_is_supp_pref( sd_mode_pref, cmph_map_cm_band_pref_to_sd_band_pref(band_pref)));

} /* cmph_is_valid_mode_band_pref() */



/*===========================================================================

FUNCTION cmph_is_valid_lte_mode_band_pref

DESCRIPTION
  Check whether a specified combination of mode and LTE band preference is
  supported by the current target.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if the specified combination of mode and band preference is supported.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_is_valid_lte_mode_band_pref(

    cm_mode_pref_e_type    mode_pref,
        /* Mode pref to check for validity */

    sys_lte_band_mask_e_type    lte_band_pref
        /* LTE band pref to check for validity */
)
{
  sd_ss_mode_pref_e_type  sd_mode_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return a boolean indicating whether specified combination of mode and
  ** band preference is supported.
  */
  sd_mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref( mode_pref );
  CM_ASSERT( sd_mode_pref != SD_SS_MODE_PREF_MAX );

  return sd_misc_is_supp_pref_lte( sd_mode_pref, lte_band_pref);

} /* cmph_is_valid_lte_mode_band_pref() */


/*===========================================================================

FUNCTION cmph_is_valid_tds_mode_band_pref

DESCRIPTION
  Check whether a specified combination of mode and TD-SCDMA band preference
  is supported by the current target.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if the specified combination of mode and band preference is supported.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_is_valid_tds_mode_band_pref(

    cm_mode_pref_e_type    mode_pref,
        /* Mode pref to check for validity */

    cm_band_pref_e_type    tds_band_pref
        /* TD-SCDMA band pref to check for validity */
)
{
  sd_ss_mode_pref_e_type  sd_mode_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return a boolean indicating whether specified combination of mode and
  ** band preference is supported.
  */
  sd_mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref( mode_pref );
  CM_ASSERT( sd_mode_pref != SD_SS_MODE_PREF_MAX );

  return sd_misc_is_supp_pref_tds( sd_mode_pref,
         cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(tds_band_pref) );

} /* cmph_is_valid_tds_mode_band_pref() */


/**===========================================================================

FUNCTION cmph_get_mode_band_capability

DESCRIPTION
  Request for all the available modes and bands supported by the current
  target.

DEPENDENCIES
  None

RETURNS


SIDE_EFFECT
  None

===========================================================================*/
void cmph_get_mode_band_capability(

  sys_sys_mode_mask_e_type *    mode_capability,
    /* Mode capability supported by the current target */

  sys_band_mask_e_type *        band_capability,
    /* Band capability supported by the current target */

  sys_lte_band_mask_e_type *    lte_band_capability,
    /* LTE band capability supported by the current target */

  sys_band_mask_e_type *        tds_band_capability
    /* TD-SCDMA band capability supported by the current target */

)
{
  sd_ss_mode_pref_e_type sd_mode_pref = SD_SS_MODE_PREF_NONE;
  sd_ss_band_pref_e_type sd_band_pref = SD_SS_BAND_PREF_NONE;
  sys_lte_band_mask_e_type sd_lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type sd_tds_band_pref = SD_SS_BAND_PREF_NONE;

  sd_misc_get_mode_band_capability(&sd_mode_pref,
                                   &sd_band_pref,
                                   &sd_lte_band_pref,
                                   &sd_tds_band_pref);

  *band_capability = (sys_band_mask_e_type)sd_band_pref;

  *lte_band_capability = sd_lte_band_pref;

  *tds_band_capability = (sys_band_mask_e_type)sd_tds_band_pref;

  *mode_capability = cmph_map_sd_mode_pref_to_sys_mode_mask(sd_mode_pref);

}



/**===========================================================================

FUNCTION cmph_get_comm_mode_band_capab_with_pm

DESCRIPTION
  Request for all the available modes and bands intersected with cmph and policyman's

DEPENDENCIES
  None

RETURNS


SIDE_EFFECT
  None

===========================================================================*/
void cmph_get_comm_mode_band_capab_with_pm(

  sd_ss_mode_pref_e_type *        comm_mode,
    /* Mode capability supported by the current target */

  sd_ss_band_pref_e_type *        comm_band,
    /* Band capability supported by the current target */

  sys_lte_band_mask_e_type *      comm_lte_band,
    /* LTE band capability supported by the current target */

  sd_ss_band_pref_e_type *        comm_tds_band,
    /* TD-SCDMA band capability supported by the current target */

  sys_modem_as_id_e_type       as_id
    /* ASID for which the capabilties are required */

)
{

  cm_mode_pref_e_type      mode_pref;
  cm_band_pref_e_type      band_pref;
  sys_lte_band_mask_e_type lte_band_pref;
  cm_band_pref_e_type      tds_band_pref;
  sys_sys_mode_mask_e_type pm_mode_mask = SYS_SYS_MODE_MASK_NONE;
  sys_band_mask_e_type     pm_band;
  sys_lte_band_mask_e_type pm_lte_band;
  sys_band_mask_e_type     pm_tds_band;
  cmph_s_type              *ph_ptr       = cmph_ptr();
  cmmsc_state_machine_s_type   *state_machine_ptr;


  mode_pref = CMPH_SS_MODE_PREF( as_id , ph_ptr );
  band_pref = CMPH_SS_BAND_PREF( as_id, ph_ptr );
  lte_band_pref = CMPH_SS_LTE_BAND_PREF( as_id, ph_ptr );
  tds_band_pref = CMPH_SS_TDS_BAND_PREF( as_id, ph_ptr );
  /* get mode and band capabilities of PM policy via state machine.  */

  if((as_id == SYS_MODEM_AS_ID_1) || \
      (as_id == SYS_MODEM_AS_ID_2) || \
      (as_id == SYS_MODEM_AS_ID_3)
     )
  {
    state_machine_ptr = cmmsimc_state_machine_ptr(as_id);
  }
  else
  {
    state_machine_ptr = cmmsimc_state_machine_ptr(SYS_MODEM_AS_ID_1);
  }

  if(state_machine_ptr != NULL)
  {
    pm_mode_mask    =  state_machine_ptr->stack_common_info.ue_mode_capability;
    pm_band         = state_machine_ptr->stack_common_info.ue_band_capability;
    pm_lte_band     = state_machine_ptr->stack_common_info.ue_lte_band_capability;
    pm_tds_band     = state_machine_ptr->stack_common_info.ue_tds_band_capability;

  *comm_mode = SD_GET_COMMON_MODE(cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref),\
                              cmph_map_sys_mode_mask_to_sd_mode_pref(pm_mode_mask));

  *comm_band = SD_GET_COMMON_BAND(cmph_map_cm_band_pref_to_sd_band_pref(band_pref),\
                              (sd_ss_band_pref_e_type)(pm_band));
  *comm_lte_band = SYS_LTE_BAND_MASK_COMMON(&lte_band_pref,&pm_lte_band);
  *comm_tds_band = SD_GET_COMMON_BAND(cmph_map_cm_band_pref_to_sd_band_pref(tds_band_pref),\
                              (sd_ss_band_pref_e_type)(pm_tds_band));
  }
  else
  {
    // mode and band pref from cmph ptr.
    CM_MSG_HIGH_0("State machine is null so fetch from cmph ptr");
    *comm_mode = cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref);
    *comm_band = cmph_map_cm_band_pref_to_sd_band_pref(band_pref);
    *comm_tds_band = cmph_map_cm_band_pref_to_sd_band_pref(tds_band_pref);
    *comm_lte_band = lte_band_pref;
  }

  CM_MSG_HIGH_6( "get common capab:, ASID=%d, comm_mode=%d,comm_band= 0x%08x %08x, comm_tds_band= 0x%08x %08x",
                  as_id, *comm_mode , 
                  QWORD_HIGH(*comm_band),QWORD_LOW(*comm_band), 
                  QWORD_HIGH(*comm_tds_band),QWORD_LOW(*comm_tds_band));
  cm_print_lte_band_mask(*comm_lte_band);

}



/*===========================================================================

FUNCTION cmph_is_valid_network_selection_mode_pref

DESCRIPTION
  Check whether a specified combination of network selection mode and mode
  preference is supported by the current target.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if the specified combination is supported.
  FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_is_valid_network_selection_mode_pref(

    cm_mode_pref_e_type                          mode_pref,
        /* Mode pref to check for validity */

    cm_network_sel_mode_pref_e_type              gw_network_sel_mode_pref
        /* Network selection mode pref to check for validity */
)
{

  /* Check if the mode preference is valid
  */
  if ( mode_pref == CM_MODE_PREF_NONE )
  {
    CM_ERR_0("mode pref. not valid");
    return FALSE;
  }

  /*
  ** Manual network selection mode preference is only allowed with a mode
  ** mode pref containing GW.
  */
  if ( gw_network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_MANUAL)
  {
    return TRUE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* When the GW network selection preference is Manual, check if the current
  ** mode preference and target supports GW.
  */
  /*
    ** We got here so Manual is requested.
    ** Check if the target even supports GWL/TDS.
    */
  if ((!sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_GSM,
                                            SD_SS_BAND_PREF_ANY,
                                            SYS_LTE_BAND_MASK_CONST_NONE,
                                            SD_SS_BAND_PREF_NONE))
        &&
        (!sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_WCDMA,
                                            SD_SS_BAND_PREF_ANY,
                                            SYS_LTE_BAND_MASK_CONST_NONE,
                                            SD_SS_BAND_PREF_NONE))

        &&
        (!sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_TDS,
                                            SD_SS_BAND_PREF_NONE,
                                            SYS_LTE_BAND_MASK_CONST_NONE,
                                            SD_SS_BAND_PREF_TDS_ANY))

        #ifdef FEATURE_CM_LTE
        &&
        (!sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_LTE,
                                            SD_SS_BAND_PREF_NONE,
                                            SYS_LTE_BAND_MASK_CONST_ANY,
                                            SD_SS_BAND_PREF_NONE))
        #endif
    )

  {
    return FALSE;
  }

  /*
    ** We got here so Manual is requested and G/W/L/TDS is supported by the target.
   */
  if (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref),
                             SD_SS_MODE_PREF_GSM)
        ||
        sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref),
                             SD_SS_MODE_PREF_WCDMA)
        ||
        sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref),
                             SD_SS_MODE_PREF_TDS)
        ||
        sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref),
                             SD_SS_MODE_PREF_LTE))

  {
    return TRUE;
  }

  return FALSE;


} /* cmph_is_valid_network_selection_mode_pref */


/*===========================================================================

FUNCTION cmph_call_start

DESCRIPTION
  Does necessary phone's call start activities.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  none

===========================================================================*/
void cmph_call_start
(

    cmcall_s_type    *call_ptr
        /* Pointer to a call object */
)
/*lint -esym(818, call_ptr) */
{

  cmph_s_type        *ph_ptr = cmph_ptr();
      /* Point at phone object */

  cmss_s_type        *ss_ptr = cmss_ptr();
      /* Point at ss object */

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  db_items_value_type  db_item;
      /* Item to do db_get() and db_put() */
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr   != NULL );
  CM_ASSERT( call_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if(cmph_is_dsda() && call_ptr->ss == CM_SS_HYBR_2 && !cmph_is_sxlte())
  {
    if(!ph_ptr->hybr2_is_in_use || !ph_ptr->hybr2_is_in_use_reported)
    {
      ph_ptr->hybr2_is_in_use = TRUE;
      cmph_event_per_subs( ph_ptr, CM_PH_EVENT_IN_USE_STATE, call_ptr->ss );
    }
  }
  #if defined FEATURE_MMODE_SXLTE_G
  else if (cmph_is_dsda() && call_ptr->ss == CM_SS_HYBR_3 && cmph_is_sxlte())
  {
    if(!ph_ptr->hybr3_is_in_use || !ph_ptr->hybr3_is_in_use_reported)
    {
      ph_ptr->hybr3_is_in_use = TRUE;
      cmph_event_per_subs( ph_ptr, CM_PH_EVENT_IN_USE_STATE, call_ptr->ss );
    }
  }
  #endif
  else
  #endif
  if( !ph_ptr->is_in_use || !ph_ptr->is_in_use_reported )
  {
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
    /* For now also update the data-base.
    */
    db_item.in_use = TRUE;
    db_put( DB_IN_USE, &db_item );
    #endif

    /* Indicate that phone is now in use
    ** and notify clients of event.
    */
    ph_ptr->is_in_use = TRUE;
    cmph_event_per_subs( ph_ptr, CM_PH_EVENT_IN_USE_STATE, call_ptr->ss );

  }

  if ( ss_ptr->info.sys_mode == SYS_SYS_MODE_CDMA )
  {
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))

    /* If this is an OTASP call, disable AUTO-NAM if necessary.
    */
    if( ( CM_CALL_TYPE_IS_OTASP(call_ptr->call_type) ||
          CM_CALL_TYPE_IS_OTAPA(call_ptr->call_type)
        )
        &&
        ph_ptr->nam_sel == CM_NAM_AUTO )
    {
      otasp_autonam_restore = TRUE;
      ph_ptr->nam_sel = ph_ptr->curr_nam;

      cmnv_item_ptr->auto_nam = FALSE;
      cmnv_write( NV_AUTO_NAM_I, cmnv_item_ptr );
    }
    else
    {
      otasp_autonam_restore = FALSE;
    }

    #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */
  } /* if ( ss_ptr->info.sys_mode == SYS_SYS_MODE_CDMA ) */
  #if (defined (FEATURE_GPSONE_MSBASED) || defined (FEATURE_GPSONE))

  cmpd_call_start( call_ptr->call_type, call_ptr->ss,
                   call_ptr->sys_mode, call_ptr->cmcall_mode_info.info_type,
                   NULL );

  #endif /* FEATURE_GPSONE_MSBASED */

  #if defined CM_GW_SUPPORTED
  cmregprx_proc_gw_resel_not_ok(cmph_map_cm_ss_type_to_sd_ss_type(call_ptr->ss));
  #endif   /* FEATURE_GSM || FEATURE_WCDMA */

  #if (defined (FEATURE_GPSONE_MSBASED) || defined (FEATURE_GPSONE))
  if(call_ptr->pd_status == CMCALL_PD_STATUS_END_ORIG )
  {
    call_ptr->end_status = CM_CALL_END_HDR_ORIG_DURING_GPS_FIX;
    return;
  }
  #endif

  return;

} /* cmph_call_start() */
/*lint +esym(818, call_ptr) */


/*===========================================================================

FUNCTION cmph_check_and_unforce_orig_mode

DESCRIPTION
  Process the origination parameters queue, and unforce the orig modes if
  required

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/


void cmph_check_and_unforce_orig_mode(

  cm_ss_e_type ss
    /* The ss on which to process the orig update
    */
)
{
  cm_orig_q_s_type      *q_ptr;

  cm_orig_q_s_type      *q_next_ptr;

  cmss_s_type           *ss_ptr       = cmss_ptr();
      /* Point at serving system object */

  dword                  uptime       = time_get_uptime_secs();
      /* Get the current uptime */

  boolean                is_q_updated    = FALSE;

  boolean                is_delete_orig_para = FALSE;
  boolean                is_act_below_ph_deleted = FALSE;
  int                    cnt_below_ph = 0;
  cm_act_orig_s_type*    last_pref_sent;

  boolean                is_top_obj_saved = FALSE;
  sd_ss_orig_mode_e_type saved_top_q_orig_mode = SD_SS_ORIG_MODE_NONE;
  cm_mode_pref_e_type    saved_top_q_user_mode_pref = CM_MODE_PREF_NONE;
  cm_band_pref_e_type    saved_top_q_band_pref = CM_BAND_PREF_NONE;
  sys_lte_band_mask_e_type    saved_top_q_lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
  cm_band_pref_e_type    saved_top_q_tds_band_pref = CM_BAND_PREF_NONE;

  cm_orig_q_s_type       *ph_orig_ptr = cmtask_orig_para_search_act_type( CM_SS_MAIN,
                                                                 CM_ACT_TYPE_PH_OBJ);
  sys_modem_as_id_e_type asubs_id = cmph_map_cm_ss_to_subs(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(ph_orig_ptr == NULL)
  {
    CM_ERR_0("Top ptr is NULL for MAIN stack");
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* Step 1: Step through the queue and delete all the modes that are marked
  **        for deletion
  ** Step 2: Force the mode that is at the top of the queue
  */

  q_ptr = cmtask_orig_para_get_first(ss);

  while(q_ptr != NULL)
  {
    q_next_ptr = cmtask_orig_para_get_next(q_ptr, ss);

    if( q_ptr->orig->orig_pref_term  == CM_PREF_TERM_CM_1_CALL_PLUS &&
        uptime >= q_ptr->orig->orig_mode_uptime )
    {

      /* Unforce the origination mode now if one of the following conditions is
      ** true:
      **
      ** 1. MS is currently not busy trying to reacquire service.
      ** 2. MS has lost service.
      ** 3. We are CMPH_HOLD_MODE_PREF_TIME or more in overtime.
      */
      if( ss == CM_SS_MAIN )
      {
        if( !ss_ptr->is_pref_srv_acq ||
             ss_ptr->main_srv_status == SYS_SRV_STATUS_NO_SRV ||
             ss_ptr->main_srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL ||
             ss_ptr->main_srv_status == SYS_SRV_STATUS_PWR_SAVE ||
             ss_ptr->main_srv_status == SYS_SRV_STATUS_PWR_SAVE_INTERNAL ||
             uptime >= (q_ptr->orig->orig_mode_uptime + CMPH_HOLD_MODE_PREF_TIME) )
        {
          is_delete_orig_para = TRUE;
        }
      }
      else if( ss == CM_SS_HYBR_2 )
      {
        if( !ss_ptr->hybr_gw_is_pref_srv_acq ||
             ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_NO_SRV ||
             ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL ||
             ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_PWR_SAVE ||
             ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_PWR_SAVE_INTERNAL ||
             uptime >= (q_ptr->orig->orig_mode_uptime + CMPH_HOLD_MODE_PREF_TIME) )
        {
          is_delete_orig_para = TRUE;
        }
      }
      #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
      else if( ss == CM_SS_HYBR_3)
      {
        if( !ss_ptr->hybr_3_gw_is_pref_srv_acq ||
             ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_NO_SRV ||
             ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL ||
             ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_PWR_SAVE ||
             ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_PWR_SAVE_INTERNAL ||
             uptime >= (q_ptr->orig->orig_mode_uptime + CMPH_HOLD_MODE_PREF_TIME) )
        {
          is_delete_orig_para = TRUE;
        }
      }
      #endif /* FEATURE_MMODE_TRIPLE_SIM */
      else if( ss == CM_SS_HYBR_1 )
      {
        if( !ss_ptr->hybr_1_is_pref_srv_acq ||
             ss_ptr->hybr_1_srv_status == SYS_SRV_STATUS_NO_SRV ||
             ss_ptr->hybr_1_srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL ||
             ss_ptr->hybr_1_srv_status == SYS_SRV_STATUS_PWR_SAVE ||
             ss_ptr->hybr_1_srv_status == SYS_SRV_STATUS_PWR_SAVE_INTERNAL ||
             uptime >= (q_ptr->orig->orig_mode_uptime + CMPH_HOLD_MODE_PREF_TIME) )
        {
          is_delete_orig_para = TRUE;
        }
      }
      else
      {
        is_delete_orig_para = TRUE;
      }

      if( is_delete_orig_para )
      {
        boolean is_notify_pmprx = (q_ptr->act_type == CM_ACT_TYPE_EMERG_CALL);

        CM_MSG_HIGH_3("cmph_force_orig_mode_on_the_fly() on %d || %d || %d",
                    (!ss_ptr->is_pref_srv_acq),
                    (ss_ptr->info.srv_status == SYS_SRV_STATUS_NO_SRV),
                    (uptime >= q_ptr->orig->orig_mode_uptime + CMPH_HOLD_MODE_PREF_TIME));
        CM_MSG_LOW_5("is_pref_srv_acq %d, srv_status %d, uptime %d, orig_mode_uptime %d, CMPH_HOLD_MODE_PREF_TIME %d",
                    ss_ptr->is_pref_srv_acq,
                    ss_ptr->info.srv_status,
                    uptime,
                    q_ptr->orig->orig_mode_uptime,
                    CMPH_HOLD_MODE_PREF_TIME);


        /* Save the top deleted OBJ */
        if(!is_top_obj_saved)
        {
          saved_top_q_orig_mode = q_ptr->orig->orig_mode;
          saved_top_q_user_mode_pref = q_ptr->orig->user_mode_pref;
          saved_top_q_band_pref = q_ptr->orig->orig_band_pref;
          saved_top_q_lte_band_pref = q_ptr->orig->orig_lte_band_pref;
          saved_top_q_tds_band_pref = q_ptr->orig->orig_tds_band_pref;

          is_top_obj_saved = TRUE;
        }

        if (q_ptr->orig->act_priority == CM_ACT_PRIORITY_BELOW_PH )
        {
          is_act_below_ph_deleted = TRUE;
        }

        /* Remove this q_ptr from the queue
        */
        is_q_updated = cmtask_orig_para_delete( ss, q_ptr, TRUE) || is_q_updated;

        /* We may have implemented new policy. Re-evaluate q_next_ptr */
        if (is_notify_pmprx)
        {
          cmpmprx_notify_call_end(cmph_map_cm_ss_to_subs(ss),TRUE);
          q_next_ptr = cmtask_orig_para_get_first(ss);
        }
      } /* if */

    }/* if q_ptr ... */

    q_ptr = q_next_ptr;

  }/* while q_ptr ... */


  cnt_below_ph = cmtask_orig_para_count_2(ss,
                                          CM_ACT_PRIORITY_BELOW_PH,
                                          CM_CMP_CRITERIA_EQUAL_TO) ;


  /* While data call is moved below the phone object, act_update_reas of
  ** ph object gets changed to ACT_UPDATE_REAS_USER. Hence after deleting
  ** all the calls below ph, update ph object act update reas to
  ** CM_ACT_UPDATE_REAS_ACT_START.
  */
  if(is_act_below_ph_deleted && cnt_below_ph == 0
     && ph_orig_ptr->orig->act_update_reas != CM_ACT_UPDATE_REAS_USER)
  {
     ph_orig_ptr->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_START;
  }

  /* If we deleted any origination modes, call the unforce routine
  */

 /*
  ** force if an activity with CM_ACT_PRIORITY_BELOW_PH
  ** was dequeued and no other such activities exist in the Q.
  ** example scenario:
  ** 1)PS call is made in cs+ps.
  ** 2)sys_sel_pref changes to cs only.
  ** 3)We force with cs+ps, but change the ph_ptr (top) to CS_only to be forced
  **   later.
  ** 4)Once the data call ends we need to force the top again.
  */

  if( is_q_updated || (is_act_below_ph_deleted && cnt_below_ph == 0) )
  {
     /* Remove the objects with priority end and above PH obj */
     cmph_remove_orig_mode_with_priority_end(ss);

     /* Get the last preference forced to SD*/
     last_pref_sent = cmph_get_last_pref_sent(ss);

     /* If ATCOP has forced PS detach, check whether the current
     ** preference to be forced is the same as the last one.
     ** If it's the same, don't force to SD.
     */
     if(cmph_ptr()->is_srv_domain_ps_detach_forced)
     {
       q_ptr = cmtask_orig_para_get_top(ss);

       if(q_ptr == NULL || last_pref_sent == NULL)
       {
         CM_ERR_0("q_ptr or last_pref_sent is NULL");
       }
       else if((q_ptr->orig->orig_mode_pref==last_pref_sent->orig_mode_pref)&&
           (q_ptr->orig->orig_band_pref == last_pref_sent->orig_band_pref)&&
           SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&(q_ptr->orig->orig_lte_band_pref),
             &(last_pref_sent->orig_lte_band_pref))&&
           (q_ptr->orig->orig_tds_band_pref ==
             last_pref_sent->orig_tds_band_pref)&&
           (q_ptr->orig->orig_prl_pref == last_pref_sent->orig_prl_pref)&&
           (q_ptr->orig->orig_roam_pref == last_pref_sent->orig_roam_pref)&&
           (q_ptr->orig->orig_hybr_pref == last_pref_sent->orig_hybr_pref)&&
           (q_ptr->orig->orig_int_hybr_pref ==
             last_pref_sent->orig_int_hybr_pref)&&
           (q_ptr->orig->orig_srv_domain_pref ==
             last_pref_sent->orig_srv_domain_pref))
        {
          cmph_ptr()->is_srv_domain_ps_detach_forced = FALSE;
          return;
        }

     }

     /* For any other preference force, reset the flag */
     cmph_ptr()->is_srv_domain_ps_detach_forced = FALSE;

     /* If the top OBJ changed, and the orig is not CSFB or VOLTE,
     ** re-evaluate the is_ps_detach_required flag.
     */
     if (is_top_obj_saved &&
         is_q_updated &&
         (saved_top_q_orig_mode < SD_SS_ORIG_MODE_PPCSFB_NORMAL_ORIG))
     {
       /* Get the top OBJ from the queue */
       q_ptr = cmtask_orig_para_get_top(ss);

       if(q_ptr == NULL)
       {
         CM_ERR_0("q_ptr is NULL");
       }
       else
       {
         cmph_s_type  *ph_ptr = cmph_ptr();
         if((q_ptr->act_type == CM_ACT_TYPE_PH_OBJ)&&
            cmph_ptr()->is_pref_change_pending[asubs_id])
         {
           /* Compare the saved top deleted OBJ with the PH OBJ
           ** to determine the is_ps_detach_required. */
           ph_ptr->is_ps_detach_required = 
           cmph_cmd_evaluate_is_ps_detach_required(
             asubs_id,
             saved_top_q_user_mode_pref,
             saved_top_q_band_pref,
             saved_top_q_lte_band_pref,
             saved_top_q_tds_band_pref,
             q_ptr->orig->orig_mode_pref,
             q_ptr->orig->orig_band_pref,
             q_ptr->orig->orig_lte_band_pref,
             q_ptr->orig->orig_tds_band_pref);

           cmph_ptr()->is_pref_change_pending[asubs_id] = FALSE;
           CM_MSG_HIGH_0("Set is_pref_change_pending to FALSE");
         }
       }
     }
     else
     {
       CM_MSG_HIGH_3("is_top_obj_saved=%d,saved_top_q_orig_mode=%d,q_updated=%d",
                    is_top_obj_saved,saved_top_q_orig_mode,is_q_updated);
     }

     /* If top object in the queue is Phone object, clear the
     ** pref_change_pending flag.
     */
     q_ptr = cmtask_orig_para_get_top(ss);

     if((!q_ptr || (q_ptr->act_type == CM_ACT_TYPE_PH_OBJ))&&
         cmph_ptr()->is_pref_change_pending[asubs_id])
     {
       cmph_ptr()->is_pref_change_pending[asubs_id] = FALSE;
     }

     /* Force the preference to SD */
     cmph_force_orig_mode_on_the_fly(ss);
  }

  return;
}

/*===========================================================================

FUNCTION cmph_remove_other_subs_act_priority_end

DESCRIPTION
  Remove the priority queue with activity priority = priority END from the other subs.

DEPENDENCIES
  none

RETURN VALUE
  TRUE: Call command requeued.
  False: Proceed with call origination.

SIDE EFFECTS
  none

===========================================================================*/
void    cmph_remove_other_subs_act_priority_end(
      sys_modem_as_id_e_type         asubs_id,

      boolean                        is_emerg,
      /* Indicate if remove other sub priority_end is due to emergency all origination */

      boolean                        is_force
      /* Indicate if forcing top pref is desired or not */
)
{
  if(asubs_id > SYS_MODEM_AS_ID_NONE &&
    asubs_id < SYS_MODEM_AS_ID_NO_CHANGE &&
    cmph_is_msim()
  )
  {
    sys_modem_as_id_e_type  other_sub = SYS_MODEM_AS_ID_NONE;
    cm_ss_e_type            other_ss = CM_SS_NONE;
    cm_ss_e_type            ss_arr[] = {CM_SS_NONE, CM_SS_NONE, CM_SS_NONE, CM_SS_NONE};
    uint8                   index = 0;

    #ifdef FEATURE_MMODE_TRIPLE_SIM
    sys_modem_as_id_e_type  other_sub2 = SYS_MODEM_AS_ID_NONE;
    cm_ss_e_type            other_ss2 = CM_SS_NONE;
    #endif

    #ifdef FEATURE_MMODE_TRIPLE_SIM
    if (cmph_is_tsts())
    {
      other_sub = ((asubs_id == SYS_MODEM_AS_ID_3)?SYS_MODEM_AS_ID_1:\
                    ((asubs_id == SYS_MODEM_AS_ID_2)?SYS_MODEM_AS_ID_1: SYS_MODEM_AS_ID_2));
      other_sub2 = ((asubs_id == SYS_MODEM_AS_ID_3)?SYS_MODEM_AS_ID_2:\
                    ((asubs_id == SYS_MODEM_AS_ID_2)?SYS_MODEM_AS_ID_3: SYS_MODEM_AS_ID_3));

      other_ss = cmph_map_subs_to_ss(other_sub);
      other_ss2 = cmph_map_subs_to_ss(other_sub2);
    }
    else
    #else
    {
      other_sub = (asubs_id == SYS_MODEM_AS_ID_2)?SYS_MODEM_AS_ID_1:SYS_MODEM_AS_ID_2;
      other_ss = cmph_map_subs_to_ss(other_sub);
    }
    #endif
    CM_MSG_HIGH_2("Remove other subs priority_end, other_sub=%d, other_ss=%d",
                   other_sub, other_ss);

    /* Delete and unforce priority = priority end on the other sub.
    */
    if (cmph_is_sxlte())
    {
      if (cmph_is_subs_feature_mode_1x_sxlte(other_sub) ||
        cmph_is_subs_feature_mode_sglte(other_sub))
      {
        ss_arr[index++] = CM_SS_MAIN;
        ss_arr[index++] = CM_SS_HYBR_1;
        ss_arr[index++] = CM_SS_HYBR_2;
      }
      else
      {
        ss_arr[index++] = other_ss;
      }
    }
    else
    {
      if (other_sub == SYS_MODEM_AS_ID_1)
      {
        ss_arr[index++] = CM_SS_MAIN;
        ss_arr[index++] = CM_SS_HYBR_1;

        #ifdef FEATURE_MMODE_TRIPLE_SIM
        if (cmph_is_tsts())
        {
          ss_arr[index++] = other_ss2;
        }
        #endif
      }
      else if (other_sub == SYS_MODEM_AS_ID_2)
      {
        ss_arr[index++] = other_ss;

        #ifdef FEATURE_MMODE_TRIPLE_SIM
        if (cmph_is_tsts())
        {
          ss_arr[index++] = other_ss2;
        }
        #endif
      }
    }
    {
      uint8 i = 0;
      for(;i < index && i < CM_SS_MAX; i++)
      {
        if (is_force)
        {
          cmph_remove_and_force_orig_mode_with_priority_end(ss_arr[i], TRUE);
        }
        else
        {
          cmph_remove_orig_mode_with_priority_end_resume_pm(ss_arr[i], TRUE);
        }
      }
    }
  }
}

/*===========================================================================

FUNCTION cmph_remove_and_force_orig_mode_with_priority_end

DESCRIPTION
  Process the origination parameters queue, and remove the specified orig
  modes with priority END and unforce the orig mode on ss.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void    cmph_remove_and_force_orig_mode_with_priority_end(
    cm_ss_e_type            ss,

    boolean                 is_emerg
    /* Indicate if remove priority_end is due to emergency all origination
    ** on the other sub
    */
)
{
  if(ss > CM_SS_NONE && ss < CM_SS_MAX)
  {
    /* Delete the ended pref from priority queue.
    */
    if (cmph_remove_orig_mode_with_priority_end(ss))
    {
      if (is_emerg)
      {
        cmpmprx_notify_call_end(cmph_map_cm_ss_to_subs(ss), FALSE);
      }

      cmph_force_orig_mode_on_the_fly(ss);
    }
  }
}


/*===========================================================================

FUNCTION cmph_remove_orig_mode_with_priority_end

DESCRIPTION
  Process the origination parameters queue, and remove the specified orig
  modes with priority END

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void    cmph_remove_orig_mode_with_priority_end_resume_pm(
    cm_ss_e_type            ss,

    boolean                 is_emerg
    /* Indicate if remove priority_end is due to emergency all origination
    ** on the other sub
    */
)
{
  if(ss > CM_SS_NONE && ss < CM_SS_MAX)
  {
    /* Delete the ended pref from priority queue.
    */
    if (cmph_remove_orig_mode_with_priority_end(ss))
    {
      if (is_emerg)
      {
        cmpmprx_notify_call_end(cmph_map_cm_ss_to_subs(ss), FALSE);
      }
    }
  }
}

/*===========================================================================

FUNCTION cmph_remove_act_id_and_force_orig_mode

DESCRIPTION
  Process the origination parameters queue, and remove the specified act id
  and unforce the orig mode on ss.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void    cmph_remove_act_id_and_force_orig_mode(
    cm_ss_e_type            ss,

    cm_act_id_type            act_id,
      /* The unique id of the activity */
    boolean                 is_emerg
    /* Indicate if remove priority_end is due to emergency all origination
    ** on the other sub
    */
)
{
  boolean top_ptr_changed=FALSE;
  
  if(ss == CM_SS_MAX)
  {
    cmph_remove_act_id_and_force_orig_mode(CM_SS_MAIN,act_id,is_emerg);
    cmph_remove_act_id_and_force_orig_mode(CM_SS_HYBR_1,act_id,is_emerg);
    cmph_remove_act_id_and_force_orig_mode(CM_SS_HYBR_2,act_id,is_emerg);
    cmph_remove_act_id_and_force_orig_mode(CM_SS_HYBR_3,act_id,is_emerg);
  }
  else if(ss > CM_SS_NONE && ss < CM_SS_MAX)
  {  
    /* Delete the ended pref from priority queue.
    */
    if (cmph_remove_orig_mode_with_act_id(ss,act_id,&top_ptr_changed))
    {
      CM_MSG_HIGH_3("Removed act_id = %d on ss %d, top_changed = %d",act_id,ss,top_ptr_changed);
      if (is_emerg)
      {
        cmpmprx_notify_call_end(cmph_map_cm_ss_to_subs(ss), is_emerg);
      }
      cmph_force_orig_mode_on_the_fly(ss);
    }
  }
}

/*===========================================================================

FUNCTION cmph_remove_orig_mode_with_priority_end

DESCRIPTION
  Process the origination parameters queue, and remove the specified orig
  modes with priority END

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_remove_orig_mode_with_priority_end(

  cm_ss_e_type ss
    /* The ss on which to process the orig update
    */
)
{
  cm_orig_q_s_type   *q_ptr;
  cm_orig_q_s_type   *q_next_ptr;
  boolean             cmd_deleted = FALSE;
  cm_orig_q_s_type   *orig_ptr = NULL;
  boolean             is_emerg_call_ended = FALSE;
  boolean             is_skip_pm_resume = FALSE;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Remove all the call objects with priority END in the priority Q.
  */

  q_ptr = cmtask_orig_para_get_first(ss);

  while(q_ptr != NULL)
  {
    q_next_ptr = cmtask_orig_para_get_next(q_ptr, ss);
    
    if((q_ptr->orig->act_priority ==CM_ACT_PRIORITY_END) &&
       ((q_ptr->act_type > CM_ACT_TYPE_NONE) &&
        (q_ptr->act_type < CM_ACT_TYPE_PH_OBJ)))
    {
      CM_MSG_HIGH_1( "Deleting act type %d, priority END",
                  q_ptr->act_type );

      if ( q_ptr->act_type == CM_ACT_TYPE_EMERG_CALL )
      {
        is_emerg_call_ended = TRUE;
      }

      /* Remove this q_ptr from the queue
      */
      (void)cmtask_orig_para_delete( ss, q_ptr, TRUE);
       cmd_deleted = TRUE;
    }/* if q_ptr ... */

    q_ptr = q_next_ptr;

  }/* while q_ptr ... */


  /* If we are deleting the last emergency call with priority end then unsuspend PM */
  if (is_emerg_call_ended == TRUE)
  {
    if(((orig_ptr = cmtask_orig_para_search_act_type( CM_SS_MAIN,
                                                     CM_ACT_TYPE_EMERG_CALL )) != NULL)
        
        #if defined FEATURE_MMODE_DUAL_SIM || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
        || ((orig_ptr = cmtask_orig_para_search_act_type( CM_SS_HYBR_2,
                                                     CM_ACT_TYPE_EMERG_CALL )) != NULL)
        #endif

        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        || ((orig_ptr = cmtask_orig_para_search_act_type( CM_SS_HYBR_3,
                                                     CM_ACT_TYPE_EMERG_CALL )) != NULL)
        #endif
        || (cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) && cmac_is_in_thermal_emergency())
      ) 
    {
      is_skip_pm_resume = TRUE;
    }

    if ((is_skip_pm_resume == FALSE) &&
        cmpm_ptr()->is_pm_suspend)
    {
      CM_MSG_HIGH_0("PMPRX: resume PM");
      policyman_resume();
      cmpm_ptr()->is_pm_suspend = FALSE;
    }
  }
  
  return cmd_deleted;
} /* cmph_remove_orig_mode_with_priority_end() */


/*===========================================================================

FUNCTION cmph_remove_orig_mode_data_call_below_ph

DESCRIPTION
  Process the origination parameters queue, and removes the preferences which are below PH and corresponding call
  is not active.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void cmph_remove_orig_mode_data_call_below_ph(

  cm_ss_e_type ss
)
{
  cm_orig_q_s_type   *q_ptr;
  cm_orig_q_s_type   *q_next_ptr;
  cmcall_s_type       *call_ptr = NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_0("cmph_remove_orig_mode_with_priority_end");

  /*
  ** Remove all the call objects with priority END in the priority Q.
  */

  q_ptr = cmtask_orig_para_get_first(ss);

  while(q_ptr != NULL)
  {
    q_next_ptr = cmtask_orig_para_get_next(q_ptr, ss);

    /* Remove DATA call preferences which are in end state.
        In global mode, after data call is connected, PS call will be pushed below PH.
        Even after call end, act_priority will not be set to PRIORITY_END as they are below PH.

        CM should not delete preferences for data calls, which are kept below PH and call is still active 

        CM should still delete call preferences which are waiting for call end confirmation from NAS. Else,
        CM will end up sending the CS_PS servcie request again.
        */
    call_ptr = cmcall_ptr((uint8)q_ptr->orig->act_id);
    if(q_ptr->act_type == CM_ACT_TYPE_DATA_CALL &&
       (((q_ptr->orig->act_priority == CM_ACT_PRIORITY_BELOW_PH) &&
        (call_ptr== NULL)) || ((call_ptr != NULL) &&
        (call_ptr->call_subst.idle == CM_CALL_IDLE_SUBST_ENDWAIT)))
      )
    {
      CM_MSG_HIGH_1( "Deleting act type %d, priority below",
                  q_ptr->act_type );

      /* Remove this q_ptr from the queue
      */
      (void)cmtask_orig_para_delete( ss, q_ptr, TRUE);
    }/* if q_ptr ... */

    q_ptr = q_next_ptr;

  }/* while q_ptr ... */

  return ;
} /* cmph_remove_orig_mode_with_priority_end() */

/*===========================================================================

FUNCTION cmph_remove_orig_mode_with_act_id

DESCRIPTION
  Process the origination parameters queue, and remove the specified act id entity

DEPENDENCIES
  None

RETURN VALUE
  command deleted or not
  
SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_remove_orig_mode_with_act_id(

  cm_ss_e_type ss,
    /* The ss on which to process the orig update
    */
  cm_act_id_type            act_id,
   /* The unique id of the activity */
  boolean *top_ptr_changed
)
{
  cm_orig_q_s_type   *q_ptr; 
  boolean             cmd_deleted=FALSE;

  *top_ptr_changed = FALSE;
  
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_2("cmph_remove_orig_mode_with_act_id = %d, ss %d",act_id,ss);

  /*
  ** Remove the call object with act_id in the priority Q.
  */
  q_ptr = cmtask_orig_para_search_act_id(ss, act_id);

  /* Remove this q_ptr from the queue
     */
  if(q_ptr!=NULL)
  {
    CM_MSG_HIGH_2( "Deleting act type %d, on SS %d",
                  q_ptr->act_type,ss );
    *top_ptr_changed = cmtask_orig_para_delete( ss, q_ptr, TRUE); 
    cmd_deleted= TRUE;
  }
  else
  {
    CM_MSG_HIGH_0("act_id NOT found in queue");
  }
  
  return cmd_deleted;
} /* cmph_remove_orig_mode_with_act_id() */



/*===========================================================================

FUNCTION cmph_remove_orig_mode

DESCRIPTION
  Process the origination parameters queue, and remove the specified orig
  modes

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/


void cmph_remove_orig_mode(

  cm_ss_e_type ss,
    /* The ss on which to process the orig update
    */

  cm_act_type_e_type act_type,
    /* The activity type to check
    */

  cm_act_priority_e_type prio_type
    /* The priority type to check, use CM_ACT_PRIORITY_MAX for wildcard entry
    ** If wildcard entry is specified, then all activities of act_type will
    ** be removed regardless of act_prio
    */
)
{
  cm_orig_q_s_type      *q_ptr;

  cm_orig_q_s_type      *q_next_ptr;
  cm_orig_q_s_type      *orig_ptr = NULL;
  boolean                is_emerg_call_ended = FALSE;
  boolean                is_skip_pm_resume = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* Step 1: Step through the queue and delete all the modes that are marked
  **        for deletion
  */

  q_ptr = cmtask_orig_para_get_first(ss);

  while(q_ptr != NULL)
  {
    q_next_ptr = cmtask_orig_para_get_next(q_ptr, ss);

    if( cmph_is_pref_term_temporary(
                            q_ptr->orig->orig_pref_term ) &&
              (q_ptr->act_type == act_type) &&
              (q_ptr->orig->act_priority == prio_type ||
               prio_type == CM_ACT_PRIORITY_MAX)
      )
    {
      CM_MSG_HIGH_1( "Deleting act type %d",
                   q_ptr->act_type);

      if ( q_ptr->act_type == CM_ACT_TYPE_EMERG_CALL )
      {
        is_emerg_call_ended = TRUE;
      }

      /* Remove this q_ptr from the queue
      */
      (void)cmtask_orig_para_delete( ss, q_ptr, TRUE);

    }/* if q_ptr ... */

    q_ptr = q_next_ptr;

  }/* while q_ptr ... */

  /* If we are deleting the last emergency call with priority end then unsuspend PM */
  if (is_emerg_call_ended == TRUE)
  {
    if(((orig_ptr = cmtask_orig_para_search_act_type( CM_SS_MAIN,
                                                     CM_ACT_TYPE_EMERG_CALL )) != NULL)
        
    #if defined FEATURE_MMODE_DUAL_SIM || defined FEATURE_MMODE_SC_SVLTE || defined FEATURE_MMODE_SC_SGLTE
        || ((orig_ptr = cmtask_orig_para_search_act_type( CM_SS_HYBR_2,
                                                     CM_ACT_TYPE_EMERG_CALL )) != NULL)
    #endif

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        || ((orig_ptr = cmtask_orig_para_search_act_type( CM_SS_HYBR_3,
                                                     CM_ACT_TYPE_EMERG_CALL )) != NULL)
    #endif
        || (cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) && cmac_is_in_thermal_emergency())
      ) 
    {
      is_skip_pm_resume = TRUE;
    }

    CM_MSG_HIGH_1("PMPRX: resume PM %d", is_skip_pm_resume);
    if ((is_skip_pm_resume == FALSE) &&
        cmpm_ptr()->is_pm_suspend)
    {
      cmpmprx_notify_call_end(cmph_map_cm_ss_to_as_id(ss), TRUE);
    }
  }

  return;
} /* cmph_check_and_unforce_data_orig_mode() */


/*===========================================================================

FUNCTION cmph_remove_orig_csg_params

DESCRIPTION
  Process the origination parameters queue, and remove the CSG Params for
  EMERGENCY, DATA, SMS and VOICE calls.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/


void cmph_remove_orig_csg_params(

  cm_ss_e_type ss,
    /* The ss on which to process the orig update
    */
  sys_radio_access_tech_e_type       csg_rat
    /* CSG RAT for which CSG orig params to be removed
    */
)
{
  cm_orig_q_s_type      *q_ptr;

  cm_orig_q_s_type      *q_next_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_2("cmph_remove_orig_csg_params for ss %d csg_rat %d", ss, csg_rat);

  /* Step 1: Step through the queue and delete all the modes that are marked
  **        for deletion
  */

  q_ptr = cmtask_orig_para_get_first(ss);

  while(q_ptr != NULL)
  {
    q_next_ptr = cmtask_orig_para_get_next(q_ptr, ss);

    if(q_ptr->orig->csg_rat == csg_rat &&
       q_ptr->orig->csg_id  != SYS_CSG_ID_INVALID)
  {
      CM_MSG_HIGH_2( "WRLF marking CSG info Invalid for act_type :%d csg_id%d",
                  q_ptr->act_type, q_ptr->orig->csg_id);

    q_ptr->orig->csg_id = SYS_CSG_ID_INVALID;
    q_ptr->orig->csg_rat = SYS_RAT_NONE;
  }

    q_ptr = q_next_ptr;
  }/* while q_ptr ... */

  return;
} /* cmph_remove_orig_csg_params() */

/*===========================================================================

FUNCTION cmph_pd_session_start

DESCRIPTION
  Does necessary phone's pd session start activities.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_pd_session_start()
{

  #if defined CM_GW_SUPPORTED
  cmregprx_proc_gw_resel_not_ok(SD_SS_MAIN);
  #endif   /* FEATURE_GSM || FEATURE_WCDMA */

}/* cmph_pd_session_start */


/*===========================================================================
FUNCTION cmph_pd_session_end

DESCRIPTION
  Does necessary phone's pd session end activities.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_pd_session_end()
{

  #ifdef FEATURE_GPSONE
  cmph_s_type        *ph_ptr = cmph_ptr();
     /* Get the pointer to the phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check whether we need to unforce the mode preference that was forced
  ** by the user.
  */

  switch( ph_ptr->main_stack_info.pref_info.pref_term )
  {
    case CM_PREF_TERM_1_CALL:
    case CM_PREF_TERM_1_CALL_OR_TIME:

      /* If mode was forced by a client for the duration of one call,
      ** unforce it now and notify clients of event.
      */
      (void) cmph_unforce_mode_on_the_fly( ph_ptr, CM_SS_MAIN );

      cmph_event( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF );
      break;

    case CM_PREF_TERM_CM_1_CALL:

      /* If mode preference was forced by CM on the fly for the duration
      ** of the one call, unforce the mode now.
      */
      (void) cmph_unforce_mode_on_the_fly( ph_ptr, CM_SS_MAIN );
      break;

    case CM_PREF_TERM_CM_1_CALL_PLUS:

      /* If mode preference was forced by CM on the fly for the duration
      ** of one call plus, indicate that we should unforce the mode
      ** preference in CMPH_HOLD_MODE_PREF_TIME seconds.
      **
      ** NOTE that we delay unforcing the mode preference in order to
      ** avoid loading MC with pref sys changes in a situation where
      ** the user is pressing SEND, END, SEND, END, ...
      */
      ph_ptr->main_stack_info.pref_info.mode_uptime = time_get_uptime_secs() +
                            CMPH_HOLD_MODE_PREF_TIME;

     break;

    default:
      break;
  }

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Inform CMSS that the phone is not in use.
  */
  cmss_proc_call_ended();

  #if defined CM_GW_SUPPORTED

  cmregprx_proc_gw_resel_ok(SD_SS_MAIN);
  #endif  /* FEATURE_GSM || FEATURE_WCDMA */

  CM_ASSERT(!ph_ptr->is_in_use);

  #endif /* FEATURE_GPSONE */

} /* cmpd_session_end() */

/*===========================================================================

FUNCTION cmph_call_end_process

DESCRIPTION
  Does necessary phone's call end activities.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_call_end_process
(

  const cmcall_s_type    *call_ptr
      /* Pointer to a call object */
)
{
  /* Number of allocated calls equal to 1 means that this is the
     last call that is being ended, so we need to notify the phone now.
  */

  if(cmph_is_dsda())
  {
    sys_modem_as_id_e_type  asubs_id = cmph_map_cm_ss_to_subs(call_ptr->ss);

    if( (call_ptr->ss == CM_SS_HYBR_2 && !cmph_is_sxlte() &&
        cmcall_call_ids_allocated_per_as_id(asubs_id) == 1)
        #if defined FEATURE_MMODE_SXLTE_G
        ||
        (call_ptr->ss == CM_SS_HYBR_3 && cmph_is_sxlte() &&
         cmcall_call_ids_allocated_per_as_id(asubs_id) == 1)
        #endif
      )
    {
      cmph_call_end_hybr_ss( call_ptr );
    }
    else if (cmcall_call_ids_allocated_per_as_id(asubs_id) == 1)
    {
      cmph_call_end( call_ptr );
    }
  }
  else if(cm_number_of_allocated_calls() == 1)
  {
    cmph_call_end( call_ptr );
  }

  if(call_ptr->call_type == CM_CALL_TYPE_EMERGENCY)
  {
    cmac_enable_emergency_if_pending();
  }
}

/*===========================================================================

FUNCTION cmph_call_end

DESCRIPTION
  Does necessary phone's call end activities.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_call_end
(

  const cmcall_s_type    *call_ptr
      /* Pointer to a call object */
)
{
  cmph_s_type             *ph_ptr = cmph_ptr();
     /* Get the pointer to the phone object */

  cmss_s_type             *ss_ptr = cmss_ptr();
      /* Point at ss object */

  sys_modem_as_id_e_type   asubs_id = SYS_MODEM_AS_ID_1;

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  db_items_value_type  db_item;
    /* Item to do db_get() and db_put() */
  #endif /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(call_ptr != NULL);
  CM_ASSERT(ph_ptr   != NULL);
  CM_ASSERT(ss_ptr   != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* set asubs id for the call */
  asubs_id = call_ptr->asubs_id;


  #if (defined(FEATURE_JCDMA) && !defined(FEATURE_MMODE_REMOVE_1X))

  /* Disable voice activity test whenever call ends
  */
  txc_set_voc_activity( FALSE, 0, 0, 0);
  #endif /* FEATURE_JCDMA */

  if (( ss_ptr->info.sys_mode == SYS_SYS_MODE_CDMA ) ||
      #ifdef FEATURE_HDR
      ( ss_ptr->info.sys_mode == SYS_SYS_MODE_HDR ) ||
      #endif  /* FEATURE_HDR */
      ( ss_ptr->info.sys_mode == SYS_SYS_MODE_AMPS ))
  {
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* If this is an OTASP call, enable AUTO-NAM if necessary. Do it only if
    ** it was enabled prior to OTASP call.
    */
    if( ( CM_CALL_TYPE_IS_OTASP(call_ptr->call_type) ||
          CM_CALL_TYPE_IS_OTAPA(call_ptr->call_type)
        )
        &&
        otasp_autonam_restore == TRUE )
    {
      otasp_autonam_restore = FALSE;
      ph_ptr->nam_sel = CM_NAM_AUTO;

      cmnv_item_ptr->auto_nam = TRUE;
      cmnv_write( NV_AUTO_NAM_I, cmnv_item_ptr );
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Indicate that phone is NOT in use any more
    ** and notify clients of event.
    */

    /* For now also update the data-base ????
    */
    db_item.in_use = FALSE;
    db_put( DB_IN_USE, &db_item );

    db_item.conv = FALSE;
    db_put( DB_CONV, &db_item );

    #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */
  } /* if ( ss_ptr->info.sys_mode == SYS_SYS_MODE_CDMA ) */

  #ifdef FEATURE_IS2000_REL_A
  if ( cm_number_of_allocated_calls() == 1 )
  {
    ph_ptr->is_in_use = FALSE;
  }
  #else
  ph_ptr->is_in_use = FALSE;
  #endif /* FEATURE_IS2000_REL_A */

  if ( cm_number_of_allocated_calls() == 1  &&
       cmph_is_subs_feature_mode_sglte(asubs_id)
     )
  {
    ph_ptr->is_in_use = FALSE;
    cmph_event_per_subs( ph_ptr, CM_PH_EVENT_IN_USE_STATE, CM_SS_MAIN);  //shivank: since sglte, this can remain ss main */
  }
  else
  {
    cmph_event_per_subs( ph_ptr, CM_PH_EVENT_IN_USE_STATE, call_ptr->ss);
  }

  /* Check if we have a PD session going
  ** If a PD session is going, don't unforce the mode
  */
  #if( defined (FEATURE_GPSONE_MSBASED) || defined (FEATURE_GPSONE) )
  if( !cmpd_is_session_active( cmpd_ptr(CMPD_SESSION_OBJ_MAIN)) &&
      !cmpd_is_session_active( cmpd_ptr(CMPD_SESSION_OBJ_DMOD)) )
  #endif /* FEATURE_GPSONE */
  {

    /* Check whether we need to unforce the mode preference that was forced
    ** by the user.
    */

    switch( CMPH_SS_PREF_TERM(call_ptr->asubs_id,ph_ptr) )
    {
      case CM_PREF_TERM_1_CALL:
      case CM_PREF_TERM_1_CALL_OR_TIME:

        /* If mode was forced by a client for the duration of one call,
        ** unforce it now and notify clients of event.
        */
        (void) cmph_unforce_mode_on_the_fly( ph_ptr, call_ptr->ss );

        cmph_event( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF );
        break;


      case CM_PREF_TERM_CM_1_CALL:

        /* If mode preference was forced by CM on the fly for the duration
        ** of the one call, unforce the mode now.
        */
        (void) cmph_unforce_mode_on_the_fly( ph_ptr, call_ptr->ss );
        break;


      case CM_PREF_TERM_CM_1_CALL_PLUS:

        /* If mode preference was forced by CM on the fly for the duration
        ** of one call plus, indicate that we should unforce the mode
        ** preference in CMPH_HOLD_MODE_PREF_TIME seconds.
        **
        ** NOTE that we delay unforcing the mode preference in order to
        ** avoid loading MC with pref sys changes in a situation where
        ** the user is pressing SEND, END, SEND, END, ...
        */
        ph_ptr->main_stack_info.pref_info.mode_uptime = time_get_uptime_secs() +
                              CMPH_HOLD_MODE_PREF_TIME;


        break;

      default:
        break;
    }

    #if defined CM_GW_SUPPORTED
    cmregprx_proc_gw_resel_ok(cmph_map_cm_ss_type_to_sd_ss_type(call_ptr->ss));
    #endif  /* FEATURE_GSM || FEATURE_WCDMA */

  } /* if */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If answer-voice setting is for one call, default it back
  ** to answer-voice-as-voice and notify clients of event.
  */
  if( (ph_ptr->answer_voice == CM_ANSWER_VOICE_AS_FAX_ONCE    ||
       ph_ptr->answer_voice == CM_ANSWER_VOICE_AS_MODEM_ONCE) &&
       !call_ptr->is_user_originated_call )
  {
    ph_ptr->answer_voice = CM_ANSWER_VOICE_AS_VOICE;
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
    db_item.voice_as_data  = DB_VOICE_AS_DATA_NEVER;
    db_put( DB_VOICE_AS_DATA, &db_item );
    #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */
    cmph_event( ph_ptr, CM_PH_EVENT_ANSWER_VOICE );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Inform CMSS that the phone is not in use.
  */
  cmss_proc_call_ended();

  /* For SGLTE, it is possible that the other stack still has an active call */
  #ifndef FEATURE_MMODE_SC_SGLTE
  CM_ASSERT(!ph_ptr->is_in_use);
  #endif

  if(TRUE == cmrpm_is_rpm_enabled())
  {
    cmrpm_process_call_end();
  }

  #ifdef FEATURE_MMODE_RPM_TDSCDMA
  cmrpm_tds_process_call_end();
  #endif

} /* cmph_call_end() */

/*===========================================================================

FUNCTION cmph_call_end_hybr_ss

DESCRIPTION
  Does necessary phone's call end activities for hybr ss.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_call_end_hybr_ss
(
  const cmcall_s_type    *call_ptr
      /* Pointer to a call object */

)
{
  #ifndef FEATURE_MMODE_DUAL_ACTIVE
  SYS_ARG_NOT_USED(call_ptr);
  return;

  #else
  cm_ss_e_type            cm_ss = call_ptr->ss;
  cmph_s_type             *ph_ptr = cmph_ptr();
     /* Get the pointer to the phone object */

  if (!cmph_is_dsda() || cm_ss == CM_SS_MAIN)
  {
    return;
  }

  switch (cm_ss)
  {
    case CM_SS_HYBR_2:
      if (!cmph_is_sxlte())
      {
  ph_ptr->hybr2_is_in_use = FALSE;
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_IN_USE_STATE, call_ptr->ss);
      }
      break;

    #if defined FEATURE_MMODE_SXLTE_G
    case CM_SS_HYBR_3:
      ph_ptr->hybr3_is_in_use = FALSE;
  cmph_event_per_subs( ph_ptr, CM_PH_EVENT_IN_USE_STATE, call_ptr->ss);
      break;
    #endif

    default:
      break;
  }

  #endif
}

/*===========================================================================

FUNCTION cmph_is_waiting_for_reply

DESCRIPTION
  Check whether the phone object is currently waiting for a reply.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  TRUE if phone object is currently waiting for a rely, FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_waiting_for_reply( void )
{
  return( cm_reply_is_waiting(&cmph_ptr()->reply) );

} /* cmph_is_waiting_for_reply() */



/*===========================================================================

FUNCTION cmph_info_get

DESCRIPTION
  Copy the current phone state information into a specified buffer.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  TRUE if phone information is valid, FALSE otherwise.

  Note that phone information only becomes valid after cmph_init()
  returns.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_info_get(

    cm_ph_info_s_type       *ph_info_ptr,
        /* Copy phone state info into this buffer */

    cm_ss_e_type            ss
       /* hybr2 maps to as_id 2 */
)
{

  cmph_s_type          *ph_ptr = cmph_ptr();
    /* Point at phone object */

  sys_modem_as_id_e_type  asubs_id = cmph_map_cm_ss_to_subs(ss);

  cmph_sub_config_s_type  *cmph_sub_info = cmph_get_sub_config_ptr(asubs_id);

  cm_mode_pref_e_type               mapped_mode_pref = CM_MODE_PREF_NONE;

  #ifdef FEATURE_DDTM_CNTL
  unsigned int         i;
  #endif
  #if defined( FEATURE_CM_LTE )&& defined( CM_DEBUG )
  #error code not present
#endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( ph_info_ptr != NULL );

  /* Verify that object was properly initialized.
  */
  CM_ASSERT( CM_INIT_CHECK(ph_ptr->init_mask) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( ( asubs_id <= SYS_MODEM_AS_ID_NONE || asubs_id >= SYS_MODEM_AS_ID_MAX ) &&
      ( asubs_id != SYS_MODEM_AS_ID_NO_CHANGE ) )
  {
    CM_MSG_HIGH_2( "Invalid asubs_id %d for ss = %d", asubs_id, ss );
    return FALSE;
  }

  /* Check integrity of phone state.
  */

  CM_ASSERT( ph_ptr->is_in_use == TRUE ||  /* check against corruption */
             ph_ptr->is_in_use == FALSE );

  CM_ASSERT( BETWEEN(ph_ptr->oprt_mode,
                     SYS_OPRT_MODE_NONE,
                     SYS_OPRT_MODE_MAX) );

  CM_ASSERT( BETWEEN(ph_ptr->cdma_lock_mode,
                     CM_CDMA_LOCK_MODE_NONE,
                     CM_CDMA_LOCK_MODE_MAX) );

  CM_ASSERT( INRANGE(CMPH_SS_MODE_PREF(asubs_id, ph_ptr),
                     CM_MODE_PREF_NONE,
                     CM_MODE_PREF_MAX) );

  CM_ASSERT( BETWEEN(CMPH_SS_PREF_TERM(asubs_id, ph_ptr),
                     CM_PREF_TERM_NONE,
                     CM_PREF_TERM_MAX) );

  #ifdef FEATURE_CM_LTE
  CM_ASSERT( BETWEEN(ph_ptr->main_stack_info.pref_info.band_pref,
                     CM_BAND_PREF_NONE,
                     CM_BAND_PREF_MAX) ||
             (!SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&(ph_ptr->main_stack_info.pref_info.lte_band_pref)) &&
              SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&lte_band_pref_any,&(ph_ptr->main_stack_info.pref_info.lte_band_pref))
              )
           );
  #else
  CM_ASSERT( BETWEEN(ph_ptr->main_stack_info.pref_info.band_pref,
                     CM_BAND_PREF_NONE,
                     CM_BAND_PREF_MAX) );
  #endif

  CM_ASSERT( INRANGE(CMPH_SS_ROAM_PREF(asubs_id, ph_ptr),
                     CM_ROAM_PREF_NONE,
                     CM_ROAM_PREF_MAX) );

  CM_ASSERT( BETWEEN(ph_ptr->nam_sel,
                     CM_NAM_NONE,
                     CM_NAM_MAX) );

  CM_ASSERT( ph_ptr->curr_nam != CM_NAM_AUTO );
  CM_ASSERT( BETWEEN(ph_ptr->curr_nam,
                     CM_NAM_NONE,
                     CM_NAM_MAX) );

  CM_ASSERT( ph_ptr->nam_sel == ph_ptr->curr_nam ||
             ph_ptr->nam_sel == CM_NAM_AUTO )

  CM_ASSERT( BETWEEN(ph_ptr->packet_state,
                     CM_PACKET_STATE_NONE,
                     CM_PACKET_STATE_MAX) );

   CM_ASSERT( BETWEEN(ph_ptr->ph_state,
                     CM_PH_STATE_NONE,
                     CM_PH_STATE_MAX) );

  CM_ASSERT( BETWEEN(CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id,ph_ptr),
                     CM_NETWORK_SEL_MODE_PREF_NONE,
                     CM_NETWORK_SEL_MODE_PREF_MAX) );

  CM_ASSERT( BETWEEN(CMPH_SS_ACQ_ORDER_PREF(asubs_id,ph_ptr),
                     CM_GW_ACQ_ORDER_PREF_NONE,
                     CM_GW_ACQ_ORDER_PREF_MAX) );

  CM_ASSERT( INRANGE(CMPH_SS_SRV_DOMAIN_PREF(asubs_id,ph_ptr),
                     CM_SRV_DOMAIN_PREF_NONE,
                     (CM_SRV_DOMAIN_PREF_MAX-1)) );

  CM_ASSERT( BETWEEN(ph_info_ptr->answer_voice,
                     CM_ANSWER_VOICE_NONE,
                     CM_ANSWER_VOICE_MAX) );


  #ifdef FEATURE_HDR_HYBRID
  CM_ASSERT( BETWEEN(ph_ptr->main_stack_info.pref_info.hybr_pref,
                      CM_HYBR_PREF_NONE,
                      CM_HYBR_PREF_MAX) );
  #endif /* FEATURE_HDR_HYBRID */

  #ifdef FEATURE_DDTM_CNTL
  CM_ASSERT( BETWEEN(ph_ptr->ddtm_pref,
                      CM_DDTM_PREF_NONE,
                      CM_DDTM_PREF_MAX) );
  #endif /* FEATURE_DDTM_CNTL */

  CM_ASSERT( INRANGE(ph_ptr->line,
                     CM_ALS_LINE_NONE,
                     CM_ALS_LINE_MAX) );

  CM_ASSERT( INRANGE(ph_ptr->line_switching,
                     CM_ALS_LINE_SWITCHING_NONE,
                     CM_ALS_LINE_SWITCHING_MAX));

  CM_ASSERT( INRANGE(ph_ptr->main_stack_info.pref_info.user_net_sel_mode,
                     CM_USER_NETWORK_SEL_MODE_PREF_NONE,
                     CM_USER_NETWORK_SEL_MODE_PREF_MAX));
  CM_ASSERT( INRANGE(ph_ptr->hybr_2_stack_info.pref_info.user_net_sel_mode,
                     CM_USER_NETWORK_SEL_MODE_PREF_NONE,
                     CM_USER_NETWORK_SEL_MODE_PREF_MAX));
  #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
  CM_ASSERT( INRANGE(ph_ptr->hybr_3_stack_info.pref_info.user_net_sel_mode,
                     CM_USER_NETWORK_SEL_MODE_PREF_NONE,
                     CM_USER_NETWORK_SEL_MODE_PREF_MAX));
  #endif

  #ifdef FEATURE_CM_LTE
  CM_ASSERT( INRANGE(cmph_sub_info->lte_ue_mode_pref,
                     CM_LTE_UE_MODE_PREF_NONE,
                     CM_LTE_UE_MODE_PREF_MAX));
  #endif

  SYS_ARG_NOT_USED(ss);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Copy appropriate phone parameters into target buffer.
  */
  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if(cmph_is_dsda() && ss ==  CM_SS_HYBR_2 && !cmph_is_sxlte())
  {
    ph_info_ptr->is_in_use           = ph_ptr->hybr2_is_in_use;
  }

  #if defined FEATURE_MMODE_SXLTE_G
  else if (cmph_is_dsda() && ss ==  CM_SS_HYBR_3)
  {
    ph_info_ptr->is_in_use           = ph_ptr->hybr3_is_in_use;
  }
  #endif

  else
  #endif
  ph_info_ptr->is_in_use           = ph_ptr->is_in_use;

  ph_info_ptr->is_in_thermal_emerg = cmac_is_in_thermal_emergency();

  ph_info_ptr->oprt_mode           = ph_ptr->oprt_mode;
  ph_info_ptr->test_control_type   = ph_ptr->test_control_type;
  ph_info_ptr->cdma_lock_mode      = ph_ptr->cdma_lock_mode;

  ph_info_ptr->answer_voice        = ph_ptr->answer_voice;

  ph_info_ptr->srv_domain_pref     = CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr);

  ph_info_ptr->band_pref           = CMPH_SS_BAND_PREF(asubs_id, ph_ptr);
  ph_info_ptr->roam_pref           = CMPH_SS_ROAM_PREF(asubs_id, ph_ptr);

  ph_info_ptr->nam_sel             = ph_ptr->nam_sel;
  ph_info_ptr->curr_nam            = ph_ptr->curr_nam;
  ph_info_ptr->packet_state        = ph_ptr->packet_state;

  #ifdef FEATURE_HDR_HYBRID
  ph_info_ptr->hybr_pref             = CMPH_SS_HYBR_PREF(asubs_id, ph_ptr);
  #endif /* FEATURE_HDR_HYBRID */

  ph_info_ptr->network_sel_mode_pref
                                   = CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr);
  ph_info_ptr->acq_order_pref      = CMPH_SS_ACQ_ORDER_PREF(asubs_id, ph_ptr);

  #ifdef CM_GW_SUPPORTED
  if( ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
  {
    ph_info_ptr->plmn                 = ph_ptr->hybr_2_stack_info.pref_info.plmn;
    ph_info_ptr->user_pref_networks   = ph_ptr->hybr_2_stack_info.user_pref_networks;

    ph_info_ptr->pci_plmn_list = ph_ptr->hybr_2_stack_info.plmn_list.pci_plmn_list;

    ph_info_ptr->available_networks= ph_ptr->hybr_2_stack_info.plmn_list.plmn_list;


    /* Copy Advice of charge parameters
    */
    ph_info_ptr->aoc_info.ACM        = ph_ptr->hybr_2_stack_info.phone_charge.ACM;
    ph_info_ptr->aoc_info.ACMmax     = ph_ptr->hybr_2_stack_info.phone_charge.ACMmax;
    ph_info_ptr->aoc_info.aoc_ready  = ph_ptr->hybr_2_stack_info.phone_charge.aoc_ready;
  }
  else
  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 && cmph_is_msim())
  {
    ph_info_ptr->plmn                 = ph_ptr->hybr_3_stack_info.pref_info.plmn;
    ph_info_ptr->user_pref_networks   = ph_ptr->hybr_3_stack_info.user_pref_networks;


    ph_info_ptr->pci_plmn_list = ph_ptr->hybr_3_stack_info.plmn_list.pci_plmn_list;
    
    ph_info_ptr->available_networks = ph_ptr->hybr_3_stack_info.plmn_list.plmn_list;


    /* Copy Advice of charge parameters
    */
    ph_info_ptr->aoc_info.ACM        = ph_ptr->hybr_3_stack_info.phone_charge.ACM;
    ph_info_ptr->aoc_info.ACMmax     = ph_ptr->hybr_3_stack_info.phone_charge.ACMmax;
    ph_info_ptr->aoc_info.aoc_ready  = ph_ptr->hybr_3_stack_info.phone_charge.aoc_ready;
  }
  else
  #endif /* FEATURE_MMODE_DUAL_SIM */
  {
    ph_info_ptr->plmn                 = ph_ptr->main_stack_info.pref_info.plmn;
    ph_info_ptr->user_pref_networks   = ph_ptr->main_stack_info.user_pref_networks;

    ph_info_ptr->pci_plmn_list = ph_ptr->main_stack_info.plmn_list.pci_plmn_list;
    
    ph_info_ptr->available_networks= ph_ptr->main_stack_info.plmn_list.plmn_list;

    /* Copy Advice of charge parameters
    */
    ph_info_ptr->aoc_info.ACM        = ph_ptr->main_stack_info.phone_charge.ACM;
    ph_info_ptr->aoc_info.ACMmax     = ph_ptr->main_stack_info.phone_charge.ACMmax;
    ph_info_ptr->aoc_info.aoc_ready  = ph_ptr->main_stack_info.phone_charge.aoc_ready;
  }
  cmph_copy_ccbs_indexes (ph_info_ptr);
  #endif /* FEATURE_WCDMA, FEATURE_GSM */


  ph_info_ptr->is_gw_subscription_available
                                   = ph_ptr->is_gwl_subscription_available;

  ph_info_ptr->is_hybr_gw_subscription_available
                                   = ph_ptr->is_hybr_gw_subscription_available;

  ph_info_ptr->is_hybr_gw3_subscription_available
                                   = ph_ptr->is_hybr_gw3_subscription_available;

  ph_info_ptr->is_cdma_subscription_available
                                   = ph_ptr->is_cdma_subscription_available;

  ph_info_ptr->rtre_control        = ph_ptr->rtre_control;
  ph_info_ptr->rtre_config         = ph_ptr->rtre_config;

  #ifdef FEATURE_DDTM_CNTL
  ph_info_ptr->ddtm_pref           = ph_ptr->ddtm_pref;
  ph_info_ptr->ddtm_act_mask       = ph_ptr->ddtm_act_mask;
  ph_info_ptr->orig_ddtm_act_mask  = ph_ptr->cur_ddtm_act_mask;
  ph_info_ptr->ddtm_num_srv_opt    = ph_ptr->ddtm_num_srv_opt;
  ph_info_ptr->cur_ddtm_status     = ph_ptr->cur_ddtm_status;
  ph_info_ptr->ddtm_so_list_act    = ph_ptr->ddtm_so_list_act;


  for ( i= 0;
        i < ph_ptr->ddtm_num_srv_opt && i < ARR_SIZE(ph_info_ptr->ddtm_srv_opt_list);
        i++
      )
  {
    ph_info_ptr->ddtm_srv_opt_list[i] = ph_ptr->ddtm_srv_opt_list[i];
  }
  #endif  /* FEATURE_DDTM_CNTL */

  ph_info_ptr->cphs_allowed   = ph_ptr->cphs_allowed;
  ph_info_ptr->als_allowed    = ph_ptr->als_allowed;
  ph_info_ptr->line_switching = ph_ptr->line_switching;
  ph_info_ptr->line           = ph_ptr->line;


  #if defined(FEATURE_UMTS_1X_HANDOVER_1XMSM) || \
      defined(FEATURE_UMTS_1X_HANDOVER_UMTSMSM)
  #error code not present
#endif

  ph_info_ptr->is_net_lists_present = ph_ptr->is_net_lists_present;


  ph_info_ptr->ph_state         = ph_ptr->ph_state;
  ph_info_ptr->ecbm_exit_reason = ph_ptr->ecbm_exit_reason;
  if( ph_info_ptr->ph_state != CM_PH_STATE_EMERG_CB )
  {
    ph_info_ptr->mode_pref          = CMPH_SS_USER_MODE_PREF(asubs_id, ph_ptr);
    ph_info_ptr->pref_term          = CMPH_SS_PREF_TERM(asubs_id, ph_ptr);
  }
  else
  {
    ph_info_ptr->mode_pref          = CM_MODE_PREF_EMERGENCY;
    ph_info_ptr->pref_term          = CM_PREF_TERM_PWR_CYCLE;
  }

  CM_MSG_HIGH_2("mode_pref %d, pref_term %d",\
   ph_info_ptr->mode_pref,
   ph_info_ptr->pref_term);

   /* If LTE was marked as disabled add LTE mode*/
   if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, asubs_id))
   {

     if (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_info_ptr->mode_pref),
                              SD_SS_MODE_PREF_GSM )  &&
         sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_info_ptr->mode_pref),
                              SD_SS_MODE_PREF_WCDMA ))
     {
       mapped_mode_pref = cm_add_mode_pref_components(ph_info_ptr->mode_pref,
                                             1,SD_SS_MODE_PREF_GWL_LTE);
     }
     else
     {
       mapped_mode_pref = cm_add_mode_pref_components(ph_info_ptr->mode_pref,
                                             1,SD_SS_MODE_PREF_LTE);
     }

     if (mapped_mode_pref != CM_MODE_PREF_MAX)
     {
       ph_info_ptr->mode_pref = mapped_mode_pref;
       mapped_mode_pref       = CM_MODE_PREF_NONE;
     }
   }
    /* If HDR was marked as disabled add HDR mode*/
   if(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, asubs_id) &&
     asubs_id == SYS_MODEM_AS_ID_1)
   {
     mapped_mode_pref = cm_add_mode_pref_components(ph_info_ptr->mode_pref,
                                             1,SD_SS_MODE_PREF_HDR);
     if (mapped_mode_pref != CM_MODE_PREF_MAX)
     {
       ph_info_ptr->mode_pref = mapped_mode_pref;
     }
   }

   CM_MSG_HIGH_1("After updating from rat_disabled_mask mode_pref %d",
   ph_info_ptr->mode_pref);

  /* set mode_pref to CM_MODE_PREF_EMERGENCY if in emergency callback mode */
  if( ph_info_ptr->ph_state == CM_PH_STATE_EMERG_CB )
  {
    ph_info_ptr->mode_pref = CM_MODE_PREF_EMERGENCY;
    CM_MSG_HIGH_1("update mode_pref %d", ph_info_ptr->mode_pref);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Gives the status of plmn list request (success/abort).
  */
  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if(cmph_is_dsda() && asubs_id == SYS_MODEM_AS_ID_2)
  {
    #if defined(FEATURE_MMODE_SXLTE_G)
    if (cmph_is_sxlte())
    {
      ph_info_ptr->available_networks_list_cnf =
                                        ph_ptr->hybr3_available_networks_list_cnf;
    }
    else
    #endif
    {
      ph_info_ptr->available_networks_list_cnf =
                                        ph_ptr->hybr2_available_networks_list_cnf;
    }
  }
  else
  #endif
  {
    ph_info_ptr->available_networks_list_cnf =
                                       ph_ptr->available_networks_list_cnf;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Gives the mode capability and band capability.
  */
  ph_info_ptr->mode_capability = ph_ptr->mode_capability;
  ph_info_ptr->band_capability = ph_ptr->band_capability;

  #ifdef FEATURE_CM_LTE
  ph_info_ptr->lte_band_capability = ph_ptr->lte_band_capability;
  ph_info_ptr->lte_band_pref = CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr);
  ph_info_ptr->lte_ue_mode_pref = cmph_sub_info->lte_ue_mode_pref;

  #endif

  ph_info_ptr->tds_band_capability = ph_ptr->tds_band_capability;
  ph_info_ptr->tds_band_pref = CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr);

  /* Copy the current prl prefferred setting.
  */
  ph_info_ptr->prl_pref        = CMPH_SS_PRL_PREF(asubs_id, ph_ptr);

  /* Copy the PRL's pref_only setting, which is extracted from PRL's header
  */
  /*lint -save -e746 */
  ph_info_ptr->prl_pref_only   = prl_hdr_get_ptr()->pref_only;

  /* Copy the PRL's id, which is extracted from PRL's header
  */
  ph_info_ptr->prl_id  = prl_hdr_get_ptr()->pr_list_id;
  /*lint -restore */

  ph_info_ptr->is_prl_load_complete  = ph_ptr->is_prl_load_complete;
  /* Copy user selected network selection mode pref
  */
  ph_info_ptr->user_net_sel_mode = ph_ptr->main_stack_info.pref_info.user_net_sel_mode;
  {
    cm_ss_e_type cmd_ss = cmph_map_subs_to_ss(asubs_id);

    if(cmd_ss == CM_SS_MAIN)
    {
      ph_info_ptr->user_net_sel_mode = ph_ptr->main_stack_info.pref_info.user_net_sel_mode;
    }
    else if(cmd_ss == CM_SS_HYBR_2)
    {
      ph_info_ptr->user_net_sel_mode = ph_ptr->hybr_2_stack_info.pref_info.user_net_sel_mode;
    }
    #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    else if(cmd_ss == CM_SS_HYBR_3)
    {
      ph_info_ptr->user_net_sel_mode = ph_ptr->hybr_3_stack_info.pref_info.user_net_sel_mode;
    }
    #endif
  }

  /*---------------------- Copy Dual Standby Info -----------------------*/

  ph_info_ptr->asubs_id       = asubs_id;

  /* Standby preference of the Phone */
  ph_info_ptr->standby_pref       = ph_ptr->standby_pref;

  /* The active subscription in Single Standby mode
  ** only valid when standby_pref is SYS_MODEM_DS_PREF_SINGLE_STANDBY
  */

  ph_info_ptr->active_subs = ACTIVE_MASK_TO_AS_ID(ph_ptr->active_subs);

  /* type of the system to avoid */
  ph_info_ptr->default_voice_subs = ph_ptr->default_voice_subs;

  /* type of the system to avoid */
  ph_info_ptr->default_data_subs  = ph_ptr->default_data_subs;

  /* type of the system to avoid */
  ph_info_ptr->priority_subs      = ph_ptr->priority_subs;

  ph_info_ptr->device_mode        = cmpmprx_get_device_mode();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Gives the phone's measurement mode - HDR access enabled /disabled
  */
  #ifdef FEATURE_CM_SS_MEAS
  #error code not present
#endif

  /* Copy rat acquisition priority order preference
  */
  ph_info_ptr->acq_pri_order_pref
    = *cmph_get_acq_pri_order_per_sub(cmph_map_subs_to_ss(asubs_id));
  ph_info_ptr->ue_usage_setting   = CMPH_SS_UE_USAGE_SETTING(asubs_id, ph_ptr);
  ph_info_ptr->voice_domain_pref  = CMPH_SS_VOICE_DOMAIN_PREF(asubs_id, ph_ptr);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)
  /* DRX */
  ph_info_ptr->drx_coefficient = ph_ptr->drx_coefficient;

  /* Result for set DRX request */
  ph_info_ptr->set_drx_result  = ph_ptr->set_drx_result;
  #endif

  /* Copy the CSG related data */
  ph_info_ptr->csg_id  = ph_ptr->main_stack_info.pref_info.csg_id;
  ph_info_ptr->csg_rat = ph_ptr->main_stack_info.pref_info.csg_rat;

  ph_info_ptr->hplmn_timer = ph_ptr->hplmn_timer;
  ph_info_ptr->lte_disable_cause = ph_ptr->lte_disable_cause;
  ph_info_ptr->wd_switch_on = ph_ptr->wd_switch_on;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(ss == CM_SS_HYBR_2)
  {
    ph_info_ptr->network_list_type = ph_ptr->hybrid2_network_list_type;
  }
  else
  {
    ph_info_ptr->network_list_type = ph_ptr->network_list_type;
  }
  /* Return boolean indicating whether phone information is valid.
  */

  ph_info_ptr->priority_type = ph_ptr->data_priority_per_sub[asubs_id].priority_type;

  ph_info_ptr->dds_switch_type = ph_ptr->dds_switch_type;

  return CM_BOOLEAN( CM_INIT_CHECK(ph_ptr->init_mask) );

} /* cmph_info_get() */



/*===========================================================================

FUNCTION cmph_client_cmd_proc

DESCRIPTION
  Process clients' phone commands.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_client_cmd_proc(

    cm_ph_cmd_s_type  *ph_cmd_ptr
        /* pointer to a CM command */
)
{

  cmph_s_type             *ph_ptr       = cmph_ptr();
      /* Point at phone object */

  cm_ph_cmd_err_e_type     ph_cmd_err;
  boolean                  wait_for_reply = FALSE;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  CM_ASSERT( ph_cmd_ptr != NULL );
  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( ph_cmd_ptr->cmd_type == CM_CMD_TYPE_PH );

  /* We are NOT supposed to process commands while
  ** waiting for MC reply.
  */
  if(cm_reply_is_waiting(&ph_ptr->reply))
  {
    if (!(cm_reply_check(&ph_ptr->reply, CM_DATA_PACKET_STATE_RPT) &&
               ph_cmd_ptr->cmd == CM_PH_CMD_PACKET_STATE))
    {

      CM_ERR_2( "Received wrong phcmd: %d, when waiting for RPT: %d",
                              ph_cmd_ptr->cmd,ph_ptr->reply.cm_mc_rpt);
      CM_ASSERT(0);
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( cmclnup_is_cmd_tobe_buff(ph_cmd_ptr) )
  {
    return;
  }

  /* Start by checking whether this is a valid command
  ** relative to the current state of the phone.
  */
  ph_cmd_err = cmph_client_cmd_check( ph_ptr,ph_cmd_ptr );

  // If Internal Standby Pref cmd resulted in some error, make sure to set buffered flag.
  if((ph_cmd_err != CM_PH_CMD_ERR_NOERR) && (ph_cmd_ptr->cmd == CM_PH_CMD_DUAL_STANDBY_PREF) && 
    (ph_cmd_ptr->client_id == CM_CLIENT_ID_ANONYMOUS))
  {
    cmph_ptr()->is_standby_pref_buffered = TRUE;
    CM_MSG_HIGH_0("Set is_standby_pref_buffered to TRUE");
  }
  /*
  ** Notify clients of command processing status.
  ** If error found, return.
  */
  cmph_client_cmd_err( ph_cmd_ptr, ph_cmd_err );
  if( ph_cmd_err != CM_PH_CMD_ERR_NOERR )
  {
    return;
  }

      if(((cmpm_ptr()->ims_for_nondds) && (ph_cmd_ptr->cmd == CM_PH_CMD_SYS_SEL_PREF) &&
        ((ph_cmd_ptr->info.srv_domain_pref == CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH)) &&
        (ph_ptr->default_data_subs != ph_cmd_ptr->info.cmd_subs) &&
        (CMPH_SS_SRV_DOMAIN_PREF(ph_cmd_ptr->info.cmd_subs,ph_ptr) == 
  CM_SRV_DOMAIN_PREF_PS_ONLY ||
          CMPH_SS_SRV_DOMAIN_PREF(ph_cmd_ptr->info.cmd_subs,ph_ptr) == 
  CM_SRV_DOMAIN_PREF_CS_PS )))
      {
        CM_MSG_HIGH_1("Due to ims_for_nondds, change srv_domain %d -> NO_CHANGE",ph_cmd_ptr->info.srv_domain_pref);
  
        ph_cmd_ptr->info.srv_domain_pref = CM_SRV_DOMAIN_PREF_NO_CHANGE;
      }


  /* Check if CM needs to wait till IP apps deregister
  */
  if (cmph_is_wait_on_ims_deregister (ph_cmd_ptr))
  {
    wait_for_reply = TRUE;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, no errors were found,
  ** so forward the client command to MC.
  */
  if( ! wait_for_reply )
  {
    wait_for_reply = cmph_client_cmd_forward_mmll( ph_ptr,ph_cmd_ptr );
  }



  /* If NO need to wait for replay from Lower Layer,
  ** call the reply function right a way.
  */
  if( ! wait_for_reply )
  {
    cmph_client_cmd_mmll_reply( ph_ptr,
                              ph_cmd_ptr,
                              CM_PH_CMD_ERR_NOERR );
  }

} /* cmph_client_cmd_proc() */

/*===========================================================================

FUNCTION  cmph_set_lte_do_redir

DESCRIPTION
 Set the flag cmph_set_lte_do_redir to true.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_set_lte_do_redir (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  CM_MSG_HIGH_1("SET lte_do_redir to TRUE %d", ph_ptr->lte_do_redir);
  if (!ph_ptr->lte_do_redir)
  {
    ph_ptr->lte_do_redir = TRUE;

  }
}

/*===========================================================================

FUNCTION  cmph_reset_lte_do_redir

DESCRIPTION
 Reset the flag cmph_reset_lte_do_redir to false.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_reset_lte_do_redir (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Reset the flag */
  if (ph_ptr->lte_do_redir)
  {
    ph_ptr->lte_do_redir = FALSE;

    CM_MSG_HIGH_0("RESET lte_do_redir flag");
  }
}

/*===========================================================================

FUNCTION cmph_recover_mmoc_subsc_fail

DESCRIPTION
  Recovers from MMOC subsc change fail due to sim busy
  If 1X failed mmoc-subsc-change , CM will store it in subsc_failed_dueTo_simBusy
  and CM is resposible for recovering once SIM have become ready .

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_recover_mmoc_subsc_fail(void)
{
  cmmmgsdi_s_type  *mmgsdi_ptr = cmmmgsdi_ptr();
  cmph_s_type      *ph_ptr = cmph_ptr();

  CM_MSG_HIGH_2( "SIMBUSY: sim Busy %d recovery needed %d",
               mmgsdi_ptr->sim_busy_status.is_sim_busy, mmgsdi_ptr->subsc_failed_dueTo_simBusy);

  if(mmgsdi_ptr->subsc_failed_dueTo_simBusy
    && mmgsdi_ptr->sim_busy_status.is_sim_busy == FALSE)
  {
    cm_pref_s_type  *hybr_2_pref_ptr = NULL;
    #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    cm_pref_s_type  *hybr_3_pref_ptr = NULL;
    #endif

    /* Allocate buffer only if multi-sim */
    if (cmph_is_msim())
    {
      hybr_2_pref_ptr = cm_pref_ptr();
      memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
             &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));

      #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
      hybr_3_pref_ptr = cm_pref_ptr();
            memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                   &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
      #endif
    }
    
    cmmsimc_proc_cmd_subsc_chgd(
            MMOC_SUBSC_CHG_SUBSC_AVAIL,
          (byte)ph_ptr->curr_nam,
            ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
            CMPH_PRST_MODE_PREF( ph_ptr ),
            CMPH_PRST_BAND_PREF( ph_ptr ),
            CMPH_PRST_LTE_BAND_PREF( ph_ptr ),
            CMPH_PRST_TDS_BAND_PREF( ph_ptr ),
            CMPH_PRST_PRL_PREF( ph_ptr ),
            CMPH_PRST_ROAM_PREF( ph_ptr ),
            CMPH_PRST_HYBR_PREF(ph_ptr),
            ph_ptr->main_stack_info.pref_info.plmn,
            CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr),
            CMPH_PRST_ACQ_ORDER_PREF( ph_ptr ),
            hybr_2_pref_ptr,
            #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
            hybr_3_pref_ptr,
            #endif
            ph_ptr->is_gwl_subscription_available,
            ph_ptr->is_hybr_gw_subscription_available,
            ph_ptr->is_hybr_gw3_subscription_available,
            ph_ptr->is_cdma_subscription_available,
            PROT_SUBSC_CHG_ALL,
            PROT_SUBSC_CHG_NONE,
            PROT_SUBSC_CHG_NONE
          );
            
    if (hybr_2_pref_ptr != NULL)
    {
      cm_mem_free (hybr_2_pref_ptr);
    }
    #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    if (hybr_3_pref_ptr != NULL)
    {
      cm_mem_free (hybr_3_pref_ptr);
    }
    #endif
    mmgsdi_ptr->subsc_failed_dueTo_simBusy = FALSE;

  }
}

/*===========================================================================

FUNCTION cmph_volte_proc_irat

DESCRIPTION
  Handling SVLTE VOLTE call upon LTE->DO redirection succeed
  - bump down connected VOLTE call to below PH so no LTE scan will interrupt IRAT. VOLTE call will be
    dropped later by IMS
  - insert voice call obj from Hybrid-2 stack to Main stack. bump down VOLTE call on hybr2 stack.
    and redial over 1x when VOLTE orig is not sent to IMS
  - wait for IMS fal_back_to_cs when VOLTE orig is sent to IMS

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_volte_proc_irat(void)
{
  cm_iterator_type        call_itr;
  cmcall_s_type           *call_ptr;
  cm_orig_q_s_type        *p_orig_ptr = NULL;
  cm_orig_q_s_type        *ph_orig_insert_ptr = NULL;

  if(cmph_is_subs_feature_mode_1x_sxlte(cmph_ptr()->main_stack_info.asubs_id) &&
    cmss_ptr()->info.is_hybr_gw_operational)
  {
    cmcall_obj_iterator_init(&call_itr);
    call_ptr = cmcall_obj_get_next(&call_itr);
    while(call_ptr != NULL)
    {
      if(call_ptr->is_volte && call_ptr->ss == CM_SS_HYBR_2)
      {
        switch(call_ptr->call_state)
        {
        case CM_CALL_STATE_CONV:
          (void)cmtask_orig_para_change_act_priority_3( CM_SS_HYBR_2,
                                      (cm_act_id_type)call_ptr->call_id,
                                      CM_ACT_PRIORITY_NONE,
                                      CM_ACT_PRIORITY_BELOW_PH
                                      );
          break;
        case CM_CALL_STATE_ORIG:
          p_orig_ptr = cmtask_orig_para_search_act_id(CM_SS_HYBR_2,(cm_act_id_type)call_ptr->call_id);
          if(p_orig_ptr == NULL)
          {
            break;
          }
          if ((ph_orig_insert_ptr = cmtask_orig_para_alloc(CM_SS_MAIN)) ==
                                              (cm_orig_q_s_type *)NULL)
          {
            sys_err_fatal_null_ptr_exception();
          }

          if(call_ptr->sr.orig_sent_on_mode == SYS_SYS_MODE_NONE)
          {
            /* Insert into the main priority Queue
            */
            ph_orig_insert_ptr->act_type = p_orig_ptr->act_type;
            memscpy(ph_orig_insert_ptr->orig ,sizeof(cm_act_orig_s_type),p_orig_ptr->orig, sizeof(cm_act_orig_s_type));

            (void)cmtask_orig_para_insert(CM_SS_MAIN, ph_orig_insert_ptr);
            (void)cmtask_orig_para_change_act_priority_3( CM_SS_HYBR_2,
                                      (cm_act_id_type)call_ptr->call_id,
                                      CM_ACT_PRIORITY_NONE,
                                      CM_ACT_PRIORITY_BELOW_PH);
            /*redial over CS*/
            call_ptr->end_status = CM_CALL_END_IP_FAIL;
            call_ptr->ss = CM_SS_MAIN;
            cmcall_orig_proc(call_ptr);
          }
          else
          {
            (void)cmtask_orig_para_change_act_priority_3( CM_SS_HYBR_2,
                                      (cm_act_id_type)call_ptr->call_id,
                                      CM_ACT_PRIORITY_NONE,
                                      CM_ACT_PRIORITY_BELOW_PH
                                      );
          }


          break;

        default:
          break;
        }
      }
      call_ptr = cmcall_obj_get_next(&call_itr);
    }
  }
  else
  {
    // For NON SV cases
    CM_MSG_HIGH_0("NON-SV case, LTE_TO_DO_REDIR");
    cmcall_obj_iterator_init(&call_itr);
    call_ptr = cmcall_obj_get_next(&call_itr);
    while(call_ptr != NULL)
    {
      if(call_ptr->is_volte && call_ptr->ss == CM_SS_MAIN)
      {
        switch(call_ptr->call_state)
        {
          case CM_CALL_STATE_CONV:
          case CM_CALL_STATE_ORIG:

            (void)cmtask_orig_para_change_act_priority_3( CM_SS_MAIN,
                                        (cm_act_id_type)call_ptr->call_id,
                                        CM_ACT_PRIORITY_NONE,
                                        CM_ACT_PRIORITY_BELOW_PH
                                        );

            break;
  
          default:
            break;
        }
      }
      call_ptr = cmcall_obj_get_next(&call_itr);
    }
  }
}

/*===========================================================================

FUNCTION cmph_sd_rpt_proc

DESCRIPTION
  Process System Determination reports


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_sd_rpt_proc(

  const cm_hdr_type   *rpt_ptr
    /* Pointer to SD reports */
)
{

  /*lint -e{826} */
  const cm_sd_rpt_u_type         *sd_rpt_ptr = (cm_sd_rpt_u_type *) rpt_ptr;
    /* Pointer to SD reports */

  cmph_s_type              *ph_ptr     = cmph_ptr();
      /* Point at phone object */

#if (defined FEATURE_CM_LTE) && (defined FEATURE_HDR_HANDOFF)
  cmss_s_type         *ss_ptr = cmss_ptr();
 #endif

 #ifdef FEATURE_LTE_TO_1X
  cmcall_s_type             *call_ptr = NULL;
  cm_call_id_type           csfb_call_id = CM_CALL_ID_INVALID;
#endif
  boolean                   irat_ret_status = TRUE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( sd_rpt_ptr != NULL );
  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Do command specific processing as follows:
  ** 1. Updating appropriate phone object fields.
  ** 2. Notifying clients of event if necessary.
  */

  switch( sd_rpt_ptr->hdr.cmd )
  {
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
    /* Auto-NAM change is appropriate.
    */
    case CM_NAM_CHANGED_F:

      /* If NAM selection is set to auto-NAM and current origination mode is
      ** none or normal, change the current NAM to the proposed NAM selection
      ** and command MC to switch to the new NAM selection.
      */
      {

        cm_orig_q_s_type  *ph_orig_ptr;
        ph_orig_ptr = cmtask_orig_para_get_top( CM_SS_MAIN );

        if( ph_ptr->nam_sel == CM_NAM_AUTO
                            &&

            ( ph_orig_ptr == NULL                                   ||
            /* No need to check for ph_orig_ptr for not NULL
            ** as due to short circuit evaluation, we will dereference if
            ** only if the first condition is false
            */
            ph_orig_ptr->orig->orig_mode  == SD_SS_ORIG_MODE_NONE  ||
              ph_orig_ptr->orig->orig_mode  == SD_SS_ORIG_MODE_NORMAL
          )
          )
        {
          /* Change the current NAM to the proposed NAM selection.
          */
          ph_ptr->curr_nam = (cm_nam_e_type )sd_rpt_ptr->nam_changed.nam;
          cmph_event( ph_ptr, CM_PH_EVENT_CURR_NAM );

          /* Write to MV the new NAM selection.
          */
          cmnv_item_ptr->curr_nam = (byte) sd_rpt_ptr->nam_changed.nam;
          cmnv_write( NV_CURR_NAM_I, cmnv_item_ptr );

          /* Command MC to switch to the new NAM selection.
          */
          cmph_send_nam_change_to_mc( ph_ptr, ph_ptr->curr_nam );

          /* Read NV items for the new NAM
          */
          cmph_read_nv_items(ph_ptr);
        }
        break;
      }
    #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Enter E911 callback mode.
    */
    case CM_E911_CALLBACK_F:
    {

      cm_orig_q_s_type *ph_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_MAIN );
      cm_orig_q_s_type *ph_hybr_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_1 );
      cm_orig_q_s_type *ph_hybr_2_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_2 );
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      cm_orig_q_s_type *ph_hybr_3_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_3 );
      #endif


      /* Update the ECBM RAT to CDMA. This report is queued by SD only for 1x calls.
      */
      ph_ptr->ecbm_rat = SYS_SYS_MODE_CDMA;
      CM_MSG_HIGH_0("1x ECBM");

      if( ph_orig_top_ptr != NULL &&
          sd_rpt_ptr->e911_callback.emerg_cb_mode == SD_EMERG_CB_MODE_MAIN_ENTER )
      {
        cmph_enter_emergency_cb( ph_ptr, CM_SS_MAIN, TRUE );
      }
      else if (ph_hybr_top_ptr !=  NULL &&
               sd_rpt_ptr->e911_callback.emerg_cb_mode == SD_EMERG_CB_MODE_HYBR_ENTER )
      {
        cmph_enter_emergency_cb( ph_ptr, CM_SS_HYBR_1, TRUE );
      }
      else if (ph_hybr_2_top_ptr != NULL &&
               sd_rpt_ptr->e911_callback.emerg_cb_mode == SD_EMERG_CB_MODE_HYBR2_ENTER &&
               cmph_is_msim() && !cmph_is_sxlte())
      {
        cmph_enter_emergency_cb( ph_ptr, CM_SS_HYBR_2, TRUE );
      }
      #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
      else if (ph_hybr_3_top_ptr != NULL &&
               sd_rpt_ptr->e911_callback.emerg_cb_mode == SD_EMERG_CB_MODE_HYBR3_ENTER )
      {
        cmph_enter_emergency_cb( ph_ptr, CM_SS_HYBR_3, TRUE );
      }      
      else if (ph_hybr_3_top_ptr != NULL &&
               ph_hybr_3_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_CB &&
               sd_rpt_ptr->e911_callback.emerg_cb_mode == SD_EMERG_CB_MODE_EXIT)
      {
        cmph_exit_emergency_cb(ph_ptr, FALSE, CM_SS_HYBR_3, FALSE);
        cmph_force_orig_mode_on_the_fly(CM_SS_HYBR_3);
      }
      #endif
      else if (ph_orig_top_ptr != NULL &&
               ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_CB &&
               sd_rpt_ptr->e911_callback.emerg_cb_mode == SD_EMERG_CB_MODE_EXIT)
      {
        /* Exit emergency callback mode if SD sends SD_EMERG_CB_MODE_EXIT
        ** and force SD with the phone object preferences
        */
        cmph_exit_emergency_cb(ph_ptr, FALSE,CM_SS_MAIN,FALSE);
        cmph_force_orig_mode_on_the_fly(CM_SS_MAX);
      }      
      else if (ph_hybr_2_top_ptr != NULL &&
               ph_hybr_2_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_CB &&
               sd_rpt_ptr->e911_callback.emerg_cb_mode == SD_EMERG_CB_MODE_EXIT &&
               !cmph_is_sxlte())
      {
        /* Exit emergency callback mode if SD sends SD_EMERG_CB_MODE_EXIT
        ** and force SD with the phone object preferences
        */
        cmph_exit_emergency_cb(ph_ptr, FALSE, CM_SS_HYBR_2, FALSE);
        cmph_force_orig_mode_on_the_fly(CM_SS_HYBR_2);
      }
      else
      {
        CM_MSG_HIGH_1("e911 callback rpt %d rxd incorrectly",
                    sd_rpt_ptr->e911_callback.emerg_cb_mode);
      }
    }
    break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_ACQ_FAIL_F:
      /* handle the ACQ_FAIL rpt based on CMPREF states
      */
      
      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_ACQ_FAIL_F, ((void*)&(sd_rpt_ptr->acq_fail)));
      #endif

      cmmsimmsc_proc_rpt_acq_fail(cmph_map_sd_ss_type_to_cm_ss_type(sd_rpt_ptr->acq_fail.ss), 
                               sd_rpt_ptr->acq_fail.mode_pref);

      #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
      cmsoa_proc_acq_fail(sd_rpt_ptr->acq_fail.ss);
      #endif

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case CM_OPT_SR_HDR_ACQ_FAIL_F:
    {
      cmmsimc_proc_rpt_redial_hdr_fail();
      break;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_HDR_HYBRID

    /* LTE->DO Redirection complete
    */
    case CM_LTE_DO_IRAT_F:
      {
        #ifdef FEATURE_CM_DEBUG_BUFFER
        cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_LTE_DO_IRAT_F, NULL);
        #endif
        cmph_volte_proc_irat();
        /* Set the flag to hold CDMA service for a duration during LTE to
        ** DO redirection */
        cmph_set_lte_do_redir();

        /* Process the rpt */
        cmmsimc_proc_rpt_lte_do_irat();
      }
      break;

      #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_HYBR_BSR_TO_HDR_F:
      CM_MSG_HIGH_1("LTE_TO_HDR: sd rpt hybr_bsr_to_hdr_status %d",
                   sd_rpt_ptr->hybr_bsr_to_hdr.hybr_bsr_to_hdr_status);

      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_HYBR_BSR_TO_HDR_F, ((void*)&(sd_rpt_ptr->hybr_bsr_to_hdr)));
      #endif
      if (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1))
      {
        cmmsimc_proc_rpt_hybr_bsr_to_hdr(sd_rpt_ptr->hybr_bsr_to_hdr.hybr_bsr_to_hdr_status);
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case CM_KICK_HYBR2_F:

      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_KICK_HYBR2_F, NULL);
      #endif
      if (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1))
        {

          cmmsimc_proc_rpt_kick_hybr2();
        }
      break;

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Entering power-down sleep mode
    */
    case CM_STANDBY_SLEEP_F:
      cmph_event( ph_ptr, CM_PH_EVENT_STANDBY_SLEEP );
      break;


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Exiting power-down sleep mode
    */
    case CM_STANDBY_WAKE_F:
      cmph_event( ph_ptr, CM_PH_EVENT_STANDBY_WAKE );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Enter Low Power Mode (LPM)
    */
    case CM_LPM_OK_F:

      /* NOTE! CM_LPM_OK_F is a reply command to an earlier MC_LPM_F
      ** command sent by CM to MC and should be processed by
      ** cmph_client_cmd_mc_reply(), being called at the end of this
      ** function.
      **
      ** If, however, we are currently NOT waiting for such a reply from MC
      ** (i.e. CM never sent the MC_LPM_F to MC in the first place or MC
      ** responded after the max reply time is expired ), do not respond
      ** with a new event at this point. Once CM has issued LPM event due
      **
      ** Removed setting oprt_mode when unexpected LPM_OK arrives.
      **
      ** - Client sends oprt_mode change to LPM
      ** - CM times out on CMPH_MAX_MC_REPLY_TIME and sends LPM in
      **   CM_PH_EVENT_OPRT_MODE
      ** - CM gets oprt_mode change to ONLINE.
      ** - MMOC sends LPM_OK for the initial LPM request.
      ** - CM changes oprt_mode to LPM, which is incorrect (CR 90176)
      **
      */
      if(! cm_reply_check(&ph_ptr->reply, sd_rpt_ptr->hdr.cmd) )
      {
        CM_MSG_HIGH_0( "Received CM_LPM_OK_F when not expecting, Ignore");
      }
      else
      {
        /* LPM Ok was expected. Reset the CSG data, irrespective of net sel mode pref */
        ph_ptr->main_stack_info.pref_info.csg_id  = SYS_CSG_ID_INVALID;
        ph_ptr->main_stack_info.pref_info.csg_rat = SYS_RAT_NONE;
        sys_plmn_undefine_plmn_id(&ph_ptr->main_stack_info.pref_info.plmn);
        sys_plmn_undefine_plmn_id(&ph_ptr->hybr_2_stack_info.pref_info.plmn);
        #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
        sys_plmn_undefine_plmn_id(&ph_ptr->hybr_3_stack_info.pref_info.plmn);
        #endif
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_RESET_OK_F:

      if(! cm_reply_check(&ph_ptr->reply, sd_rpt_ptr->hdr.cmd) )
      {
        CM_ERR_0( "Received CM_RESET_OK_F when not expecting, Ignore");
      }
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_STANDBY_PREF_CHG_OK_F:

      CM_MSG_HIGH_1("Received num_standby_requests_processing %d",ph_ptr->num_standby_requests_processing);

      if(ph_ptr->num_standby_requests_processing > 0)
      {
         ph_ptr->num_standby_requests_processing--;
      }
      if(ph_ptr->num_standby_requests_processing != 0)
      {
         return;
      }
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     case CM_PWROFF_OK_F:
      if(! cm_reply_check(&ph_ptr->reply, sd_rpt_ptr->hdr.cmd) )
      {
        CM_ERR_0( "Received CM_PWROFF_OK_F when not expecting, Ignore");
      }
      break;

     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     case CM_MMOC_SUBSCRIPTION_FAILURE:
      cmmmgsdi_ptr()->subsc_failed_dueTo_simBusy = TRUE;
      cmph_recover_mmoc_subsc_fail();
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

     case CM_OFFLINE_OK_F:
      if(! cm_reply_check( &ph_ptr->reply, sd_rpt_ptr->hdr.cmd ) )
      {
        CM_ERR_0( "Received CM_OFFLINE_OK_F when not expecting, Ignore");
      }
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_SRV_IND_INFO_F:

      if( cm_reply_check(&ph_ptr->reply, CM_SRV_IND_INFO_F)
        && sd_rpt_ptr->srv_ind_info.ss == SD_SS_MAIN)
      {
        cm_ph_cmd_s_type  *reply_cmd_ptr = (cm_ph_cmd_s_type*)cm_reply_get(&ph_ptr->reply);
        boolean wait_for_reply = FALSE;
        CM_ASSERT(reply_cmd_ptr != NULL);
        CM_ASSERT(CMD_TYPE(reply_cmd_ptr) == CM_CMD_TYPE_PH );

        wait_for_reply = cmph_client_cmd_forward_mmll(ph_ptr, reply_cmd_ptr);

        if(!wait_for_reply)
        {
          cmph_client_cmd_mmll_reply( ph_ptr,
                                    reply_cmd_ptr,
                                    CM_PH_CMD_ERR_NOERR );

          cm_cmd_dealloc( reply_cmd_ptr );

          cm_reply_init( &ph_ptr->reply);

          (void) rex_set_sigs( rex_self(), CM_CLIENT_CMD_Q_SIG );

        }
      }

      if ( sd_rpt_ptr->srv_ind_info.si_info.srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
           sd_rpt_ptr->srv_ind_info.si_info.srv_domain == SYS_SRV_DOMAIN_CS_PS)
      {
        /* Cancel the PS service request timer if the phone was able to acquire
        ** PS service.
        */
        if( sys_srv_status_is_srv(sd_rpt_ptr->srv_ind_info.si_info.srv_status))
        {
          if( cmph_is_msim() && !cmph_is_sxlte() &&
              sd_rpt_ptr->srv_ind_info.ss == SD_SS_HYBR_2 &&
            ph_ptr->hybr_2_stack_info.ps_service_req_timer_active)
        {
          cmph_deactivate_ps_service_req_timer(CM_SS_HYBR_2);
        }
           else
           #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
           if( cmph_is_msim() && sd_rpt_ptr->srv_ind_info.ss == SD_SS_HYBR_3 &&
             ph_ptr->hybr_3_stack_info.ps_service_req_timer_active)
          {
            cmph_deactivate_ps_service_req_timer(CM_SS_HYBR_3);
          }
          else
          #endif

          if( (sd_rpt_ptr->srv_ind_info.ss == SD_SS_MAIN ||
                  (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
                  sd_rpt_ptr->srv_ind_info.ss == SD_SS_HYBR_2)) &&
            ph_ptr->ps_service_req_timer_active
          )
          {
            cmph_deactivate_ps_service_req_timer(CM_SS_MAIN);
          }
        }
        /* Do not start PS signalling timer for GSM */
        if(sd_rpt_ptr->srv_ind_info.si_info.mode != SD_MODE_GSM )
        {
          /*
                 ** We need to hold the PS call origination after PS service is acquired to avoid
                 ** the race condition that Network is releasing the PS Signaling connection for
                 ** PS_ATTACH while mobile is sending PDP_CONTEXT ACTIVATE request. PS_ATTCH
                 ** happens whenever PS service is required.
                 **
                 ** CM needs to wait to receive the PS_SIG_DOWN event after PS Service is acquired.
                 ** When we change the system selection prefernece to acquire a PS service, we need
                 ** to start the PS_SIG_DOWN timer.
                 **
                 ** ps_service_req_sent flag is used to decide if we need to start the PS_SIG_DOWN
                 ** timer after PS service is acquired.
                 */
          if(  cmph_is_msim() && !cmph_is_sxlte() &&
              sd_rpt_ptr->srv_ind_info.ss == SD_SS_HYBR_2 &&
              ph_ptr->hybr_2_stack_info.is_ps_srv_req_sent)
          {
            ph_ptr->hybr_2_stack_info.is_ps_srv_req_sent = FALSE;
            cmph_set_ps_sig_down_wait_time(cmph_ptr()->ps_signaling_max_wait_timer,
                                           CM_SS_HYBR_2);
          }
          else
            #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
          if( cmph_is_msim() && sd_rpt_ptr->srv_ind_info.ss == SD_SS_HYBR_3 &&
              ph_ptr->hybr_3_stack_info.is_ps_srv_req_sent)
          {
            ph_ptr->hybr_3_stack_info.is_ps_srv_req_sent = FALSE;
            cmph_set_ps_sig_down_wait_time(cmph_ptr()->ps_signaling_max_wait_timer,
                                           CM_SS_HYBR_3);
          }
          else
          #endif
          if(ph_ptr->is_ps_srv_req_sent)
          {
            ph_ptr->is_ps_srv_req_sent = FALSE;
            cmph_set_ps_sig_down_wait_time(cmph_ptr()->ps_signaling_max_wait_timer,
                                           CM_SS_MAIN);
          }
        }
        else if(sd_rpt_ptr->srv_ind_info.si_info.mode == SD_MODE_GSM )
        {
          switch(sd_rpt_ptr->srv_ind_info.ss)
          {
            #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
            case SD_SS_HYBR_3:
              ph_ptr->hybr_3_stack_info.is_ps_srv_req_sent = FALSE;
              break;
            #endif
            
            case SD_SS_HYBR_2:
              ph_ptr->hybr_2_stack_info.is_ps_srv_req_sent = FALSE;
              break;

            default:
              ph_ptr->is_ps_srv_req_sent = FALSE;
          }
        }
      }

      /* Do not kick SD HDR instance if we got service on SD main instance
      ** and we are no longer looking for preferred service.
      */
      if( sd_rpt_ptr->srv_ind_info.ss == SD_SS_MAIN &&
          sys_srv_status_is_srv(sd_rpt_ptr->srv_ind_info.si_info.srv_status) &&
          !sd_rpt_ptr->srv_ind_info.si_info.is_pref_srv_acq
        )
      {
        *cmph_get_is_kicked_hybr_ptr() = TRUE;
      }

      #ifdef FEATURE_HICPS_STACK_SYNC_UP
      /* If the HDR activity indicator changed, update the local value for it.
      */
      if( sd_rpt_ptr->srv_ind_info.ss == SD_SS_MAIN &&
          ph_ptr->is_hdr_activity != sd_rpt_ptr->srv_ind_info.si_info.is_hdr_activity )
      {
        ph_ptr->is_hdr_activity = sd_rpt_ptr->srv_ind_info.si_info.is_hdr_activity;
        CM_MSG_HIGH_1("HICPS: HDR activity status updated : %d",
                                                ph_ptr->is_hdr_activity);
      }
      #endif

      #if (defined FEATURE_CM_LTE) && (defined FEATURE_HDR_HANDOFF)
      /* If we got HDR srv lost, set shorten BSR flag to TRUE
      */
      CM_MSG_HIGH_6("CM_SRV_IND: mode %d ss %d srv_status %d, Prev HDR srv %d hdr_personality %d Prev HDR personality %d",
                 sd_rpt_ptr->srv_ind_info.si_info.mode,
                 sd_rpt_ptr->srv_ind_info.ss,
                 sd_rpt_ptr->srv_ind_info.si_info.srv_status,
                     ss_ptr->info.hdr_srv_status,
                     sd_rpt_ptr->srv_ind_info.si_info.hdr_personality,
                     ss_ptr->info.hdr_personality);

      /* SRV_IND on HYBR_1 stack.
      ** SD reports NO_SRV.
      ** HYBR_1 stack was in service until now.
      ** personality == EHRPD.
      */
      if( sd_rpt_ptr->srv_ind_info.ss == SD_SS_HYBR_1
          &&
          !sys_srv_status_is_srv(sd_rpt_ptr->srv_ind_info.si_info.srv_status)
          &&
          sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status)
          &&
        ss_ptr->info.hdr_personality == SYS_PERSONALITY_EHRPD
        )
      {
         ph_ptr->is_shorten_bsr = TRUE;
         CM_MSG_HIGH_1("short_bsr_timer_flag is %d",ph_ptr->is_shorten_bsr);
      }
      /* If HDR srv is acquired, reset shorten bsr flag and stop timer
      */
      else if(sd_rpt_ptr->srv_ind_info.ss == SD_SS_HYBR_1 &&
             sys_srv_status_is_srv(sd_rpt_ptr->srv_ind_info.si_info.srv_status) &&
             sd_rpt_ptr->srv_ind_info.si_info.hdr_personality == SYS_PERSONALITY_EHRPD)
      {
        ph_ptr->is_shorten_bsr = FALSE;
        ph_ptr->shorten_bsr_timer = 0;
        CM_MSG_HIGH_1("short_bsr_timer_flag is %d",ph_ptr->is_shorten_bsr);
      }
      #endif

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_PRL_INIT_F:
    {
       if (sd_rpt_ptr->prl_load_complete.is_prl_load_complete == TRUE)
       {
   ph_ptr->is_prl_load_complete = TRUE;
         cmph_event( ph_ptr, CM_PH_EVENT_PRL_INIT);
       }
       break;
    }

    case CM_IRAT_HOLD_USER_ACT:
    {
      
      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_IRAT_HOLD_USER_ACT, NULL);
      #endif
      
      #ifdef FEATURE_LTE_TO_1X
      if ((csfb_call_id = cmcall_is_there_csfb_call(CM_SS_MAIN,CM_CALL_CSFB_TYPE_1XCSFB,
                                         CM_CALL_ID_INVALID)) != CM_CALL_ID_INVALID)
      {
        call_ptr = cmcall_ptr(csfb_call_id);
        if(call_ptr != NULL)
        {

          CM_MSG_HIGH_2("call_ptr->call_state %d, call_ptr->call_subst.idle %d",
            call_ptr->call_state, call_ptr->call_subst.idle);
          if ((call_ptr->call_state == CM_CALL_STATE_IDLE) &&
              (call_ptr->call_subst.idle == CM_CALL_IDLE_SUBST_ENDWAIT))
          {
            irat_ret_status = FALSE;
          }
          else
          {
            irat_ret_status = TRUE;
            ph_ptr->is_hold_user_act = TRUE;
          }
        }
      }
      #endif

      mmoc_rpt_irat_hold_user_act_cnf(irat_ret_status);
      break;
    }

    case CM_IRAT_UNHOLD_USER_ACT:
    {
      
      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_IRAT_UNHOLD_USER_ACT, NULL);
      #endif
      if (ph_ptr->is_hold_user_act)
      {
        ph_ptr->is_hold_user_act = FALSE;
        (void) rex_set_sigs( rex_self(), CM_CLIENT_CMD_Q_SIG );
        CM_MSG_HIGH_1("Re setting hold user action flag %d", ph_ptr->is_hold_user_act);
      }

      break;
    }

    default:
      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  } /* switch( sd_rpt_ptr->hdr.cmd ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is a reply to an earlier command we sent to MC,
  ** also do reply processing.
  */
  if( cm_reply_check(&ph_ptr->reply, sd_rpt_ptr->hdr.cmd) )
  {
    /* Point at client command waiting for reply
    */
    cm_ph_cmd_s_type  *reply_cmd_ptr = (cm_ph_cmd_s_type*)cm_reply_get(&ph_ptr->reply);
    CM_ASSERT( reply_cmd_ptr != NULL );
    CM_ASSERT(CMD_TYPE(reply_cmd_ptr) == CM_CMD_TYPE_PH );

    /* Invoke the reply function with the appropriate error code.
    */
    cmph_client_cmd_mmll_reply( ph_ptr,
                              reply_cmd_ptr,
                              CM_PH_CMD_ERR_NOERR );

    /* We are done with processing the command that was waiting
    ** for reply - deallocate its command buffer.
    */
    cm_cmd_dealloc( reply_cmd_ptr );

    /* reset the reply info */
    cm_reply_init( &ph_ptr->reply );

    /* Turn on the signal that causes us to process any pending
    ** clients commands. This is necessary since we were NOT
    ** processing any clients commands while waiting for a reply
    ** from MC.
    */
    (void) rex_set_sigs( rex_self(), CM_CLIENT_CMD_Q_SIG );

  } /* if( cm_reply_check(&ph_ptr->reply, sd_rpt_ptr->hdr.cmd) ) */
} /* cmph_sd_rpt_proc() */


/*===========================================================================

FUNCTION cmph_ip_rpt_proc

DESCRIPTION
  Process IP specific reports

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_ip_rpt_proc(

  const cm_hdr_type   *rpt_ptr
    /* Pointer to SD reports */
)
{
  #if defined(FEATURE_IP_CALL)

  /*lint -e{826} */
  cmipapp_rpt_s_type const *cmipapp_rpt_ptr = (cmipapp_rpt_s_type *) rpt_ptr;

  cmph_s_type              *ph_ptr     = cmph_ptr();
      /* Point at phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  switch(cmipapp_rpt_ptr->hdr.cmd)
  {
     case CM_IP_APP_UPDATE_DDTM:
       cmph_update_ddtm_status( ph_ptr );
       break;


     case CM_IP_APP_ALLAPSS_SUBSC_CNF:
       {
         CM_MSG_HIGH_1("IMS dereg proc done on sub %d",
                      cmipapp_rpt_ptr->ip_ind.ind.subs_chng_cnf.subs_id_bitmask);
         cmclnup_ip_rpt_proc( CM_IP_APP_ALLAPSS_SUBSC_CNF,
                              cmipapp_rpt_ptr->ip_ind.ind.subs_chng_cnf.subs_id_bitmask );
       }
       break;



     case CM_IP_APP_ALLAPPS_OPRT_CNF:
       CM_MSG_HIGH_0("IMS dereg proc done for oprt_mode");
       cmclnup_ip_rpt_proc( CM_IP_APP_ALLAPPS_OPRT_CNF, 0xFF );
       break;

      case CM_IP_APP_ALLAPPS_SRV_DOM_CNF:
        {
    /* Do command specific processing as follows:
    ** 1. Updating appropriate phone object fields.
    ** 2. Notifying clients of event if necessary.
    */
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- - - - - -*/

    /* If this is a reply to an earlier command we sent to MC,
    ** also do reply processing.
    */
    if( cm_reply_check(&ph_ptr->reply, cmipapp_rpt_ptr->hdr.cmd ))
    {
      boolean              wait_for_reply = FALSE;
      /* Point at client command waiting for reply
      */
      cm_ph_cmd_s_type  *reply_cmd_ptr = (cm_ph_cmd_s_type*)cm_reply_get(&ph_ptr->reply);
      CM_ASSERT( reply_cmd_ptr != NULL );
      CM_ASSERT( CMD_TYPE(reply_cmd_ptr) == CM_CMD_TYPE_PH);

        /* This check need not be made in other places where cm_reply_check() is
        ** called because CM_IP_APP_ALLAPPS_SRV_DOM_CNF is a SD report and
        ** cmph_sd_rpt_proc is the only one having a reply_check called from
        ** cm_sdrpt_handle.
        */
      /* Reset all IPAPP information
      ** Useful in reply_too_long() function
      ** where it is goes to make all ipapps go to
      ** deregister.
      */
      if (cmph_client_cmd_forward_mmll (ph_ptr, reply_cmd_ptr))
      {
        CM_MSG_HIGH_0 ("Wait for reply is TRUE");
        wait_for_reply = TRUE;
      }

      /* If NO need to wait for replay from Lower Layer,
      ** call the reply function right a way.
      */
      if( ! wait_for_reply )
      {
        /* Invoke the reply function with the appropriate error code.
        */
        cmph_client_cmd_mmll_reply( ph_ptr,
                                  reply_cmd_ptr,
                                  CM_PH_CMD_ERR_NOERR );

        /* We are done with processing the command that was waiting
        ** for reply - deallocate its command buffer.
        */
        cm_cmd_dealloc( reply_cmd_ptr );

        /* reset the reply info */
        cm_reply_init( &ph_ptr->reply );

        /* Turn on the signal that causes us to process any pending
        ** clients commands. This is necessary since we were NOT
        ** processing any clients commands while waiting for a reply
        ** from MC.
        */
        (void) rex_set_sigs( rex_self(), CM_CLIENT_CMD_Q_SIG );
      }

    } /* if( cm_reply_check(&ph_ptr->reply, sd_rpt_ptr->hdr.cmd) ) */
  }
        break;


     default:
       break;
  }
  #else /* FEATURE_IP_CALL */
  SYS_ARG_NOT_USED (rpt_ptr);
  #endif

} /* cmph_ip_rpt_proc() */


/*===========================================================================
FUNCTION cmph_proc_dem_rpt

DESCRIPTION
  Process Generic reports


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void                 cmph_proc_dem_rpt(

       cm_dem_rpt_s_type    dem_rpt

)
{
  cm_dem_s_type *dem_ptr = cmph_dem_ptr();

  CM_ASSERT( dem_ptr != NULL );

  switch(dem_rpt.dem_rpt_type)
  {
    case CM_DEM_RPT_APPS_PWR_COLLAPSE:

      dem_ptr->apps_pwr_status =  CM_APPS_PWR_STATUS_PWR_COLLAPSE;
      break;

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_DEM_RPT_APPS_PWR_RESTORED:

      if(dem_ptr->apps_pwr_status == CM_APPS_PWR_STATUS_PWR_COLLAPSE ||
         dem_ptr->apps_pwr_status == CM_APPS_PWR_STATUS_PWR_SUSPEND)
      {
        dem_ptr->apps_pwr_status =  CM_APPS_PWR_STATUS_PWR_RESTORE;

        #ifdef FEATURE_APPS_POWER_COLLAPSE
        /* Trigger info_get event for the events that are suspended.
        */
        cmclient_list_power_collapse_buffered_events_ntfy();
        #endif
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_DEM_RPT_APPS_SUSPEND:

      dem_ptr->apps_pwr_status =  CM_APPS_PWR_STATUS_PWR_SUSPEND;
      break;

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:
      break;
  } /* Switch rpt_type */
} /* cmph_proc_dem_rpt */


#ifndef FEATURE_MMGSDI_SESSION_LIB
/*===========================================================================
FUNCTION cmph_proc_card_init_completed_rpt

DESCRIPTION
  Process Generic reports


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_proc_card_init_completed_rpt(

       mmgsdi_card_init_completed_evt_info_type    card_init_completed

)
{
  const mmgsdi_app_info_type * app_info_ptr = NULL;

  /* INIT_COMPLETED event contains an array of app_info with
  ** num_avail_apps to indicate how many */
  uint32 num_avail_apps = card_init_completed.num_avail_apps;

  uint32                          current_app = 0;
      /* current application on card */

  cm_subscription_status_e_type   gw_subs_status =
                                        CM_SUBSCRIPTION_STATUS_NO_CHANGE;
      /* GW subscirpiton status */

  cm_subscription_status_e_type   cdma_subs_status =
                                        CM_SUBSCRIPTION_STATUS_NO_CHANGE;
      /* CDMA subscirpiton status */

  #if( defined CM_GW_SUPPORTED )
  /* Since CM_MMGSDI_CARD_STATUS_IND is no more valid, if
  ** CM_FEATURE_CENTRALIZED_SUBS is defined, its functionality for
  ** updating ph pointer on receiving card initilization complete
  ** event is brought here.
  */
  cmph_ptr()->valid_card_1 = MMGSDI_SLOT_1;
  #endif /* defined(WCDMA) || defined(GSM) */

  /* subscription is made available for the available apps
  */
  for(current_app = 0; current_app < num_avail_apps; current_app ++ )
  {
    #ifndef FEATURE_MMGSDI_SESSION_LIB
    /* CARD_INIT_COMPLETED contains array of app_info. Iterate over each */
    app_info_ptr = &(card_init_completed.app_info[current_app]);
    #endif /* FEATURE_MMGSDI_SESSION_LIB */

    switch( (*app_info_ptr).app_data.app_type)
    {
      #if( defined CM_GW_SUPPORTED )
      case MMGSDI_APP_SIM:
      case MMGSDI_APP_USIM:
      {
        #ifndef FEATURE_MMGSDI_SESSION_LIB
        /* Lower layer are sending 2 times card init completed events for ICC card,
        ** that contain the both GSM and CDMA apps. Since there are multiple apps,
        ** we do not know INIT is completed for which APP. To fix this issue, we add the
        ** APPS state in Card init event, that contain the TRUE or FALSE value,
        ** where FALSE means that APP is in not initialized yet.
        */
        if((*app_info_ptr).prov_app == TRUE)
        #endif
        {
          gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
        }
      }
      break;
      #endif /* ( defined CM_GW_SUPPORTED) */

      #if( (defined(FEATURE_MMODE_CDMA) || defined(FEATURE_JCDMA) ) && \
         defined(FEATURE_UIM_RUIM))
      case MMGSDI_APP_RUIM:
      #ifdef FEATURE_MMGSDI_SESSION_LIB
      case MMGSDI_APP_CSIM:
      #else
      if((*app_info_ptr).prov_app == TRUE)
      #endif
      {
        #ifdef FEATURE_UIM_RUN_TIME_ENABLE
        if(cmph_ptr()->rtre_control == CM_RTRE_CONTROL_RUIM)
        {
          cdma_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
        }

        #ifdef FEATURE_UIM_RUIM_W_GSM_ACCESS
        else if(cmph_ptr()->rtre_control == CM_RTRE_CONTROL_SIM)
        {
          cdma_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
        }
        #endif /* FEATURE_UIM_RUIM_W_GSM_ACCESS */

        #else /* FEATURE_UIM_RUN_TIME_ENABLE */
        cdma_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
        #endif /* FEATURE_UIM_RUN_TIME_ENABLE */
      } /* case MMGSDI_APP_RUIM || MMGSDI_APP_CSIM */
      break;
      #endif /* (FEATURE_MMODE_CDMA || FEATURE_JCDMA ) && FEATURE_UIM_RUIM */

      default:
        CM_ERR_1("Unknown app type: %d", (*app_info_ptr).app_data.app_type);
        break;
    } /* switch *app_info_ptr.app_data.app_type */
  } /* for(current_app = 0; current_app... */

  if( gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE &&
      cmph_get_gw_subs_from_card_sent() == TRUE
    )/*lint !e774 */
  {
    gw_subs_status = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  }

  if(gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE)/*lint !e774 */
  {
    /* subscription status updated in global
    ** varible for later use
    */
    cmph_set_gw_subs_from_card_sent(TRUE );
  }

  if( cdma_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE &&
      cmph_get_cdma_subs_from_card_sent() == TRUE
     )/*lint !e774 */
  {
    cdma_subs_status = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  }

  if( cdma_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE )/*lint !e774 */
  {
    /* subscription status updated in global
    ** varible for later use
    */
    cmph_set_cdma_subs_from_card_sent( TRUE );
  }

  /* If any of the cellular subscription (CDMA or GW) need to be
  ** made available, then only call subscription available API
  */
  if( gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE ||
     cdma_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE
     )/*lint !e774 */
  {
    if( !cm_ph_cmd_subscription_available_new( NULL,
                                           NULL,
                                           CM_CLIENT_ID_ANONYMOUS,
                                           cdma_subs_status,
                                           gw_subs_status
                                         )
       )
    {
      CM_ERR_2("subs a CDMA %d, GW %d", cdma_subs_status, gw_subs_status);
    }
    else
    {
      CM_MSG_HIGH_2("subs a CDMA %d, GW %d", cdma_subs_status, gw_subs_status);
    }
  }
} /* cmph_proc_card_init_completed_rpt */
#endif /* FEATURE_MMGSDI_SESSION_LIB */


/*===========================================================================
FUNCTION cmph_disable_subscription_status

DESCRIPTION
  Disable available subscriptions (or) the specified subscriptions

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void      cmph_disable_subscription_status(

       cm_subscription_status_e_type   gw_subs_status,
        /* should gw subscription status be changed */

       cm_subscription_status_e_type   cdma_subs_status,
        /* should cdma subscription status be changed */

       cm_subscription_status_e_type   hybr_gw_subs_status,
        /* should gw subscription status be changed */

       cm_subscription_status_e_type   hybr_3_gw_subs_status,
        /* should gw subscription status be changed */

       cm_subscription_not_avail_cause_e_type sub_not_avail_cause
        /* Cause for subscription not available */

)
{
  /* If RTRE is set to NV, do not update cdma sub */
  if (cmph_ptr()->rtre_control == CM_RTRE_CONTROL_NV ||
      cmph_ptr()->rtre_config == CM_RTRE_CONFIG_NV_ONLY)
  {
    cdma_subs_status = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  }

  /* CDMA subscription is made unavailable only if it was
  ** available from card.
  */
  if( cmph_get_cdma_subs_from_card_sent() &&
      cdma_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    /* update subscription status */
    cmph_set_cdma_subs_from_card_sent( FALSE );
  }
  else
  {
    cdma_subs_status = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  }

  /* GW subscription is made unavailable only if it was
  ** available from card.
  */
  if( cmph_get_gw_subs_from_card_sent() &&
      gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    /* update subscription status */
    cmph_set_gw_subs_from_card_sent( FALSE );
  }
  else
  {
    gw_subs_status = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  }

  /* Hybr GW subscription is made unavailable only if it was
  ** available from card.
  */
  if( cmph_get_hybr_gw_subs_from_card_sent() &&
      hybr_gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    /* update subscription status */
    cmph_set_hybr_gw_subs_from_card_sent( FALSE );
  }
  else
  {
    hybr_gw_subs_status = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  /* Hybr3 GW subscription is made unavailable only if it was
  ** available from card.
  */
  if( cmph_get_hybr_3_gw_subs_from_card_sent() &&
      hybr_3_gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE )
  {
    /* update subscription status */
    cmph_set_hybr_3_gw_subs_from_card_sent( FALSE );
  }
  else
  {
    hybr_3_gw_subs_status = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  }
  #endif /* FEATURE_MMODE_TRIPLE_SIM */

  /* If any of the cellular subscription (CDMA or GW) need to be
  ** made not available, then only call subscription available API
  */
  if( gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE ||
      cdma_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE
      || hybr_gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE
    #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
      || hybr_3_gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE
      #endif
    )
  {
    cmph_send_subscription_not_available_internal( cdma_subs_status,
                                                   gw_subs_status,
                                                   hybr_gw_subs_status,
                                                   hybr_3_gw_subs_status,
                                                   sub_not_avail_cause);
  }
} /* cmph_disable_subscription_status */

#ifdef FEATURE_MMGSDI_SESSION_LIB


/*===========================================================================
FUNCTION cmph_proc_card_inserted_rpt

DESCRIPTION
  Process Generic reports


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_proc_card_inserted_rpt( void )
{
  /* If session is already opened, skip session open handling */
  if(!cmph_sessoin_open_sent)
  {
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
    /* Open session for 1x default provisioning app */
    cmmmgsdi_open_session(MMGSDI_1X_PROV_PRI_SESSION);
    #endif /* #if (FEATURE_MMODE_CDMA_800) || (FEATURE_MMODE_CDMA_1900)) */

    #if (defined CM_GW_SUPPORTED || defined(FEATURE_CM_LTE))
    /* Open session for default provisioning app */
    cmmmgsdi_open_session(MMGSDI_GW_PROV_PRI_SESSION);

    /* Open session for secondary provisioning app
      ** 1. for dsda, open gw sec session only if device is in dual sim opr mode,
      ** 2. or for dsds, always open gw sec session
      */
    if (cmph_is_msim())
    {
    /* Open session for secondary provisioning app */
      cmmmgsdi_open_session(MMGSDI_GW_PROV_SEC_SESSION);
    /* Open session for ter provisioning app */
      #ifdef FEATURE_MMODE_TRIPLE_SIM
      if (cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY)
      {
        cmmmgsdi_open_session(MMGSDI_GW_PROV_TER_SESSION);
      }
      #endif
    }

    #endif  /* #if (FEATURE_WCDMA) || (FEATURE_GSM) */

    cmph_sessoin_open_sent = TRUE;
  }
}


/*===========================================================================
FUNCTION cmph_proc_subscription_ready_rpt

DESCRIPTION
  Process Generic reports


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_proc_subscription_ready_rpt(

       mmgsdi_session_id_type   session_id,
        /* Session Id of the report recieved */

       mmgsdi_slot_id_enum_type slot
        /* Slot on which the app is activated*/
)
{
  cm_subscription_status_e_type   gw_subs_status =
                                        CM_SUBSCRIPTION_STATUS_NO_CHANGE;
      /* GW subscirpiton status */

  cm_subscription_status_e_type   hybr_gw_subs_status =
                                        CM_SUBSCRIPTION_STATUS_NO_CHANGE;
      /* Hybr GW subscirpiton status */

   cm_subscription_status_e_type   hybr_3_gw_subs_status =
                                        CM_SUBSCRIPTION_STATUS_NO_CHANGE;
      /* Hybr GW subscirpiton status */

  cm_subscription_status_e_type   cdma_subs_status =
                                        CM_SUBSCRIPTION_STATUS_NO_CHANGE;
      /* CDMA subscirpiton status */

  cm_mmgsdi_session_info_s_type   sess_info =
                                        {MMGSDI_MAX_SESSION_TYPE_ENUM, 0 };
      /* session info for mmgsdi reports recieved */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  cmph_s_type                   *ph_ptr  =  cmph_ptr();


  cm_mmgsdi_session_id_table_entry_s_type* ssn_entry = NULL;
  ssn_entry = cm_mmgsdi_ssn_tbl_get_entry_by_id(session_id);

  /*If Either RTRE Control is set to NV or RTRE config is set to NV
  And Cm gets subs ready event from UIM then do not pass event to clients */
  if ((ph_ptr != NULL) && (ssn_entry != NULL ))
  {
    if (((ph_ptr->rtre_control == CM_RTRE_CONTROL_NV)||
         (ph_ptr->rtre_config == CM_RTRE_CONFIG_NV_ONLY))
          &&
         ((ssn_entry->session_type == MMGSDI_1X_PROV_PRI_SESSION) ||
          (ssn_entry->session_type == MMGSDI_1X_PROV_SEC_SESSION)))
    {
      CM_MSG_HIGH_1("RTRE-NV: Ignore sub ready report - session type is %d",
                     ssn_entry->session_type);
      return;
    }
  }

  /* Get the session type corresponding to this event */
  if(cm_mmgsdi_ssn_tbl_get_ssn_info_for_id(session_id, &sess_info) !=
                                                            CM_MMGSDI_SUCCESS)
  {
    CM_ERR_1(" Wrong session_id %d", session_id);
    return;
  }
/*******************************************************************************/

  #ifdef FEATURE_MMODE_DUAL_SIM
  {
    mmgsdi_access_type       uicc_access;
    mmgsdi_return_enum_type  mmgsdi_status = MMGSDI_ERROR;
    cm_mmgsdi_error_e_type   cm_mmgsdi_status = CM_MMGSDI_NOTFOUND;
    uint8                    iccid_buf[CM_MMGSDI_MAX_UICC_LEN];

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Get the UICC-Id of the app
    ** Once we retrieve the UICC-id, then Queue a generic command to process
    ** the subscription info.
    */
    uicc_access.access_method = MMGSDI_EF_ENUM_ACCESS;
    uicc_access.file.file_enum   = MMGSDI_ICCID;

    memset(iccid_buf, 0, sizeof(iccid_buf));
    cm_mmgsdi_read_cnf_ptr.data_len = sizeof(iccid_buf);
    cm_mmgsdi_read_cnf_ptr.data_ptr = iccid_buf;

    mmgsdi_status = mmgsdi_session_read_cache(session_id,
                                         uicc_access.file.file_enum,
                                         cm_mmgsdi_read_cnf_ptr);

    CM_MSG_HIGH_1 ("mmgsdi_read_cache returned : %d ", mmgsdi_status);

    /* Copy the ICC-ID into local structure if read was successfull */

    if (MMGSDI_SUCCESS != mmgsdi_status)
    {
     CM_MSG_HIGH_1 ("mmgsdi_read_cache failed!!! status %d",mmgsdi_status);
    }
    else
    {
      /* Passed mmgsdi_session_type_enum_type as client data with
           ** mmgsdi_session_open request
            */
     cm_mmgsdi_status = cm_mmgsdi_ssn_tbl_update_uicc_for_id(
                               session_id,
                               cm_mmgsdi_read_cnf_ptr.data_ptr,
                               (uint32)cm_mmgsdi_read_cnf_ptr.data_len);

      if( CM_MMGSDI_SUCCESS == cm_mmgsdi_status )
      {
        CM_MSG_HIGH_1("MMGSDI got UICC-id: session id %d",
                                 session_id);
      }
      else
      {
        CM_ERR_1("MMGSDI uicc write fail session id %d",
                                 session_id);/*lint !e641 */
      }
    }
    cm_mmgsdi_read_cnf_ptr.data_len = 0;
    cm_mmgsdi_read_cnf_ptr.data_ptr = NULL;
  }
  #endif


/******************************************************************************/
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Map the sess_info.session_type to the subscriptions */
  switch(sess_info.session_type)
  {
    case MMGSDI_1X_PROV_PRI_SESSION:
      /* When CDMA app is provisioned, set the CDMA subscription status*/
      cdma_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
      cmph_set_cdma_subs_from_card_sent( TRUE );
      (void)cm_mmgsdi_ssn_tbl_update_asubs_for_id(session_id, SYS_MODEM_AS_ID_1);
      cmph_ptr()->valid_card_1 = slot;
      cmph_ptr()->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
      break;

    case MMGSDI_GW_PROV_PRI_SESSION:
      #ifdef CM_GW_SUPPORTED
    (void)cm_mmgsdi_ssn_tbl_update_asubs_for_id(session_id, SYS_MODEM_AS_ID_1);
    /* Update the flag indicating that there is a valid card */
    cmph_ptr()->valid_card_1 = slot;

    #if defined(FEATURE_MMODE_SXLTE_G)
    if(cmph_is_msim() && cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_2))
    {
      /* AS_ID_1 on hybr_3 */
      cmph_ptr()->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
      /* When GW app is provisioned, set the GW subscription status*/
      hybr_3_gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
      cmph_set_hybr_3_gw_subs_from_card_sent(TRUE );
    }
    else
    #endif
    {
      cmph_ptr()->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
      /* When GW app is provisioned, set the GW subscription status*/
      gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
      cmph_set_gw_subs_from_card_sent(TRUE );
    }
    #endif /* defined(WCDMA) || defined(GSM) */
    break;

    case MMGSDI_GW_PROV_SEC_SESSION:
       #ifdef CM_GW_SUPPORTED
       if (cmph_is_msim())
       {
       (void)cm_mmgsdi_ssn_tbl_update_asubs_for_id(session_id, SYS_MODEM_AS_ID_2);
     cmph_ptr()->valid_card_2 = slot;

       #if defined(FEATURE_MMODE_SXLTE_G)
       if(cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_2))
       {
         /* AS_ID_2 goes to MAIN/HYBR2 */
         cmph_ptr()->main_stack_info.asubs_id = SYS_MODEM_AS_ID_2;

         gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
         cmph_set_gw_subs_from_card_sent(TRUE );
       }
       else if(cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) ||
             cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) ||
             cmph_is_sub2_map_to_hybr3())
       {
         /* AS_ID_2 goes to HYBR_3 */
         hybr_3_gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
         cmph_set_hybr_3_gw_subs_from_card_sent(TRUE );
         cmph_ptr()->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
       }
       else
       #endif
       {
         /* AS_ID_2 goes to HYBR_2 */
         hybr_gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
         cmph_set_hybr_gw_subs_from_card_sent(TRUE );

         cmph_ptr()->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
       }
    }
    #endif
    break;

      #ifdef FEATURE_MMODE_TRIPLE_SIM
      case MMGSDI_GW_PROV_TER_SESSION:
      /* When GW3 app is provisioned, set the GW subscription status*/
      hybr_3_gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
      cmph_set_hybr_3_gw_subs_from_card_sent(TRUE );

      (void)cm_mmgsdi_ssn_tbl_update_asubs_for_id(session_id, SYS_MODEM_AS_ID_3);

      /* Update the flag indicating that there is a valid card */
      cmph_ptr()->valid_card_3 = slot;
      cmph_ptr()->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_3;
      break;
      #endif

    default:
      CM_MSG_HIGH_1( "Unhandled sess_info.session_type %d", sess_info.session_type );
      break;
  }

  /* If any of the cellular subscription (CDMA or GW) need to be
  ** made available, then only call subscription available API
  */
  if( gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE ||
      hybr_gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE ||
    #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
      hybr_3_gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE ||
      #endif
      cdma_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE
     )/*lint !e774 */
  {
    if( !cm_ph_cmd_subscription_available3( NULL,
                                            NULL,
                                            CM_CLIENT_ID_ANONYMOUS,
                                            cdma_subs_status,
                                            gw_subs_status,
                                            hybr_gw_subs_status,
                                            hybr_3_gw_subs_status

                                          )
       )
    {
      CM_ERR_3("subs a CDMA %d, GW %d, Hybr GW %d", cdma_subs_status,
                     gw_subs_status, hybr_gw_subs_status);

      CM_ERR_1("Hybr GW3 %d", hybr_3_gw_subs_status);
    }
    else
    {
      CM_MSG_HIGH_4("subs a CDMA %d, GW %d, Hybr GW %d Hybr GW3 %d", 
	  	            cdma_subs_status, gw_subs_status, hybr_gw_subs_status, hybr_3_gw_subs_status);


    }

  }
} /* cmph_proc_subscription_ready_rpt */


/*===========================================================================
FUNCTION cmph_proc_illegal_subscription_rpt

DESCRIPTION
  Process the illegal subscription report recieved from MMGSDI

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_proc_illegal_subscription_rpt(

       mmgsdi_session_id_type   session_id
        /* Session Id of the report recieved */
)
{
  cm_mmgsdi_session_info_s_type ssn_info = { MMGSDI_GW_PROV_PRI_SESSION, 0 };
    /* Session info for the mmgsdi reports recieved */

  cmph_s_type                          *ph_ptr  =  cmph_ptr();
  cm_mmgsdi_session_id_table_entry_s_type *ssn_entry = NULL;

  /* Make sure that this is a known session_type */
  if(cm_mmgsdi_ssn_tbl_get_ssn_info_for_id(session_id, &ssn_info) != CM_MMGSDI_SUCCESS)
  {
    CM_MSG_HIGH_1( "Wrong session_id %d", session_id );
    return;
  }

  /*If Either RTRE Control is set to NV or RTRE config is set to NV
    And Cm gets subs event for 1x sesstion type from UIM then do not pass event to clients
  */
  ssn_entry = cm_mmgsdi_ssn_tbl_get_entry_by_id(session_id);

  if (ssn_entry)
  {
    if (((ph_ptr->rtre_control == CM_RTRE_CONTROL_NV)||
         (ph_ptr->rtre_config == CM_RTRE_CONFIG_NV_ONLY))
          &&
         ((ssn_entry->session_type == MMGSDI_1X_PROV_PRI_SESSION) ||
          (ssn_entry->session_type == MMGSDI_1X_PROV_SEC_SESSION)))
    {
      CM_MSG_HIGH_1("RTRE-NV: Ignore illegal sub report - session type is %d",
                     ssn_entry->session_type);
      return;
    }
  }

  /* Map the ssn_info.session_type to the subscriptions */
  switch(ssn_info.session_type)
  {
    case MMGSDI_1X_PROV_PRI_SESSION:
      /* Disable 1x subscriptions that are recieved from the SIM */
      cmph_disable_subscription_status(CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                       CM_SUBSCRIPTION_STATUS_CHANGE,
                                       CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                       CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                       CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_ILLEGAL_SUB);
      cm_mmgsdi_ssn_tbl_update_asubs_for_id(session_id,SYS_MODEM_AS_ID_NONE);

      break;

    case MMGSDI_GW_PROV_PRI_SESSION:
      /* Disable gw subscriptions that are recieved from the SIM */
      cmph_disable_subscription_status(CM_SUBSCRIPTION_STATUS_CHANGE,
                                       CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                       CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                       CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                       CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_ILLEGAL_SUB);
      cm_mmgsdi_ssn_tbl_update_asubs_for_id(session_id,SYS_MODEM_AS_ID_NONE);

      break;

    case MMGSDI_GW_PROV_SEC_SESSION:
      /* Disable hybr gw subscriptions that are recieved from the SIM */
      if (cmph_is_sxlte())
      {
        cmph_disable_subscription_status(CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                         CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                         CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                         CM_SUBSCRIPTION_STATUS_CHANGE,
                                         CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_ILLEGAL_SUB);
      }
      else
      {
        cmph_disable_subscription_status(CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                         CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                         CM_SUBSCRIPTION_STATUS_CHANGE,
                                         CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                         CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_ILLEGAL_SUB);
      }
      cm_mmgsdi_ssn_tbl_update_asubs_for_id(session_id,SYS_MODEM_AS_ID_NONE);

      break;

    case MMGSDI_GW_PROV_TER_SESSION:
      /* Disable gw subscriptions that are recieved from the SIM */
      cmph_disable_subscription_status(CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                       CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                       CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                       CM_SUBSCRIPTION_STATUS_CHANGE,
                                       CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_ILLEGAL_SUB);
      cm_mmgsdi_ssn_tbl_update_asubs_for_id(session_id,SYS_MODEM_AS_ID_NONE);
      break;

    default:
      CM_ERR_1("Unhandled ssn_info.session_type %d", ssn_info.session_type);
      break;
  }

} /* cmph_proc_illegal_subscription_rpt */
/*===========================================================================

FUNCTION cmph_process_subscription_changed_rpt

DESCRIPTION
  Process the subscription ready event from MMGSDI

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_process_subscription_changed_rpt(

       const mmgsdi_event_data_type   *rpt_info

)
{
  cm_subscription_status_e_type   gw_subs_status =
                                        CM_SUBSCRIPTION_STATUS_NO_CHANGE;
      /* GW subscirpiton status */

  cm_subscription_status_e_type   hybr_gw_subs_status =
                                        CM_SUBSCRIPTION_STATUS_NO_CHANGE;
      /* Hybr GW subscirpiton status */

  cm_subscription_status_e_type   hybr_3_gw_subs_status =
                                        CM_SUBSCRIPTION_STATUS_NO_CHANGE;
      /* Hybr GW subscirpiton status */

  cm_subscription_status_e_type   cdma_subs_status =
                                        CM_SUBSCRIPTION_STATUS_NO_CHANGE;
      /* CDMA subscirpiton status */

  cmph_s_type                     *ph_ptr = cmph_ptr();

  cm_mmgsdi_error_e_type          mmgsdi_status;

  cm_mmgsdi_session_info_s_type sess_info =
                                          {MMGSDI_MAX_SESSION_TYPE_ENUM, 0 };

  cm_mmgsdi_session_id_table_entry_s_type* ssn_entry = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (rpt_info == NULL)
  {
    CM_ERR_0("rpt_info NULL ptr");
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get the subscription info from the session table
  */
  mmgsdi_status = cm_mmgsdi_ssn_tbl_get_ssn_info_for_id(rpt_info->session_id,
                                                   &sess_info);
  if(mmgsdi_status != CM_MMGSDI_SUCCESS)
  {
    CM_ERR_1("Cant read session info for session id: %d", rpt_info->session_id);
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ssn_entry = cm_mmgsdi_ssn_tbl_get_entry_by_id(rpt_info->session_id);

  /*If Either RTRE Control is set to NV or RTRE config is set to NV
  And Cm gets subs ready event from UIM then do not pass event to clients */
  if (ssn_entry)
  {
    if (((ph_ptr->rtre_control == CM_RTRE_CONTROL_NV)||
         (ph_ptr->rtre_config == CM_RTRE_CONFIG_NV_ONLY))
          &&
         ((ssn_entry->session_type == MMGSDI_1X_PROV_PRI_SESSION) ||
          (ssn_entry->session_type == MMGSDI_1X_PROV_SEC_SESSION)))
    {
      CM_MSG_HIGH_1("RTRE-NV: Ignore sub chg report - session type is %d",
                     ssn_entry->session_type);
      return;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Check which subscription has changed
  */
  if( sess_info.session_type == MMGSDI_GW_PROV_PRI_SESSION &&
      ph_ptr->is_gwl_subscription_available
    )
  {
    gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
    ph_ptr->valid_card_1 = (mmgsdi_slot_id_enum_type)FALSE;
    cmph_gw_subs_from_card_sent = FALSE;
    cm_mmgsdi_ssn_tbl_update_asubs_for_id(rpt_info->session_id,SYS_MODEM_AS_ID_NONE);
  }
  else if( sess_info.session_type == MMGSDI_1X_PROV_PRI_SESSION &&
           ph_ptr->is_cdma_subscription_available
         )
  {
    cdma_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
    cmph_cdma_subs_from_card_sent = FALSE;
    cm_mmgsdi_ssn_tbl_update_asubs_for_id(rpt_info->session_id,SYS_MODEM_AS_ID_NONE);
  }
  else if( sess_info.session_type == MMGSDI_GW_PROV_SEC_SESSION &&
           ph_ptr->is_hybr_gw_subscription_available && !cmph_is_sxlte()
         )
  {
    hybr_gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
    ph_ptr->valid_card_2 = (mmgsdi_slot_id_enum_type)FALSE;
    cmph_set_hybr_gw_subs_from_card_sent(FALSE);
    cm_mmgsdi_ssn_tbl_update_asubs_for_id(rpt_info->session_id,SYS_MODEM_AS_ID_NONE);
  }
  #if defined(FEATURE_MMODE_SXLTE_G)
  else if( sess_info.session_type == MMGSDI_GW_PROV_SEC_SESSION &&
           ph_ptr->is_hybr_gw3_subscription_available && cmph_is_sxlte()
         )
  {
    hybr_3_gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
    ph_ptr->valid_card_2 = (mmgsdi_slot_id_enum_type)FALSE;
    cmph_set_hybr_3_gw_subs_from_card_sent(FALSE);
    cm_mmgsdi_ssn_tbl_update_asubs_for_id(rpt_info->session_id,SYS_MODEM_AS_ID_NONE);
  }
  #endif
  #ifdef FEATURE_MMODE_TRIPLE_SIM
  else if( sess_info.session_type == MMGSDI_GW_PROV_TER_SESSION &&
           ph_ptr->is_hybr_gw3_subscription_available
         )
  {
    hybr_3_gw_subs_status = CM_SUBSCRIPTION_STATUS_CHANGE;
    ph_ptr->valid_card_3 = (mmgsdi_slot_id_enum_type)FALSE;
    cmph_set_hybr_3_gw_subs_from_card_sent(FALSE);
    cm_mmgsdi_ssn_tbl_update_asubs_for_id(rpt_info->session_id,SYS_MODEM_AS_ID_NONE);
  }
  #endif
  else
  {
    CM_MSG_HIGH_1("session id %d not found in subsc chgd evt processing",
                sess_info.session_id);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Since the App that provided this subscription has either changed
  ** (or) is no longer available. Make this subscription as not available.
  */
  if( gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE ||
      cdma_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE
      || hybr_gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE
    #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
      || hybr_3_gw_subs_status == CM_SUBSCRIPTION_STATUS_CHANGE
      #endif
    )
  {
    cmph_send_subscription_not_available_internal( cdma_subs_status,
                                                   gw_subs_status,
                                                   hybr_gw_subs_status,
                                                   hybr_3_gw_subs_status,
                                                   CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_OTHERS);
    }
} /* cmph_process_subscription_changed_rpt */

#endif /* FEATURE_MMGSDI_SESSION_LIB */

/*===========================================================================

FUNCTION cmph_generic_rpt_proc

DESCRIPTION
  Process Generic reports


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_generic_rpt_proc(

  const cm_hdr_type   *rpt_ptr
    /* Pointer to generic reports */
)
{
  /*lint -save -e826 */
  const cm_generic_rpt_s_type         *gen_rpt_ptr = (cm_generic_rpt_s_type *) rpt_ptr;
  /*lint -restore */
    /* Pointer to SD reports */

  cmph_s_type                         *ph_ptr      = cmph_ptr();

  cm_subscription_status_e_type       cdma_status   = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  cm_subscription_status_e_type       gw_status     = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  cm_subscription_status_e_type       hybr_gw_status= CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  cm_subscription_status_e_type       hybr_3_gw_status= CM_SUBSCRIPTION_STATUS_NO_CHANGE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( gen_rpt_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch(gen_rpt_ptr->hdr.cmd)
  {
    case CM_DEM_RPT:
      cmph_proc_dem_rpt(gen_rpt_ptr->generic_rpt.dem_rpt);
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/



    #ifdef FEATURE_MMGSDI_SESSION_LIB
    case CM_MMGSDI_SESSION_OPEN_RPT:
      #ifdef FEATURE_GSTK
      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_MMGSDI_SESSION_OPEN_RPT, \
        ((void*)(&(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.session_id))));
      #endif
      cmmmgsdi_process_session_open_rpt(&(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt));
      #endif /* FEATURE_GSTK */
      break;
    #endif /* FEATURE_MMGSDI_SESSION_LIB */

    /* MMGSDI Card status and PIN related events are handled here.
    */
    case CM_MMGSDI_CARD_RPT:

      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_MMGSDI_CARD_RPT, ((void*)&(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt)));
      #endif
      switch(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.evt)
      {
        #ifdef FEATURE_MMGSDI_SESSION_LIB
        case MMGSDI_CARD_INSERTED_EVT:
          cmph_proc_card_inserted_rpt();
          break;

        case MMGSDI_SUBSCRIPTION_READY_EVT:
          CM_MSG_HIGH_1("oprt_mode_online: subscription_ready for session %d",\
            gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.session_id );
          cmmmgsdi_update_session_state(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.session_id, CMMMGSDI_STATE_SUBSCRIPTION_READY);

          cmph_proc_subscription_ready_rpt(
          gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.session_id,
          gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.subscription_ready.app_info.slot);
          break;

        case MMGSDI_SIM_BUSY_EVT:
          {
            cmmmgsdi_s_type  *mmgsdi_ptr= cmmmgsdi_ptr();

            /* here we need to store sim-busy status for SYS_MODEM_AS_ID_1
                        **since mmoc-subsc-change can fail for 1X ,
                        **which we need to recover when SIM is ready */
            if (gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.sim_busy.slot == ph_ptr->valid_card_1)
            {
            mmgsdi_ptr->sim_busy_status.is_sim_busy =
               gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.sim_busy.sim_busy;
              
              cmph_recover_mmoc_subsc_fail();
            }

          }
          break;


        case MMGSDI_SESSION_LEGAL_SUBSCRIPTION_EVT:
      cmph_proc_subscription_ready_rpt(
          gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.session_id,
          gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.legal_session.app_info.slot);
          break;

        case MMGSDI_SESSION_CHANGED_EVT:
          CM_MSG_HIGH_2("oprt_mode_online: session_change activated %d, session %d",\
            gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.session_changed.activated, gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.session_id );
          if ( gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.session_changed.activated)
          {
            cmmmgsdi_update_session_state(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.session_id, CMMMGSDI_STATE_SESSION_CHANGED);
          }
          else
          {
            cmmmgsdi_update_session_state(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.session_id, CMMMGSDI_STATE_NONE);
          }
          cmph_process_subscription_changed_rpt(
                                  &(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt));
          break;

        case MMGSDI_SESSION_ILLEGAL_SUBSCRIPTION_EVT:
          cmph_proc_illegal_subscription_rpt(
            gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.illegal_session.session_id);
          break;
        #else /* FEATURE_MMGSDI_SESSION_LIB */

        case MMGSDI_CARD_INIT_COMPLETED_EVT:
          cmph_proc_card_init_completed_rpt(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.card_init_completed);
          break;
        #endif /* FEATURE_MMGSDI_SESSION_LIB */

       case MMGSDI_CARD_ERROR_EVT:
       case MMGSDI_CARD_REMOVED_EVT:
       {
         /* Since CM_MMGSDI_CARD_STATUS_IND is no more valid, if
         ** CM_FEATURE_CENTRALIZED_SUBS is defined, its functionality for
         ** updating ph pointer on receiving card initilization complete
         ** eventis brought here.
         */
         #ifdef CM_GW_SUPPORTED

         mmgsdi_slot_id_enum_type invalid_slot;

         /* Get which slot is affected
         */
         if(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.evt == MMGSDI_CARD_ERROR_EVT)
         {
           invalid_slot = gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.card_error.slot;
         }
         else
         {
           invalid_slot = gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.card_removed.slot;
         }

           CM_MSG_HIGH_0("Card Error/Removed");

         if( invalid_slot == ph_ptr->valid_card_1)
         {
           ph_ptr->valid_card_1 = (mmgsdi_slot_id_enum_type)FALSE;
           cdma_status          = CM_SUBSCRIPTION_STATUS_CHANGE;
           gw_status            = CM_SUBSCRIPTION_STATUS_CHANGE;
         }
         else if (invalid_slot == ph_ptr->valid_card_2)
         {
           ph_ptr->valid_card_2 = (mmgsdi_slot_id_enum_type)FALSE;
           if (cmph_is_sxlte())
             hybr_3_gw_status     = CM_SUBSCRIPTION_STATUS_CHANGE;
           else
             hybr_gw_status       = CM_SUBSCRIPTION_STATUS_CHANGE;
         }
         else if (invalid_slot == ph_ptr->valid_card_3)
         {
           ph_ptr->valid_card_3 = (mmgsdi_slot_id_enum_type)FALSE;
           hybr_3_gw_status       = CM_SUBSCRIPTION_STATUS_CHANGE;
         }

         #endif /* FEATURE_WCDMA || FEATURE_GSM */
       }
       /* Disable all subscriptions that are recieved from the SIM */
       cmph_disable_subscription_status( cdma_status, gw_status,
                                         hybr_gw_status, hybr_3_gw_status,
                                         CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_OTHERS);
       cmpsm_set_psm_lmtd_srv_ind_timer();
       break;

       /*lint -fallthrough */
       case MMGSDI_SAP_CONNECT_EVT:
         if(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.evt == MMGSDI_SAP_CONNECT_EVT)
         {
                /* Get which slot is affected
                            */

           #ifndef FEATURE_MMODE_DUAL_SIM
           cdma_status          = CM_SUBSCRIPTION_STATUS_CHANGE;
           gw_status            = CM_SUBSCRIPTION_STATUS_CHANGE;
           #else
           mmgsdi_slot_id_enum_type report_slot = \
                      gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.sap_connect.slot;
           if( report_slot == ph_ptr->valid_card_1)
           {
           cdma_status          = CM_SUBSCRIPTION_STATUS_CHANGE;
           gw_status            = CM_SUBSCRIPTION_STATUS_CHANGE;
           }
           else if (report_slot == ph_ptr->valid_card_2)
           {
             ph_ptr->valid_card_2 = (mmgsdi_slot_id_enum_type)FALSE;
             if (cmph_is_sxlte())
             {
               hybr_3_gw_status     = CM_SUBSCRIPTION_STATUS_CHANGE;
             }
             else
             {
               hybr_gw_status       = CM_SUBSCRIPTION_STATUS_CHANGE;
             }
            }
           else if (report_slot == ph_ptr->valid_card_3)
           {
             hybr_3_gw_status       = CM_SUBSCRIPTION_STATUS_CHANGE;
           }
           #endif
         }
         /* Disable all subscriptions that are recieved from the SIM */
         cmph_disable_subscription_status( cdma_status, gw_status,
                                           hybr_gw_status, hybr_3_gw_status,
                                           CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_OTHERS);
         break;

       case MMGSDI_PIN1_EVT:
         if( cmph_get_received_card_init_completed_evt() == TRUE )
         {
           mmgsdi_cnf_type *mmgsdi_cnf;

           mmgsdi_cnf = (mmgsdi_cnf_type *)cm_mem_malloc(sizeof(mmgsdi_cnf_type));

           mmgsdi_cnf->get_all_pin_status_cnf.universal_pin =
                    gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.pin.pin_info;

           if(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.data.pin.pin_info.pin_replacement
              == MMGSDI_PIN_NOT_REPLACED_BY_UNIVERSAL)
           {
             mmgsdi_cnf->get_all_pin_status_cnf.universal_pin.pin_replacement
                                            = MMGSDI_PIN_REPLACED_BY_UNIVERSAL;
           }
           else
           {
             mmgsdi_cnf->get_all_pin_status_cnf.universal_pin.pin_replacement
                                        = MMGSDI_PIN_NOT_REPLACED_BY_UNIVERSAL;
           }

           mmgsdi_cnf->get_all_pin_status_cnf.response_header.session_id =
                          gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.session_id;

           cmmmgsdi_get_all_pin_status_cb( MMGSDI_SUCCESS,
                                           MMGSDI_GET_ALL_PIN_STATUS_CNF,
                                           mmgsdi_cnf
                                         );
           cm_mem_free (mmgsdi_cnf);
         } /* if( cmph_get_received_card_init_completed_evt().. */
         break;

       case MMGSDI_UNIVERSAL_PIN_EVT:
         if( cmph_get_received_card_init_completed_evt() == TRUE )
         {
           /* First need to check whether PIN1 is replaced by universal PIN.
           ** if yes, honour Universal PIN event other wise ignore it.
           */
           cmmmgsdi_get_all_pin_status(
                     gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.session_id);
           CM_MSG_HIGH_0("MMGSDI_UNIVERSAL_PIN_EVT");
         }
         break;

       default:
         break;
      } /* switch(gen_rpt_ptr->generic_rpt... */
      /*lint -fallthrough */
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_DATA_PACKET_STATE_RPT:
       CM_MSG_HIGH_1("CLNUP: DS cleanup complete on subs %d",gen_rpt_ptr->generic_rpt.pkt_data.subs_id_mask);
       cmclnup_ds_pkt_rpt_proc( gen_rpt_ptr->generic_rpt.pkt_data.subs_id_mask );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #ifdef CM_GW_SUPPORTED
    case CM_DROP_CHARGED_CALLS:
    {
      cm_ss_e_type cm_stack_ss =
                          cmph_map_sd_ss_type_to_cm_ss_type(
                            gen_rpt_ptr->generic_rpt.drop_calls_rpt.ss);
      sys_modem_as_id_e_type   asubs_id
        = cmph_map_cm_ss_to_subs(cm_stack_ss);

      cmwaoc_drop_all_calls_now(asubs_id);
      break;
    }
    #endif
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case CM_CALL_CTRL_RPT:
    {
      cm_orig_client_categ_e_type    client_categ = CM_ORIG_CLIENT_CATEG_NONE;
      cmcc_object_s_type  *cc_object_ptr =
        (cmcc_object_s_type *) gen_rpt_ptr->generic_rpt.call_ctrl_rpt.cc_object_ptr;

      CM_MSG_HIGH_2("call_control: cmph 1 MMGSDI Rcvd cc_obj_ptr %x, user_data %x", cc_object_ptr, cc_object_ptr->user_data);
      #if defined CM_GW_SUPPORTED || defined FEATURE_IP_CALL
      if (cc_object_ptr->call_type == CM_CALL_TYPE_SUPS)
      {
        cm_sups_cmd_s_type   *sups_cmd_ptr = (cm_sups_cmd_s_type*) cc_object_ptr->user_data;
        client_categ                       = sups_cmd_ptr->client_categ;
      }
      else
      #endif
      {
      cm_call_cmd_s_type   *call_cmd_ptr = (cm_call_cmd_s_type*) cc_object_ptr->user_data;
        client_categ                       = call_cmd_ptr->client_categ;
      }

      CM_MSG_HIGH_2("call_control: cmph 2 MMGSDI Rcvd cc_obj_ptr %x, user_data %x", cc_object_ptr, cc_object_ptr->user_data);
      cmcc_call_ctrl_after_sim_capabilities(cc_object_ptr,
                                            client_categ);

    }
    break;

    #if 0
    case CM_MODEM_RESET_TIMER_RPT:
    {
      #ifdef FEATURE_MMODE_DUAL_SIM
      cmss_s_type         *ss_ptr        = cmss_ptr();
      if( ss_ptr->enable_modem_reset == TRUE)
        {
        /*Handling Modem Reset Timer*/
        CM_MSG_HIGH_0("MODEM_RESET_TIMER_RPT");
        cmss_process_modem_reset_rpt();
        }
        else
        #endif
        {
        CM_MSG_HIGH_0("IGNORING MODEM_RESET_TIMER_RPT. Modem Reset not enabled");
        }
    }
    break;
    #endif
    
    case CM_AUTO_REG_TIMER_RPT:
    {
      if( cm_get_operator_info(ph_ptr->main_stack_info.asubs_id) == OPERATOR_CT)
      {
        /*Handling Auto Reg Timer expiry*/
        CM_MSG_HIGH_0("AUTO_REG_TIMER_RPT");
        handleAutoRegister(0);    // Sending invalid value 0 as this is not a Call Back
      }
      else
      {
        CM_MSG_HIGH_0("IGNORING AUTO_REG_TIMER_RPT: Operator CT not enabled");
      }
    }
    break;

    default:
      break;
  } /* switch hdr.cmd */
} /* cmph_generic_rpt_proc */

/*===========================================================================

FUNCTION cmph_is_hybr2_camped

DESCRIPTION
  Check if Hybrid2 stack is camped on service. This is currently used when
  evaluating if GWL avoidance timer needs to be extended on main stack. This
  is also applicable only to Nikel target as of now.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  TRUE: If service domain on Hybrid 2 stack is CAMPED.
  FALSE: otherwise.

SIDE EFFECTS
  none

===========================================================================*/
static boolean cmph_is_hybr2_camped(void)
{
  cmss_s_type           *ss_ptr = cmss_ptr();

  if ( sys_srv_status_is_srv( ss_ptr->hybr_gw_srv_status )  &&
       ss_ptr->info.gw_srv_domain == SYS_SRV_DOMAIN_CAMPED )
  {
    return TRUE;
  }

  return FALSE;
}

/*===========================================================================

FUNCTION cmph_timer_proc

DESCRIPTION
  Process timer events.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_timer_proc(

  cm_timer_event_type    timer_event
    /* Indicate specific timer event.
    **
    ** Note that currently timer event is not being used
    */
)
/*lint -esym(715,timer_event) */
{

  cmph_s_type           *ph_ptr = cmph_ptr();
      /* Point at phone object */

  dword                  uptime = time_get_uptime_secs();
      /* Get the current uptime */

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))

  db_items_value_type    db_item;
      /* Item to do db_get() and db_put() */
  #endif /* #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmph_err_fatal_if_ps_srv_domain_on_multiple_subs();

  #if (defined FEATURE_CM_LTE) && (defined FEATURE_HDR_HANDOFF)
  if(ph_ptr->shorten_bsr_timer != 0 && ph_ptr->shorten_bsr_timer <= uptime)
  {
     ph_ptr->is_shorten_bsr = FALSE;
     ph_ptr->shorten_bsr_timer = 0;
     CM_MSG_HIGH_0("short_bsr_timer expired");
  }
  #endif


  if( ph_ptr->is_standby_pref_buffered
    && (ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO ||
    ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY)
    #if defined(CM_GW_SUPPORTED) || defined (FEATURE_CM_LTE)
    && !(mm_per_stacks_is_mt_page_in_progress(SYS_MODEM_AS_ID_1, SYS_MODEM_STACK_ID_1) ||
      mm_per_stacks_is_mt_page_in_progress(SYS_MODEM_AS_ID_2, SYS_MODEM_STACK_ID_1)
      #ifdef FEATURE_MMODE_TRIPLE_SIM
      || mm_per_stacks_is_mt_page_in_progress(SYS_MODEM_AS_ID_3, SYS_MODEM_STACK_ID_1)
      #endif
      )
      #endif
    )
  {
    if(cmcall_is_there_a_call_type(CM_SS_MAX,
         CM_CALL_TYPE_VOICE, CM_CALL_ID_INVALID)== CM_CALL_ID_INVALID
       &&cmcall_is_there_a_call_type(CM_SS_MAX,
         CM_CALL_TYPE_EMERGENCY, CM_CALL_ID_INVALID)== CM_CALL_ID_INVALID)
    {
      cm_ph_cmd_dual_standby_pref( NULL,
                                   NULL,
                                   CM_CLIENT_ID_ANONYMOUS,
                                   ph_ptr->user_standby_pref,
                                   SYS_MODEM_AS_ID_NO_CHANGE,
                                   SYS_MODEM_AS_ID_NO_CHANGE,
                                   SYS_MODEM_AS_ID_NO_CHANGE,
                                   SYS_MODEM_AS_ID_NO_CHANGE,
                                   DDS_CAUSE_PERMANENT);
     
      ph_ptr->is_standby_pref_buffered = FALSE;

    }
  }

  /*
  ** If we receive PS Singaling down indication before timer
  ** expiry, we will stop the timer.
  **
  ** If the timer expires, we will stop waiting for the
  ** PS signaling down indication.
  **
  ** We can make the GW Pkt call only if we are not waiting
  ** for the Signaling down indicaiton.
  */

  if(ph_ptr->ps_signaling_down_wait_time != CMPH_GW_PKT_WAIT_TIME_NONE
      && ph_ptr->ps_signaling_down_wait_time <= uptime)
  {
    cmph_set_ps_sig_down_wait_time(CMPH_GW_PKT_WAIT_TIME_NONE, CM_SS_MAIN);
  }

  if(ph_ptr->hybr_2_stack_info.ps_signaling_down_wait_time != CMPH_GW_PKT_WAIT_TIME_NONE
     && (ph_ptr->hybr_2_stack_info.ps_signaling_down_wait_time <= uptime &&
     cmph_is_msim() && !cmph_is_sxlte()))
  {
    cmph_set_ps_sig_down_wait_time(CMPH_GW_PKT_WAIT_TIME_NONE, CM_SS_HYBR_2);
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  if(ph_ptr->hybr_3_stack_info.ps_signaling_down_wait_time != CMPH_GW_PKT_WAIT_TIME_NONE
     && ph_ptr->hybr_3_stack_info.ps_signaling_down_wait_time <= uptime
     && cmph_is_msim())
  {
    cmph_set_ps_sig_down_wait_time(CMPH_GW_PKT_WAIT_TIME_NONE, CM_SS_HYBR_3);
  }
  #endif

  /*
  ** If the PS service request timer expired, then notify the client(s)
  ** that the PS attach failed./
  */
  if ( ( ph_ptr->ps_service_req_timer_active    ) &&
       ( uptime > ph_ptr->ps_service_req_uptime )    )
  {
    CM_MSG_HIGH_1("PS service request timer expired, domain pref %d",
                CMPH_SS_SRV_DOMAIN_PREF(cmph_map_cm_ss_to_subs(CM_SS_MAIN),ph_ptr) );
    if( CMPH_SS_SRV_DOMAIN_PREF(cmph_map_cm_ss_to_subs(CM_SS_MAIN),ph_ptr)
             == CM_SRV_DOMAIN_PREF_CS_ONLY ||
        CMPH_SS_SRV_DOMAIN_PREF(cmph_map_cm_ss_to_subs(CM_SS_MAIN),ph_ptr)
             == CM_SRV_DOMAIN_PREF_NONE )
    {
      //Wait for CM_ATTACH_FAILED_IND from NAS
      cmph_deactivate_ps_service_req_timer(CM_SS_MAIN);
    }
    else
    {
      cmph_event_per_subs(ph_ptr, CM_PH_EVENT_PS_ATTACH_FAILED, CM_SS_MAIN );
      cmph_deactivate_ps_service_req_timer(CM_SS_MAIN);
    }
  }

  if ( ( ph_ptr->hybr_2_stack_info.ps_service_req_timer_active    ) &&
       ( uptime > ph_ptr->hybr_2_stack_info.ps_service_req_uptime )  &&
        cmph_is_msim() && !cmph_is_sxlte())
  {
    CM_MSG_HIGH_1("PS service request timer expired, hybr2 domain pref %d",
                CMPH_SS_SRV_DOMAIN_PREF(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2),ph_ptr) );

    if( CMPH_SS_SRV_DOMAIN_PREF(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2),ph_ptr)
             == CM_SRV_DOMAIN_PREF_CS_ONLY ||
        CMPH_SS_SRV_DOMAIN_PREF(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2),ph_ptr)
             == CM_SRV_DOMAIN_PREF_NONE )
    {
      //Wait for CM_ATTACH_FAILED_IND from NAS
      cmph_deactivate_ps_service_req_timer(CM_SS_HYBR_2);
    }
    else
    {
      cmph_event_per_subs(ph_ptr, CM_PH_EVENT_PS_ATTACH_FAILED, CM_SS_HYBR_2 );
      cmph_deactivate_ps_service_req_timer(CM_SS_HYBR_2);
    }
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  if ( ( ph_ptr->hybr_3_stack_info.ps_service_req_timer_active    ) &&
       ( uptime > ph_ptr->hybr_3_stack_info.ps_service_req_uptime ) &&
         cmph_is_msim())
  {
    CM_MSG_HIGH_1("PS service request timer expired, hybr3 domain pref %d",
                CMPH_SS_SRV_DOMAIN_PREF(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2),ph_ptr) );

    if( CMPH_SS_SRV_DOMAIN_PREF(cmph_map_cm_ss_to_subs(CM_SS_HYBR_3),ph_ptr) == CM_SRV_DOMAIN_PREF_CS_ONLY ||
        CMPH_SS_SRV_DOMAIN_PREF(cmph_map_cm_ss_to_subs(CM_SS_HYBR_3),ph_ptr) == CM_SRV_DOMAIN_PREF_NONE )
    {
      //Wait for CM_ATTACH_FAILED_IND from NAS
      cmph_deactivate_ps_service_req_timer(CM_SS_HYBR_3);
    }
    else
    {
      cmph_event_per_subs(ph_ptr, CM_PH_EVENT_PS_ATTACH_FAILED, CM_SS_HYBR_3 );
      cmph_deactivate_ps_service_req_timer(CM_SS_HYBR_3);
    }
  }
  #endif


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_HICPS_STACK_SYNC_UP
  /* If GW avoidance timer has expired and Hybrid stack is idle, restore the
  ** GW mode preference to main stack as per HICPS.
  */
  if ( ( ph_ptr->hicps_gwl_avoid_timer_active )    &&
       ( uptime > ph_ptr->hicps_gwl_avoid_uptime )
     )
  {
    /* If there is no traffic on HDR and
    ** there is no connection set up over LTE, proceed to scan for GW
    */
    if( !ph_ptr->is_hdr_activity &&
         (!cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)
                      ||
         (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
          cmregprx_misc_is_gw_resel_ok(SD_SS_HYBR_2) &&
          !cmph_is_hybr2_camped()))
      )
    {
      /* Restore GWL to mode preference if GWL had been removed due to
      ** HICPS and SD is no longer doing more preferred acquisition
      */
      (void)cmmsc_auto_update_gwl_operation(TRUE,
                                             SD_SS_PREF_REAS_STACK_SYNC_UP,
                                             CM_MODE_PREF_GWL,
                                             FALSE,
                                             SYS_MODEM_AS_ID_1);
    }
    else
    {
      CM_MSG_HIGH_1("HICPS: HDR active extending GW avoidance timer %ds",
                  cm_gwl_avoidance_timers.cmph_gwl_avoid_exten_value);
      ph_ptr->hicps_gwl_avoid_uptime = time_get_uptime_secs() +
                           cm_gwl_avoidance_timers.cmph_gwl_avoid_exten_value;
    }
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))

  /* If answer voice setting is temporary, check whether the answer
  ** duration expired, in which case we need to restore the normal
  ** CM_ANSWER_VOICE_AS_VOICE setting and notify clients of event.
  **
  ** Note that we also update the answer-voice setting in the database
  ** to reflect this setting since MC consults it upon receiving a page.
  */

  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( ph_ptr->answer_voice == CM_ANSWER_VOICE_AS_FAX_ONCE ||
      ph_ptr->answer_voice == CM_ANSWER_VOICE_AS_MODEM_ONCE )
  {
    if( uptime > ph_ptr->answer_uptime )
    {
      ph_ptr->answer_voice      = CM_ANSWER_VOICE_AS_VOICE;
      db_item.voice_as_data  = DB_VOICE_AS_DATA_NEVER;
      db_put( DB_VOICE_AS_DATA, &db_item );
      cmph_event( ph_ptr, CM_PH_EVENT_ANSWER_VOICE );
    }
  }
  #endif /* #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */


  if (ph_ptr->oprt_mode_send_time  <= time_get_uptime_secs())
  {
    CM_MSG_HIGH_3("oprt_mode_hold timer expired, send oprt mode to MMOC, send_time %d, uptime %d, curr_oprt_mode %d",
                  ph_ptr->oprt_mode_send_time,
                  time_get_uptime_secs(), ph_ptr->oprt_mode);
    cmph_send_oprt_mode_online_to_mmoc();
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we are waiting too long on a reply from MC, end the
  ** waiting period by forcing a MC reply with an error
  ** code indicating on a MC communication problems.
  */
  if( cm_reply_too_long(&ph_ptr->reply) )
  {
    /* Point at client command waiting for reply
    */
      cm_ph_cmd_s_type  *reply_cmd_ptr = (cm_ph_cmd_s_type*)cm_reply_get(&ph_ptr->reply);
      CM_ASSERT( reply_cmd_ptr != NULL );
      CM_ASSERT( CMD_TYPE(reply_cmd_ptr) == CM_CMD_TYPE_PH);

      /* Check if this report is specific to IP app deregistration
      ** and call forward_mm_ll() followed by mmll_reply()
      */
#if defined(FEATURE_IP_CALL)
      if (ph_ptr->reply.cm_mc_rpt == CM_IP_APP_ALLAPPS_SRV_DOM_CNF)
      {
        /* Since timeout is kicking in before all
        ** apps have responded, clear transaction
        ** ids
        */
        cmipapp_reset_trans_id ();

        if (cmph_client_cmd_forward_mmll (ph_ptr, reply_cmd_ptr))
        {
          CM_MSG_MED_0 ("Wait for reply is TRUE");
        }

        if( cm_reply_is_waiting(&ph_ptr->reply) )
        {
          CM_MSG_MED_1( "Waiting for reply : %d",ph_ptr->reply.cm_mc_rpt);
          return;
      }
      }
#endif //FEATURE_IP_CALL



      if (ph_ptr->reply.cm_mc_rpt == CM_ABORT_CC_CONF)
      {
        /* Since timeout is kicking in before NAS
        ** has responded, clear transaction
        ** ids
        */
        CM_MSG_HIGH_0( "ABORT_CNF timer expired. Proceeding with OPRT_MODE cmd" );

        if (cmph_client_cmd_forward_mmll (ph_ptr, reply_cmd_ptr))
        {
          CM_MSG_HIGH_0( "Wait for reply is TRUE" );
        }

        if( cm_reply_is_waiting(&ph_ptr->reply) )
        {
          return;
        }
      }

      if(ph_ptr->reply.cm_mc_rpt == CM_SRV_SYS_INFO_F)
      {
        if(cmph_client_cmd_forward_mmll (ph_ptr, reply_cmd_ptr))
        {
          CM_MSG_HIGH_0 ("CM_SRV_SYS_INFO_F Wait for reply is TRUE");
        }

        ph_ptr->is_wait_on_data_end = FALSE;

        if( cm_reply_is_waiting(&ph_ptr->reply) )
        {
          return;
        }
      }
      else if(ph_ptr->reply.cm_mc_rpt == CM_STANDBY_PREF_CHG_OK_F)
      {
        /*Reset the counter in CM */
        CM_MSG_HIGH_1 ("mcfg num_resp %d",ph_ptr->num_standby_requests_processing);
        ph_ptr->num_standby_requests_processing = 0;
      }
      /* Invoke the reply function with the appropriate error code.
      */
      cmph_client_cmd_mmll_reply( ph_ptr,
                                reply_cmd_ptr,
                                CM_PH_CMD_ERR_MC_COM_L );

      /* We are done with processing the command that was waiting
      ** for reply - deallocate its command buffer.
      */
      if (!reply_cmd_ptr->is_reused)
      {
        cm_cmd_dealloc( reply_cmd_ptr );
      }

      /* reset the reply info */
      cm_reply_init( &ph_ptr->reply );

      /* Turn on the signal that cause us to process any pending
      ** clients commands. This is necessary since we were NOT
      ** processing any clients commands while waiting on a reply
      ** from MC.
      */
      (void) rex_set_sigs( rex_self(), CM_CLIENT_CMD_Q_SIG );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we are waiting on a reply from MC, do NOT continue with the
  ** rest of this function. This is important because MC might not
  ** be able to process commands from CM at the moment.
  */
  if( cm_reply_is_waiting(&ph_ptr->reply) )
  {
    return;
  }

  /* If origination mode is still forced and it is time to consider unforcing
  ** the origination mode, do so.
  */

  /* Search all the origination mode queues and unforce the modes
  ** That needs to be unforced
  */
  /* if the network selection is ongoing then do not unforce the preferences */

  if(ph_ptr->main_stack_info.pref_info.network_type == CM_MODE_PREF_NONE)
  {
    sys_modem_as_id_e_type asubs_id = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2);

    cmph_check_and_unforce_orig_mode( CM_SS_MAIN );

    /* check if UE is in emergency call origination or emerg cb mode
    ** During emerg call, avoid unforcing prefs due to call end on hybr2 stack
    ** to avoid unnecessary indications to SD during this time frame.
    */
    if (!cmcall_emergency_call_active() &&
        ph_ptr->ph_state != CM_PH_STATE_EMERG_CB &&
        (cmph_is_subs_feature_mode_1x_sxlte(asubs_id) ||
         cmph_is_subs_feature_mode_sglte(asubs_id)))
    {
      cmph_check_and_unforce_orig_mode( CM_SS_HYBR_2 );
    }

  }

  cmph_check_and_unforce_orig_mode( CM_SS_HDR  );

  if((((cmph_is_dsds() || cmph_is_tsts()) &&
      ph_ptr->main_stack_info.pref_info.network_type == CM_MODE_PREF_NONE)
      #ifdef FEATURE_MMODE_DUAL_ACTIVE
      ||
      (cmph_is_dsda() &&
      ph_ptr->hybr_2_stack_info.pref_info.network_type == CM_MODE_PREF_NONE)
      #endif
      )  && !cmph_is_sxlte())
  {
    cmph_check_and_unforce_orig_mode( CM_SS_HYBR_2 );
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  if(((cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY || cmph_is_sxlte())
      && ph_ptr->main_stack_info.pref_info.network_type == CM_MODE_PREF_NONE))
  {
    cmph_check_and_unforce_orig_mode( CM_SS_HYBR_3 );
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If mode term is temporary, check whether we need to unforce
  ** the mode preference back to its persistent setting.
  */
  if(ph_ptr->main_stack_info.pref_info.network_type == CM_MODE_PREF_NONE)
  {
    if( ph_ptr->main_stack_info.pref_info.pref_term == CM_PREF_TERM_1_CALL_OR_TIME ||
        ph_ptr->main_stack_info.pref_info.pref_term == CM_PREF_TERM_CM_1_CALL_PLUS )
    {

      /* If mode duration expired and phone is not in-use,
      ** unforce the mode preference back to its persistent setting.
      */
      if( uptime >= ph_ptr->main_stack_info.pref_info.mode_uptime && ! ph_ptr->is_in_use )
      {
        /* Remember the current mode term.
        */
        cm_pref_term_e_type  pref_term = ph_ptr->main_stack_info.pref_info.pref_term;

        /* Unforce the mode back to it persistent setting,
        */
        (void) cmph_unforce_mode_on_the_fly( ph_ptr, CM_SS_MAIN );

        /* If we unforce the mode as a result of a client explicitly
        ** forcing the mode earlier, notify clients of event.
        */
        if( pref_term == CM_PREF_TERM_1_CALL_OR_TIME )
        {
          cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_MAIN );
        }
      }
    } /* if */
  }

  if(((cmph_is_dsds() || cmph_is_tsts())
      &&ph_ptr->main_stack_info.pref_info.network_type == CM_MODE_PREF_NONE)
      #ifdef FEATURE_MMODE_DUAL_ACTIVE
      ||(cmph_is_dsda()
      && ph_ptr->hybr_2_stack_info.pref_info.network_type == CM_MODE_PREF_NONE
      && !cmph_is_sxlte())
      #endif
    )
  {
    /* If mode term is temporary, check whether we need to unforce
       ** the mode preference back to its persistent setting.
      */
    if( ph_ptr->hybr_2_stack_info.pref_info.pref_term == CM_PREF_TERM_1_CALL_OR_TIME ||
        ph_ptr->hybr_2_stack_info.pref_info.pref_term == CM_PREF_TERM_CM_1_CALL_PLUS )
    {

      /* If mode duration expired and phone is not in-use,
      ** unforce the mode preference back to its persistent setting.
      */
    if(((cmph_is_dsds() || cmph_is_tsts())
       && uptime >= ph_ptr->main_stack_info.pref_info.mode_uptime && ! ph_ptr->is_in_use )
       #ifdef FEATURE_MMODE_DUAL_ACTIVE
       ||(cmph_is_dsda()
         && uptime >= ph_ptr->hybr_2_stack_info.pref_info.mode_uptime
       && ! ph_ptr->hybr2_is_in_use )
       #endif
       )
      {
        /* Remember the current mode term.
              */
        cm_pref_term_e_type pref_term =
                                ph_ptr->hybr_2_stack_info.pref_info.pref_term;

        /* Unforce the mode back to it persistent setting,
              */
        (void) cmph_unforce_mode_on_the_fly( ph_ptr, CM_SS_HYBR_2 );

        /* If we unforce the mode as a result of a client explicitly
              ** forcing the mode earlier, notify clients of event.
              */
        if( pref_term == CM_PREF_TERM_1_CALL_OR_TIME )
        {
          cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_HYBR_2 );
        }
      }
    }
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  if(
      ((cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY || cmph_is_sxlte())
      && ph_ptr->main_stack_info.pref_info.network_type == CM_MODE_PREF_NONE)
    )
  {
    /* If mode term is temporary, check whether we need to unforce
       ** the mode preference back to its persistent setting.
      */
    if( ph_ptr->hybr_3_stack_info.pref_info.pref_term == CM_PREF_TERM_1_CALL_OR_TIME ||
        ph_ptr->hybr_3_stack_info.pref_info.pref_term == CM_PREF_TERM_CM_1_CALL_PLUS )
    {

      /* If mode duration expired and phone is not in-use,
      ** unforce the mode preference back to its persistent setting.
      */
      if(uptime >= ph_ptr->main_stack_info.pref_info.mode_uptime && ! ph_ptr->is_in_use )
      {
      /* Remember the current mode term.
      */
        cm_pref_term_e_type pref_term =
                                ph_ptr->hybr_3_stack_info.pref_info.pref_term;

      /* Unforce the mode back to it persistent setting,
      */
      (void) cmph_unforce_mode_on_the_fly( ph_ptr, CM_SS_HYBR_3 );

      /* If we unforce the mode as a result of a client explicitly
      ** forcing the mode earlier, notify clients of event.
      */
      if( pref_term == CM_PREF_TERM_1_CALL_OR_TIME )
      {
        cmph_event_per_subs( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF, CM_SS_HYBR_3 );
      }
    }
  }
  }
  #endif


} /* cmph_timer_proc() */

/*lint +esym(715,timer_event) */



/*===========================================================================

FUNCTION cmph_get_curr_nam

DESCRIPTION
  Get the current NAM.

DEPENDENCIES
  Phone object must be initialized.

RETURNS
  The current NAM. If phone was not yet initialized, return CM_NAM_NONE.

SIDE EFFECTS
  None

===========================================================================*/
cm_nam_e_type  cmph_get_curr_nam( void )
{
  cmph_s_type    *ph_ptr  =  cmph_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Make sure object was properly initialized.
  */
  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( CM_INIT_CHECK(ph_ptr->init_mask) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( CM_INIT_CHECK(ph_ptr->init_mask) )
  {
    return ph_ptr->curr_nam;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return CM_NAM_NONE;

} /* cmph_get_curr_nam() */



/*===========================================================================

FUNCTION cmph_autonam_is_enabled

DESCRIPTION
  Check whether auto-NAM is currently enabled.

DEPENDENCIES
  Phone object must be initialized

RETURNS
  TRUE if auto NAM is enabled. FALSE otherwise.

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_autonam_is_enabled( void )
{
  cmph_s_type    *ph_ptr  =  cmph_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Make sure object was properly initialized.
  */
  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( CM_INIT_CHECK(ph_ptr->init_mask) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If phone object was initialized and nam_sel = CM_NAM_AUTO, return TRUE.
  ** Else, return FALSE.
  */
  if( CM_INIT_CHECK(ph_ptr->init_mask) &&
      ph_ptr->nam_sel == CM_NAM_AUTO )
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* cmph_autonam_is_enabled() */



/*===========================================================================
FUNCTION CMPH_OFFLINE

DESCRIPTION
  This function performs offline processing for the phone object

DEPENDENCIES
  Phone object must be initialized

RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_offline (void)
{
  cmlog_set_cm_offline_signal_recvd();
} /* cmph_offline() */


/*===========================================================================

FUNCTION cmph_orig_mode_reset

DESCRIPTION
  Reset the origination mode to none.
  Exit emergency callback mode.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void cmph_orig_mode_reset(

    cmph_s_type             *ph_ptr,
        /* Pointer to a phone object */

    boolean                  force_top
        /* Force the top preferences */
)
{

  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit emergency callback mode
  */
  cmph_exit_emergency_cb(ph_ptr, FALSE,CM_SS_MAIN,FALSE);

  cmph_orig_mode_reset_on_ss( ph_ptr, CM_SS_MAIN, force_top, CM_DEFAULT_VALUE);
  if (cmph_is_msim())
  {
    cmph_orig_mode_reset_on_ss( ph_ptr, CM_SS_HYBR_2, force_top, CM_DEFAULT_VALUE );
  }
  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  cmph_orig_mode_reset_on_ss( ph_ptr, CM_SS_HYBR_3, force_top, CM_DEFAULT_VALUE );
  #endif
  cmph_orig_mode_reset_on_ss( ph_ptr, CM_SS_HDR, force_top, CM_DEFAULT_VALUE );


} /* cmph_orig_mode_reset() */



/*===========================================================================

FUNCTION cmph_map_cm_ss_type_to_sd_ss_type

DESCRIPTION
  Maps cm_ss_e_type to sd_ss_e_type

DEPENDENCIES
  None

RETURN VALUE
  The sd_ss_e_type

SIDE EFFECTS
  None.

NOTE:

===========================================================================*/

sd_ss_e_type cmph_map_cm_ss_type_to_sd_ss_type(

  cm_ss_e_type cm_ss
    /* cm_ss_e_type */
)
{
  switch( cm_ss )
  {
    case CM_SS_MAIN:
      return( SD_SS_MAIN );

    case CM_SS_HYBR_2:
      return( SD_SS_HYBR_2 );

    case CM_SS_HYBR_3:
      return( SD_SS_HYBR_3 );

    case CM_SS_HDR:
      return( SD_SS_HYBR_HDR );

    case CM_SS_MAX:
      return( SD_SS_MAX );

    default:
      CM_ERR_1( "ss %d", (uint8) cm_ss);
      /*
      ** 527: Unreachable
      ** This is because CM_ERR() evaluates to error fatal
      ** (i.e exit program)
      ** But for different feature set it may not to, so we want to
      ** supress the warning here
      */
      /*lint -e527 */
      return( SD_SS_MAIN );
  }
} /* cmph_map_cm_ss_type_to_sd_ss_type */



/*===========================================================================

FUNCTION cmph_map_sd_ss_type_to_cm_ss_type

DESCRIPTION
  Maps sd_ss_e_type to cm_ss_e_type

DEPENDENCIES
  None

RETURN VALUE
  The cm_ss_e_type

SIDE EFFECTS
  None.

NOTE:

===========================================================================*/

cm_ss_e_type cmph_map_sd_ss_type_to_cm_ss_type(

  sd_ss_e_type sd_ss

)
{
  switch( sd_ss )
  {
    case SD_SS_MAIN:
      return( CM_SS_MAIN );

    case SD_SS_HYBR_2:
      return( CM_SS_HYBR_2 );

    case SD_SS_HYBR_3:
      return( CM_SS_HYBR_3 );

    case SD_SS_HYBR_HDR:
      return( CM_SS_HDR );


    case SD_SS_MAX:
      return( CM_SS_MAX );

    default:
      CM_ERR_1( "ss %d",(uint8) sd_ss);
      /*
      ** 527: Unreachable
      ** This is because CM_ERR() evaluates to error fatal
      ** (i.e exit program)
      ** But for different feature set it may not to, so we want to
      ** supress the warning here
      */
      /*lint -e527 */
      return( CM_SS_NONE );
  }
} /* cmph_map_sd_ss_type_to_cm_ss_type */


/*===========================================================================

FUNCTION cmph_map_cm_prl_pref_to_sd_prl_pref_e_type

DESCRIPTION
  Maps cm_prl_pref to sd_ss_prl_pref_e_type

DEPENDENCIES
  None

RETURN VALUE
  The sd_ss_prl_pref_e_type

SIDE EFFECTS
  None.

NOTE:

===========================================================================*/

sd_ss_prl_pref_e_type cmph_map_cm_prl_pref_to_sd_prl_pref(

  cm_prl_pref_e_type cm_prl_pref
    /* cm prl pref */
)
{

  switch( cm_prl_pref )
  {
    case CM_PRL_PREF_AVAIL_BC0_A:
      return( SD_SS_PRL_PREF_AVAIL_BC0_A );

    case CM_PRL_PREF_AVAIL_BC0_B:
      return( SD_SS_PRL_PREF_AVAIL_BC0_B );

    case CM_PRL_PREF_ANY:
      return( SD_SS_PRL_PREF_ANY );

    default:
      //CM_ERR_1( "cm_prl_pref %d", (uint8) cm_prl_pref);
      /*
      ** 527: Unreachable
      ** This is because CM_ERR() evaluates to error fatal
      ** (i.e exit program)
      ** But for different feature set it may not to, so we want to
      ** supress the warning here
      */
      /*lint -e527 */
      return( SD_SS_PRL_PREF_NONE );
  }

} /* cmph_map_cm_prl_pref_to_sd_prl_pref */


/*===========================================================================

FUNCTION cmph_map_sd_prl_pref_to_cm_prl_pref

DESCRIPTION
  Maps sd_ss_prl_pref_e_type to cm_prl_pref_e_type

DEPENDENCIES
  None

RETURN VALUE
  The sd_ss_prl_pref_e_type

SIDE EFFECTS
  None.

NOTE:

===========================================================================*/

cm_prl_pref_e_type cmph_map_sd_prl_pref_to_cm_prl_pref(

  sd_ss_prl_pref_e_type sd_prl_pref
    /* sd prl pref */
)
{

  switch( sd_prl_pref )
  {
    case SD_SS_PRL_PREF_AVAIL_BC0_A :
      return( CM_PRL_PREF_AVAIL_BC0_A );

    case SD_SS_PRL_PREF_AVAIL_BC0_B :
      return( CM_PRL_PREF_AVAIL_BC0_B );

    case SD_SS_PRL_PREF_ANY :
      return( CM_PRL_PREF_ANY );

    default:
      CM_ERR_1( "sd_ss_prl_pref %d", (uint8) sd_prl_pref);
      /*
      ** 527: Unreachable
      ** This is because CM_ERR() evaluates to error fatal
      ** (i.e exit program)
      ** But for different feature set it may not to, so we want to
      ** supress the warning here
      */
      /*lint -e527 */
      return( CM_PRL_PREF_NONE );
  }

} /* cmph_map_sd_prl_pref_to_cm_prl_pref */


/*===========================================================================

FUNCTION cmph_map_cm_roam_pref_to_sd_roam_pref

DESCRIPTION
  Maps cm_roam_pref to sd_roam_pref

DEPENDENCIES
  None

RETURN VALUE
  The sd_ss_roam_pref_e_type

SIDE EFFECTS
  None.

NOTE:

===========================================================================*/

sd_ss_roam_pref_e_type cmph_map_cm_roam_pref_to_sd_roam_pref(

  cm_roam_pref_e_type cm_roam_pref
    /* cm_roam_pref */
)
{

  switch( cm_roam_pref )
  {
    case CM_ROAM_PREF_HOME:
      return( SD_SS_ROAM_PREF_HOME );

    case CM_ROAM_PREF_ROAM_ONLY:
      return(SD_SS_ROAM_PREF_ROAM_ONLY);

    case CM_ROAM_PREF_AFFIL:
      return( SD_SS_ROAM_PREF_AFFIL );

    case CM_ROAM_PREF_ANY:
      return( SD_SS_ROAM_PREF_ANY );

    default:
      CM_ERR_1( "cm_roam_pref %d", (uint8) cm_roam_pref);
      /*
      ** 527: Unreachable
      ** This is because CM_ERR() evaluates to error fatal
      ** (i.e exit program)
      ** But for different feature set it may not to, so we want to
      ** supress the warning here
      */
      /*lint -e527 */
      return( SD_SS_ROAM_PREF_AFFIL );
  }

} /* cmph_map_cm_roam_pref_to_sd_roam_pref */


/*===========================================================================

FUNCTION cmph_map_sd_roam_pref_to_cm_roam_pref

DESCRIPTION
  Maps sd_ss_roam_pref_e_type to cm_roam_pref

DEPENDENCIES
  None

RETURN VALUE
  The cm_roam_pref

SIDE EFFECTS
  None.

NOTE:

===========================================================================*/

cm_roam_pref_e_type cmph_map_sd_roam_pref_to_cm_roam_pref(

   sd_ss_roam_pref_e_type  sd_roam_pref
    /* sd_roam_pref */
)
{

  switch( sd_roam_pref )
  {
    case SD_SS_ROAM_PREF_HOME:
      return( CM_ROAM_PREF_HOME );

    case SD_SS_ROAM_PREF_ROAM_ONLY:
      return (CM_ROAM_PREF_ROAM_ONLY);

    case SD_SS_ROAM_PREF_AFFIL:
      return( CM_ROAM_PREF_AFFIL );

    case SD_SS_ROAM_PREF_ANY:
      return( CM_ROAM_PREF_ANY );

    default:
      CM_ERR_1( "sd_ss_roam_pref %d", (uint8) sd_roam_pref);
      /*
      ** 527: Unreachable
      ** This is because CM_ERR() evaluates to error fatal
      ** (i.e exit program)
      ** But for different feature set it may not to, so we want to
      ** supress the warning here
      */
      /*lint -e527 */
      return( CM_ROAM_PREF_NONE );
  }

} /* cmph_map_sd_roam_pref_to_cm_roam_pref */


/*===========================================================================

FUNCTION cmph_map_call_type_to_act_type

DESCRIPTION
  Maps the call_type to activity type

DEPENDENCIES
  None

RETURN VALUE
  The activity type cm_act_type_e_type

SIDE EFFECTS
  None.

===========================================================================*/

cm_act_type_e_type cmph_map_call_type_to_act_type(

  cm_call_type_e_type call_type
    /* Call Type */

)
{

  switch(call_type)
  {

    case CM_CALL_TYPE_VOICE:
      return( CM_ACT_TYPE_VOICE_CALL );

    case CM_CALL_TYPE_CS_DATA:
      #if defined (FEATURE_3GPP_CSFB)
    if (cmcall_is_there_csfb_call(CM_SS_MAX,
          CM_CALL_CSFB_TYPE_PPCSFB,CM_CALL_ID_INVALID)!=CM_CALL_ID_INVALID)
      {
        return( CM_ACT_TYPE_CS_DATA_CALL);
      }
      else
      #endif
      {
        return( CM_ACT_TYPE_DATA_CALL );
      }

    case CM_CALL_TYPE_PS_DATA:
    /* Videoshare call is very similar to VideoTelephony
    ** call and so grouping it with CALL_TYPE_CS_DATA
    */
    case CM_CALL_TYPE_VS:
      return( CM_ACT_TYPE_DATA_CALL );

    case CM_CALL_TYPE_SMS:
      return( CM_ACT_TYPE_SMS_CALL );

    case CM_CALL_TYPE_OTAPA:
      return( CM_ACT_TYPE_OTAPA_CALL );

    case CM_CALL_TYPE_STD_OTASP:
      return( CM_ACT_TYPE_STD_OTASP );

    case CM_CALL_TYPE_NON_STD_OTASP:
      return( CM_ACT_TYPE_NON_STD_OTASP );

    case CM_CALL_TYPE_EMERGENCY:
      return( CM_ACT_TYPE_EMERG_CALL );

    case CM_CALL_TYPE_TEST:
      return (CM_ACT_TYPE_TEST_CALL);

    case CM_CALL_TYPE_VT:
      return (CM_ACT_TYPE_VT_CALL);

    case CM_CALL_TYPE_VT_LOOPBACK:
      return (CM_ACT_TYPE_VT_LOOPBACK);

    case CM_CALL_TYPE_PD:
      return (CM_ACT_TYPE_PD_CALL);

    case CM_CALL_TYPE_SUPS:
    default:
      return( CM_ACT_TYPE_DEFAULT_CALL );

  }/* switch(call_type) */
} /* cmph_map_call_type_to_act_type */

/*===========================================================================

FUNCTION cmph_map_subs_to_ss

DESCRIPTION
  Maps the ausbs_id to cm_ss

DEPENDENCIES
  None

RETURN VALUE
  The activity type cm_act_type_e_type

SIDE EFFECTS
  None.

===========================================================================*/

cm_ss_e_type cmph_map_subs_to_ss(

  sys_modem_as_id_e_type       asubs_id
    /* Call Type */

)
{
  cmph_s_type             *ph_ptr       = cmph_ptr();
      /* Point at phone object */

  /* always maps to cm_ss_main if non multi-sim */
  if (cmph_is_ssim())
  {
    return CM_SS_MAIN;
  }

  /* If the phone is not Online, Send the default values.
  ** (or) NONE is sent, then which ever is available.
  */
  if( ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE )
  {
    if( asubs_id == SYS_MODEM_AS_ID_2 )
    {
      if (cmph_is_sxlte())
        return CM_SS_HYBR_3;
      else
        return CM_SS_HYBR_2;
    }
    else if( asubs_id == SYS_MODEM_AS_ID_3 )
    {
      return CM_SS_HYBR_3;
    }
    else
    {
      return CM_SS_MAIN;
    }
  }

  if( asubs_id == SYS_MODEM_AS_ID_NONE )
  {
    if( ph_ptr->main_stack_info.asubs_id != asubs_id )
    {
      return CM_SS_MAIN;
    }
    else if ( ph_ptr->hybr_2_stack_info.asubs_id != asubs_id && !cmph_is_sxlte())
    {
      return CM_SS_HYBR_2;
    }
    #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
    else if ( ph_ptr->hybr_3_stack_info.asubs_id != asubs_id)
    {
      return CM_SS_HYBR_3;
    }
    #endif
    else
    {
      CM_ERR_0("All stacks are not active");
      return CM_SS_MAIN;
    }
  }

  /* Without stack id, provide stack 1 SS for this subs */
  return cmph_map_subs_stack_to_ss( asubs_id,0);
}

/*===========================================================================

FUNCTION cmph_map_subs_stack_to_ss

DESCRIPTION
  Maps the ausbs_id to cm_ss

DEPENDENCIES
  None

RETURN VALUE
  The activity type cm_act_type_e_type

SIDE EFFECTS
  None.

===========================================================================*/

cm_ss_e_type cmph_map_subs_stack_to_ss(

  sys_modem_as_id_e_type       asubs_id,
    /* Call Type */

  uint8 stack_id

)
{
  cmph_s_type             *ph_ptr       = cmph_ptr();
      /* Point at phone object */

  if(asubs_id >= MAX_AS_IDS || stack_id >= MAX_STACK_PER_SUB || asubs_id <= SYS_MODEM_AS_ID_NONE)
  {
    //CM_ERR_2("asubs id / stack id overflow",asubs_id,stack_id);
    return CM_SS_MAIN;
  }

  if(cmph_get_feature_mode() == SYS_OVERALL_FEATURE_MODE_SGLTE)
  {
    if(stack_id == 0)
      return CM_SS_MAIN;
    else
      return CM_SS_HYBR_2;
  }


    /* always maps to cm_ss_main if non multi-sim */
  /*
  if (cmph_is_ssim())
  {
    return CM_SS_MAIN;
  }*/

  #if defined(FEATURE_MMODE_TRIPLE_SIM)
  if(asubs_id == SYS_MODEM_AS_ID_3)
  {
    return ph_ptr->subs_stack_map[asubs_id][stack_id];
  }
  #endif
  if( (asubs_id == SYS_MODEM_AS_ID_1) ||(asubs_id == SYS_MODEM_AS_ID_2))
  {
    return ph_ptr->subs_stack_map[asubs_id][stack_id];
  }
  else
  {
    return ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][stack_id];
  }
}


/*===========================================================================

FUNCTION cmph_get_act_priority

DESCRIPTION
  Maps the act_type to act_priority

DEPENDENCIES
  None

RETURN VALUE
  The activity type cm_act_type_e_type

SIDE EFFECTS
  None.

===========================================================================*/

cm_act_priority_e_type cmph_get_act_priority(

  cm_act_type_e_type act_type
    /* Activity Type */

)
{
  switch(act_type)
  {

    case CM_ACT_TYPE_EMERG_CALL:
      return( CM_ACT_PRIORITY_0 );

    case CM_ACT_TYPE_EMERG_CB_MODE:
      return( CM_ACT_PRIORITY_10 );

    case CM_ACT_TYPE_AC_EMERG_MODE:
      return( CM_ACT_PRIORITY_11 );

   case CM_ACT_TYPE_POLICYMAN_RESTRICT:
     return( CM_ACT_PRIORITY_19 );

    case CM_ACT_TYPE_TEST_CALL:
      return( CM_ACT_PRIORITY_20 );

    case CM_ACT_TYPE_VOICE_CALL:
      return( CM_ACT_PRIORITY_30 );

    case CM_ACT_TYPE_VT_LOOPBACK:
      return( CM_ACT_PRIORITY_40 );

    case CM_ACT_TYPE_VT_CALL:
      return( CM_ACT_PRIORITY_50 );

    case CM_ACT_TYPE_PD_CALL:
      return( CM_ACT_PRIORITY_60 );

    case CM_ACT_TYPE_SMS_CALL:
      return( CM_ACT_PRIORITY_70 );

    #if defined (FEATURE_3GPP_CSFB)
    case CM_ACT_TYPE_CS_DATA_CALL:
    #endif
    case CM_ACT_TYPE_DATA_CALL:
      return( CM_ACT_PRIORITY_80 );

    case CM_ACT_TYPE_OTAPA_CALL:
      return( CM_ACT_PRIORITY_90 );

    case CM_ACT_TYPE_STD_OTASP:
    case CM_ACT_TYPE_NON_STD_OTASP:
      return( CM_ACT_PRIORITY_100 );

    case CM_ACT_TYPE_DBM:
      return( CM_ACT_PRIORITY_110 );

    case CM_ACT_TYPE_GPS:
      return( CM_ACT_PRIORITY_120 );

    case CM_ACT_TYPE_DEFAULT_CALL:
      return( CM_ACT_PRIORITY_200 );

    case CM_ACT_TYPE_NONE:
    case CM_ACT_TYPE_PH_OBJ:
      return( CM_ACT_PRIORITY_PH );

    default:
      return( CM_ACT_PRIORITY_MAX );

  }/* switch(call_type) */

} /* cmph_map_act_type_act_priority */

/*===========================================================================

FUNCTION cmph_cmp_act_priorities

DESCRIPTION
  Compares the act_priorities

DEPENDENCIES


RETURN VALUE
  -ve if act_priority_1 <  act_priority_2
   0  if act_priority_1 == act_priority_2
  +ve if act_priority_1 >  act_priority_2

SIDE EFFECTS
  None.

===========================================================================*/

int cmph_cmp_act_priorities(

  cm_act_priority_e_type act_priority_1,
    /* 1st activity's priority */

  cm_act_priority_e_type act_priority_2
    /* 2nd activity's priority */
)
{
  return( act_priority_2 - act_priority_1 ); /*lint !e641 !e656 */

}/* cmph_cmp_act_priorities */


/*===========================================================================

FUNCTION cmph_insert_orig_mode

DESCRIPTION
  Inserts the origination parameters in the priority queue.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
 TRUE If the top pointer changed
 FALSE Otherwise

SIDE EFFECTS
  None.

===========================================================================*/

boolean cmph_insert_orig_mode(

  cm_ss_e_type              ss,
    /* SS to use for origination, if hybrid operation is changed,
    ** then ss= SD_SS_MAX.
    */

  sd_ss_orig_mode_e_type    orig_mode,
      /* Origination Mode */

  cm_act_type_e_type        act_type,
        /* Type of CM activity */

  cm_pref_term_e_type       force_term,
      /* Term for which to force the preferences - one-call, etc. */

  cm_mode_pref_e_type       mode_pref,
      /* Mode preference which to force */

  cm_band_pref_e_type       band_pref,
      /* Band preference which to force */

  sys_lte_band_mask_e_type  lte_band_pref,
      /* LTE band preference which to force */

  cm_band_pref_e_type       tds_band_pref,
      /* TDS band preference which to force */

  cm_prl_pref_e_type        prl_pref,
      /* PRL preference which to force */

  cm_roam_pref_e_type       roam_pref,
      /* Roam preference which to force */

  cm_hybr_pref_e_type       hybr_pref,
      /* hybr preference which to force */

  sd_ss_hybr_pref_e_type    int_hybr_pref,
      /* Hybrid preferences used internally by CM */

  cm_srv_domain_pref_e_type srv_domain_pref,
     /* service domain preference to force */

  cm_act_id_type            act_id,
      /* The uniques id of the activity that is forcing the mode */

  cm_act_update_reas_e_type act_update_reas,
      /* Reason for the update */

  uint16                    req_id,
     /* Sys sel pref request id */

  sys_csg_id_type           csg_id,
     /**< CSG identifier */

  sys_radio_access_tech_e_type csg_rat
     /**< RAT specified for CSG */

)
{
  cm_orig_q_s_type  *ph_orig_ptr;
  /* Populate the queue structure and insert it in the priority queue
  */

  cm_orig_q_s_type  *ph_orig_top_ptr;
  cmph_s_type       *ph_ptr = cmph_ptr();

  boolean is_found           = FALSE;
  boolean is_top_ptr_changed = FALSE;
  cm_mode_pref_e_type original_mode_pref = CM_MODE_PREF_NONE;

  ph_orig_ptr = cmtask_orig_para_search_act_id( ss == CM_SS_MAX ? CM_SS_MAIN : ss, act_id );
  ph_orig_top_ptr = cmtask_orig_para_get_top( ss == CM_SS_MAX ? CM_SS_MAIN : ss );

  if(ph_orig_ptr == ph_orig_top_ptr)
  {
    is_top_ptr_changed = TRUE;
  }

  if( ph_orig_ptr != NULL )
  {
    is_found = TRUE;
  }

  switch ( ss )
  {
    case CM_SS_MAIN:
    case CM_SS_HDR:
    case CM_SS_HYBR_2:
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    case CM_SS_HYBR_3:
    #endif
      if(!is_found)
      {
        if ((ph_orig_ptr = cmtask_orig_para_alloc(ss)) ==
                                            (cm_orig_q_s_type *)NULL)
        {
          sys_err_fatal_null_ptr_exception();
           break;
        }
        /* first time allocation , reset to none */
        ph_orig_ptr->orig->pref_update_reason = SD_SS_PREF_UPDATE_REASON_NONE;
      }
      else
      {
         /* While silent -redial in progress. and if ph ptr mode preference change
         */
         if((ph_orig_ptr->orig->act_priority < CM_ACT_PRIORITY_PH) &&  //Conceptually if more priority
            (ph_orig_ptr->act_type != CM_ACT_TYPE_POLICYMAN_RESTRICT) &&
           (ph_orig_ptr->orig->act_priority != CM_ACT_PRIORITY_NONE))
         {
           original_mode_pref = ph_orig_ptr->orig->user_mode_pref;
           CM_MSG_HIGH_1( "backing up user mode pref for this act %d",original_mode_pref );
         }

         /* Delete it for now. We'll re-queue soon */
         (void)cmtask_orig_para_delete( ss, ph_orig_ptr, FALSE );
      }

      /* Asserts if mode than one active sub is multimode*/
      cmph_validate_multimode_pref(
                                   (ss==CM_SS_MAIN)?mode_pref:ph_ptr->main_stack_info.pref_info.mode_pref,
                                   (ss==CM_SS_HYBR_2)?mode_pref:ph_ptr->hybr_2_stack_info.pref_info.mode_pref,
                                    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
                                   (ss==CM_SS_HYBR_3)?mode_pref:ph_ptr->hybr_3_stack_info.pref_info.mode_pref
                                    #else
                                    CM_MODE_PREF_NONE
                                    #endif
                                   );
      /* Insert into the priority Queue
      */
      if( ph_orig_ptr != NULL )
      {
        ph_orig_ptr->act_type                   = act_type;
        ph_orig_ptr->orig->act_id               = act_id;
        ph_orig_ptr->orig->act_priority         = cmph_get_act_priority(  ph_orig_ptr->act_type );
        ph_orig_ptr->orig->orig_mode            = orig_mode;
        ph_orig_ptr->orig->orig_pref_term       = force_term;
        ph_orig_ptr->orig->orig_mode_pref       = mode_pref;
        ph_orig_ptr->orig->orig_band_pref       = band_pref;
        ph_orig_ptr->orig->orig_lte_band_pref   = lte_band_pref;
        ph_orig_ptr->orig->orig_tds_band_pref   = tds_band_pref;
        ph_orig_ptr->orig->orig_prl_pref        = prl_pref;
        ph_orig_ptr->orig->orig_roam_pref       = roam_pref;
        ph_orig_ptr->orig->orig_hybr_pref       = hybr_pref;
        ph_orig_ptr->orig->orig_int_hybr_pref   = int_hybr_pref;
        ph_orig_ptr->orig->orig_srv_domain_pref = srv_domain_pref;

        if(original_mode_pref != CM_MODE_PREF_NONE)
        {
          ph_orig_ptr->orig->user_mode_pref       = original_mode_pref;
        }
        else
        {
          switch(ss)
          {
            #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
            case CM_SS_HYBR_3:
              ph_orig_ptr->orig->user_mode_pref       = ph_ptr->hybr_3_stack_info.pref_info.mode_pref;
              break;
            #endif

            case CM_SS_HYBR_2:
              if(!(cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) || cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_2) ||
                cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)))
              {
                ph_orig_ptr->orig->user_mode_pref       = ph_ptr->hybr_2_stack_info.pref_info.mode_pref;
              }
              else
              {
                ph_orig_ptr->orig->user_mode_pref       = ph_ptr->main_stack_info.pref_info.mode_pref;
              }
              break;

            default:
              ph_orig_ptr->orig->user_mode_pref       = ph_ptr->main_stack_info.pref_info.mode_pref;
          }
        }
        ph_orig_ptr->orig->csg_id               = csg_id;
        ph_orig_ptr->orig->csg_rat              = csg_rat;



        if( act_update_reas != CM_ACT_UPDATE_REAS_ACT_CONT )
        {
          ph_orig_ptr->orig->act_update_reas      = act_update_reas;
          
          if((act_update_reas == CM_ACT_UPDATE_REAS_USER ||
              act_update_reas == CM_ACT_UPDATE_REAS_ACT_CONT )&&
              act_type == CM_ACT_TYPE_PH_OBJ )
          {
            ph_orig_ptr->orig->sys_sel_pref_req_id = req_id;
          }
          else
          {
            ph_orig_ptr->orig->sys_sel_pref_req_id = 0;
          }
        }

        if( act_update_reas != CM_ACT_UPDATE_REAS_ACT_END )
        {
          ph_orig_ptr->orig->orig_mode_uptime = CM_PH_ORIG_MODE_UPTIME_NONE;

        }

        if( force_term == CM_PREF_TERM_CM_MO_SMS )
        {
          ph_orig_ptr->orig->orig_mode_uptime =
                         time_get_uptime_secs() + CMPH_HOLD_MODE_PREF_TIME;

          CM_MSG_LOW_1("force MO SMS with uptime of %d",
                         ph_orig_ptr->orig->orig_mode_uptime);
        }


        /* Enqueue the orig
        ** onto the orig Q.
        */
        is_top_ptr_changed = cmtask_orig_para_insert( ss, ph_orig_ptr ) || is_top_ptr_changed;
       } /*  if( ph_orig_ptr != NULL ) */

      return( is_top_ptr_changed );

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_SS_MAX:

      is_top_ptr_changed = cmph_insert_orig_mode( CM_SS_MAIN,
                                                  orig_mode,
                                                  act_type,
                                                  force_term,
                                                  mode_pref,
                                                  band_pref,
                                                  lte_band_pref,
                                                  tds_band_pref,
                                                  prl_pref,
                                                  roam_pref,
                                                  hybr_pref,
                                                  int_hybr_pref,
                                                  srv_domain_pref,
                                                  act_id,
                                                  act_update_reas,
                                                  req_id,
                                                  csg_id,
                                                  csg_rat) || is_top_ptr_changed;
      /* Irrespective of input values for parameters csg_id and csg_rat,
         for HDR, the values passed are invalid ones. i.e. HDR does not support
         CSG as of now.
      */
      is_top_ptr_changed = cmph_insert_orig_mode( CM_SS_HDR,
                                                  orig_mode,
                                                  act_type,
                                                  force_term,
                                                  mode_pref,
                                                  band_pref,
                                                  lte_band_pref,
                                                  tds_band_pref,
                                                  prl_pref,
                                                  roam_pref,
                                                  hybr_pref,
                                                  int_hybr_pref,
                                                  srv_domain_pref,
                                                  act_id,
                                                  act_update_reas,
                                                  req_id,
                                                  SYS_CSG_ID_INVALID,
                                                  SYS_RAT_NONE) || is_top_ptr_changed;

      if ((CMPH_SS_FEATURE_MODE(ss,cmph_ptr()) == SYS_SUBS_FEATURE_MODE_SVLTE) ||
         (CMPH_SS_FEATURE_MODE(ss,cmph_ptr()) == SYS_SUBS_FEATURE_MODE_SRLTE) ||
         (CMPH_SS_FEATURE_MODE(ss,cmph_ptr()) == SYS_SUBS_FEATURE_MODE_SGLTE))
      {
        is_top_ptr_changed = cmph_insert_orig_mode( CM_SS_HYBR_2,
                                                    orig_mode,
                                                    act_type,
                                                    force_term,
                                                    mode_pref,
                                                    band_pref,
                                                    lte_band_pref,
                                                    tds_band_pref,
                                                    prl_pref,
                                                    roam_pref,
                                                    hybr_pref,
                                                    int_hybr_pref,
                                                    srv_domain_pref,
                                                    act_id,
                                                    act_update_reas,
                                                    req_id,
                                                    csg_id,
                                                    csg_rat) || is_top_ptr_changed;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      if ( cmph_is_feature_mode_sglte() &&
           cmtask_orig_para_is_obj_on_any_q(CM_ACT_TYPE_EMERG_CALL) &&
           act_type != CM_ACT_TYPE_EMERG_CALL
         )
      {
        CM_MSG_HIGH_1("SC_SGLTE: Updating obj %d during emerg call",act_type);
        is_top_ptr_changed = FALSE;
      }

      return( is_top_ptr_changed );

    default:
      sys_err_fatal_invalid_value_exception((uint8) ss);

  } /* switch ( ss ) */

  return(FALSE); /*lint !e527 */

} /* cmph_insert_orig_mode */


/*===========================================================================

FUNCTION cmph_delete_orig_param

DESCRIPTION
  Deletes the origination parameters in the priority queue.
  Currently only CM_ACT_UPDATE_REAS_END is supported

DEPENDENCIES
 None

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/

void cmph_delete_orig_param(

  cm_act_id_type            act_id,
    /* The id of the activity whose orig_params are to be updated
    */
  cm_ss_e_type              ss
    /* The ss on which the activity was going on
    */
)
{
  cm_orig_q_s_type  *ph_orig_ptr;

  CM_ASSERT(BETWEEN(ss, CM_SS_NONE, CM_SS_MAX ) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Search the ptr
  */
  ss = (ss == CM_SS_MAX ? CM_SS_MAIN : ss);

  ph_orig_ptr = cmtask_orig_para_search_act_id(  ss, act_id );

  if( ph_orig_ptr != NULL )
  {
    /* Delete the priority object identified by act_id */
    (void)cmtask_orig_para_delete( ss, ph_orig_ptr, TRUE );
  }

}


/*===========================================================================

FUNCTION cmph_update_orig_param

DESCRIPTION
  Updates the origination parameters in the priority queue.
  Currently only CM_ACT_UPDATE_REAS_END is supported

DEPENDENCIES
 None

RETURN VALUE
  True if the act_id object is found in the queue and updated
  False otherwise

SIDE EFFECTS
  None.

===========================================================================*/

boolean cmph_update_orig_param(

  cm_act_id_type            act_id,
    /* The id of the activity whose orig_params are to be updated
    */
  cm_ss_e_type              ss,
    /* The ss on which the activity was going on
    */
  cm_act_update_reas_e_type act_update_reas
    /* The reason for updating the activity
    */
)
{

  cm_orig_q_s_type *q_ptr;
  boolean is_obj_delete = FALSE;
  boolean is_obj_emerg_call = FALSE;
  cmph_s_type *ph_ptr = cmph_ptr();
  cmph_sub_config_s_type *ph_sub_config_ptr;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT( BETWEEN( act_update_reas,
                      CM_ACT_UPDATE_REAS_NONE,
                      CM_ACT_UPDATE_REAS_MAX ) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if act_id in the specified queue is not found */
  q_ptr = cmtask_orig_para_search_act_id(ss, act_id);
  if(q_ptr == NULL)
  {
    return FALSE;
  }
  ph_sub_config_ptr = cmph_get_sub_config_ptr(cmph_map_cm_ss_to_subs(ss));

  if(ph_sub_config_ptr == NULL)
  {
    CM_MSG_HIGH_1("cmph sub config pointer on ss %d is NULL",ss);
    return FALSE;
  }
  is_obj_emerg_call = (q_ptr->act_type == CM_ACT_TYPE_EMERG_CALL);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch(act_update_reas)
  {

    case CM_ACT_UPDATE_REAS_ACT_END:

      /* Step 1: Go through the queue and get a pointer to the object of
      **         Interest
      ** Step 2: If the pointer is not NULL, then update the value and
      **         Return true
      ** Step 3: Else return FALSE
      */

      q_ptr->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_END;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* Check whether we need to unforce the system selection preference
      ** that was forced automatically by CM during origination.
      */
      if( q_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE )
      {
        /* Set origination mode term to none.
        */
        q_ptr->orig->orig_pref_term  = CM_PREF_TERM_NONE;

      } /* if( q_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE ) */
      else
      {

        switch( q_ptr->orig->orig_pref_term )
        {
          case CM_PREF_TERM_CM_1_CALL:
            /* If preference was forced by CM on the fly for the duration
            ** of the one call, unforce the mode now.
            */
            CM_MSG_LOW_1("cmph_force_orig_mode_on_the_fly() on %d",
                                      q_ptr->orig->orig_pref_term);

            /* Remove this q_ptr from the queue
            */
            is_obj_delete = cmtask_orig_para_delete( ss, q_ptr, TRUE );

            break;

          case CM_PREF_TERM_CM_1_CALL_PLUS:
            /* If preference was forced by CM on the fly for the duration
            ** of one call plus, indicate that we should unforce the preference
            ** in CMPH_HOLD_MODE_PREF_TIME seconds.
            **
            ** NOTE that we delay unforcing the mode preference in order to
            ** avoid loading MC with pref sys changes in a situation where
            ** the user is pressing SEND, END, SEND, END, ...
            **
            ** If there are other active calls, preference is forced per
            ** the active call based on the order of priority queue.
            **
            */
            #if defined(FEATURE_LTE_TO_1X) || defined (FEATURE_3GPP_CSFB)
            /** While ending the CSFB call even if there are other active calls holding
            ** forsing the other priority call preferences for 4 seconds.
            */
            if( ((( cmtask_orig_para_search_act_type( ss,CM_ACT_TYPE_POLICYMAN_RESTRICT) == NULL &&
                 cmtask_orig_para_count_2( ss,
                                           CM_ACT_PRIORITY_END,
                                          CM_CMP_CRITERIA_GREATER_THAN) > 1
                )
                                          ||
               ( cmtask_orig_para_search_act_type( ss,CM_ACT_TYPE_POLICYMAN_RESTRICT) != NULL &&
                 cmtask_orig_para_count_2( ss,
                                           CM_ACT_PRIORITY_END,
                                          CM_CMP_CRITERIA_GREATER_THAN) > 2
                ))
                  &&
                (cmcall_is_there_csfb_call(CM_SS_MAIN,CM_CALL_CSFB_TYPE_1XCSFB,
                                           CM_CALL_ID_INVALID)
                                           == CM_CALL_ID_INVALID))
                                    ||
              /* UnForce the preference immediately for PPCSFB calls only */
              ( q_ptr->orig->orig_mode == SD_SS_ORIG_MODE_PPCSFB_NORMAL_ORIG ||
                q_ptr->orig->orig_mode ==SD_SS_ORIG_MODE_PPCSFB_EMERG_ORIG)
                                ||
              /* UnForce the preference immediately if phone is WCDMA freq locked & call is emerg*/
               (q_ptr->act_type == CM_ACT_TYPE_EMERG_CALL &&
                ph_sub_config_ptr->wcdma_freq_lock != 0)
              )
            #else
            if(( cmtask_orig_para_search_act_type( ss,CM_ACT_TYPE_POLICYMAN_RESTRICT) == NULL &&
                 cmtask_orig_para_count_2( ss,
                                          CM_ACT_PRIORITY_END,
                                          CM_CMP_CRITERIA_GREATER_THAN) > 1
                )
                                           ||
               ( cmtask_orig_para_search_act_type( ss,CM_ACT_TYPE_POLICYMAN_RESTRICT) != NULL &&
                 cmtask_orig_para_count_2( ss,
                                          CM_ACT_PRIORITY_END,
                                          CM_CMP_CRITERIA_GREATER_THAN) > 2
              )
                                   ||
               (q_ptr->act_type == CM_ACT_TYPE_EMERG_CALL &&
                ph_sub_config_ptr->wcdma_freq_lock != 0)
            )
            #endif
            {
              boolean is_obj_data_call = (q_ptr->act_type == CM_ACT_TYPE_DATA_CALL);

              /* Remove this q_ptr from the queue
              */
              is_obj_delete = cmtask_orig_para_delete( ss, q_ptr, TRUE );

              if( is_obj_delete && is_obj_data_call )
                {
                  /* only if data call got ended, change the pref reason to orig_end, for CS call it should still be set to ORIG_START */
                  cm_orig_q_s_type *ph_orig_top_ptr =
                  cmtask_orig_para_get_top( ss == CM_SS_MAX ? CM_SS_MAIN : ss );
                  cmcall_s_type*  call_ptr = NULL;

                  /* since there's a call in the priority queue, if the top orig_ptr is NULL
                  ** something must be corrupted. Return and take no action.
                  */
                  if(ph_orig_top_ptr == NULL)
                  {
                    CM_ERR_0("ph_orig_top_ptr == NULL");
                    return FALSE;
                  }

                  if(cmph_map_act_type_to_call_type(ph_orig_top_ptr->act_type) != CM_CALL_TYPE_NONE)
                  {
                    call_ptr = cmcall_ptr((cm_call_id_type)ph_orig_top_ptr->orig->act_id);
                  }
                  if((call_ptr!=NULL) && (call_ptr->call_state == CM_CALL_STATE_CONV 
                                          || call_ptr->call_type == CM_CALL_TYPE_PS_DATA))
                  {
                    ph_orig_top_ptr->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_END;
                  }
              }
            }
            else
            {
              q_ptr->orig->orig_mode_uptime = time_get_uptime_secs() +
                                                      CMPH_HOLD_MODE_PREF_TIME;

              if( cmph_cmp_act_priorities(q_ptr->orig->act_priority, CM_ACT_PRIORITY_END ) > 0)
              {
                q_ptr->orig->act_priority   = CM_ACT_PRIORITY_END;
              }
            }
            break;

          #if ((defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) && \
               !defined(FEATURE_MMODE_REMOVE_1X))
          case CM_PREF_TERM_CM_MO_SMS:
            /* do nothing when DBM is ended CMSMS or CMPD will schedule
            ** when to unforce the mode.
            */
            CM_MSG_HIGH_0("CM MO SMS");
            if( !cmxsms_is_mo_sms_in_progress() &&
                !cmxdbm_is_mo_dbm_in_progress()
              )
            {
              /* If there is no DBM in progress then this is an
              ** error case.
              */
              CM_MSG_LOW_1("cmph_force_orig_mode_on_the_fly() on %d",
                                      q_ptr->orig->orig_pref_term);

              /* Remove this q_ptr from the queue
              */
              is_obj_delete = cmtask_orig_para_delete( ss, q_ptr, TRUE ) ;
            }
            break;
          #endif

          case CM_PREF_TERM_PWR_CYCLE:
            break;

          case CM_PREF_TERM_NONE:
          case CM_PREF_TERM_PERMANENT:
          case CM_PREF_TERM_1_CALL:
          case CM_PREF_TERM_1_CALL_OR_TIME:
          case CM_PREF_TERM_MAX:
          default:
            CM_ERR_0( "orig_pref_term");
            /*lint -save -e527 Unreachable
            **     CM_ERR exits when CM_DEBUG is on
            */
            CM_MSG_LOW_1("cmph_force_orig_mode_on_the_fly() on %d",
                                      q_ptr->orig->orig_pref_term);
            /* Remove this q_ptr from the queue
            */
            is_obj_delete = cmtask_orig_para_delete( ss, q_ptr, TRUE ) ;

            /*lint -restore */
            break;

        } /* switch( q_ptr->orig->orig_pref_term ) */

      } /* else ( q_ptr->orig->orig_mode != SD_SS_ORIG_MODE_NONE ) */

    break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_ACT_UPDATE_REAS_ACT_PWR_SAVE:

      /* Step 1: Go through the queue and get a pointer to the object of
      **         Interest
      ** Step 2: If the pointer is not NULL, then update the value and
      **         Return true
      ** Step 3: Else return FALSE
      */

      q_ptr->orig->orig_mode_pref = CM_MODE_PREF_NONE;
      q_ptr->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_PWR_SAVE;
      cmph_force_orig_mode_on_the_fly( ss );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_ACT_UPDATE_REAS_EMERG_ENTER:

      q_ptr->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_END;

      /* thermal pref have to be forced immediately, so remove any call pref
      ** without waiting for CMPH_HOLD_MODE_PREF_TIME s */
      CM_MSG_LOW_0("TH EMERG remove call object immediately");

      is_obj_delete = cmtask_orig_para_delete( ss, q_ptr, TRUE ) ;
      break;

    default:
      return FALSE;

  } /* switch(act_update_reas) */

  if ( is_obj_delete )
  {
    if (is_obj_emerg_call)
    {
      cmpmprx_notify_call_end(cmph_map_cm_ss_to_subs(ss),TRUE);
    }
    cmph_force_orig_mode_on_the_fly(ss);
  }

  return( TRUE );

} /* cmph_update_orig_param */

/*===========================================================================

FUNCTION cmph_update_orig_para_incoming_call

DESCRIPTION
  Updates the origination parameters, for the incoming call.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init(), the orig queues must be initialized.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

boolean cmph_update_orig_param_incoming_call
(
  const cmcall_s_type *call_ptr
    /* Pointer to the call object
    */
)
{
  /* Step 0: Check if we already have this on the Q
  ** Step 1: Get the top pointer, for this ss
  ** Step 2: Create a new entry with the current call type
  ** Step 3: Push the parameters on the stack
  */

  cm_orig_q_s_type *q_top_ptr      = NULL;
  cm_orig_q_s_type *ph_orig_ptr    = NULL;
  cmph_s_type *ph_ptr = cmph_ptr();
  sys_modem_as_id_e_type   asubs_id;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT( call_ptr != NULL );
  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( cmtask_orig_para_search_act_id( call_ptr->ss, call_ptr->call_id ) != NULL )
  {
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ((ph_orig_ptr = cmtask_orig_para_alloc(call_ptr->ss)) == (cm_orig_q_s_type *)NULL)
  {
    sys_err_fatal_null_ptr_exception();
    return FALSE; /*lint !e527 */
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get asubs_id */
  asubs_id = cmph_map_cm_ss_to_subs(call_ptr->ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Irrespective of the top pointer, these fields are set to the
  ** current call parameters
  */

  ph_orig_ptr->act_type              =
                          cmph_map_call_type_to_act_type( call_ptr->call_type );
  ph_orig_ptr->orig->act_id           = call_ptr->call_id;
  ph_orig_ptr->orig->act_priority     =
                             cmph_get_act_priority(  ph_orig_ptr->act_type );

  ph_orig_ptr->orig->orig_mode_uptime = CM_PH_ORIG_MODE_UPTIME_NONE;
  ph_orig_ptr->orig->act_update_reas  = CM_ACT_UPDATE_REAS_ACT_START;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  q_top_ptr = cmtask_orig_para_get_top( call_ptr->ss );

  /* For SVLTE first LTE call, copy the orig parameters from PH obj.
  */
  if( q_top_ptr != NULL &&
     q_top_ptr->orig->act_id != (cm_act_id_type)cmph_ptr() &&
     q_top_ptr->orig->orig_mode != SD_SS_ORIG_MODE_EMERG_ORIG &&
     q_top_ptr->orig->orig_mode != SD_SS_ORIG_MODE_EMERG_CB
      )
  {

    /* For SVLTE call update orig mode based on the call type
    ** LTE call could be on either MAIN or HYBR-2
    */
    if(call_ptr->cmcall_mode_info.info_type == CM_CALL_MODE_INFO_LTE)
    {
      ph_orig_ptr->orig->orig_mode            =
                  cmph_map_cm_call_type_to_sd_orig_mode( call_ptr->call_type,
                                                         call_ptr->ss );
    }
    else
    {
      ph_orig_ptr->orig->orig_mode            = q_top_ptr->orig->orig_mode;
    }
    /* Use the top's origination parameters
    */
    ph_orig_ptr->orig->orig_pref_term       = CM_PREF_TERM_CM_1_CALL_PLUS;
    ph_orig_ptr->orig->orig_mode_pref       = q_top_ptr->orig->orig_mode_pref;
    ph_orig_ptr->orig->orig_band_pref       = q_top_ptr->orig->orig_band_pref;
    ph_orig_ptr->orig->orig_lte_band_pref   = q_top_ptr->orig->orig_lte_band_pref;
    ph_orig_ptr->orig->orig_tds_band_pref   = q_top_ptr->orig->orig_tds_band_pref;
    ph_orig_ptr->orig->orig_prl_pref        = q_top_ptr->orig->orig_prl_pref;
    ph_orig_ptr->orig->orig_roam_pref       = q_top_ptr->orig->orig_roam_pref;
    ph_orig_ptr->orig->orig_hybr_pref       = q_top_ptr->orig->orig_hybr_pref;
    ph_orig_ptr->orig->orig_int_hybr_pref   = q_top_ptr->orig->orig_int_hybr_pref;
    ph_orig_ptr->orig->user_mode_pref       = q_top_ptr->orig->user_mode_pref;

    /* set srv_domain_pref based on call_type
    ** setting it to top's srv_domain_pref can be wrong (eg:- if top is PS_ONLY
    ** and the call under consideration is VOICE)
    */
    ph_orig_ptr->orig->orig_srv_domain_pref = cmcall_get_favored_srv_domain_pref(
                                             call_ptr);


  }
  else
  {


    ph_orig_ptr->orig->orig_mode            =
                cmph_map_cm_call_type_to_sd_orig_mode( call_ptr->call_type,
                                                       call_ptr->ss );
    ph_orig_ptr->orig->orig_pref_term       = CM_PREF_TERM_CM_1_CALL_PLUS;
    ph_orig_ptr->orig->orig_mode_pref       = CMPH_SS_MODE_PREF(asubs_id, ph_ptr);
    ph_orig_ptr->orig->orig_band_pref       = CMPH_SS_BAND_PREF(asubs_id, ph_ptr);
    ph_orig_ptr->orig->orig_lte_band_pref   = CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr);
    ph_orig_ptr->orig->orig_tds_band_pref   = CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr);
    ph_orig_ptr->orig->orig_prl_pref        = CMPH_SS_PRL_PREF(asubs_id,ph_ptr);
    ph_orig_ptr->orig->orig_roam_pref       = CMPH_SS_ROAM_PREF(asubs_id,ph_ptr);
    ph_orig_ptr->orig->orig_hybr_pref       = CMPH_SS_HYBR_PREF(asubs_id, ph_ptr);
    if (asubs_id == SYS_MODEM_AS_ID_1)
    {
      ph_orig_ptr->orig->orig_int_hybr_pref   = ph_ptr->int_hybr_pref;
    }
    else
    {
      ph_orig_ptr->orig->orig_int_hybr_pref
        = cmph_map_cm_hybr_pref_to_sd_hybr_pref(ph_orig_ptr->orig->orig_hybr_pref);
    }
    ph_orig_ptr->orig->user_mode_pref       = CMPH_SS_MODE_PREF(asubs_id, ph_ptr);

    /* set srv_domain_pref based on call_type
    ** setting it to top's srv_domain_pref can be wrong (eg:- if top is PS_ONLY
    ** and the call under consideration is VOICE)
    */
    ph_orig_ptr->orig->orig_srv_domain_pref = cmcall_get_favored_srv_domain_pref(
                                             call_ptr);


  }
  /* In LTE configuration if the MT call is GW voice call then
  ** remove LTE from mode pref so that if at all service acquisition is done
  ** SD can set BST acq only for GW
  */
  #ifdef FEATURE_CM_LTE
  if ((call_ptr->call_type == CM_CALL_TYPE_VOICE ||
       call_ptr->call_type == CM_CALL_TYPE_CS_DATA ) &&
      (call_ptr->cmcall_mode_info.info_type == CM_CALL_MODE_INFO_GW_CS)
  #if defined (FEATURE_LTE_TO_1X)
      && (call_ptr->csfb_type != CM_CALL_CSFB_TYPE_1XCSFB)
  #endif
     )
  {
    ph_orig_ptr->orig->orig_mode_pref = cm_remove_mode_pref_components(
                                           ph_orig_ptr->orig->orig_mode_pref ,
                                           1,
                                           SD_SS_MODE_PREF_GWL_LTE
                                           );
  }
  #endif
  /* Enqueue the orig
  ** onto the orig Q.
  */
  if( cmtask_orig_para_insert( call_ptr->ss , ph_orig_ptr ))
  {
    #if defined (FEATURE_LTE_TO_1X)
    if( call_ptr->csfb_type == CM_CALL_CSFB_TYPE_1XCSFB )
    {
      cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

      /* For 1XCSFB call we need to force MT call preferences
      ** (With orig_mode as 1XCSFB_NORMAL_ORIG/1XCSFB_EMERG_ORIG)
      ** based on call type So that SD can execute the scripts
      ** specific to 1XCSFB
      */
      if((call_ptr->call_type == CM_CALL_TYPE_VOICE) ||
         (call_ptr->call_type == CM_CALL_TYPE_SMS) ||
         (call_ptr->call_type == CM_CALL_TYPE_PD))
      {
        ph_orig_ptr->orig->orig_mode = SD_SS_ORIG_MODE_1XCSFB_NORMAL_ORIG;
      }
      else if (call_ptr->call_type == CM_CALL_TYPE_EMERGENCY)
      {
        ph_orig_ptr->orig->orig_mode = SD_SS_ORIG_MODE_1XCSFB_EMERG_ORIG;
      }

      CM_MSG_HIGH_1("Forcing MT 1XCSFB call preferences call_type =%d", call_ptr->call_type);
      cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue (
         call_ptr->ss,
         SD_SS_PREF_REAS_ORIG_START_CS,
         ph_orig_ptr->orig->orig_mode,
         FALSE,
         ph_orig_ptr,
         CM_ACT_UPDATE_REAS_NONE,
         &cmd
         );

      cmmsimc_proc_cmd_pref_sys_chgd(&cmd);

     } /* call_ptr->csfb_type == CM_CALL_CSFB_TYPE_1XCSFB */
     #endif /* FEATURE_LTE_TO_1X */
    /* Insert succeeded */
    return TRUE;

  }else
  {
    /* Failed to insert */
    return FALSE;
  }

} /* cmph_update_orig_para_incoming_call*/

/*===========================================================================

FUNCTION cmph_add_srv_domain_pref

DESCRIPTION
  Adds the srv_domain_pref

DEPENDENCIES
 CM_SRV_DOMAIN_PREF_PS_ATTACH, CM_SRV_DOMAIN_PREF_PS_DETACH not supported


RETURN VALUE
 The union of the srv_domain_pref

SIDE EFFECTS
  None.

===========================================================================*/
cm_srv_domain_pref_e_type cmph_add_srv_domain_pref(

  cm_srv_domain_pref_e_type orig_srv_domain_pref,
    /* The original srv_domain pref
    */

  cm_srv_domain_pref_e_type srv_domain_pref_to_add
    /* The srv_domain_pref to add
    */
)
{
  switch( srv_domain_pref_to_add )
  {

    case CM_SRV_DOMAIN_PREF_NONE:
    case CM_SRV_DOMAIN_PREF_NO_CHANGE:
      return( orig_srv_domain_pref );

    case CM_SRV_DOMAIN_PREF_PS_ATTACH:
    case CM_SRV_DOMAIN_PREF_PS_DETACH:
    case CM_SRV_DOMAIN_PREF_PS_LOCAL_DETACH:
    case CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH:
      CM_ERR_1( "CM Invalid type %d cmph_add_srv_domain_pref",
                                              srv_domain_pref_to_add);
      CM_ASSERT(FALSE);
      return( orig_srv_domain_pref );

    case CM_SRV_DOMAIN_PREF_CS_ONLY:
      if( orig_srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY ||
          orig_srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS )
      {
        return( CM_SRV_DOMAIN_PREF_CS_PS );
      }
      return( CM_SRV_DOMAIN_PREF_CS_ONLY );

    case CM_SRV_DOMAIN_PREF_PS_ONLY:
      if( orig_srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY ||
          orig_srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS )
      {
        return( CM_SRV_DOMAIN_PREF_CS_PS );
      }
      return( CM_SRV_DOMAIN_PREF_PS_ONLY );

    case CM_SRV_DOMAIN_PREF_CS_PS:
      return( CM_SRV_DOMAIN_PREF_CS_PS );

    default:
       return( CM_SRV_DOMAIN_PREF_CS_ONLY );

  }/* switch( srv_domain_pref_to_add )*/

}/* cmph_add_srv_domain_pref */

/*===========================================================================

FUNCTION cmph_set_act_update_reas_for_pm_rest

DESCRIPTION
  Set act_update_reas parameters in the priority queue properly when policy restrict is forced
  on top of priority queue.  This will ensure when the correct pref reason is forced when delete
  the policy restrict from the priority queue.

DEPENDENCIES
 None

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static void cmph_set_act_update_reas_for_pm_rest (

  cmph_s_type                     *ph_ptr,
      /* Pointer to a phone object */

  sys_modem_as_id_e_type           asubs_id
)
{
  cm_orig_q_s_type *pm_rest_obj_ptr = NULL;
  cm_orig_q_s_type *queue_entry = NULL;

  /* main: search CM_ACT_TYPE_POLICYMAN_RESTRICT */
  pm_rest_obj_ptr = cmtask_orig_para_search_act_type( CM_SS_MAIN,
                    CM_ACT_TYPE_POLICYMAN_RESTRICT);
  queue_entry = cmtask_orig_para_search_act_id( CM_SS_MAIN,
                 (cm_act_id_type)ph_ptr );

  if(pm_rest_obj_ptr != NULL && queue_entry != NULL)
  {
    queue_entry->orig->act_update_reas = CM_ACT_UPDATE_REAS_USER;
    CM_MSG_HIGH_2("full_rat_search main: rest obj act_update_reas=%d, ph obj act_update_reas=%d",
                   pm_rest_obj_ptr->orig->act_update_reas,
                   queue_entry->orig->act_update_reas );
  }

  if (cmph_is_subs_feature_mode_1x_sxlte(asubs_id))
  {
    /* hybr hdr: search CM_ACT_TYPE_POLICYMAN_RESTRICT */
    pm_rest_obj_ptr = cmtask_orig_para_search_act_type( CM_SS_HDR,
                                            CM_ACT_TYPE_POLICYMAN_RESTRICT);
    queue_entry = cmtask_orig_para_search_act_id( CM_SS_HDR,
                                                (cm_act_id_type)ph_ptr );

    if(pm_rest_obj_ptr != NULL && queue_entry != NULL)
    {
      queue_entry->orig->act_update_reas = CM_ACT_UPDATE_REAS_USER;
      CM_MSG_HIGH_2("full_rat_search hdr: rest obj act_update_reas=%d, ph obj act_update_reas=%d",
                   pm_rest_obj_ptr->orig->act_update_reas,
                   queue_entry->orig->act_update_reas );
    }

    /* hybr2: search CM_ACT_TYPE_POLICYMAN_RESTRICT */
    pm_rest_obj_ptr = cmtask_orig_para_search_act_type( CM_SS_HYBR_2,
                                            CM_ACT_TYPE_POLICYMAN_RESTRICT);
    queue_entry = cmtask_orig_para_search_act_id( CM_SS_HYBR_2,
                                                (cm_act_id_type)ph_ptr );

    if(pm_rest_obj_ptr != NULL && queue_entry != NULL)
    {
      queue_entry->orig->act_update_reas = CM_ACT_UPDATE_REAS_USER;
      CM_MSG_HIGH_2("full_rat_search hybr2: rest obj act_update_reas=%d, ph obj act_update_reas=%d",
                   pm_rest_obj_ptr->orig->act_update_reas,
                   queue_entry->orig->act_update_reas );
    }
  }

}

/*===========================================================================

FUNCTION cmph_force_pref_on_the_fly_ss

DESCRIPTION
  Force the system selection preference on the fly on the HYBR_2/3 stack for
  multi-sim.
  Note: It should be only used to force preference on subs other that sub1.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
dword cmph_force_pref_on_the_fly_ss(

  cm_ss_e_type                     ss,
       /* SS to use for origination, if hybrid operation is changed,
       ** then ss= CM_SS_MAX.
       */

  cmph_s_type                     *ph_ptr,
      /* Pointer to a phone object */

  sd_ss_pref_reas_e_type           force_reason,
      /* Reason for forcing the SS-preference */

  cm_act_type_e_type               act_type,
      /* Call type for which to force the preferences */

  cm_network_sel_mode_pref_e_type  network_sel_mode_pref,
    /* The current network sel mode */

  cm_pref_s_type                   *hybr_2_pref_info_ptr,
      /* Preferences of the MAIN stack */

  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  cm_pref_s_type                   *hybr_3_pref_info_ptr,
      /* Preferences of the MAIN stack */
  #endif

  cm_activate_code_e_type          otasp_act_code,
      /* OTASP call activation code */

  cm_act_id_type                   act_id,
      /* The uniques id of the activity that is forcing the mode */

  cm_act_update_reas_e_type        act_update_reas,
      /* Reason for the update */

  boolean                          force_top_pref,
      /* Force the top ptreven if the top didn't change */

  const cm_acq_pri_order_pref_s_type   *rat_acq_order_pref_ptr,
    /* Rat acquisition priority order */

  uint16                           req_id,
    /* Sys sel pref req. id */

  sys_csg_id_type                  csg_id,
    /* CSG identifier */

  sys_radio_access_tech_e_type     csg_rat
    /* RAT specified for CSG */

)
/*lint -esym(715,int_hybr_pref) */
{

  unsigned int            rescan_time     = 0;
    /* Ballpark estimation for the number of seconds it takes
    ** the phone to reacquire service
    */

  sd_ss_orig_mode_e_type  orig_mode;
    /* Origination mode for main stack
    */

  cm_orig_q_s_type        *ph_hybr_xxx_orig_top_ptr;
    /* The pointer to the top element of the HYBR_2 priority queue
    */

  cm_orig_q_s_type        *ph_orig_top_ptr;
    /* The pointer to the top element of the priority queue
    */

  boolean                 is_top_ptr_changed        = FALSE;
  boolean                 is_hybr_xxx_top_ptr_changed = FALSE;

  sd_ss_hybr_pref_e_type  int_hybr_pref   = SD_SS_HYBR_PREF_NONE;
  cm_pref_s_type          *pref_info_ptr        = NULL;

  sys_modem_as_id_e_type   asubs_id = cmph_map_cm_ss_to_subs(ss);
  cmmsc_proc_cmd_pref_sys_chgd_s_type   cmd;
  const sys_lte_band_mask_e_type lte_band_pref_no_chg = SYS_LTE_BAND_MASK_CONST_NO_CHG;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if the params are expected
  */
  if (ss == CM_SS_MAX || ss == CM_SS_MAIN || ss == CM_SS_HYBR_1)
  {
    CM_ERR_FATAL_1("ss =%d   is not expected!!!", ss);
  }

  /* Check if the preference is allowed on the ss */
  if (cmph_no_hybr2() && ss == CM_SS_HYBR_2)
  {
    CM_ERR_FATAL_0("CHG+GWLT: not allow preference over HYBR-2");
  }    

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  if (ss == CM_SS_HYBR_3)
  {
    if (hybr_3_pref_info_ptr == NULL)
    {
      CM_MSG_HIGH_0("hybr_3_pref_info_ptr NULL");
      return rescan_time;
  }
  else
    {
      pref_info_ptr = hybr_3_pref_info_ptr;
    }
  }
  else
  #endif
    {
    if (hybr_2_pref_info_ptr == NULL)
    {
      CM_MSG_HIGH_0("hybr_2_pref_info_ptr NULL");
      return rescan_time;
    }
    else
  {
      CM_ASSERT( hybr_2_pref_info_ptr->mode_pref < CM_MODE_PREF_MAX );
      CM_ASSERT(BETWEEN(hybr_2_pref_info_ptr->band_pref, CM_BAND_PREF_NONE,CM_BAND_PREF_MAX));
      CM_ASSERT( BETWEEN(hybr_2_pref_info_ptr->hybr_pref,  CM_HYBR_PREF_NONE, CM_HYBR_PREF_MAX) );
      CM_ASSERT( BETWEEN(hybr_2_pref_info_ptr->prl_pref,   CM_PRL_PREF_NONE,  CM_PRL_PREF_MAX) );
      CM_ASSERT( BETWEEN(hybr_2_pref_info_ptr->roam_pref,  CM_ROAM_PREF_NONE, CM_ROAM_PREF_MAX) );
      CM_ASSERT( INRANGE(hybr_2_pref_info_ptr->srv_domain_pref, CM_SRV_DOMAIN_PREF_NONE,
                                          (CM_SRV_DOMAIN_PREF_MAX-1)));
      pref_info_ptr = hybr_2_pref_info_ptr;
    }    
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check and update 3GPP2 specific preference */
  cmph_msim_modify_3gpp2_pref(asubs_id,
                                &(pref_info_ptr->mode_pref),
                                &(pref_info_ptr->hybr_pref));

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  network_sel_mode_pref = pref_info_ptr->network_sel_mode_pref;

  /* Map the call type to system determination's origination mode.
  */
  if( network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_NONE )
  {
    orig_mode = cmph_map_cm_call_type_to_sd_orig_mode( cmph_map_act_type_to_call_type(act_type),
                                                       ss );
  }
  else
  {
    orig_mode = cmph_map_cm_network_sel_mode_pref_to_orig_mode(
                                                    network_sel_mode_pref );
  }

  CM_MSG_HIGH_5("ss = %d, asubs_id = %d, orig_mode (computed new) = %d, act_type = %d, act_update_reas %d",
                ss, asubs_id, orig_mode,act_type,act_update_reas);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Lower data call priority
  */
  if( act_update_reas == CM_ACT_UPDATE_REAS_USER ||
      act_update_reas == CM_ACT_UPDATE_REAS_ACT_END )
  {

    /* This is because of a user activity
    ** bump down the priority of all data calls and then insert the
    ** phone object
    */

    (void)cmtask_orig_para_change_act_priority( ss,
                                  CM_ACT_TYPE_DATA_CALL,
                                  CM_ACT_PRIORITY_80,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );

    (void)cmtask_orig_para_change_act_priority( ss,
                                  CM_ACT_TYPE_DATA_CALL,
                                  CM_ACT_PRIORITY_END,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );
  }

  /* If there is a activity and we are setting the mode to none or manual_idle,
  ** update the orig mode accordingly
  */
  ph_hybr_xxx_orig_top_ptr = cmtask_orig_para_get_top( ss );

  if (ph_hybr_xxx_orig_top_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  ph_orig_top_ptr = ph_hybr_xxx_orig_top_ptr;

  if ( (act_update_reas ==  CM_ACT_UPDATE_REAS_USER  ) &&
     ( (
          ( ( ph_hybr_xxx_orig_top_ptr != NULL   &&
              ph_hybr_xxx_orig_top_ptr->orig->orig_mode != SD_SS_ORIG_MODE_NONE &&
              ph_hybr_xxx_orig_top_ptr->orig->orig_mode != SD_SS_ORIG_MODE_MANUAL_IDLE
            )
            ||
            ( cmtask_orig_para_count_2( ss,
                                        CM_ACT_PRIORITY_END,
                                        CM_CMP_CRITERIA_GREATER_THAN) >= 1
            )
          )
       )
     )
     )
  {
    if( orig_mode ==  SD_SS_ORIG_MODE_MANUAL_IDLE )
    {
       orig_mode =  SD_SS_ORIG_MODE_MANUAL_ORIG;
    }
    else
    {
       orig_mode = SD_SS_ORIG_MODE_NORMAL;
    }
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If current origination mode is EMERG_CB and we're originating a call
  ** other than emrgency (for example, PD), set new orig mode to
  ** SD_SS_ORIG_MODE_EMERG_CB
  */
  if( ( act_type                        != CM_ACT_TYPE_EMERG_CALL &&
        act_type                        != CM_ACT_TYPE_PH_OBJ     &&
        ph_hybr_xxx_orig_top_ptr                 != NULL                   &&
        ph_hybr_xxx_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_CB
      )
    )
  {
    CM_MSG_HIGH_0("orig_mode (in callback) = SD_SS_ORIG_MODE_EMERG_CB");
    orig_mode = SD_SS_ORIG_MODE_EMERG_CB;
  }

  /*
  ** Now figure out whether we need to exit emergency callback mode
  ** or continue in callback but with current preferences
  */
  if((orig_mode != SD_SS_ORIG_MODE_EMERG_CB) && (act_type != CM_ACT_TYPE_PH_OBJ))
  {
    /*
    ** If orig_mode is anything other than SD_SS_ORIG_MODE_EMERG_CB,
    ** exit emergency callback mode
    */

    /*If Emergency call being originated on SUB 2, exit ECBM with force pref on SUB 1*/
    if( (orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG) && 
        ( ss == CM_SS_HYBR_3 || ( (ss == CM_SS_HYBR_2) && cmph_is_msim() && !cmph_is_sxlte())))
    {
      cmph_exit_emergency_cb(ph_ptr, FALSE,ss,TRUE);
    }
    else
    {
      cmph_exit_emergency_cb(ph_ptr, FALSE,ss,FALSE);
    }

  }

  #ifdef CM_GW_SUPPORTED
  if (act_type == CM_ACT_TYPE_EMERG_CALL )
  {
    cmwcall_set_lmtd_srvc_req ();
  }
  #endif  /* FEATURE_WCDMA || FEATURE_GSM */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the caller of this function wants to use existing system selection
  ** preferences, do so.
  */

  /* Top element of MAIN already accessed
  */
  if( ss != CM_SS_MAX )
  {
    ph_orig_top_ptr = cmtask_orig_para_get_top( ss );
  }
  else
  {
    /* If it's MAX, get the top ptr from MAIN.
    ** This could be due to emergency call or hybr_pref is toggled.
    ** In the back to back emergency call, we will be deleting the orig_top_ptr
    ** acquired above, so we should acquire this back from the MAIN
    */
    ph_orig_top_ptr = cmtask_orig_para_get_top(CM_SS_MAIN);
  }

  if( ( ph_orig_top_ptr != NULL &&
        ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE
      )
      ||
      ph_orig_top_ptr == NULL
    )
  {
    if( pref_info_ptr->mode_pref == CM_MODE_PREF_NO_CHANGE )
    {
      pref_info_ptr->mode_pref = CMPH_SS_MODE_PREF(asubs_id, ph_ptr);
    }

    if( pref_info_ptr->band_pref == CM_BAND_PREF_NO_CHANGE )
    {
      pref_info_ptr->band_pref = CMPH_SS_BAND_PREF(asubs_id, ph_ptr);
    }

    if ( pref_info_ptr->tds_band_pref == CM_BAND_PREF_NO_CHANGE )
    {
       pref_info_ptr->tds_band_pref = CMPH_SS_TDS_BAND_PREF( asubs_id, ph_ptr );
    }

    if ( SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&pref_info_ptr->lte_band_pref, &lte_band_pref_no_chg ))
    {
       pref_info_ptr->lte_band_pref = CMPH_SS_LTE_BAND_PREF( asubs_id, ph_ptr );
    }

    if( pref_info_ptr->prl_pref == CM_PRL_PREF_NO_CHANGE )
    {
      pref_info_ptr->prl_pref = CMPH_SS_PRL_PREF(asubs_id, ph_ptr);
    }

    if( pref_info_ptr->roam_pref == CM_ROAM_PREF_NO_CHANGE )
    {
      pref_info_ptr->roam_pref = CMPH_SS_ROAM_PREF(asubs_id, ph_ptr);
    }

    if( pref_info_ptr->hybr_pref == CM_HYBR_PREF_NO_CHANGE )
    {
      pref_info_ptr->hybr_pref = CMPH_SS_HYBR_PREF(asubs_id, ph_ptr);
    }
    int_hybr_pref =
      cmph_map_cm_hybr_pref_to_sd_hybr_pref( pref_info_ptr->hybr_pref );

    if ( pref_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_NO_CHANGE )
    {
      pref_info_ptr->srv_domain_pref = CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr);
    }
  }
  else
  {
    if( pref_info_ptr->mode_pref == CM_MODE_PREF_NO_CHANGE )
    {
      pref_info_ptr->mode_pref =  ph_orig_top_ptr->orig->orig_mode_pref;
    }

    if( pref_info_ptr->band_pref == CM_BAND_PREF_NO_CHANGE )
    {
      pref_info_ptr->band_pref = ph_orig_top_ptr->orig->orig_band_pref;
    }

    if( SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&pref_info_ptr->lte_band_pref, &lte_band_pref_no_chg) )
    {
      pref_info_ptr->lte_band_pref = ph_orig_top_ptr->orig->orig_lte_band_pref;
    }

    if( pref_info_ptr->tds_band_pref == CM_BAND_PREF_NO_CHANGE )
    {
      pref_info_ptr->tds_band_pref = ph_orig_top_ptr->orig->orig_tds_band_pref;
    }

    if( pref_info_ptr->prl_pref == CM_PRL_PREF_NO_CHANGE )
    {
      pref_info_ptr->prl_pref = ph_orig_top_ptr->orig->orig_prl_pref;
    }

    if( pref_info_ptr->roam_pref == CM_ROAM_PREF_NO_CHANGE )
    {
      pref_info_ptr->roam_pref = ph_orig_top_ptr->orig->orig_roam_pref;
    }

    if(pref_info_ptr->hybr_pref == CM_HYBR_PREF_NO_CHANGE )
    {
      pref_info_ptr->hybr_pref = ph_orig_top_ptr->orig->orig_hybr_pref;

      int_hybr_pref = ph_orig_top_ptr->orig->orig_int_hybr_pref;
    }
    else
    {
      int_hybr_pref = cmph_map_cm_hybr_pref_to_sd_hybr_pref( pref_info_ptr->hybr_pref );
    }

    if ( pref_info_ptr->srv_domain_pref == CM_SRV_DOMAIN_PREF_NO_CHANGE )
    {
      pref_info_ptr->srv_domain_pref = ph_orig_top_ptr->orig->orig_srv_domain_pref;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified mode and band preference combination is not valid for this
  ** target or not supported by the currently loaded PRL, use existing mode
  ** and band preferences.
  */
  if( ( SD_SS_ORIG_MODE_EMERG_ORIG != orig_mode || (int)CM_ACT_TYPE_EMERG_CALL!= (int)act_type )
                                                &&
      ( FALSE == cmph_is_valid_mode_band_pref( pref_info_ptr->mode_pref,
                                               pref_info_ptr->band_pref ) &&
        FALSE == cmph_is_valid_tds_mode_band_pref( pref_info_ptr->mode_pref,
                                                   pref_info_ptr->tds_band_pref ) &&
        FALSE == cmph_is_valid_lte_mode_band_pref( pref_info_ptr->mode_pref,
                                                   pref_info_ptr->lte_band_pref ))
    )
  {
    if (pref_info_ptr->mode_pref != CM_MODE_PREF_NONE)
    {
      CM_ERR_3( "Invalid mode/band pref mp=%d, bp=0x%08x %08x, tds_bp=0x%08x %08x", 
                                                     pref_info_ptr->mode_pref,
                                                     QWORD_HIGH(pref_info_ptr->band_pref),
                                                     QWORD_LOW(pref_info_ptr->band_pref));
      CM_ERR_2( "tds_bp=0x%08x %08x", QWORD_HIGH(pref_info_ptr->tds_band_pref),
                                      QWORD_LOW(pref_info_ptr->tds_band_pref));
      cm_print_lte_band_mask(pref_info_ptr->lte_band_pref);

      pref_info_ptr->mode_pref = CMPH_SS_MODE_PREF(asubs_id, ph_ptr);
      pref_info_ptr->band_pref = CMPH_SS_BAND_PREF(asubs_id, ph_ptr);
      pref_info_ptr->lte_band_pref = CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr);
      pref_info_ptr->tds_band_pref = CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr);
  
      CM_MSG_HIGH_5("Switch to use current mp=%d and bp= 0x%08x %08x instead, tds_bp= 0x%08x %08x",
                   pref_info_ptr->mode_pref,
                   QWORD_HIGH(pref_info_ptr->band_pref),
                   QWORD_LOW(pref_info_ptr->band_pref),
                   QWORD_HIGH(pref_info_ptr->tds_band_pref),
                   QWORD_LOW(pref_info_ptr->tds_band_pref));
      cm_print_lte_band_mask(pref_info_ptr->lte_band_pref);

    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if hybrid is toggled for origination, if it is toggled
  ** as a result of sys_pref_change, then clear the HDR Q and send
  ** the sys_pref down
  */

  /* If system selection preference is forced in order to originate a call
  ** (i.e., the origination mode is other than none), only change the
  ** origination mode preference.
  */
  if( act_update_reas != CM_ACT_UPDATE_REAS_USER &&
      act_update_reas != CM_ACT_UPDATE_REAS_ACT_END &&
      act_update_reas != CM_ACT_UPDATE_REAS_ACT_PWR_SAVE )
  {

    /* Insert the origination parameters in the priority queue
    */

    is_top_ptr_changed = cmph_insert_orig_mode( ss,
                                                orig_mode,
                                                act_type,
                                                pref_info_ptr->pref_term,
                                                pref_info_ptr->mode_pref,
                                                pref_info_ptr->band_pref,
                                                pref_info_ptr->lte_band_pref,
                                                pref_info_ptr->tds_band_pref,
                                                pref_info_ptr->prl_pref,
                                                pref_info_ptr->roam_pref,
                                                pref_info_ptr->hybr_pref,
                                                int_hybr_pref,
                                                pref_info_ptr->srv_domain_pref,
                                                act_id,
                                                act_update_reas,
                                                req_id,
                                                csg_id,
                                                csg_rat
                                                );

  }
  /* Else, update the phone state to reflect the new preferences.
  */
  else if( act_update_reas == CM_ACT_UPDATE_REAS_USER ||
           act_update_reas == CM_ACT_UPDATE_REAS_ACT_END )
  {
    /* If main Q changed then send pref_sys changed to both MAIN and HDR
    ** If only HDR changed, and Hybrid is toggled, then don't send
    ** pref sys changed down
    ** HYBR_2 is independent of MAIN and HDR, send it down only if
    ** the corresponding preferences changed.
    */

    if(ss == CM_SS_HYBR_2)
    {
      ph_ptr->hybr_2_stack_info.pref_info.pref_term       = pref_info_ptr->pref_term;
      ph_ptr->hybr_2_stack_info.pref_info.mode_pref       = pref_info_ptr->mode_pref;
      ph_ptr->hybr_2_stack_info.pref_info.band_pref       = pref_info_ptr->band_pref;
      ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref   = pref_info_ptr->lte_band_pref;
      ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref   = pref_info_ptr->tds_band_pref;
      ph_ptr->hybr_2_stack_info.pref_info.prl_pref        = pref_info_ptr->prl_pref;
      ph_ptr->hybr_2_stack_info.pref_info.roam_pref       = pref_info_ptr->roam_pref;
      ph_ptr->hybr_2_stack_info.pref_info.hybr_pref       = pref_info_ptr->hybr_pref;
      ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref = pref_info_ptr->srv_domain_pref;
      ph_ptr->hybr_2_stack_info.pref_info.csg_id          = csg_id;
      ph_ptr->hybr_2_stack_info.pref_info.csg_rat         = csg_rat;
    }
    #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
    else if(ss == CM_SS_HYBR_3)
    {
      ph_ptr->hybr_3_stack_info.pref_info.pref_term       = pref_info_ptr->pref_term;
      ph_ptr->hybr_3_stack_info.pref_info.mode_pref       = pref_info_ptr->mode_pref;
      ph_ptr->hybr_3_stack_info.pref_info.band_pref       = pref_info_ptr->band_pref;
      ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref   = pref_info_ptr->lte_band_pref;
      ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref   = pref_info_ptr->tds_band_pref;
      ph_ptr->hybr_3_stack_info.pref_info.prl_pref        = pref_info_ptr->prl_pref;
      ph_ptr->hybr_3_stack_info.pref_info.roam_pref       = pref_info_ptr->roam_pref;
      ph_ptr->hybr_3_stack_info.pref_info.hybr_pref       = pref_info_ptr->hybr_pref;
      ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref = pref_info_ptr->srv_domain_pref;
      ph_ptr->hybr_3_stack_info.pref_info.csg_id          = csg_id;
      ph_ptr->hybr_3_stack_info.pref_info.csg_rat         = csg_rat;
    }
    #endif
    is_hybr_xxx_top_ptr_changed = cmph_insert_orig_mode (
                                  ss,
                                  SD_SS_ORIG_MODE_NONE,
                                  CM_ACT_TYPE_PH_OBJ,
                                  pref_info_ptr->pref_term,
                                  pref_info_ptr->mode_pref,
                                  pref_info_ptr->band_pref,
                                  pref_info_ptr->lte_band_pref,
                                  pref_info_ptr->tds_band_pref,
                                  pref_info_ptr->prl_pref,
                                  pref_info_ptr->roam_pref,
                                  pref_info_ptr->hybr_pref,
                                  int_hybr_pref,
                                  pref_info_ptr->srv_domain_pref,
                                  (cm_act_id_type)ph_ptr,
                                  act_update_reas,
                                  req_id,
                                  csg_id,
                                  csg_rat
                                );

  }
  else if( act_update_reas == CM_ACT_UPDATE_REAS_ACT_PWR_SAVE )
  {

    /* Insert the origination parameters in the priority queue
    */
    (void) cmph_insert_orig_mode( ss,
                           orig_mode,
                           act_type,
                           pref_info_ptr->pref_term,
                           pref_info_ptr->mode_pref,
                           pref_info_ptr->band_pref,
                           SYS_LTE_BAND_MASK_CONST_NONE,
                           pref_info_ptr->tds_band_pref,
                           pref_info_ptr->prl_pref,
                           pref_info_ptr->roam_pref,
                           pref_info_ptr->hybr_pref,
                           int_hybr_pref,
                           pref_info_ptr->srv_domain_pref,
                           act_id,
                           act_update_reas,
                           CM_DEFAULT_VALUE,
                           csg_id,
                           csg_rat
                         );

    is_top_ptr_changed = TRUE;
  }

  /* Notify MC of mode preference change.
  */
  CM_MSG_HIGH_2( "is_top_ptr_changed %d, is_hybr_xxx_top_ptr_changed %d",
               is_top_ptr_changed, is_hybr_xxx_top_ptr_changed);

  if( is_top_ptr_changed || is_hybr_xxx_top_ptr_changed )
  {
    /*
    CM_MSG_HIGH_5( "proc_cmd_pref_sys_chgd(): ss  %d, force_reason  %d, act_type  %d force_term  %d, mode_pref  %d", 
		            ss, force_reason, act_type, pref_info_ptr->pref_term, pref_info_ptr->mode_pref );

    CM_MSG_HIGH_4( "prl_pref = %d, roam_pref = %d, hybr_pref = %ld srv_domain_pref = %d",
                 pref_info_ptr->prl_pref, pref_info_ptr->roam_pref,
                 pref_info_ptr->hybr_pref, pref_info_ptr->srv_domain_pref  );

    CM_MSG_HIGH_4( "bands: cgw 0x%08x %08x. tds 0x%08x %08x",
                                    QWORD_HIGH(pref_info_ptr->band_pref),
                                    QWORD_LOW(pref_info_ptr->band_pref),
                                    QWORD_HIGH(pref_info_ptr->tds_band_pref),
                                    QWORD_LOW(pref_info_ptr->tds_band_pref));
    cm_print_lte_band_mask(pref_info_ptr->lte_band_pref);

    */

    cmmsc_pack_cmd_for_pref_sys_chgd_per_pref(
          ss,
          force_reason,
          orig_mode,
          (const cm_pref_s_type*)pref_info_ptr,
          cmph_map_otasp_act_code_to_sd_band( otasp_act_code ),
          cmph_map_otasp_act_code_to_sd_blksys( otasp_act_code ),
          SD_SS_AVOID_SYS_IDLE,
          0,
          rat_acq_order_pref_ptr,
          cmph_map_cm_net_sel_mode_pref_to_camp_pref(network_sel_mode_pref),
          cmph_is_new_policy_apply(ss),
          CM_ACT_UPDATE_REAS_NONE,
          &cmd
          );

    cmmsimc_proc_cmd_pref_sys_chgd(&cmd);

    /* Phone is going to do a rescan, so indicate a ballpark estimation
    ** for the number of seconds it takes the phone to do the rescan and
    ** reacquire service.
    */

    rescan_time = CMPH_RESCAN_TIME;

    /* Search the Q for the phone object and change the update reason to
    ** act_start, if we don't do this, then every time the ph pref are forced
    ** the reason will be user
    */

    if( act_update_reas ==  CM_ACT_UPDATE_REAS_USER )
    {
      cm_orig_q_s_type *queue_entry;

      queue_entry = cmtask_orig_para_search_act_id( ss, (cm_act_id_type)ph_ptr );
      if(queue_entry != NULL)
      {
        queue_entry->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_START;
      }
      else
      {
        CM_ERR_1( "HYBR %d queue has no entry for ph!!",ss);
      }
    }
  }
  else if( force_top_pref )
  {

    /* Use the top ptr and force the mode, because we are waiting for OK to orig
    */
    CM_ASSERT( ph_orig_top_ptr != NULL );
    CM_ASSERT( ph_hybr_xxx_orig_top_ptr != NULL );

    /*
    CM_MSG_HIGH_5( "proc_cmd_pref_sys_chgd(): ss %d, force_reason %d, act_type %d, force_term %d, mode_pref %d", ss,
                   force_reason, act_type,  ph_hybr_xxx_orig_top_ptr->orig->orig_pref_term,
                   ph_hybr_xxx_orig_top_ptr->orig->orig_mode_pref );


    CM_MSG_HIGH_4( "prl_pref = %d, roam_pref = %d, hybr_pref = %ld srv_domain_pref = %d",
                  ph_hybr_xxx_orig_top_ptr->orig->orig_prl_pref,
                  ph_hybr_xxx_orig_top_ptr->orig->orig_roam_pref,
                   ph_hybr_xxx_orig_top_ptr->orig->orig_hybr_pref,ph_hybr_xxx_orig_top_ptr->orig->orig_srv_domain_pref );

    CM_MSG_HIGH_4("bands(MSB)(LSB): cgw 0x%08x 0x%08x, tds 0x%08x 0x%08x",
                                    QWORD_HIGH(ph_hybr_xxx_orig_top_ptr->orig->orig_band_pref),
                                    QWORD_LOW(ph_hybr_xxx_orig_top_ptr->orig->orig_band_pref),
                                    QWORD_HIGH(ph_hybr_xxx_orig_top_ptr->orig->orig_tds_band_pref),
                                    QWORD_LOW(ph_hybr_xxx_orig_top_ptr->orig->orig_tds_band_pref));

    cm_print_lte_band_mask(ph_hybr_xxx_orig_top_ptr->orig->orig_lte_band_pref);

    */
    /* Common Preferences from the queue corresponding to the ss are used.
    ** If ss = MAX, then MAIN queue is used.
    */
    if (ss == CM_SS_HYBR_2 || ss == CM_SS_HYBR_3) /* TBD: device mode check */
    {
      cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue (
         ss,
         force_reason,
         ph_hybr_xxx_orig_top_ptr->orig->orig_mode,
         cmph_is_new_policy_apply(ss),
         ph_hybr_xxx_orig_top_ptr,
         CM_ACT_UPDATE_REAS_NONE,
         &cmd
         );

      cmmsimc_proc_cmd_pref_sys_chgd(&cmd);
    }
    else
    {
      CM_MSG_HIGH_0("Invalid ss Received in cmph_force_pref_on_the_fly_per_ss()");
    }

  }
  else
  {
    CM_MSG_HIGH_0("Didn't force pref, low priority act");
  }

  SYS_ARG_NOT_USED(rat_acq_order_pref_ptr);

  return rescan_time;

} /* cmph_force_pref_on_the_fly_hybr_2() */

/*===========================================================================

FUNCTION cmph_force_pref_on_the_fly2

DESCRIPTION
  Force the system selection preference on the fly.
  It can be used to force preference for single/multi-sim for any subs.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
dword cmph_force_pref_on_the_fly2(

  cm_ss_e_type                     ss,
       /* SS to use for origination, if hybrid operation is changed,
       ** then ss= CM_SS_MAX.
       */

  cmph_s_type                     *ph_ptr,
      /* Pointer to a phone object */

  sd_ss_pref_reas_e_type           force_reason,
      /* Reason for forcing the SS-preference */

  cm_act_type_e_type               act_type,
      /* Call type for which to force the preferences */

  cm_pref_term_e_type              pref_term,
      /* Term for which to force the preferences - one-call, etc. */

  cm_mode_pref_e_type              mode_pref,
      /* Mode preference which to force */

  cm_band_pref_e_type              band_pref,
      /* Band preference which to force */

  sys_lte_band_mask_e_type         lte_band_pref,
      /* LTE band preference which to force */

  cm_band_pref_e_type              tds_band_pref,
      /* LTE band preference which to force */

  cm_prl_pref_e_type               prl_pref,
      /* PRL preference which to force */

  cm_roam_pref_e_type              roam_pref,
      /* Roam preference which to force */

  cm_hybr_pref_e_type              hybr_pref,
      /* hybr preference which to force */

  sys_plmn_id_s_type               plmn,
     /* The PLMN id to be acquired, valid when the net_sel_mode_pref
     ** is MANUAL.
     ** Applies only for GSM/WCDMA modes.
     */

  cm_srv_domain_pref_e_type        srv_domain_pref,
     /* service domain preference to force */

  cm_gw_acq_order_pref_e_type      acq_order_pref,
    /* The current acquisition order preference setting */

  cm_network_sel_mode_pref_e_type  network_sel_mode_pref,
    /* The current network sel mode */

  cm_pref_s_type                   *hybr_2_pref_info_ptr,
      /* Preferences of the MAIN stack */

  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  cm_pref_s_type                   *hybr_3_pref_info_ptr,
      /* Preferences of the MAIN stack */
  #endif

  cm_activate_code_e_type          otasp_act_code,
      /* OTASP call activation code */

  cm_act_id_type                   act_id,
      /* The uniques id of the activity that is forcing the mode */

  cm_act_update_reas_e_type        act_update_reas,
      /* Reason for the update */

  boolean                          force_top_pref,
      /* Force the top ptreven if the top didn't change */

  const cm_acq_pri_order_pref_s_type   *rat_acq_order_pref_ptr,
    /* Rat acquisition priority order */

  uint16                                req_id,
    /* sys sel pref req id */

  sys_csg_id_type                       csg_id,
    /**< CSG identifier */

  sys_radio_access_tech_e_type          csg_rat
    /**< RAT specified for CSG */

)
/*lint -esym(715,int_hybr_pref) */
{

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  CM_ASSERT( force_reason < SD_SS_PREF_REAS_MAX );
  #endif /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */

  CM_ASSERT( BETWEEN(act_type, CM_ACT_TYPE_NONE, CM_ACT_TYPE_MAX) ||
                     act_type == CM_ACT_TYPE_NONE );

  CM_ASSERT( INRANGE(otasp_act_code,  0, CM_OTASP_ACT_CODE_NONE) );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* set flag indicating user resel is buffered as there is higher priority act in the queue */
  if(ph_ptr->is_pref_change_pending[cmph_map_cm_ss_to_subs(ss)] == TRUE && force_reason == SD_SS_PREF_REAS_USER_RESEL
     && (cmtask_orig_para_search_act_type(((ss == CM_SS_MAX)?CM_SS_MAIN:ss), CM_ACT_TYPE_POLICYMAN_RESTRICT) != NULL))
  {
      cmph_set_is_user_resel_buffered_ss(ss, TRUE);
  }

  /* If the preferences are forced only on to the MAIN/HDR stacks
  ** then send them to the original function for processing
  */
  if ( cmph_is_ssim()
       ||
       (cmph_is_msim() &&
       ((ss == CM_SS_MAIN || ss == CM_SS_HYBR_1 || ss == CM_SS_MAX) ||
         (ss == CM_SS_HYBR_2 && cmph_is_sxlte())))
     )
  {
    return cmph_force_pref_on_the_fly( ss,
                                       ph_ptr,
                                       force_reason,
                                       act_type,
                                       pref_term,
                                       mode_pref,
                                       band_pref,
                                       lte_band_pref,
                                       tds_band_pref,
                                       prl_pref,
                                       roam_pref,
                                       hybr_pref,
                                       plmn,
                                       srv_domain_pref,
                                       otasp_act_code,
                                       acq_order_pref,
                                       network_sel_mode_pref,
                                       act_id,
                                       act_update_reas,
                                       force_top_pref,
                                       rat_acq_order_pref_ptr,
                                       req_id,
                                       csg_id,
                                       csg_rat);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(cmph_is_msim())
  {
    return cmph_force_pref_on_the_fly_ss(
                ss,
                ph_ptr,
                force_reason,
                act_type,
                network_sel_mode_pref,
                hybr_2_pref_info_ptr,
                #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
                hybr_3_pref_info_ptr,
                #endif /* FEATURE_MMODE_TRIPLE_SIM */
                otasp_act_code,
                act_id,
                act_update_reas,
                force_top_pref,
                rat_acq_order_pref_ptr,
                req_id,
                csg_id,
                csg_rat
                );
  }
  return 0;
} /* cmph_force_pref_on_the_fly2() */
/*lint +esym(715,hybr_2_pref_info) */
/*lint +esym(715,int_hybr_pref) */

/*===========================================================================

FUNCTION cmph_force_pref_on_the_fly

DESCRIPTION
  Force the system selection preference on the fly.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
dword cmph_force_pref_on_the_fly(

    cm_ss_e_type                     ss,
         /* SS to use for origination, if hybrid operation is changed,
         ** then ss= CM_SS_MAX.
         */

    cmph_s_type                     *ph_ptr,
        /* Pointer to a phone object */

    sd_ss_pref_reas_e_type           force_reason,
        /* Reason for forcing the SS-preference */

    cm_act_type_e_type               act_type,
        /* Call type for which to force the preferences */

    cm_pref_term_e_type              force_term,
        /* Term for which to force the preferences - one-call, etc. */

    cm_mode_pref_e_type              mode_pref,
        /* Mode preference which to force */

    cm_band_pref_e_type              band_pref,
        /* Band preference which to force */

    sys_lte_band_mask_e_type         lte_band_pref,
        /* LTE band preference which to force */

    cm_band_pref_e_type              tds_band_pref,
        /* TDS band preference which to force */

    cm_prl_pref_e_type               prl_pref,
        /* PRL preference which to force */

    cm_roam_pref_e_type              roam_pref,
        /* Roam preference which to force */

    cm_hybr_pref_e_type              hybr_pref,
        /* hybr preference which to force */

    sys_plmn_id_s_type               plmn_id,
       /* The PLMN id to be acquired, valid when the net_sel_mode_pref
       ** is MANUAL.
       ** Applies only for GSM/WCDMA modes.
       */

    cm_srv_domain_pref_e_type        srv_domain_pref,
       /* service domain preference to force */

    cm_activate_code_e_type          otasp_act_code,
        /* OTASP call activation code */

    cm_gw_acq_order_pref_e_type      acq_order_pref,
      /* The current acquisition order preference setting */

    cm_network_sel_mode_pref_e_type  network_sel_mode_pref,
      /* The current network sel mode */

    cm_act_id_type                   act_id,
        /* The uniques id of the activity that is forcing the mode */

    cm_act_update_reas_e_type        act_update_reas,
        /* Reason for the update */

    boolean                          force_top_pref,
        /* Force the top ptreven if the top didn't change */

    const cm_acq_pri_order_pref_s_type    *rat_acq_order_pref_ptr,
        /* Rat acquisition priority order */

    uint16                             req_id,
        /* Sys sel pref req id */

    sys_csg_id_type                    csg_id,
         /**< CSG identifier */

    sys_radio_access_tech_e_type       csg_rat
         /**< RAT specified for CSG */
)
{
  unsigned int            rescan_time = 0;
    /* Ballpark estimation for the number of seconds it takes
    ** the phone to reacquire service
    */

  sd_ss_orig_mode_e_type  orig_mode;
    /* Origination mode
    */

  cm_orig_q_s_type        *ph_orig_top_ptr;
    /* The pointer to the top element of the priority queue
    */

  boolean                 is_top_ptr_changed        = FALSE;
  boolean                 is_main_top_ptr_changed   = FALSE;
  boolean                 is_hybr_1_top_ptr_changed = FALSE;
  sd_ss_hybr_pref_e_type  int_hybr_pref   = SD_SS_HYBR_PREF_NONE;
  cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;
  sys_modem_as_id_e_type  asubs_id = cmph_map_cm_ss_to_subs(ss);
  boolean                 is_hybr_2_top_ptr_changed = FALSE;
  const sys_lte_band_mask_e_type lte_band_pref_no_chg      = SYS_LTE_BAND_MASK_CONST_NO_CHG;
  #if defined( FEATURE_CM_LTE )&& defined( CM_DEBUG )
  #error code not present
#endif
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  CM_ASSERT( force_reason < SD_SS_PREF_REAS_MAX );
  #endif /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */

  CM_ASSERT( BETWEEN(act_type, CM_ACT_TYPE_NONE, CM_ACT_TYPE_MAX) ||
                     act_type == CM_ACT_TYPE_NONE );

  CM_ASSERT( BETWEEN(force_term, CM_PREF_TERM_NONE, CM_PREF_TERM_MAX) );
  CM_ASSERT( mode_pref < CM_MODE_PREF_MAX );

  #ifdef FEATURE_CM_LTE
  CM_ASSERT( BETWEEN(band_pref, CM_BAND_PREF_NONE, CM_BAND_PREF_MAX) ||
             (!SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&lte_band_pref) &&
              SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&lte_band_pref_any,&lte_band_pref ))
           );
  #else
  CM_ASSERT(band_pref != CM_BAND_PREF_NONE );
  CM_ASSERT(band_pref != CM_BAND_PREF_MAX );
  #endif

  CM_ASSERT( BETWEEN(prl_pref,   CM_PRL_PREF_NONE,  CM_PRL_PREF_MAX) );
  CM_ASSERT( BETWEEN(roam_pref,  CM_ROAM_PREF_NONE, CM_ROAM_PREF_MAX) );
  CM_ASSERT( BETWEEN(hybr_pref,  CM_HYBR_PREF_NONE, CM_HYBR_PREF_MAX) );
  CM_ASSERT( INRANGE(srv_domain_pref, CM_SRV_DOMAIN_PREF_NONE,
                                      (CM_SRV_DOMAIN_PREF_MAX-1)));
  CM_ASSERT( INRANGE(otasp_act_code,  0, CM_OTASP_ACT_CODE_NONE) );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check and update 3GPP2 specific preference */
  cmph_msim_modify_3gpp2_pref(asubs_id,
                                &mode_pref,
                                &hybr_pref);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Map the call type to system determination's origination mode.
  */
  if( network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_NONE )
  {
    orig_mode = cmph_map_cm_call_type_to_sd_orig_mode( cmph_map_act_type_to_call_type(act_type),
                                                       CM_SS_MAIN );
  }
  else
  {
    orig_mode = cmph_map_cm_network_sel_mode_pref_to_orig_mode(
                                                    network_sel_mode_pref );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* During emerg call, move LTE call obj below PH obj. LTE calls
  ** are not ended during emergency call
  */
  if(orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG &&
     cmcall_get_num_call_in_call_mode(CM_CALL_MODE_INFO_LTE) > 0)
  {
    if (cmph_is_subs_feature_mode_1x_sxlte(asubs_id))
    {
      (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                    CM_ACT_TYPE_DATA_CALL,
                                    CM_ACT_PRIORITY_80,
                                    CM_ACT_PRIORITY_BELOW_PH,
                                    TRUE );

      (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                    CM_ACT_TYPE_DATA_CALL,
                                    CM_ACT_PRIORITY_END,
                                    CM_ACT_PRIORITY_BELOW_PH,
                                    TRUE );
    }

    (void)cmtask_orig_para_change_act_priority( CM_SS_MAIN,
                                  CM_ACT_TYPE_DATA_CALL,
                                  CM_ACT_PRIORITY_80,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );

    (void)cmtask_orig_para_change_act_priority( CM_SS_MAIN,
                                  CM_ACT_TYPE_DATA_CALL,
                                  CM_ACT_PRIORITY_END,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );
  }


 if( act_update_reas == CM_ACT_UPDATE_REAS_USER ||
     act_update_reas == CM_ACT_UPDATE_REAS_ACT_END )
  {
    /* This is because of a user activity
    ** bump down the priority of all data calls
  */

    (void)cmtask_orig_para_change_act_priority( CM_SS_MAIN,
                                CM_ACT_TYPE_DATA_CALL,
                                CM_ACT_PRIORITY_80,
                                CM_ACT_PRIORITY_BELOW_PH,
                                TRUE );

    (void)cmtask_orig_para_change_act_priority( CM_SS_MAIN,
                                CM_ACT_TYPE_DATA_CALL,
                                CM_ACT_PRIORITY_END,
                                CM_ACT_PRIORITY_BELOW_PH,
                                TRUE );

    if(cmph_is_subs_feature_mode_1x_sxlte(asubs_id) && cmss_is_hybr2_operational())
    {
      (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                  CM_ACT_TYPE_DATA_CALL,
                                  CM_ACT_PRIORITY_80,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );
      (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                  CM_ACT_TYPE_DATA_CALL,
                                  CM_ACT_PRIORITY_END,
                                  CM_ACT_PRIORITY_BELOW_PH,
                                  TRUE );

    }
 }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If there is a activity and we are setting the mode to none or manual_idle,
  ** update the orig mode accordingly
  */
  ph_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_MAIN );

  if (ph_orig_top_ptr != NULL)
  { 
    CM_MSG_HIGH_6( "force_pref_on_the_fly(): ss=%d, act_type=%d, orig_mode(computed new)=%d orig user_mode_pref %d, update_reas %d, mode_pref %d",
                             ss, act_type, orig_mode,ph_orig_top_ptr->orig->user_mode_pref, act_update_reas, mode_pref);    
  }


  if ( act_update_reas ==  CM_ACT_UPDATE_REAS_USER &&
       force_reason != SD_SS_PREF_REAS_MULTIMODE_SCAN &&
       network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV &&
       network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV &&
       ( ( ph_orig_top_ptr != NULL   &&
           ph_orig_top_ptr->orig->orig_mode != SD_SS_ORIG_MODE_NONE &&
           ph_orig_top_ptr->orig->orig_mode != SD_SS_ORIG_MODE_MANUAL_IDLE
          )
          ||
          ( cmtask_orig_para_count_2( CM_SS_MAIN,
                                      CM_ACT_PRIORITY_END,
                                      CM_CMP_CRITERIA_GREATER_THAN) >= 1
          )
        )
     )
  {
    if( orig_mode ==  SD_SS_ORIG_MODE_MANUAL_IDLE )
    {
       orig_mode =  SD_SS_ORIG_MODE_MANUAL_ORIG;
    }
    else
    {
       orig_mode = SD_SS_ORIG_MODE_NORMAL;
    }
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If current origination mode is EMERG_CB and we're originating a call
  ** other than emrgency (for example, PD), set new orig mode to
  ** SD_SS_ORIG_MODE_EMERG_CB
  */
  if( act_type                        != CM_ACT_TYPE_EMERG_CALL &&
      act_type                        != CM_ACT_TYPE_PH_OBJ     &&
      ph_orig_top_ptr                 != NULL                   &&
      ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_CB )
  {
    CM_MSG_LOW_0("orig_mode (in callback) = SD_SS_ORIG_MODE_EMERG_CB");
    orig_mode = SD_SS_ORIG_MODE_EMERG_CB;
  }

  /*
  ** Now figure out whether we need to exit emergency callback mode
  ** or continue in callback but with current preferences
  */
  if((orig_mode != SD_SS_ORIG_MODE_EMERG_CB) && (act_type != CM_ACT_TYPE_PH_OBJ))
  {

    /*
    ** If orig_mode is anything other than SD_SS_ORIG_MODE_EMERG_CB,
    ** exit emergency callback mode
    */
     cmph_exit_emergency_cb(ph_ptr, FALSE,ss,FALSE);
  }

  #ifdef CM_GW_SUPPORTED
  if (act_type == CM_ACT_TYPE_EMERG_CALL )
  {
    cmwcall_set_lmtd_srvc_req ();
  }
  #endif  /* FEATURE_WCDMA || FEATURE_GSM */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the caller of this function wants to use existing system selection
  ** preferences, do so.
  */

  /* Top element of MAIN already accessed
  */

  if(ss != CM_SS_MAX)
  {
    ph_orig_top_ptr = cmtask_orig_para_get_top( ss );
  }
  else
  {
    /* If it's MAX, get the top ptr from MAIN.
    ** This could be due to emergency call or hybr_pref is toggled.
    ** In the back to back emergency call, we will be deleting the orig_top_ptr
    ** acquired above, so we should acquire this back from the MAIN
    */
    ph_orig_top_ptr = cmtask_orig_para_get_top(CM_SS_MAIN);
  }

  if( ph_orig_top_ptr != NULL &&
      ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE )
  {

    if( mode_pref == CM_MODE_PREF_NO_CHANGE )
    {
      mode_pref = CMPH_SS_MODE_PREF(asubs_id, ph_ptr);
    }

    if( band_pref == CM_BAND_PREF_NO_CHANGE )
    {
      band_pref = CMPH_SS_BAND_PREF(asubs_id, ph_ptr);
    }

    if( SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&lte_band_pref, &lte_band_pref_no_chg) )
    {
      lte_band_pref = CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr);
    }

    if( tds_band_pref == CM_BAND_PREF_NO_CHANGE )
    {
      tds_band_pref = CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr);
    }

    if( prl_pref == CM_PRL_PREF_NO_CHANGE )
    {
      prl_pref = CMPH_SS_PRL_PREF(asubs_id, ph_ptr);;
    }

    if( roam_pref == CM_ROAM_PREF_NO_CHANGE )
    {
      roam_pref = CMPH_SS_ROAM_PREF(asubs_id, ph_ptr);
    }

    if( hybr_pref == CM_HYBR_PREF_NO_CHANGE )
    {
      hybr_pref = CMPH_SS_HYBR_PREF(asubs_id, ph_ptr);
      if (asubs_id == ph_ptr->main_stack_info.asubs_id)
      {
        int_hybr_pref = ph_ptr->int_hybr_pref;
      }
      else
      {
        int_hybr_pref = cmph_map_cm_hybr_pref_to_sd_hybr_pref(hybr_pref);
      }
    }
    else
    {
      int_hybr_pref =
      cmph_map_cm_hybr_pref_to_sd_hybr_pref( hybr_pref );
    }

    if ( srv_domain_pref == CM_SRV_DOMAIN_PREF_NO_CHANGE )
    {
      srv_domain_pref = CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr);
    }

    if( acq_order_pref == CM_GW_ACQ_ORDER_PREF_NO_CHANGE )
    {
      acq_order_pref = CMPH_SS_ACQ_ORDER_PREF(asubs_id, ph_ptr);
    }

  }
  else
  {
    if( mode_pref == CM_MODE_PREF_NO_CHANGE )
    {
      mode_pref = ( ph_orig_top_ptr != NULL                   ?
                    ph_orig_top_ptr->orig->orig_mode_pref :
                    CMPH_SS_MODE_PREF(asubs_id, ph_ptr));
    }

    if( band_pref == CM_BAND_PREF_NO_CHANGE )
    {
      band_pref = ( ph_orig_top_ptr != NULL                   ?
                    ph_orig_top_ptr->orig->orig_band_pref :
                    CMPH_SS_BAND_PREF(asubs_id, ph_ptr));
    }

    if( SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&lte_band_pref, &lte_band_pref_no_chg) )
    {
      lte_band_pref = ( ph_orig_top_ptr != NULL                   ?
                    ph_orig_top_ptr->orig->orig_lte_band_pref :
                    CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr));
    }

    if( tds_band_pref == CM_BAND_PREF_NO_CHANGE )
    {
      tds_band_pref = ( ph_orig_top_ptr != NULL                   ?
                    ph_orig_top_ptr->orig->orig_tds_band_pref :
                    CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr));
    }

    if( prl_pref == CM_PRL_PREF_NO_CHANGE )
    {
      prl_pref = ( ph_orig_top_ptr != NULL                   ?
                    ph_orig_top_ptr->orig->orig_prl_pref :
                    CMPH_SS_PRL_PREF(asubs_id, ph_ptr));
    }

    if( roam_pref == CM_ROAM_PREF_NO_CHANGE )
    {
      roam_pref = ( ph_orig_top_ptr != NULL                   ?
                    ph_orig_top_ptr->orig->orig_roam_pref :
                    CMPH_SS_ROAM_PREF(asubs_id, ph_ptr));
    }

    if( hybr_pref == CM_HYBR_PREF_NO_CHANGE )
    {
      sd_ss_hybr_pref_e_type  tmp_int_hybr_pref;
      hybr_pref = ( ph_orig_top_ptr != NULL                   ?
                    ph_orig_top_ptr->orig->orig_hybr_pref :
                    CMPH_SS_HYBR_PREF(asubs_id, ph_ptr));

      if (asubs_id == ph_ptr->main_stack_info.asubs_id)
      {
        tmp_int_hybr_pref = ph_ptr->int_hybr_pref;
      }
      else
      {
        tmp_int_hybr_pref = cmph_map_cm_hybr_pref_to_sd_hybr_pref(hybr_pref);
      }

      int_hybr_pref = ( ph_orig_top_ptr != NULL                ?
                        ph_orig_top_ptr->orig->orig_int_hybr_pref :
                        tmp_int_hybr_pref);
    }
    else
    {
      int_hybr_pref = cmph_map_cm_hybr_pref_to_sd_hybr_pref( hybr_pref );
    }

    if ( srv_domain_pref == CM_SRV_DOMAIN_PREF_NO_CHANGE )
    {
      srv_domain_pref = ( ph_orig_top_ptr != NULL                         ?
                          ph_orig_top_ptr->orig->orig_srv_domain_pref :
                          CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr) );
    }

    if( acq_order_pref == CM_GW_ACQ_ORDER_PREF_NO_CHANGE )
    {
      acq_order_pref = ph_ptr->main_stack_info.pref_info.acq_order_pref;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If specified mode and band preference combination is not valid for this
  ** target or not supported by the currently loaded PRL, use existing mode
  ** and band preferences.
  */
  if(
      ph_ptr->is_mode_change_due_to_ef_rat == FALSE &&
     (SD_SS_ORIG_MODE_EMERG_ORIG != orig_mode ||
      (int)CM_ACT_TYPE_EMERG_CALL!= (int)act_type) &&
     (cmph_is_valid_mode_band_pref(mode_pref, band_pref) == FALSE)
      #ifdef FEATURE_CM_LTE
      &&  ! cmph_is_valid_lte_mode_band_pref(mode_pref, lte_band_pref)
      #endif
      &&  ! cmph_is_valid_tds_mode_band_pref( mode_pref, tds_band_pref)
      && (ph_ptr->is_mode_pref_none == FALSE)
      && !(ph_ptr->main_stack_info.pref_info.mode_pref == CM_MODE_PREF_LTE_ONLY && 
          srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY)
    )
  {
    if(mode_pref != CM_MODE_PREF_NONE)
    {
    CM_MSG_HIGH_3( "Invalid mode/band pref mp=%d, bp= 0x%08x %08x", mode_pref,
            QWORD_HIGH(band_pref),QWORD_LOW(band_pref) );
    mode_pref = ph_ptr->main_stack_info.pref_info.mode_pref;
    band_pref = ph_ptr->main_stack_info.pref_info.band_pref;
    tds_band_pref = ph_ptr->main_stack_info.pref_info.tds_band_pref;
    #ifdef FEATURE_CM_LTE
    lte_band_pref = ph_ptr->main_stack_info.pref_info.lte_band_pref;
    #endif

    CM_MSG_HIGH_3("Switch to use current mp=%d and bp= 0x%08x %08x instead",
                mode_pref, QWORD_HIGH(band_pref),QWORD_LOW(band_pref));
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if hybrid is toggled for origination, if it is toggled
  ** as a result of sys_pref_change, then clear the HDR Q and send
  ** the sys_pref down
  */

  /* If system selection preference is forced in order to originate a call
  ** (i.e., the origination mode is other than none), only change the
  ** origination mode preference.
  */
  if( act_update_reas != CM_ACT_UPDATE_REAS_USER &&
      act_update_reas != CM_ACT_UPDATE_REAS_ACT_END &&
      act_update_reas != CM_ACT_UPDATE_REAS_ACT_PWR_SAVE )
  {

    /* Insert the origination parameters in the priority queue
    */

    is_top_ptr_changed = cmph_insert_orig_mode( ss,
                           orig_mode,
                           act_type,
                           force_term,
                           mode_pref,
                           band_pref,
                           lte_band_pref,
                           tds_band_pref,
                           prl_pref,
                           roam_pref,
                           hybr_pref,
                           int_hybr_pref,
                           srv_domain_pref,
                           act_id,
                           act_update_reas,
                           CM_DEFAULT_VALUE,
                           csg_id,
                           csg_rat
                         );

  }
  /* Else, update the phone state to reflect the new preferences.
  */
  else if( act_update_reas == CM_ACT_UPDATE_REAS_USER ||
         act_update_reas == CM_ACT_UPDATE_REAS_ACT_END )
  {
    /* should not enter this function if MSIM and act_reas_user */
    if (cmph_is_msim() &&
      (asubs_id == SYS_MODEM_AS_ID_2 || asubs_id == SYS_MODEM_AS_ID_3))
    {
      CM_ERR_2("MSIM: act_update_reas %d on asubs_id %d is not expected!!!",
                       act_update_reas, asubs_id);
    }

    ph_ptr->main_stack_info.pref_info.pref_term       = force_term;
    ph_ptr->main_stack_info.pref_info.mode_pref       = mode_pref;
    ph_ptr->main_stack_info.pref_info.band_pref       = band_pref;
    ph_ptr->main_stack_info.pref_info.lte_band_pref   = lte_band_pref;
    ph_ptr->main_stack_info.pref_info.tds_band_pref   = tds_band_pref;
    ph_ptr->main_stack_info.pref_info.prl_pref        = prl_pref;
    ph_ptr->main_stack_info.pref_info.roam_pref       = roam_pref;
    ph_ptr->main_stack_info.pref_info.hybr_pref       = hybr_pref;
    ph_ptr->int_hybr_pref   = int_hybr_pref;
    ph_ptr->main_stack_info.pref_info.srv_domain_pref = srv_domain_pref;
    ph_ptr->main_stack_info.pref_info.csg_id          = csg_id;
    ph_ptr->main_stack_info.pref_info.csg_rat         = csg_rat;

    /* If main Q changed then send pref_sys changed to both MAIN and HDR
    ** If only HDR changed, and Hybrid is toggled, then don't send
    ** pref sys changed down
    */
    {
      cm_act_update_reas_e_type        ph_obj_act_update_reas;
      ph_obj_act_update_reas = cmtask_orig_para_get_act_update_reas_per_pref_reason(force_reason, CM_SS_MAIN, act_update_reas);
      is_main_top_ptr_changed = cmph_insert_orig_mode (
                                  CM_SS_MAIN,
                                  SD_SS_ORIG_MODE_NONE,
                                  CM_ACT_TYPE_PH_OBJ,
                                  ph_ptr->main_stack_info.pref_info.pref_term,
                                  mode_pref,
                                  ph_ptr->main_stack_info.pref_info.band_pref,
                                  ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                  ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                  ph_ptr->main_stack_info.pref_info.prl_pref,
                                  ph_ptr->main_stack_info.pref_info.roam_pref,
                                  ph_ptr->main_stack_info.pref_info.hybr_pref,
                                  ph_ptr->int_hybr_pref,
                                  ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                  (cm_act_id_type)ph_ptr,
                                  ph_obj_act_update_reas,
                                  req_id,
                                  csg_id,
                                  csg_rat
                                );
    }

    /* Force Pref On The Fly: is used to force the preference. In this particular
    ** section, the condition is that act_update_reas = USER / ACT_END.
    ** For SVLTE, whenver user is forced on single stack, it will be updated on both.
    ** For SGLTE, we should only update hybr-2 if the ss is HYBR-2. This is different
    ** behavior because we are migrating to cmmsc architecture, where we treats each
    ** stack independently.
    */
    if ( (CMPH_SS_FEATURE_MODE(ss,cmph_ptr()) == SYS_SUBS_FEATURE_MODE_SVLTE) ||
       (CMPH_SS_FEATURE_MODE(ss,cmph_ptr()) == SYS_SUBS_FEATURE_MODE_SRLTE) ||
       ((CMPH_SS_FEATURE_MODE(ss,cmph_ptr()) == SYS_SUBS_FEATURE_MODE_SGLTE) &&
         (ss == CM_SS_MAX || ss == CM_SS_HYBR_2)))
    {
      cm_act_update_reas_e_type        ph_obj_act_update_reas;
      ph_obj_act_update_reas = cmtask_orig_para_get_act_update_reas_per_pref_reason(force_reason, CM_SS_HYBR_2, act_update_reas);
      is_hybr_2_top_ptr_changed = cmph_insert_orig_mode (
                                  CM_SS_HYBR_2,
                                  SD_SS_ORIG_MODE_NONE,
                                  CM_ACT_TYPE_PH_OBJ,
                                  ph_ptr->main_stack_info.pref_info.pref_term,
                                  mode_pref,
                                  ph_ptr->main_stack_info.pref_info.band_pref,
                                  ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                  ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                  ph_ptr->main_stack_info.pref_info.prl_pref,
                                  ph_ptr->main_stack_info.pref_info.roam_pref,
                                  ph_ptr->main_stack_info.pref_info.hybr_pref,
                                  ph_ptr->int_hybr_pref,
                                  ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                  (cm_act_id_type)ph_ptr,
                                  ph_obj_act_update_reas,
                                  req_id,
                                  csg_id,
                                  csg_rat
                                );
    }
    {
      cm_act_update_reas_e_type        ph_obj_act_update_reas;
      ph_obj_act_update_reas = cmtask_orig_para_get_act_update_reas_per_pref_reason(force_reason, CM_SS_HDR, act_update_reas);
      is_hybr_1_top_ptr_changed = cmph_insert_orig_mode (
                                  CM_SS_HDR,
                                  SD_SS_ORIG_MODE_NONE,
                                  CM_ACT_TYPE_PH_OBJ,
                                  ph_ptr->main_stack_info.pref_info.pref_term,
                                  mode_pref,
                                  ph_ptr->main_stack_info.pref_info.band_pref,
                                  ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                  ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                  ph_ptr->main_stack_info.pref_info.prl_pref,
                                  ph_ptr->main_stack_info.pref_info.roam_pref,
                                  ph_ptr->main_stack_info.pref_info.hybr_pref,
                                  ph_ptr->int_hybr_pref,
                                  ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                  (cm_act_id_type)ph_ptr,
                                  ph_obj_act_update_reas,
                                  req_id,
                                  SYS_CSG_ID_INVALID,
                                  SYS_RAT_NONE
                                 );
    }

    is_hybr_1_top_ptr_changed = TRUE;

  if (ph_orig_top_ptr != NULL)
  {	
    CM_MSG_HIGH_3( "is_hybr_1_top_ptr_changed=%d main %d ph_orig_top_ptr->orig->user_mode_pref = %d",
               is_hybr_1_top_ptr_changed,
                   is_main_top_ptr_changed,
                              ph_orig_top_ptr->orig->user_mode_pref);
  }


  }
  else if( act_update_reas == CM_ACT_UPDATE_REAS_ACT_PWR_SAVE )
  {
    mode_pref = CM_MODE_PREF_NONE;

    /* Insert the origination parameters in the priority queue
    */
    (void) cmph_insert_orig_mode( ss,
                           orig_mode,
                           act_type,
                           force_term,
                           mode_pref,
                           band_pref,
                           lte_band_pref,
                           tds_band_pref,
                           prl_pref,
                           roam_pref,
                           hybr_pref,
                           int_hybr_pref,
                           srv_domain_pref,
                           act_id,
                           act_update_reas,
                           CM_DEFAULT_VALUE,
                           csg_id,
                           csg_rat
                         );
    is_top_ptr_changed = TRUE;
  }

  /* Print the ptr changed flags */
  CM_MSG_HIGH_4("is_top_ptr_changed = %d, top_ptr_changed: main %d, hybr_1 %d, hybr_2 %d",
               is_top_ptr_changed,
               is_main_top_ptr_changed,
               is_hybr_1_top_ptr_changed,
               is_hybr_2_top_ptr_changed);



  /* Update local variable ph_orig_top_ptr as priority queue may have changed
  */
  if(ss != CM_SS_MAX)
  {
    ph_orig_top_ptr = cmtask_orig_para_get_top(ss);
  }
  else
  {
    ph_orig_top_ptr = cmtask_orig_para_get_top(CM_SS_MAIN);
  }

  /* Notify MC of mode preference change.
  */
  if( is_top_ptr_changed ||
      ( is_main_top_ptr_changed
        && is_hybr_1_top_ptr_changed
        && ( !cmph_is_subs_feature_mode_1x_sxlte(asubs_id) ||
             (cmph_is_subs_feature_mode_1x_sxlte(asubs_id) && is_hybr_2_top_ptr_changed))
        && ( !cmph_is_subs_feature_mode_sglte(asubs_id) ||
             (cmph_is_subs_feature_mode_sglte(asubs_id) && is_hybr_2_top_ptr_changed))
      )
    )
  {
    boolean read_new_policy = cmph_is_new_policy_apply(ss);

    /* Dynamically allocate memory pref info ptr */
    cm_pref_s_type  *pref_info_ptr = cm_mem_malloc( sizeof(cm_pref_s_type ));

    /*
    CM_MSG_HIGH_6( "cmmsimc_proc_cmd_pref_sys_chgd() :ss  %d, as_id %d, mode  %d ,force_reason  %d, act_type  %d, net_sel  %d",
                   ss, cmph_map_cm_ss_to_subs(ss), mode_pref ,
                   force_reason, act_type, network_sel_mode_pref );
   
    CM_MSG_HIGH_6( "prl_pref  %d, roam_pref  %d, hybr_pref  %d ,srv_domain_pref  %d, otasp_act_code  %d, force_term  %d", prl_pref,
                   roam_pref, hybr_pref,
                srv_domain_pref, otasp_act_code, force_term );

    CM_MSG_HIGH_4( "bands: cgw 0x%08x %08x, tds 0x%08x %08x",
                                    QWORD_HIGH(band_pref),
                                    QWORD_LOW(band_pref),
                                    QWORD_HIGH(tds_band_pref),
                                    QWORD_LOW(tds_band_pref));

    cm_print_lte_band_mask(lte_band_pref);

    */
    pref_info_ptr->acq_order_pref = acq_order_pref;
    pref_info_ptr->band_pref = band_pref;
    pref_info_ptr->hybr_pref = hybr_pref;
    pref_info_ptr->lte_band_pref = lte_band_pref;
    pref_info_ptr->tds_band_pref = tds_band_pref;
    pref_info_ptr->mode_pref = mode_pref;
    pref_info_ptr->prl_pref = prl_pref;
    pref_info_ptr->roam_pref = roam_pref;
    pref_info_ptr->srv_domain_pref = srv_domain_pref;
    pref_info_ptr->network_sel_mode_pref = network_sel_mode_pref;
    pref_info_ptr->pref_term = force_term;

#if (defined(FEATURE_LTE_TO_1X) && defined(FEATURE_MMODE_SC_SVLTE)) || defined(FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH)
    pref_info_ptr->pref_update_reason = cmsoa_get_pref_update_reason();
    if ( pref_info_ptr->pref_update_reason == SD_SS_PREF_UPDATE_REASON_NONE)
    {
      /* when CMSOA decided to switch to SRLTE but the prefs were
      ** not forced due to high priority activity .
      ** after this SOA cleared pref_update_reason,
      ** Hence we enter this if block .
      ** but that is copied to ph_orig_top_ptr .
      ** which we need to use when we are forcing the phobj ,
      ** after call is ended
      */    
      if(ph_orig_top_ptr != NULL)
      {
        pref_info_ptr->pref_update_reason = ph_orig_top_ptr->orig->pref_update_reason;
      }
    }
#endif

    *(&(pref_info_ptr->plmn)) = plmn_id;

    cmmsc_pack_cmd_for_pref_sys_chgd_per_pref(
        ss,
        force_reason,
        orig_mode,
        pref_info_ptr,
        cmph_map_otasp_act_code_to_sd_band( otasp_act_code ),
        cmph_map_otasp_act_code_to_sd_blksys( otasp_act_code ),
        SD_SS_AVOID_SYS_IDLE,
        0,
        rat_acq_order_pref_ptr,
        cmph_map_cm_net_sel_mode_pref_to_camp_pref(network_sel_mode_pref),
        read_new_policy,
        act_update_reas,
        &cmd
        );

    cmmsimc_proc_cmd_pref_sys_chgd(&cmd);

    /* Free the memory */
    if ( pref_info_ptr != NULL)
    {
      cm_mem_free(pref_info_ptr );
    }

    /* Phone is going to do a rescan, so indicate a ballpark estimation
    ** for the number of seconds it takes the phone to do the rescan and
    ** reacquire service.
    */

    rescan_time = CMPH_RESCAN_TIME;

    /* Search the Q for the phone object and change the update reason to
    ** act_start, if we don't do this, then every time the ph pref are forced
    ** the reason will be user
    */

    if( act_update_reas ==  CM_ACT_UPDATE_REAS_USER )
    {
      cm_orig_q_s_type *queue_entry;
      sys_modem_as_id_e_type asubs_id;
      ss = (ss == CM_SS_MAX)? CM_SS_MAIN: ss;
      asubs_id = cmph_map_cm_ss_to_subs(ss);

      queue_entry = cmtask_orig_para_search_act_id( CM_SS_MAIN, (cm_act_id_type)ph_ptr );
      if(queue_entry != NULL)
      {
        queue_entry->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_START;
      }
      else
      {
        CM_ERR_0( "MAIN queue has no entry for ph!!");
      }

      if (cmph_is_subs_feature_mode_1x_sxlte(asubs_id) ||
          cmph_is_subs_feature_mode_sglte(asubs_id))
      {
        queue_entry = cmtask_orig_para_search_act_id( CM_SS_HYBR_2, (cm_act_id_type)ph_ptr );
        if(queue_entry != NULL)
        {
          queue_entry->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_START;
        }
        else
        {
          CM_ERR_0( "hybr 2 queue has no entry for ph!!");
        }
      }

      queue_entry = cmtask_orig_para_search_act_id( CM_SS_HDR, (cm_act_id_type )ph_ptr);
      if(queue_entry != NULL)
      {
        queue_entry->orig->act_update_reas = CM_ACT_UPDATE_REAS_ACT_START;
      }
      else
      {
        CM_ERR_0( "HDR queue has no entry for ph!!");
      }

    }
    else if( act_update_reas ==  CM_ACT_UPDATE_REAS_ACT_START )
    {
      cmph_set_act_update_reas_for_pm_rest(ph_ptr, asubs_id);
    }
  }
  else if( force_top_pref )
  {
    /* Use the top ptr and force the mode, because we wait for OK to orig
    */
    if( ph_orig_top_ptr == NULL )
    {
      CM_ERR_0( "ph_orig_top_ptr is NULL");
      return rescan_time;
    }
    /*
    CM_MSG_HIGH_5( "cmmsimc_proc_cmd_pref_sys_chgd(): ss  %d, force_reason  %d, act_type  %d mode_pref  %d force_term  %d",
                  ss, force_reason, act_type, ph_orig_top_ptr->orig->orig_mode_pref, force_term );

    CM_MSG_HIGH_5( "prl_pref  %d, roam_pref  %d, hybr_pref  %d srv_domain_pref  %d, otasp_act_code  %d",
                  ph_orig_top_ptr->orig->orig_prl_pref,
                  ph_orig_top_ptr->orig->orig_roam_pref,
                   ph_orig_top_ptr->orig->orig_hybr_pref,
                   ph_orig_top_ptr->orig->orig_srv_domain_pref, otasp_act_code);

    CM_MSG_HIGH_4( "bands: cgw 0x%08x %08x tds 0x%08x %08x",
                                    QWORD_HIGH(ph_orig_top_ptr->orig->orig_band_pref),
                                    QWORD_LOW(ph_orig_top_ptr->orig->orig_band_pref),
                                    QWORD_HIGH(ph_orig_top_ptr->orig->orig_tds_band_pref),
                                    QWORD_LOW(ph_orig_top_ptr->orig->orig_tds_band_pref));
    cm_print_lte_band_mask(ph_orig_top_ptr->orig->orig_lte_band_pref);
      */

      cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue (
          ss,
          force_reason,
          ph_orig_top_ptr->orig->orig_mode,
          cmph_is_new_policy_apply(ss),
          ph_orig_top_ptr,
          act_update_reas,
          &cmd
          );

      cmmsimc_proc_cmd_pref_sys_chgd(&cmd);
    }
  else if( is_main_top_ptr_changed )
  {
    /* Here, we're either forcing HYBR-1 or MAIN.
    ** For MAIN, we should force through cmmsc (in SGLTE)
    ** For HYBR-1, use normal path. (HYBR-1 is not applicable in SGLTE)
    */
    boolean read_new_policy = cmph_is_new_policy_apply(ss);

    /* Dynamically allocate memory pref info ptr */
    cm_pref_s_type  *pref_info_ptr = cm_mem_malloc( sizeof(cm_pref_s_type ));
    cm_orig_q_s_type* ph_obj_main = cmtask_orig_para_search_act_id( CM_SS_MAIN, (cm_act_id_type)cmph_ptr());

    /*
    CM_MSG_HIGH_6( "ss  %d, force_reason  %d, act_type  %d,mode_pref  %d, band_pref 0x%08x %08x",
                ss,force_reason,act_type,mode_pref, QWORD_HIGH(band_pref),QWORD_LOW(band_pref));
    cm_print_lte_band_mask(lte_band_pref);
    CM_MSG_HIGH_6( "prl_pref  %d, roam_pref  %d, hybr_pref  %ld,srv_domain_pref  %d, otasp_act_code  %d, force_term  %d",
                prl_pref, roam_pref, hybr_pref,srv_domain_pref,otasp_act_code,force_term);
    */
    pref_info_ptr->acq_order_pref = acq_order_pref;
    pref_info_ptr->band_pref = band_pref;
    pref_info_ptr->hybr_pref = hybr_pref;
    pref_info_ptr->lte_band_pref = lte_band_pref;
    pref_info_ptr->tds_band_pref = tds_band_pref;
    pref_info_ptr->mode_pref = mode_pref;
    pref_info_ptr->prl_pref = prl_pref;
    pref_info_ptr->roam_pref = roam_pref;
    pref_info_ptr->srv_domain_pref = srv_domain_pref;
    pref_info_ptr->network_sel_mode_pref = network_sel_mode_pref;
    pref_info_ptr->pref_term = force_term;

   #if (defined(FEATURE_LTE_TO_1X) && defined(FEATURE_MMODE_SC_SVLTE)) || defined(FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH)
   if(ph_obj_main)
   {
     CM_MSG_HIGH_2("old pref_update_reason %d new pref_update_reason %d",
                  ph_obj_main->orig->pref_update_reason,
                  cmsoa_get_pref_update_reason());
     if(cmsoa_get_pref_update_reason() != SD_SS_PREF_UPDATE_REASON_NONE)
     {
       ph_obj_main->orig->pref_update_reason = cmsoa_get_pref_update_reason();
     }
  }
   #endif

    *(&(pref_info_ptr->plmn)) = plmn_id;

    #ifdef FEATURE_MMODE_SC_SGLTE
    if(cmph_is_subs_feature_mode_sglte(asubs_id))
    {
      if(ss == CM_SS_MAX)
      {
        ss = CM_SS_MAIN;
        if(force_reason == SD_SS_PREF_REAS_USER_RESEL)
        {
          cmph_set_is_user_resel_buffered_ss(CM_SS_HYBR_2, TRUE);
        }
      }
    }
    #endif

    cmmsc_pack_cmd_for_pref_sys_chgd_per_pref(
        ss,
        force_reason,
        orig_mode,
        pref_info_ptr,
        cmph_map_otasp_act_code_to_sd_band( otasp_act_code ),
        cmph_map_otasp_act_code_to_sd_blksys( otasp_act_code ),
        SD_SS_AVOID_SYS_IDLE,
        0,
        rat_acq_order_pref_ptr,
        cmph_map_cm_net_sel_mode_pref_to_camp_pref(network_sel_mode_pref),
        read_new_policy,
        act_update_reas,
        &cmd
        );

    /* SGLTE only has MAIN (no HYBR-HDR)
    */
    cmmsimc_proc_cmd_pref_sys_chgd(&cmd);

    /* Free the memory */
    if ( pref_info_ptr != NULL)
    {
      cm_mem_free(pref_info_ptr );
    }
  }
  else
  {
    cm_orig_q_s_type* ph_obj_main = cmtask_orig_para_search_act_id( CM_SS_MAIN, (cm_act_id_type)cmph_ptr());
    cm_orig_q_s_type* stk_top_obj = cmtask_orig_para_get_top(ss);
    cm_act_type_e_type    act_type = CM_ACT_TYPE_NONE;

    if( stk_top_obj != NULL )
    {
      act_type = stk_top_obj->act_type;
    }
      CM_MSG_HIGH_2("Didn't force pref, low priority act, ss=%d, stack_top = %d",
                     ss, act_type);

    if( act_update_reas == CM_ACT_UPDATE_REAS_ACT_START )
    {
      cmph_set_act_update_reas_for_pm_rest(ph_ptr, asubs_id);
    }
    /* store the SOA pref_update_reason
    ** since we have to reuse it while force the ph obj
    */
#if (defined(FEATURE_LTE_TO_1X) && defined(FEATURE_MMODE_SC_SVLTE)) || defined(FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH)
   if(cmsoa_get_pref_update_reason() != SD_SS_PREF_UPDATE_REASON_NONE)
   {
     CM_MSG_HIGH_2("old pref_update_reason %d, new pref_update_reason %d",
                  ph_obj_main->orig->pref_update_reason,
                  cmsoa_get_pref_update_reason());

     ph_obj_main->orig->pref_update_reason = cmsoa_get_pref_update_reason();
   }
#endif
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  return rescan_time;

} /* cmph_force_pref_on_the_fly() */


/*===========================================================================

FUNCTION cmph_unforce_mode_on_the_fly

DESCRIPTION
  Unforce the mode preference on the fly

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  A ballpark estimation for the number of seconds it takes the phone to
  do a rescan and reacquiring service.

SIDE EFFECTS
  none

===========================================================================*/
dword cmph_unforce_mode_on_the_fly(

    cmph_s_type    *ph_ptr,
        /* Pointer to a phone object */

    cm_ss_e_type   ss
)
{
  dword                   rescan_time = 0;
  cm_pref_s_type         *hybr_2_pref_ptr = NULL;

  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
    cm_pref_s_type         *hybr_3_pref_ptr = NULL;
  #endif

  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Allocate buffer only if multi-sim */
  if (cmph_is_msim())
  {
    hybr_2_pref_ptr = cm_pref_ptr();
    memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                   &(CMPH_PRST_HYBR_2_PREF(ph_ptr)), sizeof(cm_pref_s_type));
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
    hybr_3_pref_ptr = cm_pref_ptr();
    memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                   &(CMPH_PRST_HYBR_3_PREF(ph_ptr)), sizeof(cm_pref_s_type));

   #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For targets with System Determination 2.0 support do the following
  ** processing.
  */

    if(ss!=CM_SS_HYBR_2 && ss!=CM_SS_HYBR_3)
    {
      ss = CM_SS_MAX;
    }
    rescan_time = cmph_force_pref_on_the_fly2(
                                        ss,
                                        ph_ptr,
                                        SD_SS_PREF_REAS_ORIG_END,
                                        CM_ACT_TYPE_NONE,
                                        CM_PREF_TERM_PERMANENT,
                                        CMPH_PRST_MODE_PREF(ph_ptr),
                                        CMPH_PRST_BAND_PREF(ph_ptr),
                                        CMPH_PRST_LTE_BAND_PREF(ph_ptr),
                                        CMPH_PRST_TDS_BAND_PREF(ph_ptr),
                                        CMPH_PRST_PRL_PREF(ph_ptr),
                                        CMPH_PRST_ROAM_PREF(ph_ptr),
                                        CMPH_PRST_HYBR_PREF(ph_ptr),
                                        ph_ptr->main_stack_info.pref_info.plmn,
                                        CMPH_PRST_SRV_DOMAIN_PREF(ph_ptr),
                                        ph_ptr->main_stack_info.pref_info.acq_order_pref,
                                        CM_NETWORK_SEL_MODE_PREF_NONE,
                                        hybr_2_pref_ptr,
                                        #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
                                        hybr_3_pref_ptr,
                                        #endif
                                        CM_OTASP_ACT_CODE_NONE,
                                        (cm_act_id_type)ph_ptr,
                                        CM_ACT_UPDATE_REAS_ACT_END,
                                        FALSE,
                                        cmph_get_acq_pri_order_per_sub(ss),
                                        CM_DEFAULT_VALUE,
                                        ph_ptr->main_stack_info.pref_info.csg_id,
                                        ph_ptr->main_stack_info.pref_info.csg_rat
                                        );

   /* Free allocated buffer */
   if (hybr_2_pref_ptr)
   {
     cm_mem_free (hybr_2_pref_ptr);
   }

   #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
   /* Free allocated buffer */
   if (hybr_3_pref_ptr)
   {
     cm_mem_free (hybr_3_pref_ptr);
   }
#endif
   return rescan_time;
} /* cmph_unforce_mode_on_the_fly() */


/**--------------------------------------------------------------------------
** Functions - external, cdma
** --------------------------------------------------------------------------
*/


/*===========================================================================

FUNCTION cmph_is_valid_mode_pref

DESCRIPTION
  Check whether a given mode preference is valid.

DEPENDENCIES
  none

RETURN VALUE
  TRUE if mode preference is valid, FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_valid_mode_pref(

    cm_mode_pref_e_type     mode_pref,
        /* mode preference to check */

    sys_modem_as_id_e_type  asubs_id
)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  CM_ASSERT( BETWEEN(mode_pref, CM_MODE_PREF_NONE, CM_MODE_PREF_MAX) );
  CM_ASSERT( BETWEEN(asubs_id, SYS_MODEM_AS_ID_NONE, SYS_MODEM_AS_ID_NO_CHANGE) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For targets with System Determination 2.0 support, do the following:
  */
  #ifdef FEATURE_CM_LTE
  if( mode_pref == CM_MODE_PREF_LTE_ONLY )
  {
    return cmph_is_valid_lte_mode_band_pref(
               mode_pref, CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr));
  }
  else if(sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref),
                               SD_SS_MODE_PREF_LTE))
  {
    return (cmph_is_valid_lte_mode_band_pref(
                mode_pref, CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr)) ||
            cmph_is_valid_mode_band_pref(
                mode_pref, CMPH_SS_BAND_PREF(asubs_id, ph_ptr)) ||
            cmph_is_valid_tds_mode_band_pref(
                mode_pref, CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr)));
  }
  else
  #endif /* (FEATURE_CM_LTE) */
  if (mode_pref == CM_MODE_PREF_TDS_ONLY)
  {
    return cmph_is_valid_tds_mode_band_pref(
                mode_pref, CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr));
  }
  else
  {
    return (cmph_is_valid_mode_band_pref(
               mode_pref, CMPH_SS_BAND_PREF(asubs_id, ph_ptr)) ||
            cmph_is_valid_tds_mode_band_pref(
               mode_pref, CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr)));
  }

} /* cmph_is_valid_mode_pref() */

/*===========================================================================

FUNCTION cmph_is_valid_call_mode_pref_on_ss

DESCRIPTION
  Check whether a given mode preference is valid.

DEPENDENCIES
  none

RETURN VALUE
  TRUE if mode preference is valid, FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_valid_call_mode_pref_on_ss(

        cm_ss_e_type           ss,

        cm_mode_pref_e_type    mode_pref,
        /* mode preference to check */

        const cm_cmd_type   *cmd_ptr
)
{

  cmph_s_type    *ph_ptr  = cmph_ptr();
  sys_modem_as_id_e_type   asubs_id = cmph_map_cm_ss_to_subs(ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( BETWEEN(mode_pref, CM_MODE_PREF_NONE, CM_MODE_PREF_MAX) );
  CM_ASSERT_ENUM_IS_INRANGE(asubs_id, SYS_MODEM_AS_ID_MAX);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (cmd_ptr != NULL)
  {
    /*
    ** This function checks if a call mode preference is valid. This check
    ** below helps to eliminate the race condition when the phone is power
    ** up, or moving from LPM --> ONLINE, before the PRL is intialized,
    ** and emergency call was made, we would still have to honor it.
    **
    ** This fix does not support the emergency call over VOIP.
    */
    if (CMD_TYPE(cmd_ptr) == CM_CMD_TYPE_CALL)
    {
      /*
      ** We need to allow type VOICE to pass the PRL check in the phase
      ** CM_CALL_CMD_ORIG because at this phase, a call type voice still
      ** can potentially be an EMERGENCY call.
      */
      if(CALL_CMD_PTR(cmd_ptr)->cmd == CM_CALL_CMD_ORIG &&
        (CALL_CMD_PTR(cmd_ptr)->info.call_type == CM_CALL_TYPE_VOICE ||
         CALL_CMD_PTR(cmd_ptr)->info.call_type == CM_CALL_TYPE_EMERGENCY))
      {
        return TRUE;
      }
    }
  }

  /* For targets with System Determination 2.0 support, do the following:
  */

  #ifdef FEATURE_CM_LTE
  if( mode_pref == CM_MODE_PREF_LTE_ONLY )
  {
    return cmph_is_valid_lte_mode_band_pref(
               mode_pref, CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr));
  }
  else if(sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(mode_pref), SD_SS_MODE_PREF_LTE))
  {
    return (cmph_is_valid_lte_mode_band_pref(
                mode_pref, CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr)) ||
            cmph_is_valid_mode_band_pref(
                mode_pref, CMPH_SS_BAND_PREF(asubs_id, ph_ptr)) ||
            cmph_is_valid_tds_mode_band_pref(
                mode_pref, CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr)));
  }
  else
  #endif /* (FEATURE_CM_LTE) */
  {
    return (cmph_is_valid_mode_band_pref(
               mode_pref, CMPH_SS_BAND_PREF(asubs_id, ph_ptr)) ||
            cmph_is_valid_tds_mode_band_pref(
               mode_pref, CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr)));
  }

} /* cmph_is_valid_mode_pref_on_ss() */


#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))

/*===========================================================================

FUNCTION cmph_mo_sms_end

DESCRIPTION
  Does necessary phone's MO SMS end activities.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_mo_sms_end(

    dword          duration,
       /* duration in seconds to delay unforcing the mode */

    cm_act_id_type   act_id
       /* The id of the activity, used to access the orig parameter Q */
)
{

  cm_orig_q_s_type *computed_orig =  cmtask_orig_para_search_act_id  ( CM_SS_MAIN,
                                                                 act_id );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if( computed_orig != NULL )
  {

    CM_MSG_LOW_2("orig_pref_term = %d, orig_mode_uptime = %d",
                computed_orig->orig->orig_pref_term,
                computed_orig->orig->orig_mode_uptime);

    /* Wait <duration> seconds for retransmission or message center ack for the
    ** sms then allow system determination to do it's normal thing.
    */
    if( cmtask_orig_para_count_2( CM_SS_MAIN,
                                  CM_ACT_PRIORITY_END,
                                  CM_CMP_CRITERIA_GREATER_THAN) > 1)
    {
      /* Remove this q_ptr from the queue
      */
      if (cmtask_orig_para_delete( CM_SS_MAIN, computed_orig, TRUE ) )
      {
        cmph_force_orig_mode_on_the_fly(CM_SS_MAIN);
      }

    }
    else
    {

      computed_orig->orig->orig_pref_term   = CM_PREF_TERM_CM_1_CALL_PLUS;
      computed_orig->orig->orig_mode_uptime = time_get_uptime_secs() + duration;
      if( cmph_cmp_act_priorities(computed_orig->orig->act_priority, CM_ACT_PRIORITY_END ))
      {
        computed_orig->orig->act_priority   = CM_ACT_PRIORITY_END;
      }
    }
  }

} /* cmph_mo_sms_end() */



/*===========================================================================

FUNCTION cmph_mc_rpt_proc

DESCRIPTION
  Process MC reports (i.e. notifications of phone activity or
  replies to clients phone commands).


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_mc_rpt_proc(

  const cm_hdr_type   *rpt_ptr
    /* Pointer to MC report */
)
{
  /*lint -save -e826 */
  const cm_mc_rpt_type    *cm_mc_rpt_ptr = (cm_mc_rpt_type *) rpt_ptr;
  /*lint -restore */
      /* Pointer to MC report */

  cmph_s_type                    *ph_ptr        = cmph_ptr();
      /* Point at phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( cm_mc_rpt_ptr != NULL );
  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Do command specific processing as follows:
  ** 1. Updating appropriate phone object fields.
  ** 2. Notifying clients of event if necessary.
  */

  switch( cm_mc_rpt_ptr->hdr.cmd )
  {
    /* CDMA Lock order.
    */
    case CM_LOCK_F:
      ph_ptr->cdma_lock_mode = CM_CDMA_LOCK_MODE_ON;
      cmph_event( ph_ptr, CM_PH_EVENT_CDMA_LOCK_MODE );
      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* CDMA unlock.
    */
    case CM_UNLOCK_F:
      ph_ptr->cdma_lock_mode = CM_CDMA_LOCK_MODE_OFF;
      cmph_event( ph_ptr, CM_PH_EVENT_CDMA_LOCK_MODE );

      break;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #ifdef FEATURE_CM_SS_MEAS
    #error code not present
#endif /* FEATURE_CM_SS_MEAS */
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* CDMA maintenance required command
    */
    case CM_MAINTREQ_F:
      cmph_event( ph_ptr, CM_PH_EVENT_MAINTREQ );
      break;

    #ifdef  FEATURE_HDR_HYBRID
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_IDLE_PGSLOT_CHANGED_F:
      send_hdrmc_idle_pgslot_changed();
      break;



   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_HDR_HANDOFF
    case CM_HDR_RESELECT_EXIT_HDR_F:
      cmssidm_proc_hdr_reselect();
      break;
    #endif // FEATURE_HDR_HANDOFF
    #endif /* FEATURE_HDR_HYBRID*/


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_UMTS_1X_HANDOVER_1XMSM
    #error code not present
#endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:
      break;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is a reply to an earlier command we sent to MC,
  ** also do reply processing.
  */
  if( cm_reply_check(&ph_ptr->reply, cm_mc_rpt_ptr->hdr.cmd) )
  {
    /* Point at client command waiting for reply
    */
    cm_ph_cmd_s_type  *reply_cmd_ptr = (cm_ph_cmd_s_type*)cm_reply_get(&ph_ptr->reply);
    boolean wait_for_reply = FALSE;
    CM_ASSERT( reply_cmd_ptr != NULL );
    CM_ASSERT( CMD_TYPE(reply_cmd_ptr) == CM_CMD_TYPE_PH);

    if(cm_mc_rpt_ptr->hdr.cmd == CM_SRV_SYS_INFO_F)
    {

      wait_for_reply = cmph_client_cmd_forward_mmll(ph_ptr, reply_cmd_ptr);
    }

    if( !wait_for_reply )
    {
      /* Invoke the reply function with the appropriate error code.
      */
      cmph_client_cmd_mmll_reply( ph_ptr,
                                reply_cmd_ptr,
                                CM_PH_CMD_ERR_NOERR );

      /* We are done with processing the command that was waiting
      ** for reply - deallocate its command buffer.
      */
      cm_cmd_dealloc( reply_cmd_ptr );

      /* reset the reply info */
      cm_reply_init( &ph_ptr->reply );

      /* Turn on the signal that causes us to process any pending
      ** clients commands. This is necessary since we were NOT
      ** processing any clients commands while waiting for a reply
      ** from MC.
      */
      (void) rex_set_sigs( rex_self(), CM_CLIENT_CMD_Q_SIG );
    }
  }
} /* cmph_mc_rpt_proc() */



/*===========================================================================

FUNCTION cmph_send_nam_change_to_mc

DESCRIPTION
  Forward a MC_NAM_CHANGED_F command to MC.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  none

===========================================================================*/
void cmph_send_nam_change_to_mc(

    const cmph_s_type    *ph_ptr,
        /* Pointer to a phone object */

    cm_nam_e_type        nam
        /* The current NAM */
)
{
  cm_network_sel_mode_pref_e_type net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_NONE;
  cm_orig_q_s_type *ph_orig_top_ptr =
                            cmtask_orig_para_get_top( CM_SS_MAIN );
  cm_pref_s_type   *hybr_2_pref_ptr = NULL;

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  cm_pref_s_type   *hybr_3_pref_ptr = NULL;
  #endif
  
  CM_ASSERT( ph_ptr      != NULL );
  CM_ASSERT( BETWEEN(nam, CM_NAM_NONE, CM_NAM_AUTO) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Validate nam */
  if(!BETWEEN(nam, CM_NAM_NONE, NV_MAX_NAMS))
  {
    CM_ERR_1( "nam is invalid, nam change not sent, nam:%d",nam);
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Inform CM Pref & MMOC that subscription changed.
  ** Only CDMA gets a nam change so only cdma protocol stack has to
  ** reload NV information
  */
  if(!INRANGE(ph_ptr->curr_nam, 0, NV_MAX_NAMS))
  {
    CM_ERR_1( "invalid nam: %d", ph_ptr->curr_nam);
    return;
  }


  if( ph_orig_top_ptr != NULL &&
      ph_orig_top_ptr->act_type == CM_ACT_TYPE_POLICYMAN_RESTRICT )
  {
    if( ph_orig_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_EMERG_ORIG )
    {
      net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV;
    }
    else
    {
      switch(CMPH_PRST_NETWORK_SEL_MODE_PREF( ph_ptr ))
      {
         case CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY:
         case CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV:
         case CM_NETWORK_SEL_MODE_PREF_MANUAL:
           net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY;
           break;

         default:
           net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY;
           break;
      }
    }
  }
  else
  {
    net_sel_mode_pref = CMPH_PRST_NETWORK_SEL_MODE_PREF( ph_ptr );
  }

  /* Allocate buffer only if multi-sim */
  if (cmph_is_msim() && !cmph_no_hybr2())
  {
    hybr_2_pref_ptr = cm_pref_ptr();
    memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                  &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(cmph_is_sxlte() || cmph_is_tsts())
  {
    hybr_3_pref_ptr = cm_pref_ptr();
    memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                  &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
  }
  #endif

  cmmsimc_proc_cmd_subsc_chgd(
        MMOC_SUBSC_CHG_NAM_SEL,
        (byte) nam,
        net_sel_mode_pref,
        CMPH_PRST_MODE_PREF( ph_ptr ),
        CMPH_PRST_BAND_PREF( ph_ptr ),
        CMPH_PRST_LTE_BAND_PREF( ph_ptr ),
        CMPH_PRST_TDS_BAND_PREF( ph_ptr ),
        CMPH_PRST_PRL_PREF( ph_ptr ),
        CMPH_PRST_ROAM_PREF( ph_ptr ),
        CMPH_PRST_HYBR_PREF(ph_ptr),
        ph_ptr->main_stack_info.pref_info.plmn,
        CMPH_PRST_SRV_DOMAIN_PREF( ph_ptr),
        CMPH_PRST_ACQ_ORDER_PREF( ph_ptr ),
        hybr_2_pref_ptr,
        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        hybr_3_pref_ptr,
        #endif
        ph_ptr->is_gwl_subscription_available,
        ph_ptr->is_hybr_gw_subscription_available,
        ph_ptr->is_hybr_gw3_subscription_available,
        ph_ptr->is_cdma_subscription_available,
        PROT_SUBSC_CHG_CDMA,
        PROT_SUBSC_CHG_NONE,
        PROT_SUBSC_CHG_NONE
      );

   /* Free allocated buffer */
   if (hybr_2_pref_ptr)
   {
     cm_mem_free (hybr_2_pref_ptr);
   }

   #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
   if (hybr_3_pref_ptr)
   {
     cm_mem_free (hybr_3_pref_ptr);
   }
   #endif
} /* cmph_send_nam_change_to_mc() */



/*===========================================================================
FUNCTION cmph_get_user_mode_pref

DESCRIPTION
  This function get the user mode preference

DEPENDENCIES
  Phone object must be initialized

RETURNS
  persistent mode preference

SIDE EFFECTS
  none

===========================================================================*/
cm_mode_pref_e_type cmph_get_user_mode_pref (void)
{
  cmph_s_type          *ph_ptr  =  cmph_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If mode preference was temporarily forced by CM
  ** (i.e. mode term is orig or call), use persistent
  ** mode preference, else use current mode preference.
  */
  if( ph_ptr->main_stack_info.pref_info.pref_term == CM_PREF_TERM_CM_1_CALL ||
      ph_ptr->main_stack_info.pref_info.pref_term == CM_PREF_TERM_CM_1_CALL_PLUS ||
      ph_ptr->main_stack_info.pref_info.pref_term == CM_PREF_TERM_CM_MO_SMS )
  {
    if(INRANGE(ph_ptr->curr_nam, 0, NV_MAX_NAMS))
    {
      return CMPH_PRST_MODE_PREF( ph_ptr );
    }
    else
    {
      CM_ERR_0( "Invalid value in curr_nam: return mode_pref");
      return ph_ptr->main_stack_info.pref_info.mode_pref;
    }
  }
  else
  {
    return ph_ptr->main_stack_info.pref_info.mode_pref;
  }

} /* cmph_get_user_mode_pref() */


#ifdef FEATURE_HDR_HYBRID

/*===========================================================================

FUNCTION CMPH_GET_CONFIG_HYBR_STATUS

DESCRIPTION
  This function get the config hybrid status
DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  TRUE- hybrid operation is enabled

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_get_config_hybr_status(cm_ss_e_type ss)
{
  cmph_s_type            *ph_ptr = cmph_ptr();
      /* phone object pointer */
  sd_ss_mode_pref_e_type  sd_mode_pref;
  sys_modem_as_id_e_type  asubs_id = cmph_map_cm_ss_to_subs(ss);

  /* If 3gpp is not allowed on the sub, return right away */
  if (!cmph_msim_is_3gpp2_allowed(asubs_id))
  {
    return FALSE;
  }

  /*
  ** First map given CM mode pref to SD mode pref
  */
  sd_mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref(
                 CMPH_SS_MODE_PREF(asubs_id, ph_ptr));
  if( sd_mode_pref == SD_SS_MODE_PREF_NONE)
  {
    CM_ERR_0( "Mapping CM to SD failed !!!");
    return FALSE;
  }

  if ( (CMPH_SS_HYBR_PREF(asubs_id, ph_ptr)== CM_HYBR_PREF_ON) &&
      sd_misc_is_mode_pref(sd_mode_pref, SD_SS_MODE_PREF_CDMA) &&
      sd_misc_is_mode_pref(sd_mode_pref, SD_SS_MODE_PREF_HDR))
  {
    return TRUE;
  }

  return FALSE;

} /* cmph_get_config_hybr_status() */



/*===========================================================================

FUNCTION cmph_select_dbm_mode_pref

DESCRIPTION
  Select a mode preference suitable for data burst message transmission

DEPENDENCIES
  none

RETURN VALUE
  mode_pref: mode reference used for dbm

SIDE EFFECTS
  none

===========================================================================*/
cm_mode_pref_e_type cmph_select_dbm_mode_pref(void)
{
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return CM_MODE_PREF_CDMA_ONLY;

} /* cmph_select_dbm_mode_pref() */
#endif /* FEATURE_HDR_HYBRID */
#endif /* #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */



/*===========================================================================

@FUNCTION cmph_send_ddtm_status

@DESCRIPTION
  Send a DDTM status to 1xCP.

@DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

@RETURNS
  None

@SIDE_EFFECT
  Updates the cur_ddtm_* fields of the phone object to keep track of the DDTM
  settings sent down to 1xCP.

===========================================================================*/
void cmph_send_ddtm_status
(

  cmph_s_type          *ph_ptr,
    /**< Pointer to phone object.
    */

  boolean                     ddtm_status,
    /**< DDTM status to send to MC
    */

  sys_ddtm_act_mask_e_type    ddtm_act_mask,
    /**< DDTM mask to send to MC
    */

  sys_srv_opt_type const      *ddtm_srv_opt_list,
    /**< Service options to ignore if ignore SO bit is set in ddtm_act_mask.
    */

  uint16                      ddtm_num_srv_opt
    /**< No. of service option lists to ignore.
    */

)
{
  #if ((defined FEATURE_DDTM_CNTL) && (defined FEATURE_HDR) && \
       !defined(FEATURE_MMODE_REMOVE_1X))

  unsigned int i;
  mc_msg_type                    *mc_ptr;
      /* MC command pointer */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  ph_ptr->cur_ddtm_status       = ddtm_status;
  ph_ptr->cur_ddtm_act_mask     = ddtm_act_mask;
  ph_ptr->cur_ddtm_num_srv_opt  = MIN( ddtm_num_srv_opt,
                                       ARR_SIZE( ph_ptr->cur_ddtm_srv_opt_list )
                                     );
  for ( i=0; i < ph_ptr->cur_ddtm_num_srv_opt; i++ )
  {
    ph_ptr->cur_ddtm_srv_opt_list[i] = ddtm_srv_opt_list[i];
  }

  mc_ptr                                = cm_mc_get_buf_else_err_fatal();
  mc_ptr->hdr.cmd                       = MC_DDTM_CNTL_F;
  mc_ptr->ddtm_cntl.status              = ddtm_status;
  mc_ptr->ddtm_cntl.ddtm_act_mask       = ddtm_act_mask;


  /* if it's ALLOW mask, then we should use ALLOW list stored in phone pointer */
  if (ddtm_act_mask == SYS_DDTM_ACT_MASK_ALLOW_SO_PAGES)
  {
    mc_ptr->ddtm_cntl.num_srv_opt         = MIN( ph_ptr->ddtm_num_allow_srv_opt,
                                            SYS_DDTM_MAX_ALLOW_SO_LIST_SIZE );
    for( i=0; i < mc_ptr->ddtm_cntl.num_srv_opt; i++ )
    {
      mc_ptr->ddtm_cntl.srv_opt_list[i] =  ph_ptr->ddtm_allow_srv_opt_list[i];
    }
  }
  else
  {
    mc_ptr->ddtm_cntl.num_srv_opt         = MIN( ddtm_num_srv_opt,
                                               SYS_DDTM_MAX_SO_LIST_SIZE );
    for( i=0; i < mc_ptr->ddtm_cntl.num_srv_opt; i++ )
    {
      mc_ptr->ddtm_cntl.srv_opt_list[i] =  ddtm_srv_opt_list[i];
    }
  }

  CM_MSG_HIGH_4( "Send DDTM status=%d, mask 0x%x, num_srv_opt %d, so list action = %d",
               ph_ptr->cur_ddtm_status,
               ddtm_act_mask,
               ph_ptr->ddtm_num_srv_opt,
               ph_ptr->ddtm_so_list_act);
  //print the srv list action to be sent to clients
 
  cmph_event_per_subs(ph_ptr, CM_PH_EVENT_DDTM_STATUS, CM_SS_MAIN);

  cm_mc_send_cmd( mc_ptr );
  #else
  SYS_ARG_NOT_USED(ddtm_act_mask);
  SYS_ARG_NOT_USED(ddtm_status);
  SYS_ARG_NOT_USED(ddtm_srv_opt_list);
  SYS_ARG_NOT_USED(ddtm_num_srv_opt);
  SYS_ARG_NOT_USED(ph_ptr);
  SYS_ARG_NOT_CONST(ph_ptr);
  #endif /* FEATURE_DDTM_CNTL && FEATURE_HDR */
}


/*===========================================================================

FUNCTION cmph_ddtm_disable_cdma_tx

DESCRIPTION
  Send cmd to CDMA to disable TX.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  none

===========================================================================*/
void cmph_ddtm_disable_cdma_tx
(

       cmph_s_type          *ph_ptr
         /* Pointer to phone object.
         */
)
/*lint -esym(715, ph_ptr) */
{
  #if (defined FEATURE_DDTM_CNTL) && (defined FEATURE_HDR)
  sys_srv_opt_type  so_list[] = { CAI_SO_NULL };

  cmph_send_ddtm_status( ph_ptr, TRUE, SYS_DDTM_ACT_MASK_ALL,
                         so_list, ARR_SIZE( so_list ) );

  #else
  SYS_ARG_NOT_CONST(ph_ptr);
  #endif
}
/*lint +esym(715, ph_ptr) */


/*===========================================================================

FUNCTION cmph_update_ddtm_status

DESCRIPTION
  Send a DDTM status to MC

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  none

===========================================================================*/
void cmph_update_ddtm_status (

    cmph_s_type      *ph_ptr
        /* Pointer to a phone object */
)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  #ifdef FEATURE_DDTM_CNTL

  cmss_s_type *ss_ptr = cmss_ptr();
  #ifdef FEATURE_BCMCS
  cmbcmcs_s_type  *bcmcs_ptr = cmbcmcs_ptr();
  #endif

  /* List of conditions used in DDTM algorithm.
  */
  boolean new_ddtm_status             = FALSE;
  boolean is_bcmcs_flow_monitoring    = FALSE;
  boolean is_cdma_voice_or_emerg_call = FALSE;
  boolean is_call_on_ss_hdr           = FALSE;
  boolean is_call_connected_on_ss_hdr = FALSE;
  boolean is_mo_sms_or_dbm_in_prog    = FALSE;
  boolean is_pd_fix                   = FALSE;
  boolean is_high_psist               = FALSE;

  #ifdef FEATURE_ATOM
  boolean is_voip_call_on_ss_hdr      = FALSE;
  boolean is_voip_available_on_hdr    = FALSE;
  #endif

  boolean is_all_so_ignored_cur       = FALSE;
  boolean is_all_so_ignored_new       = FALSE;
  boolean is_so_list_diff             = FALSE;

  /* Arrays below is static to save stack usage.
  */
  static  sys_srv_opt_type new_ddtm_so_list [ SYS_DDTM_MAX_SO_LIST_SIZE ];
  uint16                   new_ddtm_num_so_list   = 0;
  sys_ddtm_act_mask_e_type new_ddtm_act_mask = SYS_DDTM_ACT_MASK_EMPTY;
  boolean is_emerg_call_or_mode       = FALSE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( ss_ptr != NULL );
  #ifdef FEATURE_BCMCS
  CM_ASSERT( bcmcs_ptr != NULL );
  #endif
  SYS_ARG_NOT_USED(is_emerg_call_or_mode);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Precompute all the conditions.
  */
  #ifdef FEATURE_BCMCS
  is_bcmcs_flow_monitoring = ( bcmcs_ptr->flow_monitoring_state ==
                       CM_BCMCS_FLOW_MONITORING_STATE_ACTIVE ? TRUE: FALSE );
  #endif

  #if (defined FEATURE_DDTM_ON_DURING_GPS_FIX) && (defined FEATURE_GPSONE)
  is_pd_fix = cmpd_get_fix_status();
  #endif

  is_high_psist = ( ss_ptr->info.psist == CM_PSIST_HIGH );

  is_mo_sms_or_dbm_in_prog = ( cmxsms_is_mo_sms_in_progress()
                               || cmxdbm_is_mo_dbm_in_progress() );

  is_all_so_ignored_cur = ( ph_ptr->cur_ddtm_num_srv_opt == 1
                            && ph_ptr->cur_ddtm_srv_opt_list[0] == CAI_SO_NULL
                            && SYS_IS_BIT_CONTAIN(
                                  ph_ptr->cur_ddtm_act_mask,
                                  SYS_DDTM_ACT_MASK_IGN_SO_PAGES )
                          );

  #ifdef FEATURE_ATOM
  is_voip_available_on_hdr = cmcall_is_active_ip_app( SYS_SYS_MODE_HDR,
                                               CM_CALL_TYPE_VOICE );
  #endif

  is_emerg_call_or_mode = cmph_is_in_emergency_cb();

  CMCALL_FOR_EACH_CALL_DO
    if( this_call->ss == CM_SS_HDR )
    {
      is_call_on_ss_hdr = TRUE;

      #ifdef FEATURE_ATOM
      if( this_call->call_type == CM_CALL_TYPE_VOICE )
      {
        is_voip_call_on_ss_hdr = TRUE;
      }
      #endif

      if( this_call->call_state  != CM_CALL_STATE_IDLE
          && this_call->cmcall_mode_info.info.cdma_info.srv_opt
                                            == CAI_SO_HDR_PKT_DATA )
      {
        is_call_connected_on_ss_hdr = TRUE;
      }
    }
    if( ( this_call->cmcall_mode_info.info_type == CM_CALL_MODE_INFO_CDMA
          && this_call->call_type == CM_CALL_TYPE_VOICE
          && this_call->ss == CM_SS_MAIN )
        || this_call->call_type == CM_CALL_TYPE_EMERGENCY )
    {
      is_cdma_voice_or_emerg_call = TRUE;
    }
    //#ifdef FEATURE_ATOM
    if( this_call->call_type == CM_CALL_TYPE_EMERGENCY )
    {
      is_emerg_call_or_mode = TRUE;
    }
    //#endif
  CMCALL_END_FOR

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* if we are in emergency call or mode and the list
  ** is valid, and we have not sent this action then we need to set this action */
  if (is_emerg_call_or_mode && (ph_ptr->ddtm_num_allow_srv_opt != CM_INVALID_DDTM_NUM_SRV_OPT) )
  {
    new_ddtm_act_mask = cmph_misc_add_ddtm_act_mask(
                      new_ddtm_act_mask,
                      1,
                      SYS_DDTM_ACT_MASK_ALLOW_SO_PAGES );
  }

  /* If phone is in therm emergency state, then we should not allow any
  ** incoming traffic on 1x. Except if phone is making emergency calls or
  ** in emergency callback mode.
  */
  if( cmac_is_in_emergency_only() &&
      !is_emerg_call_or_mode )
  {
    new_ddtm_act_mask = SYS_DDTM_ACT_MASK_ALL;

    /* Ignore ALL SO pages.
    */
    new_ddtm_num_so_list = 1;
    new_ddtm_so_list[0]  = CAI_SO_NULL;
    is_all_so_ignored_new = TRUE;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  #ifdef FEATURE_DEDICATED_C2K_MODE
  if( ss_ptr->is_hdr_session_open && !is_emerg_call_or_mode )
  {
    if( ph_ptr->is_cdma_tx_disabled == FALSE )
    {
      cmph_ddtm_disable_cdma_tx( ph_ptr );

      /* The line below was put here instead of cmph_ddtm_disable_cdma_tx() to
      ** avoid the risk of changing the existing behavior.
      */
      ph_ptr->is_cdma_tx_disabled = TRUE;
    }

    return;
  }

  ph_ptr->is_cdma_tx_disabled = FALSE;

  #endif

  /* Compute the DDTM settings to be send to 1xCP. We start with an empty
  ** DDTM mask and add corresponding suppression for each condition that is
  ** satisfied.
  */

  /* If in high psist and we are in a HDR call or monitoring BCMCS then
  ** suppress MO DBM and registrations (since they will not succeed anyway)
  */
  if( is_high_psist
      && ((is_call_on_ss_hdr && !ph_ptr->is_svdo_supported)
          || is_bcmcs_flow_monitoring ) )
  {
    new_ddtm_act_mask = cmph_misc_add_ddtm_act_mask(
                      new_ddtm_act_mask,
                      2,
                      SYS_DDTM_ACT_MASK_SUPPRESS_MO_DBM,
                      SYS_DDTM_ACT_MASK_SUPPRESS_REG );
  }

  /* If DDTM pref is ON:
  **
  ** Note:
  ** 1. If High PSIST is on, then a HDR orig is equivalent to a connected HDR
  **    call.
  ** 2. If High PSIST is on, we ignore MO SMS/DBM in progess.
  **
  ** Turn on user DDTM pref under any one of the following conditions:
  ** 1. Hybrid HDR connected data call and no MO SMS/DBM (See note 1 & 2).
  ** 2. Monitoring BCMCS but no voice/emerg/MO SMS/DBM (See note 2).
  ** 3. PD fix is in progress.
  */
  if(ph_ptr->ddtm_pref == CM_DDTM_PREF_ON
                  &&
     (
       (
         ( (is_call_connected_on_ss_hdr && !ph_ptr->is_svdo_supported)
           || ( (is_call_on_ss_hdr && !ph_ptr->is_svdo_supported) && is_high_psist)
           || ( is_bcmcs_flow_monitoring && !is_cdma_voice_or_emerg_call ) )
                  &&
         ( !is_mo_sms_or_dbm_in_prog || is_high_psist )
       )
       /*lint -e{774} Boolean within 'if' always evaluates to False */
       || is_pd_fix
     )
    )
  {
    /* Once all the above conditions are met, we need to check following condition:
    ** if you're in Emergency Mode && The ALLOW list is valid
    ** Then if the mask says "IGN", we still prefer ALLOW mask over it.
    */

    if (!(is_emerg_call_or_mode &&
         (ph_ptr->ddtm_act_mask == SYS_DDTM_ACT_MASK_IGN_SO_PAGES) &&
         (ph_ptr->ddtm_num_allow_srv_opt != CM_INVALID_DDTM_NUM_SRV_OPT)))
          new_ddtm_act_mask = cmph_misc_add_ddtm_act_mask( new_ddtm_act_mask, 1,
                                                 ph_ptr->ddtm_act_mask );

  }

  #ifdef FEATURE_ATOM
  /* If a VoIP/HDR call is going on, then make sure no 1x activity interrupts
  ** it.
  */
  if( (is_voip_call_on_ss_hdr && !ph_ptr->is_svdo_supported) && !is_emerg_call_or_mode )
  {
    new_ddtm_act_mask = SYS_DDTM_ACT_MASK_ALL;

    /* Ignore ALL SO pages.
    */
    new_ddtm_num_so_list = 1;
    new_ddtm_so_list[0]  = CAI_SO_NULL;
    is_all_so_ignored_new = TRUE;
  }

  /* If VoIP/HDR is available, then turn off 1x registration.
  */
  if( (is_voip_available_on_hdr && !ph_ptr->is_svdo_supported) && !is_emerg_call_or_mode )
  {
    new_ddtm_act_mask = cmph_misc_add_ddtm_act_mask(
                      new_ddtm_act_mask,
                      1,
                      SYS_DDTM_ACT_MASK_SUPPRESS_REG );
  }
  #endif

  #if (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
       defined( FEATURE_LTE_TO_1X )
  if (cmsds_is_in_1xcsfb_mode() &&
      (ph_ptr->ddtm_pref == CM_DDTM_PREF_ON))
  {
    new_ddtm_act_mask = ph_ptr->ddtm_act_mask;

    CM_MSG_HIGH_0("CSFB DDTM: Adding mask new_ddtm_act_mask");
  }
  #endif
  /* If number of srv list opt to be blocked is not INVALID update ddtm mask 
   ** to block/unblock service options
   ** 1. If number of blocked srv opt is greater then 0 notify MC about the updated 
   **    srv opt list 
   ** 2. If number of blocked srv opt is  0 unblock SOs blocked earlier. 
   **    ddtm_srv_opt_list will have the list of srv opt to be blocked earlier. Use this list
   **    to go back to earlier state
   ** 
   */
  if(ph_ptr->ddtm_num_blocked_srv_opt != CM_INVALID_DDTM_NUM_SRV_OPT)
  {
   
    new_ddtm_act_mask = cmph_misc_add_ddtm_act_mask( new_ddtm_act_mask, 1,
                                                    SYS_DDTM_ACT_MASK_IGN_SO_PAGES );
    
    is_so_list_diff = TRUE;
    if(ph_ptr->ddtm_num_blocked_srv_opt == 0)
    {
      ph_ptr->ddtm_num_blocked_srv_opt = CM_INVALID_DDTM_NUM_SRV_OPT;
    }
   }

  if(new_ddtm_act_mask != SYS_DDTM_ACT_MASK_EMPTY)
  {
    new_ddtm_status = TRUE;
  }

  /* Compute the new SO list if.
  **
  ** 1. Ignoring SO pages are turned on.
  ** 2. All SO pages are not already ignored by using CAI_SO_NULL.
  ** 3. We're not in emergency callback mode. If we're in this mode, we will use
  **    SYS_DDTM_ACT_MASK_ALLOW_SO_PAGES
  ** 4. If DS provided list of SOs to block append new_ddtm_so_list with 
  **     client provided list of SOs.
  */
  /*lint -e{774} */
  if( SYS_IS_BIT_CONTAIN( new_ddtm_act_mask, SYS_DDTM_ACT_MASK_IGN_SO_PAGES )
      && !is_all_so_ignored_new
      && !is_emerg_call_or_mode
    )
  {
    uint16 i,j,k;
    boolean is_duplicate = FALSE;

    /* We always just copy the DDTM SO list pref as of now.
    ** Can change this in the future as requirements change.
    */
    for( i=0; i < ph_ptr->ddtm_num_srv_opt; i++ )
    {
      new_ddtm_so_list[i] = ph_ptr->ddtm_srv_opt_list[i];
      if( new_ddtm_so_list[i] == CAI_SO_NULL )
      {
        is_all_so_ignored_new = TRUE;
      }
    }
    new_ddtm_num_so_list = i;
    k = new_ddtm_num_so_list; 

    /* Append SO to new_ddtm_so_list from ddtm_blocked_srv_opt_list containing valid list of SO to be blocked by DS
      */
    if(!is_all_so_ignored_new && 
       (ph_ptr->ddtm_num_blocked_srv_opt > 0) &&
       (ph_ptr->ddtm_num_blocked_srv_opt != CM_INVALID_DDTM_NUM_SRV_OPT))
    {
      for(i = 0; i < ph_ptr->ddtm_num_blocked_srv_opt && i < SYS_DDTM_MAX_SO_LIST_SIZE; i++)
      {
        is_duplicate = FALSE;
        for(j = 0; j< new_ddtm_num_so_list; j++)
        {
         /* Avoid appending SO which is already being blocked. Find duplicate */
          if(new_ddtm_so_list[j] == ph_ptr->ddtm_blocked_srv_opt_list[i])
          {
            is_duplicate = TRUE;
            break;
          }
        }
        if (is_duplicate == FALSE)
        {
           new_ddtm_so_list[k++] = ph_ptr->ddtm_blocked_srv_opt_list[i];
        }
      }
      
      new_ddtm_num_so_list = k;
      CM_MSG_HIGH_1("DDTM new_ddtm_num_so_list %d ",new_ddtm_num_so_list);
    }
  }


  /* If ignoring pages is not turned on, the set to SO list count to zero
  ** just for the sake of cleaning up garbage values.
  */
  if( !SYS_IS_BIT_CONTAIN( new_ddtm_act_mask,
                           SYS_DDTM_ACT_MASK_IGN_SO_PAGES ) )
  {
    new_ddtm_num_so_list = 0;
  }

  /* Check if the SO lists changed.
  **
  ** Should catch all differences ONLY IF the possible SO list values are
  ** limited to:
  ** 1. All SOs are blocked with CAI_SO_NULL.
  ** 2. All the SOs stored in NV (ph_ptr->ddtm_srv_opt_list).
  */
  if( is_all_so_ignored_cur != is_all_so_ignored_new )
  {
    is_so_list_diff = TRUE;
  }

  if( new_ddtm_act_mask != ph_ptr->cur_ddtm_act_mask
      || new_ddtm_status != ph_ptr->cur_ddtm_status
      || is_so_list_diff )
  {
    cmph_send_ddtm_status( ph_ptr, new_ddtm_status, new_ddtm_act_mask,
                           new_ddtm_so_list, new_ddtm_num_so_list );
  }

  #else

  SYS_ARG_NOT_USED(ph_ptr);
  SYS_ARG_NOT_CONST(ph_ptr);

  #endif
}

#ifdef FEATURE_DEDICATED_C2K_MODE
/*===========================================================================

FUNCTION cmph_send_hdrmc_session_close_cmd

DESCRIPTION
  Send an end command to either MC or HDRMC task

DEPENDENCIES
  Call object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_send_hdrmc_session_close_cmd( void )
{
  hdrcp_smp_deactivate(HDRHAI_CM, FALSE);
}
#endif


#if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)

/**--------------------------------------------------------------------------
** Functions - external, gsm/wcdma
** --------------------------------------------------------------------------
*/

/*===========================================================================

FUNCTION cmph_rpt_proc

DESCRIPTION
  Process Lower Layer reports (i.e. notifications of phone activity or
  replies to clients phone commands).


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_rpt_proc(

  const cm_hdr_type   *rpt_ptr
    /* Pointer to LL report */
)
{
  cm_rpt_type             *cm_rpt_ptr = (cm_rpt_type *) rpt_ptr;
      /* Pointer to a LL report */

  cmph_s_type             *ph_ptr       = cmph_ptr();
      /* Point at phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( cm_rpt_ptr != NULL );
  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Do command specific processing as follows:
  ** 1. Updating appropriate phone object fields.
  ** 2. Notifying clients of event if necessary.
  */

  switch( cm_rpt_ptr->hdr.cmd )
  {
    #ifdef FEATURE_TC
    case CM_CHANGE_TEST_MODE_IND :
      cmph_process_change_test_mode_ind
        ( &cm_rpt_ptr->cmd.tc_change_test_mode_ind );
      break;
    #endif /* FEATURE_TC */

    case CM_SI_NETWORK_LIST_F:
        cmph_process_network_list_cnf(cm_rpt_ptr);
     break;

    case CM_GET_DRX_CNF:
      cmph_process_get_drx_cnf(cm_rpt_ptr);
      break;

    case CM_SET_DRX_CNF:
      cmph_process_set_drx_cnf(cm_rpt_ptr);
      break;

    case CM_STACK_DEACT_IND:
      cmph_process_stack_deact_ind(cm_rpt_ptr);
      break;

    case CM_STACK_ACT_IND:
      cmph_process_stack_act_ind(cm_rpt_ptr);
      break;

    case CM_ABORT_CC_CONF:
      cmph_abort_cc_cnf_hdlr();
      return;

    case CM_GET_HPLMN_SEARCH_TIMER_CNF:
      cmph_process_get_hplmn_timer_cnf(cm_rpt_ptr);
      break;

    case CM_PS_ATTACH_FAILED_IND:
      cmph_process_ps_attach_failed_ind(&cm_rpt_ptr->cmd.ps_attach_failed_ind);
      break;

    case CM_CSG_SEARCH_TRIGGER_IND:
      cmph_process_search_trigger_ind(&cm_rpt_ptr->cmd.csg_search_trigger_ind);
      break;

    default:
      break;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If this is a reply to an earlier command we sent to LL,
  ** also do reply processing.
  */
  if( cm_reply_check(&ph_ptr->reply, cm_rpt_ptr->hdr.cmd) )
  {
    /* Point at client command waiting for reply
    */
    cm_ph_cmd_s_type  *reply_cmd_ptr = (cm_ph_cmd_s_type*)cm_reply_get(&ph_ptr->reply);
    CM_ASSERT( reply_cmd_ptr != NULL );
    CM_ASSERT( CMD_TYPE(reply_cmd_ptr) == CM_CMD_TYPE_PH);
    /* Invoke the reply function with the appropriate error code.
    */
    cmph_client_cmd_mmll_reply( ph_ptr,
                                reply_cmd_ptr,
                                CM_PH_CMD_ERR_NOERR );

    /* We are done with processing the command that was waiting
    ** for reply - deallocate its command buffer.
    */
    cm_cmd_dealloc( reply_cmd_ptr );

    /* Turn on the signal that causes us to process any pending
    ** clients commands. This is necessary since we were NOT
    ** processing any clients commands while waiting for a reply
    ** from MC.
    */
    (void) rex_set_sigs( rex_self(), CM_CLIENT_CMD_Q_SIG );
  }
} /* cmph_rpt_proc() */
#endif /* #if (defined CM_GW_SUPPORTED || defined(FEATURE_CM_LTE))*/


#ifdef CM_GW_SUPPORTED



/*===========================================================================

FUNCTION cmph_update_acm

DESCRIPTION
  This function is called when the ACM needs to be updated.  This can
  occur when the CCM is updated, when a call starts or ends, or when
  the acm timer has expired.

DEPENDENCIES
  The call structure pointed to within call_ptr must be initialized.

RETURN VALUE
  None.

SIDE EFFECTS
  None
===========================================================================*/
void cmph_update_acm(

   sys_modem_as_id_e_type  asubs_id
    /* sub whose acm needs to be updated */

)
{
  cm_ph_charge_data_type  *ph_charge_ptr  = NULL;
  unsigned long           ccm_for_acm     = 0;
  unsigned long           increase_in_acm = 0;
  cmph_s_type             *ph_ptr         = cmph_ptr();
  cm_ss_e_type          ss = cmph_map_as_id_to_cm_ss(asubs_id);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr != NULL);
  CM_ASSERT_ENUM_IS_INRANGE(asubs_id, SYS_MODEM_AS_ID_MAX);


  if (asubs_id == SYS_MODEM_AS_ID_2 &&
      cmph_is_ssim())
  {
    return;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Get the corresponding phone_charge object to update
  ** based on the SS
  */
  if(ss == CM_SS_HYBR_2 &&
     cmph_is_msim() && !cmph_is_sxlte())
  {
    ph_charge_ptr = &ph_ptr->hybr_2_stack_info.phone_charge;
  }
  else
  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 )
  {
    ph_charge_ptr = &ph_ptr->hybr_3_stack_info.phone_charge;
  }
  else
  #endif
  {
    ph_charge_ptr = &ph_ptr->main_stack_info.phone_charge;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  ccm_for_acm = CMAOC_CCM_TO_ACM(ph_charge_ptr->CCM);

  (void) rex_clr_timer(&ph_charge_ptr->acm_timer);
  ph_charge_ptr->acm_timer_running = FALSE;

  /* The first check ensures the ACM would change when this is called.
  ** Second is to make sure ACM has not reached its spec defined max value
  */
  if ((ccm_for_acm != ph_charge_ptr->last_CCM_to_update_ACM) &&
      (ph_charge_ptr->ACM < CMPH_MAX_VAL_ACM)
     )
  {
    /* Add the current CCM to the local version of the ACM */
    CM_MSG_HIGH_1("AOC: ACM being increased by %d",
                ccm_for_acm - ph_charge_ptr->last_CCM_to_update_ACM);

    /* Increase in acm
    */
    increase_in_acm = ccm_for_acm - ph_charge_ptr->last_CCM_to_update_ACM;

    /* IF ACM gets greater than CMPH_MAX_VAL_ACM after adding
    ** increase_in_acm, then limit the value to CMPH_MAX_VAL_ACM
    */
    if ((ph_charge_ptr->ACM + increase_in_acm) > CMPH_MAX_VAL_ACM)
    {
      increase_in_acm     = CMPH_MAX_VAL_ACM  - ph_charge_ptr->ACM;
    }

    /* Update accumilated call meter value */
    ph_charge_ptr->ACM += increase_in_acm;

    /* Save the current ACM into the SIM. */
    cmwaoc_save_acm(asubs_id, increase_in_acm);

    /* Mark that portion as charged. */
    ph_charge_ptr->last_CCM_to_update_ACM = ccm_for_acm;

    /* Start a timer for 5000 msecs to ensure we don't update ACM too often. */
    (void) rex_set_timer(&ph_charge_ptr->acm_timer, 5 * 1000);
    ph_charge_ptr->acm_timer_running = TRUE;

  }

  /* Next, check if we are over the value of ACMmax in the SIM. */
  if (ph_charge_ptr->ACMmax != 0)
  {
    if ( ph_charge_ptr->ACM >= ph_charge_ptr->ACMmax)
    {
      cmph_aoc_no_funds(asubs_id);
    }
    else
    {
      if (!ph_charge_ptr->sent_warning &&
          ((ph_charge_ptr->ACM + CMAOC_CCM_TO_ACM(cmwaoc_ccm_in_30(asubs_id)) -
            ph_charge_ptr->last_CCM_to_update_ACM) >= ph_charge_ptr->ACMmax))
      {
        cmph_event_per_subs(ph_ptr, CM_PH_EVENT_FUNDS_LOW, ss);
        ph_charge_ptr->sent_warning = TRUE;
      }
    }
  }

} /* cmph_update_acm() */


/*===========================================================================

FUNCTION cmph_aoc_funds_available

DESCRIPTION
  This function is called to determine if funds are still availble
  when a call is originated.

DEPENDENCIES
  The call structure pointed to within call_ptr must be initialized.

RETURN VALUE
  None.

SIDE EFFECTS
  None
===========================================================================*/
boolean cmph_aoc_no_funds_available(

  cm_ss_e_type    ss
    /* stack whose funds need to be checked */

)
{
  cmph_s_type      *ph_ptr = cmph_ptr();

  SYS_ARG_NOT_USED(ss);

  if( ss == CM_SS_HYBR_2 && cmph_is_msim())
  {
    return ph_ptr->hybr_2_stack_info.phone_charge.drop_calls;
  }
  else
  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 )
  {
    return ph_ptr->hybr_3_stack_info.phone_charge.drop_calls;
  }
  else
  #endif
  {
    return (ph_ptr->main_stack_info.phone_charge.drop_calls);
  }

} /* cmph_aoc_no_funds_available() */


/*===========================================================================

FUNCTION cmph_aoc_no_funds

DESCRIPTION
  This function is called when we determine the phone is out of funds.
  It sends the warning if it needs it and sets the drop_calls variable.

DEPENDENCIES
  The call structure pointed to within call_ptr must be initialized.

RETURN VALUE
  None.

SIDE EFFECTS
  None
===========================================================================*/
void cmph_aoc_no_funds(

  sys_modem_as_id_e_type   asubs_id
    /* sub on which funds are not available */

)
{
  cmph_s_type              *ph_ptr = cmph_ptr();

  cm_ph_charge_data_type   *phone_charge;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  if((asubs_id == SYS_MODEM_AS_ID_3) ||
    (asubs_id == ph_ptr->hybr_3_stack_info.asubs_id && cmph_is_sxlte()))
  {
    phone_charge = &ph_ptr->hybr_3_stack_info.phone_charge;
  }
  else
  #endif
  if(asubs_id == ph_ptr->main_stack_info.asubs_id)
  {
    phone_charge = &ph_ptr->main_stack_info.phone_charge;
  }
  else if(asubs_id == ph_ptr->hybr_2_stack_info.asubs_id)
  {
    phone_charge = &ph_ptr->hybr_2_stack_info.phone_charge;
  }
  else
  {
    phone_charge = &ph_ptr->main_stack_info.phone_charge;
  }

  phone_charge->drop_calls = TRUE;

  if (!phone_charge->sent_warning)
  {
    phone_charge->sent_warning = TRUE;
    cmph_event_per_subs(ph_ptr, CM_PH_EVENT_FUNDS_LOW,
                                       cmph_map_subs_to_ss(asubs_id));
  }

} /* cmph_aoc_no_funds() */

/*===========================================================================

FUNCTION cmph_add_ccbs_entry

DESCRIPTION

   Stores ccbs indx and corresponding called number for calls that
   are waiting on ccbs recall.

DEPENDENCIES

  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE

  TRUE  - New entry added with success.
  FALSE - New entry addition failed.

SIDE EFFECTS

  Modifies ccbs_indx_store in phone object

===========================================================================*/
boolean cmph_add_ccbs_entry (

   cm_ss_e_type                       ss,
     /* SS on which the SUPS rpt is recieved */

   cm_ccbs_indx_type                  ccbs_index,
      /* ccbs index to be added */

   cm_called_party_bcd_no_s_type      called_party
      /* Called party number */

)
{

  int ccbs_count = 0;

  cmph_s_type                *ph_ptr  = cmph_ptr();
  /* Pointer to a phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  CM_ASSERT (INRANGE(ccbs_index, 1, 5));

  for (ccbs_count = 0; ccbs_count < (int)ARR_SIZE(ph_ptr->ccbs_indx_store);
                                                 ++ccbs_count)
  {
    if (ph_ptr->ccbs_indx_store[ccbs_count].ccbs_index ==
                                                       CM_CCBS_INDX_INVALID)
    {
      ph_ptr->ccbs_indx_store[ccbs_count].ccbs_index   = ccbs_index;

      ph_ptr->ccbs_indx_store[ccbs_count].called_party = called_party;

      cmph_event_per_subs (ph_ptr, CM_PH_EVENT_CCBS_STORE_INFO_CHANGED, ss);

      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* cmph_add_ccbs_entry () */


/*===========================================================================

FUNCTION cmph_check_ccbs_entry

DESCRIPTION

  checks if ccbs index is present in any entry in phone object

DEPENDENCIES

  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE

  TRUE  - ccbs index is present
  FALSE - ccbs index is not present

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_check_ccbs_entry (

    cm_ccbs_indx_type           ccbs_index
      /* ccbs index to be checked for */
)
{
  int ccbs_count = 0;

  cmph_s_type                *ph_ptr  = cmph_ptr();
  /* Pointer to a phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  CM_ASSERT (INRANGE(ccbs_index, 1, 5));

  for (ccbs_count = 0; ccbs_count < (int)ARR_SIZE(ph_ptr->ccbs_indx_store);
                                                 ++ccbs_count)
  {
    if (ph_ptr->ccbs_indx_store[ccbs_count].ccbs_index == ccbs_index)
    {
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

}  /* cmph_check_ccbs_entry () */

/*===========================================================================

FUNCTION cmph_remove_ccbs_entry

DESCRIPTION

  Remove ccbs index from phone object entry.

DEPENDENCIES

  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE

  TRUE  - ccbs index remove operation succeeded.
  FALSE - ccbs index remove operation failed.

SIDE EFFECTS
  ccbs indx store gets changed

===========================================================================*/
boolean cmph_remove_ccbs_entry (

    cm_ss_e_type                          ss,
      /* stack on which to remove the call */

    cm_ccbs_indx_type                     ccbs_index
      /* Remove ccbs entry from phone object */
)
{
  int ccbs_count = 0;

  cmph_s_type                *ph_ptr  = cmph_ptr();
  /* Pointer to a phone object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT (INRANGE(ccbs_index, 1, 5));

  for (ccbs_count = 0; ccbs_count < (int)ARR_SIZE(ph_ptr->ccbs_indx_store);
                                                 ++ccbs_count)
  {
    if (ph_ptr->ccbs_indx_store[ccbs_count].ccbs_index == ccbs_index)
    {
      ph_ptr->ccbs_indx_store[ccbs_count].ccbs_index = CM_CCBS_INDX_INVALID;

      cmph_event_per_subs(ph_ptr, CM_PH_EVENT_CCBS_STORE_INFO_CHANGED, ss);
      return TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return FALSE;

} /* cmph_remove_ccbs_entry () */

#endif /* defined CM_GW_SUPPORTED */



/*===========================================================================

FUNCTION cmph_update_orig_mode_uptime

DESCRIPTION
  This function increases the orig mode uptime of ph by CMPH_HOLD_MODE_PREF_TIME
  plus clock uptime.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_update_orig_mode_uptime (
  cm_ss_e_type ss,
    /* The ss to search this activcity for
    */
  cm_act_id_type act_id
    /* The id of the activity
    */
)
{
  cm_orig_q_s_type *computed_orig =  cmtask_orig_para_search_act_id  ( ss, act_id );


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( computed_orig != NULL )
  {
    computed_orig->orig->orig_mode_uptime = time_get_uptime_secs() +
                                                    CMPH_HOLD_MODE_PREF_TIME;
  }

} /* cmph_update_orig_mode_uptime () */



/*===========================================================================

FUNCTION cmph_is_cdma_subscription_available

DESCRIPTION
  This function returns a boolean indicating whether cdma subscription is available.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  boolean

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_cdma_subscription_available (void)
{
  cmph_s_type                *ph_ptr   = cmph_ptr();

  return (ph_ptr->is_cdma_subscription_available);
}


/*===========================================================================

FUNCTION cmph_is_gwl_subscription_available

DESCRIPTION
  This function returns a boolean indicating whether GSM/WCDMA/LTE
   subscription is available.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE^M
  boolean

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_gwl_subscription_available (void)
{
  cmph_s_type                *ph_ptr   = cmph_ptr();

  return (ph_ptr->is_gwl_subscription_available);
}


/*===========================================================================^M
^M
FUNCTION cmph_get_cdma_subscription_source
^M
DESCRIPTION^M
  This function will determine where cdma subscription is coming from.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
cm_cc_subscription_source_e_type cmph_get_cdma_subscription_source (void)
{
  cmph_s_type                   *ph_ptr  =  cmph_ptr();

  /* Check if there is a cdma subscription */
  if (ph_ptr->is_cdma_subscription_available == FALSE)
  {
    return CM_CC_SUBSCRIPTION_SOURCE_NONE;
  }

  /* Check if cdma subscription is from NV */
  if (ph_ptr->rtre_control == CM_RTRE_CONTROL_NV)
  {
    return CM_CC_SUBSCRIPTION_SOURCE_NV;
  }


  /* Then we must be getting subscription from the SIM ...
     Figure out which one
  */

  #ifdef FEATURE_MMGSDI_SESSION_LIB
  {
    mmgsdi_slot_id_enum_type cm_mmgsdi_slot_number;

    cm_mmgsdi_slot_number = cm_mmgsdi_ssn_tbl_get_slot_for_type(
                                                MMGSDI_1X_PROV_PRI_SESSION);

    if (MMGSDI_SLOT_1 == cm_mmgsdi_slot_number)
    {
     return CM_CC_SUBSCRIPTION_SOURCE_SIM_1;
    }
    else if ( MMGSDI_SLOT_2 == cm_mmgsdi_slot_number )
    {
     return CM_CC_SUBSCRIPTION_SOURCE_SIM_2;
    }
    else if ( MMGSDI_SLOT_3 == cm_mmgsdi_slot_number )
    {
     return CM_CC_SUBSCRIPTION_SOURCE_SIM_3;
    }
    else
    {
      return CM_CC_SUBSCRIPTION_SOURCE_NONE;
    }
  }
  #else
  {
     /* Return the valid card slot based on the valid card slot information
     ** stored in the phone object.
     */
     if ( ph_ptr->valid_card_1 )
     {
        return CM_CC_SUBSCRIPTION_SOURCE_SIM_1;
     }
     else if ( ph_ptr->valid_card_2)
     {
        return CM_CC_SUBSCRIPTION_SOURCE_SIM_2;
     }
     else if ( ph_ptr->valid_card_3)
     {
        return CM_CC_SUBSCRIPTION_SOURCE_SIM_3;
     }
     else
     {
        return CM_CC_SUBSCRIPTION_SOURCE_NONE;
     }
  }
  #endif /* FEATURE_MMGSDI_SESSION_LIB */



}   /* cmph_get_cdma_subscription_source */


/*===========================================================================

FUNCTION cmph_get_gw_subscription_source

DESCRIPTION
  This function will determine where gw subscription is coming from

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
cm_cc_subscription_source_e_type cmph_get_gw_subscription_source
(
  cm_ss_e_type ss
    /* The ss for which subscription source is needed
    */
)
{
  #ifdef CM_GW_SUPPORTED
  cmph_s_type                   *ph_ptr  =  cmph_ptr();

  /* Check if there is a gw subscription */
  if (ph_ptr->is_gwl_subscription_available == FALSE &&
      ph_ptr->is_hybr_gw_subscription_available == FALSE
      #if defined FEATURE_MMODE_TRIPLE_SIM || defined FEATURE_MMODE_SXLTE_G
      && ph_ptr->is_hybr_gw3_subscription_available == FALSE
      #endif
      )
  {
    return CM_CC_SUBSCRIPTION_SOURCE_NONE;
  }

  #ifdef FEATURE_MMGSDI_SESSION_LIB
  {
    mmgsdi_slot_id_enum_type    slot_number;

    if(ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
    {
      if (ph_ptr->is_hybr_gw_subscription_available == TRUE)
      {
        slot_number = ph_ptr->valid_card_2;
      }
      else
      {
        slot_number = MMGSDI_MAX_SLOT_ID_ENUM;
      }
    }
    else
    #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
    if(ss == CM_SS_HYBR_3)
    {
      if (ph_ptr->is_hybr_gw3_subscription_available == TRUE)
      {
        if (cmph_is_sxlte())
        {
          slot_number = ph_ptr->valid_card_2;
        }
        else
        {
          slot_number = ph_ptr->valid_card_3;
        }
      }
      else
      {
        slot_number = MMGSDI_MAX_SLOT_ID_ENUM;
      }
    }
    else
    #endif
    {
      if(ph_ptr->is_gwl_subscription_available == TRUE)
      {
        slot_number = ((ph_ptr->valid_card_1 != MMGSDI_SLOT_2)?
                        MMGSDI_SLOT_1:MMGSDI_SLOT_2);
      }
      else
      {
        slot_number = MMGSDI_MAX_SLOT_ID_ENUM;
      }
    }

    if (MMGSDI_SLOT_1 == slot_number)
    {
      return CM_CC_SUBSCRIPTION_SOURCE_SIM_1;
    }
    else if ( MMGSDI_SLOT_2 == slot_number )
    {
      return CM_CC_SUBSCRIPTION_SOURCE_SIM_2;
    }
    else if ( MMGSDI_SLOT_3 == slot_number )
    {
      return CM_CC_SUBSCRIPTION_SOURCE_SIM_3;
    }
  }
  #else
  {
    gsdi_card_apps_T               card_apps;
    uint8                          slot_number;

    gsdi_get_apps_available (&card_apps);
    slot_number = card_apps.operational_slot;

    if ((slot_number & GSDI_GSM_SLOT_1_MASK) ==  GSDI_GSM_SLOT_1_MASK ||
       (slot_number & GSDI_USIM_SLOT_1_MASK) == GSDI_USIM_SLOT_1_MASK)
    {
       return CM_CC_SUBSCRIPTION_SOURCE_SIM_1;
    }

    if ((slot_number & GSDI_GSM_SLOT_2_MASK) == GSDI_GSM_SLOT_2_MASK ||
       (slot_number & GSDI_USIM_SLOT_2_MASK) == GSDI_USIM_SLOT_2_MASK)
    {
       return CM_CC_SUBSCRIPTION_SOURCE_SIM_2;
    }

    if ((slot_number & GSDI_GSM_SLOT_3_MASK) == GSDI_GSM_SLOT_3_MASK ||
       (slot_number & GSDI_USIM_SLOT_3_MASK) == GSDI_USIM_SLOT_3_MASK)
    {
       return CM_CC_SUBSCRIPTION_SOURCE_SIM_3;
    }
  }
  #endif /* FEATURE_MMGSDI_SESSION_LIB */
  #endif /* defined (FEATURE_WCDMA) || defined(FEATURE_GSM) */

  SYS_ARG_NOT_USED(ss);

  return CM_CC_SUBSCRIPTION_SOURCE_NONE;

} /* cmph_get_gw_subscription_source */


/*===========================================================================

FUNCTION cmph_get_ps_data_orig_prefs

DESCRIPTION
  This function will return where the preferences for packet switched data calls.

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  preferences for ps data originations

SIDE EFFECTS
  none

===========================================================================*/
cm_ps_data_orig_prefs_e_type cmph_get_ps_data_orig_prefs ( void )
{

  cmph_s_type                *ph_ptr = cmph_ptr();

  return ph_ptr->ps_data_orig_pref;

} /* cmph_get_ps_data_orig_prefs */


/*===========================================================================

FUNCTION cmph_call_end_req

DESCRIPTION
  Does necessary phone's call end req activities. It is applicable
  for GSM/WCDMA only.

  This function should be called from cmwcall_end_req while sending
  CM_CALL_EVENT_END_REQ to its clients.


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_call_end_req
(
    const cmcall_s_type    *call_ptr
        /* Pointer to a call object */
)
{
  /* Get the pointer to the phone object */
  cmph_s_type             *ph_ptr = cmph_ptr();

  CM_ASSERT( call_ptr != NULL );

  /* Check if all calls are in idle.
   ** If device_mode = dual_sim_dual_active, check the call state per ss
   ** otherwise, check the call state for all ss
   */
  if(cmph_is_dsda())
  {
    if(cmcall_check_each_call_in_call_state_ss(CM_CALL_STATE_IDLE,
                                               call_ptr->asubs_id))
    {
      /* Update DDTM status.
      */
      cmph_update_ddtm_status(ph_ptr);

      /* Generate In use event.
      */
      cmph_event_per_subs( ph_ptr, CM_PH_EVENT_IN_USE_STATE, call_ptr->ss);
    }
  }
  else if (cmcall_check_each_call_in_call_state(CM_CALL_STATE_IDLE))
  {

    /* Update DDTM status.
    */
    cmph_update_ddtm_status(ph_ptr);

    /* Generate In use event.
    */
    cmph_event_per_subs( ph_ptr, CM_PH_EVENT_IN_USE_STATE, call_ptr->ss);
  }

} /* cmph_call_end_req */

/*===========================================================================

FUNCTION cmph_last_gw_pkt_call

DESCRIPTION

  This function initializes the wait timer for the PS signaling down
  indication. This fuction also sets the flag indcating that we are
  waiting for the PS singaling down indication from lower layers.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void  cmph_last_gw_pkt_call(

      cm_ss_e_type  ss
        /* Stack on which this is the last pkt call*/

)
{
  cmph_set_ps_sig_down_wait_time(cmph_ptr()->ps_signaling_max_wait_timer, ss);
} /* cmph_last_gw_pkt_call */

/*===========================================================================

FUNCTION cmph_set_ps_sig_down_wait_time

DESCRIPTION

   This function sets the is_ps_signaling_down_wait_time
   with the value passed in the argument.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_set_ps_sig_down_wait_time(

     dword          wait_time,
        /* wait time */

     cm_ss_e_type   ss
        /* SS on which the PS signalling is down */
)
{
  /* Get the pointer to the phone object */
  cmph_s_type             *ph_ptr = cmph_ptr();
  CM_MSG_HIGH_3("ss %d, wait_time %d, time_get_uptime_secs() %d", ss, wait_time, time_get_uptime_secs());

  if(wait_time != CMPH_GW_PKT_WAIT_TIME_NONE)
  {
    if( ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
    {
      ph_ptr->hybr_2_stack_info.ps_signaling_down_wait_time = time_get_uptime_secs() + wait_time;
      ph_ptr->hybr_2_stack_info.is_ps_srv_req_sent = FALSE;
    }
    else
    #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
    if( ss == CM_SS_HYBR_3 )
    {
      ph_ptr->hybr_3_stack_info.ps_signaling_down_wait_time = time_get_uptime_secs() + wait_time;
      ph_ptr->hybr_3_stack_info.is_ps_srv_req_sent = FALSE;
    }
    else
    #endif
    {
      ph_ptr->ps_signaling_down_wait_time = time_get_uptime_secs() + wait_time;
      ph_ptr->is_ps_srv_req_sent = FALSE;
    }
  }
  else
  {
    if( ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
    {
      ph_ptr->hybr_2_stack_info.ps_signaling_down_wait_time = wait_time;
      ph_ptr->hybr_2_stack_info.is_ps_srv_req_sent = FALSE;
    }
    else
    #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
    if( ss == CM_SS_HYBR_3 )
    {
      ph_ptr->hybr_3_stack_info.ps_signaling_down_wait_time = wait_time;
      ph_ptr->hybr_3_stack_info.is_ps_srv_req_sent = FALSE;
    }
    else
    #endif
    {
      ph_ptr->ps_signaling_down_wait_time = wait_time;
      ph_ptr->is_ps_srv_req_sent = FALSE;
    }
  }

  SYS_ARG_NOT_USED(ss);

} /* cmph_set_ps_sig_down_ind_wait_flag */

/*===========================================================================

FUNCTION cmph_is_waiting_for_ps_sig_down

DESCRIPTION

   This function return TRUE if CM is waiting for
   the PS Signaling down indication from lower layers.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
 TRUE  : If CM is waiting for the PS Sig Down Ind from Lower Layers.
 FALSE : If CM is not waiting for the PS Sig Down Ind from Lower Layers.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_waiting_for_ps_sig_down(

        cm_ss_e_type    ss
          /* Stack */
)
{
  /* Get the pointer to the phone object */
  cmph_s_type             *ph_ptr = cmph_ptr();

  dword                   wait_time = 0;
  dword                   uptime    = time_get_uptime_secs();

  if( ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
  {
    wait_time = ph_ptr->hybr_2_stack_info.ps_signaling_down_wait_time;
  }
  else
  #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 )
  {
    wait_time = ph_ptr->hybr_3_stack_info.ps_signaling_down_wait_time;
  }
  else
  #endif
  if( ss == cmph_map_sd_ss_type_to_cm_ss_type( SD_SS_MAIN )
             && cmss_ptr()->info.sys_mode != SYS_SYS_MODE_CDMA)
  {
    wait_time = ph_ptr->ps_signaling_down_wait_time;
  }

  if( wait_time >= uptime )
  {
  CM_MSG_HIGH_2("Still in PS Signaling Wait period, sig_uptime=%ld, uptime=%ld",
                   wait_time, uptime);
    return TRUE;
  }

  return FALSE;

} /* cmph_set_ps_sig_down_ind_wait_flag */

/*===========================================================================

FUNCTION cmph_als_reset

DESCRIPTION

  ALS custom object was reset due to PH receiving subscription available,
  not available or changed event, so reset ALS settings in PH object.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void cmph_als_reset(void)
{

  cmph_s_type     *ph_ptr = cmph_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Reset ALS info after GW subscription changed.
  ** If GW subscription is still available,
  ** the phone will re-read ALS settings and send
  ** appropriate events later
  */
  ph_ptr->cphs_allowed   =  CM_CPHS_PROC_NOT_ALLOWED;
  ph_ptr->als_allowed    =  CM_ALS_PROC_NOT_ALLOWED;
  ph_ptr->line_switching =  CM_ALS_LINE_SWITCHING_NONE;
  ph_ptr->line           =  CM_ALS_LINE_NONE;

}

/*===========================================================================

FUNCTION cmph_als_supported

DESCRIPTION

  ALS is supported when:

  - CPHS is allowed
  - ALS is allowed

DEPENDENCIES

  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
boolean cmph_als_supported(void)
{

  cmph_s_type                *ph_ptr  = cmph_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( CM_INIT_CHECK(ph_ptr->init_mask) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return CM_BOOLEAN((ph_ptr->cphs_allowed == CM_CPHS_PROC_ALLOWED) &&
                    (ph_ptr->als_allowed  == CM_ALS_PROC_ALLOWED));
}



/*===========================================================================

FUNCTION cmph_is_valid_network_type_for_ss

DESCRIPTION
  Check whether a given network type is valid.

DEPENDENCIES
  none

RETURN VALUE
  TRUE if network type is valid, FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_valid_network_type_on_ss
(
    cm_ss_e_type                   ss,
        /* Indicates the SS-Instance */

    cm_mode_pref_e_type    network_type
        /* network type to check */
)
{
  sd_ss_mode_pref_e_type     sd_mode_pref    = \
    cmph_map_cm_mode_pref_to_sd_mode_pref(network_type);

  /* CM not to terminate get networks on other sub if preference change is
  ** on different sub*/
  if((cmph_is_dsds()||cmph_is_tsts()) && ss != CM_SS_MAX
     && cmph_ptr()->ss_for_get_networks != ss)
  {
     return FALSE;
  }

  /* Check for valid G/W/L/TDS network type mode.
  */
  if( ((SD_MODE_CONTAIN(sd_mode_pref, SD_SS_MODE_PREF_GSM)    ||
        SD_MODE_CONTAIN(sd_mode_pref, SD_SS_MODE_PREF_WCDMA)  ||
        SD_MODE_CONTAIN(sd_mode_pref, SD_SS_MODE_PREF_LTE)    ||
        SD_MODE_CONTAIN(sd_mode_pref, SD_SS_MODE_PREF_TDS))
        && (ss == CM_SS_HYBR_2 || ss == CM_SS_HYBR_3 || ss == CM_SS_MAIN\
             || ss == CM_SS_HYBR_1 || ss == CM_SS_MAX)
      )
  )
  {
    return TRUE;
  }

  return FALSE;

} /* cmph_is_valid_network_type_for_ss() */


/*===========================================================================

FUNCTION cmph_term_pending_get_networks_req

DESCRIPTION

  This function should be called when the phone preferences have changed or
  There is operation mode change other than online.
  - If there is a pending get network request, send a terminate event to
    clients and reset the flag.

DEPENDENCIES

  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void cmph_term_pending_get_networks_req
(
    cm_ss_e_type                   ss
        /* Indicates the SS-Instance ( SS_MAIN or SS_HDR) based on which
        ** the corresponding getNetworks requests are terminated.
        */
)
{

  cmph_s_type                *ph_ptr  = cmph_ptr();
    /* Pointer to a phone object */
  cm_mode_pref_e_type        network_type;

  sys_modem_as_id_e_type  asubs_id = cmph_map_cm_ss_to_subs(ss);

  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if(cmph_is_dsda() && asubs_id == SYS_MODEM_AS_ID_2)
  {
    #ifdef FEATURE_MMODE_SXLTE_G
    if (cmph_is_sxlte())
    {
      network_type = ph_ptr->hybr_3_stack_info.pref_info.network_type;
    }
    else
    #endif
    {
      network_type = ph_ptr->hybr_2_stack_info.pref_info.network_type;
    }
  }
  else
  #endif
  {
    network_type = ph_ptr->main_stack_info.pref_info.network_type;
  }
  /* Terminate any pending get network list request and reset the flag.
  ** based on the Stack for non-SVLTE config.
  ** SD_SS_MAIN - G/W/L/TDS request can be terminated
  ** SD_SS_MAX  - Any (G/W/L/TDS) request can be terminated
  */
  if( cmph_is_valid_network_type_on_ss(ss, network_type) )
  {
    mmoc_cmd_term_get_networks_gw(cmph_map_cm_ss_type_to_sd_ss_type(ss));

    ph_ptr->ss_for_get_networks = CM_SS_NONE;

    #ifdef FEATURE_MMODE_DUAL_ACTIVE
    if(cmph_is_dsda())
    {
      if(asubs_id == SYS_MODEM_AS_ID_2)
      {
        #ifdef FEATURE_MMODE_SXLTE_G
        if (cmph_is_sxlte())
        {
          ph_ptr->hybr_3_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
        }
        else
        #endif
        {
          ph_ptr->hybr_2_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
        }
      }
      else
      {
        ph_ptr->main_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
      }
      cmph_event_per_subs( ph_ptr, CM_PH_EVENT_TERMINATE_GET_NETWORKS,ss );
    }
    else
    #endif
    {
       /* In SVLTE config when MAIN stack is in suspended state due to get networks
       ** on HYBRD 2 stack
       ** a) send the terminate get net event and
       ** b) do not reset the flag.
       ** Stop mode request will be sent to nas and on stop mode cnf check for
       ** network_type to resume MAIN stack and then clear the flag */
      
      #ifdef FEATURE_MMODE_SC_SVLTE
      if (ph_ptr->ss_susp_info[CM_SS_MAIN].is_suspend == TRUE &&
         cmph_is_subs_feature_mode_1x_sxlte(asubs_id))
      {

        cmph_event( ph_ptr, CM_PH_EVENT_TERMINATE_GET_NETWORKS );
        return;
      }
      #endif
      cmph_event( ph_ptr, CM_PH_EVENT_TERMINATE_GET_NETWORKS );
      ph_ptr->main_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;

    }
  }

  return;

}

/*===========================================================================

FUNCTION cmph_term_pending_get_networks_req_client_only

DESCRIPTION

  This function should be called when the phone preferences have changed or
  There is operation mode change other than online.
  - If there is a pending get network request, send a terminate event to
    clients and reset the flag.

DEPENDENCIES

  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void cmph_term_pending_get_networks_req_client_only
(
    cm_ss_e_type                   ss
        /* Indicates the SS-Instance ( SS_MAIN or SS_HDR) based on which
        ** the corresponding getNetworks requests are terminated.
        */
)
{

  cmph_s_type                *ph_ptr  = cmph_ptr();
    /* Pointer to a phone object */
  sys_modem_as_id_e_type  asubs_id = cmph_map_cm_ss_to_subs(ss);

  cm_mode_pref_e_type        network_type;
  /* Terminate any pending get network list request and reset the flag.
  ** based on the Stack.
  ** SD_SS_MAIN - G/W/L/TDS request can be terminated
  ** SD_SS_MAX  - Any (G/W/L/TDS) request can be terminated
  */
  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if(cmph_is_dsda() && asubs_id == SYS_MODEM_AS_ID_2)
  {
    #ifdef FEATURE_MMODE_SXLTE_G
    if (cmph_is_sxlte())
    {
      network_type = ph_ptr->hybr_3_stack_info.pref_info.network_type;
    }
    else
    #endif
    {
      network_type = ph_ptr->hybr_2_stack_info.pref_info.network_type;
    }
  }
  else
  #endif
  {
    network_type = ph_ptr->main_stack_info.pref_info.network_type;
  }

  if( cmph_is_valid_network_type_on_ss(ss, network_type))
  {
    ph_ptr->ss_for_get_networks = CM_SS_NONE;

    #ifdef FEATURE_MMODE_DUAL_ACTIVE
    if(cmph_is_dsda() )
    {
      if(asubs_id == SYS_MODEM_AS_ID_2)
      {
        #ifdef FEATURE_MMODE_SXLTE_G
        if (cmph_is_sxlte())
        {
          ph_ptr->hybr_3_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
        }
        else
        #endif
        {
          ph_ptr->hybr_2_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
        }
      }
      else
      {
        ph_ptr->main_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
      }
      cmph_event_per_subs( ph_ptr, CM_PH_EVENT_TERMINATE_GET_NETWORKS,ss );
    }
    else
    #endif
    {
       /* For SVLTE config do not reset network type. When stop mode
       ** confirmation is received from NAS indicating LTE is shutdown
       ** resume MAIN stack and set network type to NONE
       */
      #ifdef FEATURE_MMODE_SC_SVLTE
      if (ph_ptr->ss_susp_info[CM_SS_MAIN].is_suspend == TRUE &&
         cmph_is_subs_feature_mode_1x_sxlte(asubs_id))
      {

        cmph_event( ph_ptr, CM_PH_EVENT_TERMINATE_GET_NETWORKS );
        return;
      }
      #endif

      cmph_event( ph_ptr, CM_PH_EVENT_TERMINATE_GET_NETWORKS );
      ph_ptr->main_stack_info.pref_info.network_type = CM_MODE_PREF_NONE;
    }
  }

  return;

}

static boolean cmph_is_lte_only_search_allowed
(
  cmcall_s_type              *call_ptr,
  
  cm_ph_cmd_info_s_type      *cmd_info_ptr
)
{

  if (call_ptr == NULL || cmd_info_ptr == NULL)
  {
    return FALSE;
  }

  #if defined (FEATURE_MMODE_CDMA_800)|| defined (FEATURE_MMODE_CDMA_1900)
  CM_MSG_HIGH_3("is_lte_only_search_allowed call_type %d sms_in_progress %d dbm_in_prog %d",\
    call_ptr->call_type,\
    cmxsms_is_mo_sms_in_progress(),\
    cmxdbm_is_mo_dbm_in_progress());

  CM_MSG_HIGH_3("is_lte_only_search_allowed srv_type %d net_work_type %d resultant_mode_pref %d",\
    call_ptr->srv_type,\
    cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->network_type),\
    (cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->network_type) &
       (SD_SS_MODE_PREF_GWL)));
	
  if ((call_ptr->call_type == CM_CALL_TYPE_PS_DATA &&  // this is specific to  call on LTE, where we should allow it for all type of search
        call_ptr->srv_type == CM_SRV_TYPE_NONE))
  {
    CM_MSG_HIGH_0("LTE data call allow search");
    return TRUE;
  }
  
  /* Check for Voice/SMS/DATA activity  on 1X, if MANUAL SEARCH is on SUB 1*/
  if (((call_ptr->call_type == CM_CALL_TYPE_VOICE) ||
       (call_ptr->call_type == CM_CALL_TYPE_SMS) ||
       cmxsms_is_mo_sms_in_progress() ||
       cmxdbm_is_mo_dbm_in_progress() ||
       ((call_ptr->call_type == CM_CALL_TYPE_PS_DATA) &&
        ((call_ptr->srv_type == CM_SRV_TYPE_HDR) ||
         (call_ptr->srv_type == CM_SRV_TYPE_CDMA_SPECIFIC) ||
         (call_ptr->srv_type == CM_SRV_TYPE_CDMA_AUTOMATIC)||
         (call_ptr->srv_type == CM_SRV_TYPE_CDMA_HDR) ||
         (call_ptr->srv_type == CM_SRV_TYPE_HDR_MORE_PREF)))) &&
      ((cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->network_type) &
       (SD_SS_MODE_PREF_GWL)) == SD_SS_MODE_PREF_LTE))
  {
    return TRUE;
  }

  #endif

  return FALSE;
}

/*===========================================================================

FUNCTION  cmph_cmd_get_networks_para_check

DESCRIPTION
  This function validates the get networks command parameters.

  If the network list type is CM_NETWORK_LIST_USER_PREFERRED, then
  an attempt is made to read the list from the (U)SIM.

DEPENDENCIES
  none

RETURN VALUE
  CM_PH_CMD_ERR_NOERR if no parameter related errors,
  otherwise specific cm_ph_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ph_cmd_err_e_type     cmph_cmd_get_networks_para_check
/*lint -esym(818, ph_ptr) */
(

  cmph_s_type                *ph_ptr,
      /* Pointer to a phone object */

  cm_ph_cmd_s_type           *ph_cmd_ptr
     /* Pointer at phone command component */
)
{
  cm_ph_cmd_info_s_type      *cmd_info_ptr = NULL;
  cm_ph_cmd_err_e_type        cmd_err      = CM_PH_CMD_ERR_NOERR;
  cm_ss_e_type                     ss           = CM_SS_MAIN;
  sys_modem_as_id_e_type     asubs_id = SYS_MODEM_AS_ID_1;
  cm_mode_pref_e_type          network_type = CM_MODE_PREF_NONE;
  sd_ss_band_pref_e_type       sd_band_pref        = SD_SS_BAND_PREF_NONE;

  sd_ss_mode_pref_e_type       sd_mode_pref        = SD_SS_MODE_PREF_NONE;

  sys_lte_band_mask_e_type     sd_lte_band_pref    = SYS_LTE_BAND_MASK_CONST_NONE;
  sd_ss_band_pref_e_type       sd_tds_band_pref    = SD_SS_BAND_PREF_NONE;
  cmss_s_type         *ss_ptr        = cmss_ptr();
  sys_lte_band_mask_e_type     ph_ss_lte_band_pref = CMPH_SS_LTE_BAND_PREF(asubs_id, ph_ptr);
  #ifdef CM_GW_SUPPORTED
  sys_user_pref_plmn_list_s_type   user_pref_networks;
  boolean                          is_packed_req = FALSE;
  #endif
  cmcall_s_type   *call_ptr;                        /* Call object pointer */
  cm_iterator_type call_itr;

  mmgsdi_session_type_enum_type  session_type=MMGSDI_MAX_SESSION_TYPE_ENUM;
  cm_mmgsdi_error_e_type cm_mmgsdi_status=CM_MMGSDI_UNSUPPORTED;
  cm_mode_pref_e_type ph_mode_pref;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ph_ptr     != NULL);
  CM_ASSERT(ph_cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );

  if (cmph_is_msim())
  {
    asubs_id = cmd_info_ptr->cmd_subs;
    ss = cmph_map_subs_to_ss(cmd_info_ptr->cmd_subs);
  }

  CM_MSG_HIGH_2("get network cmd_subs=%d, ss=%d",
                          cmd_info_ptr->cmd_subs, ss);

  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if(cmph_is_dsda() && asubs_id == SYS_MODEM_AS_ID_2)
  {
    #if defined(FEATURE_MMODE_SXLTE_G)
    if (cmph_is_sxlte())
    {
      network_type = ph_ptr->hybr_3_stack_info.pref_info.network_type;
    }
    else
    #endif
    {
      network_type = ph_ptr->hybr_2_stack_info.pref_info.network_type;
    }
  }
  else
  #endif
  {
    network_type = ph_ptr->main_stack_info.pref_info.network_type;
  }

    if(asubs_id == SYS_MODEM_AS_ID_2)
    {
      #if defined(FEATURE_MMODE_SXLTE_G)
      if (cmph_is_sxlte())
      {
        ph_mode_pref = ph_ptr->hybr_3_stack_info.pref_info.mode_pref;
      }
      else
      #endif
      {
        ph_mode_pref = ph_ptr->hybr_2_stack_info.pref_info.mode_pref;
      }
    }
    else
    #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
    if(ss == CM_SS_HYBR_3)
    {
      ph_mode_pref = ph_ptr->hybr_3_stack_info.pref_info.mode_pref;
    }
    else
    #endif
    {
      ph_mode_pref = ph_ptr->main_stack_info.pref_info.mode_pref;
    }


   if(cmd_info_ptr->network_type == CM_MODE_PREF_NO_CHANGE &&(cmd_info_ptr->network_list_type !=
       CM_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND) )
  {
    
    cmd_info_ptr->network_type = cmph_map_sd_mode_pref_to_cm_mode_pref(
        SD_GET_COMMON_MODE(cmph_map_cm_mode_pref_to_sd_mode_pref(ph_mode_pref),\
            SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE)
               );
    }


  if( ph_mode_pref != CM_MODE_PREF_LTE_ONLY &&
      cmd_info_ptr->network_list_type == CM_NETWORK_LIST_PCI_SCAN )
  {
    cmd_err = CM_PH_CMD_ERR_NET_TYPE_P;
    return cmd_err;
  }

  if(cmd_info_ptr->network_type != CM_MODE_PREF_LTE_ONLY
    && cmd_info_ptr->network_list_type == CM_NETWORK_LIST_PCI_SCAN )
  {
    cmd_err = CM_PH_CMD_ERR_NET_TYPE_P;
    return cmd_err;
  }

  if( (network_type != CM_MODE_PREF_NONE &&
      network_type != cmd_info_ptr->network_type) )
  {
    /* Currently we support one type of get network request at a time
    ** If we come here, it means one type of request is pending while
    ** GetNetwork request for a different type of network arrives.
    */
    cmd_err = CM_PH_CMD_ERR_GET_NETWORKS_S;
    return cmd_err;
  }

  if(!is_contain_3GPP_mode_pref(cmd_info_ptr->network_type))
  {
    /* Unsupported network list requested.
    */
    cmd_err = CM_PH_CMD_ERR_NET_TYPE_P;
    return cmd_err;
  }

  /* Service the get_networks request only if the service domain preferance
  ** is valid. This condition is applicable only for GWL.
  */
  #if (defined CM_GW_SUPPORTED || defined(FEATURE_CM_LTE))
  if (!BETWEEN (CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr),
                CM_SRV_DOMAIN_PREF_NONE, CM_SRV_DOMAIN_PREF_MAX))
  {
    cmd_err = CM_PH_CMD_ERR_SERVICE_DOMAIN_P;
    CM_MSG_HIGH_1( "Invalid service domain pref parameter for get_networks: %d",
             CMPH_SS_SRV_DOMAIN_PREF(asubs_id, ph_ptr));
    return cmd_err;
  }
  #endif

  if( cmd_info_ptr->network_list_type != CM_NETWORK_LIST_WITH_MAX_CAP )
  {
  /* For LTE only search if the SIM is 2G reject the search */
  cm_mmgsdi_status = cm_mmgsdi_ssn_tbl_get_type_for_asubs_id_gw(
                                          asubs_id,
                                          &session_type);
  if(MMGSDI_MAX_SESSION_TYPE_ENUM != session_type &&
     cm_mmgsdi_status == CM_MMGSDI_SUCCESS &&
     cmd_info_ptr->network_type == CM_MODE_PREF_LTE_ONLY)
  {

    if(cm_mmgsdi_ssn_tbl_get_app_type_for_type(session_type)==MMGSDI_APP_SIM )
    {

      CM_MSG_HIGH_1("GET_NET rejected for LTE only SIM when SIM is 2G %d",session_type);

      cmd_err = CM_PH_CMD_ERR_GET_NETWORKS_S;
      return cmd_err;

    }
  }
  }


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  sd_mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref( cmd_info_ptr->network_type);

  sd_band_pref      = cmph_map_cm_band_pref_to_sd_band_pref(
                                           cmd_info_ptr->band_pref_lmt);
  sd_lte_band_pref  = cmd_info_ptr->lte_band_pref_lmt;
  sd_tds_band_pref  = cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                                             cmd_info_ptr->tds_band_pref_lmt);
  /* For non SGLTE restrict  mode/band based on Policy man capability. If none of the mode/band is supported
        reject network search */
  /* Do not restrict mode and band capabilities to PM restricted capabilities for CM_NETWORK_LIST_WITH_MAX_CAP */
  if(!cmph_is_feature_mode_sglte() && (cmd_info_ptr->network_list_type != CM_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND) &&
  	(cmd_info_ptr->network_list_type != CM_NETWORK_LIST_WITH_MAX_CAP ))
  {
    cmmsc_state_machine_s_type   *state_machine_ptr = cmmsimc_state_machine_ptr(cmd_info_ptr->cmd_subs);

    /* Get net modes, bands are filtered based on Policy Man settings.
        */

    CM_MSG_HIGH_1("ue mode capability %d", cmph_map_sys_mode_mask_to_sd_mode_pref(state_machine_ptr->stack_common_info.ue_mode_capability));
    sd_mode_pref = SD_GET_COMMON_MODE( sd_mode_pref,
                   cmph_map_sys_mode_mask_to_sd_mode_pref(state_machine_ptr->stack_common_info.ue_mode_capability));

    sd_band_pref = SD_GET_COMMON_BAND(sd_band_pref, state_machine_ptr->stack_common_info.ue_band_capability);
    sd_lte_band_pref = SYS_LTE_BAND_MASK_COMMON(&sd_lte_band_pref , &(state_machine_ptr->stack_common_info.ue_lte_band_capability));
    sd_tds_band_pref = SD_GET_COMMON_BAND(sd_tds_band_pref, state_machine_ptr->stack_common_info.ue_tds_band_capability);
  }
  if (! sd_misc_is_target_supp_mode_band ( sd_mode_pref,
                                              cmph_map_cm_band_pref_to_sd_band_pref(CMPH_SS_BAND_PREF(asubs_id, ph_ptr)) &
                                              sd_band_pref,
                                              SYS_LTE_BAND_MASK_COMMON(&ph_ss_lte_band_pref, &sd_lte_band_pref),
                                              cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(CMPH_SS_TDS_BAND_PREF(asubs_id, ph_ptr)) &
                                              sd_tds_band_pref
                                              )
     )
  {
    /* Target does not support the network type requested to search for.
    */
    cmd_err = CM_PH_CMD_ERR_NET_TYPE_P;

    CM_MSG_HIGH_1("Mode pref %d", sd_mode_pref);
    CM_MSG_HIGH_4("PH GW  BAND PREF 0x%08x %08x, PH TDS BAND PREF 0x%08x %08x",
      QWORD_HIGH(ph_ptr->main_stack_info.pref_info.band_pref), QWORD_LOW(ph_ptr->main_stack_info.pref_info.band_pref),
      QWORD_HIGH(ph_ptr->main_stack_info.pref_info.tds_band_pref), QWORD_LOW(ph_ptr->main_stack_info.pref_info.tds_band_pref));
    cm_print_lte_band_mask(ph_ptr->main_stack_info.pref_info.lte_band_pref);

    return cmd_err;
  }

  if(cmph_is_msim()&& (cmd_info_ptr->network_list_type != CM_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND))
  {
    sd_ss_mode_pref_e_type subs_capability;

    if(ss == CM_SS_HYBR_2 && !cmph_is_sxlte())
    {
      subs_capability = cmph_map_sys_mode_mask_to_sd_mode_pref(
                   ph_ptr->hybr_2_stack_info.subs_capability);
    }
    #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
    else if(ss == CM_SS_HYBR_3)
    {
      subs_capability = cmph_map_sys_mode_mask_to_sd_mode_pref(
                   ph_ptr->hybr_3_stack_info.subs_capability);
    }
    #endif
    else
    {
      subs_capability = cmph_map_sys_mode_mask_to_sd_mode_pref(
                    ph_ptr->main_stack_info.subs_capability);
    }

    cmd_info_ptr->network_type = cmph_map_sd_mode_pref_to_cm_mode_pref(
        SD_GET_COMMON_MODE(cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->network_type),\
            subs_capability)
               );
  }

  CM_MSG_HIGH_2("get network global mode plmn search support %d csg support %d",
                      ph_ptr->get_net_auto_mode_enabled.get_net_auto_mode,
                      ph_ptr->csg_auto_mode.csg_global_mode_support);

  /*
  ** Check if the phones current mode contains any 3GPP2 mode
  ** and target capability supports 3GPP2.
  */
  if (  sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_CDMA_HDR,
                                          SD_SS_BAND_PREF_ANY,
                                          SYS_LTE_BAND_MASK_CONST_ANY,
                                          SD_SS_BAND_PREF_NONE)
        &&
          cmcall_misc_is_mode_pref(CMPH_SS_MODE_PREF(asubs_id, ph_ptr),
                                   CM_MODE_PREF_CDMA_HDR_ONLY)

        &&
          SD_MODE_CONTAIN(cmmsc_get_cm_ss_mode_cap(ss),SD_SS_MODE_PREF_CDMA_HDR)
     )
  {

    if (((cmd_info_ptr->network_list_type == CM_NETWORK_LIST_AVAILABLE ||
		 cmd_info_ptr->network_list_type == CM_NETWORK_LIST_WITH_MAX_CAP ) &&
         ph_ptr->get_net_auto_mode_enabled.get_net_auto_mode)
      ||
       /*Manual CSG search */
       (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG &&
        (ph_ptr->csg_auto_mode.csg_global_mode_support == CSG_MANUAL_AND_APP_SUPPORT||
        ph_ptr->csg_auto_mode.csg_global_mode_support == CSG_MANUAL_SUPPORT))
          ||
          /* CSG app search */
       ((cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG_USER ||
       cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG_SELECTION_APP) &&
       (ph_ptr->csg_auto_mode.csg_global_mode_support == CSG_MANUAL_AND_APP_SUPPORT||
        ph_ptr->csg_auto_mode.csg_global_mode_support == CSG_APP_SUPPORT) )
          ||
        (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND &&
        ph_ptr->get_net_auto_mode_enabled.get_net_auto_mode)
		||
		(cmd_info_ptr->network_list_type == CM_NETWORK_LIST_PCI_SCAN)
		)
    {
          sd_ss_mode_pref_e_type sd_mode_pref =
            cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->network_type);

          /* For SVLTE conf if CSG app search contains W + L reject */
          if(cmph_is_subs_feature_mode_1x_sxlte(asubs_id) &&
            (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG_USER ||
          cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG_SELECTION_APP) &&
          (SD_MODE_CONTAIN( sd_mode_pref, SD_SS_MODE_PREF_WCDMA)&&
          SD_MODE_CONTAIN( sd_mode_pref, SD_SS_MODE_PREF_LTE)) )
        {
         cmd_err = CM_PH_CMD_ERR_NET_TYPE_P;

            CM_MSG_HIGH_1( "Invalid config: cmd_info_ptr->network_type= %d",cmd_info_ptr->network_type);
          return cmd_err;
        }

    }
    /*If NV not enabled reject the search */
    else
    {
      /* Target does not support the network type requested while 3GPP2 is enabled.
      */
      cmd_err = CM_PH_CMD_ERR_NET_TYPE_P;
      CM_MSG_HIGH_1( "Invalid config: ph_ptr->main_stack_info.pref_info.mode_pref= %d",ph_ptr->main_stack_info.pref_info.mode_pref);

      return cmd_err;
    }
  }

  /* If UE is in thermal emergency mode, do not allow the SMS */
  if(cmac_is_in_thermal_emergency())
  {
    cmd_err = CM_PH_CMD_ERR_IN_USE_S;
  
    CM_MSG_HIGH_0( "GET_NET: Phone in Thermal emergency");
    return cmd_err;
  }

  /* get_net_auto is enbaled and SEARCH is on SUB 1 */
  /* Target supports 3gpp2 */
  if(((ph_ptr->get_net_auto_mode_enabled.get_net_auto_mode) ||
      (ph_ptr->csg_auto_mode.csg_global_mode_support)
      )
     &&
      (ss == CM_SS_MAIN)
     &&
      (sd_misc_is_target_supp_mode_band (SD_SS_MODE_PREF_CDMA_HDR,
                                          SD_SS_BAND_PREF_ANY,
                                          SYS_LTE_BAND_MASK_CONST_ANY,
                                          SD_SS_BAND_PREF_NONE)
        &&
       cmcall_misc_is_mode_pref(CMPH_SS_MODE_PREF(asubs_id, ph_ptr),
                                   CM_MODE_PREF_CDMA_HDR_ONLY)
     )
     )
  {

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    /*
      ** Check for ECBM and thermal emergency
      */
    if(cmph_get_last_pref_sent(CM_SS_MAIN) != NULL )
    {
      CM_MSG_HIGH_1("cmph_get_last_pref_sent(CM_SS_MAIN)->orig_mode %d",cmph_get_last_pref_sent(CM_SS_MAIN)->orig_mode);

      if (cmph_get_last_pref_sent(CM_SS_MAIN)->orig_mode == SD_SS_ORIG_MODE_EMERG_CB )
      {
        cmd_err = CM_PH_CMD_ERR_IN_USE_S;

        CM_MSG_HIGH_0( "GET_NET: Phone in Emergency call back mode");
      return cmd_err;
    }
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /*
  ** Check for voice or emergency call activity
  */
  cmcall_obj_iterator_init(&call_itr);

  call_ptr = cmcall_obj_get_next(&call_itr);
  while(call_ptr != NULL)
  {
    /* In DUAL stack home mode of operation */
    if (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) && 
        ss_ptr->info.is_hybr_gw_operational )
    {
      /* For SVLTE configuration, search initiated for LTE only can be allowed during
      ** 1x voice/data/SMS  call
      */
      if (cmph_is_lte_only_search_allowed(call_ptr, cmd_info_ptr))
      {
        CM_MSG_HIGH_0("Allow LTE only search during 1x activity for svlte ");
      }
      else
      {
        /* GW SERACH is made while call is active on 1X */
        cmd_err = CM_PH_CMD_ERR_IN_USE_S;
        CM_MSG_HIGH_1( "GET_NET: call in progress call_ptr->call_type = %d",
        call_ptr->call_type);
        return cmd_err;
      }
    }
    else
    {
      /* In roaming mode, follow the legacy behavior to reject the MANUAL SEARCH during active call*/
      if ( cmcall_is_there_a_call_activity( ss ) )
      {
        cmd_err = CM_PH_CMD_ERR_IN_USE_S;
        CM_MSG_HIGH_1( "GET_NET: call in progress call_ptr->call_type = %d on SUB1",
            call_ptr->call_type);
        return cmd_err;
      }
    }
    call_ptr = cmcall_obj_get_next(&call_itr);
   } /* while */
  }// plmn / csg search in auto mode
  else
  {
    if ( cmcall_is_there_a_call_activity( ss ) )
    {
      CM_MSG_HIGH_0( "Call Activity On-Going. Rej GET_NET" );
      cmd_err = CM_PH_CMD_ERR_IN_USE_S;
    }
  }

  if(cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG ||
     cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG_USER ||
     cmd_info_ptr->network_list_type == CM_NETWORK_LIST_CSG_SELECTION_APP)
  {

    if (!is_contain_3GPP_mode_pref(cmd_info_ptr->network_type))
    {
       CM_MSG_HIGH_0( "Network_type doesn't have any 3gpp rat in CSG search request");	  
       cmd_err = CM_PH_CMD_ERR_MODE_PREF_S;
       return cmd_err;
    }
  
    if(ph_ptr->csg_support == SYS_CSG_SUPPORT_DISABLED )
    {
      /* CSG feature is disabled but GetNetwork request for CSG type.
      */
      CM_MSG_HIGH_0( "SYS_CSG_SUPPORT_DISABLED");
      cmd_err = CM_PH_CMD_ERR_NETWORK_LIST_TYPE_P;
      return cmd_err;
    }
    else
    {	
      cm_mode_pref_e_type cm_mode_pref;
      sd_ss_mode_pref_e_type sd_mode_pref; 
      sd_mode_pref = cmph_map_cm_mode_pref_to_sd_mode_pref(cmd_info_ptr->network_type);             

      if(ph_ptr->csg_support == SYS_CSG_SUPPORT_WCDMA_LTE )
      {
        /* Filter the 3GPP Rats based upon the CSG support
        */
          sd_mode_pref = (sd_mode_pref & (SD_SS_MODE_PREF_WCDMA_LTE));
      }
      else if(ph_ptr->csg_support == SYS_CSG_SUPPORT_WCDMA )
      {
        /* Filter the 3GPP Rats based upon the CSG support
        */
          sd_mode_pref = (sd_mode_pref & (SD_SS_MODE_PREF_WCDMA));
      }

      if(sd_mode_pref == SD_SS_MODE_PREF_NONE)
      {
        /* GET_NET_REQ doesn't have any of the supported CSG RAT, Reject command
        */
          CM_MSG_HIGH_2( "CSG: PHCMD REJ. SYS_CSG_SUPPORT %d CMD nw_type:%d",
          ph_ptr->csg_support, cmd_info_ptr->network_type);
          cmd_err = CM_PH_CMD_ERR_NETWORK_LIST_TYPE_P;
          return cmd_err;
      }
      
      cm_mode_pref = cmph_map_sd_mode_pref_to_cm_mode_pref(sd_mode_pref);
      CM_MSG_HIGH_2("CSG: CMD nw_type: %d  New supported nw_type %d", cmd_info_ptr->network_type, cm_mode_pref);

      cmd_info_ptr->network_type = cm_mode_pref;
		 
    }	

  }
  else if ( cmd_info_ptr->network_list_type == CM_NETWORK_LIST_USER_PREFERRED ||
       cmd_info_ptr->network_list_type == CM_NETWORK_LIST_USER_PREFERRED_UNPACKED )
  {
    /*
    ** Attempt to read the User Preferred PLMN List from the (U)SIM.
    */

    #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
    /* is_packed_req indicates if user wants to read the file without
    ** collapsing invalid entries or not. If is_packed_req = TRUE, it means
    ** user does not want invalid entries.
    */
    if(cmd_info_ptr->network_list_type == CM_NETWORK_LIST_USER_PREFERRED)
    {
      is_packed_req = TRUE;
    }
    #endif

    /* This request is allowed only for GW*/

    if (!is_contain_3GPP_mode_pref(cmd_info_ptr->network_type))
    {
      cmd_err = CM_PH_CMD_ERR_MODE_PREF_S;
      return cmd_err;
    }
    #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
    else if ( cmmmgsdi_read_preferred_plmn_list(ss, &user_pref_networks,
                                                is_packed_req)
            )

    {
      if ( ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
      {
        ph_ptr->hybr_2_stack_info.user_pref_networks = user_pref_networks;
      }
      else
      #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
      if ( ss == CM_SS_HYBR_3 )
      {
        ph_ptr->hybr_3_stack_info.user_pref_networks = user_pref_networks;
      }
      else
      #endif
      {
        ph_ptr->main_stack_info.user_pref_networks = user_pref_networks;
      }
    }
    else
    {
      cmd_err = CM_PH_CMD_ERR_USER_PREFERRED_NETWORK_LIST_ACCESS;
      CM_ERR_0( "Preferred user PLMN list could not be read");
      return cmd_err;
    }
    #endif
  }
  else if ( cmd_info_ptr->network_list_type != CM_NETWORK_LIST_AVAILABLE &&
      cmd_info_ptr->network_list_type != CM_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND
	  && cmd_info_ptr->network_list_type != CM_NETWORK_LIST_PCI_SCAN &&
          cmd_info_ptr->network_list_type != CM_NETWORK_LIST_WITH_MAX_CAP )
  {
    cmd_err = CM_PH_CMD_ERR_NETWORK_LIST_TYPE_P;
    CM_ERR_1( "Invalid get networks cmd network list type param %d",
            cmd_info_ptr->network_list_type);
    return cmd_err;
  }

  if (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_WITH_MAX_CAP &&
      !(asubs_id == ph_ptr->default_data_subs &&
      ph_ptr->dds_switch_type == DDS_CAUSE_PERMANENT) )
  {
    CM_MSG_HIGH_2("GET NET WITH_MAX_CAP rejected. on non_dds_sub not allowed dds %d dds_cause %d",
                ph_ptr->default_data_subs, ph_ptr->dds_switch_type);
    cmd_err = CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P;
    return cmd_err;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Check if the stack corresponding to this get networks request
  ** is active. If not, return error.
  */
  if( ((ss == CM_SS_HYBR_2 && !cmss_is_hybr2_operational())
      #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
      || (ss == CM_SS_HYBR_3 && !cmss_is_hybr3_operational())
      #endif
      ||(ss == CM_SS_MAIN && !cmss_is_main_operational()))
        &&
        cmph_is_msim())
  {
    CM_MSG_HIGH_1("get networks not allowed on ss %d", ss);
    cmd_err = CM_PH_CMD_ERR_INVALID_SUBSCRIPTION_P;
    return cmd_err;
  }

  CM_MSG_HIGH_6("network_type %d, cmd_info->network_type %d, cmd_subs %d, active_subs %d, cdma_subs_avail %d, gw_subs_avail %d", 
  	network_type, cmd_info_ptr->network_type, cmd_info_ptr->cmd_subs,\
    ph_ptr->active_subs, ph_ptr->is_cdma_subscription_available,\
    ph_ptr->is_gwl_subscription_available);

  if( cmd_info_ptr->network_list_type != CM_NETWORK_LIST_WITH_MAX_CAP && 
  	  ph_ptr->is_cdma_subscription_available &&
       !ph_ptr->is_gwl_subscription_available &&
       (!cmcall_misc_is_mode_pref(CMPH_SS_MODE_PREF(SYS_MODEM_AS_ID_1, ph_ptr), CM_MODE_PREF_CDMA_ONLY)) &&
       cmd_info_ptr->network_type != CM_MODE_PREF_NONE &&
       cmd_info_ptr->cmd_subs == ph_ptr->main_stack_info.asubs_id &&
         (cmd_info_ptr->network_list_type == CM_NETWORK_LIST_AVAILABLE ||
          cmd_info_ptr->network_list_type == CM_NETWORK_LIST_USER_PREFERRED ||
          cmd_info_ptr->network_list_type == CM_NETWORK_LIST_USER_PREFERRED_UNPACKED))
  {

    /* Taking care to reject network_search when SUB 1 has only CDMA subscription and no C in mode_pref
    Here main stack will be in power save. Here if we allow network_search then NAS will send it on last_active_rat, which will cause AS_ID mismatch
    For details see CR 695009 */

    cmd_err = CM_PH_CMD_ERR_GET_NETWORKS_S;
    return cmd_err;
  }

  return cmd_err;

} /* cmph_cmd_get_networks_para_check */
/*lint +esym(818, ph_ptr) */


/*===========================================================================

FUNCTION  cmph_cmd_terminate_get_networks_para_check

DESCRIPTION
  This function validates the terminate get networks command parameters.

DEPENDENCIES
  none

RETURN VALUE
  CM_PH_CMD_ERR_NOERR if no parameter related errors,
  otherwise specific cm_ph_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ph_cmd_err_e_type     cmph_cmd_terminate_get_networks_para_check(

    cm_ph_cmd_s_type               *ph_cmd_ptr

)
{
  cm_ph_cmd_err_e_type        cmd_err      = CM_PH_CMD_ERR_NOERR;

  cmph_s_type                 *ph_ptr = cmph_ptr();
  cm_ph_cmd_info_s_type       *cmd_info_ptr = NULL;
  sys_modem_as_id_e_type       asubs_id = SYS_MODEM_AS_ID_1;

  cmd_info_ptr = CMD_INFO_PTR( ph_cmd_ptr );
  if (cmph_is_msim())
  {
    asubs_id = cmd_info_ptr->cmd_subs;
  }

  #ifdef FEATURE_MMODE_DUAL_ACTIVE

  if(cmph_is_dsda()
    && ph_cmd_ptr->info.cmd_subs == SYS_MODEM_AS_ID_2)
  {
    /*
    ** The request to terminate a get network list is only valid if
    ** there is a pending request for the list of available networks.
    **/
    #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
    if (cmph_is_sxlte() &&
      !is_contain_3GPP_mode_pref(ph_ptr->hybr_3_stack_info.pref_info.network_type))
    {
      cmd_err = CM_PH_CMD_ERR_GET_NETWORKS_S;
    }
    else
    #endif
    if (!cmph_is_sxlte() &&
        !is_contain_3GPP_mode_pref(ph_ptr->hybr_2_stack_info.pref_info.network_type))
    {
      cmd_err = CM_PH_CMD_ERR_GET_NETWORKS_S;
    }
  }
  else
  #endif
  if (
      !is_contain_3GPP_mode_pref(ph_ptr->main_stack_info.pref_info.network_type)
     )
  {
    /*
    ** The request to terminate a get network list is only valid if
    ** there is a pending request for the list of available networks.
    **/
    cmd_err = CM_PH_CMD_ERR_GET_NETWORKS_S;

  }

  if ( !cmph_in_valid_oprt_mode( ph_ptr ) )
  {
    cmd_err = CM_PH_CMD_ERR_OPRT_MODE_S;
  }

  if(cmph_map_cm_ss_to_as_id(ph_ptr->ss_for_get_networks) != cmd_info_ptr->cmd_subs)
  {
    CM_MSG_HIGH_1("No get networks on going on the subs %d", cmd_info_ptr->cmd_subs);
    cmd_err = CM_PH_CMD_ERR_GET_NETWORKS_S;
  }

  return cmd_err;
} /* cmph_cmd_terminate_get_networks_para_check */



/*===========================================================================

FUNCTION cmph_set_net_lists_present_flag

DESCRIPTION
  Set is_net_lists_present flag.

DEPENDENCIES
  none

RETURN VALUE
  None

SIDE EFFECTS
  Modifies is_net_lists_present flag.

===========================================================================*/
void cmph_set_net_lists_present_flag
(
  boolean flag
)
{
  cmph_s_type                *ph_ptr = cmph_ptr();
      /* Pointer to a phone object */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT(ph_ptr != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ph_ptr->is_net_lists_present = flag;

  return;
}

/*===========================================================================

FUNCTION cmph_cm_map_band_pref_to_sd_band_pref

DESCRIPTION
  Map CM band-preference type to SD band-preference type.

DEPENDENCIES
  none

RETURN VALUE
  The SD band-preference that corresponds to the input CM band-preference.

SIDE EFFECTS
  none

===========================================================================*/
sd_ss_band_pref_e_type   cmph_map_cm_band_pref_to_sd_band_pref(

    cm_band_pref_e_type    band_pref
        /* Band pref to map */
)
{
  /*
  ** Map CM band-preference type to SD band-preference type.
  ** Note that unsupported CM band-preferences are mapped
  ** to SD_SS_BAND_PREF_ANY.
  */

  if(band_pref == CM_BAND_PREF_ANY)
  {
    return SD_SS_BAND_PREF_ANY;
  }
  else
  {
    return ((sd_ss_band_pref_e_type)band_pref);
  } /* switch */

} /* cmph_map_cm_band_pref_to_sd_band_pref() */


/*===========================================================================

FUNCTION cmph_map_cm_tds_band_pref_to_sd_tds_band_pref

DESCRIPTION
  Map CM TD-SCDMA band-preference type to SD TD-SCDMA band-preference type.

DEPENDENCIES
  none

RETURN VALUE
  The SD TD-SCDMA band-preference that corresponds to the input
  CM TD-SCDMA band-preference.

SIDE EFFECTS
  none

===========================================================================*/
sd_ss_band_pref_e_type   cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(

    cm_band_pref_e_type    tds_band_pref
        /* TD-SCDMA Band pref to map */
)
{
  /*
  ** Map CM TD-SCDMA band-preference type to SD TD-SCDMA band-preference type.
  */

  if(tds_band_pref == CM_BAND_PREF_TDS_ANY)
  {
    return SD_SS_BAND_PREF_TDS_ANY;
  }
  else
  {
    return ((sd_ss_band_pref_e_type)tds_band_pref);
  }

} /* cmph_map_cm_tds_band_pref_to_sd_tds_band_pref() */



/*===========================================================================

FUNCTION cmph_map_sd_band_pref_to_cm_band_pref

DESCRIPTION
  Map SD band-preference type to CM band-preference type.

DEPENDENCIES
  none

RETURN VALUE
  The CM band-preference that corresponds to the input SD band-preference.

SIDE EFFECTS
  none

===========================================================================*/
cm_band_pref_e_type  cmph_map_sd_band_pref_to_cm_band_pref(

    sd_ss_band_pref_e_type    band_pref
        /* Band pref to map */
)
{
  /*
  ** Map CM band-preference type to SD band-preference type.
  ** Note that unsupported CM band-preferences are mapped
  ** to SD_SS_BAND_PREF_ANY.
  */

  if(band_pref == SD_SS_BAND_PREF_ANY)
  {
    return CM_BAND_PREF_ANY;
  }
  else
  {
    return ((cm_band_pref_e_type)band_pref);
  } /* switch */

} /* cmph_map_sd_band_pref_to_cm_band_pref() */


/*===========================================================================

FUNCTION cmph_map_sd_tds_band_pref_to_cm_tds_band_pref

DESCRIPTION
  Map SD LTE band-preference type to CM LTE band-preference type.

DEPENDENCIES
  none

RETURN VALUE
  The CM LTE band-preference that corresponds to the input SD LTE band-preference.

SIDE EFFECTS
  none

===========================================================================*/
cm_band_pref_e_type  cmph_map_sd_tds_band_pref_to_cm_tds_band_pref(

    sd_ss_band_pref_e_type    tds_band_pref
        /* LTE Band pref to map */
)
{
  /*
  ** Map SD LTE band-preference type to CM LTE band-preference type.
  */

  if(tds_band_pref == SD_SS_BAND_PREF_TDS_ANY)
  {
    return CM_BAND_PREF_TDS_ANY;
  }
  else
  {
    return ((cm_band_pref_e_type)tds_band_pref);
  } /* switch */

} /* cmph_map_sd_lte_band_pref_to_cm_lte_band_pref() */

/*===========================================================================

FUNCTION cmph_map_cm_network_list_type_to_sd_network_list_type

DESCRIPTION
  Map CM Network List type to SD Network List type.

DEPENDENCIES
  none

RETURN VALUE
  The SD network list type that corresponds to the input CM
  network list type.

SIDE EFFECTS
  none

===========================================================================*/
sd_network_list_type_e_type  cmph_map_cm_network_list_type_to_sd_network_list_type(

    cm_network_list_type_e_type    list_type
        /* Network list type to map */
)
{
  sd_network_list_type_e_type sd_list_type = SD_NETWORK_LIST_NONE;

  /*
  ** Map CM network list type to SD network list type.
  */
  switch(list_type)
  {
  case CM_NETWORK_LIST_NONE:
    sd_list_type = SD_NETWORK_LIST_NONE;
    break;
  case CM_NETWORK_LIST_AVAILABLE:
  case CM_NETWORK_LIST_WITH_MAX_CAP:
    sd_list_type = SD_NETWORK_LIST_AVAILABLE;
    break;
  case CM_NETWORK_LIST_CSG:
    sd_list_type = SD_NETWORK_LIST_CSG;
    break;
  case CM_NETWORK_LIST_CSG_SELECTION_APP:
    sd_list_type = SD_NETWORK_LIST_CSG_SELECTION_APP;
    break;
  case CM_NETWORK_LIST_CSG_USER:
    sd_list_type = SD_NETWORK_LIST_CSG_USER;
    break;
  case CM_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND:
      sd_list_type = SD_NETWORK_LIST_PRIORITY_PLMN_SEARCH_BGND;
      break;
  case CM_NETWORK_LIST_PCI_SCAN:
      sd_list_type = SD_NETWORK_LIST_PCI_SCAN;
      break;
  default:
    sd_list_type = SD_NETWORK_LIST_MAX;
    break;
  }

  return sd_list_type;


} /* cmph_map_cm_network_list_type_to_sd_network_list_type() */


#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
/*===========================================================================

FUNCTION cm_otasp_update_mode

DESCRIPTION
  Check the mode in NV and update the mode

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

  CM will not write this value to NV.  It is expected that this value
  has been written to NV already.

RETURN VALUE
  none

SIDE EFFECTS
  Phone mode may be changed to reflect the NV item

===========================================================================*/
void cm_otasp_update_mode(

   cm_nam_e_type        nam,
   /* nam for which this mode is set for */

   nv_mode_enum_type    nv_mode
   /* mode to set to */
)
{
  cm_mode_pref_e_type    mode_pref;
  cmph_s_type           *ph_ptr = cmph_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the nam given matches the current nam then update the mode
  ** otherwise don't need to do anything right now.  We'll pick up
  ** the mode later if we switch nams. But go ahead and print out an error.
  */
  if(nam == ph_ptr->curr_nam)
  {
    mode_pref = cmph_map_mode_pref_nv2cm(nv_mode);
    if( mode_pref != ph_ptr->main_stack_info.pref_info.mode_pref )
    {
      /* Change the mode and inform MC.
      */
      {
        (void) cmph_force_pref_on_the_fly(
                      CM_SS_MAX,
                      ph_ptr,
                      SD_SS_PREF_REAS_ORIG_END,
                      CM_ACT_TYPE_NONE,
                      CM_PREF_TERM_PERMANENT,
                      mode_pref,
                      CMPH_PRST_BAND_PREF(ph_ptr),
                      CMPH_PRST_LTE_BAND_PREF(ph_ptr),
                      CMPH_PRST_TDS_BAND_PREF(ph_ptr),
                      CMPH_PRST_PRL_PREF(ph_ptr),
                      CMPH_PRST_ROAM_PREF(ph_ptr),
                      CMPH_PRST_HYBR_PREF(ph_ptr),
                      ph_ptr->main_stack_info.pref_info.plmn,
                      CMPH_PRST_SRV_DOMAIN_PREF(ph_ptr),
                      CM_OTASP_ACT_CODE_NONE,
                      ph_ptr->main_stack_info.pref_info.acq_order_pref,
                      CM_NETWORK_SEL_MODE_PREF_NONE,
                      (cm_act_id_type)ph_ptr,
                      CM_ACT_UPDATE_REAS_ACT_END,
                      FALSE,
                      cmph_get_acq_pri_order_per_sub(CM_SS_MAX),
                      CM_DEFAULT_VALUE,
                      ph_ptr->main_stack_info.pref_info.csg_id,
                      ph_ptr->main_stack_info.pref_info.csg_rat);
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Send event reports to all registered clients on change in mode.
      */
      cmph_event( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF );
    }
  }
  else
  {
    CM_ERR_2("Otasp Update Mode - NAM mismatch (%d and %d)", ph_ptr->curr_nam, nam);
  }
} /* cm_otasp_update_mode() */
#endif /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */

/*===========================================================================

FUNCTION cmph_kick_hybr_2_if_pending

DESCRIPTION
  Kick Hybrid 2 stack if a kick is pending with the initial intended values.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  None

===========================================================================*/
void cmph_kick_hybr_2_if_pending(

  boolean         force_top
    /* Flag to indicate if acquisition has to be forced
    */

)
{
  #ifdef FEATURE_MMODE_SC_SVLTE
  cmph_s_type             *ph_ptr          = cmph_ptr();
  cm_orig_q_s_type        *ph_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_2 );
  sd_ss_pref_reas_e_type   pref_reas;
  cm_pref_s_type          *hybr_2_pref_info_ptr  = NULL;
  cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;
  cmmsc_state_machine_s_type     *state_machine
        = cmmsimc_get_msc_ptr_per_cm_ss(CM_SS_HYBR_2);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* if in emerg mode, do not kick LTE stack with orig mode NONE or pref reas != EMERG
  */
  if(  ph_ptr->ph_state == CM_PH_STATE_EMERG_CB ||
       cmcall_emergency_call_active()
    )
  {
    CM_MSG_HIGH_0("hybr2 kick deferred - emerg");
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (cmmsc_auto_is_kick_hybr2_pending(state_machine) ||
      force_top)
  {

    /* Dynamically allocate memory for hybr2 pref info ptr
    */
    hybr_2_pref_info_ptr = cm_mem_malloc( sizeof(cm_pref_s_type ));

    /* decide the pref reas based on whether HYBR 2 has been kicked before or
    ** not
    */
    if(*cmph_get_is_kicked_hybr_2_ptr() == FALSE )
    {
      pref_reas = SD_SS_PREF_REAS_USER;
    }
    else
    {
      pref_reas = SD_SS_PREF_REAS_STACK_SYNC_UP;
    }

    if (ph_orig_top_ptr == NULL)
    {
      CM_ERR_0("Top element on priority queue of HYBR_2 Stack is NULL");
      return;
    }

    CM_MSG_HIGH_2( "Call is to cmmsc_proc_cmd_pref_sys_chgd ss=%d, pref_reas=%d",
                            SD_SS_HYBR_2, pref_reas);

    cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue (
       CM_SS_HYBR_2,
       pref_reas,
       SD_SS_ORIG_MODE_NONE,
       FALSE,
       ph_orig_top_ptr,
       CM_ACT_UPDATE_REAS_NONE,
       &cmd
       );

    cmmsimc_proc_cmd_pref_sys_chgd(&cmd);

    cmmsc_auto_update_is_kick_hybr2_pending(state_machine, FALSE);
    *cmph_get_is_kicked_hybr_2_ptr()               = TRUE;

    /* Free dynamically allocated memory
    */
    cm_mem_free(hybr_2_pref_info_ptr );
  }

  #else
  SYS_ARG_NOT_USED(force_top);
  #endif
}

/*===========================================================================

FUNCTION cmph_map_sys_mode_to_srv_type

DESCRIPTION
  Maps phone's sys_mode to service type.

DEPENDENCIES
  CM must be initialized

RETURN VALUE
  srv_type of teh call, else NONE

SIDE EFFECTS
  None

===========================================================================*/

cm_srv_type_e_type cmph_map_sys_mode_to_srv_type
(
         sys_sys_mode_e_type sys_mode
)
{
  cm_srv_type_e_type srv_type = CM_SRV_TYPE_NONE;

  CM_ASSERT (BETWEEN(sys_mode, SYS_SYS_MODE_NONE, SYS_SYS_MODE_MAX));

  switch (sys_mode)
  {
    case SYS_SYS_MODE_AMPS:
      srv_type = CM_SRV_TYPE_AMPS;
      break;

    case SYS_SYS_MODE_CDMA:
      srv_type = CM_SRV_TYPE_CDMA_AUTOMATIC;
      break;

    case SYS_SYS_MODE_GSM:
    case SYS_SYS_MODE_WCDMA:
    case SYS_SYS_MODE_GW:
      srv_type = CM_SRV_TYPE_GSM_WCDMA;
      break;

    case SYS_SYS_MODE_HDR:
      srv_type = CM_SRV_TYPE_CDMA_HDR;
      break;

    case SYS_SYS_MODE_LTE:
      srv_type = CM_SRV_TYPE_LTE;
      break;

    case SYS_SYS_MODE_TDS:
      srv_type = CM_SRV_TYPE_TDS;
      break;

    case SYS_SYS_MODE_GWL:
      srv_type = CM_SRV_TYPE_TDS_GSM_WCDMA_LTE;
      break;

    default:
      break;

  }

  return srv_type;
}

/*===========================================================================

FUNCTION cmph_pref_nochg_ptr

DESCRIPTION
  If user specify NO_CHANGE in command sys_sel_pref, corresponding bit will be set.
  When update NV values, check this flag.
  Only updat NV pref when corresponding bit is not set

DEPENDENCIES
  none

RETURN VALUE
  Return a pointer to pref NO_CHANGE flag.

SIDE EFFECTS
  none

===========================================================================*/
static uint32 *cmph_pref_nochg_ptr( void )
{

  static uint32 pref_no_change_local;

  return &pref_no_change_local;

}

/*===========================================================================

FUNCTION cmph_set_pref_nochg_flag

DESCRIPTION
  If user specify NO_CHANGE for system selection preference, set corresponding bit.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmph_set_pref_nochg_flag
(
    cmph_pref_nochg_e_type pref
)
{
  uint32 *ph_pref_ptr = cmph_pref_nochg_ptr();

  CM_ASSERT(BETWEEN(pref, CMPH_PREF_NOCHG_MIN, CMPH_PREF_NOCHG_MAX));

  /*lint -e{701} Shift left of signed quantity*/
  *ph_pref_ptr |= BM(pref);
}
/*===========================================================================

FUNCTION cmph_is_pref_nochg_set

DESCRIPTION
  check whether SS preference bit in NO_CHANGE flag is set

DEPENDENCIES
  none

RETURN VALUE
  boolean
  If preference bit is set return TRUE. Otherwise return FALSE

SIDE EFFECTS
  none

===========================================================================*/

static boolean cmph_is_pref_nochg_set
(
    cmph_pref_nochg_e_type pref
)
{
  uint32 *ph_pref_ptr = cmph_pref_nochg_ptr();

  CM_ASSERT(BETWEEN(pref, CMPH_PREF_NOCHG_MIN, CMPH_PREF_NOCHG_MAX));

  /*lint -e{701} Shift left of signed quantity */
  if(*ph_pref_ptr & BM(pref))
  {
    return TRUE;
  }

  return FALSE;
}
/*===========================================================================

FUNCTION cmph_clr_all_pref_nochg_flag

DESCRIPTION
  Clear preference no change flag to 0

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmph_clr_all_pref_nochg_flag(void)
{
  uint32 *ph_pref_ptr = cmph_pref_nochg_ptr();

  *ph_pref_ptr = 0;
}

/*===========================================================================

FUNCTION cm_data_oprt_mode_reg_ext

DESCRIPTION
  registration function for DS to register callback. When PWROFF/LPM received, CM will call DS callback
  To notify DS

DEPENDENCIES
  none

RETURN VALUE
  results of the registration

SIDE EFFECTS
  none

===========================================================================*/

boolean cm_data_subsc_cmd_reg_ext(

cm_ds_cmd_notif_ext_f_type * ds_ntfy_cb_func_ext
    /*  pointer to DS callback function */
)
{
  if(ds_ntfy_cb_func_ext == NULL)
  {
    return FALSE;
  }

  cm_ds_subsc_cmd_notif_cb_ext_func_ptr = ds_ntfy_cb_func_ext;
  CM_MSG_HIGH_0("DS subsc ext cb func registered");

  return TRUE;
}

/*===========================================================================

FUNCTION cm_get_hdr_intl_srv_status

DESCRIPTION
  Returns the internal servcie status of HDR mode

DEPENDENCIES
  none

RETURN VALUE
  results of the registration

SIDE EFFECTS
  none

===========================================================================*/
sys_srv_status_e_type cm_get_hdr_intl_srv_status (void)
{
  cmph_s_type           *ph_ptr        = cmph_ptr();
  sys_srv_status_e_type hdr_srv_status = SYS_SRV_STATUS_NO_SRV;
    
  if ((cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref) & SD_SS_MODE_PREF_HDR) 
       == SD_SS_MODE_PREF_NONE)
  {
    return SYS_SRV_STATUS_NO_SRV;
  }
    
  if (cmss_is_hybr_status_on())
  {
    if ((cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->mode == SYS_SYS_MODE_HDR) ||
         (cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->mode == SYS_SYS_MODE_NO_SRV))
    {
      hdr_srv_status = cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status;
    }
  }
  else
  {
    if ((cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode == SYS_SYS_MODE_HDR) ||
         (cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode == SYS_SYS_MODE_NO_SRV))
    {
      hdr_srv_status = cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status;
    }
  }

  return hdr_srv_status;
}



/*===========================================================================

FUNCTION cm_data_oprt_mode_reg

DESCRIPTION
  registration function for DS to register callback. When PWROFF/LPM received, CM will call DS callback
  To notify DS

DEPENDENCIES
  none

RETURN VALUE
  results of the registration

SIDE EFFECTS
  none

===========================================================================*/

boolean cm_data_oprt_mode_reg(

cm_ds_sys_pwroff_lpm_notif_f_type * ds_ntfy_cb_func
    /*  pointer to DS callback function */
)
{
  if(ds_ntfy_cb_func == NULL)
  {
    return FALSE;
  }

  cm_ds_sys_pwroff_lpm_notif_cb_func_ptr = ds_ntfy_cb_func;

  return TRUE;
}

/*===========================================================================

FUNCTION cm_data_packet_state_notify

DESCRIPTION
  call back function for DS to notify CM data traffic status

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cm_data_packet_state_notify(

   uint8          inactive_subs_id_bitmask
)
{

  cm_generic_rpt_s_type *cm_generic_rpt_ptr =
                                     cm_generic_rpt_get_buf_else_err_fatal();


  /* Queue the data traffic status report to CM
  */

  cm_generic_rpt_ptr->hdr.cmd = CM_DATA_PACKET_STATE_RPT;
  cm_generic_rpt_ptr->generic_rpt.pkt_data.subs_id_mask
                                                   = inactive_subs_id_bitmask;

  cm_generic_rpt(cm_generic_rpt_ptr);

  return;
}

#ifdef FEATURE_CM_LTE
/*===========================================================================

FUNCTION cmph_update_lte_ue_mode_of_operation

DESCRIPTION
  Clear preference no change flag to 0

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cmph_update_lte_ue_mode_of_operation(
  sys_modem_as_id_e_type   sub_id
)
{

  cmph_s_type                   *ph_ptr        = cmph_ptr();
      /* Point at phone object */

  cmph_sub_config_s_type     *cmph_sub_info = cmph_get_sub_config_ptr(sub_id);

  cmsds_sub_config_s_type    *cmsds_config = cmsds_get_config_ptr(sub_id);

  switch ( CMPH_SS_SRV_DOMAIN_PREF(sub_id, ph_ptr) )
  {
    case CM_SRV_DOMAIN_PREF_NONE:
    {
      cmph_sub_info->lte_ue_mode_pref = CM_LTE_UE_MODE_PREF_NONE;
    }
    break;

    case CM_SRV_DOMAIN_PREF_CS_ONLY:
    {
      cmph_sub_info->lte_ue_mode_pref = CM_LTE_UE_MODE_PREF_NONE;
    }
    break;

    case CM_SRV_DOMAIN_PREF_PS_ONLY:
    {
      if(cmsds_config->ue_usage_setting == SYS_UE_USAGE_SETTING_VOICE_CENTRIC)
      {
        cmph_sub_info->lte_ue_mode_pref = CM_LTE_UE_MODE_PREF_PS_MODE1;
      }
      else if (cmsds_config->ue_usage_setting == SYS_UE_USAGE_SETTING_DATA_CENTRIC)
      {
        cmph_sub_info->lte_ue_mode_pref = CM_LTE_UE_MODE_PREF_PS_MODE2;
      }
    }
    break;
    case CM_SRV_DOMAIN_PREF_CS_PS:
    {
      if(cmsds_config->ue_usage_setting == SYS_UE_USAGE_SETTING_VOICE_CENTRIC)
      {
        cmph_sub_info->lte_ue_mode_pref = CM_LTE_UE_MODE_PREF_CS_PS_MODE1;
      }
      else if(cmsds_config->ue_usage_setting == SYS_UE_USAGE_SETTING_DATA_CENTRIC)
      {
        cmph_sub_info->lte_ue_mode_pref = CM_LTE_UE_MODE_PREF_CS_PS_MODE2;
      }
    }
    break;

    default:
      CM_ERR_1( "Invalid service domain %d", ph_ptr->main_stack_info.pref_info.srv_domain_pref);
      cmph_sub_info->lte_ue_mode_pref = CM_LTE_UE_MODE_PREF_NONE;
      break;
   } /* switch ( service_domain_pref ) */

   CM_MSG_HIGH_2("Updated lte_ue_mode_pref to %d for sub %d",
                 cmph_sub_info->lte_ue_mode_pref, sub_id);

}

#endif
/*===========================================================================

FUNCTION cmph_is_subsc_cmd_on_hold

  Check if hold command queue has subscription command. subscriptoin command will be put to hold
  command queue if there is emergency call ongoing. Since subsc command need to be processed
  sequentially so if hold queue has subsc command the following received subsc command need to be
  put to hold queue as well.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static boolean cmph_is_subsc_cmd_on_hold(void)
{
  cm_ph_cmd_e_type    subsc_avail = CM_PH_CMD_SUBSCRIPTION_AVAILABLE;
  cm_ph_cmd_e_type    subsc_unavail = CM_PH_CMD_SUBSCRIPTION_NOT_AVAILABLE;
  cm_ph_cmd_e_type    subsc_chgd = CM_PH_CMD_SUBSCRIPTION_CHANGED;

  if(cm_hold_cmd_q_exists_cmd(CM_CMD_TYPE_PH, &subsc_avail) ||
    cm_hold_cmd_q_exists_cmd(CM_CMD_TYPE_PH, &subsc_unavail) ||
    cm_hold_cmd_q_exists_cmd(CM_CMD_TYPE_PH, &subsc_chgd))
  {
    return TRUE;
  }
  return FALSE;
}

#ifdef FEATURE_RAT_PRIORITY_LIST
/*===========================================================================

FUNCTION cmph_write_rat_acq_order

DESCRIPTION
  This function writes rat_acq_order into EFS

DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
/*lint -esym(528, cmph_write_rat_acq_order) not referenced */
static boolean cmph_write_rat_acq_order(
  const cm_acq_pri_order_pref_s_type *rat_acq_order_ptr,
  sys_modem_as_id_e_type          sub_id
)
{
  boolean                       is_ver_valid = FALSE;
  sd_rat_acq_order_s_type       efs_rat_acq_order;
  int32                         size_of_efs_info = sizeof(sd_rat_acq_order_s_type);
  uint8                         i=0;
  byte                          efs_tot[PRL_TOT_TBL_MAX_SIZE];

  memset(&efs_rat_acq_order,0,sizeof(sd_rat_acq_order_s_type));

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Read RAT Acuisition order from NV-EFS for Version information
  */
  if(cmefs_get(CMEFS_RAT_ACQ_ORDER,
                   (byte *)efs_tot,
                   size_of_efs_info,
                   sub_id))
  {
    if(prl_decode_tot_tbl( efs_tot, &efs_rat_acq_order ))
    {
      is_ver_valid = TRUE;
      CM_MSG_HIGH_2("sub %d rat_acq_order (TOT) version %d",
                      sub_id, efs_rat_acq_order.version);
    }
  }

  if(!is_ver_valid)
  {
    /* Fill up default version */
    CM_MSG_HIGH_1("sub %d rat_acq_order (TOT) writing dflt version: 888", sub_id);
    efs_rat_acq_order.version = PRL_TOT_DEFAULT_VERSION;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Fill up num_rat and acq_sys_mode */
  CM_MSG_HIGH_2("sub %d rat_acq_order (TOT) num_rat %d", sub_id, efs_rat_acq_order.num_rat);
  efs_rat_acq_order.num_rat = rat_acq_order_ptr->num_rat;
  for(i=0; i<efs_rat_acq_order.num_rat; i++)
  {
    efs_rat_acq_order.acq_sys_mode[i] = rat_acq_order_ptr->acq_order[i];
    CM_MSG_HIGH_3("sub %d rat_acq_order (TOT) acq_sys_mode[%d] = %d",
                  sub_id, i,efs_rat_acq_order.acq_sys_mode[i]);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Encode tot table and writing it to EFS
  */
  if(prl_encode_tot_tbl(&efs_rat_acq_order,efs_tot))
  {
    if(cmefs_fs_write(CMEFS_RAT_ACQ_ORDER,
                (byte *)efs_tot,
                sizeof(sd_rat_acq_order_s_type),
                sub_id))
    {
      CM_MSG_HIGH_1("sub %d rat_acq_order (TOT) writing succesful", sub_id);
      return TRUE;
    }
  }

  return FALSE;

}
#endif



#ifdef CM_GW_SUPPORTED

/*===========================================================================

FUNCTION cmph_is_3GPP_ef_rat_mode_pref_change_allowed

DESCRIPTION
 check for mode change is allowed when RAT balacing feature
  is enabled

DEPENDENCIES


RETURN VALUE
  TRUE/FALSE

SIDE EFFECTS
  none

===========================================================================*/


static boolean cmph_is_3GPP_ef_rat_mode_pref_change_allowed
(
  sd_ss_mode_pref_e_type new_mode_pref , sd_ss_mode_pref_e_type ef_rat_mode_pref
)
{
  if(SD_MODE_CONTAIN (new_mode_pref,SD_SS_MODE_PREF_GSM))
  {
    if(!(SD_MODE_CONTAIN (ef_rat_mode_pref,SD_SS_MODE_PREF_GSM)))
    {
      CM_MSG_HIGH_2("GSM not part of EF-RAT new_mode_pref =%d to ef_rat_mode_pref = %d",
                        new_mode_pref, ef_rat_mode_pref);
      /* change to mode which is not in EF-RAT*/
      return FALSE;
    }
  }

  if(SD_MODE_CONTAIN (new_mode_pref,SD_SS_MODE_PREF_WCDMA))
  {
    if(!(SD_MODE_CONTAIN (ef_rat_mode_pref,SD_SS_MODE_PREF_WCDMA)))
    {
      CM_MSG_HIGH_2("WCDMA not part of EF-RAT new_mode_pref =%d to ef_rat_mode_pref = %d",
                        new_mode_pref, ef_rat_mode_pref);
      /* change to mode which is not in EF-RAT*/
      return FALSE;
    }
  }
  #ifdef FEATURE_CM_LTE
  if(SD_MODE_CONTAIN (new_mode_pref,SD_SS_MODE_PREF_LTE))
  {
    if(!(SD_MODE_CONTAIN (ef_rat_mode_pref,SD_SS_MODE_PREF_LTE)))
    {
      CM_MSG_HIGH_2("LTE not part of EF-RAT new_mode_pref =%d to ef_rat_mode_pref = %d",
                        new_mode_pref, ef_rat_mode_pref);
      /* change to mode which is not in EF-RAT*/
      return FALSE;
    }
  }
  #endif
  /* new mode is subset of  EF-RAT*/
  return TRUE;

} /* cmph_is_3GPP_ef_rat_mode_pref_change_allowed*/

#endif /* CM_GW_SUPPORTED */

/*===========================================================================

FUNCTION cmph_resume_hybrid_opr_without_activating_prot
  Subscription change or going Online would have initiated resume to
  MMOC. This function will initiate state transistions withou doing
  protocol activate again.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmph_resume_hybrid_opr_without_activating_prot( void )
{
  #ifdef FEATURE_MMODE_SC_SVLTE
  cmph_s_type *ph_ptr = cmph_ptr();

  /* If LTE /HDR stack is in suspend state sent unsuspend request to MMOC
  ** This clears state in MMOC and will not resume stack as ONLINE/Subcription
  ** change has already initiated it.
  */

  /* If HYBR2 is suspended or request is pending with
        MMOC send suspend FALSE */
  if( ph_ptr->is_svlte_supported &&
    ( ph_ptr->ss_susp_info[CM_SS_HYBR_2].is_suspend == TRUE ||
      ph_ptr->ss_susp_info[CM_SS_HYBR_2].num_requests != 0 ))
  {
    mmoc_cmd_suspend_ss(SD_SS_HYBR_2,  FALSE, TRUE);
  }
  /* If HYBR1 is suspended or request is pending with MMOC
        send suspend FALSE */
  if( ph_ptr->is_svdo_supported &&
    ( ph_ptr->ss_susp_info[CM_SS_HYBR_1].is_suspend == TRUE ||
      ph_ptr->ss_susp_info[CM_SS_HYBR_1].num_requests != 0 ))
  {
      mmoc_cmd_suspend_ss(SD_SS_HYBR_1, FALSE, TRUE);
  }

  /* When we are in middle of get network and there is subscription change
     Resume MAIN stack if suspended in SVLTE */
  if( ph_ptr->is_svlte_supported &&
      ph_ptr->main_stack_info.pref_info.network_type != CM_MODE_PREF_NONE &&
      ph_ptr->ss_susp_info[CM_SS_MAIN].is_suspend == TRUE )
  {
    mmoc_cmd_suspend_ss(SD_SS_MAIN,  FALSE, TRUE);
  }

  #endif
  return;
}

/*===========================================================================

FUNCTION  cmph_is_msim_svlte_sub

DESCRIPTION
 Check if the specified sub is svlte sub for a msim device.

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  boolean

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_msim_svlte_sub (sys_modem_as_id_e_type asubs_id)
{
  if(cmph_is_subs_feature_mode_1x_sxlte(asubs_id)
     &&
     cmph_is_msim()
  )
    return TRUE;
  else
    return FALSE;
}

/*===========================================================================

FUNCTION  cmph_is_msim

DESCRIPTION
 Check if the device mode is type of multiple sim verse single sim.

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  TRUE if device mode is type of multiple sim verse single sim.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_msim (void)
{
  return (cmph_is_dsda() || cmph_is_dsds() || cmph_is_tsts());
}

/*===========================================================================

FUNCTION  cmph_is_svlte_any

DESCRIPTION
 Check if sub feature mode is svlte

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  TRUE if sub feature mode is SVLTE
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_svlte_any (void)
{
  size_t sim_idx = 0;
  for (sim_idx = 0; sim_idx < cmpmprx_get_num_of_sims(); sim_idx++)
  {
    if (cmph_is_subs_feature_mode_1x_sxlte((sys_modem_as_id_e_type)sim_idx))
    {
      return TRUE;
    }
  }
  return FALSE;
}

/*===========================================================================

FUNCTION  cmph_is_sxlte_any

DESCRIPTION
 Check if the feature mode says that device is SVLTE or SGLTE capable

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  TRUE if feature mode is SVLTE or SGLTE
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_sxlte_any (void)
{
  if(cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) ||
     cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) ||
     cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_2)
  )
     return TRUE;
  else
  return FALSE;
}

/*===========================================================================

FUNCTION  cmph_is_sxlte

DESCRIPTION
 Check if the feature mode says that device is SVLTE or SGLTE capable

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  TRUE if feature mode is SVLTE or SGLTE
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_sxlte (void)
{
  if((cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) ||
     cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) ||
     cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_2) ||
     cmph_is_sub2_map_to_hybr3())
     &&
     cmph_is_msim()
  )
     return TRUE;
  else
  return FALSE;
}

/*===========================================================================

FUNCTION  cmph_is_ssim

DESCRIPTION
 Check if the device mode is type of single_sim.

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  TRUE if device mode is type of single_sim.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_ssim (void)
{
  return (cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_SINGLE_SIM);
}

/*===========================================================================

FUNCTION  cmph_is_dsds

DESCRIPTION
 Check if the device mode is type of dual_sim_dual_standby.

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  TRUE if device mode is type of dual_sim_dual_standby.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_dsds (void)
{
  return (cmpmprx_get_device_mode()
    == SYS_MODEM_DEVICE_MODE_DUAL_SIM_DUAL_STANDBY &&
    cmph_ptr()->feature_mode == SYS_OVERALL_FEATURE_MODE_MULTISIM);
}

/*===========================================================================

FUNCTION  cmph_is_dsda

DESCRIPTION
 Check if the device mode is type of dual_sim_dual_active.

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  TRUE if device mode is type of dual_sim_dual_active.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_dsda (void)
{
  return (cmpmprx_get_device_mode()
    == SYS_MODEM_DEVICE_MODE_DUAL_SIM_DUAL_ACTIVE &&
    cmph_ptr()->feature_mode == SYS_OVERALL_FEATURE_MODE_MULTISIM);
}

/*===========================================================================

FUNCTION  cmph_is_tsts

DESCRIPTION
 Check if the device mode is type of dual_sim_dual_standby.

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  TRUE if device mode is type of dual_sim_dual_standby.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_tsts (void)
{
  return (cmpmprx_get_device_mode()
    == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY &&
    cmph_ptr()->feature_mode == SYS_OVERALL_FEATURE_MODE_MULTISIM);
}

/*===========================================================================

FUNCTION  cmph_init_single_sim_mode

DESCRIPTION
 Initialize the single sim mode.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_init_single_sim_mode (void)
{
  cmph_s_type                    *ph_ptr = cmph_ptr();

  /* Read the Dual-standby preferences from NV
  */
  cmnv_read_wait( NV_DUAL_STANDBY_CFG_ITEMS_I, cmnv_item_ptr );
  ph_ptr->user_standby_pref  = (sys_modem_dual_standby_pref_e_type)cmnv_item_ptr->dual_standby_cfg_items.dual_standby_pref;


  /* If DS pref from NV is NO_STANDBY, power up with sub DISABLED
  */
  if(ph_ptr->user_standby_pref == SYS_MODEM_DS_PREF_NO_STANDBY_PREF)
  {
    ph_ptr->standby_pref = SYS_MODEM_DS_PREF_NO_STANDBY_PREF;
    ph_ptr->internal_standby_pref = SYS_MODEM_DS_PREF_NO_STANDBY_PREF;
    ph_ptr->active_subs = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;
    ph_ptr->is_bootup_no_standby = TRUE;
  }
  else
  {
    /* Internally CM treats single sim opr mode same as single standby on sub1 in dual sim
     ** opr mode
     */
    ph_ptr->user_standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
    ph_ptr->standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
    ph_ptr->internal_standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
    ph_ptr->active_subs = SYS_MODEM_AS_ID_1_MASK;
    ph_ptr->is_bootup_no_standby = FALSE;
  }
  
  ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;

  /* For single sim opr mode, the following params should be ignored
   */
  ph_ptr->priority_subs = SYS_MODEM_AS_ID_1;
  ph_ptr->curr_priority_subs = SYS_MODEM_AS_ID_1;
  ph_ptr->default_data_subs = SYS_MODEM_AS_ID_1;
  ph_ptr->default_voice_subs = SYS_MODEM_AS_ID_1;
  ph_ptr->curr_voice_subs = SYS_MODEM_AS_ID_1;

  ph_ptr->mcfg_deactivate_subs = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;
  ph_ptr->num_standby_requests_processing = 0;
}

/*===========================================================================

@FUNCTION cmph_is_sub1_mm_in_single_standby

@DESCRIPTION
   Checks if primary subs is multimode and Active

@DEPENDENCIES
  None

@RETURN VALUE
  TRUE: if primary subs is multimode and Active.
  FALSE: Otherwise.

@SIDE EFFECTS
  None

===========================================================================*/

boolean   cmph_is_sub1_mm_in_single_standby( void )
{
  if(!cmph_is_msim())
  {
    return TRUE;
  }
  else 
  {
      return (cm_is_multimode_subs(SYS_MODEM_AS_ID_1) &&\
  	          (cmph_ptr()->active_subs == SYS_MODEM_AS_ID_1_MASK));
  }
}

/*===========================================================================

  This function gives configuration about if ESR needs to be done in MSIM
  scenarios.
===========================================================================*/
boolean cmph_is_msim_standby_esr_enabled( void )
{
  return cmph_ptr()->is_msim_esr_enabled;
}

/*===========================================================================

FUNCTION cmph_set_is_in_use_reported

DESCRIPTION
  This function sets the value of is_in_use_reported or hybr2_is_in_use_reported for phone
  ptr based on ss.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  none

===========================================================================*/
void cmph_set_is_in_use_reported(
  cm_ss_e_type   ss,
  boolean        val
)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  #ifndef FEATURE_MMODE_DUAL_ACTIVE
  SYS_ARG_NOT_USED(ss);
  #endif

  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if (cmph_is_dsda() && ss == CM_SS_HYBR_2 && !cmph_is_sxlte())
  {
    ph_ptr->hybr2_is_in_use_reported = val;
  }
  #if defined FEATURE_MMODE_SXLTE_G
  else if (cmph_is_dsda() && ss == CM_SS_HYBR_3 && cmph_is_sxlte())
  {
    ph_ptr->hybr3_is_in_use_reported = val;
  }
  #endif
  else
  #endif
  {
    ph_ptr->is_in_use_reported = val;
  }
}

/*===========================================================================

FUNCTION cmph_get_sub_with_lte_cap

DESCRIPTION
  Returns the sub which has LTE in max cap.  For now, only 1 sub could support LTE.

DEPENDENCIES
  None

RETURN VALUE
  sys_modem_as_id_e_type

SIDE EFFECTS
  none

===========================================================================*/
sys_modem_as_id_e_type cmph_get_sub_with_lte_cap(void)
{
  
  size_t as_id_val = SYS_MODEM_AS_ID_NONE; 
  boolean is_lte_present;

 
  if (!cmph_is_msim())
  {
    return SYS_MODEM_AS_ID_1;
  }
 
  for(as_id_val=0; as_id_val < cmpmprx_get_num_of_sims(); as_id_val++)
  {
    is_lte_present = (((cmmsc_get_curr_msc_max_cap(as_id_val)) & (1<< ((uint32)SYS_SYS_MODE_LTE))) != 0); 

    if(is_lte_present)
    {     
      return as_id_val;
    }
  } 
   /*It should not come here*/
  CM_MSG_HIGH_0("Invalid Config: LTE cap not present in any SUB");
  return SYS_MODEM_AS_ID_1; 
}

/*===========================================================================

FUNCTION cmph_is_lte_capable_on_ss

DESCRIPTION
  Check if the LTE is allowed on the specified ss per max allowed capability.

DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
boolean cmph_is_lte_capable_on_ss(
  cm_ss_e_type  ss
)
{
  if (cmph_get_sub_with_lte_cap() == cmph_map_cm_ss_to_subs(ss))
  {
    return TRUE;
  }
  return FALSE;
}

/*===========================================================================

FUNCTION cmph_is_lte_capable_on_sub

DESCRIPTION
  Check if the LTE is allowed on the specified sub per max allowed capability.

DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
boolean cmph_is_lte_capable_on_sub(
  sys_modem_as_id_e_type  asubs_id
)
{
  if (!cmph_is_msim())
  {
    return TRUE;
  }
  else if (cmph_get_sub_with_lte_cap() == asubs_id)
  {
    return TRUE;
  }
  return FALSE;
}

/*===========================================================================

FUNCTION cmph_is_as_id_valid

DESCRIPTION
  Check subs id is valid or not

DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/

boolean cmph_is_as_id_valid(

  sys_modem_as_id_e_type       as_id
)
{
  boolean status = FALSE;
  if ( as_id >= SYS_MODEM_AS_ID_1 && as_id < MAX_AS_IDS)
  {
    status = TRUE;
  }
  
  CM_MSG_HIGH_1 ("Is as_id valid %d", status);
  return status;
}


/*===========================================================================

FUNCTION cmph_map_cm_ss_to_subs

DESCRIPTION
  Maps CM SS to the active subscription id

DEPENDENCIES
  None

RETURN VALUE
  subscription id

SIDE EFFECTS
  None.

===========================================================================*/

sys_modem_as_id_e_type cmph_map_cm_ss_to_subs(

  cm_ss_e_type       ss
)
{

  cmph_s_type            *ph_ptr       = cmph_ptr();

  if (!cmph_is_feature_mode_msim())
  {
    return SYS_MODEM_AS_ID_1;
  }
  
  #if defined(FEATURE_MMODE_SXLTE_G)
  if (cmph_is_sxlte())
  {
    /* Only apply to multi-sim configuration */
    switch(ss)
    {
      case CM_SS_MAIN:
      case CM_SS_HYBR_1:
      case CM_SS_HYBR_2:
      case CM_SS_MAX:
          return (ph_ptr->main_stack_info.asubs_id);
      case CM_SS_HYBR_3:
          return (ph_ptr->hybr_3_stack_info.asubs_id);
      default:
        CM_ERR_1("Invalid sd_ss %d",ss);
        return SYS_MODEM_AS_ID_MAX;
    }

  }
  else
  #endif
  {
    /* Only apply to multi-sim configuration */
    switch(ss)
    {
      case CM_SS_MAIN:
      case CM_SS_HYBR_1:
      case CM_SS_MAX:
          return (ph_ptr->main_stack_info.asubs_id);

      case CM_SS_HYBR_2:
        return (ph_ptr->hybr_2_stack_info.asubs_id);

      #if defined(FEATURE_MMODE_TRIPLE_SIM)|| defined(FEATURE_MMODE_SXLTE_G)
      case CM_SS_HYBR_3:
        return (ph_ptr->hybr_3_stack_info.asubs_id);
      #endif

      default:
        CM_ERR_1("Invalid sd_ss %d",ss);
        return SYS_MODEM_AS_ID_MAX;
    }

  }

}

sys_modem_as_id_e_type cmph_map_cm_ss_to_as_id (
    cm_ss_e_type ss
)
{
  CM_ASSERT_ENUM_IS_INRANGE(ss, CM_SS_MAX);

  switch(ss)
  {
    case CM_SS_MAIN:
    case CM_SS_HYBR_1:
      return cmph_ptr()->main_stack_info.asubs_id;

    case CM_SS_HYBR_2:
      return cmph_ptr()->hybr_2_stack_info.asubs_id;

    #if defined(FEATURE_MMODE_TRIPLE_SIM)  || defined(FEATURE_MMODE_SXLTE_G)
    case CM_SS_HYBR_3:
      return cmph_ptr()->hybr_3_stack_info.asubs_id;
    #endif
    
    default:
      CM_ERR_1("cmph_map_cm_ss_to_as_id(), invalid ss %d",ss);
      return SYS_MODEM_AS_ID_MAX;
  }
}

cm_ss_e_type  cmph_map_as_id_to_cm_ss(
    sys_modem_as_id_e_type as_id
)
{
  CM_ASSERT_ENUM_IS_INRANGE(as_id, SYS_MODEM_AS_ID_MAX);

  if(as_id > SYS_MODEM_AS_ID_NONE && as_id < MAX_AS_IDS)
  {
    return cmph_ptr()->subs_stack_map[as_id][0];
  }

  return CM_SS_MAIN;

  /*

  switch(as_id)
  {
    case SYS_MODEM_AS_ID_1:
      return CM_SS_MAIN;

    case SYS_MODEM_AS_ID_2:
      return CM_SS_HYBR_2;

    case SYS_MODEM_AS_ID_3:
      return CM_SS_HYBR_3;


    default:
      CM_ERR_2("invalid as_id value %d, map to default ss %d", as_id, CM_SS_MAIN);
      return CM_SS_MAIN;
  }
  */

}

/*===========================================================================

FUNCTION  cmph_read_qmss_enabled

DESCRIPTION
 Read the device mode from nv efs.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_read_qmss_enabled (void)
{
  boolean def_value = FALSE;
  boolean qmss_enabled;
  int32 qmss_enabled_size = sizeof(boolean);
  cmph_s_type                  *ph_ptr = cmph_ptr();

  /* Read the EFS file */
  if ( cmefs_read ( CMEFS_QMSS_ENABLED,
                 (byte*)&qmss_enabled,
                 &qmss_enabled_size)
     )
  {
    qmss_enabled = (boolean) qmss_enabled;
    if ((qmss_enabled > TRUE) ||
          (qmss_enabled < FALSE)
       )
    {
      ph_ptr->qmss_enabled = def_value;
      CM_MSG_HIGH_2 ("QMSS: qmss_enabled invalid value %d, default to %d",
                    qmss_enabled, ph_ptr->qmss_enabled);
    }
    else
    {
      ph_ptr->qmss_enabled = qmss_enabled;
      CM_MSG_HIGH_1 ("QMSS: EFS read succ. qmss_enabled = %d",
                    ph_ptr->qmss_enabled);
    }
  }
  else
  {
    /* set default value to  dual sim opr mode */
    ph_ptr->qmss_enabled = def_value;

    CM_ERR_1 ("QMSS: fail to read /nv/item_files/modem/mmode/qmss_enabled, default to %d",
            ph_ptr->qmss_enabled);
  }
}

/*===========================================================================

FUNCTION  cmph_read_operator_name

DESCRIPTION
 Read the device mode from nv efs.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_read_operator_name (sys_modem_as_id_e_type asubs_id)
{
  cm_operator_e_type def_value = OPERATOR_NULL;

  /* The operator_name is 8 bits in efs per subs*/
    cm_operator_e_type opname;
  cmph_sub_config_s_type *ph_sub_config_ptr
    = cmph_get_sub_config_ptr(asubs_id);

  if(ph_sub_config_ptr == NULL)
  {
    CM_MSG_HIGH_1("cmph sub config pointer[%d] is NULL",asubs_id);
    return;
  }

    if( cmefs_get (CMEFS_OPERATOR_NAME,
                (byte*)&opname,
                  sizeof(opname),
                  asubs_id)
    )
  {
      /*Processing the buffer*/
      ph_sub_config_ptr->operator_name = opname;

      if (!(ph_sub_config_ptr->operator_name > OPERATOR_NULL &&
            ph_sub_config_ptr->operator_name < OPERATOR_MAX)
        )
      {
        ph_sub_config_ptr->operator_name = def_value;
        CM_MSG_HIGH_2 ("QMSS: operator_name invalid value %d, default to %d",
                      opname, ph_sub_config_ptr->operator_name);
      }
      else
      {
        CM_MSG_HIGH_1 ("QMSS: EFS read succ. operator_name = %d",
                      ph_sub_config_ptr->operator_name);
    }
  }
  else
  {
    /* set default value to  dual sim opr mode */
      ph_sub_config_ptr->operator_name = def_value;

      CM_ERR_1 ("QMSS: fail to read /nv/item_files/modem/mmode/operator_name, default to %d",
                ph_sub_config_ptr->operator_name);
    }
  }

/*===========================================================================

FUNCTION  cmph_set_sys_sel_pref_rsp_pending

DESCRIPTION
 Set the flag is_sys_sel_pref_rsp_pending to true.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_set_sys_sel_pref_rsp_pending (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Set req_id pending for hybr2 satck to true */
  if (!ph_ptr->is_sys_sel_pref_rsp_pending)
  {
    ph_ptr->is_sys_sel_pref_rsp_pending = TRUE;
  }
}

/*===========================================================================

FUNCTION  cmph_reset_sys_sel_pref_rsp_pending

DESCRIPTION
 Reset the flag is_sys_sel_pref_rsp_pending to false.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_reset_sys_sel_pref_rsp_pending (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Reset the flag */
  if (ph_ptr->is_sys_sel_pref_rsp_pending)
  {
    ph_ptr->is_sys_sel_pref_rsp_pending = FALSE;

    CM_MSG_HIGH_0("RESET is_sys_sel_pref_rsp_pending");
  }
}

/*===========================================================================

FUNCTION  cmph_set_req_id_pending

DESCRIPTION
 Set the flag is_req_id_pending to true.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_set_req_id_pending (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Set req_id pending for hybr2 satck to true */
  CM_MSG_HIGH_1("is_req_id_pending=%d", ph_ptr->is_req_id_pending);
  if (!ph_ptr->is_req_id_pending)
  {
    ph_ptr->is_req_id_pending = TRUE;
  }
}


/*===========================================================================

FUNCTION  cmph_reset_req_id_pending

DESCRIPTION
 Reset the flag is_req_id_pending to false.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_reset_req_id_pending (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Reset the flag */
  if (ph_ptr->is_req_id_pending)
  {
    ph_ptr->is_req_id_pending = FALSE;

    CM_MSG_HIGH_0("RESET is_req_id_pending");
  }
}

/*===========================================================================

FUNCTION  cmph_set_sys_sel_pref_rsp_pending2

DESCRIPTION
 Set the flag is_sys_sel_pref_rsp_pending2 to true.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_set_sys_sel_pref_rsp_pending2 (
    uint16 sys_sel_pref_req_id
)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Set req_id pending for hybr2 satck to true */
  CM_MSG_HIGH_2("SC_SGLTE: is_sys_sel_pref_rsp_pending2=%d, req_id=%d",ph_ptr->is_sys_sel_pref_rsp_pending2, sys_sel_pref_req_id);
  if (!ph_ptr->is_sys_sel_pref_rsp_pending2)
  {
    ph_ptr->is_sys_sel_pref_rsp_pending2 = TRUE;
  }

  /* Set is_req_id_pending2 to true if req_id is non default value */
  if (sys_sel_pref_req_id != CM_DEFAULT_VALUE)
  {
    cmph_set_req_id_pending2();
  }
}

/*===========================================================================

FUNCTION  cmph_reset_sys_sel_pref_rsp_pending2

DESCRIPTION
 Reset the flag is_sys_sel_pref_rsp_pending2 to true.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_reset_sys_sel_pref_rsp_pending2 (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Reset the flag */
  if (ph_ptr->is_sys_sel_pref_rsp_pending2)
  {
    ph_ptr->is_sys_sel_pref_rsp_pending2 = FALSE;

    CM_MSG_HIGH_0("SC_SGLTE: RESET is_sys_sel_pref_rsp_pending2");
  }
}

/*===========================================================================

FUNCTION  cmph_set_req_id_pending2

DESCRIPTION
 Set the flag is_req_id_pending2 to true.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_set_req_id_pending2 (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Set req_id pending for hybr2 satck to true */
  CM_MSG_HIGH_1("SC_SGLTE: is_req_id_pending2=%d", ph_ptr->is_req_id_pending2);

  if (!ph_ptr->is_req_id_pending2)
  {
    ph_ptr->is_req_id_pending2 = TRUE;
  }
}


/*===========================================================================

FUNCTION  cmph_reset_req_id_pending2

DESCRIPTION
 Reset the flag is_req_id_pending2 to false.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_reset_req_id_pending2 (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Reset the flag */
  if (ph_ptr->is_req_id_pending2)
  {
    ph_ptr->is_req_id_pending2 = FALSE;

    CM_MSG_HIGH_0("SC_SGLTE: RESET is_req_id_pending2");
  }
}

/*===========================================================================

FUNCTION  cmph_set_sys_sel_pref_rsp_pending3

DESCRIPTION
 Set the flag is_sys_sel_pref_rsp_pending3 to true.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_set_sys_sel_pref_rsp_pending3 (
    uint16 sys_sel_pref_req_id
)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Set req_id pending for hybr2 satck to true */
  if (!ph_ptr->is_sys_sel_pref_rsp_pending3)
  {
    ph_ptr->is_sys_sel_pref_rsp_pending3 = TRUE;

    CM_MSG_HIGH_1("SC_SGLTE: SET is_sys_sel_pref_rsp_pending3=TRUE, req_id=%d",
                 sys_sel_pref_req_id);
  }
  else
  {
    CM_ERR_0("SC_SGLTE: is_sys_sel_pref_rsp_pending3 is already TRUE");
  }

  /* Set is_req_id_pending2 to true if req_id is non default value */
  if (sys_sel_pref_req_id != CM_DEFAULT_VALUE)
  {
    cmph_set_req_id_pending3();
  }
}

/*===========================================================================

FUNCTION  cmph_reset_sys_sel_pref_rsp_pending3

DESCRIPTION
 Reset the flag is_sys_sel_pref_rsp_pending3 to true.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_reset_sys_sel_pref_rsp_pending3 (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Reset the flag */
  if (ph_ptr->is_sys_sel_pref_rsp_pending3)
  {
    ph_ptr->is_sys_sel_pref_rsp_pending3 = FALSE;

    CM_MSG_HIGH_0("SC_SGLTE: RESET is_sys_sel_pref_rsp_pending3");
  }
}

/*===========================================================================

FUNCTION  cmph_set_req_id_pending3

DESCRIPTION
 Set the flag is_req_id_pending3 to true.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_set_req_id_pending3 (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Set req_id pending for hybr2 satck to true */
  CM_MSG_HIGH_1("SC_SGLTE: is_req_id_pending3=%d", ph_ptr->is_req_id_pending3);
  if (!ph_ptr->is_req_id_pending3)
  {
    ph_ptr->is_req_id_pending3 = TRUE;
  }
}


/*===========================================================================

FUNCTION  cmph_reset_req_id_pending3

DESCRIPTION
 Reset the flag is_req_id_pending3 to false.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_reset_req_id_pending3 (void)
{
  cmph_s_type *ph_ptr = cmph_ptr();

  /* Reset the flag */
  if (ph_ptr->is_req_id_pending3)
  {
    ph_ptr->is_req_id_pending3 = FALSE;

    CM_MSG_HIGH_0("SC_SGLTE: RESET is_req_id_pending3");
  }
}



/*===========================================================================
FUNCTION   cmph_getNVImsi

DESCRIPTION
  This function reads NV info.

DEPENDENCIES
  Currently usable only for Thin UI builds

RETURNS
  None

SIDE EFFECTS
  None
===========================================================================*/

void cmph_getNVImsi (byte* imsi_p)
{
  nv_item_type nvi;
  int i = 0;
  cmnv_read_wait( NV_GSMUMTS_IMSI_I, &nvi );
  for ( i = 0; i < REG_NV_IMSI_MAX_LENGTH; i++ )
  {
    imsi_p[i] = nvi.gsmumts_imsi[i];
  }
}

/*===========================================================================
FUNCTION   cm_create_cu_efs_imsi_file

DESCRIPTION
  This function create imsi efs file.

DEPENDENCIES

RETURNS
  None

SIDE EFFECTS
  None
===========================================================================*/

void cm_create_cu_efs_imsi_file( void )
{
  struct fs_stat     cm_conf_stat;
  int32              cm_conf_fd;

  /* create the directory if it doesn't exist */
  if ( mcfg_fs_stat(CM_AUTO_REG_EFS_CU_IMSI_DIR2, &cm_conf_stat, MCFG_FS_TYPE_EFS, MCFG_FS_SUBID_0) 
       != MCFG_FS_STATUS_OK )
  {
    if ( mcfg_fs_stat(CM_AUTO_REG_EFS_CU_IMSI_DIR1, &cm_conf_stat, MCFG_FS_TYPE_EFS, MCFG_FS_SUBID_0)
         != MCFG_FS_STATUS_OK )
    {
      (void)mcfg_mkdir(CM_AUTO_REG_EFS_CU_IMSI_DIR1, MCFG_FS_ALLPERMS, MCFG_FS_TYPE_EFS);
    }
    (void)mcfg_mkdir(CM_AUTO_REG_EFS_CU_IMSI_DIR2, MCFG_FS_ALLPERMS, MCFG_FS_TYPE_EFS);
  }

  /* create the /operetor/cu/imsi.dat  file if it doesn't exist */
  if ( mcfg_fs_stat(CM_AUTO_REG_EFS_CU_IMSI_FILE, &cm_conf_stat, MCFG_FS_TYPE_EFS, MCFG_FS_SUBID_0) 
       != MCFG_FS_STATUS_OK )
  {
    cm_conf_fd = mcfg_fopen (CM_AUTO_REG_EFS_CU_IMSI_FILE, 
                             MCFG_FS_O_WRONLY|MCFG_FS_O_CREAT|MCFG_FS_O_TRUNC, 
                             MCFG_FS_ALLPERMS, 
                             MCFG_FS_TYPE_EFS, 
                             MCFG_FS_SUBID_0);
    if( cm_conf_fd >= 0 )
    {
      CM_MSG_HIGH_0("create efs imsi file success");
    }
    else
    {
      CM_MSG_HIGH_1("efs imsi file NOT created %d",cm_conf_fd);
    }
    (void)mcfg_fclose(cm_conf_fd, MCFG_FS_TYPE_EFS);
  }
}

/*===========================================================================
FUNCTION   cm_create_cmcc_efs_imsi_file

DESCRIPTION
  This function create imsi efs file.

DEPENDENCIES

RETURNS
  None

SIDE EFFECTS
  None
===========================================================================*/

void cm_create_cmcc_efs_imsi_file( void )
{
  struct fs_stat     cm_conf_stat;
  int32              cm_conf_fd;

  /* create the directory if it doesn't exist */
  if ( mcfg_fs_stat(CM_AUTO_REG_EFS_CMCC_IMSI_DIR2, &cm_conf_stat, MCFG_FS_TYPE_EFS, MCFG_FS_SUBID_0) 
       != MCFG_FS_STATUS_OK )
  {
    if ( mcfg_fs_stat(CM_AUTO_REG_EFS_CU_IMSI_DIR1, &cm_conf_stat, MCFG_FS_TYPE_EFS, MCFG_FS_SUBID_0)
         != MCFG_FS_STATUS_OK )
    {
      (void)mcfg_mkdir(CM_AUTO_REG_EFS_CU_IMSI_DIR1, MCFG_FS_ALLPERMS, MCFG_FS_TYPE_EFS);
    }
    (void)mcfg_mkdir(CM_AUTO_REG_EFS_CMCC_IMSI_DIR2, MCFG_FS_ALLPERMS, MCFG_FS_TYPE_EFS);
  }

  /* create the /operetor/cu/imsi.dat  file if it doesn't exist */
  if ( mcfg_fs_stat(CM_AUTO_REG_EFS_CMCC_IMSI_FILE, &cm_conf_stat, MCFG_FS_TYPE_EFS, MCFG_FS_SUBID_0)
       != MCFG_FS_STATUS_OK )
  {
    cm_conf_fd = mcfg_fopen (CM_AUTO_REG_EFS_CMCC_IMSI_FILE, 
                             MCFG_FS_O_WRONLY|MCFG_FS_O_CREAT|MCFG_FS_O_TRUNC, 
                             MCFG_FS_ALLPERMS, 
                             MCFG_FS_TYPE_EFS, 
                             MCFG_FS_SUBID_0);
    if( cm_conf_fd >= 0 )
    {
      CM_MSG_HIGH_0("create efs imsi file success");
    }
    else
    {
      CM_MSG_HIGH_1("efs imsi file NOT created %d",cm_conf_fd);
    }
    (void)mcfg_fclose(cm_conf_fd, MCFG_FS_TYPE_EFS);
  }
}

/*===========================================================================

FUNCTION cm_device_model_init

DESCRIPTION
  This function returns the current value of the Price Unit Currency Conversion

DEPENDENCIES

RETURN VALUE
  The puct value from the AP.

SIDE EFFECTS
  None
===========================================================================*/
void cmph_device_model_init
(
  void
)
{
  int32 size = 0;
  char oldValue = 0x5F;
  char newValue = 0x20;
  cm_device_model_info_efs *model_ptr = NULL;


  model_ptr  = cm_get_device_info();

  /* memset the entire structure to NULL as this is the entry point */
  memset(model_ptr,0x0,sizeof(cm_device_model_info_efs));


  /* Operator */
  model_ptr->oprtr = cm_get_operator_info(SYS_MODEM_AS_ID_1);

  /* manufacturer name */

  size = sizeof (model_ptr->manufacturer_name);
  if(cmefs_read(CMEFS_MANU_NAME, (byte*)model_ptr->manufacturer_name, &size))
  {
    CM_MSG_HIGH_4("Manufacturer Name : %s, Value of manufacturer_name, 0x%x,0x%x,0x%x",model_ptr->manufacturer_name,
                                         model_ptr->manufacturer_name[0],
                                         model_ptr->manufacturer_name[1],
                                         model_ptr->manufacturer_name[2]);
    cm_model_initialized = DEV_MODEL_INIT_PARTIAL;

  }
  else
  {
    CM_ERR_0("Failed to read CMEFS_MANUFACTURE_NAME...");
    cm_model_initialized = DEV_MODEL_INIT_NULL;
    return;
  }

  /* manufacture code */

  size = sizeof (model_ptr->manufacturer_code);
  if(cmefs_read(CMEFS_MANU_CODE, (byte*)model_ptr->manufacturer_code, &size))
  {
    CM_MSG_HIGH_4("Manufacturer Code : %s, Value of manufacturer_code, 0x%x,0x%x,0x%x",model_ptr->manufacturer_code,
                                         model_ptr->manufacturer_code[0],
                                         model_ptr->manufacturer_code[1],
                                         model_ptr->manufacturer_code[2]);
    cm_model_initialized = DEV_MODEL_INIT_PARTIAL;
  }
  else
  {
    CM_ERR_0("Failed to read CMEFS_MANUFACTURE_CODE...");
    cm_model_initialized = DEV_MODEL_INIT_NULL;

    return;
  }


  /* device model */

  size = sizeof (model_ptr->device_model);
  if(cmefs_read(CMEFS_DEV_MODEL, (byte*)model_ptr->device_model, &size))
  {
    CM_MSG_HIGH_4("Device Model : %s, Value of device_model, 0x%x,0x%x,0x%x",model_ptr->device_model,
                                         model_ptr->device_model[0],
                                         model_ptr->device_model[1],
                                         model_ptr->device_model[2]);

    /*Replace char '-'*/ /* underscore will be replaced by space*/
    charReplace(model_ptr->device_model,oldValue,newValue);
    cm_model_initialized = DEV_MODEL_INIT_PARTIAL;
  }
  else
  {
    CM_ERR_0("Failed to read CMEFS_MANUFACTURE_CODE...");
    cm_model_initialized = DEV_MODEL_INIT_NULL;

    return;
  }


  /*  sw version */
  /*updated by APSS*/

  size = sizeof (model_ptr->sw_version);
  if(cmefs_read(CMEFS_SW_VER, (byte*)model_ptr->sw_version, &size))
  {

    CM_MSG_HIGH_4("Software Version : %s, Value of sw_version, 0x%x,0x%x,0x%x",model_ptr->device_model,
                                         model_ptr->device_model[0],
                                         model_ptr->device_model[1],
                                         model_ptr->device_model[2]);

    /*Replace char '-'*/ /* underscore will be replaced by space*/
    charReplace(model_ptr->device_model,oldValue,newValue);
    if (cm_model_initialized == DEV_MODEL_INIT_PARTIAL)
    {
      cm_model_initialized = DEV_MODEL_INIT_FULL;
    }
  }
  else
  {
    CM_ERR_0("Failed to read CMEFS_SW_VER...");

    return;
  }

  CM_MSG_HIGH_1("cm_device_model_init() - Status:%d",cm_model_initialized);

  return;
}

/*===========================================================================
FUNCTION charReplace

DESCRIPTION
    This function replace  c1 to  c2 for string s

DEPENDENCIES

RETURN VALUE
   Void

SIDE EFFECTS
  None
===========================================================================*/
void charReplace(char *s,char c1,char c2 )
{

  for (; *s != '\0'; s++)
  {
    if (*s == c1)
    {
      *s = c2;
    }
  }

  return;
}

/*===========================================================================
FUNCTION cmph_set_apss_sw_version_efs

DESCRIPTION
    This function writes the SW Version received from APSS to EFS

DEPENDENCIES

RETURN VALUE
   Void

SIDE EFFECTS
  None
===========================================================================*/

void cmph_set_apss_sw_version_efs
(
  void
)
{
  cm_device_model_info_efs *model_ptr = NULL;
  int32 size = 0;


  model_ptr  = cm_get_device_info();

  /*sw version */

  size = sizeof (model_ptr->sw_version);
  if(cmefs_write(CMEFS_SW_VER, (byte*)model_ptr->sw_version, size))
  {
    CM_MSG_HIGH_4("SW Version : %s Value of sw_ver, 0x%x,0x%x,0x%x", model_ptr->sw_version,
                                         model_ptr->sw_version[0],
                                         model_ptr->sw_version[1],
                                         model_ptr->sw_version[2]);
  }
  else
  {
    CM_MSG_HIGH_0("Failed to write CMEFS_SW_VER...");
  }
  return;
}

/*===========================================================================
FUNCTION cmph_send_oprt_mode_online_to_mmoc

DESCRIPTION
    This function sends operating mode online to mmoc if it is buffered.

DEPENDENCIES

RETURN VALUE
   Void

SIDE EFFECTS
  None
===========================================================================*/

void cmph_send_oprt_mode_online_to_mmoc
(
  void
)
{
  CM_MSG_HIGH_2("oprt_mode_hold: send oprt mode to mmoc, send_time %d, cmph_ptr()->oprt_mode %d",
                cmph_ptr()->oprt_mode_send_time, cmph_ptr()->oprt_mode );

  if (cmph_ptr()->oprt_mode_send_time != CMPH_MAX_UPTIME)
  {
    mmoc_cmd_oprt_mode_chgd( SYS_OPRT_MODE_ONLINE );
    cmph_ptr()->oprt_mode_send_time = CMPH_MAX_UPTIME;


    cmmsimc_proc_cmd_oprt_mode_chgd(SYS_OPRT_MODE_ONLINE);

    /* Reset the origination throttle table
    */
    cmss_orig_thr_table_reset( cmss_ptr()->cmss_orig_thr_tbl_ptr );

    /* Clear the is hybr kicked flag
    */
    *cmph_get_is_kicked_hybr_ptr() = FALSE;

    /* Updating clients about pref info now, to keep them in sync*/

    cmph_send_subs_info(CM_SS_MAIN, NULL);

    if (!cmph_is_sxlte() && cmph_is_msim())
    {
      cmph_send_subs_info(CM_SS_HYBR_2, NULL);
    }

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if(cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY ||
       cmph_is_sxlte() )
    {
      cmph_send_subs_info(CM_SS_HYBR_3, NULL);
    }
    #endif

    cmph_sp_subs_info_update();
    cmph_send_vsid_info();

  }
}

/*===========================================================================

FUNCTION cmph_send_sim_available_ph_event

DESCRIPTION
  This function sends the event CM_PH_EVENT_SIM_AVAILABLE


DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_send_sim_available_ph_event()
{
  cmph_s_type *ph_ptr = cmph_ptr();
  CM_MSG_HIGH_0("sending SIM_AVAILABLE_EVENT");
  cmph_event(ph_ptr, CM_PH_EVENT_SIM_AVAILABLE);
}


/*===========================================================================

FUNCTION  cmph_read_operator_imsi

DESCRIPTION
 Read the imsi from nv efs.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_read_operator_imsi (void)
{
  int32 imsi_size = sizeof(cm_auto_reg_efs_cu_imsi);
  int  i=0;
  /*IMSI in EFS is 8bytes*/
  /*CM_AUTO_REG_EFS_CU_IMSI_LEN is 8*/

  /* Read the EFS file */

  memset (&cm_auto_reg_efs_cu_imsi,0,sizeof(cm_auto_reg_efs_cu_imsi));
  memset (&cm_auto_reg_efs_cmcc_imsi,0,sizeof(cm_auto_reg_efs_cmcc_imsi));

  if ( cm_get_operator_info(SYS_MODEM_AS_ID_1) == OPERATOR_CMCC )
  {
    if( cmefs_read ( CMEFS_CMCC_IMSI,
                    (byte*)&cm_auto_reg_efs_cmcc_imsi,
                    &imsi_size)
      )
    {
      for(i=0;i<imsi_size;i++)
      {
      /*Processing the buffer*/
        CM_MSG_HIGH_2 ("CMCC IMSI[%d]:%X",
                      i, cm_auto_reg_efs_cmcc_imsi[i]);
      }
    }
    else
    {
      /* set default value to  dual sim opr mode */
      CM_ERR_0 ("QMSS: fail to read /nv/item_files/modem/mmode/cmcc_imsi, default to NULL");
    }
  }

  else if ( cm_get_operator_info(SYS_MODEM_AS_ID_1) == OPERATOR_CU )
  {
    if( cmefs_read ( CMEFS_CU_IMSI,
                    (byte*)&cm_auto_reg_efs_cu_imsi,
                    &imsi_size)
      )
    {
      for(i=0;i<imsi_size;i++)
      {
      /*Processing the buffer*/
        CM_MSG_HIGH_2 ("CU IMSI[%d]:%X",
                      i, cm_auto_reg_efs_cu_imsi[i]);
      }
    }
    else
    {
      /* set default value to  dual sim opr mode */
      CM_ERR_0 ("QMSS: fail to read /nv/item_files/modem/mmode/cu_imsi, default to NULL");
    }
  }
}

/*===========================================================================

FUNCTION cmph_is_allow_mode_pref_none_during_lte_disable

DESCRIPTION
  This function sends the event CM_PH_EVENT_SIM_AVAILABLE

DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none
===========================================================================*/
boolean  cmph_is_allow_mode_pref_none_during_lte_disable
(
    cm_ph_cmd_info_s_type          *cmd_info_ptr
)
{
  if (cmd_info_ptr == NULL)
  {
    return FALSE;
  }

  switch(cmd_info_ptr->lte_disable_cause)
  {
    case CM_LTE_DISABLE_CAUSE_DAM:
    case CM_LTE_DISABLE_CAUSE_PERMANENT_DS:
        return TRUE;
    break;
    default:
        return FALSE;
  }

  return FALSE;
}
/*===========================================================================

FUNCTION cmph_send_reg_csg_selection_update_cmd

DESCRIPTION
  This function sends the CM_CSG_SELECT_CONFIG_UPDATE_IND to REG


DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cmph_send_reg_csg_selection_update_cmd(ui_base_msgr_msg_csg_select_config_cmd_msg_type *csg_sel_cfg)
{

  #if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)
  reg_cmd_type                *reg_ptr;

  CM_ASSERT(csg_sel_cfg != NULL);

  CM_MSG_HIGH_2("sending CM_CSG_SELECT_CONFIG_UPDATE_IND csg_sel_config %d, asubs_id",csg_sel_cfg->csg_sel.select_config,csg_sel_cfg->csg_sel.asubs_id);

  /*Get reg cmd. buffer and populate params.*/
  reg_ptr =  cm_reg_get_buf_else_err_fatal( CM_CSG_SELECT_CONFIG_UPDATE_IND );
  /* Fill in parameters. */

  reg_ptr->cmd.cm_csg_select_config_update_ind.as_id= csg_sel_cfg->csg_sel.asubs_id;

  reg_ptr->cmd.cm_csg_select_config_update_ind.csg_selection_config = cmph_map_ui_base_csg_sel_config_to_sys(csg_sel_cfg->csg_sel.select_config);

  /* Send the request to NAS */
  cm_reg_send_cmd( reg_ptr );
  #endif
}

/*===========================================================================

FUNCTION cmph_process_search_trigger_ind

DESCRIPTION
  This function sends the MM_CM_CSG_SEARCH_TRIGGER_IND to CSG app upon recieving CM_CSG_SEARCH_TRIGGER_IND from REG


DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cmph_process_search_trigger_ind( const cm_csg_search_trigger_ind_s_type *csg_srch_trigger)
{

  cm_csg_srch_trigger_ind_s_type  csg_srch_params;

  memset(&csg_srch_params, 0, sizeof(cm_csg_srch_trigger_ind_s_type));

  /* Send MM_CM_CSG_SEARCH_TRIGGER_IND to TUI for triggering the network search
        upon SIM refresh(CM_CSG_SEARCH_TRIGGER_IND) from REG */

  CM_MSG_HIGH_1("CM->MSGR: sending MM_CM_CSG_SEARCH_TRIGGER_IND as_id %d",csg_srch_trigger->as_id);

  csg_srch_params.as_id = csg_srch_trigger->as_id;
  csg_srch_params.hdr.inst_id= SYS_AS_ID_TO_INST_ID(csg_srch_trigger->as_id);

  (void) cm_msgr_send( MM_CM_CSG_SEARCH_TRIGGER_IND, MSGR_MM_CM,
      (msgr_hdr_struct_type*)&csg_srch_params, sizeof(cm_csg_srch_trigger_ind_s_type) );

}

#ifdef FEATURE_MMODE_SXLTE_G
void cmph_initiate_sxlte_multimode_switch
(
  boolean force_subs_change
)
{
  cmph_s_type *ph_ptr = cmph_ptr();
  cm_pref_s_type temp_pref_info;
  cmph_stack_info_s_type  temp_stack_info;

  /* Switch preferences */
  temp_stack_info = ph_ptr->main_stack_info;
  ph_ptr->main_stack_info = ph_ptr->hybr_2_stack_info = ph_ptr->hybr_3_stack_info;
  ph_ptr->hybr_3_stack_info = temp_stack_info;

  /* Switch persist preferences */
  {
    int i = 0;
    while(i<NV_MAX_NAMS)
    {
      temp_pref_info = ph_ptr->prst_main_stack_info[i];
      ph_ptr->prst_main_stack_info[i] = ph_ptr->prst_hybr_2_stack_info[i] = ph_ptr->prst_hybr_3_stack_info[i];
      ph_ptr->prst_hybr_3_stack_info[i] = temp_pref_info;
      i++;
    }
  }

  /* Switch sub feature modes */
  {
    sys_subs_feature_t temp_subs_feature;
    temp_subs_feature = ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1];
    ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] = ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_2];
    ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_2] = temp_subs_feature;

    ph_ptr->main_stack_info.feature_mode = ph_ptr->subs_feature_mode[ph_ptr->main_stack_info.asubs_id];
    ph_ptr->hybr_2_stack_info.feature_mode = ph_ptr->subs_feature_mode[ph_ptr->main_stack_info.asubs_id];
    ph_ptr->hybr_3_stack_info.feature_mode = ph_ptr->subs_feature_mode[ph_ptr->hybr_3_stack_info.asubs_id];
  }

  /* Set stack mapping */
  if(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SGLTE)
  {
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_MAIN;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][1] = CM_SS_HYBR_2;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][0] = CM_SS_HYBR_3;

    ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 0;/* shld not be accessed */
    ph_ptr->ss_subs_map[CM_SS_HYBR_2].stack_id = 1;
    ph_ptr->ss_subs_map[CM_SS_HYBR_3].stack_id = 0;

    ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
    ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
    ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
  }
  else if(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_2] == SYS_SUBS_FEATURE_MODE_SGLTE)
  {
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][0] = CM_SS_MAIN;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][1] = CM_SS_HYBR_2;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_HYBR_3;

    ph_ptr->ss_subs_map[CM_SS_MAIN].stack_id = 0;
    ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 0;
    ph_ptr->ss_subs_map[CM_SS_HYBR_2].stack_id = 1;
    ph_ptr->ss_subs_map[CM_SS_HYBR_3].stack_id = 0;

    ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
    ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
    ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
  }
  else if(ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE ||
        ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SRLTE
  )
  {
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][0] = CM_SS_MAIN;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][1] = CM_SS_HYBR_1;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_1][2] = CM_SS_HYBR_2;
    ph_ptr->subs_stack_map[SYS_MODEM_AS_ID_2][0] = CM_SS_HYBR_3;

    ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id = 1;
    ph_ptr->ss_subs_map[CM_SS_HYBR_2].stack_id = 2;
    ph_ptr->ss_subs_map[CM_SS_HYBR_3].stack_id = 0;

    ph_ptr->main_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
    ph_ptr->hybr_2_stack_info.asubs_id = SYS_MODEM_AS_ID_1;
    ph_ptr->hybr_3_stack_info.asubs_id = SYS_MODEM_AS_ID_2;
  }

  /* Switch subscription available /subs sent flags */
  {
    boolean temp_subs;

    temp_subs = ph_ptr->is_gwl_subscription_available;
    ph_ptr->is_gwl_subscription_available = ph_ptr->is_hybr_gw3_subscription_available;
    ph_ptr->is_hybr_gw3_subscription_available = temp_subs;

    temp_subs = cmph_get_gw_subs_from_card_sent();
    cmph_set_gw_subs_from_card_sent(cmph_get_hybr_3_gw_subs_from_card_sent());
    cmph_set_hybr_3_gw_subs_from_card_sent(temp_subs);
  }

  /* Call CM SIM coord to reinit state machines */
  cmsimcoord_reinit();
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * */

  /* Force new PH OBJ to priority queues */
  (void)cmph_insert_orig_mode ( CM_SS_HYBR_3,
                           SD_SS_ORIG_MODE_NONE,
                           CM_ACT_TYPE_PH_OBJ,
                           ph_ptr->hybr_3_stack_info.pref_info.pref_term,
                           ph_ptr->hybr_3_stack_info.pref_info.mode_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.band_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.prl_pref,
                           ph_ptr->hybr_3_stack_info.pref_info.roam_pref,
                           CM_HYBR_PREF_OFF,
                           SD_SS_HYBR_PREF_NONE,
                           ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref,
                           (cm_act_id_type)ph_ptr,
                           CM_ACT_UPDATE_REAS_ACT_START,
                           CM_DEFAULT_VALUE,
                           ph_ptr->main_stack_info.pref_info.csg_id,
                           ph_ptr->main_stack_info.pref_info.csg_rat
                           );


  (void)cmph_insert_orig_mode (
                                CM_SS_HYBR_2,
                                SD_SS_ORIG_MODE_NONE,
                                CM_ACT_TYPE_PH_OBJ,
                                ph_ptr->main_stack_info.pref_info.pref_term,
                                ph_ptr->main_stack_info.pref_info.mode_pref,
                                ph_ptr->main_stack_info.pref_info.band_pref,
                                ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                ph_ptr->main_stack_info.pref_info.prl_pref,
                                ph_ptr->main_stack_info.pref_info.roam_pref,
                                ph_ptr->main_stack_info.pref_info.hybr_pref,
                                ph_ptr->int_hybr_pref,
                                ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                (cm_act_id_type)ph_ptr,
                                CM_ACT_UPDATE_REAS_ACT_START,
                                CM_DEFAULT_VALUE,
                                ph_ptr->main_stack_info.pref_info.csg_id,
                                ph_ptr->main_stack_info.pref_info.csg_rat
                              );

    (void)cmph_insert_orig_mode (
                                CM_SS_MAIN,
                                SD_SS_ORIG_MODE_NONE,
                                CM_ACT_TYPE_PH_OBJ,
                                ph_ptr->main_stack_info.pref_info.pref_term,
                                ph_ptr->main_stack_info.pref_info.mode_pref,
                                ph_ptr->main_stack_info.pref_info.band_pref,
                                ph_ptr->main_stack_info.pref_info.lte_band_pref,
                                ph_ptr->main_stack_info.pref_info.tds_band_pref,
                                ph_ptr->main_stack_info.pref_info.prl_pref,
                                ph_ptr->main_stack_info.pref_info.roam_pref,
                                ph_ptr->main_stack_info.pref_info.hybr_pref,
                                ph_ptr->int_hybr_pref,
                                ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                                (cm_act_id_type)ph_ptr,
                                CM_ACT_UPDATE_REAS_ACT_START,
                                CM_DEFAULT_VALUE,
                                ph_ptr->main_stack_info.pref_info.csg_id,
                                ph_ptr->main_stack_info.pref_info.csg_rat
                              );

    CM_MSG_HIGH_3("Multimode switch: force_subs_chg: %d, sfmode1 %d, sfmode %d",
                force_subs_change, ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1],
                ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_2]);

    CM_MSG_HIGH_2("mode_pref1 %d, mode_pref2 %d", ph_ptr->main_stack_info.pref_info.mode_pref,
                ph_ptr->hybr_3_stack_info.pref_info.mode_pref);

    CM_MSG_HIGH_2("asid1[0] %d, asid1[1] %d",
                ph_ptr->subs_stack_map[0][0],
                ph_ptr->subs_stack_map[0][1]);

    CM_MSG_HIGH_3("subs gw %d gw2 %d gw3 %d",
                ph_ptr->is_gwl_subscription_available,
                ph_ptr->is_hybr_gw_subscription_available,
                ph_ptr->is_hybr_gw3_subscription_available);

    CM_MSG_HIGH_3("AS_ID main %d, hybr_2 %d, hybr_3 %d",
                ph_ptr->main_stack_info.asubs_id,
                ph_ptr->hybr_2_stack_info.asubs_id,
                ph_ptr->hybr_3_stack_info.asubs_id);


    /* Force subscription change again */
    if(force_subs_change == TRUE)
    {
          cm_pref_s_type  *hybr_2_pref_ptr = NULL;

          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
          cm_pref_s_type  *hybr_3_pref_ptr = NULL;

          if(cmph_is_tsts() ||cmph_is_sxlte())
          {
            hybr_3_pref_ptr = &(ph_ptr->hybr_3_stack_info.pref_info);
          }
          #endif
            
          /* Allocate buffer only if multi-sim */
          if (cmph_is_msim() && !cmph_no_hybr2())
          {
            hybr_2_pref_ptr = cm_pref_ptr();
            memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                           &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
          }
          cmmsimc_proc_cmd_subsc_chgd(  MMOC_SUBSC_CHG_SUBSC_AVAIL,
             (byte) ph_ptr->curr_nam,
              ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
              ph_ptr->main_stack_info.pref_info.mode_pref,
              ph_ptr->main_stack_info.pref_info.band_pref,
              ph_ptr->main_stack_info.pref_info.lte_band_pref,
              ph_ptr->main_stack_info.pref_info.tds_band_pref,
              CMPH_PRST_PRL_PREF( ph_ptr ),
              CMPH_PRST_ROAM_PREF( ph_ptr ),
              ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].hybr_pref,
              ph_ptr->main_stack_info.pref_info.plmn,
              ph_ptr->main_stack_info.pref_info.srv_domain_pref,
              ph_ptr->main_stack_info.pref_info.acq_order_pref,
              hybr_2_pref_ptr,
              #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
              hybr_3_pref_ptr,
              #endif
              ph_ptr->is_gwl_subscription_available,
              ph_ptr->is_hybr_gw_subscription_available,
              ph_ptr->is_hybr_gw3_subscription_available,
              ph_ptr->is_cdma_subscription_available,
              PROT_SUBSC_CHG_ALL,
              PROT_SUBSC_CHG_NONE,
              PROT_SUBSC_CHG_GW
           );

           /* Free allocated buffer */
           if (hybr_2_pref_ptr)
           {
             cm_mem_free (hybr_2_pref_ptr);
           }
    }


}

#endif

/*===========================================================================

    FUNCTION cmph_get_sxlte_sub

   DESCRIPTION
      This function returns which sub is sxlte


    DEPENDENCIES

   RETURN VALUE
      sys_modem_as_id_e_type

    SIDE EFFECTS
      none

    ===========================================================================*/

sys_modem_as_id_e_type cmph_get_sxlte_sub()
{
  sys_modem_as_id_e_type as_id_i = SYS_MODEM_AS_ID_1;

  for(; as_id_i <= SYS_MODEM_AS_ID_2; as_id_i++)
  {
    if (cmph_is_subs_feature_mode_sglte(as_id_i) ||
       cmph_is_subs_feature_mode_1x_sxlte(as_id_i))
    {
      return as_id_i;
    }
  }
  return SYS_MODEM_AS_ID_NONE;
}

/*===========================================================================
FUNCTION  cmph_is_oprting_in_csfb_pref

DESCRIPTION
Returns TRUE if UE is operating in csfb preferred mode .



DEPENDENCIES
 cmmsc_init should already be called


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_oprting_in_csfb_pref(
    sys_modem_as_id_e_type         asubs_id
)
{
  cmmsc_state_machine_s_type *state_machine = cmmsimc_state_machine_ptr(asubs_id);
  boolean ret = FALSE;

  if(cmph_is_subs_feature_mode_1x_sxlte(asubs_id) &&
     state_machine->stack_common_info.ue_mode == SYS_UE_MODE_1XSRLTE_CSFB_PREFERRED)
  {
    ret = TRUE;
  }

  return ret;
}

//#if defined(FEATURE_LTE_TO_1X) && defined(FEATURE_MMODE_SC_SVLTE)
/*===========================================================================
FUNCTION  cmph_is_oprting_in_csfb_pref_srlte

DESCRIPTION
Returns TRUE if UE is operating in 1XSRLTE-Dual mode .



DEPENDENCIES
 cmmsc_init should already be called


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_oprting_in_csfb_pref_srlte(
    sys_modem_as_id_e_type         asubs_id
)
{
  cmmsc_state_machine_s_type *state_machine = cmmsimc_state_machine_ptr(asubs_id);
  boolean ret = FALSE;

  if(cmph_is_subs_feature_mode_1x_sxlte(asubs_id) &&
     state_machine->stack_common_info.ue_mode == SYS_UE_MODE_1XSRLTE_CSFB_PREFERRED &&
     cmss_is_hybr2_operational())
  {
    ret = TRUE;
  }

  return ret;
}

/*===========================================================================
FUNCTION  cmph_is_oprting_in_csfb_pref_csfb_sub_mode

DESCRIPTION
Returns TRUE, if UE is operating in CSFB sub mode of operation when UE mode is CSFB_PREF



DEPENDENCIES
 cmmsc_init should already be called


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_oprting_in_csfb_pref_csfb_sub_mode(
    sys_modem_as_id_e_type         asubs_id
)
{
  cmmsc_state_machine_s_type *state_machine = cmmsimc_state_machine_ptr(asubs_id);
  boolean ret = FALSE;

  if(cmph_is_subs_feature_mode_1x_sxlte(asubs_id) &&
     state_machine->stack_common_info.ue_mode == SYS_UE_MODE_1XSRLTE_CSFB_PREFERRED &&
     !cmss_is_hybr2_operational())
  {
    ret = TRUE;
  }

  return ret;
}

/*===========================================================================

FUNCTION  cmph_is_oprting_in_1xsrlte_mode

DESCRIPTION
 Returns TRUE if UE is operating in 1XSRLTE-SVLTE mode .

DEPENDENCIES
 cmmsc_init should already be called


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_oprting_in_1xsrlte_mode(
    sys_modem_as_id_e_type         asubs_id
)
{
  cmmsc_state_machine_s_type *state_machine = cmmsimc_state_machine_ptr(asubs_id);
  boolean ret = FALSE;

  if( cmph_is_subs_feature_mode_1x_sxlte(asubs_id)
         &&
     (state_machine->stack_common_info.ue_mode == SYS_UE_MODE_1XSRLTE_CSFB_PREFERRED ||
      state_machine->stack_common_info.ue_mode == SYS_UE_MODE_1XSRLTE_ONLY
     )   &&
     cmss_is_hybr2_operational())
  {
    ret = TRUE;
  }

  return ret;
}

/*===========================================================================

FUNCTION cmph_update_suspend_status

DESCRIPTION
  take action whenever a new suspend cmd has been sent to MMOC or response
  has been recieved from MMOC.
  update suspend status whenver response is obtained.
  increment or decrement num_request based on request/response sent/recieved.

DEPENDENCIES
  Ph object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  none

===========================================================================*/
void cmph_update_suspend_status(

    cm_ss_e_type            ss,
    /* indicates the stack that is being updated
    */

    boolean                 is_request,
    /* indicate if a request has been sent (TRUE) or response recieved (FALSE)
    */

    boolean                 suspend_status
    /* valid only if is_request = FALSE (response). It is the new value of
    ** stack suspend status
    */
)
{
  cm_stack_suspend_info_s_type * info_ptr = &(cmph_ptr()->ss_susp_info[ss]);

  /* If a request is being sent to MMOC, update request count and indicate
  ** 1xcp */
  if( is_request )
  {
    info_ptr->num_requests++;
  }
  /* If a response is recieved, update status and decrement count
  */
  else
  {
    if( info_ptr->num_requests > 0 )
    {
      info_ptr->num_requests--;
    }
    info_ptr->is_suspend = suspend_status;
  }
  CM_MSG_HIGH_3("SO:ss %d, susp_status %d , num_req %d",ss,
              cmph_ptr()->ss_susp_info[ss].is_suspend,
              cmph_ptr()->ss_susp_info[ss].num_requests);
}//cmph_update_suspend_status


/*===========================================================================

FUNCTION cmph_ss_susp_due_to_emerg

DESCRIPTION
  Check iff stack is supended due to emergency

DEPENDENCIES
  Ph object must have already been initialized with
  cmph_init().

RETURN VALUE
  TRUE if stack is suspended, FALSE otherwise

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_ss_susp_due_to_emerg(

    cm_ss_e_type            ss
    /* Stack to be checked */
)
{
  uint8 i;

  if((ss > CM_SS_MAX) || (ss <= CM_SS_NONE))
  {
    CM_MSG_HIGH_1("Invalid SS %d input",ss);
  }
  else if(ss < CM_SS_MAX)
  {
    return cmph_ptr()->ss_susp_info[ss].susp_due_to_emerg;
  }
  else
  {
    /* CM_SS_MAX case. Need to check if one of the stacks is suspended */
    for(i=CM_SS_MAIN; i<CM_SS_MAX; i++)
    {
      if(cmph_ptr()->ss_susp_info[i].susp_due_to_emerg)
      {
        return TRUE;
      }
    }
  }

  return FALSE;

}/* cmph_ss_susp_due_to_emerg */

/*===========================================================================

FUNCTION cmph_get_ss_mode_pref

DESCRIPTION
  Returns the mode_pref of corresponding ss

DEPENDENCIES
  Ph object must have already been initialized with
  cmph_init().

RETURN VALUE
  mode_pref of ss, which is passed as argument

SIDE EFFECTS
  none

===========================================================================*/
cm_mode_pref_e_type cmph_get_ss_mode_pref(

    cm_ss_e_type            ss
    /* Stack to be checked */
)
{
  cmph_s_type           *ph_ptr = cmph_ptr();

  #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
  if (ss == CM_SS_HYBR_3)
  {
    return ph_ptr->hybr_3_stack_info.pref_info.mode_pref;
  }
  #endif
  if (ss == CM_SS_HYBR_2)
  {
    return ph_ptr->hybr_2_stack_info.pref_info.mode_pref;
  }
  if (ss == CM_SS_MAIN || ss == CM_SS_HYBR_1)
  {
    return ph_ptr->main_stack_info.pref_info.mode_pref;
  }

  return CM_MODE_PREF_NONE;
}

/*===========================================================================

FUNCTION  cmph_get_ss_to_check_for_call

DESCRIPTION
 The function returns ss on which CM need to check that if there is any call
 ongoing or not, while processing get_networks

DEPENDENCIES
 none

RETURN VALUE
  ss

SIDE EFFECTS
  none

===========================================================================*/
static cm_ss_e_type cmph_get_ss_to_check_for_call(cm_ss_e_type ss)
{


  CM_MSG_HIGH_1("In: ss %d",ss);
  switch (cm_get_device_mode())
  {
    case SYS_MODEM_DEVICE_MODE_SINGLE_SIM:
      // Need not to make ss as MAX, because for SVLTE/SGLTE where CM got two stacks, each stack
      // will be served by independent RF. For Single Stack, check on ss only will suffice
      break;
    case SYS_MODEM_DEVICE_MODE_DUAL_SIM_DUAL_STANDBY:
    case SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY:
      // Check on all ss, device got only one RF
      ss = CM_SS_MAX;
      break;
    case SYS_MODEM_DEVICE_MODE_DUAL_SIM_DUAL_ACTIVE:
      break;
    default:
      CM_MSG_HIGH_1("Invalid Device mode %d",cm_get_device_mode());
  }
  CM_MSG_HIGH_1("Out: ss %d",ss);
  return ss;
}

/*===========================================================================

FUNCTION  cmph_map_as_id_stack_id_to_ss

DESCRIPTION
 The function returns ss corresponding to as_id, stack_id passed

DEPENDENCIES
 none

RETURN VALUE
  ss

SIDE EFFECTS
  none

===========================================================================*/
cm_ss_e_type cmph_map_as_id_stack_id_to_ss(sys_modem_as_id_e_type as_id, sys_modem_stack_id_e_type stack_id)
{
  if (!(as_id > SYS_MODEM_AS_ID_NONE && as_id < SYS_MODEM_AS_ID_NO_CHANGE) ||
      !(stack_id > SYS_MODEM_STACK_ID_NONE && stack_id < SYS_MODEM_STACK_ID_MAX)
     )
  {
    CM_MSG_HIGH_2("Invalid as_id %d, stack_id %d",as_id,stack_id);
    return CM_SS_NONE;
  }

  return cmph_ptr()->subs_stack_map[as_id][stack_id];
}

/*===========================================================================

FUNCTION  cmph_delete_and_unforce_activity

DESCRIPTION
 This function checks for the given activityand unforces it without any timer logic.

DEPENDENCIES
 none

RETURN VALUE
  ss

SIDE EFFECTS
  none

===========================================================================*/
void cmph_delete_and_unforce_activity(cm_ss_e_type ss, cm_act_id_type  act_id)
{
  cm_orig_q_s_type  *ph_orig_ptr;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Search the ptr
  */
  if (ss != CM_SS_NONE)
  {
    ss = (ss == CM_SS_MAX ? CM_SS_MAIN : ss);

    ph_orig_ptr = cmtask_orig_para_search_act_id(ss, act_id);

    if( ph_orig_ptr != NULL )
    {
      /* Delete the priority object identified by act_id */
      if (cmtask_orig_para_delete( ss, ph_orig_ptr, TRUE ))
      {
        cmph_force_orig_mode_on_the_fly(ss);
      }
    }
  }

}


/*===========================================================================

FUNCTION cmph_add_mode_in_DSDX

DESCRIPTION
   To add the modes as dictated by NV-mode_disabled_in_TSTS to the mode_pref of
   multimode sub.

DEPENDENCIES
  Ph object must have already been initialized with
  cmph_init().
  standby pref should change from triple standby to dual/single standby

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_add_mode_in_DSDX()
{

  cm_mode_pref_e_type      cm_prst_mode_pref = CM_MODE_PREF_NONE;
  cm_mode_pref_e_type      cm_mode_pref = CM_MODE_PREF_NONE;

  cmph_s_type             *ph_ptr = cmph_ptr();

  cm_pref_s_type           pref_ptr, *hybr_2_pref_ptr  = NULL;
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  cm_pref_s_type          *hybr_3_pref_ptr  = NULL ;
  #endif

  cm_ss_e_type             cm_ss = CM_SS_NONE;
  sys_modem_as_id_e_type   sub_asub_id = SYS_MODEM_AS_ID_NONE;



  sub_asub_id = cmph_get_sub_with_lte_cap();
  cm_ss = cmph_map_as_id_to_cm_ss(sub_asub_id);

  cm_prst_mode_pref = CMPH_PRST_SS_MODE_PREF(sub_asub_id, ph_ptr);
  cm_mode_pref      = CMPH_SS_MODE_PREF(sub_asub_id, ph_ptr);
  CM_MSG_HIGH_2("ADD_LTE : ss_with_mm: %d, old_mode_pref: %d",cm_ss,cm_mode_pref);

  if( cmcall_misc_is_mode_pref(cm_prst_mode_pref , CM_MODE_PREF_TDS_ONLY) &&
     (ph_ptr->mode_disabled_in_TSTS & SYS_SYS_MODE_MASK_TDS))
  {
    cm_mode_pref = cm_add_mode_pref_components(cm_mode_pref,
                                     1, SD_SS_MODE_PREF_TDS);
  }
  if( cmcall_misc_is_mode_pref(cm_prst_mode_pref , CM_MODE_PREF_LTE_ONLY) &&
      (ph_ptr->mode_disabled_in_TSTS & SYS_SYS_MODE_MASK_LTE))
  {
    cm_mode_pref = cm_add_mode_pref_components(cm_mode_pref,
                                1, SD_SS_MODE_PREF_GWL_LTE );
  }

  if( cm_mode_pref != CMPH_SS_MODE_PREF(sub_asub_id, ph_ptr) )
  {
    CM_MSG_HIGH_2("ADD_LTE : ss_with_mm: %d, cm_mode_pref: %d",cm_ss,cm_mode_pref);
    pref_ptr = CMPH_SS_PREF_PTR(sub_asub_id, ph_ptr);

    /* Allocate buffer only if multi-sim */
    if (cmph_is_msim())
    {

      hybr_2_pref_ptr = cm_pref_ptr();
      memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
            &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));


      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    hybr_3_pref_ptr = cm_pref_ptr();
    memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
         &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));

    if(cm_ss == CM_SS_HYBR_3)
    {
      hybr_3_pref_ptr->mode_pref  = cm_mode_pref;
    }
      #endif

      if(cm_ss == CM_SS_HYBR_2)
      {
        hybr_2_pref_ptr->mode_pref  = cm_mode_pref;
      }

    }

    cmph_force_pref_on_the_fly2(cm_ss,
                  ph_ptr,
                  SD_SS_PREF_REAS_USER,
                          CM_ACT_TYPE_PH_OBJ,
                      pref_ptr.pref_term,
                  cm_mode_pref,
                  pref_ptr.band_pref,
                  pref_ptr.lte_band_pref,
                  pref_ptr.tds_band_pref,
                  pref_ptr.prl_pref,
                  pref_ptr.roam_pref,
                  pref_ptr.hybr_pref,
                  pref_ptr.plmn,
                  pref_ptr.srv_domain_pref,
                  pref_ptr.acq_order_pref,
                  pref_ptr.network_sel_mode_pref,
                  hybr_2_pref_ptr,
                  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
                  hybr_3_pref_ptr,
                  #endif
                  CM_OTASP_ACT_CODE_NONE,
                  (cm_act_id_type)ph_ptr,
                  CM_ACT_UPDATE_REAS_USER,
                                  FALSE,
                  cmph_get_acq_pri_order_per_sub(cm_ss),
                  CM_DEFAULT_VALUE,
                  pref_ptr.csg_id,
                  pref_ptr.csg_rat
                );
  }
  else
  {
    CM_MSG_HIGH_2("ss %d does not have either TDS or LTE to add in its prst mode_pref(%d)", cm_ss, cm_mode_pref);
  }


}


/*===========================================================================

FUNCTION cmph_remove_mode_in_TSTS

DESCRIPTION
  To remove the modes as dictated by NV-mode_disabled_in_TSTS from the mode_pref of
  multimode sub.

DEPENDENCIES
  Ph object must have already been initialized with
  cmph_init().
  standby pref should change from single/dual standby to triple standby

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_remove_mode_in_TSTS(

    prot_subsc_chg_e_type *prot_subsc_chg,

    prot_subsc_chg_e_type *hybr_2_prot_subsc_chg,

    prot_subsc_chg_e_type *hybr_3_prot_subsc_chg
)

{

  cmph_s_type *ph_ptr = cmph_ptr();
  cm_mode_pref_e_type cm_mode_pref = CM_MODE_PREF_NONE;


  cmmsimc_state_s_type     *cmmsimc_state = cmmsimc_state_ptr();
  cm_ss_e_type      cm_ss = CM_SS_NONE;

   cm_orig_q_s_type  *ph_orig_top_ptr = cmtask_orig_para_get_top( CM_SS_MAIN );

  cm_orig_q_s_type  *ph_hybr_2_orig_top_ptr
                                     = cmtask_orig_para_get_top( CM_SS_HYBR_2 );

  sys_modem_as_id_e_type   sub_asub_id = SYS_MODEM_AS_ID_NONE;

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)

  cm_orig_q_s_type  *ph_hybr_3_orig_top_ptr
    = cmtask_orig_para_get_top( CM_SS_HYBR_3 );

  #endif

  sub_asub_id = cmph_get_sub_with_lte_cap();
  cm_ss = cmph_map_as_id_to_cm_ss(sub_asub_id);

  cm_mode_pref = cmph_get_ss_mode_pref(cm_ss);
  CM_MSG_HIGH_2("Remove_LTE: ss_with_mm: %d, old_mode_pref: %d", cm_ss, cm_mode_pref);

  if( cmcall_misc_is_mode_pref(cm_mode_pref , CM_MODE_PREF_TDS_ONLY) &&
     (ph_ptr->mode_disabled_in_TSTS & SYS_SYS_MODE_MASK_TDS) )
  {
    cm_mode_pref = cm_remove_mode_pref_components(cm_mode_pref,
                                                        1, SD_SS_MODE_PREF_TDS);
  }
  if( cmcall_misc_is_mode_pref(cm_mode_pref , CM_MODE_PREF_LTE_ONLY) &&
     (ph_ptr->mode_disabled_in_TSTS & SYS_SYS_MODE_MASK_LTE) )
  {
    cm_mode_pref = cm_remove_mode_pref_components(cm_mode_pref,
                                                        1, SD_SS_MODE_PREF_GWL_LTE);
  }

  if(cm_mode_pref != cmph_get_ss_mode_pref(cm_ss))
  {

    if(cm_ss == CM_SS_MAIN)
    {
      *prot_subsc_chg |= PROT_SUBSC_CHG_GW;
      ph_ptr->main_stack_info.pref_info.mode_pref = cm_mode_pref;

      if ( ph_orig_top_ptr != NULL )
      {
        ph_orig_top_ptr->orig->orig_mode_pref = cm_mode_pref;
      }
      else
      {
        CM_ERR_0( "ph_orig_top_ptr is NULL" );
      }

    }
    else if(cm_ss == CM_SS_HYBR_2)
    {
      *hybr_2_prot_subsc_chg |= PROT_SUBSC_CHG_GW;
      ph_ptr->hybr_2_stack_info.pref_info.mode_pref = cm_mode_pref;

      if ( ph_hybr_2_orig_top_ptr != NULL )
      {
        ph_hybr_2_orig_top_ptr->orig->orig_mode_pref = cm_mode_pref;
      }
      else
      {
        CM_ERR_0( "ph_hybr_2_orig_top_ptr is NULL" );
      }
    }
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    else if(cm_ss == CM_SS_HYBR_3)
    {
      *hybr_3_prot_subsc_chg |= PROT_SUBSC_CHG_GW;
      ph_ptr->hybr_3_stack_info.pref_info.mode_pref = cm_mode_pref;

      if ( ph_hybr_3_orig_top_ptr != NULL )
      {
        ph_hybr_3_orig_top_ptr->orig->orig_mode_pref = cm_mode_pref;
      }
      else
      {
        CM_ERR_0( "ph_hybr_3_orig_top_ptr is NULL" );
      }
    }
    #endif
    CM_MSG_HIGH_2("Remove_LTE: ss_with_mm: %d, cm_mode_pref: %d", cm_ss, cm_mode_pref);
    if((ph_ptr->user_standby_pref != SYS_MODEM_DS_PREF_AUTO
     && ph_ptr->user_standby_pref != SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY)
     || ph_ptr->is_standby_pref_buffered
     || cmmsimc_state->device_mode != cmpmprx_get_device_mode())
    {
      CM_MSG_HIGH_3("Remove_LTE: forcefully mark subsc->main:%d hybr2:%d hybr3:%d",prot_subsc_chg,hybr_2_prot_subsc_chg,hybr_3_prot_subsc_chg);
      cmmsimc_send_subsc_chgd_current_pref(*prot_subsc_chg,
                                           *hybr_2_prot_subsc_chg,
                                           *hybr_3_prot_subsc_chg);
    }
  }


}

/*===========================================================================

FUNCTION cmph_remove_orig_mode_with_priority_end_per_subs

DESCRIPTION
  Remove the priority queue with activity priority = priority END from the sub.

DEPENDENCIES
  none

RETURN VALUE
 None.

SIDE EFFECTS
  none

===========================================================================*/
void    cmph_remove_orig_mode_with_priority_end_per_subs(
      sys_modem_as_id_e_type         asubs_id
)
{
  if(asubs_id > SYS_MODEM_AS_ID_NONE &&
    asubs_id < SYS_MODEM_AS_ID_NO_CHANGE
  )
  {
    cm_ss_e_type            ss = CM_SS_NONE;

    ss = cmph_map_subs_to_ss(asubs_id);

    CM_MSG_HIGH_1("Remove orig mode with subs priority_end, sub=%d",
                   asubs_id);

    if (cmph_is_sxlte() 
       && 
       (cmph_is_subs_feature_mode_1x_sxlte(asubs_id) ||
        cmph_is_subs_feature_mode_sglte(asubs_id))
    )
      {
        cmph_remove_orig_mode_with_priority_end(CM_SS_MAIN);
        cmph_remove_orig_mode_with_priority_end(CM_SS_HYBR_1);
        cmph_remove_orig_mode_with_priority_end(CM_SS_HYBR_2);
      }
      else
      {
      if (asubs_id == SYS_MODEM_AS_ID_1)
      {
        cmph_remove_orig_mode_with_priority_end(CM_SS_MAIN);
        cmph_remove_orig_mode_with_priority_end(CM_SS_HYBR_1);
      }
      else
      {
        cmph_remove_orig_mode_with_priority_end(ss);
      }
    }
  }
}
#ifdef FEATURE_HDR
/*===========================================================================

FUNCTION cmph_send_trm_priority_req_non_lte

DESCRIPTION
  Send TRM priority (HIGH/LOW) to HDR based on QCHAT call
  TRUE: when TRM priority should be high (tune-away should be OFF) (when QCHAT call on)
  FALSE: when TRM priority should be low (when tune-away should be ON)
 

DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_send_trm_priority_req_non_lte( boolean tune_away_req)
{

 errno_enum_type msgr_error;

 cm_trm_priority_ind_s_type trm_priority_req;

  msgr_init_hdr(&(trm_priority_req.msg_hdr),
                MSGR_MM_CM,
                MM_CM_TRM_PRIORITY_IND);

  
 
  trm_priority_req.trm_priority_high = tune_away_req; 
 

  msgr_error = msgr_send(&(trm_priority_req.msg_hdr),
                         sizeof(cm_trm_priority_ind_s_type));
  
  CM_ASSERT(msgr_error != E_FAILURE);

  CM_MSG_HIGH_1("sent new tuneaway req %d",tune_away_req);

}
#endif


#ifdef FEATURE_CM_LTE
/*===========================================================================

FUNCTION cmph_reg_send_unblock_plmn_req

DESCRIPTION
  This function sendsPLMN unblocking to reg


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_reg_send_unblock_plmn_req(

  sys_plmn_id_s_type                plmn,
      /* The id of the system to be selected */

  sys_modem_as_id_e_type            cmd_subs,
        /* The subscription on which the command is being issued.
        */
  sys_block_plmn_cause_e_type       unblock_cause
    /* The reason for unblocking the PLMN
      */
)
{
  reg_cmd_type                *reg_ptr;
  /* Pointer to REG command buffer*/

  /* Get reg cmd. buffer and populate params.*/
  reg_ptr =  cm_reg_get_buf_else_err_fatal( CM_BLOCK_PLMN_REQ );

  /* Fill in parameters. */
  reg_ptr->cmd.cm_block_plmn_req.type = SYS_BLOCK_PLMN_UNBLOCK;
  reg_ptr->cmd.cm_block_plmn_req.plmn = plmn;
  reg_ptr->cmd.cm_block_plmn_req.as_id = cmd_subs;
  reg_ptr->cmd.cm_block_plmn_req.cause = unblock_cause;

  CM_MSG_HIGH_2("as_id=%d unblock_cause=%d, Send SYS_BLOCK_PLMN_UNBLOCK", 
                     reg_ptr->cmd.cm_block_plmn_req.as_id,
                     reg_ptr->cmd.cm_block_plmn_req.cause);

  /* Send the request to NAS */
  cm_reg_send_cmd( reg_ptr );

}

/*===========================================================================

FUNCTION cmph_reg_send_unblock_plmn_force_pref_req

DESCRIPTION
  This function sendsPLMN unblocking to reg


DEPENDENCIES
  Phone object must have already been initialized with cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_reg_send_unblock_plmn_force_pref_req(

  sys_plmn_id_s_type                plmn,
      /* The id of the system to be selected */

  sys_modem_as_id_e_type            cmd_subs,
        /* The subscription on which the command is being issued.
        */
  sys_block_plmn_cause_e_type       unblock_cause
    /* The reason for unblocking the PLMN
      */
)
{
  reg_cmd_type                *reg_ptr;
  /* Pointer to REG command buffer*/

  /* Get reg cmd. buffer and populate params.*/
  reg_ptr =  cm_reg_get_buf_else_err_fatal( CM_BLOCK_PLMN_REQ );

  /* Fill in parameters. */
  reg_ptr->cmd.cm_block_plmn_req.type = SYS_BLOCK_PLMN_UNBLOCK_FORCE_PREF;
  reg_ptr->cmd.cm_block_plmn_req.plmn = plmn;
  reg_ptr->cmd.cm_block_plmn_req.as_id = cmd_subs;
  reg_ptr->cmd.cm_block_plmn_req.cause = unblock_cause;

  CM_MSG_HIGH_2("as_id=%d unblock_cause=%d, Send SYS_BLOCK_PLMN_UNBLOCK_FORCE_PREF", 
                     reg_ptr->cmd.cm_block_plmn_req.as_id,
                     reg_ptr->cmd.cm_block_plmn_req.cause);

  /* Send the request to NAS */
  cm_reg_send_cmd( reg_ptr );

}
#endif
/*===========================================================================

FUNCTION  cmph_is_lte_only_sub

DESCRIPTION
 indicates whether the SUB is LTE only SUB or not.

DEPENDENCIES
 none

RETURN VALUE
  ss

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_lte_only_sub(cm_ss_e_type  ss)
{

  /* Pointer to phone object.*/
  sd_ss_mode_pref_e_type  comm_mode;
  sd_ss_band_pref_e_type  comm_band;
  sd_ss_band_pref_e_type  comm_tds_band;
  sys_lte_band_mask_e_type  comm_lte_band;
  sys_modem_as_id_e_type  asubs_id = cmph_map_cm_ss_to_subs(ss);

  /* get mode and band capabilities of PM policy via state machine.  */
  cmph_get_comm_mode_band_capab_with_pm(&comm_mode, &comm_band, &comm_lte_band, &comm_tds_band, asubs_id);

  if(cmcall_is_lte_only_mode(cmph_map_sd_mode_pref_to_cm_mode_pref(comm_mode),\
             cmph_map_sd_band_pref_to_cm_band_pref(comm_band),\
             comm_lte_band,\
             cmph_map_sd_tds_band_pref_to_cm_tds_band_pref(comm_tds_band)))
  {
    CM_MSG_HIGH_0("LTE ONLY SUB");
    return TRUE;
  }

  return FALSE;
}



/*===========================================================================

FUNCTION  cmph_is_voice_domain_pref_change_allowed

DESCRIPTION
 The function returns ss on which CM need to check that if there is any call
 ongoing or not

DEPENDENCIES
 none

RETURN VALUE
  TRUE if vocie doomain pre fchange is allowed.
  FLASE if vocie doomain pre fchange is not allowed.
  
SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_is_voice_domain_pref_change_allowed(cm_ph_cmd_info_s_type  *cmd_info_ptr)
{
  cm_ss_e_type       call_ss    = CM_SS_NONE;
  boolean            retVal    = FALSE;
  
  if ((cmcall_is_there_a_call_type_per_sub(cmd_info_ptr->cmd_subs, 
        CM_CALL_TYPE_VOICE, &call_ss) == CM_CALL_ID_INVALID) &&
       
      (cmcall_is_there_a_call_type_per_sub(cmd_info_ptr->cmd_subs, 
        CM_CALL_TYPE_EMERGENCY, &call_ss) == CM_CALL_ID_INVALID) &&
  
      (cmcall_is_there_a_call_type_per_sub(cmd_info_ptr->cmd_subs, 
        CM_CALL_TYPE_CS_DATA, &call_ss) == CM_CALL_ID_INVALID) &&
  
      (cmcall_is_there_a_call_type_per_sub(cmd_info_ptr->cmd_subs, 
        CM_CALL_TYPE_SMS, &call_ss) == CM_CALL_ID_INVALID)
     )
  {
    retVal = TRUE;
  }

  CM_MSG_HIGH_1("voice domain pref change retVal %d", retVal);
  return retVal;
}

/*===========================================================================

FUNCTION  cmph_send_srvcc_capability_to_reg

DESCRIPTION
 The function sends the srvcc capability sent from AP to NAS whenever invoked by client


DEPENDENCIES
 none

RETURN VALUE

SIDE EFFECTS
  none

===========================================================================*/
void cmph_send_srvcc_capability_to_reg(cm_ph_cmd_info_s_type  *cmd_info_ptr)
{
 
 #ifdef FEATURE_CM_LTE
  mm_cmd_type                   *mm_ptr;
      /* MM command pointer */

  mm_ptr = mm_cm_get_cmd_buf(MMCM_UE_CAPABILITIES_INFO);

  if (mm_ptr == NULL)
  {
    CM_ERR_0("MMCM_UE_CAPABILITIES_INFO: out of MM cmd buffer");
    return ;
  }

  mm_ptr->cmd.cm_mm_ue_capabilities_info.as_id = cmd_info_ptr->cmd_subs;

  mm_ptr->cmd.cm_mm_ue_capabilities_info.srvcc_on_fly_value = cmd_info_ptr->srvcc_capability;


  mm_put_cmd( mm_ptr );

  CM_MSG_HIGH_0("Send SRVCC Cap status to MM ");

  return ;

#endif


}

/*===========================================================================

FUNCTION cmsds_determide_mode_to_add()

DESCRIPTION
  Determines mode to be added while enabling LTE.
  

DEPENDENCIES
  

RETURN VALUE
  None.

SIDE EFFECTS
  Nothing.

========================================================================== */
sd_ss_mode_pref_e_type cmph_determine_mode_to_add
(
    cm_mode_pref_e_type curr_mode_pref
)
{

  sd_ss_mode_pref_e_type mode_to_add = SD_SS_MODE_PREF_MAX;
  
  switch (curr_mode_pref)
  {
    case CM_MODE_PREF_GSM_ONLY:
    case CM_MODE_PREF_WCDMA_ONLY:
    case CM_MODE_PREF_TDS_ONLY:
    case CM_MODE_PREF_TDS_GSM:
    case CM_MODE_PREF_TDS_WCDMA:
      mode_to_add =  SD_SS_MODE_PREF_LTE;
      break;

    default:
      if (sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(curr_mode_pref), 
                    SD_SS_MODE_PREF_TDS_GSM_WCDMA ))
      {
        mode_to_add = SD_SS_MODE_PREF_GWL_LTE;
      }
      else
      {
        mode_to_add = SD_SS_MODE_PREF_LTE;
      }
      break;
  }

  return mode_to_add;
}

/*===========================================================================

FUNCTION cmph_send_trm_priority_req

DESCRIPTION
  Send TRM priority request(HIGH/LOW) to LTE RCC for multisim configuration
  (DSDS/DSDA)
  Internally if last sent TRM req is set to FALSE,  send HIGH priority to RRC
  Otherwise set to LOW

DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_send_trm_priority_req( 
  lte_trm_priority_e      trm_priority,
  sys_modem_as_id_e_type  as_id
)
{

 lte_dsds_trm_priority_req_s trm_priority_req;


  if(trm_priority == cmph_ptr()->volte_tuneaway_req_sent)
  {
    CM_MSG_HIGH_1("ignore sending new tuneaway req %d",trm_priority);
	return;

  }

  trm_priority_req.trm_priority =trm_priority; 
 
  trm_priority_req.msg_hdr.inst_id = SYS_AS_ID_TO_INST_ID(as_id);

  trm_priority_req.client_id = LTE_TRM_PRIORITY_REQ_FROM_CM ;
  trm_priority_req.msg_hdr.inst_id = SYS_AS_ID_TO_INST_ID(as_id);

  CM_MSG_HIGH_2("CM->LTE: sent new tuneaway req %d,inst_id=%d",
                   trm_priority, 
                   trm_priority_req.msg_hdr.inst_id);

  (void) cm_msgr_send( LTE_RRC_DSDS_TRM_PRIORITY_REQ, MSGR_CM_TRM_PRIORITY_REQ,
                       (msgr_hdr_s*)&trm_priority_req, sizeof(lte_dsds_trm_priority_req_s) );

  cmph_ptr()->volte_tuneaway_req_sent = trm_priority;
   
}

/*===========================================================================

FUNCTION cmph_send_subscription_not_available_internal()

DESCRIPTION
  Utility function to put the subscription not available command on to CM
  command queue. End all the


DEPENDENCIES


RETURN VALUE
  None.

SIDE EFFECTS
  Nothing.

========================================================================== */
void                               cmph_send_subscription_not_available_internal(

   cm_subscription_status_e_type   cdma_subs_status,
    /* should cdma subscription status be changed */

   cm_subscription_status_e_type   gw_subs_status,
    /* should gw subscription status be changed */

   cm_subscription_status_e_type   hybr_gw_subs_status,
    /* should hybr_gw subscription status be changed */

   cm_subscription_status_e_type   hybr_3_gw_subs_status,
    /* should Hybr_3_gw subscription status be changed */

   cm_subscription_not_avail_cause_e_type sub_not_avail_cause
    /* Cause for subscription not available */

)
{
  if( cm_ph_cmd_subscription_not_available4( NULL,
                                             NULL,
                                             CM_CLIENT_ID_ANONYMOUS,
                                             cdma_subs_status,
                                             gw_subs_status,
                                             hybr_gw_subs_status,
                                             hybr_3_gw_subs_status,
                                             sub_not_avail_cause))
  {
    uint8 subs_bm = cmph_compute_subs_bitmask( cdma_subs_status,
                                               gw_subs_status,
                                               hybr_gw_subs_status,
                                               hybr_3_gw_subs_status );

    CM_MSG_HIGH_4("subs na CDMA %d, GW %d, Hybr GW %d Hybr GW3 %d",
                cdma_subs_status, gw_subs_status, hybr_gw_subs_status, hybr_3_gw_subs_status);

    /* Do not end voice calls when subscription loss is due to ilegal
    ** subscription event */
    if(sub_not_avail_cause != CM_SUBSCRIPTION_NOT_AVAIL_CAUSE_ILLEGAL_SUB)
    {
      cmcall_end_all_non_emerg_non_data_calls( subs_bm,
                                             CM_CALL_END_UIM_NOT_PRESENT );
    }
  }
  else
  {
    CM_ERR_3("Unable to Q: subs na CDMA %d, GW %d, Hybr GW %d",
           cdma_subs_status, gw_subs_status, hybr_gw_subs_status);
    CM_ERR_1("Hybr GW3 %d", hybr_3_gw_subs_status);
  }
  return;
}
/*===========================================================================
FUNCTION cmph_load_prst_dual_standby_pref

DESCRIPTION
  updates the ph_ptr with persistent standby values from NV


DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void cmph_load_prst_dual_standby_pref ( void )

{

  #ifdef FEATURE_MMODE_DUAL_SIM
  cmph_s_type *ph_ptr = cmph_ptr();

  if(ph_ptr->default_data_subs != ph_ptr->prst_dual_standby_pref.default_data_subs)
  {
     ph_ptr->default_data_subs = ph_ptr->prst_dual_standby_pref.default_data_subs;
     ph_ptr->dds_switch_type = DDS_CAUSE_PERMANENT;

     cmpmprx_msim_subsc_changed(ph_ptr->active_subs,ph_ptr->default_data_subs,ph_ptr->dds_switch_type); 

	/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	/* Send the PH Event that Standby Preferences have changed */
	cmph_event( ph_ptr, CM_PH_EVENT_DUAL_STANDBY_PREF );

	/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
            
    }
  #endif
}

/*===========================================================================

FUNCTION cmph_hybr_2_gw_init

DESCRIPTION
  Initializing the phone object for hybr_2 stack.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_hybr_2_gw_init(

   uint8             refresh_subs_mask ,
    /* Subs mask whose NVs need to be refreshed
    */
   boolean           is_pwr_on
    /* is this a power on refresh or MCFG triggered refresh
    */
                              )
{
  #ifdef FEATURE_MMODE_DUAL_SIM
  cmph_s_type                           *ph_ptr  =  cmph_ptr();
      /* Point at phone object to be initialized */

  unsigned int                          i;
      /* loop counter */

  cm_user_net_sel_mode_pref_e_type  user_net_sel_mode_pref;

  int32                             efs_read_size;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(cmph_is_sxlte())
  {
    ph_ptr->hybr_2_stack_info.nv_context = 0;
  }
  else
  {
  ph_ptr->hybr_2_stack_info.nv_context = 1;
  }
  if (is_pwr_on)
  {
    sys_plmn_undefine_plmn_id( &ph_ptr->hybr_2_stack_info.pref_info.plmn );
    ph_ptr->hybr_2_stack_info.pref_info.csg_id  = SYS_CSG_ID_INVALID;
    ph_ptr->hybr_2_stack_info.pref_info.csg_rat = SYS_RAT_NONE;

  } //is_pwr_on

  /* If this is not power on (ie. refresh instead) and
     hybr2 nv context is not part of the refresh subs mask, skip refresh
  */
  if ( is_pwr_on ||
      (BM(ph_ptr->hybr_2_stack_info.nv_context) & refresh_subs_mask))
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    /* Read Hybr2 stack mode preference */
    cmnv_item_ptr->pref_mode.nam = (byte) i;
    cmnv_read_wait_extn( NV_PREF_MODE_I,
                         cmnv_item_ptr,
                         ph_ptr->hybr_2_stack_info.nv_context );
    ph_ptr->prst_hybr_2_stack_info[i].mode_pref = cmph_map_mode_pref_nv2cm( cmnv_item_ptr->pref_mode.mode );

    /* This is for GW only, not multimode
    */
    #if ( defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) )
    /*
    ** Single mode WCDMA or Single mode TDSCDMA.
    */
    if ( ph_ptr->prst_hybr_2_stack_info[i].mode_pref != CM_MODE_PREF_WCDMA_ONLY )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_2_stack_info[i].mode_pref     = CM_MODE_PREF_WCDMA_ONLY;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_2_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I,
                               ph_ptr->hybr_2_stack_info.nv_context,
                               cmnv_item_ptr);
      #endif
    } /* if ! CM_MODE_PREF_WCDMA_ONLY */
    #elif ( defined(FEATURE_TDSCDMA) && !defined(FEATURE_GSM) )
    if ( ph_ptr->prst_hybr_2_stack_info[i].mode_pref != CM_MODE_PREF_TDS_ONLY )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_2_stack_info[i].mode_pref     = CM_MODE_PREF_TDS_ONLY;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_2_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I,
                               ph_ptr->hybr_2_stack_info.nv_context,
                               cmnv_item_ptr);
      #endif
    } /* if ! CM_MODE_PREF_TDS_ONLY */
    #endif /* ( FEATURE_WCDMA && !FEATURE_GSM ) || ( FEATURE_TDSCDMA && !FEATURE_GSM ) */

    #if ( defined(FEATURE_GSM) && !defined(FEATURE_WCDMA) && !defined(FEATURE_TDSCDMA) )
    /*
    ** Single mode GSM.
    **/
    if ( ph_ptr->prst_hybr_2_stack_info[i].mode_pref != CM_MODE_PREF_GSM_ONLY )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_2_stack_info[i].mode_pref     = CM_MODE_PREF_GSM_ONLY;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_2_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I, cmnv_item_ptr,
                           ph_ptr->hybr_2_stack_info.nv_context);
      #endif
    } /* if ! CM_MODE_PREF_GSM_ONLY */
    #endif /* FEATURE_GSM, FEATURE_WCDMA, FEATURE_TDSCDMA */

    #if ( defined(FEATURE_GSM) && defined(FEATURE_WCDMA)||defined(FEATURE_TDSCDMA)||defined(FEATURE_CM_LTE) )
    /*
    ** Dual mode GSM/WCDMA.
    ** G, W, GW are the only allowed values.
    **/
    if ( !cmcall_misc_is_mode_pref(ph_ptr->prst_hybr_2_stack_info[i].mode_pref,
     CM_MODE_PREF_TDS_GSM_WCDMA_LTE)
       )
    {
      /* Default the mode preference and write it back to NV.
      */
      #if defined(FEATURE_CM_LTE)
      ph_ptr->prst_hybr_2_stack_info[i].mode_pref     = CM_MODE_PREF_TDS_GSM_WCDMA_LTE;
    #elif defined(FEATURE_TDSCDMA)
    ph_ptr->prst_hybr_2_stack_info[i].mode_pref     = CM_MODE_PREF_TDS_GSM;
    #else
    ph_ptr->prst_hybr_2_stack_info[i].mode_pref     = CM_MODE_PREF_GSM_WCDMA_ONLY;
    #endif
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_2_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I,
                           cmnv_item_ptr,
                           ph_ptr->hybr_2_stack_info.nv_context);
      #endif
    }
    #elif ( defined(FEATURE_GSM) && defined(FEATURE_TDSCDMA) )
    /*
    ** Dual mode GSM/TDSCDMA.
    ** G, T, GT are the only allowed values.
    **/
    if ( ph_ptr->prst_hybr_2_stack_info[i].mode_pref != CM_MODE_PREF_GSM_ONLY &&
         ph_ptr->prst_hybr_2_stack_info[i].mode_pref != CM_MODE_PREF_TDS_ONLY &&
         ph_ptr->prst_hybr_2_stack_info[i].mode_pref != CM_MODE_PREF_TDS_GSM &&
         ph_ptr->prst_hybr_2_stack_info[i].mode_pref != CM_MODE_PREF_GSM_WCDMA_ONLY &&
         ph_ptr->prst_hybr_2_stack_info[i].mode_pref != CM_MODE_PREF_WCDMA_ONLY
       )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_2_stack_info[i].mode_pref     = CM_MODE_PREF_TDS_GSM;
      cmnv_item_ptr->pref_mode.mode = cmph_map_mode_pref_cm2nv( ph_ptr->prst_hybr_2_stack_info[i].mode_pref );
      cmnv_item_ptr->pref_mode.nam  = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I,
                           cmnv_item_ptr,
                           ph_ptr->hybr_2_stack_info.nv_context);
      #endif
    }
    /*lint -restore */
    #endif /* FEATURE_GSM, FEATURE_WCDMA */
  }

  ph_ptr->hybr_2_stack_info.pref_info.mode_pref = CMPH_PRST_HYBR_2_PREF(ph_ptr).mode_pref;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ph_ptr->hybr_2_stack_info.pref_info.hybr_pref = CM_HYBR_PREF_OFF;
  ph_ptr->prst_hybr_2_stack_info[ph_ptr->curr_nam].hybr_pref =
                                ph_ptr->hybr_2_stack_info.pref_info.hybr_pref;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cm_nv_band_pref_u_type  temp;
    uint64                  band_pref_32_63;
    uint64                  temp1;

    /* Read the Band Preference from NV for subscription 2
    */
    cmnv_item_ptr->band_pref.nam = (byte) i;
    cmnv_read_wait_extn( NV_BAND_PREF_I,
                         cmnv_item_ptr,
                         ph_ptr->hybr_2_stack_info.nv_context);
    temp.nv_band_pref[0] = (uint16)cmnv_item_ptr->band_pref.band;

    cmnv_read_wait_extn( NV_BAND_PREF_16_31_I,
                         cmnv_item_ptr,
                         ph_ptr->hybr_2_stack_info.nv_context);
    temp.nv_band_pref[1] = (uint16)cmnv_item_ptr->band_pref.band;

    cmnv_read_wait_extn( NV_BAND_PREF_32_63_I,
                         cmnv_item_ptr,
                         ph_ptr->hybr_2_stack_info.nv_context);
    band_pref_32_63 = (uint32)cmnv_item_ptr->band_pref_32_63.band;

    /* Copy Bits 0-31 in temporary variable.
    */
    temp1 = temp.dummy;

    /* Move bits 32-63 to its desired position and insert bits 0-31.
    */
    ph_ptr->prst_hybr_2_stack_info[i].band_pref =  temp1 | (uint64)(band_pref_32_63 << 32);

    /* If the band pref is not a valid value, write a valid value into NV (ANY) */
    if (ph_ptr->prst_hybr_2_stack_info[i].band_pref >= CM_BAND_PREF_MAX)
    {
       ph_ptr->prst_hybr_2_stack_info[i].band_pref = CM_BAND_PREF_ANY;
       cmnv_item_ptr->band_pref.nam  = (byte) i;
       cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)CM_BAND_PREF_ANY;
                                      //NV_BAND_PREF_ANY;
       #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
       cmnv_write_wait_extn(NV_BAND_PREF_I,
                            cmnv_item_ptr,
                            ph_ptr->hybr_2_stack_info.nv_context);
       #endif

       cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)(CM_BAND_PREF_ANY >> 16);
                                      //((word)NV_BAND_PREF_ANY & 0x7FFF);
       #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
       cmnv_write_wait_extn(NV_BAND_PREF_16_31_I,
                            cmnv_item_ptr,
                            ph_ptr->hybr_2_stack_info.nv_context);
       #endif

       cmnv_item_ptr->band_pref_32_63.band = (uint32)(CM_BAND_PREF_ANY >> 32);
                                      //((word)NV_BAND_PREF_ANY & 0x3FFF);
       #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
       cmnv_write_wait_extn(NV_BAND_PREF_32_63_I,
                            cmnv_item_ptr,
                            ph_ptr->hybr_2_stack_info.nv_context);
       #endif
    }

    /* Read the persistent TDS band preference. */

    read_persistent_band_pref( CMEFS_ID_TDS_BANDPREF,
                               &(ph_ptr->prst_hybr_2_stack_info[i].tds_band_pref),
                               ph_ptr->hybr_2_stack_info.asubs_id);

    #ifdef FEATURE_CM_LTE
    {
      cm_band_pref_e_type lte_bands_1_64 = CM_BAND_PREF_NONE;
      #if(LTE_BAND_NUM == 256)
      sys_lte_band_mask_e_type lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
      read_persistent_lte_extn_band_pref( &lte_band_pref, ph_ptr->hybr_2_stack_info.asubs_id);
      #endif
      read_persistent_band_pref(CMEFS_ID_LTE_BANDPREF,
                              &lte_bands_1_64,
                              ph_ptr->hybr_2_stack_info.asubs_id);

      #if(LTE_BAND_NUM == 256)
      lte_band_pref.bits_1_64 = lte_bands_1_64;
      ph_ptr->prst_hybr_2_stack_info[i].lte_band_pref = lte_band_pref;
      #else
      ph_ptr->prst_hybr_2_stack_info[i].lte_band_pref = lte_bands_1_64;
      #endif
    }
    #else
    ph_ptr->prst_hybr_2_stack_info[i].lte_band_pref = SYS_LTE_BAND_MASK_CONST_NONE;
    #endif

    /* If target or PRL oes not support the specified mode and band preference
    ** combination, set the mode and band preference to their default
    ** values.
    */
    if( ! sd_misc_is_supp_pref(
          cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->prst_hybr_2_stack_info[i].mode_pref),
          cmph_map_cm_band_pref_to_sd_band_pref(ph_ptr->prst_hybr_2_stack_info[i].band_pref))

        &&

        ! sd_misc_is_supp_pref_tds(
           cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->prst_hybr_2_stack_info[i].mode_pref),
           cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(ph_ptr->prst_hybr_2_stack_info[i].tds_band_pref))
        #ifdef FEATURE_CM_LTE
        &&

        ! sd_misc_is_supp_pref_lte(
           cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->prst_hybr_2_stack_info[i].mode_pref),
           ph_ptr->prst_hybr_2_stack_info[i].lte_band_pref)
        #endif
      )
    {
      /* Default the mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_2_stack_info[i].mode_pref     = CM_MODE_PREF_AUTOMATIC;
      cmnv_item_ptr->pref_mode.nam  = (byte) i;
      cmnv_item_ptr->pref_mode.mode = NV_MODE_AUTOMATIC;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PREF_MODE_I, cmnv_item_ptr,
                           ph_ptr->hybr_2_stack_info.nv_context);
      #endif

      /* Default the band preference and write it back to NV.
      */
      ph_ptr->prst_hybr_2_stack_info[i].band_pref     = CM_BAND_PREF_ANY;
      cmnv_item_ptr->band_pref.nam  = (byte) i;
      cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)CM_BAND_PREF_ANY;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_BAND_PREF_I, cmnv_item_ptr,
                           ph_ptr->hybr_2_stack_info.nv_context);
      #endif
      cmnv_item_ptr->band_pref.band = (nv_band_pref_enum_type)(CM_BAND_PREF_ANY >> 16 );
      cmnv_write_wait_extn(NV_BAND_PREF_16_31_I, cmnv_item_ptr,
                           ph_ptr->hybr_2_stack_info.nv_context );
      cmnv_item_ptr->band_pref_32_63.band = (uint32)(CM_BAND_PREF_ANY >> 32 );
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_BAND_PREF_32_63_I, cmnv_item_ptr,
                           ph_ptr->hybr_2_stack_info.nv_context);
      #endif
    }
    efs_read_size = sizeof(cm_user_net_sel_mode_pref_e_type);
    if(cmefs_get ( cmefs_get_efs_id_for_curr_nam ((cm_nam_e_type)i),
                          (byte*)&user_net_sel_mode_pref,
                          efs_read_size,
                          cmph_map_cm_ss_to_subs(CM_SS_HYBR_2)))
    {
      ph_ptr->prst_hybr_2_stack_info[i].user_net_sel_mode = user_net_sel_mode_pref;
    }
  }
  ph_ptr->hybr_2_stack_info.pref_info.user_net_sel_mode =
    CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( cmph_map_cm_ss_to_subs(CM_SS_HYBR_2), ph_ptr );
  if ((CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( cmph_map_cm_ss_to_subs(CM_SS_HYBR_2), ph_ptr )
                                      == CM_USER_NETWORK_SEL_MODE_PREF_AUTOMATIC)
      ||
      (CMPH_PRST_USER_NETWORK_SEL_MODE_PREF(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2), ph_ptr )
                                      == CM_USER_NETWORK_SEL_MODE_PREF_MANUAL))
  {
    ph_ptr->hybr_2_stack_info.pref_info.network_sel_mode_pref =
      cmph_map_user_to_cm_net_sel_mode_pref (
        CMPH_PRST_USER_NETWORK_SEL_MODE_PREF( cmph_map_cm_ss_to_subs(CM_SS_HYBR_2), ph_ptr ));
    CM_MSG_HIGH_1 ("phone's hybr2 stack net_sel_mode updated with user_net_sel_mode - %d",
                  ph_ptr->hybr_2_stack_info.pref_info.network_sel_mode_pref);
  }

  ph_ptr->hybr_2_stack_info.pref_info.band_pref = CMPH_PRST_HYBR_2_BAND_PREF(ph_ptr);
  ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref = CMPH_PRST_HYBR_2_TDS_BAND_PREF(ph_ptr);
  ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref = CMPH_PRST_HYBR_2_LTE_BAND_PREF(ph_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_read_wait_extn(NV_PRL_PREF_I, cmnv_item_ptr,
                            ph_ptr->hybr_2_stack_info.nv_context);
    ph_ptr->prst_hybr_2_stack_info[i].prl_pref =
                            (cm_prl_pref_e_type) (cmnv_item_ptr->prl_pref.prl);

    /* If the prl preference is out of bound, set the prl preference to its
    ** deflate value.
    */

     if( ph_ptr->prst_hybr_2_stack_info[i].prl_pref != CM_PRL_PREF_AVAIL_BC0_A &&
         ph_ptr->prst_hybr_2_stack_info[i].prl_pref != CM_PRL_PREF_AVAIL_BC0_B &&
         ph_ptr->prst_hybr_2_stack_info[i].prl_pref != CM_PRL_PREF_ANY )
    {
      ph_ptr->prst_hybr_2_stack_info[i].prl_pref     = CM_PRL_PREF_ANY;
      cmnv_item_ptr->prl_pref.nam  = (byte) i;
      cmnv_item_ptr->prl_pref.prl =  (uint32) CM_PRL_PREF_ANY;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_PRL_PREF_I, cmnv_item_ptr,
                           ph_ptr->hybr_2_stack_info.nv_context);
      #endif
    }
  }

  ph_ptr->hybr_2_stack_info.pref_info.prl_pref = CMPH_PRST_HYBR_2_PRL_PREF(ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_read_wait_extn(NV_ROAM_PREF_I, cmnv_item_ptr,
                            ph_ptr->hybr_2_stack_info.nv_context);
    ph_ptr->prst_hybr_2_stack_info[i].roam_pref =
                         (cm_roam_pref_e_type) (cmnv_item_ptr->roam_pref.roam);

    /* If the roam preference is out of bound, set the roam preference to its
    ** deflate value.
    */
    if( ! BETWEEN(ph_ptr->prst_hybr_2_stack_info[i].roam_pref, CM_ROAM_PREF_NONE,
                  CM_ROAM_PREF_NO_CHANGE) )
    {
      ph_ptr->prst_hybr_2_stack_info[i].roam_pref     = CM_ROAM_PREF_ANY;
      cmnv_item_ptr->roam_pref.nam  = (byte) i;
      cmnv_item_ptr->roam_pref.roam = (nv_roam_pref_enum_type)
                                      SD_SS_ROAM_PREF_ANY;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn(NV_ROAM_PREF_I, cmnv_item_ptr,
                           ph_ptr->hybr_2_stack_info.nv_context);
      #endif
    }
  }

  ph_ptr->hybr_2_stack_info.pref_info.roam_pref = CMPH_PRST_HYBR_2_ROAM_PREF(ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_item_ptr->acq_order_pref.nam = (byte) i;
    cmnv_read_wait_extn(NV_ACQ_ORDER_PREF_I, cmnv_item_ptr,
                        ph_ptr->hybr_2_stack_info.nv_context);

    ph_ptr->prst_hybr_2_stack_info[i].acq_order_pref =
       acq_order_pref_nv2cm( cmnv_item_ptr->acq_order_pref.acq_order );

    if( ( ph_ptr->prst_hybr_2_stack_info[i].acq_order_pref != CM_GW_ACQ_ORDER_PREF_AUTOMATIC ) &&
      ( ph_ptr->prst_hybr_2_stack_info[i].acq_order_pref != CM_GW_ACQ_ORDER_PREF_WCDMA_GSM ) &&
      ( ph_ptr->prst_hybr_2_stack_info[i].acq_order_pref != CM_GW_ACQ_ORDER_PREF_GSM_WCDMA )    )
    {
      /*
      ** Default the acquistion order preference and write it back to NV.
      */
      #ifdef FEATURE_WCDMA
      ph_ptr->prst_hybr_2_stack_info[i].acq_order_pref          = CM_GW_ACQ_ORDER_PREF_WCDMA_GSM;
      #else
      ph_ptr->prst_hybr_2_stack_info[i].acq_order_pref          = CM_GW_ACQ_ORDER_PREF_GSM_WCDMA;
      #endif  /* FEATURE_WCDMA */
      cmnv_item_ptr->acq_order_pref.acq_order =
      acq_order_pref_cm2nv( ph_ptr->prst_hybr_2_stack_info[i].acq_order_pref );
      cmnv_item_ptr->acq_order_pref.nam       = (byte) i;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn( NV_ACQ_ORDER_PREF_I, cmnv_item_ptr,
                            ph_ptr->hybr_2_stack_info.nv_context);
      #endif
    } /* if not valid acquisition order */
  }

  ph_ptr->hybr_2_stack_info.pref_info.acq_order_pref = CMPH_PRST_HYBR_2_ACQ_ORDER_PREF(ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_item_ptr->net_sel_mode_pref.nam = (byte) i;
    cmnv_read_wait_extn(NV_NET_SEL_MODE_PREF_I, cmnv_item_ptr,
                        ph_ptr->hybr_2_stack_info.nv_context);

    ph_ptr->prst_hybr_2_stack_info[i].network_sel_mode_pref =
     cmph_map_net_sel_mode_pref_nv2cm( cmnv_item_ptr->net_sel_mode_pref.net_sel_mode );

    if ( ( ph_ptr->prst_hybr_2_stack_info[i].network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_AUTOMATIC   &&
           ph_ptr->prst_hybr_2_stack_info[i].network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_MANUAL      &&
           ph_ptr->prst_hybr_2_stack_info[i].network_sel_mode_pref != CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV ) ||
         ( !cmph_is_valid_network_selection_mode_pref( ph_ptr->prst_hybr_2_stack_info[i].mode_pref,
                                                       ph_ptr->prst_hybr_2_stack_info[i].network_sel_mode_pref
                                                     )
         )
       )
    {
      /*
      ** Default the network selection mode preference and write it back to NV.
      */
      ph_ptr->prst_hybr_2_stack_info[i].network_sel_mode_pref         = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
      cmnv_item_ptr->net_sel_mode_pref.net_sel_mode =
        cmph_map_net_sel_mode_pref_cm2nv( ph_ptr->prst_hybr_2_stack_info[i].network_sel_mode_pref );
      cmnv_item_ptr->net_sel_mode_pref.nam          = (byte) i;

      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn( NV_NET_SEL_MODE_PREF_I, cmnv_item_ptr,
                            ph_ptr->hybr_2_stack_info.nv_context);
      #endif
    } /* if not valid network selection mode */
  }

  ph_ptr->hybr_2_stack_info.pref_info.network_sel_mode_pref =
                    CMPH_PRST_HYBR_2_NETWORK_SEL_MODE_PREF( ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for( i=0; i < NV_MAX_NAMS; i++ )
  {
    cmnv_item_ptr->service_domain_pref.nam = (byte) i;
    cmnv_read_wait_extn(NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
                        ph_ptr->hybr_2_stack_info.nv_context);

    ph_ptr->prst_hybr_2_stack_info[i].srv_domain_pref =
     cmph_map_srv_domain_pref_nv2cm( cmnv_item_ptr->service_domain_pref.srv_domain );

    if (( ph_ptr->prst_hybr_2_stack_info[i].srv_domain_pref != CM_SRV_DOMAIN_PREF_CS_ONLY ) &&
      ( ph_ptr->prst_hybr_2_stack_info[i].srv_domain_pref != CM_SRV_DOMAIN_PREF_PS_ONLY ) &&
      ( ph_ptr->prst_hybr_2_stack_info[i].srv_domain_pref != CM_SRV_DOMAIN_PREF_CS_PS   )    )
    {
      /*
      ** Default the service domain preference and write it back to NV.
      */
      ph_ptr->prst_hybr_2_stack_info[i].srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
      cmnv_item_ptr->service_domain_pref.srv_domain     =
      cmph_map_srv_domain_pref_cm2nv( ph_ptr->prst_hybr_2_stack_info[i].srv_domain_pref );
      cmnv_item_ptr->service_domain_pref.nam            = (byte) i;
      #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
      cmnv_write_wait_extn( NV_SERVICE_DOMAIN_PREF_I, cmnv_item_ptr,
                            ph_ptr->hybr_2_stack_info.nv_context);
      #endif
    } /* if not valid service domain */
  }

  ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref =
                          CMPH_PRST_HYBR_2_SRV_DOMAIN_PREF( ph_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  rex_def_timer(&ph_ptr->hybr_2_stack_info.phone_charge.acm_timer, get_cm_tcb(), CM_ACM_TIMER_SIG);
  rex_def_timer(&ph_ptr->hybr_2_stack_info.phone_charge.ccm_timer, get_cm_tcb(), CM_CCM_TIMER_SIG);

  ph_ptr->hybr_2_stack_info.user_pref_networks.length = 0;
  ph_ptr->hybr_2_stack_info.plmn_list.plmn_list.length = 0;
 
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Read preferences for packet switched data calls on subs2
  */
  cmnv_read_wait_extn( NV_PS_DATA_ORIG_PREF_I, cmnv_item_ptr,
                       ph_ptr->hybr_2_stack_info.nv_context);
  ph_ptr->hybr_2_stack_info.ps_data_orig_pref = (cm_ps_data_orig_prefs_e_type)
                                              cmnv_item_ptr->ps_data_orig_pref;

  if( ! BETWEEN(ph_ptr->hybr_2_stack_info.ps_data_orig_pref,
                CM_PS_DATA_ORIG_PREF_NONE,
                CM_PS_DATA_ORIG_PREF_MAX)
    )
  {
    /*
    ** Default the ps data orig preference and write it back to NV.
    */
    ph_ptr->hybr_2_stack_info.ps_data_orig_pref = CM_PS_DATA_ORIG_PREF_ANY;
    cmnv_item_ptr->ps_data_orig_pref = NV_PS_DATA_ORIG_PREF_ANY;
    #ifndef FEATURE_DISABLE_CM_INIT_NV_WRITE
    cmnv_write_wait_extn (NV_PS_DATA_ORIG_PREF_I, cmnv_item_ptr,
                          ph_ptr->hybr_2_stack_info.nv_context);
    #endif
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmnv_read_wait_extn(NV_DISABLE_CM_CALL_TYPE_I, cmnv_item_ptr,
                      ph_ptr->hybr_2_stack_info.nv_context);

  ph_ptr->hybr_2_stack_info.disable_call_type_mask = (cm_disable_call_type)
                                          cmnv_item_ptr->disable_cm_call_type;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmph_deactivate_ps_service_req_timer(CM_SS_HYBR_2);
  cmph_set_ps_sig_down_wait_time(CMPH_GW_PKT_WAIT_TIME_NONE, CM_SS_HYBR_2);
  ph_ptr->hybr_2_stack_info.is_ps_srv_req_sent = FALSE;
  ph_ptr->hybr_2_stack_info.is_sys_sel_pref_rsp_pending = FALSE;

  }
  else
  {
    CM_MSG_HIGH_0("mcfgrefresh:no hybr2 init");
  }

  #endif /* FEATURE_MMODE_DUAL_SIM */
} 
/*===========================================================================

FUNCTION cmph_is_sub2_map_to_hybr3

DESCRIPTION
  Check the value of is_sub2_map_to_hybr3.

DEPENDENCIES
  none

RETURN VALUE
  Boolean

SIDE EFFECTS
  none

===========================================================================*/
boolean  cmph_is_sub2_map_to_hybr3(void)
{
  return cmph_ptr()->is_sub2_map_to_hybr3;
}

/*===========================================================================

FUNCTION cmph_set_is_sub2_map_to_hybr3

DESCRIPTION
  Set is_sub2_map_to_hybr3.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmph_set_is_sub2_map_to_hybr3(void)
{
  cmph_s_type *ph_ptr           = cmph_ptr();

  /* Set it to FALSE for single sim config */
  if (cmpmprx_get_num_of_sims() == 1)
  {
    ph_ptr->is_sub2_map_to_hybr3 = FALSE;
  }

  /* Set it to TRUE for SXLTE+G */
  else if (ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SVLTE ||
         ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SRLTE ||
         ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1]  == SYS_SUBS_FEATURE_MODE_SGLTE)
  {
    ph_ptr->is_sub2_map_to_hybr3 = TRUE;
  }
  else
  {
    ph_ptr->is_sub2_map_to_hybr3 = FALSE;
  }
}

/*===========================================================================

FUNCTION  cmph_no_hybr2

DESCRIPTION
 Check if the hybr2 is not required for the configuration.

DEPENDENCIES
 cmph_init has been called.

RETURN VALUE
  TRUE if hybr2 is not needed.
  FALSE otherwise.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmph_no_hybr2 (void)
{
  if(cmph_is_subs_feature_mode_normal(SYS_MODEM_AS_ID_1) &&
    cmph_is_sub2_map_to_hybr3())
  {
    return TRUE;
  }
  else if (!cmph_is_msim() && 
            cmph_is_subs_feature_mode_normal(SYS_MODEM_AS_ID_1)
  )
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

/*===========================================================================

FUNCTION  cmph_get_1x_as_id

DESCRIPTION
  Get the asubs_id for the 1x stack.

DEPENDENCIES
  None.

RETURN VALUE
  sys_modem_as_id_e_type.

SIDE EFFECTS
  none

===========================================================================*/
sys_modem_as_id_e_type  cmph_get_1x_as_id (void)
{
  return SYS_MODEM_AS_ID_1;
}

/*===========================================================================

FUNCTION cmph_get_sub_in_emg_cb

DESCRIPTION
  Get the sub which is in emergency cb mode.

DEPENDENCIES
  None.

RETURN VALUE
  sys_modem_as_id_e_type.

SIDE EFFECTS
  None.

===========================================================================*/
sys_modem_as_id_e_type  cmph_get_sub_in_emg_cb(void)
{
  uint8 i = 0;

  if(!cmph_is_in_emergency_cb())
  {
    return SYS_MODEM_AS_ID_NONE;
  }

  if (!cmph_is_msim())
  {
    return SYS_MODEM_AS_ID_1;
  }

  for (i = 0; i < CM_SS_MAX; i++)
  {
    cm_orig_q_s_type *emg_cb_ptr 
      = cmtask_orig_para_search_act_type((cm_ss_e_type)i, CM_ACT_TYPE_EMERG_CB_MODE);
    
    if (emg_cb_ptr != NULL)
    {
      return cmph_map_cm_ss_to_subs((cm_ss_e_type)i); 
    }
  }
  /* in WLAN ECBM there wont be PH object in queue */
  /*CM_ERR_0("in emcb mode but as_id is invalid"); */
  return SYS_MODEM_AS_ID_1;
}

/*===========================================================================

FUNCTION cmph_is_lte_capable_on_any_sub

DESCRIPTION
  Check if the LTE is allowed on any sub per max allowed capability.

DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
boolean cmph_is_lte_capable_on_any_sub(void)
{
  size_t i = 0;
  for (i = 0; i< cmpmprx_get_num_of_sims(); i ++)
  {
    if (cmph_is_lte_capable_on_sub((sys_modem_as_id_e_type)i))
    {
      return TRUE;
    }
  }
  return FALSE;
}

/*===========================================================================

FUNCTION cmph_is_gsm_only_sub

DESCRIPTION
  Check if the sub is GSM only capable.

DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
boolean cmph_is_gsm_only_sub(
  sys_modem_as_id_e_type  as_id
)
{
  return (cmmsc_get_curr_msc_max_cap(as_id) == SYS_SYS_MODE_MASK_GSM);
}

/*===========================================================================

FUNCTION cmph_dds_update_srv_domain
  
DESCRIPTION
  Update phone pointer srv domain based on asubs_id

DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_dds_update_srv_domain(
  sys_modem_as_id_e_type        asubs_id, 
  cm_srv_domain_pref_e_type     new_srv_domain
)
{
  cmph_s_type *ph_ptr;
  ph_ptr      = cmph_ptr();

  if(asubs_id == ph_ptr->main_stack_info.asubs_id)
  {
    ph_ptr->main_stack_info.pref_info.srv_domain_pref = new_srv_domain;
  }
  else if(asubs_id == ph_ptr->hybr_2_stack_info.asubs_id)
  {
    ph_ptr->hybr_2_stack_info.pref_info.srv_domain_pref
                                          = new_srv_domain;
  }
  #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
  else if(asubs_id == ph_ptr->hybr_3_stack_info.asubs_id)
  {
    ph_ptr->hybr_3_stack_info.pref_info.srv_domain_pref
                                          = new_srv_domain;
  }
  #endif
  return;
}

/*===========================================================================

FUNCTION cmph_dds_update_cmd_mode_pref
  
DESCRIPTION
  Update phone pointer mode pref based on asubs_id

DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_dds_update_cmd_mode_pref(
  sys_modem_as_id_e_type        asubs_id, 
  cm_mode_pref_e_type           new_mode_pref
)
{
  cmph_s_type *ph_ptr;
  ph_ptr      = cmph_ptr();

  if(asubs_id == ph_ptr->main_stack_info.asubs_id)
  {
    ph_ptr->main_stack_info.pref_info.mode_pref = new_mode_pref;
  }
  else if(asubs_id == ph_ptr->hybr_2_stack_info.asubs_id)
  {
    ph_ptr->hybr_2_stack_info.pref_info.mode_pref = new_mode_pref;
  }
  #if defined(FEATURE_MMODE_SXLTE_G) || defined (FEATURE_MMODE_TRIPLE_SIM)
  else if(asubs_id == ph_ptr->hybr_3_stack_info.asubs_id)
  {
    ph_ptr->hybr_3_stack_info.pref_info.mode_pref = new_mode_pref;
  }
  #endif
  return;
}

/*===========================================================================

FUNCTION cmph_get_sub_config_ptr

DESCRIPTION
  Helper function to get ph_ptr->cmph_sub_info[] for a given sub_id.
  Checks that sub_id is in range of ph_ptr->cmph_sub_info[] array.

DEPENDENCIES
  none

RETURN VALUE
  cmph_sub_config_s_type* cmph_sub_info

SIDE EFFECTS
  none

===========================================================================*/
cmph_sub_config_s_type* cmph_get_sub_config_ptr(
  sys_modem_as_id_e_type sub_id
)
{
  cmph_s_type   *ph_ptr = cmph_ptr();

  if(cmph_is_ssim())
  {
    sub_id = SYS_MODEM_AS_ID_1;
  }
  else if(sub_id <= SYS_MODEM_AS_ID_NONE || sub_id >= MAX_SIMS)
  {
    CM_MSG_HIGH_1("cmph_is_allow_sms_in_ecbm_enabled: invalid sub_id %d", sub_id);
    sub_id = SYS_MODEM_AS_ID_1;
  }

  return &(ph_ptr->sub_config[sub_id]);
}

/*===========================================================================

FUNCTION cmph_get_ph_sub_config_size
  
DESCRIPTION
  Get the effective size of phone sub-level configuration.

DEPENDENCIES

RETURN VALUE
  uint8

SIDE EFFECTS
  none

===========================================================================*/
uint8 cmph_get_ph_sub_config_size (void)
{
  return (MIN(ARR_SIZE(cmph_ptr()->sub_config), cmpm_ptr()->device_mode.nSims));
}

/*===========================================================================

FUNCTION cmph_enter_emergency_cb_wlan

DESCRIPTION

  Enter emergency callback mode for WLAN  and notify clients

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void cmph_enter_emergency_cb_wlan()
{
  cmph_s_type  * ph_ptr = cmph_ptr();
      
  /* Store the RAT on which CM enters callback mode
  */
  ph_ptr->ecbm_rat = SYS_SYS_MODE_WLAN;
  ph_ptr->ph_state = CM_PH_STATE_EMERG_CB;
  ph_ptr->ecbm_exit_reason = CM_ECBM_EXIT_REASON_NORMAL;
  cmph_event( ph_ptr, CM_PH_EVENT_SYS_SEL_PREF );
  cmlog_enter_emergency_cb();
}


/*===========================================================================

FUNCTION cmph_set_t_wwan_911_req

DESCRIPTION
  UPdates value of t wwan 911 timer.
  New values will apply for the calls originated after setting the timer.

DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_set_t_wwan_911_req( uint16 t_wwan_911_val,
  sys_modem_as_id_e_type asubs_id)
{
  
  uint16 write_size;
  mcfg_fs_status_e_type status;
  cmph_custom_emerg_call_info_s_type  e911_info;
  cmph_sub_config_s_type *ph_sub_config_ptr = cmph_get_sub_config_ptr(asubs_id);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ph_sub_config_ptr != NULL );

  /* if t_ssac_val is not set to anything between 0 and 1024 
  QMI itself would reject the command so CM does not expect this input at all */
  
  if(t_wwan_911_val > 1024)
  {
    t_wwan_911_val = 40;
  }
  memset(&e911_info, 0 , sizeof(cmph_custom_emerg_call_info_s_type));
  /* fill the structure to be written in EFS from current volte pointer */
  {
    e911_info.is_ecbm_required = ph_sub_config_ptr->is_ecbm_required;
    e911_info.is_alternate_redial_algorithm = ph_sub_config_ptr->is_alternate_redial_algorithm;
    e911_info.hold_concurrent_voicecall_during_emergency = ph_sub_config_ptr->hold_concurrent_voicecall_during_emergency;
    e911_info.is_wlan_e911_call_supp = ph_sub_config_ptr->is_wlan_e911_call_supp;
    e911_info.twwan_timer = t_wwan_911_val;
  }
  write_size = sizeof(cmph_custom_emerg_call_info_s_type);
  /* do not create the file if it was not already existing */  
  status = mcfg_fs_write( "/nv/item_files/modem/mmode/custom_emerg_info",
                (void*)&e911_info,
                (int)write_size,
                MCFG_FS_O_RDWR, 
                MCFG_FS_ALLPERMS, 
                MCFG_FS_TYPE_EFS, 
                MCFG_FS_SUBID_0 );
  
  if ( status != MCFG_FS_STATUS_OK )
  {
    CM_ERR_2( "t_wwan_911: write for e911 custom info fail status=%d, errno %d", status, mcfg_fs_errno(MCFG_FS_TYPE_EFS));
  }
  else
  {
    CM_MSG_HIGH_1("t_wwan_911: timer updated with value %d", t_wwan_911_val);
    ph_sub_config_ptr->twwan_timer = t_wwan_911_val;
  }
  return;
}

/*===========================================================================

FUNCTION cmph_send_get_t_wwan_911_rsp

DESCRIPTION
  Sends the current value of the t_wwan_911 timer to clients.

DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmph_send_get_t_wwan_911_rsp( uint8 inst_id )
{
  cm_mm_get_t_wwan_911_rsp_s_type *t_wwan_911_rsp;

  t_wwan_911_rsp = (cm_mm_get_t_wwan_911_rsp_s_type *)cm_mem_malloc(
  sizeof(cm_mm_get_t_wwan_911_rsp_s_type));

  if(t_wwan_911_rsp == NULL)
  { 
    CM_ERR_0("Heap exhausted, cm_mem_malloc() returned NULL");
  }
  t_wwan_911_rsp->t_wwan_911_val = cmph_get_sub_config_ptr(INST_ID_TO_SYS_AS_ID(inst_id))->twwan_timer;
  t_wwan_911_rsp->msg_hdr.inst_id = inst_id;
  (void) cm_msgr_send( MM_CM_GET_T_WWAN_911_RSP, MSGR_MM_CM,
                     (msgr_hdr_s *)t_wwan_911_rsp, sizeof(cm_mm_get_t_wwan_911_rsp_s_type) );
  CM_MSG_HIGH_1("t_wwan_911: send resp with timer value %d",t_wwan_911_rsp->t_wwan_911_val);
  cm_mem_free(t_wwan_911_rsp);  
  return;
}

/*==========================================================================

FUNCTION cmph_is_sxlte_hybr_stack_allowed

DESCRIPTION
  Function returns TRUE if there can be second stack for SXLTE/CH

RETURN VALUE
  TRUE/FALSE

DEPENDENCIES
  None
===========================================================================*/
boolean cmph_is_sxlte_second_stack_allowed_on_mode(sys_modem_as_id_e_type as_id, cm_mode_pref_e_type mode)
{
  cmph_s_type*               ph_ptr = cmph_ptr();
  cm_mode_pref_e_type  cm_mode_pref = CMPH_SS_MODE_PREF(as_id,ph_ptr);

  typedef enum cm_ph_no_hybr_cause {
    CM_PH_NO_HYBR_CAUSE_NONE     = 0,
    CM_PH_NO_HYBR_CAUSE_NON_DDS,
    CM_PH_NO_HYBR_CAUSE_NO_LH_IN_PHONE_PREF,
    CM_PH_NO_HYBR_CAUSE_NO_LH_IN_PM_RAT_CAP,
    CM_PH_NO_HYBR_CAUSE_HYBR_PREF,
    CM_PH_NO_HYBR_CAUSE_MAX
  }cm_ph_no_hybr_cause_type;

  cm_ph_no_hybr_cause_type cause = CM_PH_NO_HYBR_CAUSE_NONE;

  // 1. as_id is DDS but mode_pref does not supports CH
  if (!cmcall_misc_is_mode_pref(cm_mode_pref, mode))
  {
    cause = CM_PH_NO_HYBR_CAUSE_NO_LH_IN_PHONE_PREF;
  }
  // 2. PM cap does not supports CH in RAT cap
  else if ((cmpmprx_read_mode_capability(as_id) & cmph_map_cm_mode_pref_to_sd_mode_pref(mode)) != cmph_map_cm_mode_pref_to_sd_mode_pref(mode))
  {
    cause = CM_PH_NO_HYBR_CAUSE_NO_LH_IN_PM_RAT_CAP;
  }
  // 3. Not SXLTE and Hybr pref is off
  else if (!(cmph_is_subs_feature_mode_1x_sxlte(as_id) || cmph_is_subs_feature_mode_sglte(as_id)) && 
    CMPH_SS_HYBR_PREF(as_id, ph_ptr) == CM_HYBR_PREF_OFF)
  {
    cause = CM_PH_NO_HYBR_CAUSE_HYBR_PREF;
  }

  if (cause != CM_PH_NO_HYBR_CAUSE_NONE)
  {
    if (as_id == SYS_MODEM_AS_ID_1)
    {
      CM_MSG_HIGH_3("No Second Stack for as_id %d, mode %d as cause = %d ", as_id, mode, cause );
      CM_MSG_HIGH_3("No Second Stack for cm_mode_pref %d, mode_cap %d, hybr_pref %d", cm_mode_pref, cmpmprx_read_mode_capability(as_id), CMPH_SS_HYBR_PREF(as_id, ph_ptr));
    }
    return FALSE; 
  }

  return TRUE;
}

/*==========================================================================

FUNCTION cmph_is_get_networks_ongoing

DESCRIPTION
  Function returns TRUE if there is any ongoing get_networks present on provided as_id

RETURN VALUE
  TRUE/FALSE

DEPENDENCIES
  None
===========================================================================*/
boolean cmph_is_get_networks_ongoing(sys_modem_as_id_e_type as_id)
{

  cmph_s_type*               ph_ptr = cmph_ptr();
  cm_mode_pref_e_type        network_type;
  boolean                    ret = FALSE;

  #ifdef FEATURE_MMODE_DUAL_ACTIVE
  if(cmph_is_dsda() && as_id == SYS_MODEM_AS_ID_2)
  {
    #ifdef FEATURE_MMODE_SXLTE_G
    if (cmph_is_sxlte())
    {
      network_type = ph_ptr->hybr_3_stack_info.pref_info.network_type;
    }
    else
    #endif
    {
      network_type = ph_ptr->hybr_2_stack_info.pref_info.network_type;
    }
  }
  else
  #endif
  {
    network_type = ph_ptr->main_stack_info.pref_info.network_type;
  }

  if(network_type != CM_MODE_PREF_NONE &&
  	cmph_map_cm_ss_to_as_id(ph_ptr->ss_for_get_networks) ==  as_id)
  {
    ret = TRUE;
  }

  return ret;

}

/*==========================================================================

FUNCTION cmph_update_user_mode_pref

DESCRIPTION
  Function that update the's the user mode pref on receiving command sys_sel_pref from user or read from NV during ph_nv_reset.

RETURN VALUE
  None

DEPENDENCIES
  None
===========================================================================*/


void cmph_update_user_mode_pref(cm_ss_e_type ss,cm_mode_pref_e_type mode_pref)
{
    cmph_s_type     *ph_ptr    = cmph_ptr();
    CM_MSG_HIGH_2("Changing user mode pref for ss=%d with mode_pref=%d",ss, mode_pref);
    
    if(ss == CM_SS_HYBR_2)
    {
      ph_ptr->hybr_2_stack_info.pref_info.user_mode_pref = mode_pref;
    }
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    else if(ss == CM_SS_HYBR_3)
    {
      ph_ptr->hybr_3_stack_info.pref_info.user_mode_pref = mode_pref;
    }
    #endif
    else
    {
      ph_ptr->main_stack_info.pref_info.user_mode_pref = mode_pref;
    }
}

/*==========================================================================

FUNCTION cmph_get_intersected_mode_pref_from_efrat_user_mode_pref

DESCRIPTION
  Function that retrieves a intersection of mode pref from EF_RAT and user mode pref settings.
  

RETURN VALUE
  Intersection of EF_RAT&USER_MODE_PREF , if no intersection then EF_RAT

DEPENDENCIES
  None
===========================================================================*/

cm_mode_pref_e_type cmph_get_intersected_mode_pref_from_efrat_user_mode_pref(cm_mode_pref_e_type user_pref,cm_mode_pref_e_type ef_mode_pref)
{
     sd_ss_mode_pref_e_type user_mode_pref_mask= cmph_map_cm_mode_pref_to_sd_mode_pref(user_pref);
     sd_ss_mode_pref_e_type ef_mode_pref_mask= cmph_map_cm_mode_pref_to_sd_mode_pref(ef_mode_pref);

     if(ef_mode_pref == CM_MODE_PREF_GWL)
     {
       return user_pref;
     }
     else
     {
       user_mode_pref_mask = SD_GET_COMMON_MODE(ef_mode_pref_mask,user_mode_pref_mask);
     }

     CM_MSG_HIGH_3("Intersecting EF_RAT, user_pref=%d,ef_mode_pref=%d,calc temp_mode_pref=%d",user_pref, ef_mode_pref, user_mode_pref_mask);
      //if intersection found then return intersection else return NONE
      return(cmph_map_sd_mode_pref_to_cm_mode_pref(user_mode_pref_mask));
      
}
/*==========================================================================

FUNCTION cmph_find_standby_pref

DESCRIPTION
  Finds new standby pref based on active subs
  provided. New standby pref is calculated based on
  number of subs available.

RETURN VALUE
  None

DEPENDENCIES
  None
===========================================================================*/
sys_modem_dual_standby_pref_e_type cmph_find_standby_pref(cm_ph_cmd_info_s_type cmd_info_ptr, uint8 *new_sub_mask)
{
  cmph_s_type     *ph_ptr    = cmph_ptr();
  uint8 no_of_active_sims=0;
  uint8 active_subs =0;
  sys_modem_dual_standby_pref_e_type new_standby_pref = SYS_MODEM_DS_PREF_NONE;

  /* If subs is already made inactive during MCFG refresh, no need to invoke 
     cleanup again */
  active_subs = cmd_info_ptr.active_subs & ~cmph_ptr()->mcfg_deactivate_subs;

  if(active_subs & SYS_MODEM_AS_ID_1_MASK)
  {
    no_of_active_sims++;
	*new_sub_mask|= SYS_MODEM_AS_ID_1_MASK;
  }

  if(active_subs & SYS_MODEM_AS_ID_2_MASK)
  {
    no_of_active_sims++;
	*new_sub_mask|= SYS_MODEM_AS_ID_2_MASK;
  }

  if(active_subs & SYS_MODEM_AS_ID_3_MASK)
  {
    no_of_active_sims++;
	*new_sub_mask|= SYS_MODEM_AS_ID_3_MASK;
  }

  switch(no_of_active_sims)
  {
    case 1:
     new_standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
     break;

    case 2:
     /* Depending on tuneaway, set the standby preference accordingly */
     new_standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
     break;

     case 3:
      new_standby_pref = SYS_MODEM_DS_PREF_TRIPLE_STANDBY;
      break;

    default:
        new_standby_pref = SYS_MODEM_DS_PREF_NO_STANDBY_PREF;
     break;
  }

  return new_standby_pref;
}

/*==========================================================================

FUNCTION cmph_is_subscription_available

DESCRIPTION
  Function that find if given subscription is available. Considers
  DS->SS and SS->NO case only.

RETURN VALUE
  None

DEPENDENCIES
  None
===========================================================================*/
static boolean cmph_is_subscription_available( uint8 new_sub_mask)
{
 boolean is_subs_avail = FALSE;

  switch(new_sub_mask>>1)
  {
    case SYS_MODEM_AS_ID_1:

    if(cmph_ptr()->is_gwl_subscription_available ||
           cmph_ptr()->is_cdma_subscription_available)
    {
      is_subs_avail = TRUE;
    }
    break;

    case SYS_MODEM_AS_ID_2:

    if(!cmph_is_sxlte())
    {
      if(cmph_ptr()->is_hybr_gw_subscription_available)
      {
        is_subs_avail = TRUE;
      }
    }
    else
    {
      if(cmph_ptr()->is_hybr_gw3_subscription_available)
      {
        is_subs_avail = TRUE;
      }
    }
    break;

    default:
    is_subs_avail = FALSE;
    break;

  }
  return is_subs_avail;
}

/*==========================================================================
FUNCTION cmph_force_srv_domain_on_nondds_sub

DESCRIPTION
  This Fn forces the given srv domain on nonDDS Sub for 'IMS for nonDDS feature'. Later, the same Fn can be 
  extended for SUB2 as per requirement

RETURN VALUE
  None

DEPENDENCIES
  None
===========================================================================*/
void cmph_force_srv_domain_on_nondds_sub(cm_srv_domain_pref_e_type srv_domain_pref)
{
  cmph_s_type *ph_ptr = cmph_ptr();
  cm_ph_cmd_info_s_type       *cmd_info_ptr1;
  cm_ph_cmd_s_type            *ph_cmd_ptr;
  
  CM_MSG_HIGH_2("Due to Change in maxActiveData to %d, force srv_domain %d on SUB1",
    cmpm_ptr()->device_mode.nMaxActiveData, srv_domain_pref);

  ph_cmd_ptr = cm_cmd_alloc_ph_init();
  ph_cmd_ptr->client_id               = CM_CLIENT_ID_ANONYMOUS;
  ph_cmd_ptr->cmd                     = CM_PH_CMD_SYS_SEL_PREF;
  
  cmd_info_ptr1 = CMD_INFO_PTR( ph_cmd_ptr );
  cmd_info_ptr1->cmd_subs              = SYS_MODEM_AS_ID_1; // AS_ID_2 is be added in future based on Req
  cmd_info_ptr1->mode_pref             = CMPH_SS_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
  cmd_info_ptr1->pref_term             = CM_PREF_TERM_PERMANENT;
  cmd_info_ptr1->pref_duration         = 0;
  cmd_info_ptr1->band_pref             = CMPH_SS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
  cmd_info_ptr1->lte_band_pref         = CMPH_SS_LTE_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
  cmd_info_ptr1->tds_band_pref         = CMPH_SS_TDS_BAND_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
  cmd_info_ptr1->prl_pref              = CMPH_SS_PRL_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
  cmd_info_ptr1->roam_pref             = CMPH_SS_ROAM_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
  cmd_info_ptr1->hybr_pref             = CMPH_SS_HYBR_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
  cmd_info_ptr1->srv_domain_pref       = srv_domain_pref; // PS_ONLY is also possibility and can be added based on Req
  cmd_info_ptr1->network_sel_mode_pref = CMPH_SS_NETWORK_SEL_MODE_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
  cmd_info_ptr1->sys_sel_pref_req_id   = 0;
  cmd_info_ptr1->ue_usage_setting = CMPH_SS_UE_USAGE_SETTING(cmd_info_ptr1->cmd_subs, ph_ptr);
  cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_UE_USAGE_SETTING);
  cmd_info_ptr1->csg_id                = SYS_CSG_ID_INVALID;
  cmd_info_ptr1->csg_rat               = SYS_RAT_NONE;
  cmd_info_ptr1->voice_domain_pref = CMPH_SS_VOICE_DOMAIN_PREF(cmd_info_ptr1->cmd_subs, ph_ptr);
  cmph_set_pref_nochg_flag(CMPH_PREF_NOCHG_VOICE_DOMAIN_PREF);
  cmd_info_ptr1->acq_order_pref = CMPH_SS_ACQ_ORDER_PREF(cmd_info_ptr1->cmd_subs,ph_ptr);
  sys_plmn_undefine_plmn_id( &cmd_info_ptr1->plmn );
  
  cmph_cmd_sys_sel_pref_proc(ph_cmd_ptr);
  
  cmph_dds_update_srv_domain(SYS_MODEM_AS_ID_1, srv_domain_pref);

  /*We can skip writing new srv_domain to NV coz it should get adjusted based on DDS anyway*/
  CMPH_SET_PRST_SRV_DOMAIN_PREF(SYS_MODEM_AS_ID_1, ph_ptr, srv_domain_pref);
  
  cmph_event_per_subs(ph_ptr,CM_PH_EVENT_SYS_SEL_PREF,cmph_map_subs_to_ss(SYS_MODEM_AS_ID_1));
  cm_cmd_dealloc(ph_cmd_ptr);

  return;
}

/*===========================================================================

FUNCTION cm_print_lte_band_mask

DESCRIPTION
Print the LTE band mask.

DEPENDENCIES
None

RETURN VALUE
None

SIDE EFFECTS
none

===========================================================================*/
void cm_print_lte_band_mask(sys_lte_band_mask_e_type lte_band_pref)
{
  #if (LTE_BAND_NUM == 256)
  CM_MSG_MED_2("LTE bands 193_256: 0x%08x %08x",
               QWORD_HIGH(lte_band_pref.bits_193_256),
               QWORD_LOW(lte_band_pref.bits_193_256));
  CM_MSG_MED_2("LTE bands 129_192: 0x%08x %08x",
               QWORD_HIGH(lte_band_pref.bits_129_192),
               QWORD_LOW(lte_band_pref.bits_129_192));
  CM_MSG_MED_2("LTE bands  65_128: 0x%08x %08x",
               QWORD_HIGH(lte_band_pref.bits_65_128),
               QWORD_LOW(lte_band_pref.bits_65_128));
  CM_MSG_MED_2("LTE bands    1_64: 0x%08x %08x",
               QWORD_HIGH(lte_band_pref.bits_1_64),
               QWORD_LOW(lte_band_pref.bits_1_64));
  #else
  CM_MSG_MED_2("LTE bands    1_64: 0x%08x %08x", QWORD_HIGH(lte_band_pref),
                                                  QWORD_LOW(lte_band_pref));
  #endif
}

/*===========================================================================

FUNCTION cmph_get_ss_lte_band_pref

DESCRIPTION
return the LTE band mask on the sub.

DEPENDENCIES
None

RETURN VALUE
None

SIDE EFFECTS
none

===========================================================================*/
sys_lte_band_mask_e_type cmph_get_ss_lte_band_pref(

   sys_modem_as_id_e_type asubs_id,

   cmph_s_type*            ph_ptr
)
{
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  return ((cmph_map_subs_to_ss(asubs_id) == CM_SS_HYBR_3)?
            ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref:
            ((cmph_map_subs_to_ss(asubs_id) != CM_SS_HYBR_2)?
                ph_ptr->main_stack_info.pref_info.lte_band_pref:
                ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref
              )
         );
  #else
  return ((asubs_id != SYS_MODEM_AS_ID_2)?
            ph_ptr->main_stack_info.pref_info.lte_band_pref:
            ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref
         );
  #endif
}

/*==========================================================================
FUNCTION cmph_adjust_hybr_pref_for_pending_pref

DESCRIPTION
  Function that adjust's the hybr_pref oc ommand pointer as per switching values

RETURN VALUE
  None

DEPENDENCIES
  None
===========================================================================*/
void cmph_adjust_hybr_pref_for_pending_pref(cm_hybr_pref_e_type hybr_pref)
{
  cmph_s_type     *ph_ptr    = cmph_ptr();
  cm_reply_s_type *reply_ptr = &ph_ptr->reply;

  if(cm_reply_is_waiting(reply_ptr) &&
     reply_ptr->cmd_ptr != NULL)
  {
    if(reply_ptr->cmd_ptr->cmd_type == CM_CMD_TYPE_PH)
    {
      cm_ph_cmd_s_type *ph_cmd_ptr = (cm_ph_cmd_s_type *)reply_ptr->cmd_ptr;
      
      if (ph_cmd_ptr == NULL)
      {
        return;
      }
      
      if(cmph_is_pref_nochg_set(CMPH_PREF_NOCHG_HYBR_PREF))
      {
        ph_cmd_ptr->info.hybr_pref = hybr_pref;
        CM_MSG_HIGH_1("Changing hybr_pref to %d during the switch", hybr_pref);
      }
    }
  }

}

/*==========================================================================

FUNCTION cmph_get_pref_reason

DESCRIPTION
  Function returns valid pref reason for pri Q object type

RETURN VALUE
  TRUE/FALSE

DEPENDENCIES
  None
===========================================================================*/
static sd_ss_pref_reas_e_type cmph_get_pref_reason(cm_act_type_e_type    act_type)
{
 sd_ss_pref_reas_e_type pref_reas  = SD_SS_PREF_REAS_ORIG_START_CS;

 switch(act_type)
 {
   case CM_ACT_TYPE_DATA_CALL:
   case CM_ACT_TYPE_GPS: 
     pref_reas = SD_SS_PREF_REAS_ORIG_START_PS;
	 break;

   case CM_ACT_TYPE_POLICYMAN_RESTRICT:
   case CM_ACT_TYPE_AC_EMERG_MODE:
     pref_reas = SD_SS_PREF_REAS_USER;
	 break;
 
   default:
     break;  
 }
 return pref_reas;
}
