/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

     C A L L   M A N A G E R   S E R V I N G   S Y S T E M   M O D U L E

GENERAL DESCRIPTION
  This module contains the Call Manager Serving System Object.

  The Serving System Object is responsible for:
  1. Processing MC serving system related notifications.
  2. Notifying the client list of serving system events.


INITIALIZATION AND SEQUENCING REQUIREMENTS
  cmss_init() must be call to initialize this module before any other
  function declared in this module is being called.


Copyright (c) 1998 - 2015 by Qualcomm Technologies INCORPORATED. All Rights Reserved.

Export of this technology or software is regulated by the U.S. Government.
Diversion contrary to U.S. law prohibited.

*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/mmcp/mmode/cm/src/cmss.c#1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
07/08/14   jvo     Don't always print summary F3s for cmss_report_rssi()
02/11/14   ss      eMBMS support for QMI
01/30/14   ss      Fix to send req id on hybr_2 stack in SGLTE
01/08/14   jvo     Added segment loading support for 5 bare WCDMA rrc calls
01/02/14   ss      Check for on-going voice or emergency calls before forcing
                   user prefs down to MMoC in SGLTE
12/19/13   sm      Introduce separate HYBR2 and MAIN div duplex field
12/13/13   sm      Update srv status immediately during SIM not available
12/06/13   xs      FR3799: Broadcasting IMS E911 capability
05/15/13   fj      Add support for segment loading.
07/22/13   fj      Add support for DSDX L+G
09/04/13   mh/jvo  Mainline the modem statistics code
09/04/13   jvo     3GPP2 MCC is now reported even when HPCD is disabled
07/25/13   ar      Extended multisim geran interface
07/19/13   jvo     Remove all MDM/MSM Fusion features
07/17/13   xs      Lu reject info notification
07/15/13   ss      FR1860 - T/G on DSDS
07/02/13   fj      Do not reset no srv timer in cmss_event().
05/21/13   fj      Buffer the LTE PWR_SAVE status on hybr_2 stack.
06/23/13   xs      SDS for TD and 1X
06/18/13   gm      FR 2617 - OMADM IMS and ADMIN PDN Disable Requirement
06/03/13   xs      E911 ready ind with ac_bar info considered
05/10/13   ss      TDD/FDD for LTE on HYBR_2
04/30/13   skk     Enhance Interface For Packet Attach/Detach
04/24/13   ss      New API for BCD to ASCII Conversion
03/26/13   fj      Hold no srv or limited srv for the dedicated time based on RAT.
02/03/13   cl      FR1975: Dynamic Switch SVLTE <-> CSFB
02/02/12   xs      Fix issue of not sending bsr_in_progress when it is changed
01/07/13   qf      FR 2564 - World mode support for DSDA
01/01/02   mg      Update plmn id information on LTE cell id change.
11/07/12   mg      Update cell id change in hybr_gw_cell_info in SVLTE mode.
11/06/12   cl      Reject PS_DATA_AVAIL command during 1X.Voice or CS_only domain
10/02/12   jh      Reset changed_fields before send ssevt for cell_rpt
11/02/12   skk     Make sure not to inform both LTE and HDR as in service at a time.
10/17/12   fj      Added as_sys_mode and tac in sys_cell_info_s_type.
10/12/12   qf      Send cmss cell broadcast capability update only if G/W has
                   limited or full service.
10/11/12   ak      Centralized the available_plmn_type update in srv_ind.
10/09/12   skk     Implemented fetch based mechanism for 3GPP RSSI
09/28/12   qf      Do not indicate 3GPP and hdr in service at the same time
07/19/12   jh      Added trace_id for embms_info
09/18/12   qf      Reset SSAC backoff timer if G/W full service is acquired
09/18/12   qf      For cell information update, CM should not send ss srv change event
                   with no service if no_srv_timer is running.
09/17/12   skk     Do not send internal service lost or limited service during uptime.
05/11/12   ab      Fix for wrong throttling information is returned when hybrid is off
                   and HDR is on the main stack
04/18/12   gm      Simplified API to retrieve SS info for all tech.
04/10/12   sk      Fixing the CW and KW warnings
04/02/12   gm      Home MCC should refreshed on subscription/OTASP change
03/25/12   cl      Update sys-mode upon power-save indication
03/23/12   gm      DIME integration fix: TMC deprecation and others.
03/09/12   fj      Add SVLTE support in cmss_sys_mm_info_match().
03/03/12   vk      FIX to reject PS_DATA_AVAIL_REQ during Emergency call.
03/15/12   vk      Added domain selection info in CMSS
03/12/12   fj      Update cell_id & reg_reject_info in hybr_gw stack in SVLTE.
03/13/12   vk      FIX to reject PS_DATA_AVAIL_REQ during Emergency call.
03/13/12   vk      Removal of feature flags added for CELL_DCH feature.
03/09/12   vk      Added feature to get DCH cell info.
03/06/12   jh      Added eMBMS coverage status indication handling
11/30/11   jh      Added feature for dynamic rat acq order change
02/14/12   xs      Remove JCDMA feature flag for call throttle
01/26/12   fj      Add support for LTE time info in SVLTE mode.
02/12/12   aj      update DCTM algo to use hybrid_active_band for HDR system
02/12/12   aj      check cmregprx state before sending deact from dormant command
02/09/12   aj      update cmpref2_proc_cmd_pref_sys_chgd() param to fix mem issue
02/07/12   fj      Update GWL TAC bit mask in SVLTE mode.
02/03/12   sg      Call is throttled when current time is equal to throttle time
01/24/12   fj      Add support for EUTRA detection status.
01/17/12   ar      Update change fields in both MAIN & HYBR2 stacks when
01/11/12   mj      Register with TDS-RRC for cell change indication
                   SS event is sent independent on which subs
01/10/12   gm      Mainlining HDR API change integration
01/06/12   gm      Data synchronization changes for freefloating platform
12/21/11   xs      Fix compilation error when FEATURE_LTE is not defined
12/15/11   rk      Fix to check mode pref before decide to do multimode scan
12/07/11   fj      Update data_suspend and send corresponding SS event for SVLTE mode.
12/06/11   ab      Corrected typecasts on orig_band_pref, orig_lte_band_pref
                   and orig_tds_band_pref
11/28/11   ab      Roam status is included in CM_CONN_MODE_SERVICE_STATUS_IND
11/16/11   jh      Replace cmcall CTXT_TRANSFER event to cmss event
12/01/11   vk      PS voice domain selection migration from CNE to CM
11/16/11   fj      Add support to udpate cipher_domain in SVLTE mode.
11/04/11   jh      Added new field/mask in SS event to notify lte div_duplex
11/02/11   gm      Changes for HDR API cleanup
10/11/11   jh      Added bsr_in_progress notification
09/28/11   vk      Throtling time Random delay range changed from (0-54) to (0-15)
09/22/11   rk      Handle SYS_LTE_CS_CAPABILITY_LIMITED
09/15/11   rk      Fix to declare data fail event only if data is suspended
08/22/11   gm      Calls on THR sys not allowed until uptime > thr_time
08/29/11   sg      Restore sim_state to previous value after sys_mode changed
                   from CDMA/NO_SRV to G/W/L.
08/25/11   xs      Added EPS network feature support definition (PS voice indication)
08/15/11   aj      update to LTE to do resel when LTE is on hybr2 stack
07/27/11   xs      Drop LTE RSSI when sys mode is still W during W->L reselection
07/24/11   aj      SC SVLTE 1.0 merge to mainline
07/11/11   rk      Do not diable LTE from mode pref when sim state is PS invalid
06/23/11   fj      During GWL IRAT, don't update GW RSSI if sys_mode is LTE.
06/20/11   ay      Fix to report the RAT information properly
06/08/11   gm      Revert Fusion Type 1 CR 284736 for sending ALT_SCAN to NAS
05/25/11   cl      Remove/Restore GW for MMSS arbitration optimization
05/20/11   xs      Added debug message of target RAT
05/18/11   cl      Added support for GW throttle filtering based on regions.
05/12/11   sv      Move Data call below PH, only when CDMA is part of mode pref
05/11/11   skp     Lint Issue Fixed.
05/02/11   rm      Cell broadcast changes
04/28/11   sv      Pass geo_sys_idx and cdma_reg_prd to clients in SS Event.
04/21/11   sv      Correct Lint Errors
04/14/11   xs      Added support for target_rat notification
04/12/11   xs      Fix ecio not report issue
04/11/11   am      Cleaning stubs and runnning qtf SUTE
03/30/11   rk      Fix to disble LTE if sim state is PS invalid and do not
                   do PS detach as part of LTE disable if SIM is PS invalid
03/24/11   cl      FUSION2 MMSS-Arbitration centralization rework
03/23/11   sv      Fix compilation errors in FEATURE_USERZONE
03/17/11   xs      Lint error fix
03/15/11   cl      Uses power-save from service status instead new indication
03/14/11   sv      Perform card power-down and up after OTASP commit
03/03/11   gm      Added separate queue processing for M2M indications
03/03/11   xs      Fix invalid read size issue of cmefs_read
03/03/11   fj      Pass buffer size to read EFS idm timer value.
03/02/11   rk      Domain selection phase 2 requirements
02/28/11   gm      Support for thermal emergency feature
02/17/11   cl      Add support FEATURE_MMODE_REMOVE_1X for FUSION-MDM
02/07/11   xs      Lint error fix
01/27/11   fj      Add debug message.
01/24/11   ak      Merging the Fusion type I code to mainline.
01/19/11   fj      Read EFS for the IDM timer value in cmss_init().
01/15/11   rk      Indicate about 1XCSFB call in service change event when
                   service is changed from LTE to CDMA
01/04/11   xs      Added LTE check for mm info reset to get correct NTIZ info
12/28/10   sv      Fix DSDS code
12/23/10   sv      Integrate DSDS feature
12/16/10   am      Cleaning nas_stubs_ref.h inclusion
12/14/10   xs      Added support for call throttle parameter configurable in EFS for JCDMA
12/07/10   cl      When timer expires, also check if the state has been change
                   instead of just checking against TRUE, to avoid race cond.
12/02/10   gm      Fix to MOB lint warning.
11/24/10   xs      Fusion featurization clean up
11/11/10   rm      Inform WLAN clients with ss evt when no parameters change
11/11/10   rm      Adding WLAN security info interface
11/15/10   rm      Memory optimization changes
11/02/10   am      Replacing FEATURE_MOB_MMODE_CUTE
11/02/10   gm      Fix to KW errors.
10/27/10   rk      Reverting support for deativating dormant protocol through MMOC
10/28/10   gm      Fix to compilation warning.
10/27/10   rk      Adding support for deativating dormant protocol through MMOC
10/20/10   xs      Added support to make rsrp_delta and rsrq_delta configurable
10/05/10   sg      Recompute the orig_mode, based on net sel mode pref
10/04/10   cl      Adding support for uplink/downlink lte cell info indication
10/01/10   ak      Merged the Fusion code from Dev branch.
09/30/10   sv      Update preferred GWL service indication based on LTE service
09/27/10   xs      Added error handler for call throttle in case it is wrongly used in UMTS
09/23/10   np      Add to populate LTE sinr
09/23/10   xs      Superlint critical/high error fixed
09/17/10   cl      Disable nam-change for feature FEATURE_THIN_UI
09/12/10   rm      Update srv_domain pref to clients while in PWR_SAVE
08/30/10   xs      Repetitive HDR RSSI report fix in cmss_report_rssi().
08/18/10   fj      Add cmss_update_lte_cell_info().
07/14/10   mh      Fixed compile warnings
07/08/10   sv      Updates to CMPREF API
07/06/10   aj      HICPS - add GWL to mode pref only after 1x more pref
                   acquisition is complete
07/01/10   fj      Revert temp solution in CL#1330955.
06/28/10   ak      Added EOOS support
06/18/10   aj      Add support to throttle HDR systems based on subnet id
06/15/10   aj      support for IRAT measurement support
06/14/10   gm      Fix to KW/Lint errors.
06/10/10   ak      Mainlining memory optimization changes.
06/07/10   fj      Temp solution for handling DRB_SETUP_IND before SERVICE_IND
                   during W to L redirection.
06/03/10   aj      deact dormant GWL stack only if more pref 1x acq is complete
05/18/10   xs      Added EHRPD and HRPD personality support
05/06/10   rk      Deactivating dormant GW stack on aquiring HDR service.
05/04/10   aj      LTE support for passing plmn id/ lac info to clients
04/29/10   sv      Add NAS stubs for QTF
04/29/10   rm      Adding Modem Statistics changes for 1x/HDR
04/27/10   rm      Ciphering indication should be sent to clients in all case
04/16/10   fj      Added support for LTE to GW call object transfer.
03/25/10   fj      Removed FEATURE_CM_LTE in cmss_reset().
03/24/10   fj      Added support for LAC/TAC/RAC in ss event.
03/17/10   fj      Added support for LTE RSSI indication handling.
03/19/10   am      Fixing compilation warning
03/02/10   fj      Added HICPS support for LTE.
03/03/10   rn      Move to Auto with MM17 reject with new NV
02/01/10   aj      Add support for DCTM 4.0
01/05/10   pm      Removing UOOS
01/05/09   fj      Added LTE mapping in map_sd_mode_to_cm_mode().
12/08/09   fj      Added lte_band_pref in necessary APIs.
12/10/09   ak      Corrected KW errors.
10/29/09   ak      Updated HICPS to work with BSR 2.0
10/15/09   ks      Sending SS event as response to client against
                   sys_sel_pref cmd when network mode change from auto to
                   manual or vice versa
10/15/09   ks      Adding support for FER and PER reporting in 1X and HDR
10/14/09   sg      ZI memory reduction. Mmode should call new Heap Manager API to
                   allocate memory dynamically.
08/04/09   np      Added handling pref mode according to LTE system mode addition
12/22/08   fj      Enabled some APIs for LTE.
09/01/09   sv      Moving from clk API to time API
08/25/09   np      Reducing HPCD NV selection option range
08/28/09   ks      Added support to inform client block error rate in 3G.
08/25/09   rn      MM reject 17 makes data card move to Automatic mode
08/19/09   ks      Adding support to inform bit error rate to client
08/07/09   rm      CMI phase-2: Removing featurisation from /api files
06/29/09   rk      Handling new pref_reason SD_SS_PREF_REAS_MULTIMODE_SCAN
06/10/09   ks      Adding support for camped cell info requirement
05/27/09   aj      Adding support for updating clients with cdma local time
04/24/09   rm      Including cmlog_v.h
04/23/09   ks      Avoid CM SS event sent to client when UE manually select
                   same plmn as acq before in automatic mode
04/23/09   rm      Updating correct mode pref of phone when data_avaialable
                   request comes. Added cmph_get_srv_type.
03/31/09   mh      Added support for prl match indicator in ss info
03/24/09   sv      updated to cmtaski.h
03/24/09   sg      Removing feature flag FEATURE_EGPRS_IND check in CM code
03/23/09   rm      Adding _v.h files from NAS
03/16/09   rm      Defining BOOLEAN for some Windows dependency
02/04/09   fj      Cast ss_ptr->daylt_savings into cm_daylt_savings_e_type
02/25/09   aj      UMA GAN related changes
02/23/09   rm      Removing cm_log_v.h and adding sys_wlan_v.h
02/17/09   ak      Updating the UOOS stack sync up to use cmph_force_pref_on_the_fly
02/13/09   mh      Added support for default roaming indicator in ss info
02/11/09   ks      Add spare_bits field in the mm_information to indicate
                   no. of spare bits in end octet of n/w names(full/short)
01/21/09   rk      Fixing data resume issue in multimode targets.
12/17/08   jd      Fixed Lint errors
11/21/08   ks      Fixing compiler warnings
11/12/08   np      Convert OTA MCC to PRL MCC for HPCD
11/12/08   ks      Reset cell_srv_ind values once UE moves to No Service or inter-rat
                   happen W->G and G->W to avoid unnecessary event send to clients.
11/12/08   ks      Fixing Compilation error
11/11/08   ks      Resolve Klocwork defects
11/10/08   jd      Removed dead code in MC report processing
11/03/08   pk/ak   Updated the HICPS for RIM issues.
10/28/08   sv      Correct Compilation Warnings
10/27/08   rk      On data avail request pump the priority of all data calls
                   over to phone object.
10/21/08   ks      Update default threshold value for sir and pathloss and
                   add masks for RSSI event
10/06/08   np      Added HPCD Rev B
10/01/08   sv      Corrected featurization for cmss_misc_is_sys_id_equal
                   to remove compiler warning.
09/27/08   cl      Support active channels for QMI
09/25/08   cl      1X icon disappear when enter & exit LPM or FTM
09/17/08   ks      When OOS in CELL_FACH, UE needs to follow UOOS scanning
                   pattern to re-acquire service
09/16/08   pk      Added support for WLAN UOoS
09/05/08   sv      Remove compiler warnings.
09/05/08   sv      Memory Reduction for ULC
09/04/08   ks      Remove info for Neighbors Cell IDs
08/25/08   ak      Fixed the general compiler warnings.
08/24/08   rn      Send regn reject info to clients
08/20/08   st      Klockwork Fixes
07/30/08   ak      Fix for the HICPS scenario.
07/18/08   ks      Added new info for Current Operator's Cell ID and
                   Neighbors Cell IDs
06/12/08   sv      Resolve Klocwork defects
06/11/08   sv      Exposing cmss_send_ss_info for power collapse buffered
                   events notifications.
05/27/08   sv      Updated report_rssi to send rssi info to individual clients
05/01/08   sv      Added CMSS_ECIO_VALUE_MAX to limit cdma ecio
04/14/08   rm      Update call_ptr->sys_mode when the phone's
                   mode/service_status changes
03/26/08   vs      Updated the list of Call end status handled in
                   call throttling for DCTM 3.0.
03/14/08   ks      Updating UI with service status when UE is OOS in Connected Mode
03/13/08   sk      Fix to allow CDMA scans during dormant GW PS data calls
                   without tearing down the PS data call.
03/10/08   rn      Added support for indicating Limited_regional to clients
03/05/08   vk      corrected code for HYBR_GW configuration
02/20/08   rn      Initialized sim_state in cmss_reset function
02/15/08   ks      Adding SIR, Pathloss Implementation
01/24/08   ks      Display of UE signal strength indication
01/24/08   ks      Fix the flashing issue when moving from No Service to
                   Limited to Full Service in a short time frame.
01/03/08   ka      Adding handset based plus code dialing feature.
12/16/07   ks      Added cm_ph_cmd_signal_strength_delta
12/13/07   sk/ak   Added DCM.
12/07/07   ra      Added support for IMS VCC in HOMER files
12/03/07   vs      Fixing CR#129599, Updating srv_avail_info and info with
                   mccreg_is_registered()
08/17/07   dm      Featurised to report HSPA call status indication
08/17/07   ka/dm   New field to report HS call in progress
08/12/07   jq      Fixed DCTM timeline issue under JCDMA feature.
08/07/07   ic      Lint clean up
06/08/07   cl      Fix CR#: 119770 - cmss_orig_thr_tbl_entry_info_put should
                   pass parameter by pointer
06/06/07   rp      Adding support for EGPRS indication
06/06/07   pk/cl   Added support for LN status notification from HDR
05/15/07   rp      Adding support for ECNO for GW in cmss_report_rssi()
05/15/07   rp      Adding cmss_update_last_reported_sysmode()
03/30/07   jqi     Changed the DCTM timeline to 0,0,180 under JCDMA feature.
03/29/07   rp      Adjusting length of BCD number sent in enum_list
03/07/07   jqi     Added support for FEATURE_SMS_OVER_IP
02/23/07   ic      Initialize SS info buffer in cmss_info_alloc() before use
11/20/06   pk      Added support for HYBR_GW and UMTS -> 1X handover cont...
11/17/06   jqi     Added support for HDR active protocol revision information.
11/16/06   pk      Lint Fixes
11/11/06   pk      Added support for HYBR_GW and UMTS -> 1X handover cont...
11/09/06   pk      Added support for HYBR_GW and UMTS -> 1X handover cont...
11/07/06   pk      Added support for HYBR_GW and UMTS -> 1X handover
11/07/06   sk      Memory reduction effort.
10/11/06   jqi     Added CDMA 450M(BC5) block L support.
08/16/06   ic      Lint fixes
06/27/06   ka      Adding feature flag FEATURE_IP_CALL
04/17/06   ka      Adding support for HSDPA and DTM indications.
04/10/06   pk      Lint fixes
04/06/06   sk      Changed the BCMCS supported and BCMCS service (new)
                   indication behaviour. BCMCS supported never delayed and
                   changes only upon explicit indication from HDR. BCMCS
                   service status is an "AND" of the BCMCS supported and HDR
                   service status and is delayed if it changes due to HDR
                   service status change.
04/01/06   ka      Changes for emerg serv category during orig, aborting
                   manual search and returning current band with srv ind.
03/14/06   pk      Added support for high PSIST
03/13/06   sk      Set usable flag to UNKNOWN when real service lost on HDR.
03/10/06   pk      Added support for IMSI and MCC for IS 95 systems
02/17/06   ka      Adding support for videoshare
02/15/06   ic      Removed copy/paste errors from cmss_info_get()
01/24/06   pk      Modified cmss_update_hdr_srv_ind to report the correct
                   HDR mask.
01/12/06   ic      For specific calls / walks Lint warnings, replaced global
                   -fsp comment with -e{error#} comments where needed
01/09/06   ic      Adjusted for cm_num_init() / cm_num_copy() changes in cm.h
01/06/06   ka      Adding Release 5 changes including emerg call list,
                   traffic flow template for PDP modify and protocol config
                   options for some of the GW PS call reports.
01/06/06   ic      Lint cleanup
                   Mainlined FEATURE_ENHANCED_BAND_CLASS
11/18/05   pk      Added support for BC 5 and BC 11 sub blocks I,J,K
11/08/05   sk      Separated CM reports and commands.
11/03/05   ic      Added CM_ASSERT() for ptr function parameters and lint
                   comments for 613 Lint error
11/01/05   pk      Added support for the SD_SYS_USABLE_NOT_OK indication from
                   SD
10/27/05   pk      Added support for SS events for DCTM
10/23/05   jqi     Hold ps data call orig or data avail request if there is
                   a pending get network list request.
10/20/05   pk      Cleaned RVCT compiler warnings and added mapping functions
10/18/05   pk      Changed map_cm_hybr_pref_to_sd_hybr_pref to
                   cmph_map_cm_hybr_pref_to_sd_hybr_pref
09/23/05   ic      Do not start BCMCS timer when BCMCS service did not change
09/15/05   pk      Modified call to cmpref_proc_cmd_pref_sys_chgd in
                   cmss_proc_data_avail, passing NULL for wlan_ptr
09/15/05   pk      Changed DCTM messages to CM_MSG_LOW
08/29/05   ic      Integration of the BCMCS DS to CM to HDRMC path
08/15/05   pk      Added support for priority Queues for origination
                   parameters
08/11/05   pk      DCTM modifications, corrected the backoff time for the
                   case where the update is zero. Not adding randomizing
                   factor if the update is zero
08/02/05   ic      Print value that caused error in default switch case
07/26/05   pk      DCTM modifications, changed the backoff time line from
                   1,2,4,8 to 0,0,1,2,8,15. Ignoring NID for DCTM, a system
                   is uniquely identified by SID,PZID.
07/11/05   pk      Removed
                   cmss_read_sys_mode_from_db( &ss_ptr->info.sys_mode );
                   from the processing of CM_SRV_SYS_INFO_F report from MC.
07/11/05   pk      Modified cmss_misc_is_sys_id_equal(), to consider PZID's
06/14/05   pk      Modified cmss_update_hdr_srv_ind(). While in power save
                   hdr_no_srv_uptime is updated. This is the fix for CR 66297
06/06/05   pk      Added Data Throttle Manager API's and helper functions
06/02/05   ic      Mainlined FEATURE_CIPHER_IND and FEATURE_EXTENDED_PRL
05/18/05   ka      Merging CIPHER_IND feature.
05/20/05   ic      Mainlined FEATURE_IS683C_PRL
05/12/05   ic      Function name change update to cmbcmcs_srv_status_is_srv()
04/20/05   ka      Informing IP apps when there is a service change
03/17/05   pk      Modified cmss_report_rssi to check for ecio,io and sinr
                   while reporting change in rssi.
02/01/05   dk      Added WLAN Support.
0/17/05    dk      Print CMSS Event and Changed Field.
01/10/05   dk      Generate Service Indicator event for LAC change as well.
11/16/04   sj      Updated avoid_type mapping to SD types.
11/15/04   ic      Lint cleanup with CM_DEBUG on
11/11/04   ic      Lint cleanup
10/25/04   ic      Fixed "is_cmd_done" was declared but never referenced RVCT/ADS
                   compiler warning
10/22/04   jqi     Removed redundent RSSI type from cmss_report_rssi().
10/20/04   sj      Include is_colloc in CM SS event.
10/19/04   jqi     Sent the data available request upon the ps call orig
                   when the data is suspended.
09/27/04   ic      Fixed RVCT 2.1 compiler warning "..\..\services\cm\cmss.c"
                   line 2167: Warning:  #177-D: variable "cm_band_class" was
                   declared but never referenced"
09/20/04   jqi     Added debug messages for ps dormant optimization.
09/13/04   ka      Fixed a condition where serving parameter changes that are
                   recvd during throttling do not get passed on to call
                   objects at the end of throttling. There was no way to pass
                   on changes in serving system parameters to call objects
                   after throttling got ended.
09/03/04   ka      Added service throttling for HDR. Both HDR and MAIN throttling
                   is stopped if EVENT_SRV_CHANGED is generated due to other
                   triggers like sim state updation or data suspend flag change.
09/08/04   jqi     More ps dormant optimization.
08/27/04   jqi     Added ps dormant optimization.
08/12/04   ws      Remove cm20 support.
08/10/04   ic      Removed cmlog_system_mode() as it became obsolete.
08/04/04   ic      CM Lint clean up - cmregprx.c with Lint supression verified
                   and free of Lint issues in all CUTE configurations.
07/26/04   ic      Changed include file order to customer.h, then cm.h then
                   cmi.h
07/07/04   ka      Fixed Lint errors.
07/06/04   ka      Throttling EVENT_SRV_CHANGED sent to clients in STATUS_SRV
                   or STATUS_LIMITED. First transition to SERVICE reported immed.
                   Subseqent change in SERVICE params reported in 2 secs interv.
                   If no change detected in SERVICE params for 2 secs or
                   transitioned out of SERVICE, we move out of throttling mode.
07/05/04   dk      Fixed cmss_map_sd_mode_to_cm_mode() to report WCDMA/GSM mode
                   also.
07/02/04   sj      Fixed lint errors.
06/30/04   ic      Fixed obvious RVCT 2.1 compiler warnings (Jaguar build)
06/23/04   ic      Fixed ADS 120 compiler warnings (Saber build)
06/22/04   ic      Comments clean up
06/07/04   dk      Optimized CM not to inform its clients of SS NO Service every
                   one second if it is still in NO service state and CM has already
                   notified.
06/07/04   sj      Removed call to generate ph event standby sleep and wakeup.
05/27/04   ic      In cmss_client_cmd_proc() call cmss_client_cmd_err()
                   irrespective of whether error occured or not (client is
                   supposed to be always notified about command processing
                   status)
05/20/04   ic      Removed unnecessary comment
05/18/04   ic      In cmss_send_idle_digital_mode_event() copied current and
                   previous IDM from CM SS IDM object into CM SS object
05/17/04   ic      Changes related to bcmcs_srv_supported field being removed
                   from sd_si_info_s_type (sd.h)
05/14/04   ka      Fixed Lint errors.
04/23/04   ic      Merged over to CM mainline the delta between
                   MSMSHARED_CM.01.00.10.00.28 and MSMSHARED_CM.01.00.10.00.31
                   Removed cmss_update_rssi() as it had been removed long ago
                   from Jaguar 4.X branch
                   Replaced calls to cmss_update_rssi() with calls to
                   cmss_report_rssi() so CM SS here behaves like on 4.X Jaguar
                   branch with respect to RSSI reporting.
04/22/04   ic      Defined CMSS_ECIO_VALUE_NO_SIGNAL / CMSS_IO_VALUE_NO_SIGNAL.
                   Used them to initialize ecio / hdr_ecio and io / hdr_io
                   fields in CM SS object.
04/19/04   ic      Added support for HDR Ec/Io & Io reporting.
                   HDR Ec/Io & Io will be reported with CM_SS_EVENT_RSSI &
                   CM_SS_EVENT_HDR_RSSI events.
03/23/04   ws      Merged code from 6300.
03/15/04   ka      Merged code from 6250. Fixed Lint error.
03/02/04   ic      Added BCMCS support (FEATURE_BCMCS)
02/25/04   ic      Changes to make the code pass unit test cases and at the
                   same time make calls in Saber build
02/12/04   ic      Merged in changes from MSMSHARED_CM.01.00.10.00.20 to
                   MSMSHARED_CM.01.00.10.00.23
02/06/04   ws      Initial jaguar/mainline merge.
01/13/04   ka      Merged changes from MSM6200
12/11/03   ic      Fixes to cmss_proc_call_connected(), send IDM changed event
                   when needed
11/03/03   ws      Fixed LTK compile problems.
11/04/03   sj      Updated to support srv_status_pwr_save.
10/30/03   prk     Modified featurization of cmss_timer_proc().
10/27/03   ws      Fixed compiler warnings.
10/21/03   ws      Merged BS Info Changes
10/17/03   ws      Fix problem with multiple service indications.
09/16/03   ws      Generate a SS event for uz_id changes
08/15/03   ws      Do not set srv status to no service until timer proc expires.
07/28/03   SJ      Support for circulating data suspend flag thru' SD.
07/25/03   vt      Attempts reporting of RSSI for CDMA only in valid modes.
07/10/03   jqi     Added Extended PRL support
                   -Removed FEATURE_IS683C_PRL
07/01/03   az      Added FEATURE_ENHANCED_BAND_CLASS
05/01/03   ws      Fixed problem with packet_zone_update () comparing wrong enum
04/28/03   AT      Lint cleanup.
04/22/03   prk     Removed runtime mode check before calling cmcall_proc_srv_status
                   in cmss_update_srv_ind.  Instead, made changes to
                   cmcall_proc_srv_status.
03/24/03   ws      Added runtime mode check before calling cmcall_proc_srv_status
                   in cmss_update_srv_ind
03/13/03   prk     Updated cmss_update_srv_ind() to assign the service status
                   from SD to the serving system information.  The limited
                   service service status was not being handled.
02/28/03   prk     Updated cmss_update_srv_ind() to re-initialize the mobility
                   management if there is a loss of service or a change in the
                   PLMN.
02/27/03   CS      Added handling for the new SS ps_data_suspend field.
                   Modified cmss_process_service_ind to only handle the
                   SS info that has not been processed by SD.
02/25/03   RI      Added cmcall_proc_srv_status() call in cmss_update_srv_ind()
02/21/03   vt      Fixed problems to build for HDR.
02/03/03   prk     Modified cmss_process_service_ind() to always call
                   cmcall_proc_srv_status() (even if the srv status did not
                   change).
01/21/03   ws      Updated copyright information for 2003
01/09/03   PRK     Added forward declartion for cm_ss_init_mm_information().
12/17/02   vt      Fixed a typo.
11/27/02   vt      Fixed a compiler warning.
11/22/02   PRK     Added processing of mobility management information.
11/15/02   vt      Updated RSSI value whenever service status changed.
11/14/02   vt      Merged changes from GW mainline.
                   [CS]Added notification of service change event to CM call Object.
11/05/02   vt      Changed the slope from 28 to 33 for FM RSSI.
10/31/02   vt      Initialized ss object for multimode build.
                   Corrected a compile error for JCDMA. Fixed a GW RSSI problem.
10/30/02   vt      Fixed compiler errors.
10/23/02   vt      Mainlined FEATURE_CM_USE_UMTS_REG_INTERFACE.
10/22/02   vt      Uncommented code for GPS mode handling.
10/05/02   vt      Replaced checking srv_is_on with srv_status
09/10/02   ws      Added initial cm20 backward compatibility.
09/03/02   PRk     Modified cmss_report_rssi to report RSSI regardless of
                   mode being GSM or WCDMA.
05/17/02   PRK     Modified cmss_reset to set service indicators to "no service"
12/07/01   jqi     Added support for band class 5 in cmss_xlat_block_or_system.
05/05/02   vt      Fixed compile problem with new mm cm.h
05/04/02   PRK     Updated to support new REG-CM interface.
                   Introduced FEATURE_CM_USE_UMTS_REG_INTERFACE.
04/26/02   ATM     Added calls to cmlog_system_mode()
02/06/02   PRK     Updated parameter list in call to cm_util_sys_id_match.
02/04/02   PRK     Updated parameter list in call to sys_PLMN_get_MCC_MNC.
01/04/02   PRK     Renamed types and structs used by PLMN selection/reselection.
                   Featurized future PLMN selection/reselection code with
                   FEATURE_NEW_PLMN.
                   Removed REAL_CODE pre-processor directive.
11/21/01   PRK     Added REAL_CODE pre-processor "feature" to remove code not
                   needed in initial Surf testing.  Upon completion of Surf
                   testing the code should be restored to its original form.
10/18/01   PRK     Added changes for WCDMA/GSM mode.
                   Added support for PLMN selection/reselection (FEATURE_WCDMA,
                   FEATURE_GSM, FEATURE_PLMN).
                   Re-added Serving System group and moved srv_state, roam_status,
                   rssi from phone group to serving system group (FEATURE_NEWSS).
01/18/02   ic      Merged MSM_CM.05.03.33 on top of tip CCS CM
                   Diffed MSM_CM.05.03.32 with MSM_CM.05.03.33 and only the changes
                   between those two were merged with CCS CM
01/14/02   ic      Fixes related to running with FEATURE_IS2000_REL_A undefined
12/13/01   ic      Merged MSM_CM.05.03.32 onto SVD CM tip.
                   CCS CM code started from CM VU MSM_CM.05.03.25 + WCDMA/GSM
                   stuff from SIMBA team merged on top of it.
                   We diff'ed MSM_CM.05.03.25 with MSM_CM.05.03.32 (CM VU in N*2165)
                   that we needed to merge with and changes between those two VUs
                   were merged onto CCS CM tip.
10/23/01   VT/IC   Baseline for CCS
09/24/01   RC      Fixed CR 18443: MS powers down with fatal error cmss.c
                   477 on acquiring an invalid T53  channel.
08/21/01   ic      Main-lined FEATURE_NEWCM
01/23/01   ych     Merged JCDMA features.
09/09/99   SH      Added band class, block, registration status and p_rev
                   information to support data application
05/31/99   SH      Added CM 2.0 fetures
01/07/99   RC      Changes per ARM compiler.
12/30/98   RC      Changes per 4th week of I&T.
11/24/98   RC      Initial release.

===========================================================================*/


/****************************************************************************

 Organization of the file:

    The file is divided into multiple sections.
    You can jump from one sections to the other by searching for / followed
    by 2 *'s. The order of objects defined is as follows:

        includes
        forward declarations
        #defines
        enums
        macros

        functions
        - Internal [Common, 1x only, GW only]
        - External [Common, 1x only, GW only]

****************************************************************************/

/**--------------------------------------------------------------------------
** Includes
** --------------------------------------------------------------------------
*/
#include "queue.h"

#include "mmcp_variation.h"
#include "customer.h"
#include "cm.h"        /* External interface to cm.c */
#include "cm_v.h"
#include "cmi.h"
#include "cmss.h"      /* Interface to CM Serving System Object */
#include "comdef.h"    /* Definition for basic types and macros */
#include "sys.h"       /* System wide definitions */
#include "sys_v.h"
#include "cmtaski.h"    /* Interface to timer definitions */
#include "cmdbg.h"     /* Interface to CM debug services */
#include "cmclient.h"  /* Interface to CM Client Interface Block */
#include "cmlog.h"     /* Interface for Diagnostic Logging */
#include "cmlog_v.h"
#include "cmph.h"      /* Interface to CM phone */
#include "cmutil.h"    /* Interface for cm_util_undefine_sys_id */

#ifdef CM_GW_SUPPORTED
#include "cmwcall.h"   /* Interface to CM GW call object */
#endif

#if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined(FEATURE_WCDMA))
#include "cmwll.h"
#endif

#include "mmoc.h"      /* interface to dormant protocol state */
#include "time_svc.h"       /* Interface to clock services */

#if (defined CM_GW_SUPPORTED|| defined FEATURE_EOOS )
#include "cmregprx.h"  /* Interface for CM Reg Proxy */
#include "cmcall.h"
#include "cmregprxi.h"  /* Regproxy implementation related declarations */
#include <string.h>
#include "sd.h"        /* Interface to System Determination services */
#include "sd_v.h"


#endif /* defined CM_GW_SUPPORTED */

#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
#include "mccreg.h"    /* CDMA registration service */
#include "mccreg_v.h"
#include "srch.h"
#include "srch_v.h"
#endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

#include "nv.h"        /* interface to NV */

#include "cmmsc.h"
#include "cmsimcoord.h"
#include "cmmsc_sglte.h"
#include "cm_msgr_msg.h"
#include "cmpmprx.h"

#include "timer.h"


#ifdef FEATURE_HDR_HANDOFF
#include "cmssidm.h"     /* Interface to CM IDM module */
#endif // FEATURE_HDR_HANDOFF
#ifdef CM_GW_SUPPORTED
#include "mmtask.h"    /* MM command buffer allocation */
/*lint -esym(766,mmtask_v.h)*/
#include "mmtask_v.h"
#endif


#ifdef FEATURE_IP_CALL
#include "cmipappi.h" /* Interface to inform cm ip app about service */
#endif

#ifdef FEATURE_BCMCS
#include "cmbcmcs.h"
#endif


#ifdef FEATURE_DEDICATED_C2K_MODE
#include "cmxdbm.h"
#include "cmxsms.h"
#endif

#if defined(FEATURE_WCDMA)
#include "rrcmmif.h"
#ifdef FEATURE_SEGMENT_LOADING
#include "IWCDMA.h"
#endif
#endif

#if defined(FEATURE_TDSCDMA)

#ifdef FEATURE_SEGMENT_LOADING
#include "ITDSCDMA.h"
#endif

#include "tdsrrccsp.h"
#endif

#if (defined(FEATURE_GSM) && defined(FEATURE_GSM_RR_CELL_CALLBACK))
#ifdef FEATURE_CM_NEW_RR_CELL_INFO_INTERFACE
#include "geran_eng_mode_read_api.h"
#else
#include "rr_cb_if.h"
#endif  /* FEATURE_CM_NEW_RR_CELL_INFO_INTERFACE */
#endif /* defined(FEATURE_GSM) && defined(FEATURE_GSM_RR_CELL_CALLBACK) */

#ifdef FEATURE_CM_LTE
#include "esm_cm_msgr_enum_msg.h"  /* Interface to UMID */
#include "cmltecall.h"
#endif

#include "cmsds.h"
#include "cmsoa.h"
#include "cmaccessctrl.h"

#include "cmstats.h"

#if (defined(FEATURE_HDR) || defined(FEATURE_HDR_HYBRID))
#include "hdrcp_msg.h"
#include "hdrl1_api.h"
#endif

#include "cmefs.h"

#ifdef FEATURE_MMODE_DUAL_SIM
#include "subs_prio.h"
#endif

#include "cmmmgsdi.h"

#if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
#include "cmregprxi.h"
#endif

#ifdef CM_DEBUG
#error code not present
#endif

#include <stringl/stringl.h>
#include "cmautoreg.h"
#include "cmsups.h"
#include "cmdbg_qsh.h"

// instance pointer for segment loading of TDS or WCDMA
#ifdef FEATURE_SEGMENT_LOADING
extern interface_t *pi_mmode_tdscdma;
extern interface_t *pi_mmode_wcdma;
#endif

#include "cmpsm.h"

static void cmss_resolve_hdr_lte_srv_conflicts(void);
static void cmss_resolve_lte_lte_srv_conflicts(void);

/**--------------------------------------------------------------------------
** Forward declarations
** --------------------------------------------------------------------------
*/

#ifdef CM_DEBUG
#error code not present
#endif

boolean is_hybr1_full_srv_lost;
boolean is_hybr2_full_srv_lost;

#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
static uint16 cmss_get_fm_rssi (void);
static uint16 cmss_get_cdma_rssi (void);
static byte   cmss_get_cdma_ecio( void );
#endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */
#ifdef CM_GW_SUPPORTED
static void cm_ss_init_mm_information(

    sys_mm_information_s_type  *mm_information_ptr
        /* The mobility management information structure to be initialized */
);
static boolean cm_ss_is_mm_information_same(

    sys_mm_information_s_type  *mm_info1_ptr,
    sys_mm_information_s_type  *mm_info2_ptr
        /* The mobility management information structure to be initialized */
);

#endif /* FEATURE_WCDMA || FEATURE_GSM */
static void cm_ss_init_reg_reject_info(

    cm_ss_e_type               ss,
      /* stack whose structure needs to be initialized */

    cm_reg_reject_info_s_type  *cm_reg_reject_info_ptr
        /* The SS regn reject info structure to be initialized */
);


/* Compares Srv info and returns bit-mask of changed fields
** from main
*/
static uint64 cmss_get_ss_main_info_change(

    const cm_mm_ss_info_s_type     *new_srv_info,
        /*  New SS information */

    const cm_mm_msim_ss_info_s_type     *old_srv_info,
        /*  Old SS information */

          uint64                   *changed_fields2
);

/* Compares Srv info and returns bit-mask of changed fields
** from main
*/
static uint64 cmss_get_ss_hybr_2_info_change(

    const cm_mm_ss_info_s_type     *new_srv_info,
        /*  New SS information */

    const cm_mm_msim_ss_info_s_type     *old_srv_info
        /*  Old SS information */
);

/* This function gets the RSSI. If the RSSI change exceeds the delta threshold,
**  CM reports rssi change event to registered clients.
*/
static void cmss_report_hybr_2_rssi (

  const void              *rpt_ptr,
    /* ptr to message received */

  cm_client_s_type        *client_ptr,
    /* pointer to a client struct */

  boolean                 ignore_updates
    /* flag to ignore any RSSI changes and always send RSSI events */

);

#if defined (FEATURE_MMODE_TRIPLE_SIM) || defined (FEATURE_MMODE_SXLTE_G)
/* Compares Srv info and returns bit-mask of changed fields
** from main
*/
static uint64 cmss_get_ss_hybr_3_info_change(

    const cm_mm_ss_info_s_type     *new_srv_info,
        /*  New SS information */

    const cm_mm_msim_ss_info_s_type     *old_srv_info
        /*  Old SS information */
);

/* This function gets the RSSI. If the RSSI change exceeds the delta threshold,
**  CM reports rssi change event to registered clients.
*/
static void cmss_report_hybr_3_rssi (

  const void              *rpt_ptr,
    /* ptr to message received */

  cm_client_s_type        *client_ptr,
    /* pointer to a client struct */

  boolean                 ignore_updates
    /* flag to ignore any RSSI changes and always send RSSI events */

);
#endif /* FEATURE_MMODE_DUAL_SIM */


/* Compares Srv info and returns bit-mask of changed fields
** from HDR
*/
static uint64 cmss_get_ss_hdr_info_change(

    const cm_mm_ss_info_s_type     *new_srv_info,
        /*  New SS information */

    const cm_mm_msim_ss_info_s_type     *old_srv_info
        /*  Old SS information */
);

/* this function removes service domain from a given service domain
*/
static sys_srv_domain_e_type cmss_remove_srv_domain_comp
(
   sys_srv_domain_e_type  srv_domain_val,
     /* Srv domain value that needs to have a component removed
     */

   sys_srv_domain_e_type  srv_domain_comp
     /* Srv domain component that needs to be removed
     */
);

#ifdef FEATURE_CM_LTE
static sys_div_duplex_e_type cmss_map_lte_rrc_div_duplex_to_sys_val(
    lte_rrc_div_duplex_e  lte_rrc_div
    /**< lte rrc division duplex */
);

#endif

/* -------------------------- QMSS Changes --------------------------*/
#if 0

#define CMSS_MODEM_RESET_TIMER_EXPIRE_TIME 4
typedef struct
{
  uint64 time;
  sys_modem_as_id_e_type as_id;
}cmss_modem_reset_trigger_s_type;

boolean cmss_modem_reset_timer_fired = FALSE;
boolean cmss_can_trigger_modem_reset_0 = FALSE;
boolean cmss_can_trigger_modem_reset_1 =  FALSE;
boolean cmss_can_trigger_modem_reset_2 =  FALSE;

static timer_type cmss_modem_reset_timer;
static timer_group_type cmss_modem_reset_timer_group;

static cmss_modem_reset_trigger_s_type* cmss_modem_reset_trigger = NULL;

static void cmss_modem_reset_timer_init(void);
static cmss_modem_reset_trigger_s_type* cmss_check_if_modem_need_reset(void);
static void cmss_modem_reset_start_timer(cmss_modem_reset_trigger_s_type* trigger);
static void cmss_modem_reset_timer_expire_handler(timer_cb_data_type data);
void cmss_process_modem_reset_rpt(void);
#endif

boolean data_suspend_store = FALSE;
boolean data_suspend_valid = FALSE;
/*-------------------------------------------------------------------*/

/**--------------------------------------------------------------------------
** Defines
** --------------------------------------------------------------------------
*/

#define CMSS_RSSI_NO_SIGNAL                 125      /* -125dBm for no signal */

#define CMSS_RRC_RSSI_NO_SIGNAL             121

#define CMSS_RSCP_NO_SIGNAL                -125      /* -125 dBm for no signal */

#define CMSS_RSSI2_NO_SIGNAL               -125      /* -125dBm for no signal */

#define CMSS_ECIO_VALUE_NO_SIGNAL             5

#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
#define CMSS_ECIO_VALUE_MAX                  14
#endif

#define CMSS_ECIO_VALUE_NO_SIGNAL_UMTS      0x3F

#define CMSS_PATHLOSS_VALUE_NO_SIGNAL       0xFF

#define CMSS_SIR_VALUE_NO_SIGNAL            0xFF

#define CMSS_BER_VALUE_NO_SIGNAL            0xFF

#define CMSS_HDR_PER_INVALID                0xFFFF

#define CMSS_FER_INVALID                    0xFFFF

#define CMSS_CQI_VALUE_NO_SIGNAL            0xFF

#if (defined FEATURE_WCDMA) && defined(FEATURE_UMTS_REPORT_ECIO)
#define CMSS_ECIO_VALUE_INVALID_SIGNAL      0xFF
#endif

#if (defined CM_GW_SUPPORTED)
#define CMSS_RSCP_THRESHOLD_DELTA             5      /* 5dBm for rscp delta */
#endif

#if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
#define CMSS_NO_PS_DATA_UPTIME_NONE         (dword) (-1)
#endif /* FEATURE_PS_DORMANT_PWR_SAVE */

#define CMSS_IO_VALUE_NO_SIGNAL       (-106)

#define CMSS_SINR_VALUE_NO_SIGNAL     (8)

#define CMSS_INFORM_SRV_CHANGE_TIME        2    /* seconds */
     /* Time interval when the current service parameters are
     ** checked to see if EVENT_SRV_CHANGED should be posted
     */

 #define CMSS_HYBR_GW_SIG_STR_CHANGED_FIELDS_MASK   (CM_SS_GW_RSSI_MASK | \
                                                              CM_SS_GW_RSCP_MASK|CM_SS_GW_ECIO_MASK\
                                                             |CM_SS_GW_IO_MASK|CM_SS_GW_SINR_MASK\
                                                             |CM_SS_GW_SIR_MASK|CM_SS_GW_PATHLOSS_MASK\
                                                             |CM_SS_GW_BER_MASK|CM_SS_GWL_RSRP_MASK\
                                                             |CM_SS_GWL_RSRQ_MASK)

#define CMSS_MAX_NO_SRV_TIME          4    /* seconds */
    /* Max time for phone to be with no service before reporting to CM
    ** clients of service lost event. If service is reacquired before such
    ** time is expired, CM clients never notified of the service lost
    ** event */
#if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
#define CMSS_MAX_PS_DATA_PENDING_TIME  30    /* seconds */
    /* Max time for CM to pending a PS data available request.
    */


#define CMSS_MAX_NO_PS_DATA_SRV_TIME  30    /* seconds */
    /* Max time for CM to waiting for service upon PS data available request.
    */

#define CMSS_MAX_NO_PS_DATA_RESUME_TIME 120 /* seconds */
    /* Max time for CM to waiting for data resume after passing down ps data
    ** available request to stack
    */
#endif /* FEATURE_PS_DORMANT_PWR_SAVE */

#ifdef CM_GW_SUPPORTED
static cmss_gwl_signal_status_s_type cmss_gwl_signal_status;
#endif

/* Auto Register */
extern cm_auto_reg_cmds_e_type                     cm_auto_reg_cmds;

/* Srv indication uptimers
*/
static cmss_srv_ind_uptimers_s_type  cmss_srv_ind_uptimers =
{
  {CMSS_MAX_NO_SRV_TIME, CMSS_INFORM_SRV_CHANGE_TIME},
  {CMSS_MAX_NO_SRV_TIME, CMSS_INFORM_SRV_CHANGE_TIME},
  {CMSS_MAX_NO_SRV_TIME, CMSS_INFORM_SRV_CHANGE_TIME},
  {CMSS_MAX_NO_SRV_TIME, CMSS_INFORM_SRV_CHANGE_TIME}
};

/* Srv indication uptimers
*/
static cmss_rat_srv_ind_uptimers_s_type  cmss_rat_srv_ind_uptimers =
{
  FALSE,
  {CMSS_MAX_NO_SRV_TIME, CMSS_INFORM_SRV_CHANGE_TIME},
  {CMSS_MAX_NO_SRV_TIME, CMSS_INFORM_SRV_CHANGE_TIME},
  {CMSS_MAX_NO_SRV_TIME, CMSS_INFORM_SRV_CHANGE_TIME},
  {CMSS_MAX_NO_SRV_TIME, CMSS_INFORM_SRV_CHANGE_TIME},
  {CMSS_MAX_NO_SRV_TIME, CMSS_INFORM_SRV_CHANGE_TIME},
  {CMSS_MAX_NO_SRV_TIME, CMSS_INFORM_SRV_CHANGE_TIME}
};

static uint8 cdma_srv_lte_do_redir_uptimer;

/* Number of uptimers("no srv" & "limited service") */
#define TIMER_VALUES_COUNT 6

/* Number of Rat-based uptimers("no srv" & "limited service") */
#define RAT_TIMER_VALUES_COUNT 12

#ifdef FEATURE_CALL_THROTTLE
static dword *thr_time;
static const dword thr_time_dft[CMSS_ORIG_THR_MAX_TIMER_INDEX_DFT] = {0,0,0,60,120,480,900};

/*lint -esym(765, cmss_orig_thr_max_timer)
** Can't be static, unit test uses it
*/
unsigned int cmss_orig_thr_max_timer = 0;
#endif /* FEATURE_CALL_THROTTLE */
static boolean transition_rats = FALSE;
#if defined(CM_GW_SUPPORTED) /* For Lint */
#define CMSS_MAX_EMERG_BCD_NUM_LEN             (CM_MAX_NUMBER_CHARS / 2)
  /* Max bcd number length CM can accept. BCD takes half the length of
  ** actual ascii size.
  */
#endif


/* 6th Bit position that decides negative LTM */
#define CMSS_LTM_NEG_BIT  0x20

/* Sign extending to 7th and 8th bits */
#define CMSS_LTM_NEG_SIGN_EXTN  0xC0

#ifdef CM_GW_SUPPORTED

/* MM reject cause of value 17 */
#define CMSS_MM_REJECT_CAUSE17  17

#endif

/* EMBMS trace id initial value */
#define CMSS_EMBMS_TRACE_ID_NONE -1

/**--------------------------------------------------------------------------
** Macros
** --------------------------------------------------------------------------
*/

#define CMABS(x) (((x) < 0) ? -(x) : (x))

#if defined(CM_GW_SUPPORTED) /* For Lint */
#define CM_TYPE_CONTAIN( val, bit_mask ) \
      ( CM_BOOLEAN( (byte) val & (byte) bit_mask) )
#endif

/**--------------------------------------------------------------------------
** Functions - internal
** --------------------------------------------------------------------------
*/
#if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
static void cmss_identify_3gpp_serving_country (void);
#endif
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
static cm_country_code_type cmss_identify_3gpp2_serving_country (void);

static cm_country_code_type cmss_convert_mcc_ota_to_hpcd(
  cm_country_code_type  ota_mcc
);

static void cmss_identify_3gpp2_mcc_from_prl(
  const  sys_plmn_mcc_list    *prl_mcc_list,
  cm_country_code_type         current_mcc,
  cm_country_code_type         ota_mcc
);

static void cmss_identify_hdr_mcc_from_prl(
  const  sys_plmn_mcc_list    *prl_mcc_list,
  cm_country_code_type         current_mcc,
  cm_country_code_type         ota_mcc
);
#endif
static void cmss_map_sd_sid_to_sys_sid(
    sd_mode_e_type          sd_mode,
    sys_sys_id_s_type       *sys_sid_ptr,
    const sd_sid_u_type     *sd_sid_ptr
);



static boolean cmss_sys_mm_info_match (
      const cmss_s_type           *ss_ptr,
      const sd_si_info_s_type     *si_info_ptr,
      sd_ss_e_type           ss
);
static void cmss_update_srv_status_for_main(
    sys_srv_status_e_type new_srv_status,
    sys_sys_mode_e_type   new_sys_mode,
    sys_band_class_e_type new_active_band,
    sys_channel_num_type  new_active_chan
);
static void cmss_update_srv_status_for_hybr_2(
    sys_srv_status_e_type new_srv_status,
    sys_sys_mode_e_type   new_sys_mode,
    sys_band_class_e_type new_active_band,
    sys_channel_num_type  new_active_chan
);

#if defined (FEATURE_MMODE_TRIPLE_SIM) || defined (FEATURE_MMODE_SXLTE_G)
static void cmss_update_srv_status_for_hybr_3(
    sys_srv_status_e_type new_srv_status,
    sys_sys_mode_e_type   new_sys_mode,
    sys_band_class_e_type new_active_band,
    sys_channel_num_type  new_active_chan
);
#endif

boolean cmss_is_hybr_gw_operational_skip = FALSE;

boolean cmss_get_is_hybr1_full_srv_lost()
{
  return is_hybr1_full_srv_lost;
}

boolean cmss_get_is_hybr2_full_srv_lost()
{
  return is_hybr2_full_srv_lost;
}

#if ( defined(FEATURE_HDR_HYBRID))
static void cmss_update_srv_status_for_hybr_1(
    sys_srv_status_e_type new_srv_status,
    sys_band_class_e_type new_active_band,
    sys_channel_num_type  new_active_chan
);

/*===========================================================================

FUNCTION cmss_update_hybr_1_no_srv_ind_info

DESCRIPTION
  Update the phone object per the new service indicators.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmss_update_hybr_1_no_srv_ind_info(

    cmss_s_type               *ss_ptr,
        /* Pointer to a ss object */

    const sd_si_info_s_type   *si_info_ptr
       /* Pointer to buffer containing new service info information */
)
{
    sys_band_class_e_type new_hybrid_active_band =
                                          ss_ptr->info.hybrid_active_band;
    sys_channel_num_type  new_hybrid_active_channel =
                                          ss_ptr->info.hybrid_active_channel;

    ss_ptr->hybr_1_srv_status = si_info_ptr->srv_status;

    ss_ptr->hdr_is_pref_srv_acq = TRUE;
    ss_ptr->hybr_1_is_pref_srv_acq = TRUE;

    ss_ptr->current_hdr_mcc = CM_INVALID_MOBILE_COUNTRY_CODE;

    /* Update CMSS global for HYBR_1 stack atomically */
    cmss_update_srv_status_for_hybr_1(si_info_ptr->srv_status,
                                      new_hybrid_active_band,
                                      new_hybrid_active_channel);
}

/*===========================================================================

FUNCTION cmss_update_hybr_1_lmtd_srv_ind_info

DESCRIPTION
  Update the phone object per the new service indicators.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmss_update_hybr_1_lmtd_srv_ind_info(

    cmss_s_type               *ss_ptr,
        /* Pointer to a ss object */

    const sd_si_info_s_type   *si_info_ptr,
       /* Pointer to buffer containing new service info information */
    boolean is_lmt_srv_timeout_handling

)
{
  dword                    clk_time   = time_get_uptime_secs();

  sys_modem_as_id_e_type   subId    = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ; 
  uint8                    stk_id_main = cmph_ptr()->ss_subs_map[CM_SS_MAIN].stack_id;

  sys_srv_status_e_type prev_srv_ind = SYS_SRV_STATUS_NONE;

  sys_srv_status_e_type new_hdr_srv_status = ss_ptr->info.hdr_srv_status;
  sys_band_class_e_type new_hybrid_active_band =
                                          ss_ptr->info.hybrid_active_band;
  sys_channel_num_type  new_hybrid_active_channel =
                                          ss_ptr->info.hybrid_active_channel;

  sys_time_info_s_type * time_info        = SS_CDMA_TIME_PTR(ss_ptr);

  /* Copy previous service status sent to client
  */

  uint8                    stk_id = cmph_ptr()->ss_subs_map[CM_SS_HYBR_1].stack_id;

  
  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }

  prev_srv_ind = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;

  ss_ptr->hybr_1_srv_status = sys_intl_srv_status_to_actl_srv_status(si_info_ptr->srv_status);

  new_hdr_srv_status = sys_intl_srv_status_to_actl_srv_status(si_info_ptr->srv_status);

 /* Copy band/channel of the current active service */
  new_hybrid_active_band = si_info_ptr->band;
  new_hybrid_active_channel = si_info_ptr->chan;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the service state.
  */
  switch( si_info_ptr->mode )
  {
    case SD_MODE_HDR:

      if( si_info_ptr->usable_status != SD_SYS_USABLE_NOT_OK )
      {
        new_hdr_srv_status = si_info_ptr->srv_status;
      }
      else
      {
        new_hdr_srv_status = SYS_SRV_STATUS_NO_SRV;
        ss_ptr->hybr_1_srv_status   = SYS_SRV_STATUS_NO_SRV;
      }
      /* Update CMSS global for HYBR_1 stack atomically */
      cmss_update_srv_status_for_hybr_1(new_hdr_srv_status,
                                        new_hybrid_active_band,
                                        new_hybrid_active_channel);

      /* Update the roaming status.
      */
      ss_ptr->info.hdr_roam_status =
                              (sys_roam_status_e_type) si_info_ptr->roam;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Get the new system id.
      */
      cmss_map_sd_sid_to_sys_sid( si_info_ptr->mode,
                                  &ss_ptr->info.hdr_sys_id,
                                  &si_info_ptr->sid );

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      /* Update the preferred acquisition indicator.
      */
      ss_ptr->hdr_is_pref_srv_acq      = si_info_ptr->is_pref_srv_acq;
      ss_ptr->hybr_1_is_pref_srv_acq   = si_info_ptr->is_pref_srv_acq;

      /* Update the HDR active protocol
      */
      CM_MSG_HIGH_2("cmss_update_hybr_1_srv_ind: HDR Active Prot changed %d to %d",
                   ss_ptr->info.hdr_active_prot,si_info_ptr->hdr_active_prot);
      ss_ptr->info.hdr_active_prot = si_info_ptr->hdr_active_prot;

      /* Update the HDR personality
      */
      ss_ptr->info.hdr_personality = si_info_ptr->hdr_personality;
      ss_ptr->info.is_hdr_custom_home  = si_info_ptr->is_custom_home;
      ss_ptr->info.latitude= si_info_ptr->mode_info.hdr.latitude;
      ss_ptr->info.longitude= si_info_ptr->mode_info.hdr.longitude;
      ss_ptr->info.mcc = si_info_ptr->mode_info.hdr.hdr_mcc;
      ss_ptr->info.system_type= si_info_ptr->mode_info.hdr.hdr_system_type;

      CM_MSG_HIGH_4("HDR latitude : %d, longitude: %d MCC from hdr : %d, system_type: %d",
	  	            ss_ptr->info.latitude,ss_ptr->info.longitude, ss_ptr->info.mcc,ss_ptr->info.system_type);
     

      /* Update the HDR time
      */
      time_info->sys_mode = SYS_SYS_MODE_NO_SRV;
      if(si_info_ptr->time_info.sys_mode == SYS_SYS_MODE_HDR)
      {
        time_info->sys_mode = SYS_SYS_MODE_HDR;
        time_info->time.hdr_time.lp_sec
           = si_info_ptr->time_info.time.hdr_time.lp_sec;
        time_info->time.hdr_time.ltm_offset
           = si_info_ptr->time_info.time.hdr_time.ltm_offset;
      }



      #ifdef FEATURE_HICPS_STACK_SYNC_UP

      /* Since HDR is acquired, deactivate the GWL stack
      ** from dormant state
      */

      if( cmregprx_get_stack_info_ptr(SD_SS_MAIN)->state == CMREGPRX_STATE_DORMANT
          && si_info_ptr->is_stable_in_svc == TRUE )
      {
        mmoc_cmd_deact_from_dormant( SD_SS_MAIN, SD_SS_MODE_PREF_GWL );
      }

      #endif /* HICPS */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      #ifdef FEATURE_EOOS
      #error code not present
#endif

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case SD_MODE_GSM:
    case SD_MODE_WCDMA:
    case SD_MODE_TDS:


      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SD_MODE_AMPS:
    case SD_MODE_CDMA:
    case SD_MODE_INACT:
    case SD_MODE_MAX:
    default:
      CM_ERR_1( "sd_mode = %d", si_info_ptr->mode);
      /*lint -save -e527 Unreachable
      **     CM_ERR exits when CM_DEBUG is on
      */
      new_hdr_srv_status = SYS_SRV_STATUS_NO_SRV;
      /* Update CMSS global for HYBR_1 stack atomically */
      cmss_update_srv_status_for_hybr_1(new_hdr_srv_status,
                                        new_hybrid_active_band,
                                        new_hybrid_active_channel);

      ss_ptr->hybr_1_srv_status   = SYS_SRV_STATUS_NO_SRV;
      /*lint -restore */
      break;

  } /* switch */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* Update the roaming status.
  */
  ss_ptr->info.hdr_roam_status =
                              (sys_roam_status_e_type) si_info_ptr->roam;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get the new system id.
  */
  cmss_map_sd_sid_to_sys_sid( si_info_ptr->mode,
                              &ss_ptr->info.hdr_sys_id,
                              &si_info_ptr->sid );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the redirection/handoff indicator.
  */
  ss_ptr->hdr_is_redir_or_ho    = si_info_ptr->is_redir_or_ho;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( ( ss_ptr->hdr_srv_inform_uptime == CMSS_INFORM_SRV_CHANGE_INTER_NONE )
       || (ss_ptr->hybr_1_srv_status > prev_srv_ind)

       || (ss_ptr->info.sys_mode != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id_main].sys_mode)
       || ( !cmss_sys_id_match( ss_ptr->new_srv_avl_info[subId].stack_info[stk_id_main].sys_id, ss_ptr->info.sys_id ) &&
            ( ss_ptr->hybr_1_srv_status == prev_srv_ind )
           )
       || is_lmt_srv_timeout_handling
       || (( ss_ptr->hybr_1_srv_status == SYS_SRV_STATUS_SRV ) &&
           (ss_ptr->info.hdr_personality != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_personality) )

     )
  {

    /* uptime is CMSS_INFORM_SRV_CHANGE_INTER_NONE when srv indication
    ** transitions to SRV available from PWR_SAVE or NO_SRV. Clients need
    ** to be informed immediately of service here.
    */


    ss_ptr->hdr_srv_inform_uptime   =
        clk_time + cmss_rat_srv_ind_uptimers.hdr_uptimers.srv_uptimer;


    /* srv_avail_info holds serving system parameters last
    ** reported to clients by
    ** CM_SS_EVENT_SRV_CHANGED. cmss_update_ss_bit_mask ()
    ** computes the change in
    ** parameters that need to be reported to clients.
    */
    ss_ptr->info.changed_fields =
     cmss_get_ss_hdr_info_change(&ss_ptr->info, &ss_ptr->new_srv_avl_info[subId]);

  }
  else
  {
    /* By this time hdr_srv_inform_uptime is active and serving system
    ** parameter change gets informed once in 2 secs only if there is
    ** a change in parameters.
    */
    ss_ptr->info.changed_fields                = 0;
  }

} /* cmss_update_hybr_1_lmtd_srv_ind_info */

#endif

void cmss_update_skip_srv_ind_update(
  boolean  skip_srv_ind_update
)
{

  /* In MERGE/SPLIT scenario, getting SRV_CNF or SRV_IND is not guaranteed from NAS.
        per CM design, serving status was hidden from clients during IRAT and last service
        status was updated to the clients, but in case of back to back MERGE/SPLIT or vice versa
        CM may update the current serving status to the clients, which is not expected so as
        to keep the clients undisturbed*/

  #ifdef FEATURE_MMODE_SC_SGLTE
  if(cmss_ptr()->skip_srv_ind_update != skip_srv_ind_update)
  {
     cmss_is_hybr_gw_operational_skip = cmss_ptr()->info.is_hybr_gw_operational;
  }
  #endif

  cmss_ptr()->skip_srv_ind_update = skip_srv_ind_update;

  CM_MSG_HIGH_3("skip_srv_ind_update %d is_hybr_gw_operational_skip %d is_hybr_gw_operational %d",
       cmss_ptr()->skip_srv_ind_update, cmss_is_hybr_gw_operational_skip,
       cmss_ptr()->info.is_hybr_gw_operational);

}

/*===========================================================================

FUNCTION cmph_map_ss_to_stack_info

DESCRIPTION
  Initializing the phone object.

  This function must be called before the phone object
  is being used, in any way, place, or form.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
  uint8 cmss_map_ss_to_stack_info(cm_ss_e_type ss  )
  {
    uint8 stack_info = cmph_ptr()->ss_subs_map[ss].stack_id ;

    if(stack_info > 1)
    {
      stack_info = 1;
    }

    return stack_info ;

  }

/*===========================================================================

FUNCTION cmss_is_user_plmn_rat_selection_pending

DESCRIPTION
  Checks if cm is waiting on service cnf for user selected plmn plus RAT service request.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if waiting for service cnf
  FALSE otherwise

SIDE EFFECTS
  none

===========================================================================*/

boolean cmss_is_user_plmn_rat_selection_pending(cm_ss_e_type ss)
{
#if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  if(cmregprx_get_stack_info_ptr(ss)->substate == CMREGPRX_SUBSTATE_WAIT_SRV_CNF &&
     cmregprx_get_stack_info_ptr(ss)->last_srv_req.network_selection_mode == SYS_NETWORK_SELECTION_MODE_MANUAL && 
     cmregprx_get_stack_info_ptr(ss)->last_srv_req.parameters.manual.type == REG_CM_SERVICE_REQ_USER_PREFERRED_PLMN_RAT)
  {
    
    return TRUE;
  }
     
#endif
  return FALSE;
}


/*==============================================================================

FUNCTION NAME
  sys_actl_srv_status_to_intl_srv_status

DESCRIPTION

  converts actual srv status to internal srv status.

PARAMETERS

  sys_srv_status_e_type  value   Value that needs to be converted.

RETURN VALUE

  sys_srv_status_e_type  converted srv status.

==============================================================================*/
static sys_srv_status_e_type sys_actl_srv_status_to_intl_srv_status
(
  sys_srv_status_e_type  value
)
{
  switch(value)
  {
  case SYS_SRV_STATUS_NO_SRV:
    return SYS_SRV_STATUS_NO_SRV_INTERNAL;

  case SYS_SRV_STATUS_LIMITED:
    return SYS_SRV_STATUS_LIMITED_INTERNAL;

  case SYS_SRV_STATUS_LIMITED_REGIONAL:
    return SYS_SRV_STATUS_LIMITED_REGIONAL_INTERNAL;

  case SYS_SRV_STATUS_PWR_SAVE:
    return SYS_SRV_STATUS_PWR_SAVE_INTERNAL;
  default:
    return value;
  }
} /* sys_actl_srv_status_to_intl_srv_status */


static int cmss_get_srv_ind_uptimer_value(

  sys_sys_mode_e_type              sys_mode,
        /* Based on this sys_mode to get hold timer value.  */

  boolean                          is_no_srv_uptimer
        /* Return no_srv_uptimer or limited_srv_uptimer */
)
{
  int                        uptimer_value = 0;

  /* Find the uptimer value based on the sys_mode. */
  if (is_no_srv_uptimer)
  {
    /* return no_srv_uptimer for Main stack based on the sys_mode */
    switch (sys_mode)
    {
      case SYS_SYS_MODE_CDMA:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.cdma_uptimers.no_srv_uptimer;
        break;
      }
      case SYS_SYS_MODE_HDR:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.hdr_uptimers.no_srv_uptimer;
        break;
      }
      case SYS_SYS_MODE_GSM:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.gsm_uptimers.no_srv_uptimer;
        break;
      }
      case SYS_SYS_MODE_WCDMA:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.wcdma_uptimers.no_srv_uptimer;
        break;
      }
      case SYS_SYS_MODE_TDS:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.tds_uptimers.no_srv_uptimer;
        break;
      }
      case SYS_SYS_MODE_LTE:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.lte_uptimers.no_srv_uptimer;
        break;
      }
      default:
      {
        CM_MSG_MED_1("Unexpected sys_mode=%d,can't set no_srv_uptimer",
                   sys_mode);
        uptimer_value = 0;
        break;
      }
    }

  }
  else
  {
    /* return limited_srv_uptimer for Main stack based on the sys_mode */
    switch (sys_mode)
    {
      case SYS_SYS_MODE_CDMA:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.cdma_uptimers.srv_uptimer;
        break;
      }
      case SYS_SYS_MODE_HDR:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.hdr_uptimers.srv_uptimer;
        break;
      }
      case SYS_SYS_MODE_GSM:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.gsm_uptimers.srv_uptimer;
        break;
      }
      case SYS_SYS_MODE_WCDMA:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.wcdma_uptimers.srv_uptimer;
        break;
      }
      case SYS_SYS_MODE_TDS:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.tds_uptimers.srv_uptimer;
        break;
      }
      case SYS_SYS_MODE_LTE:
      {
        uptimer_value = cmss_rat_srv_ind_uptimers.lte_uptimers.srv_uptimer;
        break;
      }
      default:
      {
        CM_MSG_MED_1("Unexpected sys_mode=%d,can't set srv_uptimer",
                    sys_mode);
        uptimer_value = 0;
        break;
      }
    }
  }

  return (uptimer_value);

}

/*===========================================================================

FUNCTION cmss_update_no_srv_ind_info

DESCRIPTION
  Update the phone object per the new service indicators.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_no_srv_ind_info(

    cmss_s_type               *ss_ptr,
        /* Pointer to a phone object */

  const sd_si_info_s_type   *si_info_ptr
  /* Pointer to buffer containing new service info information */
  )
{
  sys_band_class_e_type    new_active_band = ss_ptr->info.active_band;
  sys_channel_num_type     new_active_chan = ss_ptr->info.active_channel;


  ss_ptr->is_pref_srv_acq = TRUE;
  ss_ptr->is_stable_in_svc = FALSE;
  cmss_update_srv_status_for_main(SYS_SRV_STATUS_NO_SRV, SYS_SYS_MODE_NO_SRV,
                                  new_active_band, new_active_chan);
  ss_ptr->info.true_srv_status = si_info_ptr->cs_srv_status;
  ss_ptr->main_srv_status = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->info.srv_domain = si_info_ptr->srv_domain;
  ss_ptr->info.current_mcc = CM_INVALID_MOBILE_COUNTRY_CODE;


  /* if NO_SRV, reset the LAC/TAC/RAC info.
  */
  ss_ptr->info.lac             = CMSS_INVALID_LAC_INFO;
  ss_ptr->info.tac             = 0;
  ss_ptr->info.rac_or_mme_code = 0;

  /* Reset Main LTE div duplex */
  ss_ptr->main_div_duplex = SYS_DIV_DUPLEX_UNKNOWN;

  /* Update cell info */
  ss_ptr->info.cell_info.cell_id      = CMSS_INVALID_CELL_ID_INFO;

  ss_ptr->info.cell_info.emerg_access_status        = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;

  /* Here we make cell_srv_ind values to invalid, as this are no more valid
  ** once UE move to NO Service,  and upon regaining of appropriate service,
  ** cell_srv_ind will be sent by LL. Hence no need to retain old value in CM
  */

  ss_ptr->info.cell_srv_ind.hs_ind         = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;

  #ifdef FEATURE_HSPA_CALL_STATUS_IND
  ss_ptr->info.cell_srv_ind.hs_call_status = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
  #endif

  ss_ptr->info.cell_srv_ind.dtm_supp       = SYS_DTM_SUPPORT_NOT_AVAIL;
  ss_ptr->info.cell_srv_ind.egprs_supp     = SYS_EGPRS_SUPPORT_NOT_AVAIL;

  #if defined (FEATURE_LTE_TO_1X)
  if(cmcall_is_there_csfb_call(CM_SS_MAIN,CM_CALL_CSFB_TYPE_1XCSFB,
                                         CM_CALL_ID_INVALID)
                                         == CM_CALL_ID_INVALID)
  {
    ss_ptr->info.is_csfb_call_active = FALSE;
    CM_MSG_HIGH_1("1XCSFB: NO_SRV no CSFB call so make is_csfb_call_active = %d",
                  ss_ptr->info.is_csfb_call_active);
  }
  #endif

  /* Update bsr_in_progress to FALSE when we lose the service */
  ss_ptr->info.bsr_in_progress = FALSE;

} /* cmss_update_no_srv_ind_info */

/*===========================================================================

FUNCTION cmss_update_srv_ind_info

DESCRIPTION
  Update the phone object per the new service indicators.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_srv_ind_info(
  cmss_s_type               *ss_ptr,
  /* Pointer to a phone object */

  const sd_si_info_s_type   *si_info_ptr,
  /* Pointer to buffer containing new service info information */

  boolean is_lmt_srv_timeout_handling
  )
{

  cmph_s_type              *ph_ptr = cmph_ptr();

  sys_srv_status_e_type    prev_srv_status  = SYS_SRV_STATUS_NONE;
  sys_sys_mode_e_type      new_sys_mode = ss_ptr->info.sys_mode;
  sys_srv_status_e_type    new_srv_status = ss_ptr->info.srv_status;
  sys_band_class_e_type    new_active_band = ss_ptr->info.active_band;
  sys_channel_num_type     new_active_chan = ss_ptr->info.active_channel;

  sys_time_info_s_type     *time_info       = SS_CDMA_TIME_PTR(ss_ptr);

  #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  sys_sys_id_s_type        prev_sid = ss_ptr->info.sys_id;
  #endif  /* FEATURE_WCDMA || FEATURE_GSM || defined(FEATURE_CM_LTE)*/

  /* Remember the current System Id. */

  dword                    clk_time = time_get_uptime_secs();

  sys_modem_as_id_e_type   subId    = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;
  uint8                    stk_id = ph_ptr->ss_subs_map[CM_SS_MAIN].stack_id;

  #if defined (FEATURE_MMODE_TRIPLE_SIM)
  cm_mode_pref_e_type    hybr_3_mode_pref          = ph_ptr->hybr_3_stack_info.pref_info.mode_pref;
  #endif


  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }


  /* Reset the no_srv_uptime.
  */
  ss_ptr->no_srv_uptime   = CMSS_NO_SRV_UPTIME_NONE;
  new_sys_mode   = SYS_SYS_MODE_CDMA;

  ss_ptr->info.srv_domain = si_info_ptr->srv_domain;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the CS service status.
  */
  ss_ptr->info.true_srv_status  = si_info_ptr->cs_srv_status;
  /* Update the service status.
  */
  new_srv_status = sys_intl_srv_status_to_actl_srv_status(si_info_ptr->srv_status);
  prev_srv_status         = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;
  ss_ptr->main_srv_status = sys_intl_srv_status_to_actl_srv_status(si_info_ptr->srv_status);


  /* Copy band/channel information
  */
  new_active_band    = si_info_ptr->band;
  new_active_chan = si_info_ptr->chan;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the system mode.
  */
  switch( si_info_ptr->mode )
  {
    case SD_MODE_AMPS:
      new_sys_mode = SYS_SYS_MODE_AMPS;
      cmss_update_srv_status_for_main(new_srv_status, new_sys_mode,
                                      new_active_band, new_active_chan);
      ss_ptr->info.mode_info.cdma_info.srch_win_n = 0;
      ss_ptr->info.mode_info.cdma_info.base_id = 0;
      ss_ptr->info.mode_info.cdma_info.base_lat = 0;
      ss_ptr->info.mode_info.cdma_info.base_long = 0;
      break;

    case SD_MODE_HDR:
      new_sys_mode = SYS_SYS_MODE_HDR;
      ss_ptr->info.mode_info.cdma_info.srch_win_n = 0;
      ss_ptr->info.mode_info.cdma_info.base_id = 0;
      ss_ptr->info.mode_info.cdma_info.base_lat = 0;
      ss_ptr->info.mode_info.cdma_info.base_long = 0;

      /* Update the HDR active protocol
      */
      CM_MSG_HIGH_2("HDR Active Prot changed %d to %d",ss_ptr->info.hdr_active_prot,si_info_ptr->hdr_active_prot);
      ss_ptr->info.hdr_active_prot = si_info_ptr->hdr_active_prot;

      /* Update the HDR active protocol
      */
      ss_ptr->info.hdr_personality = si_info_ptr->hdr_personality;

      ss_ptr->info.is_hdr_custom_home  = si_info_ptr->is_custom_home;

      ss_ptr->info.latitude= si_info_ptr->mode_info.hdr.latitude;
      ss_ptr->info.longitude= si_info_ptr->mode_info.hdr.longitude;
      ss_ptr->info.mcc = si_info_ptr->mode_info.hdr.hdr_mcc;
      ss_ptr->info.system_type= si_info_ptr->mode_info.hdr.hdr_system_type;

      CM_MSG_HIGH_4("HDR latitude : %d, longitude: %d MCC from hdr : %d, system_type: %d ",
	  				ss_ptr->info.latitude, ss_ptr->info.longitude, ss_ptr->info.mcc, ss_ptr->info.system_type);
      
      time_info->sys_mode =  SYS_SYS_MODE_NO_SRV;
      /* Update the HDR time
      */
      if(si_info_ptr->time_info.sys_mode == SYS_SYS_MODE_HDR)
      {
        time_info->sys_mode = SYS_SYS_MODE_HDR;
        time_info->time.hdr_time.lp_sec     =
                          si_info_ptr->time_info.time.hdr_time.lp_sec;
        time_info->time.hdr_time.ltm_offset =
                      si_info_ptr->time_info.time.hdr_time.ltm_offset;
      }

      /* Check if the system is usable
      */
      if( si_info_ptr->usable_status == SD_SYS_USABLE_NOT_OK )
      {

        new_srv_status = SYS_SRV_STATUS_NO_SRV;
        ss_ptr->info.true_srv_status     = SYS_SRV_STATUS_NO_SRV;
        ss_ptr->main_srv_status = SYS_SRV_STATUS_NO_SRV;
        cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = ss_ptr->main_srv_status;
      }
      cmss_update_srv_status_for_main(new_srv_status, new_sys_mode,
                                      new_active_band, new_active_chan);

      break;

    case SD_MODE_CDMA:
      new_sys_mode      = SYS_SYS_MODE_CDMA;
      cmss_update_srv_status_for_main(new_srv_status, new_sys_mode,
                                      new_active_band, new_active_chan);
      ss_ptr->info.mode_info.cdma_info.srch_win_n = si_info_ptr->mode_info.cdma.srch_win_n;
      ss_ptr->info.mode_info.cdma_info.base_id = si_info_ptr->mode_info.cdma.base_id;
      ss_ptr->info.mode_info.cdma_info.base_lat = si_info_ptr->mode_info.cdma.base_lat;
      ss_ptr->info.mode_info.cdma_info.base_long = si_info_ptr->mode_info.cdma.base_long;

      ss_ptr->info.cdma_reg_prd = si_info_ptr->mode_info.cdma.reg_prd;
      ss_ptr->info.geo_sys_idx  = si_info_ptr->geo_sys_idx;
      ss_ptr->info.is_cdma_custom_home = si_info_ptr->is_custom_home;
      ss_ptr->info.height = si_info_ptr->mode_info.cdma.height;
      ss_ptr->info.horiz_uncertainty = si_info_ptr->mode_info.cdma.loc_unc_h;
      ss_ptr->info.vert_uncertainty = si_info_ptr->mode_info.cdma.loc_unc_v;
      CM_MSG_HIGH_3("Base station parms, height:%d, horiz_uncert: %d, vert_uncert: %d ",
               ss_ptr->info.height,ss_ptr->info.horiz_uncertainty,ss_ptr->info.vert_uncertainty);

      /* Update the CDMA time
      */
      time_info->sys_mode =  SYS_SYS_MODE_NO_SRV;
      if(si_info_ptr->time_info.sys_mode == SYS_SYS_MODE_CDMA)
      {
        time_info->sys_mode = SYS_SYS_MODE_CDMA;
        time_info->time.cdma_time.lp_sec
           = si_info_ptr->time_info.time.cdma_time.lp_sec;
        time_info->time.cdma_time.ltm_offset
           = si_info_ptr->time_info.time.cdma_time.ltm_offset;
        time_info->time.cdma_time.daylt_savings
           = si_info_ptr->time_info.time.cdma_time.daylt_savings;

        /* Convert ltm to signed value for use in HPCD
        **
        ** LTM value is stored in
        ** signed format. If 5th bit has 1
        ** sign extend or else copy as it is
        */
        if (time_info->time.cdma_time.ltm_offset & CMSS_LTM_NEG_BIT)
        {
          ss_ptr->ltm_offset =
                (int8)(time_info->time.cdma_time.ltm_offset | CMSS_LTM_NEG_SIGN_EXTN);
        }
        else
        {
          ss_ptr->ltm_offset = (int8)time_info->time.cdma_time.ltm_offset;
        }
        /* Day light savings info */
        ss_ptr->daylt_savings = time_info->time.cdma_time.daylt_savings;
      }
     #if defined (FEATURE_LTE_TO_1X)
      if(cmcall_is_there_csfb_call(CM_SS_MAIN,CM_CALL_CSFB_TYPE_1XCSFB,
                                     CM_CALL_ID_INVALID)
                                     != CM_CALL_ID_INVALID)
      {
        ss_ptr->info.is_csfb_call_active = TRUE;
        CM_MSG_HIGH_1("1XCSFB: setting is_csfb_call_active = %d", ss_ptr->info.is_csfb_call_active);
      }
    else if ( ss_ptr->info.is_csfb_call_active == TRUE)
      {
        ss_ptr->info.is_csfb_call_active = FALSE;
        CM_MSG_HIGH_1("1XCSFB:  no CSFB call so set is_csfb_call_active = %d",
                      ss_ptr->info.is_csfb_call_active);
     }
     #endif
     break;


    case SD_MODE_GPS:
      new_sys_mode      = SYS_SYS_MODE_GPS;
      cmss_update_srv_status_for_main(new_srv_status, new_sys_mode,
                                      new_active_band, new_active_chan);
      break;

    case SD_MODE_GSM:

      new_sys_mode      = SYS_SYS_MODE_GSM;
      cmss_update_srv_status_for_main(new_srv_status, new_sys_mode,
                                      new_active_band, new_active_chan);


      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat W->G, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      ss_ptr->info.cell_srv_ind.hs_ind         = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;

      #ifdef FEATURE_HSPA_CALL_STATUS_IND
      ss_ptr->info.cell_srv_ind.hs_call_status = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #endif

      /* Update LAC and RAC info.
      */
      ss_ptr->info.lac             = si_info_ptr->mode_info.gwl.lac;
      ss_ptr->info.rac_or_mme_code = si_info_ptr->mode_info.gwl.rac_or_mme_code;

      #ifdef FEATURE_MMODE_DUAL_SIM
      if( si_info_ptr->srv_status == SYS_SRV_STATUS_LIMITED &&
          (ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV
          #if defined (FEATURE_MMODE_TRIPLE_SIM) || defined (FEATURE_MMODE_SXLTE_G)
          || ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV
          #endif
          ) &&
          ph_ptr->curr_priority_subs == ph_ptr->main_stack_info.asubs_id &&
          cmph_is_msim())
      {
        /* Dynamic change of priority as priority_sub is in limited
        ** and non-priority sub in full service
        */
       #ifdef FEATURE_MMODE_TRIPLE_SIM
       if( ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV \
            && ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV)
       {
         /* chk which has higher mode pref , make that as curr priority sub */
         if( hybr_3_mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY)
         {
           ph_ptr->curr_priority_subs = ph_ptr->hybr_3_stack_info.asubs_id;
         }
         else
         {
           ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
         }
       }
       else if( ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV )
       {
         ph_ptr->curr_priority_subs = ph_ptr->hybr_3_stack_info.asubs_id;
       }
       else
       #endif
       {
        ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
       }

    /* Update MCS on priority change*/
        CM_MSG_HIGH_1("MAIN : GSM1, Curr Priority Sub:%d", ph_ptr->curr_priority_subs);
        cmph_sp_subs_info_update();

      }
      else if(si_info_ptr->srv_status == SYS_SRV_STATUS_SRV &&
              (ph_ptr->curr_priority_subs == ph_ptr->hybr_2_stack_info.asubs_id
              #ifdef FEATURE_MMODE_TRIPLE_SIM
              || ph_ptr->curr_priority_subs == ph_ptr->hybr_3_stack_info.asubs_id
              #endif
              ) &&
              ph_ptr->priority_subs == ph_ptr->main_stack_info.asubs_id)
      {
        /* User selected priority sub is full srv, switch back priority
        */
        ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;

          /* Update MCS on priority change*/
        CM_MSG_HIGH_1("MAIN : GSM2, Curr Priority Sub:%d", ph_ptr->curr_priority_subs);
        cmph_sp_subs_info_update();
      }
      #endif /* FEATURE_MMODE_DUAL_SIM */

      break;

    case SD_MODE_WCDMA:

      new_sys_mode      = SYS_SYS_MODE_WCDMA;
      cmss_update_srv_status_for_main(new_srv_status, new_sys_mode,
                                      new_active_band, new_active_chan);


      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat G->W, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      {
        sd_si_info_s_type      si_info = {0};

        sd_si_info_ptr_get(SD_SS_MAIN, &si_info);
        /* Reset only when CM & SD are in sync
        */
        if(si_info.mode != SYS_SYS_MODE_GSM)
        {
          ss_ptr->info.cell_srv_ind.dtm_supp    = SYS_DTM_SUPPORT_NOT_AVAIL;
          ss_ptr->info.cell_srv_ind.egprs_supp  = SYS_EGPRS_SUPPORT_NOT_AVAIL;
        }
      }

      /* Update LAC and RAC info.
      */
      ss_ptr->info.lac             = si_info_ptr->mode_info.gwl.lac;
      ss_ptr->info.rac_or_mme_code = si_info_ptr->mode_info.gwl.rac_or_mme_code;

      #ifdef FEATURE_MMODE_DUAL_SIM
      if( si_info_ptr->srv_status == SYS_SRV_STATUS_LIMITED &&
          (ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV
           #if defined (FEATURE_MMODE_TRIPLE_SIM) || defined (FEATURE_MMODE_SXLTE_G)
           || ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV
           #endif
          ) &&
          ph_ptr->curr_priority_subs == ph_ptr->main_stack_info.asubs_id &&
          cmph_is_msim())
      {
        #ifdef FEATURE_MMODE_TRIPLE_SIM
        /* SXLTE_Q */
        if( ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV \
            && ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV)
        {
           /* chk which has higher mode pref , make that as curr priority sub */
           if( hybr_3_mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY)
           {
             ph_ptr->curr_priority_subs = ph_ptr->hybr_3_stack_info.asubs_id;
           }
           else
           {
        ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
           }
         }
         else if( ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV )
         {
           ph_ptr->curr_priority_subs = ph_ptr->hybr_3_stack_info.asubs_id;
         }
         else
         #endif
         {
           ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
         }
          /* Update MCS on priority change*/
        CM_MSG_HIGH_1("MAIN : WCDMA1, Curr Priority Sub:%d", ph_ptr->curr_priority_subs);
        cmph_sp_subs_info_update();

      }
      else if(si_info_ptr->srv_status == SYS_SRV_STATUS_SRV &&
              (ph_ptr->curr_priority_subs == ph_ptr->hybr_2_stack_info.asubs_id
               #ifdef FEATURE_MMODE_TRIPLE_SIM
               || ph_ptr->curr_priority_subs == ph_ptr->hybr_3_stack_info.asubs_id
               #endif
              ) &&
              ph_ptr->priority_subs == ph_ptr->main_stack_info.asubs_id)
      {
        /* User selected priority sub is full srv, switch back priority
        */

        ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;

        /* Update MCS on priority change*/
        CM_MSG_HIGH_1("MAIN : WCDMA2, Curr Priority Sub:%d", ph_ptr->curr_priority_subs);
        cmph_sp_subs_info_update();

      }
      #endif /* FEATURE_MMODE_DUAL_SIM */
      break;

    case SD_MODE_LTE:
      new_sys_mode      = SYS_SYS_MODE_LTE;
      cmss_update_srv_status_for_main(new_srv_status, new_sys_mode,
                                      new_active_band, new_active_chan);

      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat G->L, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      {
        sd_si_info_s_type      si_info = {0};

        sd_si_info_ptr_get(SD_SS_MAIN, &si_info);
        /* Reset only when CM & SD are in sync
        */
        if(si_info.mode != SYS_SYS_MODE_GSM)
        {
          ss_ptr->info.cell_srv_ind.dtm_supp    = SYS_DTM_SUPPORT_NOT_AVAIL;
          ss_ptr->info.cell_srv_ind.egprs_supp  = SYS_EGPRS_SUPPORT_NOT_AVAIL;
        }
      }

      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat W->L, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      ss_ptr->info.cell_srv_ind.hs_ind         = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #ifdef FEATURE_HSPA_CALL_STATUS_IND
      ss_ptr->info.cell_srv_ind.hs_call_status = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #endif

      #ifdef FEATURE_CM_LTE
      /* Update TAC and RAC info.
      */
      ss_ptr->info.tac             = si_info_ptr->mode_info.gwl.tac;
      ss_ptr->info.rac_or_mme_code = si_info_ptr->mode_info.gwl.rac_or_mme_code;
      #endif

      /* Need to add more once LTE system informatin is clarified*/

      /* UE is camped on LTE so reset csfb call status */
       if ( ss_ptr->info.is_csfb_call_active == TRUE)
       {
            /* UE is camped on LTE so reset csfb call status */
         ss_ptr->info.is_csfb_call_active = FALSE;

         CM_MSG_HIGH_1("1XCSFB: moved back to LTE so reset  is_csfb_call_active = %d",
                      ss_ptr->info.is_csfb_call_active);
       }

      break;

    case SD_MODE_TDS:

      new_sys_mode      = SYS_SYS_MODE_TDS;
      cmss_update_srv_status_for_main(new_srv_status, new_sys_mode,
                                      new_active_band, new_active_chan);

      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat G->T, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      {
        sd_si_info_s_type      si_info = {0};

        sd_si_info_ptr_get(SD_SS_MAIN, &si_info);
        /* Reset only when CM & SD are in sync
        */
        if(si_info.mode != SYS_SYS_MODE_GSM)
        {
          ss_ptr->info.cell_srv_ind.dtm_supp    = SYS_DTM_SUPPORT_NOT_AVAIL;
          ss_ptr->info.cell_srv_ind.egprs_supp  = SYS_EGPRS_SUPPORT_NOT_AVAIL;
        }
      }
       /* Update LAC and RAC info.
       */
       ss_ptr->info.lac             = si_info_ptr->mode_info.gwl.lac;
       ss_ptr->info.rac_or_mme_code = si_info_ptr->mode_info.gwl.rac_or_mme_code;

      /* TODO TDS: Update for T+G mode */
      break;

    case SD_MODE_INACT:
    case SD_MODE_MAX:
    default:
      CM_ERR_1( "sd_mode = %d",si_info_ptr->mode);
      /*lint -save -e527 Unreachable
      **     CM_ERR exits when CM_DEBUG is on
      */
      new_sys_mode      = SYS_SYS_MODE_NO_SRV;
      cmss_update_srv_status_for_main(new_srv_status, new_sys_mode,
                                      new_active_band, new_active_chan);
      break;
      /*lint -restore */

  } /* switch( si_info_ptr->mode ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the roaming status.
  */
  ss_ptr->info.roam_status       = (sys_roam_status_e_type) si_info_ptr->roam;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the service domain and capability.
  */
  ss_ptr->info.srv_domain       = si_info_ptr->srv_domain;
  ss_ptr->info.srv_capability   = (sys_srv_domain_e_type) (si_info_ptr->sys_srv_cap);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Get the new system id.
  */
  cmss_map_sd_sid_to_sys_sid( si_info_ptr->mode,
                              &ss_ptr->info.sys_id,
                              &si_info_ptr->sid );

 /* Store the values modified in stats object and inform clients */
 *(&(cmstats_ptr()->prm.cm_info.sys_sel_info.sel_sys)) = *(&(ss_ptr->info.sys_id));

 cmstats_ptr()->prm.cm_info.sys_sel_info.roam_ind =
                       (sys_stat_roam_e_type) ss_ptr->info.roam_status;

 cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK |
                                      SYS_CM_SYS_SEL_INFO_BIT_MASK );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* Update the prl match status.
  */
  ss_ptr->info.is_sys_prl_match = si_info_ptr->is_sys_prl_match;

  /* Update the system forbidden status.
  */
  ss_ptr->info.is_sys_forbidden = si_info_ptr->is_sys_forbidden;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the preferred acquisition indicator.
  */
  if(ss_ptr->is_pref_srv_acq  != si_info_ptr->is_pref_srv_acq)
  {
    ss_ptr->is_pref_srv_acq = si_info_ptr->is_pref_srv_acq;
  }

  if(ss_ptr->is_stable_in_svc  != si_info_ptr->is_stable_in_svc)
  {
    ss_ptr->is_stable_in_svc = si_info_ptr->is_stable_in_svc;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the redirection/handoff indicator.
  */
  ss_ptr->is_redir_or_ho = si_info_ptr->is_redir_or_ho;
  ss_ptr->is_colloc      = si_info_ptr->is_colloc;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
  /* Deals with identifying the current country */

  #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  if (CM_IS_MODE_3GPP (ss_ptr->info.sys_mode))
  {
    cmss_identify_3gpp_serving_country();
  }
  else
  #endif /* CM_GW_SUPPORTED ||  FEATURE_CM_LTE */
  {
    if(ss_ptr->info.sys_mode == SYS_SYS_MODE_CDMA)
    {
      cm_country_code_type current_mcc = cmss_identify_3gpp2_serving_country();
      cmss_identify_3gpp2_mcc_from_prl(&(si_info_ptr->plmn_mcc_list),
                                       current_mcc,
                                       cmss_convert_mcc_ota_to_hpcd(ss_ptr->info.sys_id.id.is95.mcc));
    }
     else if(ss_ptr->info.sys_mode == SYS_SYS_MODE_HDR)
    {
      ss_ptr->info.current_mcc = ss_ptr->current_hdr_mcc;
      cmss_identify_hdr_mcc_from_prl(&(si_info_ptr->plmn_mcc_list),
                                     ss_ptr->info.current_mcc,
                                     ss_ptr->info.mcc);
    }
    CM_MSG_MED_1("current mcc: %d",ss_ptr->info.current_mcc);
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  /* If we got CDMA service and are not doing more preferred acquisitions ,
  ** then make sure GSM/UMTS/LTE stack is no longer in dormant state.
  ** On SC_SVLTE, ensure that the deact from dormant is sent only if
  ** a) not in svlte mode
     b) cmregprx's hybr2 stack is not active
  */
  if( ( new_sys_mode == SYS_SYS_MODE_CDMA ||
        new_sys_mode == SYS_SYS_MODE_HDR
      )
      && si_info_ptr->is_stable_in_svc == TRUE
      && cmregprx_get_stack_info_ptr(SD_SS_MAIN)->state == CMREGPRX_STATE_DORMANT )
   {

      if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
         ss_ptr->info.is_hybr_gw_operational == TRUE)
      {
        cmwcall_send_pdp_abort_req( cmph_map_sd_ss_type_to_cm_ss_type(SD_SS_MAIN));
      }
      else if( cmregprx_get_stack_info_ptr(SD_SS_HYBR_2)->state != CMREGPRX_STATE_ACTIVE )
      {
        /* Send deact cmd to Dormant GWL protocol */
        mmoc_cmd_deact_from_dormant( SD_SS_MAIN, SD_SS_MODE_PREF_GWL );
      }
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update default roaming indicator
  */
  ss_ptr->info.def_roam_ind = si_info_ptr->def_roam_ind;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef CM_GW_SUPPORTED

  /* Check if we got Limited/Full G/W service in a data card */
  /* It is either lu_reject_auto_enabled = TRUE OR
  ** It is data card with ens = TRUE
  */
  if( ( ( ph_ptr->main_stack_info.ens_value       == TRUE  &&
          ph_ptr->main_stack_info.disable_call_type_mask == CM_CALL_TYPE_VOICE_MASK
        )
                              ||
         ph_ptr->lu_reject_auto_enabled
      )
                              &&
     (new_sys_mode   == SYS_SYS_MODE_GSM ||
      new_sys_mode   == SYS_SYS_MODE_WCDMA ||
      new_sys_mode   == SYS_SYS_MODE_TDS)
    )
  {
    if( ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV &&
        (ss_ptr->info.srv_domain == SYS_SRV_DOMAIN_CS_ONLY ||
         ss_ptr->info.srv_domain == SYS_SRV_DOMAIN_CS_PS))
    {
      /* Default the values of regn reject info upon getting Full service
      ** on CS or CS+PS srv domain
      */
      cm_ss_init_reg_reject_info( CM_SS_MAIN, &ss_ptr->info.reg_reject_info );
    }
    else if(ss_ptr->info.true_srv_status == SYS_SRV_STATUS_LIMITED)
    {
      /* True (CS) service status is Limited */
      if(ph_ptr->main_stack_info.pref_info.network_sel_mode_pref ==
                                       CM_NETWORK_SEL_MODE_PREF_MANUAL &&
         ss_ptr->cs_reg_reject_cause == CMSS_MM_REJECT_CAUSE17
        )
      {
        /* Change to Automatic network selection preference */
        if (!cm_ph_cmd_sys_sel_pref_new(NULL,
                                    NULL,
                                    CM_CLIENT_ID_ANONYMOUS,
                                    CM_MODE_PREF_NO_CHANGE,
                                    CM_PREF_TERM_PERMANENT,
                                    0,
                                    CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                    CM_BAND_PREF_NO_CHANGE,
                                    CM_PRL_PREF_NO_CHANGE,
                                    CM_ROAM_PREF_NO_CHANGE,
                                    CM_HYBR_PREF_NO_CHANGE,
                                    CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                    CM_NETWORK_SEL_MODE_PREF_AUTOMATIC,
                                    NULL))
        {
          CM_ERR_0("Unable to change system selection preferences to Automatic mode");
        }
        else
        {
          CM_MSG_HIGH_0(" Moved to Automatic mode due to reject cause 17");

          /* Default the values of regn reject info upon moving to
          ** Automatic network selection mode
          */
          cm_ss_init_reg_reject_info(CM_SS_MAIN, &ss_ptr->info.reg_reject_info );
        }
      }
    }/*if(ss_ptr->info.true_srv_status == SYS_SRV_STATUS_LIMITED)*/
  }
  #endif /* #ifdef CM_GW_SUPPORTED */
  /* If we were initially in no service or if we move from Limited to
  ** Full service, then inform the clients immediately. Or if srv_change timer expires.
  */
  if (ss_ptr->main_srv_inform_uptime == CMSS_INFORM_SRV_CHANGE_INTER_NONE
      || ss_ptr->main_srv_status > prev_srv_status

      || new_sys_mode != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode
      //#ifdef FEATURE_MMODE_SC_SGLTE
      //|| (ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV &&
      //    prev_srv_domain != ss_ptr->info.srv_domain)
      //#endif

      || ( !cmss_sys_id_match( ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_id, ss_ptr->info.sys_id ) &&
           ( ss_ptr->main_srv_status == prev_srv_status ) ) || is_lmt_srv_timeout_handling
      || (( ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV ) && (new_sys_mode == SYS_SYS_MODE_HDR)
            && (ss_ptr->info.hdr_personality != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_personality) )
      || (ss_ptr->info.srv_domain != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_domain)
     )
  {

    /* uptime is CMSS_INFORM_SRV_CHANGE_INTER_NONE when srv indication
    ** transitions to SRV available from PWR_SAVE or NO_SRV. Clients need
    ** to be informed immediately of service here.
    */

    ss_ptr->main_srv_inform_uptime   = clk_time +
      cmss_get_srv_ind_uptimer_value( ss_ptr->info.sys_mode,FALSE);


    /* srv_avail_info holds serving system parameters last reported to clients by
    ** CM_SS_EVENT_SRV_CHANGED. cmss_update_ss_bit_mask () computes the change in
    ** parameters that need to be reported to clients.
    */
    ss_ptr->info.changed_fields =
      cmss_get_ss_main_info_change (&ss_ptr->info, &ss_ptr->new_srv_avl_info[subId],
                                    &ss_ptr->info.changed_fields2);

    CM_MSG_HIGH_2("changed_fields 0x%x 0x%x ",QWORD_HIGH(ss_ptr->info.changed_fields),
                                         QWORD_LOW(ss_ptr->info.changed_fields));
    CM_MSG_HIGH_2("changed_fields2 0x%x 0x%x ",QWORD_HIGH(ss_ptr->info.changed_fields2),
                                         QWORD_LOW(ss_ptr->info.changed_fields2));

    if( cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
        (ss_ptr->info.is_hybr_gw_operational) &&
        ((ss_ptr->hybr_gw_no_srv_uptime == CMSS_NO_SRV_UPTIME_NONE) ||
         (ss_ptr->hybr_gw_srv_inform_uptime == CMSS_INFORM_SRV_CHANGE_INTER_NONE)))
    {
      ss_ptr->info.hybr_gw_changed_fields = 0;
    }


  }
  else
  {
    /* By this time main_srv_inform_uptime is active and serving system
    ** parameter change gets informed once in 2 secs only if there is a change
    ** in parameters.
    */
    CM_MSG_HIGH_0("changed_fields=0");
    ss_ptr->info.changed_fields                = 0;
  }


  /*
  ** If the system identifier has changed, notify CM clients of the
  ** corresponding event.
  */


  /* Do not reset mm info if prev and current mm info are same */

  #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)  
  if (CM_IS_MODE_3GPP(new_sys_mode))
  {  
    CM_MSG_HIGH_2("lac prev %d, new %d",ss_ptr->info.sys_id.id.plmn_lac.lac, prev_sid.id.plmn_lac.lac);
  }
  #endif
  if ( cmss_sys_mm_info_match(ss_ptr, si_info_ptr, SD_SS_MAIN) )
  {
    CM_MSG_HIGH_0 ("Prev and current mm info same. init_mm_info skip");
  }
  else if (CM_IS_MODE_3GPP(new_sys_mode))
  {
    #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
    if ((new_sys_mode != SYS_SYS_MODE_LTE && !cmss_sys_id_match( ss_ptr->info.sys_id, prev_sid)) ||
         (new_sys_mode == SYS_SYS_MODE_LTE && !sys_sys_id_match(ss_ptr->info.sys_id, prev_sid)))
    {
      CM_MSG_HIGH_0("init mm_info sys_id does not match");
    cm_ss_init_mm_information
       ( &ss_ptr->info.mode_info.gw_info.mm_information );
    }
    else
    {
      /*
      ** If we moved from OOS to the same PLMN we were camped onto before
      ** going OOS, we need to restore the MM INFO
      */
      sys_mm_information_s_type                temp_mm_information;
      cm_ss_init_mm_information(&temp_mm_information);
      // Restore only if current mm_info has no valid value
      if (cm_ss_is_mm_information_same(&temp_mm_information, &ss_ptr->info.mode_info.gw_info.mm_information))
      {
        CM_MSG_HIGH_0("restore prev mm_info");
      ss_ptr->info.mode_info.gw_info.mm_information = ss_ptr->info.mode_info.gw_info.prev_mm_information;
    }
    }
    cm_ss_init_mm_information
       ( &ss_ptr->info.mode_info.gw_info.prev_mm_information );
    #endif  /* FEATURE_WCDMA || FEATURE_GSM || defined(FEATURE_CM_LTE)*/
  }

  /*
  ** If sys_mode is changed from CDMA/NO_SRV to G/W/L, restore sim_state to
  ** previous value.
  */
  #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  if ( ((new_sys_mode == SYS_SYS_MODE_GSM) ||
   (new_sys_mode == SYS_SYS_MODE_WCDMA) ||
   (new_sys_mode == SYS_SYS_MODE_LTE))
                             &&
        ((ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode == SYS_SYS_MODE_HDR) ||
        (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode == SYS_SYS_MODE_CDMA) ||
        (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode == SYS_SYS_MODE_NO_SRV)) )
    {
       ss_ptr->info.mode_info.gw_info.sim_state = sd_ss_gw_get_sim_state(SD_SS_MAIN);
    }
  #endif // defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
  #endif //(defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900))

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the bsr_in_progress flag
  */
  if( ss_ptr->info.bsr_in_progress != si_info_ptr->is_pref_srv_acq )
  {
    ss_ptr->info.bsr_in_progress = si_info_ptr->is_pref_srv_acq;
    ss_ptr->info.changed_fields |= CM_SS_BSR_PROGRESS_MASK;
    ss_ptr->new_srv_avl_info[subId].changed_fields_subs |= CM_SS_EVT_BSR_PROGRESS_MASK ;
  }
}  /* !cmss_update_srv_ind_info */


/*===========================================================================

FUNCTION cmss_update_hybr_2_lmtd_srv_ind_info

DESCRIPTION
  Update the phone object per the new service indicators.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_hybr_2_lmtd_srv_ind_info(

  cmss_s_type               *ss_ptr,
    /* Pointer to a ss object */

  const sd_si_info_s_type   *si_info_ptr,
    /* Pointer to buffer containing new service info information */
  boolean is_lmt_srv_timeout_handling

)
{
  sys_sys_id_s_type        prev_sid;
    /* Remember the current System Id. */

  cmph_s_type              *ph_ptr          = cmph_ptr();
    /* Pointer to the PH Object */

  sys_srv_status_e_type    prev_srv_status  = SYS_SRV_STATUS_NONE;

    
  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) ;
    
  uint8                    stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_2);
  
  sys_srv_domain_e_type    prev_srv_domain  = SYS_SRV_DOMAIN_NONE;

  dword                    clk_time = time_get_uptime_secs();

  /* Temporary variables to store new srv parameters, so that they can be
  ** written to CMSS global atomically, as they are being shared outside
  ** CM task */
  sys_sys_mode_e_type   new_gw_sys_mode = ss_ptr->info.gw_sys_mode;
  sys_srv_status_e_type new_gw_srv_status =  ss_ptr->info.gw_srv_status;
  sys_band_class_e_type new_gw_active_band = ss_ptr->info.gw_active_band;
  sys_channel_num_type  new_gw_active_chan = ss_ptr->info.gw_active_channel;


  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }


  prev_srv_domain  = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_domain;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if non-multi-stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  prev_sid              = ss_ptr->info.gw_sys_id;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the CS service status.
  */
  ss_ptr->info.true_gw_srv_status  = si_info_ptr->cs_srv_status;

  /* Update the service status.
  */
  new_gw_srv_status   = sys_intl_srv_status_to_actl_srv_status(si_info_ptr->srv_status);
  prev_srv_status                   = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;
  ss_ptr->hybr_gw_srv_status        = sys_intl_srv_status_to_actl_srv_status(si_info_ptr->srv_status);


  /* Copy band/channel information
  */
  new_gw_active_band    = si_info_ptr->band;
  new_gw_active_chan = si_info_ptr->chan;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_3( "cmss_update_hybr_2_lmtd_srv_ind_info, is_hybr_gw_operational %d, ss_req_id %d, srv_info_req_id %d",
               cmss_ptr()->info.is_hybr_gw_operational,
               ss_ptr->info.sys_sel_pref_req_id,
               si_info_ptr->sys_sel_pref_req_id );

  /* reset value of IMS emerg support */
  if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
     cmss_ptr()->info.is_hybr_gw_operational)
  {
    ss_ptr->info.lte_ims_emerg_avail = SYS_IMS_LTE_EMERG_SUPP_UNKNOWN;
  }

  /* Update the system mode.
  */
  CM_MSG_HIGH_1( "mode %d", si_info_ptr->mode );
  switch( si_info_ptr->mode )
  {
    case SD_MODE_GSM:
      ss_ptr->info.true_gw_srv_status  = si_info_ptr->cs_srv_status;
      new_gw_srv_status       = si_info_ptr->srv_status;
      new_gw_sys_mode         = SYS_SYS_MODE_GSM;

      prev_srv_status = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;

      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat W->G, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      ss_ptr->info.gw_cell_srv_ind.hs_ind  =
                                        SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;

      #ifdef FEATURE_HSPA_CALL_STATUS_IND
      ss_ptr->info.gw_cell_srv_ind.hs_call_status =
                                        SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #endif

      /* Update LAC and RAC info.
      */
      ss_ptr->info.gwl_lac             = si_info_ptr->mode_info.gwl.lac;
      ss_ptr->info.gwl_rac_or_mme_code = si_info_ptr->mode_info.gwl.rac_or_mme_code;

      #ifdef FEATURE_MMODE_DUAL_SIM
      if(cmph_is_msim() &&
         si_info_ptr->srv_status == SYS_SRV_STATUS_LIMITED &&
         (ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
          || ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV
          #endif
         ) &&
         ph_ptr->curr_priority_subs == ph_ptr->hybr_2_stack_info.asubs_id)
      {
        /* Dynamic change of priority as priority_sub is in limited
        ** and non-priority sub in full service
        */

       #ifdef FEATURE_MMODE_TRIPLE_SIM
       /* SXLTE_Q */
       if( ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV \
              && ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV)
       {
        if( ph_ptr->main_stack_info.pref_info.mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY)
        {
          ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;
        }
        else
        {
          ph_ptr->curr_priority_subs = ph_ptr->hybr_3_stack_info.asubs_id;
        }
       }
       else if( ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV )
       {
         ph_ptr->curr_priority_subs = ph_ptr->hybr_3_stack_info.asubs_id;
       }
       else
       #endif
       {
        ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;
       }

        /* Update MCS on priority change*/
            CM_MSG_HIGH_1("SUB2 : GSM2, Curr Priority Sub:%d", ph_ptr->curr_priority_subs);
        cmph_sp_subs_info_update();


      }
      else if(cmph_is_msim() &&
                si_info_ptr->srv_status == SYS_SRV_STATUS_SRV &&
                (ph_ptr->curr_priority_subs == ph_ptr->main_stack_info.asubs_id
                #ifdef FEATURE_MMODE_TRIPLE_SIM
                || ph_ptr->curr_priority_subs == ph_ptr->hybr_3_stack_info.asubs_id
                #endif
                ) &&
                ph_ptr->priority_subs == ph_ptr->hybr_2_stack_info.asubs_id)
      {
        /* User selected priority sub is full srv, switch back priority
        */
        ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
          /* Update MCS on priority change*/
        CM_MSG_HIGH_1("SUB2 : GSM2, Curr Priority Sub:%d", ph_ptr->curr_priority_subs);
        cmph_sp_subs_info_update();
      }
      #endif

      break;

    case SD_MODE_WCDMA:
    case SD_MODE_TDS:                                                         /* TDS now supported on Hybr-2 */
      ss_ptr->info.true_gw_srv_status  = si_info_ptr->cs_srv_status;
      new_gw_srv_status       = si_info_ptr->srv_status;
      new_gw_sys_mode         = si_info_ptr->mode;

      prev_srv_status = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;

      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat G->W or G->T, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      {
        sd_si_info_s_type      si_info = {0};
        sd_si_info_ptr_get(SD_SS_HYBR_2, &si_info);
        /* Reset only when CM & SD are in sync
        */
        if(si_info.mode != SYS_SYS_MODE_GSM)
        {
          CM_MSG_HIGH_0("SET HYBR2 dtm_supp & egprs_supp as NOT AVAIL for W/T");
          ss_ptr->info.gw_cell_srv_ind.dtm_supp    = SYS_DTM_SUPPORT_NOT_AVAIL;
          ss_ptr->info.gw_cell_srv_ind.egprs_supp  = SYS_EGPRS_SUPPORT_NOT_AVAIL;
        }
      }


      /* Update LAC and RAC info.
      */
      ss_ptr->info.gwl_lac             = si_info_ptr->mode_info.gwl.lac;
      ss_ptr->info.gwl_rac_or_mme_code = si_info_ptr->mode_info.gwl.rac_or_mme_code;


      #ifdef FEATURE_MMODE_DUAL_SIM
      if( cmph_is_msim() &&
          si_info_ptr->srv_status == SYS_SRV_STATUS_LIMITED &&
          (ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
           || ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV
           #endif
          ) &&
          ph_ptr->curr_priority_subs == ph_ptr->hybr_2_stack_info.asubs_id)
      {
        /* Dynamic change of priority as priority_sub is in limited
        ** and non-priority sub in full service
        */
        #ifdef FEATURE_MMODE_TRIPLE_SIM
        /* SXLTE_Q */
        if( ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV \
            && ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV)
        {
          if( ph_ptr->main_stack_info.pref_info.mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY)
          {
          ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;
          }
          else
          {
            ph_ptr->curr_priority_subs = ph_ptr->hybr_3_stack_info.asubs_id;
          }
        }
        else if( ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV )
        {
          ph_ptr->curr_priority_subs = ph_ptr->hybr_3_stack_info.asubs_id;
        }
        else
        #endif
        {
        ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;
        }

                    /* Update MCS on priority change*/
        CM_MSG_HIGH_1("SUB2 : WCDMA1, Curr Priority Sub:%d", ph_ptr->curr_priority_subs);
        cmph_sp_subs_info_update();

      }
      else if(cmph_is_msim() &&
              si_info_ptr->srv_status == SYS_SRV_STATUS_SRV &&
              (ph_ptr->curr_priority_subs == ph_ptr->main_stack_info.asubs_id
              #if defined(FEATURE_MMODE_TRIPLE_SIM)
               || ph_ptr->curr_priority_subs == SYS_MODEM_AS_ID_3
               #endif
              ) &&
              ph_ptr->priority_subs == ph_ptr->hybr_2_stack_info.asubs_id)
      {
        /* User selected priority sub is full srv, switch back priority
        */

        ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;

        CM_MSG_HIGH_1("SUB2 : WCDMA2, Curr Priority Sub:%d", ph_ptr->curr_priority_subs);
        /* Update MCS on priority change*/
            cmph_sp_subs_info_update();

      }
      #endif

      break;

    case SD_MODE_LTE:
      ss_ptr->info.true_gw_srv_status  = si_info_ptr->cs_srv_status;
      new_gw_srv_status     = si_info_ptr->srv_status;
      new_gw_sys_mode     = SYS_SYS_MODE_LTE;

      prev_srv_status = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;

      /* Update TAC and RAC info.
      */
      ss_ptr->info.gwl_tac             = si_info_ptr->mode_info.gwl.tac;
      ss_ptr->info.gwl_rac_or_mme_code = si_info_ptr->mode_info.gwl.rac_or_mme_code;

      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat G->L, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */

      {
        sd_si_info_s_type      si_info = {0};
        sd_si_info_ptr_get(SD_SS_HYBR_2, &si_info);
        CM_MSG_HIGH_1("si_info.mode %d", si_info.mode);
        /* Reset only when CM & SD are in sync
        */
        if(si_info.mode != SYS_SYS_MODE_GSM)
        {
          
          ss_ptr->info.gw_cell_srv_ind.dtm_supp    = SYS_DTM_SUPPORT_NOT_AVAIL;
          ss_ptr->info.gw_cell_srv_ind.egprs_supp  = SYS_EGPRS_SUPPORT_NOT_AVAIL;
        }
      }
      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat W->L, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      ss_ptr->info.gw_cell_srv_ind.hs_ind         = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #ifdef FEATURE_HSPA_CALL_STATUS_IND
      ss_ptr->info.gw_cell_srv_ind.hs_call_status = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #endif


      break;

    case SD_MODE_AMPS:
    case SD_MODE_HDR:
    case SD_MODE_CDMA:
    case SD_MODE_GPS:
    case SD_MODE_INACT:
    case SD_MODE_MAX:
    default:
      CM_ERR_1( "sd_mode = %d",si_info_ptr->mode);
      /*lint -save -e527 Unreachable
      **     CM_ERR exits when CM_DEBUG is on
      */
      new_gw_sys_mode      = SYS_SYS_MODE_NO_SRV;
      cmss_update_srv_status_for_hybr_2(new_gw_srv_status,
                                        new_gw_sys_mode,
                                        new_gw_active_band,
                                        new_gw_active_chan);
      break;
      /*lint -restore */

  } /* switch( si_info_ptr->mode ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( si_info_ptr->mode )
  {
    case SD_MODE_GSM:
    case SD_MODE_WCDMA:
    case SD_MODE_TDS:
    case SD_MODE_LTE:

      /* Update the roaming status.
      */
      ss_ptr->info.gw_roam_status       = (sys_roam_status_e_type) si_info_ptr->roam;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Update the service domain and capability.
      */
      ss_ptr->info.gw_srv_domain       = si_info_ptr->srv_domain;
      ss_ptr->info.gw_srv_capability   = (sys_srv_domain_e_type) (si_info_ptr->sys_srv_cap);

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Update the system forbidden status.
      */
      ss_ptr->info.gw_is_sys_forbidden = si_info_ptr->is_sys_forbidden;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Get the new system id.
      */
      cmss_map_sd_sid_to_sys_sid( si_info_ptr->mode,
                                  &ss_ptr->info.gw_sys_id,
                                  &si_info_ptr->sid );

      new_gw_active_band = si_info_ptr->band;
      cmss_update_srv_status_for_hybr_2(new_gw_srv_status,
                                        new_gw_sys_mode,
                                        new_gw_active_band,
                                        new_gw_active_chan);

      if(cmss_is_hybr2_operational())
      {
        if (si_info_ptr->mode == SD_MODE_LTE)
        {

          #if defined(FEATURE_IP_CALL) && defined(FEATURE_LTE)
          cmsds_update_ims_voice_support_on_lte(CM_SS_HYBR_2, si_info_ptr->lte_ims_voice_avail);
          cmsds_update_ims_emerg_support_on_lte(si_info_ptr->lte_ims_emerg_avail);
          #endif

          #ifdef FEATURE_DOMAIN_SELECTION
          /* Handle LTE full service or also limited LTE CS capability */
          if (((SYS_SRV_STATUS_SRV == si_info_ptr->srv_status) ||
               (SYS_LTE_CS_CAPABILITY_LIMITED == si_info_ptr->lte_cs_capability ) ||
               (SYS_EXTEND_SRV_INFO_T3402_STARTED == si_info_ptr->extend_srv_info))
              )
          {
            cmsds_process_srv_ind (CM_SS_HYBR_2, si_info_ptr);
          }
          #endif
        }

        #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH

        /* Handle domain selection service indication */
        if(!cmph_is_subs_feature_mode_srlte(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2)))
        {
          cmsoa_process_domain_selection_srv_ind(si_info_ptr, CM_SS_HYBR_2);
        }
        #endif
      }
      else
      {
        CM_MSG_HIGH_0("CMSOA: ignore srv_ind on HYBR-2 while hybr-2 is disabled");
      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:
      break;
  }

  /* Update the prl match status.
  */
  ss_ptr->info.gw_is_sys_prl_match = si_info_ptr->is_sys_prl_match;

  /* Update the system forbidden status.
  */
  ss_ptr->info.gw_is_sys_forbidden = si_info_ptr->is_sys_forbidden;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the preferred acquisition indicator.
  */
  if(ss_ptr->hybr_gw_is_pref_srv_acq  != si_info_ptr->is_pref_srv_acq)
  {
    ss_ptr->hybr_gw_is_pref_srv_acq = si_info_ptr->is_pref_srv_acq;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update default roaming indicator
  */
  //ss_ptr->info.gw_def_roam_ind = si_info_ptr->def_roam_ind;

  #if defined(CM_GW_SUPPORTED) && defined(FEATURE_MMODE_DUAL_SIM)

  /* Check if we got Limited/Full G/W service in a data card */
  if(((ph_ptr->hybr_2_stack_info.ens_value       == TRUE  &&
      ph_ptr->hybr_2_stack_info.disable_call_type_mask == CM_CALL_TYPE_VOICE_MASK)
                        ||
         ph_ptr->lu_reject_auto_enabled) &&
     (new_gw_sys_mode   == SYS_SYS_MODE_GSM ||
      new_gw_sys_mode   == SYS_SYS_MODE_WCDMA ||
      new_gw_sys_mode   == SYS_SYS_MODE_TDS) &&  /* TDS is now a supported mode on DSDS */
      cmph_is_msim()
    )
  {
    if( ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV &&
        (ss_ptr->info.gw_srv_domain == SYS_SRV_DOMAIN_CS_ONLY ||
         ss_ptr->info.gw_srv_domain == SYS_SRV_DOMAIN_CS_PS))
    {
      /* Default the values of regn reject info upon getting Full service
      ** on CS or CS+PS srv domain
      */
      cm_ss_init_reg_reject_info(CM_SS_HYBR_2, &ss_ptr->info.gw_reg_reject_info );
    }
    else if(ss_ptr->info.true_gw_srv_status == SYS_SRV_STATUS_LIMITED)
    {
      /* True (CS) service status is Limited */
      if(CMPH_SS_NETWORK_SEL_MODE_PREF(subId, ph_ptr) ==
                                       CM_NETWORK_SEL_MODE_PREF_MANUAL &&
         ss_ptr->hybr_gw_cs_reg_reject_cause == CMSS_MM_REJECT_CAUSE17
        )
      {
        /* Change to Automatic network selection preference */
        if (!cm_ph_cmd_sys_sel_pref_per_subs_2(NULL,
                                               NULL,
                                               CM_CLIENT_ID_ANONYMOUS,
                                               ph_ptr->hybr_2_stack_info.asubs_id,
                                               CM_MODE_PREF_NO_CHANGE,
                                               CM_PREF_TERM_PERMANENT,
                                               0,
                                               CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                               CM_BAND_PREF_NO_CHANGE,
                                               CM_BAND_PREF_NO_CHANGE,
                                               CM_BAND_PREF_NO_CHANGE,
                                               CM_PRL_PREF_NO_CHANGE,
                                               CM_ROAM_PREF_NO_CHANGE,
                                               CM_HYBR_PREF_NO_CHANGE,
                                               CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                               CM_NETWORK_SEL_MODE_PREF_AUTOMATIC,
                                               NULL,
                                               0))
        {
          CM_ERR_0("Unable to change system selection preferences to Automatic mode");
        }
        else
        {
          CM_MSG_HIGH_0(" Moved to Automatic mode due to reject cause 17");

          /* Default the values of regn reject info upon moving to
          ** Automatic network selection mode
          */
          cm_ss_init_reg_reject_info( CM_SS_HYBR_2,
                                      &ss_ptr->info.gw_reg_reject_info );
        }
      }
    }/*if(ss_ptr->info.true_srv_status == SYS_SRV_STATUS_LIMITED)*/
  }
  #endif /* #ifdef CM_GW_SUPPORTED */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we were initially in no service or if we move from Limited to
  ** Full service, then inform the clients immediatly.
  */
  if (ss_ptr->hybr_gw_srv_inform_uptime == CMSS_INFORM_SRV_CHANGE_INTER_NONE
      || ss_ptr->hybr_gw_srv_status > prev_srv_status
      || new_gw_sys_mode != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode
      || (ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV &&
          prev_srv_domain != ss_ptr->info.gw_srv_domain &&
          (CMPH_SS_FEATURE_MODE(CM_SS_HYBR_2, ph_ptr) == SYS_SUBS_FEATURE_MODE_SGLTE) )
      || ( !cmss_sys_id_match( ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_id, ss_ptr->info.gw_sys_id ) &&
           ss_ptr->hybr_gw_srv_status == prev_srv_status )
      || ( ss_ptr->info.gw_srv_domain != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_domain )
      || is_lmt_srv_timeout_handling
      || (ss_ptr->info.voice_domain != ss_ptr->new_srv_avl_info[subId].voice_domain)
      || (ss_ptr->info.sms_domain != ss_ptr->new_srv_avl_info[subId].sms_domain)
     )
  {
    /* uptime is CMSS_INFORM_SRV_CHANGE_INTER_NONE when srv indication
    ** transitions to SRV available from PWR_SAVE or NO_SRV. Clients need
    ** to be informed immediately of service here.
    */
    ss_ptr->hybr_gw_srv_inform_uptime   = clk_time +
      cmss_get_srv_ind_uptimer_value( ss_ptr->info.gw_sys_mode,FALSE);


    /* srv_avail_info holds serving system parameters last reported to clients by
    ** CM_SS_EVENT_SRV_CHANGED. cmss_update_ss_bit_mask () computes the change in
    ** parameters that need to be reported to clients.
    */
    ss_ptr->info.hybr_gw_changed_fields =
      cmss_get_ss_hybr_2_info_change (&ss_ptr->info, &ss_ptr->new_srv_avl_info[subId]);

  }
  else
  {
    /* By this time main_srv_inform_uptime is active and serving system
    ** parameter change gets informed once in 2 secs only if there is a change
    ** in parameters.
    */
    ss_ptr->info.hybr_gw_changed_fields                = 0;
  }


  /*
  ** If the system identifier has changed, notify CM clients of the
  ** corresponding event.
  */
  /* Do not reset mm info if prev and current mm info are same */
  if ( cmss_sys_mm_info_match(ss_ptr, si_info_ptr, SD_SS_HYBR_2) )
  {
    CM_MSG_HIGH_0 ("HYBR2: Prev and current mm info same. init_mm_info skip");
  }
  else if( si_info_ptr->mode == SD_MODE_GSM ||
             si_info_ptr->mode == SD_MODE_WCDMA ||
             si_info_ptr->mode == SD_MODE_TDS ||
             si_info_ptr->mode == SD_MODE_LTE
         )
  {
    #if defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE)
    if ((new_gw_sys_mode != SYS_SYS_MODE_LTE && !cmss_sys_id_match( ss_ptr->info.gw_sys_id, prev_sid)) ||
         (new_gw_sys_mode == SYS_SYS_MODE_LTE && !sys_sys_id_match(ss_ptr->info.gw_sys_id, prev_sid)))
    {
      CM_MSG_HIGH_0("init hybr_2 mm_info sys_id does not match");
    cm_ss_init_mm_information
       ( &ss_ptr->info.gw_mode_info.gw_info.mm_information );
    }
    else
    {
       /*
       ** If we moved from OOS to the same PLMN we were camped onto before
       ** going OOS, we need to restore the MM INFO
       */
        sys_mm_information_s_type                temp_mm_information;
        cm_ss_init_mm_information(&temp_mm_information);
       
       // Restore only if current mm_info has no valid value
       if (cm_ss_is_mm_information_same(&temp_mm_information, &ss_ptr->info.gw_mode_info.gw_info.mm_information))
       {
         CM_MSG_HIGH_0("restore hybr_2 prev mm_info");
       ss_ptr->info.gw_mode_info.gw_info.mm_information = ss_ptr->info.gw_mode_info.gw_info.prev_mm_information;
     }
     }
     cm_ss_init_mm_information( &ss_ptr->info.gw_mode_info.gw_info.prev_mm_information );
     
    #endif  /* FEATURE_WCDMA || FEATURE_GSM */
  }
} /* !cmss_update_hybr_2_lmtd_srv_ind_info */

/*===========================================================================

FUNCTION cmss_update_hybr_2_no_srv_ind_info

DESCRIPTION
  Update the phone object per the new service indicators.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmss_update_hybr_2_no_srv_ind_info(

    cmss_s_type               *ss_ptr,
        /* Pointer to a ss object */

    const sd_si_info_s_type   *si_info_ptr
       /* Pointer to buffer containing new service info information */
)
{
    /* Pointer to the PH Object */

  CM_ASSERT( ss_ptr != NULL );
  CM_ASSERT( si_info_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if non-multi-stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->hybr_gw_is_pref_srv_acq = TRUE;

  cmss_update_srv_status_for_hybr_2(si_info_ptr->srv_status,
                                    SYS_SYS_MODE_NO_SRV,
                                    ss_ptr->info.gw_active_band,
                                    ss_ptr->info.gw_active_channel);

  ss_ptr->info.true_gw_srv_status = si_info_ptr->cs_srv_status;
  ss_ptr->hybr_gw_srv_status      = si_info_ptr->srv_status;
  ss_ptr->info.gw_srv_domain      = si_info_ptr->srv_domain;

  /* If there is service on Main, do not reset the current_mcc
  as this is a common variable for both main and hybrid */
  if( !sys_srv_status_is_srv(ss_ptr->info.srv_status) )
  {
    ss_ptr->info.current_mcc        = CM_INVALID_MOBILE_COUNTRY_CODE;
  }

  /* Here we make cell_srv_ind values to invalid, as this are no more valid
  ** once UE move to NO Service,  and upon regaining of appropriate service,
  ** cell_srv_ind will be sent by LL. Hence no need to retain old value in CM
  */
  ss_ptr->info.gw_cell_srv_ind.hs_ind = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;

  /* if NO_SRV, reset the LAC/TAC/RAC info.
  */
  ss_ptr->info.gwl_lac             = CMSS_INVALID_LAC_INFO;
  ss_ptr->info.gwl_tac             = 0;
  ss_ptr->info.gwl_rac_or_mme_code = 0;

  #ifdef FEATURE_CM_LTE
  /* Reset hybr div_duplex info */
  ss_ptr->hybr_gw_div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
  #endif

  ss_ptr->info.gw_cell_info.cell_id = CMSS_INVALID_CELL_ID_INFO;

  ss_ptr->info.gw_cell_info.emerg_access_status        = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;

  #ifdef FEATURE_HSPA_CALL_STATUS_IND
  ss_ptr->info.gw_cell_srv_ind.hs_call_status =
                                             SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
  #endif

  ss_ptr->info.gw_cell_srv_ind.dtm_supp       = SYS_DTM_SUPPORT_NOT_AVAIL;
  ss_ptr->info.gw_cell_srv_ind.egprs_supp     = SYS_EGPRS_SUPPORT_NOT_AVAIL;
}
#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================

FUNCTION cmss_update_hybr_3_lmtd_srv_ind_info

DESCRIPTION
  Update the phone object per the new service indicators.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_hybr_3_lmtd_srv_ind_info(

  cmss_s_type               *ss_ptr,
    /* Pointer to a ss object */

  const sd_si_info_s_type   *si_info_ptr,
    /* Pointer to buffer containing new service info information */
  boolean is_lmt_srv_timeout_handling

)
{
  sys_sys_id_s_type        prev_sid;
    /* Remember the current System Id. */

  #if defined(FEATURE_MMODE_DUAL_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  cmph_s_type              *ph_ptr          = cmph_ptr();
    /* Pointer to the PH Object */
  #endif

  sys_srv_status_e_type    prev_srv_status  = SYS_SRV_STATUS_NONE;

  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_3) ;
    
  uint8                    stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_3);

  dword                    clk_time = time_get_uptime_secs();


  /* Temporary variables to store new srv parameters, so that they can be
  ** written to CMSS global atomically, as they are being shared outside
  ** CM task */
  sys_sys_mode_e_type   new_gw_sys_mode = ss_ptr->info.gw3_sys_mode;
  sys_srv_status_e_type new_gw_srv_status =  ss_ptr->info.gw3_srv_status;
  sys_band_class_e_type new_gw_active_band = ss_ptr->info.gw3_active_band;
  sys_channel_num_type  new_gw_active_chan = ss_ptr->info.gw3_active_channel;



  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if non-multi-stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  prev_sid              = ss_ptr->info.gw3_sys_id;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the CS service status.
  */
  ss_ptr->info.true_gw3_srv_status  = si_info_ptr->cs_srv_status;

  /* Update the service status.
  */
  new_gw_srv_status   = sys_intl_srv_status_to_actl_srv_status(si_info_ptr->srv_status);
  prev_srv_status                   = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;
  ss_ptr->hybr_3_gw_srv_status        = sys_intl_srv_status_to_actl_srv_status(si_info_ptr->srv_status);

  /* Copy band/channel information
  */
  new_gw_active_band    = si_info_ptr->band;
  new_gw_active_chan = si_info_ptr->chan;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* Update the system mode.
  */
  CM_MSG_HIGH_1("hybr3: mode %d", si_info_ptr->mode );
  switch( si_info_ptr->mode )
  {
    case SD_MODE_GSM:
      ss_ptr->info.true_gw3_srv_status  = si_info_ptr->cs_srv_status;
      new_gw_srv_status       = si_info_ptr->srv_status;
      new_gw_sys_mode         = SYS_SYS_MODE_GSM;

      prev_srv_status = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;

      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat W->G, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      ss_ptr->info.gw3_cell_srv_ind.hs_ind  =
                                        SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;

      #ifdef FEATURE_HSPA_CALL_STATUS_IND
      ss_ptr->info.gw3_cell_srv_ind.hs_call_status =
                                        SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #endif

        ss_ptr->info.gw3_lac             = si_info_ptr->mode_info.gwl.lac;
        ss_ptr->info.gw3_rac_or_mme_code = si_info_ptr->mode_info.gwl.rac_or_mme_code;


      if(cmph_is_msim() &&
         si_info_ptr->srv_status == SYS_SRV_STATUS_LIMITED &&
         (ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV
          || ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV
         ) &&
         ph_ptr->curr_priority_subs == subId)
      {
        /* Dynamic change of priority as priority_sub is in limited
        ** and non-priority sub in full service
        */

       if( ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV \
              && ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV)
       {
        if( ph_ptr->main_stack_info.pref_info.mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY)
        {
          ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;
        }
        else
        {
          ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
        }
       }
       else if( ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV )
       {
         ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
       }
       else
       {
        ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;
       }

        /* Update MCS on priority change*/
        CM_MSG_HIGH_2("Current priority_sub_chgd: %d->%d, hybr3-gsm", subId, ph_ptr->curr_priority_subs);
        cmph_sp_subs_info_update();

      }
      else if(cmph_is_msim() &&
                si_info_ptr->srv_status == SYS_SRV_STATUS_SRV &&
                (ph_ptr->curr_priority_subs == ph_ptr->main_stack_info.asubs_id
                || ph_ptr->curr_priority_subs == ph_ptr->hybr_2_stack_info.asubs_id
                ) &&
                ph_ptr->priority_subs == subId)
      {
        CM_MSG_HIGH_2("Current priority_sub_chgd: %d->%d, hybr3-gsm", ph_ptr->curr_priority_subs, subId);

        /* User selected priority sub is full srv, switch back priority
        */
        ph_ptr->curr_priority_subs = subId;

        /* Update MCS on priority change*/
        cmph_sp_subs_info_update();
      }


      break;

    case SD_MODE_WCDMA:
    case SD_MODE_TDS:                                                         /* TDS now supported on Hybr-2 */
      ss_ptr->info.true_gw3_srv_status  = si_info_ptr->cs_srv_status;
      new_gw_srv_status       = si_info_ptr->srv_status;
      new_gw_sys_mode         = si_info_ptr->mode;

      prev_srv_status = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;

      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat G->W or G->T, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      {
        sd_si_info_s_type      si_info = {0};
        sd_si_info_ptr_get(SD_SS_HYBR_3, &si_info);
        /* Reset only when CM & SD are in sync
        */
        if(si_info.mode != SYS_SYS_MODE_GSM)
        {
          CM_MSG_HIGH_0("SET HYBR2 dtm_supp & egprs_supp as NOT AVAIL for W/T");
          ss_ptr->info.gw3_cell_srv_ind.dtm_supp    = SYS_DTM_SUPPORT_NOT_AVAIL;
          ss_ptr->info.gw3_cell_srv_ind.egprs_supp  = SYS_EGPRS_SUPPORT_NOT_AVAIL;
        }
      }


      /* Update LAC and RAC info.
      */
        ss_ptr->info.gw3_lac             = si_info_ptr->mode_info.gwl.lac;
        ss_ptr->info.gw3_rac_or_mme_code = si_info_ptr->mode_info.gwl.rac_or_mme_code;



      #ifdef FEATURE_MMODE_DUAL_SIM
      if( cmph_is_msim() &&
          si_info_ptr->srv_status == SYS_SRV_STATUS_LIMITED &&
          (ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV
           #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
           || ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV
           #endif
          ) &&
          ph_ptr->curr_priority_subs == subId)
      {
        /* Dynamic change of priority as priority_sub is in limited
        ** and non-priority sub in full service
        */

        if( ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV \
            && ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV)
        {
          if( ph_ptr->main_stack_info.pref_info.mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY)
          {
          ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;
          }
          else
          {
            ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
          }
        }
        else if( ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV )
        {
          ph_ptr->curr_priority_subs = ph_ptr->hybr_2_stack_info.asubs_id;
        }
        else
        {
          ph_ptr->curr_priority_subs = ph_ptr->main_stack_info.asubs_id;
        }

        /* Update MCS on priority change*/
        CM_MSG_HIGH_2("Current priority_sub_chgd: %d->%d, hybr3-wcdma/tds", subId, ph_ptr->curr_priority_subs);
        cmph_sp_subs_info_update();

      }
      else if(cmph_is_msim() &&
              si_info_ptr->srv_status == SYS_SRV_STATUS_SRV &&
              (ph_ptr->curr_priority_subs == ph_ptr->main_stack_info.asubs_id
               || ph_ptr->curr_priority_subs == ph_ptr->hybr_2_stack_info.asubs_id
              ) &&
              ph_ptr->priority_subs == subId)
      {
        CM_MSG_HIGH_2("Current priority_sub_chgd: %d->%d, hybr3-wcdma/tds", ph_ptr->curr_priority_subs, subId);

        /* User selected priority sub is full srv, switch back priority
        */
        ph_ptr->curr_priority_subs = subId;

       /* Update MCS on priority change*/
        cmph_sp_subs_info_update();

      }
      #endif

      break;

    case SD_MODE_LTE:
      ss_ptr->info.true_gw3_srv_status  = si_info_ptr->cs_srv_status;
      new_gw_srv_status     = si_info_ptr->srv_status;
      new_gw_sys_mode     = SYS_SYS_MODE_LTE;

      prev_srv_status = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;

      /* Update TAC and RAC info.
      */
        ss_ptr->info.gw3_tac             = si_info_ptr->mode_info.gwl.tac;
        ss_ptr->info.gw3_rac_or_mme_code = si_info_ptr->mode_info.gwl.rac_or_mme_code;


      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat G->L, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      {
        sd_si_info_s_type      si_info = {0};
        sd_si_info_ptr_get(SD_SS_HYBR_3, &si_info);
        /* Reset only when CM & SD are in sync
        */
        if(si_info.mode != SYS_SYS_MODE_GSM)
        {
          CM_MSG_HIGH_0("HYBR3: SET dtm_supp & egprs_supp as NOT AVAIL for LTE");
          ss_ptr->info.gw3_cell_srv_ind.dtm_supp    = SYS_DTM_SUPPORT_NOT_AVAIL;
          ss_ptr->info.gw3_cell_srv_ind.egprs_supp  = SYS_EGPRS_SUPPORT_NOT_AVAIL;
        }
      }
      /* it is required that CM default local copy of cell_srv_ind values during
      ** inter-rat W->L, otherwise we see an unnecessary SS event going from
      ** CM to clients (Default mismatch with local copy).
      */
      CM_MSG_HIGH_0("HYBR3: SET hs_ind & hs_call_status as UNSUPP for LTE");
      ss_ptr->info.gw3_cell_srv_ind.hs_ind         = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #ifdef FEATURE_HSPA_CALL_STATUS_IND
      ss_ptr->info.gw3_cell_srv_ind.hs_call_status = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #endif


      break;

    case SD_MODE_AMPS:
    case SD_MODE_HDR:
    case SD_MODE_CDMA:
    case SD_MODE_GPS:
    case SD_MODE_INACT:
    case SD_MODE_MAX:
    default:
      CM_ERR_1( "sd_mode = %d",si_info_ptr->mode);
      /*lint -save -e527 Unreachable
      **     CM_ERR exits when CM_DEBUG is on
      */
      new_gw_sys_mode      = SYS_SYS_MODE_NO_SRV;
      cmss_update_srv_status_for_hybr_3(new_gw_srv_status,
                                        new_gw_sys_mode,
                                        new_gw_active_band,
                                        new_gw_active_chan);
      break;
      /*lint -restore */

  } /* switch( si_info_ptr->mode ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch( si_info_ptr->mode )
  {
    case SD_MODE_GSM:
    case SD_MODE_WCDMA:
    case SD_MODE_TDS:
    case SD_MODE_LTE:

      /* Update the roaming status.
      */
      ss_ptr->info.gw3_roam_status       = (sys_roam_status_e_type) si_info_ptr->roam;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Update the service domain and capability.
      */
      ss_ptr->info.gw3_srv_domain       = si_info_ptr->srv_domain;
      ss_ptr->info.gw3_srv_capability   = (sys_srv_domain_e_type) (si_info_ptr->sys_srv_cap);

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Update the system forbidden status.
      */
      ss_ptr->info.gw3_is_sys_forbidden = si_info_ptr->is_sys_forbidden;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      /* Get the new system id.
      */
      cmss_map_sd_sid_to_sys_sid( si_info_ptr->mode,
                                  &ss_ptr->info.gw3_sys_id,
                                  &si_info_ptr->sid );

      new_gw_active_band = si_info_ptr->band;
      cmss_update_srv_status_for_hybr_3(new_gw_srv_status,
                                        new_gw_sys_mode,
                                        new_gw_active_band,
                                        new_gw_active_chan);

      if(cmss_is_hybr3_operational())
      {
        if (si_info_ptr->mode == SD_MODE_LTE)
        {

          #if defined(FEATURE_IP_CALL) && defined(FEATURE_LTE)
          cmsds_update_ims_voice_support_on_lte(CM_SS_HYBR_3, si_info_ptr->lte_ims_voice_avail);
          cmsds_update_ims_emerg_support_on_lte(si_info_ptr->lte_ims_emerg_avail);
          #endif

        #ifdef FEATURE_DOMAIN_SELECTION
        /* Handle LTE full service or also limited LTE CS capability */
        if (((SYS_SRV_STATUS_SRV == si_info_ptr->srv_status) ||
             (SYS_LTE_CS_CAPABILITY_LIMITED == si_info_ptr->lte_cs_capability ) ||
             (SYS_EXTEND_SRV_INFO_T3402_STARTED == si_info_ptr->extend_srv_info)) &&
            (si_info_ptr->mode == SD_MODE_LTE))
        {
          cmsds_process_srv_ind (CM_SS_HYBR_3, si_info_ptr);
        }
        #endif
        }

      }

      break;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:
      break;
  }

  /* Update the prl match status.
  */
  ss_ptr->info.gw3_is_sys_prl_match = si_info_ptr->is_sys_prl_match;

  /* Update the system forbidden status.
  */
  ss_ptr->info.gw3_is_sys_forbidden = si_info_ptr->is_sys_forbidden;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the preferred acquisition indicator.
  */
  if(ss_ptr->hybr_3_gw_is_pref_srv_acq  != si_info_ptr->is_pref_srv_acq)
  {
    ss_ptr->hybr_3_gw_is_pref_srv_acq = si_info_ptr->is_pref_srv_acq;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update default roaming indicator
  */
  //ss_ptr->info.gw_def_roam_ind = si_info_ptr->def_roam_ind;

  #if defined(CM_GW_SUPPORTED) && defined(FEATURE_MMODE_DUAL_SIM)

  /* Check if we got Limited/Full G/W service in a data card */
  if(((ph_ptr->hybr_3_stack_info.ens_value       == TRUE  &&
      ph_ptr->hybr_3_stack_info.disable_call_type_mask == CM_CALL_TYPE_VOICE_MASK)
                        ||
         ph_ptr->lu_reject_auto_enabled) &&
     (new_gw_sys_mode   == SYS_SYS_MODE_GSM ||
      new_gw_sys_mode   == SYS_SYS_MODE_WCDMA ||
      new_gw_sys_mode   == SYS_SYS_MODE_TDS) &&  /* TDS is now a supported mode on DSDS */
      cmph_is_msim()
    )
  {
    if( ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV &&
        (ss_ptr->info.gw3_srv_domain == SYS_SRV_DOMAIN_CS_ONLY ||
         ss_ptr->info.gw3_srv_domain == SYS_SRV_DOMAIN_CS_PS))
    {
      /* Default the values of regn reject info upon getting Full service
      ** on CS or CS+PS srv domain
      */
      cm_ss_init_reg_reject_info(CM_SS_HYBR_3, &ss_ptr->info.gw3_reg_reject_info );
    }
    else if(ss_ptr->info.true_gw3_srv_status == SYS_SRV_STATUS_LIMITED)
    {
      /* True (CS) service status is Limited */
      if(CMPH_SS_NETWORK_SEL_MODE_PREF(cmph_map_cm_ss_to_subs(CM_SS_HYBR_3), ph_ptr) ==
                                       CM_NETWORK_SEL_MODE_PREF_MANUAL &&
         ss_ptr->hybr_3_gw_cs_reg_reject_cause == CMSS_MM_REJECT_CAUSE17
        )
      {
        /* Change to Automatic network selection preference */
        if (!cm_ph_cmd_sys_sel_pref_per_subs_2(NULL,
                                               NULL,
                                               CM_CLIENT_ID_ANONYMOUS,
                                               ph_ptr->hybr_3_stack_info.asubs_id,
                                               CM_MODE_PREF_NO_CHANGE,
                                               CM_PREF_TERM_PERMANENT,
                                               0,
                                               CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                               CM_BAND_PREF_NO_CHANGE,
                                               CM_BAND_PREF_NO_CHANGE,
                                               CM_BAND_PREF_NO_CHANGE,
                                               CM_PRL_PREF_NO_CHANGE,
                                               CM_ROAM_PREF_NO_CHANGE,
                                               CM_HYBR_PREF_NO_CHANGE,
                                               CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                               CM_NETWORK_SEL_MODE_PREF_AUTOMATIC,
                                               NULL,
                                               0))
        {
          CM_ERR_0("Hybr3: Unable to change system selection preferences to Automatic mode");
        }
        else
        {
          CM_MSG_HIGH_0("Hybr3: Moved to Automatic mode due to reject cause 17");

          /* Default the values of regn reject info upon moving to
          ** Automatic network selection mode
          */
          cm_ss_init_reg_reject_info( CM_SS_HYBR_3,
                                      &ss_ptr->info.gw3_reg_reject_info );
        }
      }
    }/*if(ss_ptr->info.true_srv_status == SYS_SRV_STATUS_LIMITED)*/
  }
  #endif /* #ifdef CM_GW_SUPPORTED */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

//check with shivnk also
  /* If we were initially in no service or if we move from Limited to
  ** Full service, then inform the clients immediatly.
  */
  if (ss_ptr->hybr_3_gw_srv_inform_uptime == CMSS_INFORM_SRV_CHANGE_INTER_NONE
      || ss_ptr->hybr_3_gw_srv_status > prev_srv_status
      || new_gw_sys_mode != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode
      || ( !cmss_sys_id_match( ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_id, ss_ptr->info.gw3_sys_id ) &&
           ss_ptr->hybr_3_gw_srv_status == prev_srv_status )
      || ( ss_ptr->info.gw3_srv_domain != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_domain )
      || is_lmt_srv_timeout_handling
      || (ss_ptr->info.voice_domain != ss_ptr->new_srv_avl_info[subId].voice_domain)
      || (ss_ptr->info.sms_domain != ss_ptr->new_srv_avl_info[subId].sms_domain)
     )
  {
    /* uptime is CMSS_INFORM_SRV_CHANGE_INTER_NONE when srv indication
    ** transitions to SRV available from PWR_SAVE or NO_SRV. Clients need
    ** to be informed immediately of service here.
    */


    ss_ptr->hybr_3_gw_srv_inform_uptime   = clk_time +
      cmss_get_srv_ind_uptimer_value( ss_ptr->info.gw3_sys_mode,FALSE);


    /* srv_avail_info holds serving system parameters last reported to clients by
    ** CM_SS_EVENT_SRV_CHANGED. cmss_update_ss_bit_mask () computes the change in
    ** parameters that need to be reported to clients.
    */
    ss_ptr->info.gw3_changed_fields =
      cmss_get_ss_hybr_3_info_change (&ss_ptr->info, &ss_ptr->new_srv_avl_info[subId]);

  }
  else
  {
    /* By this time main_srv_inform_uptime is active and serving system
    ** parameter change gets informed once in 2 secs only if there is a change
    ** in parameters.
    */
    ss_ptr->info.gw3_changed_fields                = 0;
  }


  /*
  ** If the system identifier has changed, notify CM clients of the
  ** corresponding event.
  */
  /* Do not reset mm info if prev and current mm info are same */
  if ( cmss_sys_mm_info_match(ss_ptr, si_info_ptr, SD_SS_HYBR_3) )
  {
    CM_MSG_HIGH_0 ("HYBR3: Prev and current mm info same. init_mm_info skip");
  }
  else if( si_info_ptr->mode == SD_MODE_GSM ||
             si_info_ptr->mode == SD_MODE_WCDMA ||
             si_info_ptr->mode == SD_MODE_TDS ||
             si_info_ptr->mode == SD_MODE_LTE
         )
  {
    #if defined(CM_GW_SUPPORTED)
    if (!cmss_sys_id_match( ss_ptr->info.gw3_sys_id, prev_sid))
    {
    cm_ss_init_mm_information
       ( &ss_ptr->info.gw3_mode_info.gw_info.mm_information );
    }
    else
    {
       /*
       ** If we moved from OOS to the same PLMN we were camped onto before
       ** going OOS, we need to restore the MM INFO
       */
        sys_mm_information_s_type                temp_mm_information;
        cm_ss_init_mm_information(&temp_mm_information);
       
       // Restore only if current mm_info has no valid value
       if (cm_ss_is_mm_information_same(&temp_mm_information, &ss_ptr->info.gw3_mode_info.gw_info.mm_information))
       {
         CM_MSG_HIGH_0("restore hybr_3 prev mm_info");
       ss_ptr->info.gw3_mode_info.gw_info.mm_information = ss_ptr->info.gw3_mode_info.gw_info.prev_mm_information;
     }
     }
     cm_ss_init_mm_information( &ss_ptr->info.gw3_mode_info.gw_info.prev_mm_information );

    #endif  /* FEATURE_WCDMA || FEATURE_GSM */
  }
} /* !cmss_update_hybr_3_lmtd_srv_ind_info */


/*===========================================================================

FUNCTION cmss_update_hybr_3_no_srv_ind_info

DESCRIPTION
  Update the phone object per the new service indicators.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmss_update_hybr_3_no_srv_ind_info(

    cmss_s_type               *ss_ptr,
        /* Pointer to a ss object */

    const sd_si_info_s_type   *si_info_ptr
       /* Pointer to buffer containing new service info information */
)
{
    /* Pointer to the PH Object */

  CM_ASSERT( ss_ptr != NULL );
  CM_ASSERT( si_info_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if non-multi-stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->hybr_3_gw_is_pref_srv_acq = TRUE;

  cmss_update_srv_status_for_hybr_3(si_info_ptr->srv_status,
                                    SYS_SYS_MODE_NO_SRV,
                                    ss_ptr->info.gw3_active_band,
                                    ss_ptr->info.gw3_active_channel);

  ss_ptr->info.true_gw3_srv_status = si_info_ptr->cs_srv_status;
  ss_ptr->hybr_3_gw_srv_status      = si_info_ptr->srv_status;
  ss_ptr->info.gw3_srv_domain      = si_info_ptr->srv_domain;

  /* If there is service on Main, do not reset the current_mcc
  as this is a common variable for both main and hybrid */
  if( !sys_srv_status_is_srv(ss_ptr->info.srv_status) )
  {
    ss_ptr->info.current_mcc        = CM_INVALID_MOBILE_COUNTRY_CODE;
  }

  ss_ptr->info.gw3_lac             = CMSS_INVALID_LAC_INFO;
  ss_ptr->info.gw3_tac             = 0;
  ss_ptr->info.gw3_rac_or_mme_code = 0;


  /* Here we make cell_srv_ind values to invalid, as this are no more valid
  ** once UE move to NO Service,  and upon regaining of appropriate service,
  ** cell_srv_ind will be sent by LL. Hence no need to retain old value in CM
  */
  ss_ptr->info.gw3_cell_srv_ind.hs_ind = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;

  /* if NO_SRV, reset the LAC/TAC/RAC info.
  */
  ss_ptr->info.gwl_lac             = CMSS_INVALID_LAC_INFO;
  ss_ptr->info.gwl_tac             = 0;
  ss_ptr->info.gwl_rac_or_mme_code = 0;

  #ifdef FEATURE_CM_LTE
  /* Reset hybr div_duplex info */
  ss_ptr->gw3_div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
  #endif

  ss_ptr->info.gw3_cell_info.cell_id = CMSS_INVALID_CELL_ID_INFO;

  ss_ptr->info.gw3_cell_info.emerg_access_status        = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;



  #ifdef FEATURE_HSPA_CALL_STATUS_IND
  ss_ptr->info.gw3_cell_srv_ind.hs_call_status =
                                             SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
  #endif

  ss_ptr->info.gw3_cell_srv_ind.dtm_supp       = SYS_DTM_SUPPORT_NOT_AVAIL;
  ss_ptr->info.gw3_cell_srv_ind.egprs_supp     = SYS_EGPRS_SUPPORT_NOT_AVAIL;
}

#endif

static char* cmss_strchr(const char* str, char c)
{
  int i = 0;

  if( NULL == str)
  {
    return NULL;
  }
  while(str[i] != '\0')
  {
    if(str[i] == c)
    {
      return (char *)str + i;
    }
    i++;
  }
  return NULL;
}

//convert the string to number
static int cmss_atoi(const char *str)
{
  int num = 0, i = 0;

  if( NULL == str)
  {
    return 0;
  }
  while(str[i] != '\0')
  {
    if(str[i] >= '0' && str[i] <= '9')
    {
      num = num * 10 + (str[i] - '0');
      i++;
    }
    else
    {
      break;
    }
  }
  return num;
}

/*===========================================================================

FUNCTION cmss_set_default_rat_srv_ind_uptimers

DESCRIPTION
  Set the default values for the RAT-based service indication uptimers.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_set_default_rat_srv_ind_uptimers(void)
{
  CM_MSG_MED_0("Set default values for RAT-based srv ind uptimers");

  cmss_rat_srv_ind_uptimers.is_valid = TRUE;

  cmss_rat_srv_ind_uptimers.cdma_uptimers.no_srv_uptimer  = 4;
  cmss_rat_srv_ind_uptimers.cdma_uptimers.srv_uptimer     = 2;
  cmss_rat_srv_ind_uptimers.hdr_uptimers.no_srv_uptimer   = 20;
  cmss_rat_srv_ind_uptimers.hdr_uptimers.srv_uptimer      = 5;
  cmss_rat_srv_ind_uptimers.gsm_uptimers.no_srv_uptimer   = 4;
  cmss_rat_srv_ind_uptimers.gsm_uptimers.srv_uptimer      = 2;
  cmss_rat_srv_ind_uptimers.wcdma_uptimers.no_srv_uptimer = 4;
  cmss_rat_srv_ind_uptimers.wcdma_uptimers.srv_uptimer    = 2;
  cmss_rat_srv_ind_uptimers.tds_uptimers.no_srv_uptimer   = 8;
  cmss_rat_srv_ind_uptimers.tds_uptimers.srv_uptimer      = 4;
  cmss_rat_srv_ind_uptimers.lte_uptimers.no_srv_uptimer   = 16;
  cmss_rat_srv_ind_uptimers.lte_uptimers.srv_uptimer      = 4;
}

/* CMEFS_RAT_SRV_IND_TIMER_VALUES
**
** Format: CDMANSTV:CDMALSTV:HDRNSTV:HDRLSTV:GSMNSTV:GSMLSTV:WCDMANSTV:WCDMALSTV:TDSNSTV:TDSLSTV:LTENSTV:LTELSTV
**
** CDMANSTV   : cdma no_srv_timer_value
** CDMALSTV   : cdma lmt_srv_timer_value
** HDRNSTV    : hdr no_srv_timer_value
** HDRLSTV    : hdr lmt_srv_timer_value
** GSMNSTV    : gsm no_srv_timer_value
** GSMLSTV    : gsm lmt_srv_timer_value
** WCDMANSTV  : wcdma no_srv_timer_value
** WCDMALSTV  : wcdma lmt_srv_timer_value
** TDSNSTV    : tds no_srv_timer_value
** TDSLSTV    : tds lmt_srv_timer_value
** LTENSTV    : lte no_srv_timer_value
** LTELSTV    : lte lmt_srv_timer_value
*/
static void cmss_read_rat_srv_ind_uptimers(void)
{
  char srv_ind_timer_values_str[64];
  int32  size = sizeof(srv_ind_timer_values_str);

  if(cmefs_read(CMEFS_RAT_SRV_IND_TIMER_VALUES, (byte*)srv_ind_timer_values_str, &size))
  {
    char *num_str_ptr = srv_ind_timer_values_str;
    int  timer_values[RAT_TIMER_VALUES_COUNT] = {0};
    int num_index = 0;

    while(num_str_ptr && num_index < RAT_TIMER_VALUES_COUNT)
    {
      timer_values[num_index++] =  cmss_atoi(num_str_ptr);
      num_str_ptr = cmss_strchr(num_str_ptr, ':');
      if(num_str_ptr)
      {
        //skip ':'
        num_str_ptr = num_str_ptr + 1;
      }
    }

    if(num_index == RAT_TIMER_VALUES_COUNT)
    {
      cmss_rat_srv_ind_uptimers.is_valid = TRUE;
      cmss_rat_srv_ind_uptimers.cdma_uptimers.no_srv_uptimer = timer_values[0];
      cmss_rat_srv_ind_uptimers.cdma_uptimers.srv_uptimer = timer_values[1];
      cmss_rat_srv_ind_uptimers.hdr_uptimers.no_srv_uptimer = timer_values[2];
      cmss_rat_srv_ind_uptimers.hdr_uptimers.srv_uptimer = timer_values[3];
      cmss_rat_srv_ind_uptimers.gsm_uptimers.no_srv_uptimer = timer_values[4];
      cmss_rat_srv_ind_uptimers.gsm_uptimers.srv_uptimer = timer_values[5];
      cmss_rat_srv_ind_uptimers.wcdma_uptimers.no_srv_uptimer = timer_values[6];
      cmss_rat_srv_ind_uptimers.wcdma_uptimers.srv_uptimer = timer_values[7];
      cmss_rat_srv_ind_uptimers.tds_uptimers.no_srv_uptimer = timer_values[8];
      cmss_rat_srv_ind_uptimers.tds_uptimers.srv_uptimer = timer_values[9];
      cmss_rat_srv_ind_uptimers.lte_uptimers.no_srv_uptimer = timer_values[10];
      cmss_rat_srv_ind_uptimers.lte_uptimers.srv_uptimer = timer_values[11];
    }
  }
  else
  {
    cmss_rat_srv_ind_uptimers.is_valid = FALSE;

  }
}

/*===========================================================================

FUNCTION cmss_get_sid_mcc_assoc_ptr

DESCRIPTION
  Returns pointer to user selected sid -> mcc association table.

DEPENDENCIES
 None

RETURN VALUE
  TRUE  if sys_id are equal
  FALSE otherwise.

SIDE EFFECTS
  None.
===========================================================================*/
static cmss_sid_mcc_assoc_tbl_s_type *cmss_get_sid_mcc_assoc_ptr ( void )
{
  /** Holds user selected sid to mcc mapping
  */
  static cmss_sid_mcc_assoc_tbl_s_type cmss_sid_to_mcc_map_tbl;

  return &cmss_sid_to_mcc_map_tbl;

}


/* Note that miscellaneous functions (as opposed to serving system object
** functions) do NOT take a pointer to a serving system object as their
** first parameter. As a result these functions aren't capable of changing
** the serving system state nor do they have a lasting effect beyond their
** returned value.
*/



#ifdef FEATURE_CALL_THROTTLE
/*===========================================================================

FUNCTION cmss_misc_is_sys_id_equal

DESCRIPTION
  This function checks to see it two sys_ids are equal

DEPENDENCIES
 None

RETURN VALUE
  TRUE  if sys_id are equal
  FALSE otherwise.

SIDE EFFECTS
  None.
===========================================================================*/
/*lint -esym(528, cmss_misc_is_sys_id_equal) not referenced */
/*
** called when FEATURE_CALL_THROTTLE on
*/
static boolean cmss_misc_is_sys_id_equal
(
  sys_sys_id_s_type sys_id1,

  sys_sys_id_s_type sys_id2,
    /* The sys_ids to compare
    */

  sys_band_class_e_type band_class1,

  sys_band_class_e_type band_class2,
    /* Band class information
    */

  uint16   packet_zone1,

  uint16   packet_zone2
    /* The packet zone information
    */
)
{
  if( sys_id1.id_type != sys_id2.id_type )
    return FALSE;

  switch( sys_id1.id_type )
  {
    case SYS_SYS_ID_TYPE_UNDEFINED:
    {
      return FALSE;
    }

    case SYS_SYS_ID_TYPE_IS95:
    /* IS-95 system ID
    */
      if( band_class1 != band_class2 || packet_zone1 != packet_zone2 )
      {
        return FALSE;
      }
      if(sys_id1.id.is95.nid == SD_WILDCARD_NID)
      {
        sys_id2.id.is95.nid = SD_WILDCARD_NID;
      }
      else if(sys_id2.id.is95.nid == SD_WILDCARD_NID)
      {
        sys_id1.id.is95.nid = SD_WILDCARD_NID;
      }
      return(cmss_sys_id_match(sys_id1,sys_id2));

    case SYS_SYS_ID_TYPE_IS856:
      if( band_class1 != band_class2 )
      {
        return FALSE;
      }
      return(cmss_is856_sys_id_match(sys_id1,sys_id2));

    default:
      return FALSE;

  }/* switch(sys_id1.id_type) */

}/* cmss_misc_is_sys_id_equal */
#endif /* FEATURE_CALL_THROTTLE */

#ifdef FEATURE_CALL_THROTTLE

/*===========================================================================

FUNCTION cmss_orig_thr_tbl_ptr

DESCRIPTION
  Return a pointer to the origination table.

DEPENDENCIES
  none

RETURN VALUE
  Pointer to the origination throttle table

SIDE EFFECTS
  none

===========================================================================*/
static cmss_orig_thr_table_s_type* cmss_orig_thr_tbl_init
(
    void
)
{
  static cmss_orig_thr_table_s_type cmss_orig_thr_tbl;
  int q_counter = 0;

  cmss_orig_thr_table_q_type *cur_ptr = NULL;
  cmss_orig_thr_table_q_type *next_ptr = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  q_counter = q_cnt(&(cmss_orig_thr_tbl.cmss_orig_thr_q));

  if( q_counter > 0)
  {
    // delete all the items from the queue
    cur_ptr = q_check(&(cmss_orig_thr_tbl.cmss_orig_thr_q));
    if( NULL == cur_ptr )
    {
      sys_err_fatal_null_ptr_exception();
    }

    while((q_counter > 0) && (cur_ptr != NULL))
    {

      next_ptr = q_next(&(cmss_orig_thr_tbl.cmss_orig_thr_q), &(cur_ptr->link));
#ifdef FEATURE_Q_NO_SELF_QPTR
      q_delete( &(cmss_orig_thr_tbl.cmss_orig_thr_q), &cur_ptr->link );
#else
      q_delete( &cur_ptr->link );
#endif

    (void) memset( &cur_ptr->cmss_orig_thr_tbl.orig_call_info.mode_info, 0,
                 sizeof( cm_ss_orig_thr_ss_info_u_type ));

     // cm_mem_free( cur_ptr);

      q_counter--;
      cur_ptr = next_ptr ;
    } /* end while */
  }

  // Initialize the cmss_orig_thr_q
  (void) q_init( &(cmss_orig_thr_tbl.cmss_orig_thr_q) );

  return &cmss_orig_thr_tbl;

}/* cmss_orig_thre_tbl_ptr */

#endif /* FEATURE_CALL_THROTTLE */


#ifdef FEATURE_BCMCS
/*===========================================================================

FUNCTION cmss_compute_bcmcs_srv_status

DESCRIPTION
  Computes the BCMCS service status based on the BCMCS supported flag and the
  service status of the protocol (CDMA, HDR, etc).

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  Enum value corresponding to the BCMCS service status

SIDE EFFECTS
  None.
===========================================================================*/
static sys_bcmcs_srv_status_e_type cmss_compute_bcmcs_srv_status(
  boolean                 bcmcs_srv_supported,
  /* BCMCS supported.
  */

  sys_srv_status_e_type   prot_srv_status
  /* Service status of the protocol.
  */
)
{
  return ( (bcmcs_srv_supported && (prot_srv_status == SYS_SRV_STATUS_SRV))
           ? SYS_BCMCS_SRV_STATUS_SRV : SYS_BCMCS_SRV_STATUS_NO_SRV );
}
#endif /* FEATURE_BCMCS */

#ifdef FEATURE_CALL_THROTTLE
/*===========================================================================

FUNCTION cmss_orig_thr_get_orig_tbl_entry

DESCRIPTION
  This returns the entry for the sys_id if it is present, otherwise it
  returns an Invalid sys_id

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  Pointer to the entry if found,
  NULL otherwise

SIDE EFFECTS
  None.
===========================================================================*/
static cmss_orig_thr_table_q_type* cmss_orig_thr_get_orig_tbl_entry
(
  cmss_orig_thr_table_s_type *thr_tbl_ptr,
    /* Pointer to the origination throttle table
    */

  sys_sys_id_s_type           sys_id,
    /* The sys_id which is to be searched in the throttle table
    */

  sys_band_class_e_type       band_class,
     /* The band class
     */

  uint16                      packet_zone
     /* The packet zone id
     */
)
{


  int q_counter = 0;

  cmss_orig_thr_table_q_type  *q_item_ptr = NULL;

  if(thr_tbl_ptr == NULL )
  {
    sys_err_fatal_null_ptr_exception();
  }

  if(thr_tbl_ptr->num_valid_entries == 0)
  {
    return NULL;
  }

  q_counter = q_cnt(&(thr_tbl_ptr->cmss_orig_thr_q ));
  if(  q_counter  > 0)
  {
    q_item_ptr = q_check(&(thr_tbl_ptr->cmss_orig_thr_q) );
    if( NULL == q_item_ptr )
    {
      sys_err_fatal_null_ptr_exception();
    }
  }

  for(; (q_counter > 0) && (q_item_ptr != NULL); q_counter--)
  {
    if( cmss_misc_is_sys_id_equal(
        q_item_ptr->cmss_orig_thr_tbl.orig_call_info.sys_id,
        sys_id,
        q_item_ptr->cmss_orig_thr_tbl.orig_call_info.mode_info.cdma_info.band_class,
        band_class,
        q_item_ptr->cmss_orig_thr_tbl.orig_call_info.mode_info.cdma_info.packet_zone,
        packet_zone ) )
    {

       /* Found a match, return the entry
      */
      return( q_item_ptr);

     } /* if(cmss_misc_is_sys_id_equal */

    q_item_ptr = q_next(&(thr_tbl_ptr->cmss_orig_thr_q), &(q_item_ptr->link));

  }/* for(i =0 , i < ARR ... )*/

  return NULL;
} /* cmss_orig_thr_get_orig_tbl_entry */
#endif /* FEATURE_CALL_THROTTLE */


/*===========================================================================

FUNCTION cmss_info_alloc_new

DESCRIPTION
 Allocate a serving system info buffer.

DEPENDENCIES
  none

RETURN VALUE
  Pointer to allocated serving system info buffer.

SIDE EFFECTS
  none

===========================================================================*/
static cm_mm_msim_ss_info_s_type  *cmss_info_alloc_new( void )
{
  cm_mm_msim_ss_info_s_type  *cmss_info_ptr;


   /*
  ** Dynamically allocate a sups info object
  */
  cmss_info_ptr = (cm_mm_msim_ss_info_s_type *)cm_mem_malloc(
                                          sizeof(cm_mm_msim_ss_info_s_type));

  return cmss_info_ptr;
} /* cmss_info_alloc() */



/*===========================================================================

FUNCTION cmss_info_alloc

DESCRIPTION
 Allocate a serving system info buffer.

DEPENDENCIES
  none

RETURN VALUE
  Pointer to allocated serving system info buffer.

SIDE EFFECTS
  none

===========================================================================*/
static cm_mm_ss_info_s_type  *cmss_info_alloc( void )
{
  cm_mm_ss_info_s_type  *cmss_info_ptr;

   /*
  ** Dynamically allocate a sups info object
  */
  cmss_info_ptr = (cm_mm_ss_info_s_type *)cm_mem_malloc(
                                          sizeof(cm_mm_ss_info_s_type));

  return cmss_info_ptr;
} /* cmss_info_alloc() */


/*===========================================================================

FUNCTION cmss_info_get_new

DESCRIPTION
  Copy the current serving system state information into a specified buffer.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  TRUE if serving system information is valid, FALSE otherwise.

  Note that serving system information only becomes valid after cmss_init()
  returns.

SIDE EFFECTS
  none

===========================================================================*/
static boolean cmss_info_get_new(

    cm_mm_msim_ss_info_s_type    *ss_info_ptr,
        /* Copy serving system state info into this buffer */

    const cm_mm_msim_ss_info_s_type    *base_ss_info_ptr,
        /* Base ss_info that gets copied into ss_info_ptr. Can be either
        ** cmss.info OR cmss.srv_avail_info
        */
    sys_modem_as_id_e_type   as_id_info
)
{

  uint8                    index = 0 ;

  #ifdef FEATURE_HDR_HANDOFF
  sys_sys_mode_e_type     cur_idm;
  sys_sys_mode_e_type     prev_idm;
  #endif // FEATURE_HDR_HANDOFF

  cmss_s_type          *ss_ptr = cmss_ptr();
      /* Point at serving system object */

  #ifdef FEATURE_CALL_THROTTLE
  cmss_orig_thr_table_q_type* tbl_entry_ptr;
  #endif /* FEATURE_CALL_THROTTLE */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );
  CM_ASSERT( ss_info_ptr != NULL );

  /* Verify that object was properly initialized.
  */
  CM_ASSERT( CM_INIT_CHECK(ss_ptr->init_mask) );


  #ifdef FEATURE_HDR_HYBRID
  {

  CM_ASSERT( BETWEEN(base_ss_info_ptr->stack_info[cmph_ptr()->ss_subs_map[CM_SS_HYBR_1].stack_id].srv_status,
                     SYS_SRV_STATUS_NONE,
                     SYS_SRV_STATUS_MAX) );

  CM_ASSERT( BETWEEN(base_ss_info_ptr->stack_info[cmph_ptr()->ss_subs_map[CM_SS_HYBR_1].stack_id].sys_mode,
                     SYS_SYS_MODE_NONE,
                     SYS_SYS_MODE_MAX) );
  }
  #endif /* FEATURE_HDR_HYBRID */

  #ifdef FEATURE_HDR_HANDOFF
  /* On and just after power up, as long as
     si_info.is_pref_srv_acq == TRUE,
     CM SS IDM will remain in CMSSIDM_STATE_NONE,
     with prev_idm == curr_idm == SYS_SYS_MODE_NONE.
     Also on transition from IDM_NONE to IDM_MAIN state,
     prev_idm will be SYS_SYS_MODE_NONE
  */
  cur_idm  = cmssidm_get_curr_idm();
  prev_idm = cmssidm_get_prev_idm();
  CM_ASSERT( cur_idm >= SYS_SYS_MODE_NONE &&
             cur_idm <  SYS_SYS_MODE_MAX );
  CM_ASSERT( prev_idm >= SYS_SYS_MODE_NONE &&
             prev_idm <  SYS_SYS_MODE_MAX );
  #endif // FEATURE_HDR_HANDOFF

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


 // ss_info_ptr->no_of_stacks = base_ss_info_ptr->no_of_stacks ;


  if(cmph_ptr()->subs_feature_mode[as_id_info] == SYS_SUBS_FEATURE_MODE_SGLTE)
  {
    ss_info_ptr->number_of_stacks = 2 ;
  }
  else if(cmph_is_subs_feature_mode_1x_sxlte(as_id_info))
  {
    ss_info_ptr->number_of_stacks = 2 ;
  }
  else if((cmph_ptr()->subs_feature_mode[as_id_info] == SYS_SUBS_FEATURE_MODE_NORMAL) &&
          (base_ss_info_ptr->stack_info[0].sys_mode == SYS_SYS_MODE_CDMA) &&
          (base_ss_info_ptr->stack_info[1].sys_mode == SYS_SYS_MODE_HDR))
  {
    ss_info_ptr->number_of_stacks = 2 ;
  }
  else
  {
    ss_info_ptr->number_of_stacks = 1 ;
  }

  CM_MSG_HIGH_2(" AS_ID  %d, no_of_stacks = %d" , base_ss_info_ptr->asubs_id ,ss_info_ptr->number_of_stacks );


  /* For non multi-sim, set asubs_id to the default asubs_id.
  ** For multi-sim, get asubs_id from base ss info
  */

  for(index = 0 ; index <=1 ;index++)
  {
    if (cmph_is_ssim())
    {
      ss_info_ptr->asubs_id = SYS_MODEM_AS_ID_1;
    }
    else
    {
      ss_info_ptr->asubs_id = base_ss_info_ptr->asubs_id;
    }

    ss_info_ptr->stack_info[index].is_operational = base_ss_info_ptr->stack_info[index].is_operational;

    /* Copy appropriate serving system parameters into target buffer.
    */
    ss_info_ptr->stack_info[index].changed_fields         = base_ss_info_ptr->stack_info[index].changed_fields;
    ss_info_ptr->stack_info[index].changed_fields2        = base_ss_info_ptr->stack_info[index].changed_fields2;
    ss_info_ptr->stack_info[index].signal_strength_changed_fields =
                           base_ss_info_ptr->stack_info[index].signal_strength_changed_fields;
    ss_info_ptr->stack_info[index].srv_status             = base_ss_info_ptr->stack_info[index].srv_status;
    ss_info_ptr->stack_info[index].true_srv_status        = base_ss_info_ptr->stack_info[index].true_srv_status;
    ss_info_ptr->stack_info[index].srv_domain             = base_ss_info_ptr->stack_info[index].srv_domain;
    ss_info_ptr->stack_info[index].srv_capability         = base_ss_info_ptr->stack_info[index].srv_capability;
    ss_info_ptr->stack_info[index].sys_mode               = base_ss_info_ptr->stack_info[index].sys_mode;
    ss_info_ptr->stack_info[index].active_band            = base_ss_info_ptr->stack_info[index].active_band;
    ss_info_ptr->stack_info[index].active_channel         = base_ss_info_ptr->stack_info[index].active_channel;
    ss_info_ptr->stack_info[index].roam_status            = base_ss_info_ptr->stack_info[index].roam_status;
    ss_info_ptr->stack_info[index].sys_id                 = base_ss_info_ptr->stack_info[index].sys_id;
    if (base_ss_info_ptr->stack_info[index].sys_mode == SYS_SYS_MODE_HDR )
    {
    ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.subnet_mask_len
                                                          = base_ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.subnet_mask_len;
    }
    ss_info_ptr->stack_info[index].rssi                   = base_ss_info_ptr->stack_info[index].rssi;
    ss_info_ptr->stack_info[index].ecio                   = base_ss_info_ptr->stack_info[index].ecio;
    ss_info_ptr->stack_info[index].pathloss               = base_ss_info_ptr->stack_info[index].pathloss;
    ss_info_ptr->stack_info[index].cqi_info.gw_cqi        = base_ss_info_ptr->stack_info[index].cqi_info.gw_cqi;
    ss_info_ptr->stack_info[index].cqi_info.num_cqi_samples =
                                 base_ss_info_ptr->stack_info[index].cqi_info.num_cqi_samples;
    ss_info_ptr->stack_info[index].sir                    = base_ss_info_ptr->stack_info[index].sir;
    ss_info_ptr->stack_info[index].io                     = base_ss_info_ptr->stack_info[index].io;
    ss_info_ptr->stack_info[index].sinr                   = base_ss_info_ptr->stack_info[index].sinr;
    ss_info_ptr->stack_info[index].rssi2                  = base_ss_info_ptr->stack_info[index].rssi2;
    ss_info_ptr->stack_info[index].rscp                   = base_ss_info_ptr->stack_info[index].rscp;
    ss_info_ptr->stack_info[index].ecio_for_display       = base_ss_info_ptr->stack_info[index].ecio_for_display;

    ss_info_ptr->ps_data_suspend        = base_ss_info_ptr->ps_data_suspend;
    ss_info_ptr->stack_info[index].mode_info.gw_info.bit_err_rate
                                        = base_ss_info_ptr->stack_info[index].mode_info.gw_info.bit_err_rate;

    if (base_ss_info_ptr->stack_info[index].sys_mode == SYS_SYS_MODE_CDMA )
    {
    ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.frame_err_rate
                                        = base_ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.frame_err_rate;


    ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.cdma_reg_prd
                                        = base_ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.cdma_reg_prd;
    ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.is_custom_home
                                        = base_ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.is_custom_home;
    ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.height
                                        = base_ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.height;

    ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.horiz_uncertainty
                                        = base_ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.horiz_uncertainty;

    ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.vert_uncertainty
                                        = base_ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.vert_uncertainty;

    }
    ss_info_ptr->stack_info[index].geo_sys_idx            = base_ss_info_ptr->stack_info[index].geo_sys_idx;

    ss_info_ptr->stack_info[index].is_sys_prl_match       = base_ss_info_ptr->stack_info[index].is_sys_prl_match;
    ss_info_ptr->stack_info[index].is_sys_forbidden       = base_ss_info_ptr->stack_info[index].is_sys_forbidden;
    ss_info_ptr->stack_info[index].available_plmn_type    = base_ss_info_ptr->stack_info[index].available_plmn_type;

    if (base_ss_info_ptr->stack_info[index].sys_mode == SYS_SYS_MODE_HDR )
    {

      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.hdr_hybrid    = cmss_is_hybr_status_on();
      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.hdr_active_prot
                                           = base_ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.hdr_active_prot;
      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.hdr_personality
                                           = base_ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.hdr_personality;

      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.hdr_ln_status
                                           = base_ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.hdr_ln_status;
      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.hdr_packet_err_rate
                                           = base_ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.is_custom_home
                                           = base_ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.is_custom_home;


      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.latitude
                                           = base_ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.latitude;

      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.longitude
                                           = base_ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.longitude;

      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.mcc
                                           = base_ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.mcc;

      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.system_type
                                           = base_ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.system_type;


    }
    ss_info_ptr->stack_info[index].cipher_domain          = base_ss_info_ptr->stack_info[index].cipher_domain;
    ss_info_ptr->stack_info[index].cell_info              = base_ss_info_ptr->stack_info[index].cell_info;

    switch(base_ss_info_ptr->stack_info[index].sys_mode)
    {
      case SYS_SYS_MODE_GSM :

        ss_info_ptr->stack_info[index].rat_mode_info.gsm_mode_info.lac
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.gsm_mode_info.lac;
        ss_info_ptr->stack_info[index].rat_mode_info.gsm_mode_info.rac_or_mme_code
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.gsm_mode_info.rac_or_mme_code;

        *(&(ss_info_ptr->stack_info[index].rat_mode_info.gsm_mode_info.csg_info)) = *(&(base_ss_info_ptr->stack_info[index].rat_mode_info.gsm_mode_info.csg_info));

        break ;

      case SYS_SYS_MODE_WCDMA :


        ss_info_ptr->stack_info[index].rat_mode_info.wcdma_mode_info.lac
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.wcdma_mode_info.lac;
        ss_info_ptr->stack_info[index].rat_mode_info.wcdma_mode_info.rac_or_mme_code
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.wcdma_mode_info.rac_or_mme_code;

        *(&(ss_info_ptr->stack_info[index].rat_mode_info.wcdma_mode_info.csg_info)) = *(&(base_ss_info_ptr->stack_info[index].rat_mode_info.wcdma_mode_info.csg_info));
        break ;

      case SYS_SYS_MODE_LTE :
        ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.lac
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.lac;

        ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.tac
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.tac;
        ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.rac_or_mme_code
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.rac_or_mme_code;
        ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.rsrp
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.rsrp;
        ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.rsrq
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.rsrq;

        *(&(ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.csg_info)) = *(&(base_ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.csg_info));
        break ;

      case SYS_SYS_MODE_TDS :

        ss_info_ptr->stack_info[index].rat_mode_info.tds_mode_info.lac
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.tds_mode_info.lac;
        ss_info_ptr->stack_info[index].rat_mode_info.tds_mode_info.rac_or_mme_code
                                            = base_ss_info_ptr->stack_info[index].rat_mode_info.tds_mode_info.rac_or_mme_code;

        *(&(ss_info_ptr->stack_info[index].rat_mode_info.tds_mode_info.csg_info)) = *(&(base_ss_info_ptr->stack_info[index].rat_mode_info.tds_mode_info.csg_info));
        break ;

      case SYS_SYS_MODE_CDMA :

        ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.is_colloc                    = FALSE;
      break ;


      case SYS_SYS_MODE_HDR :
        ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.is_colloc                    = FALSE;
      break ;

      default:
      break;

    }

    #ifdef FEATURE_CM_LTE
    ss_info_ptr->div_duplex             = base_ss_info_ptr->div_duplex;
    #endif

    ss_info_ptr->eutra_detect_status    = base_ss_info_ptr->eutra_detect_status;

    #ifdef FEATURE_LTE_TO_1X
    ss_info_ptr->is_csfb_call_active    = base_ss_info_ptr->is_csfb_call_active;
    #endif

    #ifdef FEATURE_HDR_HANDOFF
    ss_info_ptr->stack_info[index].prev_idle_digital_mode = prev_idm;
    ss_info_ptr->stack_info[index].cur_idle_digital_mode  = cur_idm;
    #endif // FEATURE_HDR_HANDOFF

    #ifdef FEATURE_BCMCS
    ss_info_ptr->stack_info[index].bcmcs_srv_supported = base_ss_info_ptr->stack_info[index].bcmcs_srv_supported;
    ss_info_ptr->stack_info[index].bcmcs_srv_status    = base_ss_info_ptr->stack_info[index].bcmcs_srv_status;

    #endif /* FEATURE_BCMCS */


    if (cmss_is_hybr_status_on() )
    {
      ss_info_ptr->stack_info[index].rat_mode_info.cdma_mode_info.is_colloc    = ss_ptr->is_colloc;
      ss_info_ptr->stack_info[index].rat_mode_info.hdr_mode_info.is_colloc      = ss_ptr->is_colloc;
    }

    ss_info_ptr->stack_info[index].mode_info  = base_ss_info_ptr->stack_info[index].mode_info;



    if(as_id_info == SYS_MODEM_AS_ID_1)
    {

    ss_info_ptr->stack_info[index].thr_status.ss_thr_status = base_ss_info_ptr->stack_info[index].thr_status.ss_thr_status;

    if((index == 0) || (index == 1 && cmss_is_hybr_status_on()))
    {
      #ifdef FEATURE_CALL_THROTTLE
      tbl_entry_ptr = cmss_orig_thr_get_orig_tbl_entry(
                                  ss_ptr->cmss_orig_thr_tbl_ptr,
                                  base_ss_info_ptr->stack_info[index].sys_id,
                                  base_ss_info_ptr->stack_info[index].active_band,
                                  base_ss_info_ptr->stack_info[0].mode_info.cdma_info.packet_zone );

      if( tbl_entry_ptr != NULL)
      {
        ss_info_ptr->stack_info[index].thr_status.thr_uptime  = tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime;
        ss_info_ptr->stack_info[index].thr_status.idx         = tbl_entry_ptr->cmss_orig_thr_tbl.idx;
        ss_info_ptr->stack_info[index].thr_status.call_status = tbl_entry_ptr->cmss_orig_thr_tbl.orig_call_info.call_status;
      }
      else
      #endif /* FEATURE_CALL_THROTTLE */
      {
        ss_info_ptr->stack_info[index].thr_status.thr_uptime  = 0;
        ss_info_ptr->stack_info[index].thr_status.idx         = 0;
        ss_info_ptr->stack_info[index].thr_status.call_status = CM_SS_ORIG_THR_REASON_NONE;
      }

    }
    if((index == 1) && !(cmss_is_hybr_status_on()))
    {
      ss_info_ptr->stack_info[index].thr_status.thr_uptime  = 0;
      ss_info_ptr->stack_info[index].thr_status.idx         = 0;
      ss_info_ptr->stack_info[index].thr_status.call_status = CM_SS_ORIG_THR_REASON_NONE;
    }

    }

    ss_info_ptr->curr_uptime                  = time_get_uptime_secs();


    ss_info_ptr->stack_info[index].emerg_num_list               = base_ss_info_ptr->stack_info[index].emerg_num_list;

    /* Copy registration status of ipapp
    */
    ss_info_ptr->ipapp_info                   = base_ss_info_ptr->ipapp_info;

    ss_info_ptr->stack_info[index].psist                        = base_ss_info_ptr->stack_info[index].psist;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* HS srv and call indication gets copied only when in WCDMA or TDS
    */
    if (base_ss_info_ptr->stack_info[index].sys_mode == SYS_SYS_MODE_WCDMA ||
        base_ss_info_ptr->stack_info[index].sys_mode == SYS_SYS_MODE_TDS)
    {
      ss_info_ptr->stack_info[index].cell_srv_ind.hs_ind = base_ss_info_ptr->stack_info[index].cell_srv_ind.hs_ind;
      #ifdef FEATURE_HSPA_CALL_STATUS_IND
      ss_info_ptr->stack_info[index].cell_srv_ind.hs_call_status = base_ss_info_ptr->stack_info[index].cell_srv_ind.hs_call_status;
      #endif
    }
    else
    {
      ss_info_ptr->stack_info[index].cell_srv_ind.hs_ind = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #ifdef FEATURE_HSPA_CALL_STATUS_IND
      ss_info_ptr->stack_info[index].cell_srv_ind.hs_call_status = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      #endif
    }

    /* DTM/EGPRS indication gets copied only when in GSM
    */
    if (base_ss_info_ptr->stack_info[index].sys_mode    == SYS_SYS_MODE_GSM)
    {
      ss_info_ptr->stack_info[index].cell_srv_ind.dtm_supp   = base_ss_info_ptr->stack_info[index].cell_srv_ind.dtm_supp;
      ss_info_ptr->stack_info[index].cell_srv_ind.egprs_supp = base_ss_info_ptr->stack_info[index].cell_srv_ind.egprs_supp;
    }
    else
    {
      ss_info_ptr->stack_info[index].cell_srv_ind.dtm_supp   = SYS_DTM_SUPPORT_NOT_AVAIL;
      ss_info_ptr->stack_info[index].cell_srv_ind.egprs_supp = SYS_EGPRS_SUPPORT_NOT_AVAIL;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Copy 3GPP2 MCC (from ota or eqprl)
    */
    ss_info_ptr->prl_3gpp2_mcc = ss_ptr->info.prl_3gpp2_mcc;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Copy HDR MCC (from ota or eqprl)
    */
    ss_info_ptr->prl_hdr_mcc = ss_ptr->info.prl_hdr_mcc;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Copy current country and home country and plus dial settings
    */
    ss_info_ptr->home_mcc = ss_ptr->info.home_mcc;

    ss_info_ptr->current_mcc = ss_ptr->info.current_mcc;

    ss_info_ptr->plus_dial_setting = ss_ptr->info.plus_dial_setting;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Copy Registration reject information
    */
    ss_info_ptr->stack_info[index].reg_reject_info.reject_cause             = base_ss_info_ptr->stack_info[index].reg_reject_info.reject_cause;
    ss_info_ptr->stack_info[index].reg_reject_info.reject_srv_domain        = base_ss_info_ptr->stack_info[index].reg_reject_info.reject_srv_domain;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Copy UMA GAN information
    */
    ss_info_ptr->gan_info  = base_ss_info_ptr->gan_info;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Copy measurement info
    */
    ss_info_ptr->meas_resp  = base_ss_info_ptr->meas_resp;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Copy default roaming indicator
    */
    ss_info_ptr->def_roam_ind  = base_ss_info_ptr->def_roam_ind;


    /* Copy cell broadcast info */
    ss_info_ptr->stack_info[index].cell_bc_info.subscription_id =
                             base_ss_info_ptr->stack_info[index].cell_bc_info.subscription_id;
    ss_info_ptr->stack_info[index].cell_bc_info.cell_bc_capability =
                             base_ss_info_ptr->stack_info[index].cell_bc_info.cell_bc_capability;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef FEATURE_MMODE_SC_SGLTE
    if (ss_ptr->skip_srv_ind_update)
    {

      uint8 stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_2);
      if((stk_id == index) && ((cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1))
                                     ||(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1))
                                     ||(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_2))
                                     || (cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_2)))
        )
      {
        ss_info_ptr->stack_info[index].is_operational = cmss_is_hybr_gw_operational_skip;
      }
    }
    else
    #endif
    {
      ss_info_ptr->stack_info[index].is_operational = base_ss_info_ptr->stack_info[index].is_operational;
    }



    ss_info_ptr->stack_info[index].reg_reject_info.csg_id                   = base_ss_info_ptr->stack_info[index].reg_reject_info.csg_id;

    *(&(ss_info_ptr->stack_info[index].reg_reject_info.plmn)) = *(&(base_ss_info_ptr->stack_info[index].reg_reject_info.plmn));


    /*-----------------------------------------------------------------------*/
    /* Copy eMBMS information
    */
    if(base_ss_info_ptr->stack_info[index].sys_mode == SYS_SYS_MODE_LTE)
    {
    ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status = \
      base_ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status;
    ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.embms_info.trace_id = \
      base_ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.embms_info.trace_id ;

    /*-----------------------------------------------------------------------*/

    #ifdef FEATURE_DOMAIN_SELECTION
    ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.voice_support_on_lte = base_ss_info_ptr->stack_info[index].rat_mode_info.lte_mode_info.voice_support_on_lte;
    #endif
    }
    ss_info_ptr->stack_info[index].lte_ims_voice_avail = base_ss_info_ptr->stack_info[index].lte_ims_voice_avail;
    ss_info_ptr->stack_info[index].lte_ims_emerg_avail = base_ss_info_ptr->stack_info[index].lte_ims_emerg_avail;
    ss_info_ptr->voice_domain        = base_ss_info_ptr->voice_domain;
    ss_info_ptr->sms_domain        = base_ss_info_ptr->sms_domain;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Copy cell access (DSAC) information
    */
    ss_info_ptr->stack_info[index].cell_access_info.cs_bar_status =
                             base_ss_info_ptr->stack_info[index].cell_access_info.cs_bar_status;
    ss_info_ptr->stack_info[index].cell_access_info.ps_bar_status =
                             base_ss_info_ptr->stack_info[index].cell_access_info.ps_bar_status;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    ss_info_ptr->target_rat = base_ss_info_ptr->target_rat;

    ss_info_ptr->bsr_in_progress = base_ss_info_ptr->bsr_in_progress;

    ss_info_ptr->changed_fields_subs = base_ss_info_ptr->changed_fields_subs ;
  
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Return boolean indicating whether serving system information is valid.
    */

    /* Copy irat target rat info */
    ss_info_ptr->irat_ctxt_target_rat = base_ss_info_ptr->irat_ctxt_target_rat;
    ss_info_ptr->gwl_irat_asubs_id = base_ss_info_ptr->gwl_irat_asubs_id;

    /* populate the sys sel pref request id */
    ss_info_ptr->sys_sel_pref_req_id = base_ss_info_ptr->sys_sel_pref_req_id;

  }
  return CM_BOOLEAN( CM_INIT_CHECK(ss_ptr->init_mask) );

} /* cmss_info_get() */


/*===========================================================================

FUNCTION cmss_info_get

DESCRIPTION
  Copy the current serving system state information into a specified buffer.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  TRUE if serving system information is valid, FALSE otherwise.

  Note that serving system information only becomes valid after cmss_init()
  returns.

SIDE EFFECTS
  none

===========================================================================*/
static boolean cmss_info_get(

    cm_mm_ss_info_s_type    *ss_info_ptr,
        /* Copy serving system state info into this buffer */

    const cm_mm_ss_info_s_type    *base_ss_info_ptr
        /* Base ss_info that gets copied into ss_info_ptr. Can be either
        ** cmss.info OR cmss.srv_avail_info
        */
)
{
  #ifdef FEATURE_HDR_HANDOFF
  sys_sys_mode_e_type     cur_idm;
  sys_sys_mode_e_type     prev_idm;
  #endif // FEATURE_HDR_HANDOFF

  cmss_s_type          *ss_ptr = cmss_ptr();
      /* Point at serving system object */

  #ifdef FEATURE_CALL_THROTTLE
  cmss_orig_thr_table_q_type* tbl_entry_ptr;
  #endif /* FEATURE_CALL_THROTTLE */

  #ifdef FEATURE_CM_LTE
  cm_ss_e_type   intl_srv_lte_ss;
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );
  CM_ASSERT( ss_info_ptr != NULL );

  /* Verify that object was properly initialized.
  */
  CM_ASSERT( CM_INIT_CHECK(ss_ptr->init_mask) );


  #ifdef FEATURE_HDR_HYBRID
  CM_ASSERT( BETWEEN(base_ss_info_ptr->hdr_srv_status,
                     SYS_SRV_STATUS_NONE,
                     SYS_SRV_STATUS_MAX) );

  CM_ASSERT( BETWEEN(base_ss_info_ptr->sys_mode,
                     SYS_SYS_MODE_NONE,
                     SYS_SYS_MODE_MAX) );
  #endif /* FEATURE_HDR_HYBRID */

  #ifdef FEATURE_HDR_HANDOFF
  /* On and just after power up, as long as
     si_info.is_pref_srv_acq == TRUE,
     CM SS IDM will remain in CMSSIDM_STATE_NONE,
     with prev_idm == curr_idm == SYS_SYS_MODE_NONE.
     Also on transition from IDM_NONE to IDM_MAIN state,
     prev_idm will be SYS_SYS_MODE_NONE
  */
  cur_idm  = cmssidm_get_curr_idm();
  prev_idm = cmssidm_get_prev_idm();
  CM_ASSERT( cur_idm >= SYS_SYS_MODE_NONE &&
             cur_idm <  SYS_SYS_MODE_MAX );
  CM_ASSERT( prev_idm >= SYS_SYS_MODE_NONE &&
             prev_idm <  SYS_SYS_MODE_MAX );
  #endif // FEATURE_HDR_HANDOFF

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For non multi-sim, set asubs_id to the default asubs_id.
  ** For multi-sim, get asubs_id from base ss info
  */
  if (cmph_is_ssim())
  {
    ss_info_ptr->asubs_id = SYS_MODEM_AS_ID_1;
  }
  else
  {
    ss_info_ptr->asubs_id = base_ss_info_ptr->asubs_id;
  }

  ss_info_ptr->is_main_operational = base_ss_info_ptr->is_main_operational;

  /* Copy appropriate serving system parameters into target buffer.
  */
  ss_info_ptr->changed_fields         = base_ss_info_ptr->changed_fields;
  ss_info_ptr->changed_fields2        = base_ss_info_ptr->changed_fields2;
  ss_info_ptr->hybr_gw_changed_fields = base_ss_info_ptr->hybr_gw_changed_fields;
  ss_info_ptr->signal_strength_changed_fields =
                         base_ss_info_ptr->signal_strength_changed_fields;
  ss_info_ptr->srv_status             = base_ss_info_ptr->srv_status;
  ss_info_ptr->true_srv_status        = base_ss_info_ptr->true_srv_status;
  ss_info_ptr->srv_domain             = base_ss_info_ptr->srv_domain;
  ss_info_ptr->srv_capability         = base_ss_info_ptr->srv_capability;
  ss_info_ptr->sys_mode               = base_ss_info_ptr->sys_mode;
  ss_info_ptr->active_band            = base_ss_info_ptr->active_band;
  ss_info_ptr->active_channel         = base_ss_info_ptr->active_channel;
  ss_info_ptr->hybrid_active_band     = base_ss_info_ptr->hybrid_active_band;
  ss_info_ptr->hybrid_active_channel  = base_ss_info_ptr->hybrid_active_channel;
  ss_info_ptr->roam_status            = base_ss_info_ptr->roam_status;
  ss_info_ptr->sys_id                 = base_ss_info_ptr->sys_id;
  ss_info_ptr->subnet_mask_len        = base_ss_info_ptr->subnet_mask_len;
  ss_info_ptr->rssi                   = base_ss_info_ptr->rssi;
  ss_info_ptr->ecio                   = base_ss_info_ptr->ecio;
  ss_info_ptr->gw_ecio                = base_ss_info_ptr->gw_ecio;
  ss_info_ptr->pathloss               = base_ss_info_ptr->pathloss;
  ss_info_ptr->cqi_info.gw_cqi        = base_ss_info_ptr->cqi_info.gw_cqi;
  ss_info_ptr->cqi_info.num_cqi_samples =
                               base_ss_info_ptr->cqi_info.num_cqi_samples;
  ss_info_ptr->sir                    = base_ss_info_ptr->sir;
  ss_info_ptr->io                     = base_ss_info_ptr->io;
  ss_info_ptr->sinr                   = base_ss_info_ptr->sinr;
  ss_info_ptr->rssi2                  = base_ss_info_ptr->rssi2;
  ss_info_ptr->rscp                   = base_ss_info_ptr->rscp;
  ss_info_ptr->ecio_for_display       = base_ss_info_ptr->ecio_for_display;
  ss_info_ptr->ps_data_suspend        = base_ss_info_ptr->ps_data_suspend;
  ss_info_ptr->mode_info.gw_info.bit_err_rate
                                      = base_ss_info_ptr->mode_info.gw_info.bit_err_rate;
  ss_info_ptr->frame_err_rate         = base_ss_info_ptr->frame_err_rate;

  ss_info_ptr->cdma_reg_prd           = base_ss_info_ptr->cdma_reg_prd;
  ss_info_ptr->height                 = base_ss_info_ptr->height;
  ss_info_ptr->horiz_uncertainty      = base_ss_info_ptr->horiz_uncertainty;
  ss_info_ptr->vert_uncertainty       = base_ss_info_ptr->vert_uncertainty;

  ss_info_ptr->geo_sys_idx            = base_ss_info_ptr->geo_sys_idx;

  ss_info_ptr->is_sys_prl_match       = base_ss_info_ptr->is_sys_prl_match;
  ss_info_ptr->is_sys_forbidden       = base_ss_info_ptr->is_sys_forbidden;
  ss_info_ptr->available_plmn_type    = base_ss_info_ptr->available_plmn_type;

  ss_info_ptr->hdr_hybrid             = cmss_is_hybr_status_on();
  ss_info_ptr->hdr_srv_status         = base_ss_info_ptr->hdr_srv_status;
  ss_info_ptr->hdr_roam_status        = base_ss_info_ptr->hdr_roam_status;
  ss_info_ptr->hdr_rssi               = base_ss_info_ptr->hdr_rssi;
  ss_info_ptr->hdr_ecio               = base_ss_info_ptr->hdr_ecio;
  ss_info_ptr->hdr_io                 = base_ss_info_ptr->hdr_io;
  ss_info_ptr->hdr_sinr               = base_ss_info_ptr->hdr_sinr;
  ss_info_ptr->hdr_active_prot        = base_ss_info_ptr->hdr_active_prot;
  ss_info_ptr->hdr_personality        = base_ss_info_ptr->hdr_personality;
  ss_info_ptr->mcc                    = base_ss_info_ptr->mcc;
  ss_info_ptr->latitude               = base_ss_info_ptr->latitude;
  ss_info_ptr->longitude              = base_ss_info_ptr->longitude;
  ss_info_ptr->system_type            = base_ss_info_ptr->system_type;

  ss_info_ptr->hdr_ln_status          = base_ss_info_ptr->hdr_ln_status;
  ss_info_ptr->hdr_packet_err_rate    = base_ss_info_ptr->hdr_packet_err_rate;
  ss_info_ptr->cipher_domain          = base_ss_info_ptr->cipher_domain;
  ss_info_ptr->cell_info              = base_ss_info_ptr->cell_info;

  ss_info_ptr->lac                    = base_ss_info_ptr->lac;
  ss_info_ptr->tac                    = base_ss_info_ptr->tac;
  ss_info_ptr->rac_or_mme_code        = base_ss_info_ptr->rac_or_mme_code;

  #ifdef FEATURE_CM_LTE
  ss_info_ptr->rsrp                   = base_ss_info_ptr->rsrp;
  ss_info_ptr->rsrq                   = base_ss_info_ptr->rsrq;
  /*copy div duplex based on stack active */
  intl_srv_lte_ss = cmss_get_intl_srv_lte_ss();
  
   /* For CSFB ->SRLTE scenarios, 
    When RRC updates div duplex after switch is
    initiated, Hybr gw will have valid div duplex
    regardless of the stack in which LTE currently in service,
    so that once 1x comes to service on MAIN, hybr gw can be used
  */
  
  if(intl_srv_lte_ss == CM_SS_MAIN &&
    !ss_ptr->info.is_hybr_gw_operational)
  {
    ss_info_ptr->div_duplex             = ss_ptr->main_div_duplex;
  }
  else if(intl_srv_lte_ss == CM_SS_HYBR_2)
  {
    ss_info_ptr->div_duplex             = ss_ptr->hybr_gw_div_duplex;
  }
  else if(intl_srv_lte_ss == CM_SS_HYBR_3)
  {
    ss_info_ptr->div_duplex             = ss_ptr->gw3_div_duplex;
  }
  else
  {
    if( ss_ptr->info.is_hybr_gw_operational && (ss_ptr->hybr_gw_div_duplex != SYS_DIV_DUPLEX_UNKNOWN) && 
          (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) ||
           cmph_is_lte_capable_on_sub(SYS_MODEM_AS_ID_2)))
    {
      ss_info_ptr->div_duplex             = ss_ptr->hybr_gw_div_duplex;
    }
    else if (ss_ptr->info.is_gw3_operational && cmph_is_lte_capable_on_ss(CM_SS_HYBR_3))
    {
      ss_info_ptr->div_duplex             = ss_ptr->gw3_div_duplex;
    }
    else
    {
      ss_info_ptr->div_duplex             = ss_ptr->main_div_duplex;
    }
  }
  #endif

  ss_info_ptr->eutra_detect_status    = base_ss_info_ptr->eutra_detect_status;

  #ifdef FEATURE_LTE_TO_1X
  ss_info_ptr->is_csfb_call_active    = base_ss_info_ptr->is_csfb_call_active;
  #endif

  #ifdef FEATURE_HDR_HANDOFF
  ss_info_ptr->prev_idle_digital_mode = prev_idm;
  ss_info_ptr->cur_idle_digital_mode  = cur_idm;
  #endif // FEATURE_HDR_HANDOFF

  #ifdef FEATURE_BCMCS
  ss_info_ptr->hybr_hdr_bcmcs_srv_supported = base_ss_info_ptr->hybr_hdr_bcmcs_srv_supported;
  ss_info_ptr->hybr_hdr_bcmcs_srv_status    = base_ss_info_ptr->hybr_hdr_bcmcs_srv_status;

  ss_info_ptr->ss_main_bcmcs_srv_supported  = base_ss_info_ptr->ss_main_bcmcs_srv_supported;
  ss_info_ptr->ss_main_bcmcs_srv_status     = base_ss_info_ptr->ss_main_bcmcs_srv_status;
  #endif /* FEATURE_BCMCS */

  ss_info_ptr->is_colloc                    = FALSE;

  if (cmss_is_hybr_status_on() )
  {
    ss_info_ptr->is_colloc                  = ss_ptr->is_colloc;
  }

  ss_info_ptr->mode_info                    = base_ss_info_ptr->mode_info;


 ss_info_ptr->main_thr_status.ss_thr_status = base_ss_info_ptr->main_thr_status.ss_thr_status;


  #ifdef FEATURE_CALL_THROTTLE
  tbl_entry_ptr = cmss_orig_thr_get_orig_tbl_entry(
                              ss_ptr->cmss_orig_thr_tbl_ptr,
                              base_ss_info_ptr->sys_id,
                              base_ss_info_ptr->active_band,
                              base_ss_info_ptr->mode_info.cdma_info.packet_zone );

  if( tbl_entry_ptr != NULL)
  {
    ss_info_ptr->main_thr_status.thr_uptime  = tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime;
  ss_info_ptr->main_thr_status.idx         = tbl_entry_ptr->cmss_orig_thr_tbl.idx;
  ss_info_ptr->main_thr_status.call_status = tbl_entry_ptr->cmss_orig_thr_tbl.orig_call_info.call_status;
  }
  else
  #endif /* FEATURE_CALL_THROTTLE */
  {
    ss_info_ptr->main_thr_status.thr_uptime  = 0;
    ss_info_ptr->main_thr_status.idx         = 0;
    ss_info_ptr->main_thr_status.call_status = CM_SS_ORIG_THR_REASON_NONE;
  }

  ss_info_ptr->hdr_sys_id                    = base_ss_info_ptr->hdr_sys_id;

  ss_info_ptr->hdr_thr_status.ss_thr_status  = base_ss_info_ptr->hdr_thr_status.ss_thr_status;

  if (cmss_is_hybr_status_on() )
  {

    #ifdef FEATURE_CALL_THROTTLE
    tbl_entry_ptr = cmss_orig_thr_get_orig_tbl_entry(
                              ss_ptr->cmss_orig_thr_tbl_ptr,
                              base_ss_info_ptr->hdr_sys_id,
                              base_ss_info_ptr->hybrid_active_band,
                              base_ss_info_ptr->mode_info.cdma_info.packet_zone );

    if( tbl_entry_ptr != NULL )
    {
      ss_info_ptr->hdr_thr_status.thr_uptime  = tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime;
      ss_info_ptr->hdr_thr_status.idx         = tbl_entry_ptr->cmss_orig_thr_tbl.idx;
      ss_info_ptr->hdr_thr_status.call_status = tbl_entry_ptr->cmss_orig_thr_tbl.orig_call_info.call_status;
    }
    else
    #endif /* FEATURE_CALL_THROTTLE */
    {
      ss_info_ptr->hdr_thr_status.thr_uptime  = 0;
      ss_info_ptr->hdr_thr_status.idx         = 0;
      ss_info_ptr->hdr_thr_status.call_status = CM_SS_ORIG_THR_REASON_NONE;
    }
  }
  else
  {
    ss_info_ptr->hdr_thr_status.thr_uptime  = 0;
    ss_info_ptr->hdr_thr_status.idx         = 0;
    ss_info_ptr->hdr_thr_status.call_status = CM_SS_ORIG_THR_REASON_NONE;
  }

  ss_info_ptr->curr_uptime                  = time_get_uptime_secs();


  ss_info_ptr->emerg_num_list               = base_ss_info_ptr->emerg_num_list;

  /* Copy registration status of ipapp
  */
  ss_info_ptr->ipapp_info                   = base_ss_info_ptr->ipapp_info;

  ss_info_ptr->psist                        = base_ss_info_ptr->psist;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* HS srv and call indication gets copied only when in WCDMA or TDS
  */
  if (base_ss_info_ptr->sys_mode == SYS_SYS_MODE_WCDMA ||
      base_ss_info_ptr->sys_mode == SYS_SYS_MODE_TDS)
  {
    ss_info_ptr->cell_srv_ind.hs_ind = base_ss_info_ptr->cell_srv_ind.hs_ind;
    #ifdef FEATURE_HSPA_CALL_STATUS_IND
    ss_info_ptr->cell_srv_ind.hs_call_status = base_ss_info_ptr->cell_srv_ind.hs_call_status;
    #endif
  }
  else
  {
    ss_info_ptr->cell_srv_ind.hs_ind = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
    #ifdef FEATURE_HSPA_CALL_STATUS_IND
    ss_info_ptr->cell_srv_ind.hs_call_status = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
    #endif
  }

  /* DTM/EGPRS indication gets copied only when in GSM
  */
  if (base_ss_info_ptr->sys_mode    == SYS_SYS_MODE_GSM)
  {
    ss_info_ptr->cell_srv_ind.dtm_supp   = base_ss_info_ptr->cell_srv_ind.dtm_supp;
    ss_info_ptr->cell_srv_ind.egprs_supp = base_ss_info_ptr->cell_srv_ind.egprs_supp;
  }
  else
  {
    ss_info_ptr->cell_srv_ind.dtm_supp   = SYS_DTM_SUPPORT_NOT_AVAIL;
    ss_info_ptr->cell_srv_ind.egprs_supp = SYS_EGPRS_SUPPORT_NOT_AVAIL;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_info_ptr->prl_3gpp2_mcc = ss_ptr->info.prl_3gpp2_mcc;

  ss_info_ptr->prl_hdr_mcc = ss_ptr->info.prl_hdr_mcc;

  /* Copy current country and home country and plus dial settings
  */
  ss_info_ptr->home_mcc = ss_ptr->info.home_mcc;

  ss_info_ptr->current_mcc = ss_ptr->info.current_mcc;

  ss_info_ptr->plus_dial_setting = ss_ptr->info.plus_dial_setting;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Copy Registration reject information
  */
  ss_info_ptr->reg_reject_info.reject_cause             = base_ss_info_ptr->reg_reject_info.reject_cause;
  ss_info_ptr->reg_reject_info.reject_srv_domain        = base_ss_info_ptr->reg_reject_info.reject_srv_domain;
  ss_info_ptr->reg_reject_info.csg_id                   = base_ss_info_ptr->reg_reject_info.csg_id;
  *((&ss_info_ptr->reg_reject_info.plmn))      = *(&base_ss_info_ptr->reg_reject_info.plmn);
  ss_info_ptr->reg_reject_info.reg_rej_rat              = base_ss_info_ptr->reg_reject_info.reg_rej_rat;


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Copy UMA GAN information
  */
  ss_info_ptr->gan_info  = base_ss_info_ptr->gan_info;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Copy measurement info
  */
  ss_info_ptr->meas_resp  = base_ss_info_ptr->meas_resp;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Copy default roaming indicator
  */
  ss_info_ptr->def_roam_ind  = base_ss_info_ptr->def_roam_ind;


  /* Copy cell broadcast info */
  ss_info_ptr->cell_bc_info.subscription_id =
                           base_ss_info_ptr->cell_bc_info.subscription_id;
  ss_info_ptr->cell_bc_info.cell_bc_capability =
                           base_ss_info_ptr->cell_bc_info.cell_bc_capability;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_MMODE_SC_SGLTE
  if (ss_ptr->skip_srv_ind_update)
  {
    ss_info_ptr->is_hybr_gw_operational = cmss_is_hybr_gw_operational_skip;
  }
  else
  #endif
  if (ss_ptr->hold_hy2_oper_flag_uptime != CMSS_NO_SRV_UPTIME_NONE)
  {
    ss_info_ptr->is_hybr_gw_operational = TRUE;
  }
  else
  {
    ss_info_ptr->is_hybr_gw_operational = base_ss_info_ptr->is_hybr_gw_operational;
  }

  ss_info_ptr->hybr_gw_changed_fields = base_ss_info_ptr->hybr_gw_changed_fields;

  /* For non multi-sim, set asubs_id to the default asubs_id.
  ** For multi-sim, get asubs_id from base ss info
  */
  if (cmph_is_ssim())
  {
    ss_info_ptr->gw_asubs_id = SYS_MODEM_AS_ID_1;
  }
  else
  {
    ss_info_ptr->gw_asubs_id = base_ss_info_ptr->gw_asubs_id;
  }
  ss_info_ptr->gw_is_sys_prl_match= base_ss_info_ptr->gw_is_sys_prl_match;
  ss_info_ptr->gw_is_sys_forbidden= base_ss_info_ptr->gw_is_sys_forbidden;
  ss_info_ptr->gw_srv_status      = base_ss_info_ptr->gw_srv_status;
  ss_info_ptr->true_gw_srv_status = base_ss_info_ptr->true_gw_srv_status;
  ss_info_ptr->gw_srv_domain      = base_ss_info_ptr->gw_srv_domain;
  ss_info_ptr->gw_srv_capability  = base_ss_info_ptr->gw_srv_capability;
  ss_info_ptr->gw_cipher_domain   = base_ss_info_ptr->gw_cipher_domain;
  ss_info_ptr->gw_sys_mode        = base_ss_info_ptr->gw_sys_mode;
  ss_info_ptr->gw_active_band     = base_ss_info_ptr->gw_active_band;
  ss_info_ptr->gw_active_channel  = base_ss_info_ptr->gw_active_channel;
  ss_info_ptr->gw_roam_status     = base_ss_info_ptr->gw_roam_status;
  ss_info_ptr->gw_sys_id          = base_ss_info_ptr->gw_sys_id;
  ss_info_ptr->gw_rssi            = base_ss_info_ptr->gw_rssi;
  ss_info_ptr->gw_pathloss        = base_ss_info_ptr->gw_pathloss;
  ss_info_ptr->gw_sir             = base_ss_info_ptr->gw_sir;
  ss_info_ptr->gw_rssi2           = base_ss_info_ptr->gw_rssi2;
  ss_info_ptr->gw_rscp            = base_ss_info_ptr->gw_rscp;
  ss_info_ptr->gw2_ecio           = base_ss_info_ptr->gw2_ecio;
  ss_info_ptr->gw_ecio_for_display= base_ss_info_ptr->gw_ecio_for_display;
  ss_info_ptr->gw_io              = base_ss_info_ptr->gw_io;
  ss_info_ptr->gw_sinr            = base_ss_info_ptr->gw_sinr;
  ss_info_ptr->gw_cell_info       = base_ss_info_ptr->gw_cell_info;
  /* HS srv and call indication gets copied only when in WCDMA
  */
  if (base_ss_info_ptr->gw_sys_mode == SYS_SYS_MODE_WCDMA ||
      base_ss_info_ptr->gw_sys_mode == SYS_SYS_MODE_TDS)
  {
    ss_info_ptr->gw_cell_srv_ind.hs_ind = base_ss_info_ptr->gw_cell_srv_ind.hs_ind;
    #ifdef FEATURE_HSPA_CALL_STATUS_IND
    ss_info_ptr->gw_cell_srv_ind.hs_call_status = base_ss_info_ptr->gw_cell_srv_ind.hs_call_status;
    #endif
  }
  else
  {
    ss_info_ptr->gw_cell_srv_ind.hs_ind = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
    #ifdef FEATURE_HSPA_CALL_STATUS_IND
    ss_info_ptr->gw_cell_srv_ind.hs_call_status = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
    #endif
  }

  /* DTM/EGPRS indication gets copied only when in GSM
  */
  if (base_ss_info_ptr->gw_sys_mode    == SYS_SYS_MODE_GSM)
  {
    ss_info_ptr->gw_cell_srv_ind.dtm_supp   = base_ss_info_ptr->gw_cell_srv_ind.dtm_supp;
    ss_info_ptr->gw_cell_srv_ind.egprs_supp = base_ss_info_ptr->gw_cell_srv_ind.egprs_supp;
  }
  else
  {
    ss_info_ptr->gw_cell_srv_ind.dtm_supp   = SYS_DTM_SUPPORT_NOT_AVAIL;
    ss_info_ptr->gw_cell_srv_ind.egprs_supp = SYS_EGPRS_SUPPORT_NOT_AVAIL;
  }
  ss_info_ptr->gw_ps_data_suspend = base_ss_info_ptr->gw_ps_data_suspend;
  ss_info_ptr->gw_reg_reject_info.reject_cause             = base_ss_info_ptr->gw_reg_reject_info.reject_cause;
  ss_info_ptr->gw_reg_reject_info.reject_srv_domain        = base_ss_info_ptr->gw_reg_reject_info.reject_srv_domain;
  ss_info_ptr->gw_reg_reject_info.csg_id                   = base_ss_info_ptr->gw_reg_reject_info.csg_id;

  *(&(ss_info_ptr->gw_reg_reject_info.plmn)) = *(&(base_ss_info_ptr->gw_reg_reject_info.plmn));

  ss_info_ptr->gw_reg_reject_info.reg_rej_rat               = base_ss_info_ptr->gw_reg_reject_info.reg_rej_rat;
  ss_info_ptr->gw_mode_info                    = base_ss_info_ptr->gw_mode_info;
  ss_info_ptr->gw_emerg_num_list               = base_ss_info_ptr->gw_emerg_num_list;

  /* Copy cell broadcast info */
  ss_info_ptr->gw_cell_bc_info.subscription_id =
                               base_ss_info_ptr->gw_cell_bc_info.subscription_id;
  ss_info_ptr->gw_cell_bc_info.cell_bc_capability =
                               base_ss_info_ptr->gw_cell_bc_info.cell_bc_capability;


  ss_info_ptr->gwl_rsrp               = base_ss_info_ptr->gwl_rsrp;
  ss_info_ptr->gwl_rsrq               = base_ss_info_ptr->gwl_rsrq;
  ss_info_ptr->gwl_lac                = base_ss_info_ptr->gwl_lac;
  ss_info_ptr->gwl_tac                = base_ss_info_ptr->gwl_tac;
  ss_info_ptr->gwl_rac_or_mme_code    = base_ss_info_ptr->gwl_rac_or_mme_code;

  /*-----------------------------------------------------------------------*/
  /* Copy eMBMS information
  */
  ss_info_ptr->gwl_embms_info.embms_coverage_status = \
    base_ss_info_ptr->gwl_embms_info.embms_coverage_status;
  ss_info_ptr->gwl_embms_info.trace_id = \
    base_ss_info_ptr->gwl_embms_info.trace_id ;

  /*-----------------------------------------------------------------------*/

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  ss_info_ptr->is_gw3_operational = base_ss_info_ptr->is_gw3_operational;
  ss_info_ptr->gw3_changed_fields = base_ss_info_ptr->gw3_changed_fields;

  if (cmph_is_ssim())
  {
    ss_info_ptr->gw3_asubs_id = SYS_MODEM_AS_ID_1;
  }
  else
  {
    ss_info_ptr->gw3_asubs_id        = base_ss_info_ptr->gw3_asubs_id;
  }
  ss_info_ptr->gw3_is_sys_prl_match= base_ss_info_ptr->gw3_is_sys_prl_match;
  ss_info_ptr->gw3_is_sys_forbidden= base_ss_info_ptr->gw3_is_sys_forbidden;
  ss_info_ptr->gw3_srv_status      = base_ss_info_ptr->gw3_srv_status;
  ss_info_ptr->true_gw3_srv_status = base_ss_info_ptr->true_gw3_srv_status;
  ss_info_ptr->gw3_srv_domain      = base_ss_info_ptr->gw3_srv_domain;
  ss_info_ptr->gw3_srv_capability  = base_ss_info_ptr->gw3_srv_capability;
  ss_info_ptr->gw3_cipher_domain   = base_ss_info_ptr->gw3_cipher_domain;
  ss_info_ptr->gw3_sys_mode        = base_ss_info_ptr->gw3_sys_mode;
  ss_info_ptr->gw3_active_band     = base_ss_info_ptr->gw3_active_band;
  ss_info_ptr->gw3_active_channel  = base_ss_info_ptr->gw3_active_channel;
  ss_info_ptr->gw3_roam_status     = base_ss_info_ptr->gw3_roam_status;
  ss_info_ptr->gw3_sys_id          = base_ss_info_ptr->gw3_sys_id;
  ss_info_ptr->gw3_rssi            = base_ss_info_ptr->gw3_rssi;
  ss_info_ptr->gw3_pathloss        = base_ss_info_ptr->gw3_pathloss;
  ss_info_ptr->gw3_sir             = base_ss_info_ptr->gw3_sir;
  ss_info_ptr->gw3_rssi2           = base_ss_info_ptr->gw3_rssi2;
  ss_info_ptr->gw3_rscp            = base_ss_info_ptr->gw3_rscp;
  ss_info_ptr->gw3_ecio           = base_ss_info_ptr->gw3_ecio;
  ss_info_ptr->gw3_ecio_for_display= base_ss_info_ptr->gw3_ecio_for_display;
  ss_info_ptr->gw3_io              = base_ss_info_ptr->gw3_io;
  ss_info_ptr->gw3_sinr            = base_ss_info_ptr->gw3_sinr;
  ss_info_ptr->gw3_cell_info       = base_ss_info_ptr->gw3_cell_info;
  /* HS srv and call indication gets copied only when in WCDMA
  */
  if (base_ss_info_ptr->gw3_sys_mode == SYS_SYS_MODE_WCDMA ||
      base_ss_info_ptr->gw3_sys_mode == SYS_SYS_MODE_TDS)
  {
    ss_info_ptr->gw3_cell_srv_ind.hs_ind = base_ss_info_ptr->gw3_cell_srv_ind.hs_ind;
  #ifdef FEATURE_HSPA_CALL_STATUS_IND
    ss_info_ptr->gw3_cell_srv_ind.hs_call_status = base_ss_info_ptr->gw3_cell_srv_ind.hs_call_status;
  #endif
  }
  else
  {
    ss_info_ptr->gw3_cell_srv_ind.hs_ind = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
  #ifdef FEATURE_HSPA_CALL_STATUS_IND
    ss_info_ptr->gw3_cell_srv_ind.hs_call_status = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
  #endif
  }

  /* DTM/EGPRS indication gets copied only when in GSM
  */
  if (base_ss_info_ptr->gw3_sys_mode    == SYS_SYS_MODE_GSM)
  {
    ss_info_ptr->gw3_cell_srv_ind.dtm_supp   = base_ss_info_ptr->gw3_cell_srv_ind.dtm_supp;
    ss_info_ptr->gw3_cell_srv_ind.egprs_supp = base_ss_info_ptr->gw3_cell_srv_ind.egprs_supp;
  }
  else
  {
    ss_info_ptr->gw3_cell_srv_ind.dtm_supp   = SYS_DTM_SUPPORT_NOT_AVAIL;
    ss_info_ptr->gw3_cell_srv_ind.egprs_supp = SYS_EGPRS_SUPPORT_NOT_AVAIL;
  }
  ss_info_ptr->gw3_ps_data_suspend = base_ss_info_ptr->gw3_ps_data_suspend;
  ss_info_ptr->gw3_reg_reject_info.reject_cause             = base_ss_info_ptr->gw3_reg_reject_info.reject_cause;
  ss_info_ptr->gw3_reg_reject_info.reject_srv_domain        = base_ss_info_ptr->gw3_reg_reject_info.reject_srv_domain;
  ss_info_ptr->gw3_reg_reject_info.csg_id                   = base_ss_info_ptr->gw3_reg_reject_info.csg_id;
  *(&(ss_info_ptr->gw3_reg_reject_info.plmn)) = *(&(base_ss_info_ptr->gw3_reg_reject_info.plmn));
  
  *(&(ss_info_ptr->gw3_reg_reject_info.plmn)) = *(&(base_ss_info_ptr->gw3_reg_reject_info.plmn));
  ss_info_ptr->gw3_reg_reject_info.reg_rej_rat               = base_ss_info_ptr->gw3_reg_reject_info.reg_rej_rat;

  ss_info_ptr->gw3_mode_info                    = base_ss_info_ptr->gw3_mode_info;
  ss_info_ptr->gw3_emerg_num_list               = base_ss_info_ptr->gw3_emerg_num_list;

  /* Copy cell broadcast info */
  ss_info_ptr->gw3_cell_bc_info.subscription_id =
                               base_ss_info_ptr->gw3_cell_bc_info.subscription_id;
  ss_info_ptr->gw3_cell_bc_info.cell_bc_capability =
                               base_ss_info_ptr->gw3_cell_bc_info.cell_bc_capability;

  ss_info_ptr->gw3_rsrp               = base_ss_info_ptr->gw3_rsrp;
  ss_info_ptr->gw3_rsrq               = base_ss_info_ptr->gw3_rsrq;
  ss_info_ptr->gw3_lac                = base_ss_info_ptr->gw3_lac;
  ss_info_ptr->gw3_tac                = base_ss_info_ptr->gw3_tac;
  ss_info_ptr->gw3_rac_or_mme_code    = base_ss_info_ptr->gw3_rac_or_mme_code;

  /*-----------------------------------------------------------------------*/
  /* Copy eMBMS information
  */
  ss_info_ptr->gw3_embms_info.embms_coverage_status = \
    base_ss_info_ptr->gw3_embms_info.embms_coverage_status;
  ss_info_ptr->gw3_embms_info.trace_id = \
    base_ss_info_ptr->gw3_embms_info.trace_id ;

  /*-----------------------------------------------------------------------*/

  ss_info_ptr->gw3_cell_access_info.cs_bar_status =
                           base_ss_info_ptr->gw3_cell_access_info.cs_bar_status;
  ss_info_ptr->gw3_cell_access_info.ps_bar_status =
                           base_ss_info_ptr->gw3_cell_access_info.ps_bar_status;
  #endif /* FEATURE_MMODE_TRIPLE_SIM */

  #ifdef FEATURE_DOMAIN_SELECTION
  ss_info_ptr->voice_support_on_lte = base_ss_info_ptr->voice_support_on_lte;
  #endif
  ss_info_ptr->lte_ims_voice_avail = base_ss_info_ptr->lte_ims_voice_avail;
  ss_info_ptr->lte_ims_emerg_avail = base_ss_info_ptr->lte_ims_emerg_avail;
  ss_info_ptr->voice_domain        = base_ss_info_ptr->voice_domain;
  ss_info_ptr->sms_domain        = base_ss_info_ptr->sms_domain;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Copy cell access (DSAC) information
  */
  ss_info_ptr->cell_access_info.cs_bar_status =
                           base_ss_info_ptr->cell_access_info.cs_bar_status;
  ss_info_ptr->cell_access_info.ps_bar_status =
                           base_ss_info_ptr->cell_access_info.ps_bar_status;
#ifdef FEATURE_MMODE_DUAL_SIM
  ss_info_ptr->gw_cell_access_info.cs_bar_status =
                           base_ss_info_ptr->gw_cell_access_info.cs_bar_status;
  ss_info_ptr->gw_cell_access_info.ps_bar_status =
                           base_ss_info_ptr->gw_cell_access_info.ps_bar_status;
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_info_ptr->target_rat = base_ss_info_ptr->target_rat;

  ss_info_ptr->bsr_in_progress = base_ss_info_ptr->bsr_in_progress;

  /*-----------------------------------------------------------------------*/
  /* Copy eMBMS information
  */
  ss_info_ptr->embms_info.embms_coverage_status = base_ss_info_ptr->embms_info.embms_coverage_status;
  ss_info_ptr->embms_info.trace_id = base_ss_info_ptr->embms_info.trace_id ;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Return boolean indicating whether serving system information is valid.
  */

  /* Copy irat target rat info */
  ss_info_ptr->irat_ctxt_target_rat = base_ss_info_ptr->irat_ctxt_target_rat;
  ss_info_ptr->gwl_irat_asubs_id = base_ss_info_ptr->gwl_irat_asubs_id;

  /* populate the sys sel pref request id */
  ss_info_ptr->sys_sel_pref_req_id = base_ss_info_ptr->sys_sel_pref_req_id;

  *(&(ss_info_ptr->csg_info)) = *(&(base_ss_info_ptr->csg_info));

  return CM_BOOLEAN( CM_INIT_CHECK(ss_ptr->init_mask) );

} /* cmss_info_get() */

/*===========================================================================

FUNCTION cmss_is_hybr_status_on

DESCRIPTION
  This function should be called to determine if hybrid is ON.

DEPENDENCIES
  None.

RETURN VALUE
  Boolean.

SIDE EFFECTS
  None.
===========================================================================*/
boolean    cmss_is_hybr_status_on(void)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT( ss_ptr != NULL );
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return ( CM_BOOLEAN( ss_ptr->info.hdr_hybrid ) );

}

/*===========================================================================

FUNCTION cmss_is_hybr2_operational

DESCRIPTION
  This function should be called to determine if hybr2 is operational.

DEPENDENCIES
  None.

RETURN VALUE
  Boolean.

SIDE EFFECTS
  None.
===========================================================================*/
boolean    cmss_is_hybr2_operational(void)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return ss_ptr->info.is_hybr_gw_operational;

}

/*===========================================================================

FUNCTION cmss_is_hybr3_operational

DESCRIPTION
  This function should be called to determine if hybr3 is operational.

DEPENDENCIES
  None.

RETURN VALUE
  Boolean.

SIDE EFFECTS
  None.
===========================================================================*/
boolean    cmss_is_hybr3_operational(void)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return ss_ptr->info.is_gw3_operational;

}

/*===========================================================================

FUNCTION cmss_is_main_operational

DESCRIPTION
  This function should be called to determine if MAIN is operational

DEPENDENCIES
  None.

RETURN VALUE
  Boolean.

SIDE EFFECTS
  None.
===========================================================================*/
boolean    cmss_is_main_operational(void)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return ss_ptr->info.is_main_operational;

}

/*===========================================================================
  This function checks to if any stack or subscription has LTE service.
  If LTE service found in anystack, it returns that stack.
===========================================================================*/
cm_ss_e_type cmss_lte_srv_on_any_stack( void )
{
  cmss_s_type *ss_ptr = cmss_ptr();

  if(ss_ptr->info.sys_mode == SYS_SYS_MODE_LTE &&
     ss_ptr->info.is_main_operational)
  {
    return CM_SS_MAIN;
  }

  if(ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_LTE &&
     ss_ptr->info.is_hybr_gw_operational)
  {
    return CM_SS_HYBR_2;
  }

  if(ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_LTE &&
     ss_ptr->info.is_gw3_operational)
  {
    return CM_SS_HYBR_3;
  }

  return CM_SS_NONE;
}

/*===========================================================================

FUNCTION cmss_get_ss_cmd_asubs_id

DESCRIPTION
  Get asubs_id from cm ss command ptr.

DEPENDENCIES
  None.

RETURN VALUE
  sys_modem_as_id_e_type.

SIDE EFFECTS
  None.
===========================================================================*/
sys_modem_as_id_e_type cmss_get_ss_cmd_asubs_id (
      const cm_ss_cmd_s_type  *ss_cmd_ptr
)
{
  CM_ASSERT(ss_cmd_ptr   != NULL);

  if (ss_cmd_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  if (cmph_is_msim())
  {
    return ss_cmd_ptr->cmd_subs;
  }
  else
  {
    return SYS_MODEM_AS_ID_1;
  }
}

static void cmss_print_srv_status_info(cmss_s_type *ss_ptr)
{

  CM_MSG_MED_6("last_system | is_operational: main %d, hybr2 %d, hybr3  %d | MAIN : as_id %d, mode %d, status %d",
     ss_ptr->info.is_main_operational, ss_ptr->info.is_hybr_gw_operational,
     ss_ptr->info.is_gw3_operational,
   ss_ptr->info.asubs_id, ss_ptr->info.sys_mode, ss_ptr->info.srv_status);

  if(ss_ptr->info.hdr_hybrid)
  {
    CM_MSG_MED_3("last_system | HYBR1 as_id %d, mode %d, status %d",
     ss_ptr->info.asubs_id, SYS_SYS_MODE_HDR, ss_ptr->info.hdr_srv_status);
  }

  CM_MSG_MED_6("last_system HYBR2 as_id %d, mode %d, status %d ,HYBR3 as_id %d, mode %d, status %d",
    ss_ptr->info.gw_asubs_id, ss_ptr->info.gw_sys_mode,
    ss_ptr->info.gw_srv_status,ss_ptr->info.gw3_asubs_id, 
    ss_ptr->info.gw3_sys_mode,ss_ptr->info.gw3_srv_status);

}

/*===========================================================================

FUNCTION cmss_update_last_reported_sysmode

DESCRIPTION
  Update the ss_ptr->last_system_reported field with the sysmode that is being
  reported to the clients.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  Changes Serving System object
===========================================================================*/

static void cmss_update_last_reported_sysmode(void)
{
   cmss_s_type          *ss_ptr        =  cmss_ptr();
   CM_ASSERT( ss_ptr != NULL );

   if (BETWEEN(ss_ptr->info.gw_sys_mode,SYS_SYS_MODE_NO_SRV, SYS_SYS_MODE_MAX) )
   {
    /* Store the sys_mode that is being sent to the clients
    ** Dont copy if sys_mode that is being reported is SYS_SYS_MODE_NO_SRV,
    ** this makes sure that last_system_reported has the last successfully
    ** acquired system in case UE goes OOS. This helps DS to be in sync
    ** when call_events are sent. DS ignores SYS_SYS_MODE_NO_SRV (stores the
    ** previously acquired system) and hence
    ** the call_event we send to them when we are in no service should have
    ** the last successfully acquired system.
    */
     ss_ptr->hybr_gw_last_system_reported = ss_ptr->info.gw_sys_mode;
   }

   #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
   if (BETWEEN(ss_ptr->info.gw3_sys_mode,SYS_SYS_MODE_NO_SRV, SYS_SYS_MODE_MAX) )
   {
    /* Store the sys_mode that is being sent to the clients
    ** Dont copy if sys_mode that is being reported is SYS_SYS_MODE_NO_SRV,
    ** this makes sure that last_system_reported has the last successfully
    ** acquired system in case UE goes OOS. This helps DS to be in sync
    ** when call_events are sent. DS ignores SYS_SYS_MODE_NO_SRV (stores the
    ** previously acquired system) and hence
    ** the call_event we send to them when we are in no service should have
    ** the last successfully acquired system.
    */
     ss_ptr->hybr_3_gw_last_system_reported = ss_ptr->info.gw3_sys_mode;
   }
   #endif //FEATURE_MMODE_TRIPLE_SIM

   if (BETWEEN(ss_ptr->info.sys_mode,SYS_SYS_MODE_NO_SRV, SYS_SYS_MODE_MAX) )
   {
    /* Store the sys_mode that is being sent to the clients
    ** Dont copy if sys_mode that is being reported is SYS_SYS_MODE_NO_SRV,
    ** this makes sure that last_system_reported has the last successfully
    ** acquired system in case UE goes OOS. This helps DS to be in sync
    ** when call_events are sent. DS ignores SYS_SYS_MODE_NO_SRV (stores the
    ** previously acquired system) and hence
    ** the call_event we send to them when we are in no service should have
    ** the last successfully acquired system.
    */
     ss_ptr->last_system_reported = ss_ptr->info.sys_mode;
   }

   cmss_print_srv_status_info(ss_ptr);

   return;
}

/*===========================================================================

@FUNCTION cmss_copy_signal_strength_info_change

@DESCRIPTION
   Update the latest signal_strenfth information change information
   to structure that contains info last send to client

@DEPENDENCIES
   Phone object must have already been initialized with
   cmph_init().

@RETURN VALUE
   none

@SIDE EFFECTS
   none
===========================================================================*/
static void cmss_copy_signal_strength_info_change (

    cm_mm_msim_ss_info_s_type           *avail_srv_info,
        /*  Available SS information send to client */

    const cm_mm_ss_info_s_type     *curr_srv_info,
        /*  SS information current */

    uint64     signal_strength_changed_fields_main,
        
    uint64     signal_strength_changed_fields_hdr,
    
    uint64     signal_strength_changed_fields_subs

)
{
  uint8                    stk_id = cmph_ptr()->ss_subs_map[CM_SS_MAIN].stack_id;

  avail_srv_info->stack_info[stk_id].signal_strength_changed_fields =
                          signal_strength_changed_fields_main;

  avail_srv_info->changed_fields_subs =
                          signal_strength_changed_fields_subs;

  avail_srv_info->stack_info[stk_id].rssi                          = curr_srv_info->rssi;
  avail_srv_info->stack_info[stk_id].rssi2                          = curr_srv_info->rssi2;
  avail_srv_info->stack_info[stk_id].rscp                          = curr_srv_info->rscp;
  avail_srv_info->stack_info[stk_id].ecio                          = curr_srv_info->ecio;

  if(curr_srv_info->sys_mode == SYS_SYS_MODE_WCDMA)
  {
    avail_srv_info->stack_info[stk_id].ecio                       = curr_srv_info->gw_ecio;
  }
  avail_srv_info->stack_info[stk_id].io                            = curr_srv_info->io;
  avail_srv_info->stack_info[stk_id].sinr                          = curr_srv_info->sinr;
  avail_srv_info->stack_info[stk_id].sir                           = curr_srv_info->sir;
  avail_srv_info->stack_info[stk_id].pathloss                      = curr_srv_info->pathloss;
  avail_srv_info->stack_info[stk_id].ecio_for_display              =
                                            curr_srv_info->ecio_for_display;
  avail_srv_info->stack_info[stk_id].mode_info.gw_info.bit_err_rate =
                              curr_srv_info->mode_info.gw_info.bit_err_rate;
  avail_srv_info->stack_info[stk_id].rat_mode_info.cdma_mode_info.frame_err_rate                
                                                                         =  curr_srv_info->frame_err_rate ;

  #ifdef FEATURE_CM_LTE
  if(curr_srv_info->sys_mode == SYS_SYS_MODE_LTE)
  {
    avail_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.rsrp
                                                                           = curr_srv_info->rsrp;
    avail_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.rsrq
                                                                           = curr_srv_info->rsrq;
  }
  #endif
  avail_srv_info->stack_info[stk_id].cqi_info                      = curr_srv_info->cqi_info;
  avail_srv_info->eutra_detect_status 
                                                                          =  curr_srv_info->eutra_detect_status;
  
  stk_id = cmph_ptr()->ss_subs_map[CM_SS_HYBR_1].stack_id;

  avail_srv_info->stack_info[stk_id].signal_strength_changed_fields =
                          signal_strength_changed_fields_hdr;

  avail_srv_info->stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_packet_err_rate  =
                                                                              curr_srv_info->hdr_packet_err_rate;
  avail_srv_info->stack_info[stk_id].rssi                      = curr_srv_info->hdr_rssi;
  avail_srv_info->stack_info[stk_id].io                        = curr_srv_info->hdr_io;
  avail_srv_info->stack_info[stk_id].ecio                      = curr_srv_info->hdr_ecio;
  avail_srv_info->stack_info[stk_id].sinr                      = curr_srv_info->hdr_sinr;

  
} /* cmss_copy_signal_strength_info_change */

//arun remove signal strength chnge fields
/*===========================================================================

@FUNCTION cmss_get_signal_strength_info_change

@DESCRIPTION
   Compares the signal_strenfth information change and returns
   a bit mask holding difference.

@DEPENDENCIES
   Phone object must have already been initialized with
   cmph_init().

@RETURN VALUE
   none

@SIDE EFFECTS
   none

===========================================================================*/
static void cmss_get_signal_strength_info_change(

    cm_mm_ss_info_s_type     *new_srv_info,
        /*  New SS information */

    cmss_s_type               *ss_ptr
        /*  SS information */
)
{
  uint64     signal_strength_changed_fields = 0;
      /** Records the changes in Signal Strength parameters
      **  between new_srv_info and old_srv_info
      */
  uint64     signal_strength_changed_fields_main = 0;
      
  uint64     signal_strength_changed_fields_hdr = 0;

  uint64     signal_strength_changed_fields_subs = cmss_ptr()->new_srv_avl_info[0].changed_fields_subs;

  uint64     gw_signal_strength_changed_fields = 0;

  uint64     gw_signal_strength_changed_fields_hybr2 = 0;
      /** Records the changes in Signal Strength parameters
      **  between new_srv_info and old_srv_info
      */




  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;
      
  uint8                    stk_id = cmph_ptr()->ss_subs_map[CM_SS_MAIN].stack_id;

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  uint64     gw3_signal_strength_changed_fields = 0;
  
  uint64     gw3_signal_strength_changed_fields_hybr3 = 0;
      /** Records the changes in Signal Strength parameters
      **  between new_srv_info and old_srv_info
      */
  #endif

  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }

  CM_MSG_HIGH_6("Before calc sig_str_chged_fields: overall %d, main %d, hdr %d, subs %d, gw %d, gw_hybr2 %d",
                signal_strength_changed_fields,signal_strength_changed_fields_main,signal_strength_changed_fields_hdr,
               signal_strength_changed_fields_subs,gw_signal_strength_changed_fields,gw_signal_strength_changed_fields_hybr2);
  
  if ((new_srv_info != NULL) && (ss_ptr != NULL))
  {

    if (new_srv_info->rssi != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rssi)
    {
      signal_strength_changed_fields |= CM_SS_RSSI_MASK;
      signal_strength_changed_fields_main |= CM_SS_EVT_RSSI_MASK ;
    }

    if (new_srv_info->rscp != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rscp)
    {
      signal_strength_changed_fields |= CM_SS_RSCP_MASK;
      signal_strength_changed_fields_main |= CM_SS_EVT_RSCP_MASK ;
    }

    if(new_srv_info->sys_mode == SYS_SYS_MODE_WCDMA)
    {
      if (new_srv_info->gw_ecio != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio)
      {
        signal_strength_changed_fields |= CM_SS_ECIO_MASK;
        signal_strength_changed_fields_main |= CM_SS_EVT_ECIO_MASK;
      }
    }

    if (new_srv_info->io != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].io)
    {
      signal_strength_changed_fields |= CM_SS_IO_MASK;
      signal_strength_changed_fields_main |= CM_SS_EVT_IO_MASK;
    }

    if (new_srv_info->sinr != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sinr)
    {
      signal_strength_changed_fields |= CM_SS_SINR_MASK;
      signal_strength_changed_fields_main |= CM_SS_EVT_SINR_MASK;
    }

    if (new_srv_info->sir != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sir)
    {
      signal_strength_changed_fields |= CM_SS_SIR_MASK;
      signal_strength_changed_fields_main |= CM_SS_EVT_SIR_MASK;
    }

    if (new_srv_info->pathloss != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].pathloss)
    {
      signal_strength_changed_fields |= CM_SS_PATHLOSS_MASK;
      signal_strength_changed_fields_main |= CM_SS_EVT_PATHLOSS_MASK;
    }

    if (new_srv_info->mode_info.gw_info.bit_err_rate !=
               ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.gw_info.bit_err_rate)
    {
      signal_strength_changed_fields |= CM_SS_BER_MASK;
      signal_strength_changed_fields_main |= CM_SS_EVT_BER_MASK;
    }

    if(new_srv_info->sys_mode == SYS_SYS_MODE_CDMA)
    {
    if (new_srv_info->frame_err_rate !=
                                      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.cdma_mode_info.frame_err_rate)
     {
        signal_strength_changed_fields |= CM_SS_FER_MASK;
        signal_strength_changed_fields_main |= CM_SS_EVT_FER_MASK;
      }
    }

    if(new_srv_info->sys_mode != SYS_SYS_MODE_WCDMA)
    {
      if (new_srv_info->ecio != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio)
      {
        signal_strength_changed_fields |= CM_SS_CDMA_ECIO_MASK;
        signal_strength_changed_fields_main|= CM_SS_EVT_CDMA_ECIO_MASK;
        
      }
    }
    #ifdef FEATURE_CM_LTE
    if(new_srv_info->sys_mode == SYS_SYS_MODE_LTE)
    {
      if (new_srv_info->rsrp != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.lte_mode_info.rsrp)
      {
        signal_strength_changed_fields |= CM_SS_RSRP_MASK;
        signal_strength_changed_fields_main |= CM_SS_EVT_RSRP_MASK;
      }

      if (new_srv_info->rsrq != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.lte_mode_info.rsrq)
      {
        signal_strength_changed_fields |= CM_SS_RSRQ_MASK;
        signal_strength_changed_fields_main |= CM_SS_EVT_RSRQ_MASK;
      }
    }
    #endif

    subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_1) ;
        
    stk_id = cmph_ptr()->ss_subs_map[CM_SS_HYBR_1].stack_id;
    
    if (!cmph_is_as_id_valid(subId))
    {
      return ;
    }

    if (new_srv_info->hdr_packet_err_rate !=
                               ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_packet_err_rate)
    {
      signal_strength_changed_fields |= CM_SS_HDR_PER_MASK;
      signal_strength_changed_fields_hdr |= CM_SS_EVT_HDR_PER_MASK;
    }

    if (new_srv_info->hdr_rssi  != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rssi)
    {
      signal_strength_changed_fields |= CM_SS_HDR_RSSI_MASK;
      signal_strength_changed_fields_hdr |= CM_SS_EVT_RSSI_MASK;
    }

    if (new_srv_info->hdr_io!= ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].io)
    {
      signal_strength_changed_fields |= CM_SS_HDR_IO_MASK;
      signal_strength_changed_fields_hdr |= CM_SS_EVT_IO_MASK;
    }

    if (new_srv_info->hdr_ecio  != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio)
    {
      if( !((new_srv_info->hdr_ecio == CMSS_ECIO_VALUE_NO_SIGNAL) && (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio == CMSS_ECIO_VALUE_NO_SIGNAL_UMTS)))
    {
      signal_strength_changed_fields |= CM_SS_HDR_ECIO_MASK;
      signal_strength_changed_fields_hdr |= CM_SS_EVT_ECIO_MASK;
      }
    }

    if (new_srv_info->hdr_sinr != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sinr)
    {
      signal_strength_changed_fields |= CM_SS_HDR_SINR_MASK;
      signal_strength_changed_fields_hdr |= CM_SS_EVT_SINR_MASK;

    }



    if (new_srv_info->eutra_detect_status != \
        ss_ptr->new_srv_avl_info[subId].eutra_detect_status)
    {
      signal_strength_changed_fields |= CM_SS_EUTRA_DETECT_MASK;
      signal_strength_changed_fields_subs |= CM_SS_EVT_EUTRA_DETECT_MASK;
    }


    ss_ptr->info.signal_strength_changed_fields  |= signal_strength_changed_fields;

    new_srv_info->signal_strength_changed_fields  |= signal_strength_changed_fields;

    /* Update srv_avail_info with latest information */
    cmss_copy_signal_strength_info_change(&ss_ptr->new_srv_avl_info[subId], new_srv_info ,signal_strength_changed_fields_main 
                                          , signal_strength_changed_fields_hdr , signal_strength_changed_fields_subs);

    CM_MSG_HIGH_2("CMSS Signal Strength Changed 0x%x 0x%x ",
                 QWORD_HIGH(new_srv_info->signal_strength_changed_fields),
                 QWORD_LOW(new_srv_info->signal_strength_changed_fields));

    /* Calculate the changed fields for Hybr GW
    */

    
    subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) ;
        
    stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_2);

    
    if (!cmph_is_as_id_valid(subId))
    {
      return ;
    }

    if (new_srv_info->gw_rssi != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rssi)
    {
      gw_signal_strength_changed_fields |= CM_SS_GW_RSSI_MASK;
      gw_signal_strength_changed_fields_hybr2 |= CM_SS_EVT_RSSI_MASK;
    }

    if (new_srv_info->gw_rscp != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rscp)
    {
      gw_signal_strength_changed_fields |= CM_SS_GW_RSCP_MASK;
      gw_signal_strength_changed_fields_hybr2 |= CM_SS_EVT_RSCP_MASK;
    }

    if (new_srv_info->gw2_ecio != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio)
    {
      gw_signal_strength_changed_fields |= CM_SS_GW_ECIO_MASK;
      gw_signal_strength_changed_fields_hybr2 |= CM_SS_EVT_ECIO_MASK;
    }

    if (new_srv_info->gw_io != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].io)
    {
      gw_signal_strength_changed_fields |= CM_SS_GW_IO_MASK;
      gw_signal_strength_changed_fields_hybr2 |= CM_SS_EVT_IO_MASK;
    }

    if (new_srv_info->gw_sinr != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sinr)
    {
      gw_signal_strength_changed_fields |= CM_SS_GW_SINR_MASK;
      gw_signal_strength_changed_fields_hybr2 |= CM_SS_EVT_SINR_MASK;
    }

    if (new_srv_info->gw_sir != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sir)
    {
      gw_signal_strength_changed_fields |= CM_SS_GW_SIR_MASK;
      gw_signal_strength_changed_fields_hybr2 |= CM_SS_EVT_SIR_MASK;
    }

    if (new_srv_info->gw_pathloss != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].pathloss)
    {
      gw_signal_strength_changed_fields |= CM_SS_GW_PATHLOSS_MASK;
      gw_signal_strength_changed_fields_hybr2 |= CM_SS_EVT_PATHLOSS_MASK;
    }

    if (new_srv_info->gw_mode_info.gw_info.bit_err_rate != \
               ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.gw_info.bit_err_rate)
    {
      gw_signal_strength_changed_fields |= CM_SS_GW_BER_MASK;
      gw_signal_strength_changed_fields_hybr2 |= CM_SS_EVT_BER_MASK;
    }

    if (new_srv_info->gwl_rsrp != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.lte_mode_info.rsrp)
    {
      gw_signal_strength_changed_fields |= CM_SS_GWL_RSRP_MASK;
      gw_signal_strength_changed_fields_hybr2 |= CM_SS_EVT_RSRP_MASK;
    }

    if (new_srv_info->gwl_rsrq != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.lte_mode_info.rsrq)
    {
      gw_signal_strength_changed_fields |= CM_SS_GWL_RSRQ_MASK;
      gw_signal_strength_changed_fields_hybr2 |= CM_SS_EVT_RSRQ_MASK;
    }

    ss_ptr->info.hybr_gw_changed_fields  |= gw_signal_strength_changed_fields;

    new_srv_info->hybr_gw_changed_fields  |= gw_signal_strength_changed_fields;

    /* Update srv_avail_info with latest information */
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].signal_strength_changed_fields |=
                                  gw_signal_strength_changed_fields_hybr2;

    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rssi                     = new_srv_info->gw_rssi;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rscp                     = new_srv_info->gw_rscp;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio                    = new_srv_info->gw2_ecio;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].io                       = new_srv_info->gw_io;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sinr                     = new_srv_info->gw_sinr;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sir                      = new_srv_info->gw_sir;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].pathloss                 = new_srv_info->gw_pathloss;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio_for_display         = new_srv_info->gw_ecio_for_display;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.gw_info.bit_err_rate = \
                                      new_srv_info->gw_mode_info.gw_info.bit_err_rate;

    if(ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode == SYS_SYS_MODE_LTE)
    {
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.lte_mode_info.rsrp                    = new_srv_info->gwl_rsrp;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.lte_mode_info.rsrq                    = new_srv_info->gwl_rsrq;
    }
    CM_MSG_HIGH_2("Hybr GW CMSS Signal Strength Changed 0x%x 0x%x ",
                 QWORD_HIGH(new_srv_info->hybr_gw_changed_fields),
                 QWORD_LOW(new_srv_info->hybr_gw_changed_fields));

       #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    /* Calculate the changed fields for Hybr3 GW
    */
    
    if( cmph_is_tsts() || cmph_is_sxlte())
    {
    
    subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_3) ;
           
    stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_3);

    
    if (!cmph_is_as_id_valid(subId))
    {
      return ;
    }
       
    if (new_srv_info->gw3_rssi != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rssi)
    {
      gw3_signal_strength_changed_fields |= CM_SS_GW_RSSI_MASK;
      gw3_signal_strength_changed_fields_hybr3 |= CM_SS_EVT_RSSI_MASK ;
    }

    if (new_srv_info->gw3_rscp != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rscp)
    {
      gw3_signal_strength_changed_fields |= CM_SS_GW_RSCP_MASK;
      gw3_signal_strength_changed_fields_hybr3 |= CM_SS_EVT_RSCP_MASK;
    }

    if (new_srv_info->gw3_ecio != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio)
    {
      gw3_signal_strength_changed_fields |= CM_SS_GW_ECIO_MASK;
      gw3_signal_strength_changed_fields_hybr3|= CM_SS_EVT_ECIO_MASK;
    }

    if (new_srv_info->gw3_io != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].io)
    {
      gw3_signal_strength_changed_fields |= CM_SS_GW_IO_MASK;
      gw3_signal_strength_changed_fields_hybr3|= CM_SS_EVT_IO_MASK;
    }

    if (new_srv_info->gw3_sinr != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sinr)
    {
      gw3_signal_strength_changed_fields |= CM_SS_GW_SINR_MASK;
      gw3_signal_strength_changed_fields_hybr3|= CM_SS_EVT_SINR_MASK;
    }

    if (new_srv_info->gw3_sir != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sir)
    {
      gw3_signal_strength_changed_fields |= CM_SS_GW_SIR_MASK;
      gw3_signal_strength_changed_fields_hybr3|= CM_SS_EVT_SIR_MASK;
    }

    if (new_srv_info->gw3_pathloss != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].pathloss)
    {
      gw3_signal_strength_changed_fields |= CM_SS_GW_PATHLOSS_MASK;
      gw3_signal_strength_changed_fields_hybr3 |= CM_SS_EVT_PATHLOSS_MASK;
    }

    if (new_srv_info->gw3_mode_info.gw_info.bit_err_rate != \
               ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.gw_info.bit_err_rate)
    {
      gw3_signal_strength_changed_fields |= CM_SS_GW_BER_MASK;
      gw3_signal_strength_changed_fields_hybr3 |= CM_SS_EVT_BER_MASK;
    }

    if (new_srv_info->gw3_rsrp != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.lte_mode_info.rsrp)
    {
      gw3_signal_strength_changed_fields |= CM_SS_GWL_RSRP_MASK;
      gw3_signal_strength_changed_fields_hybr3 |= CM_SS_EVT_RSRP_MASK;
    }

    if (new_srv_info->gw3_rsrq != ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.lte_mode_info.rsrq)
    {
      gw3_signal_strength_changed_fields |= CM_SS_GWL_RSRQ_MASK;
      gw3_signal_strength_changed_fields_hybr3 |= CM_SS_EVT_RSRQ_MASK;
    }

    ss_ptr->info.gw3_changed_fields  |= gw3_signal_strength_changed_fields;

    new_srv_info->gw3_changed_fields  |= gw3_signal_strength_changed_fields;

    /* Update srv_avail_info with latest information */
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].signal_strength_changed_fields|=
                                  gw3_signal_strength_changed_fields_hybr3;

    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rssi                     = new_srv_info->gw3_rssi;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rscp                     = new_srv_info->gw3_rscp;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio                    = new_srv_info->gw3_ecio;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].io                       = new_srv_info->gw3_io;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sinr                     = new_srv_info->gw3_sinr;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sir                      = new_srv_info->gw3_sir;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].pathloss                 = new_srv_info->gw3_pathloss;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio_for_display         = new_srv_info->gw3_ecio_for_display;
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.gw_info.bit_err_rate = \
                                      new_srv_info->gw3_mode_info.gw_info.bit_err_rate;

    if(ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode == SYS_SYS_MODE_LTE)
    {
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.lte_mode_info.rsrp = new_srv_info->gw3_rsrp;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rat_mode_info.lte_mode_info.rsrq = new_srv_info->gw3_rsrq;
    }    

    CM_MSG_HIGH_2("Hybr3 GW CMSS Signal Strength Changed 0x%x 0x%x ",
                 QWORD_HIGH(new_srv_info->gw3_changed_fields),
                 QWORD_LOW(new_srv_info->gw3_changed_fields));
    }

#endif /* FEATURE_MMODE_TRIPLE_SIM */

  CM_MSG_HIGH_6("After calc sig_str_chged_fields: overall %d, main %d, hdr %d, subs %d, gw %d, gw_hybr2 %d",
                signal_strength_changed_fields, signal_strength_changed_fields_main,
                signal_strength_changed_fields_hdr, signal_strength_changed_fields_subs,
                gw_signal_strength_changed_fields,gw_signal_strength_changed_fields_hybr2);

  }
} /* cmss_get_signal_strength_info_change */


/*===========================================================================

FUNCTION cmss_update_thr_status

DESCRIPTION
  This function updates the ss_thr_status of the ss object

DEPENDENCIES

RETURN VALUE
  TRUE if throttle status has changed for either main or hybrid

SIDE EFFECTS
  None.
===========================================================================*/

static boolean cmss_update_thr_status( void )
{
  cmss_s_type          *ss_ptr                    =  cmss_ptr();
      /* Point at serving system object to be initialized */

  cmss_orig_thr_table_q_type* tbl_entry_ptr = NULL;

  dword                uptime                     = 0;

  
  sys_modem_as_id_e_type   subId    = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;

  if (!cmph_is_as_id_valid(subId))
  {
    return FALSE;
  }

  SYS_ARG_NOT_USED(tbl_entry_ptr);
  SYS_ARG_NOT_USED(uptime);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Reset all throttle values
  */
  ss_ptr->info.main_thr_status.ss_thr_status = FALSE;
  ss_ptr->info.hdr_thr_status.ss_thr_status  = FALSE;
  ss_ptr->info.main_thr_status.thr_uptime    = 0;
  ss_ptr->info.main_thr_status.idx           = 0;
  ss_ptr->info.main_thr_status.call_status = CM_SS_ORIG_THR_REASON_NONE;
  ss_ptr->info.hdr_thr_status.thr_uptime     = 0;
  ss_ptr->info.hdr_thr_status.idx            = 0;
  ss_ptr->info.hdr_thr_status.call_status = CM_SS_ORIG_THR_REASON_NONE;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_CALL_THROTTLE

  uptime = time_get_uptime_secs();

  /* Check if the system on the main stack is being throttled and update
  ** parameters accordingly
  */
  tbl_entry_ptr = cmss_orig_thr_get_orig_tbl_entry(
                            ss_ptr->cmss_orig_thr_tbl_ptr,
                            ss_ptr->info.sys_id,
                            ss_ptr->info.active_band,
                            ss_ptr->info.mode_info.cdma_info.packet_zone );

  if( tbl_entry_ptr != NULL )
  {
    if(tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime > uptime )
    {
      ss_ptr->info.main_thr_status.ss_thr_status = TRUE;
    }
    ss_ptr->info.main_thr_status.thr_uptime  = tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime;
    ss_ptr->info.main_thr_status.idx         = tbl_entry_ptr->cmss_orig_thr_tbl.idx;
    ss_ptr->info.main_thr_status.call_status =
                                   tbl_entry_ptr->cmss_orig_thr_tbl.orig_call_info.call_status;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If FEATURE_CM_TECH_SPEC_SRV_IND is not defined, we need to update the
  ** HDR throttle status only if hybrid is ON. If hybrid is off, HDR is
  ** running on main and its status is already taken care of by the main_thr_status
  */
  /* If FEATURE_CM_TECH_SPEC_SRV_IND is defined, we need to update the
  ** HDR throttle status from hdr_sys_id, regardless of whether hybrid is ON
  ** or OFF and update the hdr_thr_status with it.
  */
  tbl_entry_ptr  =  NULL;
  if ( cmss_is_hybr_status_on())

  {
    tbl_entry_ptr = cmss_orig_thr_get_orig_tbl_entry(
                              ss_ptr->cmss_orig_thr_tbl_ptr,
                              ss_ptr->info.hdr_sys_id,
                              ss_ptr->info.hybrid_active_band,
                              ss_ptr->info.mode_info.cdma_info.packet_zone );
    if( tbl_entry_ptr != NULL )
    {
      if(tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime > uptime )
      {
        ss_ptr->info.hdr_thr_status.ss_thr_status = TRUE;
      }
      ss_ptr->info.hdr_thr_status.thr_uptime  = tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime;
      ss_ptr->info.hdr_thr_status.idx         = tbl_entry_ptr->cmss_orig_thr_tbl.idx;
      ss_ptr->info.hdr_thr_status.call_status =
                                   tbl_entry_ptr->cmss_orig_thr_tbl.orig_call_info.call_status;
    }
  }
  #endif // FEATURE_CALL_THROTTLE
  /* If throttle status has changed return TRUE
  */
  if( ( ss_ptr->info.main_thr_status.ss_thr_status !=
        ss_ptr->new_srv_avl_info[subId].stack_info[cmss_map_ss_to_stack_info(CM_SS_MAIN)].thr_status.ss_thr_status ) ||
      ( ss_ptr->info.hdr_thr_status.ss_thr_status !=
        ss_ptr->new_srv_avl_info[subId].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_1)].thr_status.ss_thr_status)
      )
  {
    return TRUE;
  }
  return FALSE;

}/* cmss_update_thr_status */

/*===========================================================================

FUNCTION cmss_set_hdr_no_srv_per_uptime

DESCRIPTION
  If the HDR no_srv_uptime is still running, and the outgoing payload for
  CM_SS_EVENT_SRV_CHANGED has HDR service as NO_SRV, toggle it back to the
  previous value.

  Exception:
    If outgoing payload indicates 3gpp service on Main/Hybr2 stack.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  Changes Serving System object
===========================================================================*/
void cmss_set_hdr_no_srv_per_uptime(

     cm_mm_ss_info_s_type     *new_srv_info
)
{
  #ifdef FEATURE_HDR_HYBRID

  cmss_s_type          *ss_ptr = NULL;
      /* Point at serving system object to be initialized */

  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_1) ;
      
  uint8                    stk_id = cmph_ptr()->ss_subs_map[CM_SS_HYBR_1].stack_id;

  /* Invalid input parameter. */
  if ( new_srv_info == NULL )
  {
    return;
  }

  ss_ptr = cmss_ptr();

  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* No change in HDR service or Non-Hybrid operation. */
  if ( new_srv_info->hdr_srv_status == ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status
     ||new_srv_info->hdr_hybrid     == FALSE )
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Outgoing payload has HDR service status as NO_SRV and hdr_no_srv_uptime
  ** has not yet expired.
  */
  if ( new_srv_info->hdr_srv_status == SYS_SRV_STATUS_NO_SRV    &&
       ss_ptr->hdr_no_srv_uptime    != CMSS_NO_SRV_UPTIME_NONE  &&
       ss_ptr->hdr_no_srv_uptime    > time_get_uptime_secs() &&
       ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode == SYS_SYS_MODE_HDR)
  {
    /* 3GPP service reported on Main/Hybr2 so need to suppress HDR service loss.
    */
    if ( sys_srv_status_is_srv( new_srv_info->gw_srv_status ) ||   //Hybr2
         ( sys_srv_status_is_srv( new_srv_info->srv_status )    && //Main
           CM_IS_MODE_3GPP( new_srv_info->sys_mode )
         )
       )
    {
      return;
    }

    /* Set HDR service status same as previous reported value. */
    new_srv_info->hdr_srv_status = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #endif
}


/*===========================================================================

FUNCTION cmss_change_fields2_mapping_info

DESCRIPTION
  Copy the change fields2 from SS_INFO_PTR(change fields).

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  TRUE if serving system information is valid, FALSE otherwise.

  Note that serving system information only becomes valid after cmss_init()
  returns.

SIDE EFFECTS
  none

===========================================================================*/
   void cmss_change_fields2_mapping_info(

        cm_mm_msim_ss_info_s_type    *old_srv_info,


        cm_mm_msim_ss_info_s_type    *new_srv_info
  )
  {


    uint16 index = 0 ;

    for(index = 0 ; index <=1 ; index++)
      {

      /**
         If we initially have HDR on second stack and now we have LTE on second stack or vice versa than we need to changemake change filelds as all set
      */

      if( (index == 1) &&
          (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) || cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_2)) &&
          (((new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_LTE) &&
            (old_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_HDR))
           ||
           ((new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_HDR) &&
            (old_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_LTE))
          )
        )
      {
        new_srv_info->stack_info[index].changed_fields2 = 0xFFFFFFFFFFFFFFFF ;
        break ;
      }

      if((index == 1) &&
         (new_srv_info->stack_info[index].is_operational != old_srv_info->stack_info[index].is_operational))
      {
        new_srv_info->stack_info[index].changed_fields2 = 0xFFFFFFFFFFFFFFFF ;
        break ;
      }

      if(new_srv_info->stack_info[index].lte_ims_emerg_avail != old_srv_info->stack_info[index].lte_ims_emerg_avail)
      {
      new_srv_info->stack_info[index].changed_fields2 |= CM_SS_EVT_LTE_IMS_EMERG_AVAIL_MASK;
      }


      if(new_srv_info->stack_info[index].cell_info.emerg_access_status != old_srv_info->stack_info[index].cell_info.emerg_access_status)
      {
        new_srv_info->stack_info[index].changed_fields2 |= CM_SS_EVT_LTE_EMERG_ACCESS_BARRED_MASK;
      }

      if(new_srv_info->stack_info[index].cell_info.lte_cell_access_status != old_srv_info->stack_info[index].cell_info.lte_cell_access_status)
      {
        new_srv_info->stack_info[index].changed_fields2 |= CM_SS_EVT_LTE_CELL_ACCESS_STATUS_MASK;
      }


      if( new_srv_info->stack_info[index].reg_reject_info.reject_cause != old_srv_info->stack_info[index].reg_reject_info.reject_cause ||
        new_srv_info->stack_info[index].reg_reject_info.reject_srv_domain !=  old_srv_info->stack_info[index].reg_reject_info.reject_srv_domain)
      {
         new_srv_info->stack_info[index].changed_fields2 |= CM_SS_EVT_LU_REJECT_MASK;
      }




      if(new_srv_info->stack_info[index].available_plmn_type  !=  old_srv_info->stack_info[index].available_plmn_type )
      {
        new_srv_info->stack_info[index].changed_fields2 |= CM_SS_EVT_SGLTE_REG_DOMAIN_CHANGED_MASK;
      }


      if(new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_CDMA)
      {
        if( (new_srv_info->stack_info[index].rat_mode_info.cdma_mode_info.height  !=  old_srv_info->stack_info[0].rat_mode_info.cdma_mode_info.height) ||
            (new_srv_info->stack_info[index].rat_mode_info.cdma_mode_info.horiz_uncertainty  !=  old_srv_info->stack_info[0].rat_mode_info.cdma_mode_info.horiz_uncertainty) ||
            (new_srv_info->stack_info[index].rat_mode_info.cdma_mode_info.vert_uncertainty  !=  old_srv_info->stack_info[0].rat_mode_info.cdma_mode_info.vert_uncertainty)
      )
        {
          new_srv_info->stack_info[index].changed_fields2 |= CM_SS_EVT_POSITION_INFO_MASK;
        }
      }

      if(new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_HDR)
      {

        if((new_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.latitude  != old_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.latitude ) ||
       (new_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.longitude  != old_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.longitude )
          )
        {
          new_srv_info->stack_info[index].changed_fields2 |= CM_SS_EVT_HDR_BASE_STATION_PARMS_MASK;
        }

        if(new_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.mcc != old_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.mcc )
        {
          new_srv_info->stack_info[index].changed_fields2 |= CM_SS_EVT_HDR_MCC_MASK;
        }

        if(new_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.system_type != old_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.system_type)
        {
          new_srv_info->stack_info[index].changed_fields2 |= CM_SS_EVT_HDR_SYS_TYPE_MASK;
        }


      }

      }



  }


/*===========================================================================

FUNCTION cmss_change_fields_mapping_info

DESCRIPTION
  Copy the change fields from SS_INFO_PTR(change fields).

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  TRUE if serving system information is valid, FALSE otherwise.

  Note that serving system information only becomes valid after cmss_init()
  returns.

SIDE EFFECTS
  none

===========================================================================*/
   void cmss_change_fields_mapping_info(

        cm_mm_msim_ss_info_s_type    *old_srv_info,


        cm_mm_msim_ss_info_s_type    *new_srv_info
  )
  {

    #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined(FEATURE_WCDMA))
      cmss_s_type          *ss_ptr        =  cmss_ptr();
    #endif


    uint16 index = 0 ;


    /* Set the mask if SS event is due to CELL_INFO_CNF from RRC */
    #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined(FEATURE_WCDMA))

    if(new_srv_info->asubs_id == SYS_MODEM_AS_ID_1)
    {
      if (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
      {
        new_srv_info->changed_fields_subs |= CM_SS_EVT_CELLID_DCH_MASK;
      }
      else
      {
        ss_ptr->new_srv_avl_info[SYS_MODEM_AS_ID_1].changed_fields_subs &= (~CM_SS_EVT_CELLID_DCH_MASK);
      }
    }

    #endif
    if(new_srv_info->eutra_detect_status !=  old_srv_info->eutra_detect_status)
    {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_EUTRA_DETECT_MASK;
    }

    if(new_srv_info->is_csfb_call_active  !=  old_srv_info->is_csfb_call_active)
    {
      new_srv_info->changed_fields_subs|= CM_SS_EVT_CSFB_CALL_ACTIVE_MASK ;
    }

    if(new_srv_info->msm_id !=  old_srv_info->msm_id)
    {
      new_srv_info->changed_fields_subs|= CM_SS_EVT_MSM_ID_MASK ;
    }

    if (memcmp(&(new_srv_info->prl_3gpp2_mcc), &(old_srv_info->prl_3gpp2_mcc),
               sizeof(sys_plmn_mcc_list)) != 0
    )
    {
      CM_MSG_HIGH_0("3GPP2_MCC: MASK is set");
      new_srv_info->changed_fields_subs |= CM_SS_EVT_PRL_3GPP2_MCC_MASK;
    }

    if (memcmp(&(new_srv_info->prl_hdr_mcc), &(old_srv_info->prl_hdr_mcc),
               sizeof(sys_plmn_mcc_list)) != 0
    )
    {
      CM_MSG_HIGH_0("HDR_MCC: MASK is set");
      new_srv_info->changed_fields_subs |= CM_SS_EVT_PRL_HDR_MCC_MASK;
    }

    if(new_srv_info->current_mcc != old_srv_info->current_mcc)
    {
    new_srv_info->changed_fields_subs |= CM_SS_EVT_CUR_MCC_MASK;
    }

    if(new_srv_info->home_mcc!= old_srv_info->home_mcc)
    {
    new_srv_info->changed_fields_subs |= CM_SS_EVT_HOME_MCC_MASK;
    }

    if(new_srv_info->plus_dial_setting != old_srv_info->plus_dial_setting)
    {
    new_srv_info->changed_fields_subs |= CM_SS_EVT_PLUS_DIAG_SETTING_MASK;
    }

    if(  new_srv_info->target_rat!= old_srv_info->target_rat)
    {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_TARGET_RAT_MASK ;
    }

    if(  new_srv_info->irat_ctxt_target_rat != old_srv_info->irat_ctxt_target_rat)
    {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_IRAT_CTXT_TRGT_RAT_MASK ;
    }

    if(  new_srv_info->gwl_irat_asubs_id!= old_srv_info->gwl_irat_asubs_id)
    {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_GWL_IRAT_ASUBS_ID_MASK ;
    }

    if(  new_srv_info->voice_domain != old_srv_info->voice_domain)
    {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_VOICE_DOMAIN_MASK ;
    }

    if(  new_srv_info->sms_domain != old_srv_info->sms_domain)
    {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_SMS_DOMAIN_MASK ;
    }

    if(  new_srv_info->div_duplex != old_srv_info->div_duplex)
    {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_DIV_DUPLEX_MASK;
    }


    if(  new_srv_info->def_roam_ind != old_srv_info->def_roam_ind)
    {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_DEF_ROAM_IND_MASK;
    }


    if(  new_srv_info->ps_data_suspend != old_srv_info->ps_data_suspend)
    {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_PS_DATA_SUSPEND_MASK;
    }

    if(new_srv_info->bsr_in_progress !=  old_srv_info->bsr_in_progress)
      {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_BSR_PROGRESS_MASK;
      }


    if((new_srv_info->ipapp_info.reg_status!=  old_srv_info->ipapp_info.reg_status) ||
       (new_srv_info->ipapp_info.cause!=  old_srv_info->ipapp_info.cause)  ||
        (memcmp(new_srv_info->ipapp_info.sys_mode, old_srv_info->ipapp_info.sys_mode, \
                sizeof(new_srv_info->ipapp_info.sys_mode)) != 0) ||
        (memcmp(new_srv_info->ipapp_info.call_type_mask, old_srv_info->ipapp_info.call_type_mask,\
                sizeof(new_srv_info->ipapp_info.call_type_mask)) != 0)
       )
      {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_IPPAPP_INFO_MASK;
      }

    if(new_srv_info->gan_info.gan_conn_status!=  old_srv_info->gan_info.gan_conn_status)
      {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_GAN_CONN_STATUS_MASK;
      }

    if((new_srv_info->gan_info.gan_error.gan_error_category !=  old_srv_info->gan_info.gan_error.gan_error_category)||
      (new_srv_info->gan_info.gan_error.gan_error_codepoint!=  old_srv_info->gan_info.gan_error.gan_error_codepoint))
      {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_GAN_ERROR_PROMPT_MASK;
      }

    if((new_srv_info->gan_info.gan_mode_display.is_mode_display_on !=  old_srv_info->gan_info.gan_mode_display.is_mode_display_on)||
      (new_srv_info->gan_info.gan_mode_display.gan_usz_icon_indicator!=  old_srv_info->gan_info.gan_mode_display.gan_usz_icon_indicator) ||
      (new_srv_info->gan_info.gan_mode_display.gan_ms_location_status!=  old_srv_info->gan_info.gan_mode_display.gan_ms_location_status))
      {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_GAN_MODE_DISPLAY_MASK;
      }

    if(new_srv_info->gan_info.gan_sig_chan_status!=  old_srv_info->gan_info.gan_sig_chan_status)
      {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_GAN_SIG_CHAN_STATUS_MASK;
      }

    if(new_srv_info->gan_info.gan_state!=  old_srv_info->gan_info.gan_state)
      {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_GAN_STATE_MASK;
      }

    if(new_srv_info->meas_resp.sys_mode !=  old_srv_info->meas_resp.sys_mode)
      {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_MEAS_RESP_MASK;
      }


    if(new_srv_info->meas_resp.info.hdr_resp.meas_status !=  old_srv_info->meas_resp.info.hdr_resp.meas_status)
      {
      new_srv_info->changed_fields_subs |= CM_SS_EVT_MEAS_RESP_MASK;
      }

    for(index = 0 ; index <=1 ; index++)
      {

      const sys_time_info_s_type   *new_time = &(new_srv_info->stack_info[index].mode_info.cdma_info.time_info) ;

      const sys_time_info_s_type   *old_time = &(old_srv_info->stack_info[index].mode_info.cdma_info.time_info) ;


  /**
     If we initially have HDR on second stack and now we have LTE on second stack or vice versa than we need to changemake change filelds as all set
  */
      if( (index == 1) &&
          (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) || cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_2)) &&
          (((new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_LTE) &&
            (old_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_HDR))
           ||
           ((new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_HDR) &&
            (old_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_LTE))
          )
        )
      {
        CM_MSG_HIGH_0("Resetting all fields");
        new_srv_info->stack_info[index].changed_fields = 0xFFFFFFFFFFFFFFFF ;
        break ;
      }


     if((index == 1) &&
        (new_srv_info->stack_info[index].is_operational != old_srv_info->stack_info[index].is_operational))
     {
       CM_MSG_HIGH_0("Resetting all fields operational changed");
       new_srv_info->stack_info[index].changed_fields = 0xFFFFFFFFFFFFFFFF ;
       break ;
     }

     if(new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_LTE)
      {
        if(new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.voice_support_on_lte != old_srv_info->stack_info[index].rat_mode_info.lte_mode_info.voice_support_on_lte)
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_VOICE_SUPPORT_ON_LTE_MASK;
        }
      }

      if(new_srv_info->stack_info[index].lte_ims_voice_avail != old_srv_info->stack_info[index].lte_ims_voice_avail)
      {
       new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_LTE_IMS_VOICE_AVAIL_MASK;
      }

      if ((new_srv_info->stack_info[0].sys_mode == SYS_SYS_MODE_WCDMA)
      ||
      (new_srv_info->stack_info[0].sys_mode == SYS_SYS_MODE_GSM)
      ||
      (new_srv_info->stack_info[0].sys_mode == SYS_SYS_MODE_LTE))
      {
        transition_rats = TRUE;
      }

      if ( ( new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_CDMA||
               new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_HDR))
        {
          if ( old_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_CDMA||
               old_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_HDR)
          {
            transition_rats = FALSE;
            if(new_time->sys_mode != old_time->sys_mode)
            {
              CM_MSG_HIGH_2("new_cmss : time:main-old mode %d new mode %d",
                                     old_time->sys_mode,
                                     new_time->sys_mode);
              /* time is always updated in idx[0] for CDMA and HDR */
              new_srv_info->stack_info[0].changed_fields |= CM_SS_EVT_CDMA_TIME_CHGD_MASK;
              new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_CDMA_TIME_CHGD_MASK;
            }
          }
          else
          {
            CM_MSG_HIGH_0("new_cmss : adding mask CDMA_TIME");
            transition_rats = TRUE;
             /* time is always updated in idx[0] for CDMA and HDR */
             new_srv_info->stack_info[0].changed_fields  |= CM_SS_EVT_CDMA_TIME_CHGD_MASK;
             new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_CDMA_TIME_CHGD_MASK;
          }
      }

      if (new_time->sys_mode == SYS_SYS_MODE_CDMA)
      {
         if( (new_time->time.cdma_time.daylt_savings !=
             old_time->time.cdma_time.daylt_savings) ||
            (new_time->time.cdma_time.ltm_offset !=
            old_time->time.cdma_time.ltm_offset) ||
            (new_time->time.cdma_time.lp_sec !=
            old_time->time.cdma_time.lp_sec) )
         {
           new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_CDMA_TIME_CHGD_MASK;

          }
      }



    if (new_time->sys_mode == SYS_SYS_MODE_HDR)
    {
       if( (new_time->time.hdr_time.ltm_offset != old_time->time.hdr_time.ltm_offset) ||
           (new_time->time.hdr_time.lp_sec     != old_time->time.hdr_time.lp_sec) )
       {
          new_srv_info->stack_info[index].changed_fields  |= CM_SS_EVT_CDMA_TIME_CHGD_MASK;
        }
     }


    if ((old_srv_info->stack_info[index].sys_mode != SYS_SYS_MODE_WCDMA)
         &&
         (old_srv_info->stack_info[index].sys_mode != SYS_SYS_MODE_GSM)
         &&
         (old_srv_info->stack_info[index].sys_mode != SYS_SYS_MODE_LTE))

    {
       if (old_time->sys_mode != new_time->sys_mode)
       {

       new_srv_info->stack_info[index].changed_fields  |= CM_SS_EVT_CDMA_TIME_CHGD_MASK;
       }
    }


      if(new_srv_info->stack_info[index].srv_status != old_srv_info->stack_info[index].srv_status)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SRV_STATUS_MASK ;

        if(sys_srv_status_is_srv(new_srv_info->stack_info[index].srv_status))
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SYS_ID_MASK;
        }

      }
      

      if(new_srv_info->stack_info[index].true_srv_status != old_srv_info->stack_info[index].true_srv_status)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_TRUE_SRV_STATUS_MASK ;
      }

      if(new_srv_info->stack_info[index].srv_domain != old_srv_info->stack_info[index].srv_domain)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SRV_DOMAIN_MASK ;
      }

	  if(new_srv_info->stack_info[index].effective_srv_domain != old_srv_info->stack_info[index].effective_srv_domain)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_EFFECTV_SRV_DOMAIN_MASK ;
      }

      if(new_srv_info->stack_info[index].srv_capability != old_srv_info->stack_info[index].srv_capability)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SRV_CAPABILITY_MASK ;
      }
      if(new_srv_info->stack_info[index].sys_mode != old_srv_info->stack_info[index].sys_mode)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SYS_MODE_MASK ;
      }
      //below for mode info
      if(new_srv_info->stack_info[index].sys_mode== SYS_SYS_MODE_CDMA)
      {
        if(new_srv_info->stack_info[index].mode_info.cdma_info.reg_zone != old_srv_info->stack_info[index].mode_info.cdma_info.reg_zone)
        {
            new_srv_info->stack_info[index].changed_fields     |= CM_SS_EVT_REG_ZONE_MASK;
        }

        if(new_srv_info->stack_info[index].mode_info.cdma_info.packet_zone != old_srv_info->stack_info[index].mode_info.cdma_info.packet_zone)
        {
           new_srv_info->stack_info[index].changed_fields        |= CM_SS_EVT_PACKET_ZONE_MASK;
        }
        if(new_srv_info->stack_info[index].mode_info.cdma_info.bs_p_rev != old_srv_info->stack_info[index].mode_info.cdma_info.bs_p_rev)
        {
          new_srv_info->stack_info[index].changed_fields     |= CM_SS_EVT_BS_P_REV_MASK;
        }
        if(new_srv_info->stack_info[index].mode_info.cdma_info.p_rev_in_use != old_srv_info->stack_info[index].mode_info.cdma_info.p_rev_in_use)
        {
          new_srv_info->stack_info[index].changed_fields         |= CM_SS_EVT_P_REV_IN_USE_MASK;
        }

        if ( new_srv_info->stack_info[index].mode_info.cdma_info.ccs_supported != old_srv_info->stack_info[index].mode_info.cdma_info.ccs_supported )
        {
          new_srv_info->stack_info[index].changed_fields          |= CM_SS_EVT_CCS_SUPPORTED_MASK;
        }
        if ( new_srv_info->stack_info[index].sys_mode == old_srv_info->stack_info[index].sys_mode &&
           ( old_srv_info->stack_info[index].mode_info.cdma_info.base_lat !=
                                   new_srv_info->stack_info[index].mode_info.cdma_info.base_lat ||
             old_srv_info->stack_info[index].mode_info.cdma_info.base_long !=
                                   new_srv_info->stack_info[index].mode_info.cdma_info.base_long ||
             old_srv_info->stack_info[index].mode_info.cdma_info.base_id !=
                                       new_srv_info->stack_info[index].mode_info.cdma_info.base_id ||
             old_srv_info->stack_info[index].mode_info.cdma_info.srch_win_n !=
                                       new_srv_info->stack_info[index].mode_info.cdma_info.srch_win_n
           )
         )
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_BASE_STATION_PARMS_CHGD_MASK;
        }
      }

      if(new_srv_info->stack_info[index].roam_status != old_srv_info->stack_info[index].roam_status)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_ROAM_STATUS_MASK ;
      }

      //sys id masking
      if(new_srv_info->stack_info[index].sys_id.id.is95.sid != old_srv_info->stack_info[index].sys_id.id.is95.sid)
      {
        new_srv_info->stack_info[index].changed_fields     |= CM_SS_EVT_SID_MASK;
        new_srv_info->stack_info[index].changed_fields     |= CM_SS_EVT_SYS_ID_MASK;
      }

      if(new_srv_info->stack_info[index].sys_id.id.is95.nid != old_srv_info->stack_info[index].sys_id.id.is95.nid)
      {
        new_srv_info->stack_info[index].changed_fields     |= CM_SS_EVT_NID_MASK;
        new_srv_info->stack_info[index].changed_fields     |= CM_SS_EVT_SYS_ID_MASK;
      }

      /*
         ** If the system identifier has changed, notify CM clients of the
         ** corresponding event.
         */
      if ( !cmss_sys_id_match( new_srv_info->stack_info[index].sys_id, old_srv_info->stack_info[index].sys_id ) )
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SYS_ID_MASK;

           /*
           ** Decide whether the SID and NID Mask fields need to be set also.
           */
           if ((new_srv_info->stack_info[index].sys_id.id_type == SYS_SYS_ID_TYPE_IS95) &&
               (old_srv_info->stack_info[index].sys_id.id_type == SYS_SYS_ID_TYPE_IS95))
           {
             if (new_srv_info->stack_info[index].sys_id.id.is95.nid != old_srv_info->stack_info[index].sys_id.id.is95.nid)
             {
               new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_NID_MASK;
             }

             if (new_srv_info->stack_info[index].sys_id.id.is95.sid != old_srv_info->stack_info[index].sys_id.id.is95.sid)
             {
               new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SID_MASK;
             }
             if( new_srv_info->stack_info[index].sys_id.id.is95.mcc != old_srv_info->stack_info[index].sys_id.id.is95.mcc )
             {
               new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_MCC_MASK;
             }

             if(new_srv_info->stack_info[index].sys_id.id.is95.imsi_11_12 != old_srv_info->stack_info[index].sys_id.id.is95.imsi_11_12 )
             {
               new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_IMSI_11_12_MASK;
             }
           }
           else if ((new_srv_info->stack_info[index].sys_id.id_type == SYS_SYS_ID_TYPE_IS95) &&
                    (old_srv_info->stack_info[index].sys_id.id_type != SYS_SYS_ID_TYPE_IS95))
           {
              new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_NID_MASK;
              new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SID_MASK;
              new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_MCC_MASK;
              new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_IMSI_11_12_MASK;
           }
         }


      if(new_srv_info->stack_info[index].is_sys_prl_match != old_srv_info->stack_info[index].is_sys_prl_match)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SYS_PRL_MATCH_MASK ;
      }
      if(new_srv_info->stack_info[index].is_sys_forbidden != old_srv_info->stack_info[index].is_sys_forbidden)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SYS_FORBIDDEN_MASK;
      }


      if(new_srv_info->stack_info[index].rssi2 != old_srv_info->stack_info[index].rssi2)
        {
          // no mask related to this
        }



      switch(new_srv_info->stack_info[index].sys_mode)
      {
        case  SYS_SYS_MODE_LTE:

        if(new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.tac !=  old_srv_info->stack_info[index].rat_mode_info.lte_mode_info.tac)
        {
            new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_LAC_TAC_RAC_CHGD_MASK ;
        }
        if(new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.rac_or_mme_code !=  old_srv_info->stack_info[index].rat_mode_info.lte_mode_info.rac_or_mme_code)
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_LAC_TAC_RAC_CHGD_MASK ;
        }

        if(new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status!=  old_srv_info->stack_info[index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status )
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_LTE_EMBMS_INFO_MASK;
        }
        break ;

        case SYS_SYS_MODE_GSM:
        if(new_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.rac_or_mme_code !=  old_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.rac_or_mme_code)
          {
            new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_LAC_TAC_RAC_CHGD_MASK ;
          }
        if(new_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.lac !=  new_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.lac)
          {
            new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_LAC_TAC_RAC_CHGD_MASK ;
          }
        break ;

        case SYS_SYS_MODE_WCDMA:
        if(new_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.lac !=  old_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.lac)
          {
            new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_LAC_TAC_RAC_CHGD_MASK ;
          }

        if(new_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.rac_or_mme_code!=old_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.rac_or_mme_code)
          {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_LAC_TAC_RAC_CHGD_MASK;
          }
        break ;

        case SYS_SYS_MODE_TDS:
        if(new_srv_info->stack_info[index].rat_mode_info.tds_mode_info.lac !=  old_srv_info->stack_info[index].rat_mode_info.tds_mode_info.lac )
          {
            new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_LAC_TAC_RAC_CHGD_MASK ;
          }

        if(new_srv_info->stack_info[index].rat_mode_info.tds_mode_info.rac_or_mme_code!= old_srv_info->stack_info[index].rat_mode_info.tds_mode_info.rac_or_mme_code)
          {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_LAC_TAC_RAC_CHGD_MASK;
          }
        break ;

        default:
         break;

      }

      if(new_srv_info->stack_info[index].psist !=  old_srv_info->stack_info[index].psist)
        {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_PSIST_CHGD_MASK ;
        }
      if(new_srv_info->stack_info[index].active_band  !=  old_srv_info->stack_info[index].active_band)
        {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_ACTIVE_BAND_MASK ;
        }
      if(new_srv_info->stack_info[index].active_channel !=  old_srv_info->stack_info[index].active_channel)
        {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_ACTIVE_CHANNEL_MASK;
        }
      if(new_srv_info->curr_uptime !=  old_srv_info->curr_uptime)
        {
        //not able to find mask
        }

      if(new_srv_info->asubs_id == SYS_MODEM_AS_ID_1)
      {
      if(new_srv_info->stack_info[index].thr_status.ss_thr_status!=  old_srv_info->stack_info[index].thr_status.ss_thr_status)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_ORIG_THR_STATUS_MASK;
      }
       if(( new_srv_info->stack_info[index].thr_status.thr_uptime!=
        old_srv_info->stack_info[index].thr_status.thr_uptime
      ) ||
     ( new_srv_info->stack_info[index].thr_status.idx !=
        old_srv_info->stack_info[index].thr_status.idx) ||
            ( new_srv_info->stack_info[index].thr_status.call_status !=
             old_srv_info->stack_info[index].thr_status.call_status)
     )
        {
         new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_ORIG_THR_STATUS_MASK;
        }
      }

      if ((new_srv_info->stack_info[index].cell_info.cell_id != old_srv_info->stack_info[index].cell_info.cell_id )||
          (new_srv_info->stack_info[index].cell_info.as_sys_mode != old_srv_info->stack_info[index].cell_info.as_sys_mode ) ||
          ((new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_LTE) && (new_srv_info->stack_info[index].cell_info.tac != old_srv_info->stack_info[index].cell_info.tac )) ||
          (new_srv_info->stack_info[index].cell_info.plmn_id.identity[0] != old_srv_info->stack_info[index].cell_info.plmn_id.identity[0]) ||
          (new_srv_info->stack_info[index].cell_info.plmn_id.identity[1] != old_srv_info->stack_info[index].cell_info.plmn_id.identity[1]) ||
          (new_srv_info->stack_info[index].cell_info.plmn_id.identity[2] != old_srv_info->stack_info[index].cell_info.plmn_id.identity[2]) ||
          (new_srv_info->stack_info[index].cell_info.earfcn_dl != old_srv_info->stack_info[index].cell_info.earfcn_dl)
      )

      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_CELL_INFO_MASK;
      }

        if(new_srv_info->stack_info[index].cell_srv_ind.hs_ind
        != old_srv_info->stack_info[index].cell_srv_ind.hs_ind )
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SRV_IND_MASK;
        }

      /* If HS call indication has changed, set mask
        */
      if ( new_srv_info->stack_info[index].cell_srv_ind.hs_call_status
        != old_srv_info->stack_info[index].cell_srv_ind.hs_call_status)
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SRV_IND_MASK;
        }

        /* If DTM indication has changed, set mask
        */
        if ( new_srv_info->stack_info[index].cell_srv_ind.dtm_supp
        != old_srv_info->stack_info[index].cell_srv_ind.dtm_supp )
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SRV_IND_MASK;
        }
        /* If EGPRS indication has changed, set mask
        */
        if ( new_srv_info->stack_info[index].cell_srv_ind.egprs_supp
        != old_srv_info->stack_info[index].cell_srv_ind.egprs_supp )
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SRV_IND_MASK;
        }

      if((new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_CDMA) && new_srv_info->stack_info[index].rat_mode_info.cdma_mode_info.cdma_reg_prd  !=  old_srv_info->stack_info[0].rat_mode_info.cdma_mode_info.cdma_reg_prd)
        {
        // not able
        }

      if ( new_srv_info->stack_info[index].cell_bc_info.cell_bc_capability !=
           old_srv_info->stack_info[index].cell_bc_info.cell_bc_capability)
      {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_CELL_BROADCAST_MASK;
      }
      if(new_srv_info->stack_info[index].bcmcs_srv_supported  !=  old_srv_info->stack_info[index].bcmcs_srv_supported )
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_BCMCS_SRV_SUPPORTED_MASK;
        }
      if(new_srv_info->stack_info[index].bcmcs_srv_status  !=  old_srv_info->stack_info[index].bcmcs_srv_status )
        {
        new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_BCMCS_SRV_STATUS_MASK;
        }

      switch(new_srv_info->stack_info[index].sys_mode)
      {
        case  SYS_SYS_MODE_LTE:
          if ( !(new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID) &&
               (new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.csg_id          != old_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.csg_id               || \
                new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.hnb_name.length != old_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.hnb_name.length      || \
            0 != strcmp((char*)new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.hnb_name.name,
                (char*)old_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.hnb_name.name) ||
                 ( new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID && \
                   new_srv_info->stack_info[index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS &&
                   ( !cmss_sys_id_match( new_srv_info->stack_info[index].sys_id, old_srv_info->stack_info[index].sys_id ) )))
             )
          {
            new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_CSG_INFO_CHANGED_MASK;
          }

          break ;

        case SYS_SYS_MODE_GSM:
          if ( !(new_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID) &&
           (new_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.csg_info.csg_id          != old_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.csg_info.csg_id               || \
                new_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.csg_info.hnb_name.length != old_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.csg_info.hnb_name.length      || \
            0 != strcmp((char*)new_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.csg_info.hnb_name.name,
                (char*)old_srv_info->stack_info[index].rat_mode_info.gsm_mode_info.csg_info.hnb_name.name) ||
                 ( new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID && \
                   new_srv_info->stack_info[index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS &&
                   ( !cmss_sys_id_match( new_srv_info->stack_info[index].sys_id, old_srv_info->stack_info[index].sys_id ) )))
             )
          {
            new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_CSG_INFO_CHANGED_MASK;
          }

          break ;

        case SYS_SYS_MODE_WCDMA:
          if ( !(new_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID) &&
               (new_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.csg_info.csg_id          != old_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.csg_info.csg_id               || \
                new_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.length != old_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.length      || \
            0 != strcmp((char*)new_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.name,
                (char*)old_srv_info->stack_info[index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.name) ||
                 ( new_srv_info->stack_info[index].rat_mode_info.lte_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID && \
                   new_srv_info->stack_info[index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS &&
                   ( !cmss_sys_id_match( new_srv_info->stack_info[index].sys_id, old_srv_info->stack_info[index].sys_id ) )))
             )
          {
            new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_CSG_INFO_CHANGED_MASK;
          }

          break;

        default:
          break;

      }


      if(new_srv_info->stack_info[index].sys_mode == SYS_SYS_MODE_HDR)
      {
        if(new_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.hdr_active_prot  != old_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.hdr_active_prot)
          {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_HDR_ACTIVE_PROT_MASK;
          }
        if(new_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.subnet_mask_len  != old_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.subnet_mask_len )
          {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SYS_ID_MASK;
          }
        if(new_srv_info->stack_info[index].prev_idle_digital_mode  != old_srv_info->stack_info[index].prev_idle_digital_mode)
          {//need to discuss
          }
        if(new_srv_info->stack_info[index].cur_idle_digital_mode  != old_srv_info->stack_info[index].cur_idle_digital_mode )
          {//need to discuss
          }

        if(new_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.hdr_personality  != old_srv_info->stack_info[index].rat_mode_info.hdr_mode_info.hdr_personality )
          {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_HDR_PERSONALITY_MASK;
          }

        }

      if(CM_IS_MODE_3GPP(new_srv_info->stack_info[index].sys_mode))
      {

      if ( !cmss_sys_id_match( new_srv_info->stack_info[index].sys_id , old_srv_info->stack_info[index].sys_id ) )
        {

          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SYS_ID_MASK;

        }
      }
      if((new_srv_info->stack_info[index].sys_mode != SYS_SYS_MODE_CDMA) &&
         (new_srv_info->stack_info[index].sys_mode != SYS_SYS_MODE_HDR)
        )
      {
        if (new_srv_info->stack_info[index].mode_info.gw_info.sim_state != \
                   old_srv_info->stack_info[index].mode_info.gw_info.sim_state)
        {
          new_srv_info->stack_info[index].changed_fields |= CM_SS_EVT_SIM_STATE_MASK;
        }
      }

      }

  }


  
  /*===========================================================================
  
  FUNCTION cmss_reseting_helper
  
  DESCRIPTION
    Reseting the pointer with default values
  
  DEPENDENCIES
    Serving System object must have already been initialized with
    cmss_init().
  
  RETURN VALUE
  
  SIDE EFFECTS
    none
  
  ===========================================================================*/
  void  cmss_reseting_helper(  cm_mm_msim_ss_info_s_type    *new_info_ptr)
  {
  uint8 stk_id = 0 ;
  for(stk_id =0 ; stk_id <= 1; stk_id++ )
  {
    new_info_ptr->asubs_id               = SYS_MODEM_AS_ID_NONE;
    
    new_info_ptr->number_of_stacks       = 0 ;
    new_info_ptr->bsr_in_progress        = FALSE;
    new_info_ptr->eutra_detect_status    = SYS_EUTRA_DETECTION_UNKNOWN;
    new_info_ptr->gan_info.gan_state           =
                                                        SYS_GW_GAN_STATE_NONE;
    
    new_info_ptr->gan_info.gan_conn_status     =
                                                  SYS_GW_GAN_CONN_STATUS_NONE;
    
    new_info_ptr->gan_info.gan_sig_chan_status =
                                              SYS_GW_GAN_SIG_CHAN_STATUS_NONE;
    
    memset(&(new_info_ptr->gan_info.gan_mode_display), 0,
           sizeof(sys_gw_gan_mode_display_s_type));
    
    memset(&(new_info_ptr->gan_info.gan_error), 0,
           sizeof(sys_gw_gan_error_s_type));
    
    new_info_ptr->meas_resp.sys_mode             = SYS_SYS_MODE_NONE;
    new_info_ptr->meas_resp.info.hdr_resp.meas_status  =
                                                       CM_SS_MEAS_STATUS_NONE;
    
    new_info_ptr->voice_domain           = SYS_CM_DOMAIN_SEL_DOMAIN_MAX;
    new_info_ptr->sms_domain             = SYS_CM_DOMAIN_SEL_DOMAIN_MAX;
    
    new_info_ptr->div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
    new_info_ptr->def_roam_ind = SYS_ROAM_STATUS_OFF;
    
    new_info_ptr->ps_data_suspend        = FALSE;
    /*********************************************************************************/
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
    #if ( !defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) )
    new_info_ptr->stack_info[stk_id].mode_info.cdma_info.time_info.sys_mode = SYS_SYS_MODE_NO_SRV;
    new_info_ptr->stack_info[stk_id].mode_info.cdma_info.base_id    = 0;
    new_info_ptr->stack_info[stk_id].mode_info.cdma_info.base_lat   = 0;
    new_info_ptr->stack_info[stk_id].mode_info.cdma_info.base_long  = 0;
    new_info_ptr->stack_info[stk_id].mode_info.cdma_info.srch_win_n = 0;
    
    #endif /* ( !defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) ) */
    #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */
    
    
    
    #ifdef CM_GW_SUPPORTED
    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
      (void) memset( &new_info_ptr->stack_info[stk_id].mode_info, 0,
                                        sizeof( cm_ss_info_u_type ) );
    
    
    #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */
    #endif /* defined CM_GW_SUPPORTED */
    
    
    /**************************************************************************************/
    new_info_ptr->stack_info[stk_id].changed_fields        = 0;
    new_info_ptr->stack_info[stk_id].changed_fields2        = 0;
    new_info_ptr->stack_info[stk_id].signal_strength_changed_fields        = 0;
    new_info_ptr->stack_info[stk_id].is_operational       = FALSE;
    
    
    
    
    new_info_ptr->stack_info[stk_id].srv_status         = SYS_SRV_STATUS_NO_SRV;
    new_info_ptr->stack_info[stk_id].true_srv_status    = SYS_SRV_STATUS_NO_SRV;
    new_info_ptr->stack_info[stk_id].sys_mode           = SYS_SYS_MODE_NO_SRV;
    new_info_ptr->stack_info[stk_id].roam_status        = SYS_ROAM_STATUS_OFF;
    new_info_ptr->stack_info[stk_id].srv_domain         = SYS_SRV_DOMAIN_NO_SRV;  
    new_info_ptr->stack_info[stk_id].srv_capability     = SYS_SRV_DOMAIN_NO_SRV;
    new_info_ptr->stack_info[stk_id].active_band        = SYS_BAND_CLASS_NONE;
    new_info_ptr->stack_info[stk_id].active_channel         = 0;
    new_info_ptr->stack_info[stk_id].mode_info.gw_info.bit_err_rate
                                              = CMSS_BER_VALUE_NO_SIGNAL;
    new_info_ptr->stack_info[stk_id].mode_info.gw_info.sim_state              = SYS_SIM_STATE_NOT_AVAILABLE;
    new_info_ptr->stack_info[stk_id].mode_info.gw_info.plmn_forbidden         = FALSE;
    
    #ifdef CM_GW_SUPPORTED
    #if (!defined(FEATURE_MMODE_CDMA_800) && !defined(FEATURE_MMODE_CDMA_1900))
    cm_ss_init_mm_information( &new_info_ptr->stack_info[stk_id].mode_info.gw_info.mm_information );
    #endif
    #endif
    
    sys_undefine_sys_id( &new_info_ptr->stack_info[stk_id].sys_id );
    new_info_ptr->stack_info[stk_id].is_sys_prl_match   = FALSE;
    new_info_ptr->stack_info[stk_id].is_sys_forbidden   = FALSE;
    new_info_ptr->stack_info[stk_id].rssi               = CMSS_RSSI_NO_SIGNAL;
    new_info_ptr->stack_info[stk_id].ecio               = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
    if(stk_id == 1)
    {
      new_info_ptr->stack_info[stk_id].ecio               = CMSS_ECIO_VALUE_NO_SIGNAL;
    }
    new_info_ptr->stack_info[stk_id].io                 = CMSS_IO_VALUE_NO_SIGNAL;
    new_info_ptr->stack_info[stk_id].sinr               = CMSS_SINR_VALUE_NO_SIGNAL;
    new_info_ptr->stack_info[stk_id].pathloss               = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
    new_info_ptr->stack_info[stk_id].sir                    = CMSS_SIR_VALUE_NO_SIGNAL;
    new_info_ptr->stack_info[stk_id].rssi2                  = CMSS_RSSI2_NO_SIGNAL;
    new_info_ptr->stack_info[stk_id].rscp                   = CMSS_RSCP_NO_SIGNAL;
    new_info_ptr->stack_info[stk_id].cqi_info.gw_cqi                     = CMSS_CQI_VALUE_NO_SIGNAL;
    new_info_ptr->stack_info[stk_id].cqi_info.num_cqi_samples            = 0;
    new_info_ptr->stack_info[stk_id].ecio_for_display       = FALSE;
    new_info_ptr->stack_info[stk_id].thr_status.ss_thr_status  = FALSE;
    new_info_ptr->stack_info[stk_id].thr_status.thr_uptime     = 0;
    new_info_ptr->stack_info[stk_id].thr_status.idx            = 0;
    new_info_ptr->stack_info[stk_id].thr_status.call_status = CM_SS_ORIG_THR_REASON_NONE;
    
    new_info_ptr->stack_info[stk_id].cell_info.cell_id  = CMSS_INVALID_CELL_ID_INFO;
    new_info_ptr->stack_info[stk_id].cell_info.emerg_access_status = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;
    new_info_ptr->stack_info[stk_id].cell_info.lte_cell_access_status = SYS_CELL_ACCESS_NONE;
    sys_plmn_undefine_plmn_id( &new_info_ptr->stack_info[stk_id].cell_info.plmn_id );
    new_info_ptr->stack_info[stk_id].cell_info.lac_id   = CMSS_INVALID_LAC_INFO;
    new_info_ptr->stack_info[stk_id].cell_info.arfcn     = CMSS_INVALID_ARFCN_INFO;
    new_info_ptr->stack_info[stk_id].cell_info.bsic      = CMSS_INVALID_BSIC_INFO;
    new_info_ptr->stack_info[stk_id].cell_info.psc       = CMSS_INVALID_PSC_INFO;
    new_info_ptr->stack_info[stk_id].cell_info.uarfcn_dl = CMSS_INVALID_UARFCN_DL_INFO;
    new_info_ptr->stack_info[stk_id].cell_info.uarfcn_ul = CMSS_INVALID_UARFCN_UL_INFO;
    new_info_ptr->stack_info[stk_id].cell_info.refpn     = CMSS_INVALID_REFPN_INFO;
    
    new_info_ptr->stack_info[stk_id].cell_srv_ind.egprs_supp      = SYS_EGPRS_SUPPORT_NOT_AVAIL;
    new_info_ptr->stack_info[stk_id].cell_srv_ind.hs_call_status =
                                           SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
    new_info_ptr->stack_info[stk_id].cell_srv_ind.hs_ind    = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
    new_info_ptr->stack_info[stk_id].cell_srv_ind.dtm_supp  = SYS_DTM_SUPPORT_NOT_AVAIL;
    
     new_info_ptr->stack_info[stk_id].reg_reject_info.reject_cause = 0;
     new_info_ptr->stack_info[stk_id].reg_reject_info.reject_srv_domain = SYS_SRV_DOMAIN_NONE;
     new_info_ptr->stack_info[stk_id].reg_reject_info.csg_id = SYS_CSG_ID_INVALID;
     sys_plmn_undefine_plmn_id(&(new_info_ptr->stack_info[stk_id].reg_reject_info.plmn));
     new_info_ptr->stack_info[stk_id].cipher_domain          = SYS_SRV_DOMAIN_NO_SRV;
     new_info_ptr->stack_info[stk_id].geo_sys_idx            = 0xFFFF;
     new_info_ptr->stack_info[stk_id].lte_ims_voice_avail = FALSE;
     new_info_ptr->stack_info[stk_id].lte_ims_emerg_avail = SYS_IMS_LTE_EMERG_SUPP_UNKNOWN;
    new_info_ptr->stack_info[stk_id].rat_mode_info.gsm_mode_info.lac                    = CMSS_INVALID_LAC_INFO;
    new_info_ptr->stack_info[stk_id].rat_mode_info.gsm_mode_info.rac_or_mme_code        = 0;
    new_info_ptr->stack_info[stk_id].rat_mode_info.gsm_mode_info.csg_info.csg_id = SYS_CSG_ID_INVALID;
    memset(&(new_info_ptr->stack_info[stk_id].rat_mode_info.gsm_mode_info.csg_info.hnb_name),0,sizeof(sys_home_nodeb_name_type));
    
    new_info_ptr->stack_info[stk_id].rat_mode_info.wcdma_mode_info.lac                    = CMSS_INVALID_LAC_INFO;
    new_info_ptr->stack_info[stk_id].rat_mode_info.wcdma_mode_info.rac_or_mme_code        = 0;
    new_info_ptr->stack_info[stk_id].rat_mode_info.wcdma_mode_info.csg_info.csg_id = SYS_CSG_ID_INVALID;
    memset(&(new_info_ptr->stack_info[stk_id].rat_mode_info.wcdma_mode_info.csg_info.hnb_name),0,sizeof(sys_home_nodeb_name_type));
    
    
    new_info_ptr->stack_info[stk_id].rat_mode_info.tds_mode_info.lac                    = CMSS_INVALID_LAC_INFO;
    new_info_ptr->stack_info[stk_id].rat_mode_info.tds_mode_info.rac_or_mme_code        = 0;
    new_info_ptr->stack_info[stk_id].rat_mode_info.tds_mode_info.csg_info.csg_id = SYS_CSG_ID_INVALID;
    memset(&(new_info_ptr->stack_info[stk_id].rat_mode_info.tds_mode_info.csg_info.hnb_name),0,sizeof(sys_home_nodeb_name_type));
     
    new_info_ptr->stack_info[stk_id].rat_mode_info.lte_mode_info.rsrp                   = 0;
    new_info_ptr->stack_info[stk_id].rat_mode_info.lte_mode_info.rsrq                   = 0;
     new_info_ptr->stack_info[stk_id].rat_mode_info.lte_mode_info.lac                    = CMSS_INVALID_LAC_INFO;
     new_info_ptr->stack_info[stk_id].rat_mode_info.lte_mode_info.tac                    = 0;
    new_info_ptr->stack_info[stk_id].rat_mode_info.lte_mode_info.rac_or_mme_code        = 0;
    new_info_ptr->stack_info[stk_id].rat_mode_info.lte_mode_info.csg_info.csg_id = SYS_CSG_ID_INVALID;
    memset(&(new_info_ptr->stack_info[stk_id].rat_mode_info.lte_mode_info.csg_info.hnb_name),0,sizeof(sys_home_nodeb_name_type));
    new_info_ptr->stack_info[stk_id].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status = SYS_EMBMS_COVERAGE_STATUS_INVALID;
    new_info_ptr->stack_info[stk_id].rat_mode_info.lte_mode_info.embms_info.trace_id = CMSS_EMBMS_TRACE_ID_NONE;
    
    new_info_ptr->stack_info[stk_id].rat_mode_info.lte_mode_info.voice_support_on_lte = FALSE;
    new_info_ptr->stack_info[stk_id].rat_mode_info.cdma_mode_info.cdma_reg_prd           = 0;
    new_info_ptr->stack_info[stk_id].rat_mode_info.cdma_mode_info.is_colloc          = FALSE;
  new_info_ptr->stack_info[stk_id].rat_mode_info.cdma_mode_info.height           = 0;
    new_info_ptr->stack_info[stk_id].rat_mode_info.cdma_mode_info.horiz_uncertainty           = 0;
  new_info_ptr->stack_info[stk_id].rat_mode_info.cdma_mode_info.vert_uncertainty           = 0;
    new_info_ptr->stack_info[stk_id].rat_mode_info.cdma_mode_info.frame_err_rate         = CMSS_FER_INVALID;
    
    new_info_ptr->stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_active_prot        = SYS_ACTIVE_PROT_NONE;
    new_info_ptr->stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_personality        = SYS_PERSONALITY_NONE;
    new_info_ptr->stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_ln_status          = SYS_HDR_LOCATION_NOTIFICATION_STATUS_NONE;
    new_info_ptr->stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_packet_err_rate    = CMSS_HDR_PER_INVALID;
    new_info_ptr->stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_hybrid             = FALSE;
    new_info_ptr->stack_info[stk_id].rat_mode_info.hdr_mode_info.is_colloc          = FALSE;
  }

 
  }

/*===========================================================================

FUNCTION cmss_changed_fields_helper

DESCRIPTION
  Set some changed fields hardcoded that are already set before coming to cmss_event

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  void.

  Note that serving system information only becomes valid after cmss_init()
  returns.

SIDE EFFECTS
  none

===========================================================================*/

void cmss_changed_fields_helper(

  cm_mm_ss_info_s_type    *ss_info_ptr,
  /* Copy serving system state info into this buffer */
 
  sys_modem_as_id_e_type        req_as_id,
     
  cm_mm_msim_ss_info_s_type    *new_info_ptr
     /* Base ss_info that gets copied into ss_info_ptr. Can be either
     ** cmss.info OR cmss.srv_avail_info
     */
 )
{
    if( req_as_id == ss_info_ptr->asubs_id )
  {
    if(ss_info_ptr->changed_fields & CM_SS_MOBILITY_MGMT_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_MOBILITY_MGMT_MASK ;
    }
    else
    {
      new_info_ptr->stack_info[0].changed_fields &= (~CM_SS_EVT_MOBILITY_MGMT_MASK );
    }

    if(ss_info_ptr->changed_fields & CM_SS_NO_CHANGE_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_NO_CHANGE_MASK;
    }
    else
    {
      new_info_ptr->stack_info[0].changed_fields &= (~CM_SS_EVT_NO_CHANGE_MASK );
  }

    if(ss_info_ptr->changed_fields & CM_SS_IDLE_DIGITAL_MODE_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_IDLE_DIGITAL_MODE_MASK ;    
      new_info_ptr->stack_info[1].changed_fields |= CM_SS_EVT_IDLE_DIGITAL_MODE_MASK ;
    }

  if(ss_info_ptr->changed_fields2 & CM_SS_LTE_SMS_DOMAIN_CHANGED_MASK)
    {
      new_info_ptr->changed_fields_subs |= CM_SS_EVT_SMS_DOMAIN_MASK;
    }

  if(ss_info_ptr->changed_fields2 & CM_SS_LTE_VOICE_DOMAIN_CHANGED_MASK)
    {
      new_info_ptr->changed_fields_subs |= CM_SS_EVT_VOICE_DOMAIN_MASK;
    }

  if(ss_info_ptr->changed_fields & CM_SS_SRV_IND_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_SRV_IND_MASK;
    }

  if(ss_info_ptr->changed_fields2 & CM_SS_LU_REJECT_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields2 |= CM_SS_EVT_LU_REJECT_MASK;
    }

  if(ss_info_ptr->changed_fields & CM_SS_PS_DATA_SUSPEND_MASK)
    {
      new_info_ptr->changed_fields_subs |= CM_SS_EVT_PS_DATA_SUSPEND_MASK;
    }
  if(ss_info_ptr->changed_fields & CM_SS_SRV_STATUS_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_SRV_STATUS_MASK;
    }
  if(ss_info_ptr->changed_fields & CM_SS_SYS_MODE_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_SYS_MODE_MASK;
    }
  if(ss_info_ptr->changed_fields & CM_SS_HDR_SRV_STATUS_MASK)
    {
      new_info_ptr->stack_info[1].changed_fields |= CM_SS_EVT_SRV_STATUS_MASK;
    }
    if(((cmph_is_subs_feature_mode_sglte(req_as_id) || 
             cmph_is_subs_feature_mode_1x_sxlte(req_as_id)) &&
         req_as_id == ss_info_ptr->gw_asubs_id )
         ||
         (!sys_srv_status_is_srv(ss_info_ptr->gw_srv_status) && 
           (sys_srv_status_is_srv(cmss_ptr()->new_srv_avl_info[req_as_id].stack_info[1].srv_status) &&
           req_as_id == ss_info_ptr->gw_asubs_id) &&
           cmss_ptr()->new_srv_avl_info[req_as_id].stack_info[1].sys_mode == SYS_SYS_MODE_LTE
         ))
      {
      if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_MOBILITY_MGMT_MASK)
      {
       new_info_ptr->stack_info[1].changed_fields |= CM_SS_EVT_MOBILITY_MGMT_MASK ;
      }
      else
      {
        new_info_ptr->stack_info[1].changed_fields &= (~CM_SS_EVT_MOBILITY_MGMT_MASK) ;
      }

      if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_IDLE_DIGITAL_MODE_MASK)
      {
      
       new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_IDLE_DIGITAL_MODE_MASK ;
       new_info_ptr->stack_info[1].changed_fields |= CM_SS_EVT_IDLE_DIGITAL_MODE_MASK ;
      }

      if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_NO_CHANGE_MASK)
      {
       new_info_ptr->stack_info[1].changed_fields |= CM_SS_EVT_NO_CHANGE_MASK ;
      }
      else
      {
        new_info_ptr->stack_info[1].changed_fields &= (~CM_SS_EVT_NO_CHANGE_MASK );
      }
      if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_LTE_SMS_DOMAIN_CHANGED_MASK)
      {
      new_info_ptr->changed_fields_subs |= CM_SS_EVT_SMS_DOMAIN_MASK;
      }

      if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_LTE_VOICE_DOMAIN_CHANGED_MASK)
      {
        new_info_ptr->changed_fields_subs |= CM_SS_EVT_VOICE_DOMAIN_MASK;
      }
      if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_SRV_IND_MASK) 
      {
        new_info_ptr->stack_info[1].changed_fields |= CM_SS_EVT_SRV_IND_MASK;
      }
  
      if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_LU_REJECT_MASK)
      {
        new_info_ptr->stack_info[1].changed_fields2 |= CM_SS_EVT_LU_REJECT_MASK;
      }

   
      if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_PS_DATA_SUSPEND_MASK)
      {
        new_info_ptr->changed_fields_subs |= CM_SS_EVT_PS_DATA_SUSPEND_MASK;
      }
      
      if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_SRV_STATUS_MASK)
      {
        new_info_ptr->stack_info[1].changed_fields |= CM_SS_EVT_SRV_STATUS_MASK;
      }
      
      if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_SYS_MODE_MASK) 
      {
        new_info_ptr->stack_info[1].changed_fields |= CM_SS_EVT_SYS_MODE_MASK;
      }
    }
  }
  else if(req_as_id == ss_info_ptr->gw3_asubs_id)
  {
    if(ss_info_ptr->gw3_changed_fields & CM_SS_GW_MOBILITY_MGMT_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_MOBILITY_MGMT_MASK ;
    }
    else
    {
      new_info_ptr->stack_info[0].changed_fields &= (~CM_SS_EVT_MOBILITY_MGMT_MASK );
    }

    if(ss_info_ptr->gw3_changed_fields & CM_SS_IDLE_DIGITAL_MODE_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_IDLE_DIGITAL_MODE_MASK ;    
      new_info_ptr->stack_info[1].changed_fields |= CM_SS_EVT_IDLE_DIGITAL_MODE_MASK ;
    }

    if(ss_info_ptr->gw3_changed_fields & CM_SS_NO_CHANGE_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_NO_CHANGE_MASK;
    }
    else
    {
      new_info_ptr->stack_info[0].changed_fields &= (~CM_SS_EVT_NO_CHANGE_MASK );
    }
    if(ss_info_ptr->gw3_changed_fields & CM_SS_GW_LTE_SMS_DOMAIN_CHANGED_MASK)
    {
    new_info_ptr->changed_fields_subs |= CM_SS_EVT_SMS_DOMAIN_MASK;
    }


    if(ss_info_ptr->gw3_changed_fields & CM_SS_GW_LTE_VOICE_DOMAIN_CHANGED_MASK)
    {
      new_info_ptr->changed_fields_subs |= CM_SS_EVT_VOICE_DOMAIN_MASK;
    }

    if(ss_info_ptr->gw3_changed_fields & CM_SS_GW_SRV_IND_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_SRV_IND_MASK;
    }

      
    if(ss_info_ptr->gw3_changed_fields & CM_SS_GW_LU_REJECT_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields2 |= CM_SS_EVT_LU_REJECT_MASK;
    }

    if(ss_info_ptr->gw3_changed_fields & CM_SS_GW_PS_DATA_SUSPEND_MASK)
    {
      new_info_ptr->changed_fields_subs |= CM_SS_EVT_PS_DATA_SUSPEND_MASK;
    }

    if(ss_info_ptr->gw3_changed_fields & CM_SS_GW_SRV_STATUS_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_SRV_STATUS_MASK;
    }
    
  if(ss_info_ptr->gw3_changed_fields & CM_SS_GW_SYS_MODE_MASK) 
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_SYS_MODE_MASK;
    }
  }
      
  else if(req_as_id == ss_info_ptr->gw_asubs_id )
  {
  
    if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_MOBILITY_MGMT_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_MOBILITY_MGMT_MASK ;
    }
    else
    {
      new_info_ptr->stack_info[0].changed_fields &= (~CM_SS_EVT_MOBILITY_MGMT_MASK );
    }
      
    if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_IDLE_DIGITAL_MODE_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_IDLE_DIGITAL_MODE_MASK ;    
      new_info_ptr->stack_info[1].changed_fields |= CM_SS_EVT_IDLE_DIGITAL_MODE_MASK ;
    }
       
    if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_NO_CHANGE_MASK)
    {
          
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_NO_CHANGE_MASK ;
    }
    else
    {
      new_info_ptr->stack_info[0].changed_fields &= (~CM_SS_EVT_NO_CHANGE_MASK );
    }
    if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_LTE_SMS_DOMAIN_CHANGED_MASK)
    {
      new_info_ptr->changed_fields_subs |= CM_SS_EVT_SMS_DOMAIN_MASK;
    }
    
    if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_LTE_VOICE_DOMAIN_CHANGED_MASK)
    {
      new_info_ptr->changed_fields_subs |= CM_SS_EVT_VOICE_DOMAIN_MASK;
    }
      
    if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_SRV_IND_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_SRV_IND_MASK;
    }
      
    if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_LU_REJECT_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields2 |= CM_SS_EVT_LU_REJECT_MASK;
    }
      
    if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_PS_DATA_SUSPEND_MASK)
    {
      new_info_ptr->changed_fields_subs |= CM_SS_EVT_PS_DATA_SUSPEND_MASK;
    }
    if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_SRV_STATUS_MASK)
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_SRV_STATUS_MASK;
    }
        
    if(ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_SYS_MODE_MASK) 
    {
      new_info_ptr->stack_info[0].changed_fields |= CM_SS_EVT_SYS_MODE_MASK;
    } 
  }      

}

/*===========================================================================

FUNCTION cmss_mapping_info

DESCRIPTION
  Copy the current serving system state information into a specified buffer.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  TRUE if serving system information is valid, FALSE otherwise.

  Note that serving system information only becomes valid after cmss_init()
  returns.

SIDE EFFECTS
  none

===========================================================================*/
 void cmss_mapping_info(

      cm_mm_ss_info_s_type    *ss_info_ptr,
          /* Copy serving system state info into this buffer */

      sys_modem_as_id_e_type        req_as_id,

      cm_mm_msim_ss_info_s_type    *new_info_ptr
      /* Base ss_info that gets copied into ss_info_ptr. Can be either
      ** cmss.info OR cmss.srv_avail_info
      */
  )
{

  CM_MSG_HIGH_5("Mapping csg_info, NEW csg_id:%d, hnb_name_length:%d, sys_id_type:%d, sys_mode:%d, req_as_id %d",
                ss_info_ptr->csg_info.csg_id,
                ss_info_ptr->csg_info.hnb_name.length,
                ss_info_ptr->sys_id.id_type,
                ss_info_ptr->sys_mode,
                req_as_id);

 CM_MSG_HIGH_6("as_id[0].stack[0].srv_status %d, stack[1].srv_status %d, gw_srv_status %d, as_id[1].stack[0].srv_status %d, stack[1].srv_status %d mode %d",\
   cmss_ptr()->new_srv_avl_info[0].stack_info[0].srv_status,\
   cmss_ptr()->new_srv_avl_info[0].stack_info[1].srv_status,
   ss_info_ptr->gw_srv_status,
   cmss_ptr()->new_srv_avl_info[1].stack_info[0].srv_status,
   cmss_ptr()->new_srv_avl_info[1].stack_info[1].srv_status,
   cmss_ptr()->new_srv_avl_info[1].stack_info[1].sys_mode);

 cmss_reseting_helper(new_info_ptr);

  /* If the req_as_id for which we are going to send info to clients is either AS_ID_2/AS_ID_3
     and cmph is not multisim than we will not send the events to clients */
 if(( !cmph_is_msim() && req_as_id == SYS_MODEM_AS_ID_2 ) ||
    ( !(cmph_is_tsts()) && req_as_id == SYS_MODEM_AS_ID_3))
  {
    return  ;
  }

 cmss_changed_fields_helper(ss_info_ptr, req_as_id, new_info_ptr);
  
  //Updating fields that are at sub level
  new_info_ptr->prl_3gpp2_mcc = ss_info_ptr->prl_3gpp2_mcc;
  new_info_ptr->prl_hdr_mcc = ss_info_ptr->prl_hdr_mcc;
  new_info_ptr->current_mcc = ss_info_ptr->current_mcc;
  new_info_ptr->home_mcc = ss_info_ptr->home_mcc;
  new_info_ptr->plus_dial_setting = ss_info_ptr->plus_dial_setting;
  new_info_ptr->gan_info = ss_info_ptr->gan_info;
  new_info_ptr->meas_resp = ss_info_ptr->meas_resp;
  new_info_ptr->target_rat = ss_info_ptr->target_rat;
  new_info_ptr->irat_ctxt_target_rat = ss_info_ptr->irat_ctxt_target_rat;
  new_info_ptr->gwl_irat_asubs_id = ss_info_ptr->gwl_irat_asubs_id;
  new_info_ptr->voice_domain = ss_info_ptr->voice_domain;
  new_info_ptr->sms_domain = ss_info_ptr->sms_domain;
  new_info_ptr->div_duplex = ss_info_ptr->div_duplex;
  new_info_ptr->sys_sel_pref_req_id = ss_info_ptr->sys_sel_pref_req_id;
  new_info_ptr->msm_id = ss_info_ptr->msm_id ;

  new_info_ptr->requesting_client_id = ss_info_ptr->requesting_client_id ;
  new_info_ptr->ipapp_info = ss_info_ptr->ipapp_info ;
  if(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) == SYS_MODEM_AS_ID_1)
  {
  new_info_ptr->is_stack2_operational = ss_info_ptr->is_hybr_gw_operational;
  }
  else
  {
    new_info_ptr->is_stack2_operational = FALSE;
  }

  /*
  **  Updating ss information (related to main stack) to zeroth stack of req subs(stack_info[0]
  */
  if( req_as_id == ss_info_ptr->asubs_id )
  {
    //main data in 0 stack
    new_info_ptr->asubs_id = ss_info_ptr->asubs_id ;
    new_info_ptr->number_of_stacks = 1 ;
    new_info_ptr->ps_data_suspend= ss_info_ptr->ps_data_suspend;
    new_info_ptr->stack_info[0].is_operational = ss_info_ptr->is_main_operational;
    new_info_ptr->stack_info[0].srv_status = ss_info_ptr->srv_status;
    new_info_ptr->stack_info[0].true_srv_status = ss_info_ptr->true_srv_status;
    new_info_ptr->stack_info[0].srv_domain= ss_info_ptr->srv_domain;

    if(cmph_is_ssim())
    { 
      new_info_ptr->stack_info[0].effective_srv_domain = ss_info_ptr->srv_domain;
    }
    else if(cmph_is_msim())
    {
      new_info_ptr->stack_info[0].effective_srv_domain = cmph_get_effective_srv_domain(req_as_id,ss_info_ptr->srv_domain);	
    }
    new_info_ptr->stack_info[0].srv_capability= ss_info_ptr->srv_capability;
    new_info_ptr->stack_info[0].sys_mode= ss_info_ptr->sys_mode;
    new_info_ptr->stack_info[0].mode_info= ss_info_ptr->mode_info;
    new_info_ptr->stack_info[0].roam_status= ss_info_ptr->roam_status;
    new_info_ptr->stack_info[0].sys_id= ss_info_ptr->sys_id;
    new_info_ptr->stack_info[0].is_sys_prl_match= ss_info_ptr->is_sys_prl_match;
    new_info_ptr->stack_info[0].is_sys_forbidden= ss_info_ptr->is_sys_forbidden;
    new_info_ptr->stack_info[0].rssi= ss_info_ptr->rssi;
    new_info_ptr->stack_info[0].ecio= ss_info_ptr->ecio;
    new_info_ptr->stack_info[0].io= ss_info_ptr->io;
    new_info_ptr->stack_info[0].sinr= ss_info_ptr->sinr;
    new_info_ptr->stack_info[0].pathloss= ss_info_ptr->pathloss;
    new_info_ptr->stack_info[0].sir= ss_info_ptr->sir;
    new_info_ptr->stack_info[0].rssi2= ss_info_ptr->rssi2;
    new_info_ptr->stack_info[0].rscp= ss_info_ptr->rscp;
    new_info_ptr->stack_info[0].cur_idle_digital_mode = ss_info_ptr->cur_idle_digital_mode;
    
    new_info_ptr->stack_info[1].cur_idle_digital_mode = ss_info_ptr->cur_idle_digital_mode;
    
    new_info_ptr->stack_info[0].prev_idle_digital_mode = ss_info_ptr->prev_idle_digital_mode ;
    new_info_ptr->stack_info[1].prev_idle_digital_mode = ss_info_ptr->prev_idle_digital_mode ;
    
    if( new_info_ptr->stack_info[0].sys_mode == SYS_SYS_MODE_WCDMA)
    {
      new_info_ptr->stack_info[0].ecio                = ss_info_ptr->gw_ecio;          // for hybr2 we already have gw2_ecio
    }
    new_info_ptr->stack_info[0].cqi_info= ss_info_ptr->cqi_info;
    new_info_ptr->stack_info[0].lte_ims_voice_avail = ss_info_ptr->lte_ims_voice_avail;
    new_info_ptr->stack_info[0].lte_ims_emerg_avail = ss_info_ptr->lte_ims_emerg_avail;

    switch(ss_info_ptr->sys_mode)
    {
      case  SYS_SYS_MODE_LTE:
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.rsrp = ss_info_ptr->rsrp;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.rsrq= ss_info_ptr->rsrq;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.lac= ss_info_ptr->lac;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.tac= ss_info_ptr->tac;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.rac_or_mme_code= ss_info_ptr->rac_or_mme_code;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.embms_info = ss_info_ptr->embms_info ;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.csg_info = ss_info_ptr->csg_info ;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.voice_support_on_lte = ss_info_ptr->voice_support_on_lte;
      break ;

      case SYS_SYS_MODE_GSM:
      new_info_ptr->stack_info[0].rat_mode_info.gsm_mode_info.rac_or_mme_code= ss_info_ptr->rac_or_mme_code;
      new_info_ptr->stack_info[0].rat_mode_info.gsm_mode_info.lac= ss_info_ptr->lac;
      new_info_ptr->stack_info[0].rat_mode_info.gsm_mode_info.csg_info= ss_info_ptr->csg_info;
      break ;

      case SYS_SYS_MODE_WCDMA:
      new_info_ptr->stack_info[0].rat_mode_info.wcdma_mode_info.lac= ss_info_ptr->lac;
      new_info_ptr->stack_info[0].rat_mode_info.wcdma_mode_info.rac_or_mme_code= ss_info_ptr->rac_or_mme_code;
      new_info_ptr->stack_info[0].rat_mode_info.wcdma_mode_info.csg_info= ss_info_ptr->csg_info;
      break ;

      case SYS_SYS_MODE_TDS:
      new_info_ptr->stack_info[0].rat_mode_info.tds_mode_info.lac= ss_info_ptr->lac;
      new_info_ptr->stack_info[0].rat_mode_info.tds_mode_info.rac_or_mme_code= ss_info_ptr->rac_or_mme_code;
      new_info_ptr->stack_info[0].rat_mode_info.tds_mode_info.csg_info= ss_info_ptr->csg_info;
      break ;

      case SYS_SYS_MODE_CDMA:
      new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.frame_err_rate = ss_info_ptr->frame_err_rate;
      new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.cdma_reg_prd = ss_info_ptr->cdma_reg_prd;
      new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.is_colloc = ss_info_ptr->is_colloc;
        break;

      default:
        break;

    }
    new_info_ptr->stack_info[0].ecio_for_display = ss_info_ptr->ecio_for_display;
    new_info_ptr->stack_info[0].psist= ss_info_ptr->psist;
    new_info_ptr->is_csfb_call_active = ss_info_ptr->is_csfb_call_active;
    new_info_ptr->stack_info[0].active_band = ss_info_ptr->active_band;
    new_info_ptr->stack_info[0].active_channel= ss_info_ptr->active_channel;
    new_info_ptr->curr_uptime= ss_info_ptr->curr_uptime;
    new_info_ptr->stack_info[0].emerg_num_list= ss_info_ptr->emerg_num_list;
    new_info_ptr->stack_info[0].thr_status= ss_info_ptr->main_thr_status;
    new_info_ptr->stack_info[0].cell_info= ss_info_ptr->cell_info;
    new_info_ptr->def_roam_ind= ss_info_ptr->def_roam_ind;
    new_info_ptr->stack_info[0].cell_srv_ind= ss_info_ptr->cell_srv_ind;
    new_info_ptr->stack_info[0].reg_reject_info= ss_info_ptr->reg_reject_info;
    new_info_ptr->stack_info[0].cipher_domain= ss_info_ptr->cipher_domain;
    new_info_ptr->stack_info[0].geo_sys_idx= ss_info_ptr->geo_sys_idx;
    if(ss_info_ptr->sys_mode == SYS_SYS_MODE_CDMA)
    {
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.cdma_reg_prd = ss_info_ptr->cdma_reg_prd;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.is_colloc = ss_info_ptr->is_colloc;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.is_custom_home = ss_info_ptr->is_cdma_custom_home;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.height = ss_info_ptr->height;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.horiz_uncertainty= ss_info_ptr->horiz_uncertainty;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.vert_uncertainty= ss_info_ptr->vert_uncertainty;
     }
    new_info_ptr->stack_info[0].cell_bc_info= ss_info_ptr->cell_bc_info;
    new_info_ptr->bsr_in_progress= ss_info_ptr->bsr_in_progress;
    new_info_ptr->eutra_detect_status= ss_info_ptr->eutra_detect_status;
    new_info_ptr->stack_info[0].bcmcs_srv_supported = ss_info_ptr->ss_main_bcmcs_srv_supported ;
    new_info_ptr->stack_info[1].bcmcs_srv_supported = ss_info_ptr->hybr_hdr_bcmcs_srv_supported ;

    new_info_ptr->stack_info[0].bcmcs_srv_status = ss_info_ptr->ss_main_bcmcs_srv_status ;
    new_info_ptr->stack_info[1].bcmcs_srv_status = ss_info_ptr->hybr_hdr_bcmcs_srv_status ;

    new_info_ptr->stack_info[0].simultaneous_mode= ss_info_ptr->simultaneous_mode;
    new_info_ptr->stack_info[0].available_plmn_type = ss_info_ptr->available_plmn_type ;
    new_info_ptr->stack_info[0].cell_access_info = ss_info_ptr->cell_access_info ;

    new_info_ptr->stack_info[0].prev_idle_digital_mode = ss_info_ptr->prev_idle_digital_mode ;
    new_info_ptr->stack_info[0].cur_idle_digital_mode = ss_info_ptr->cur_idle_digital_mode ;
    new_info_ptr->stack_info[1].prev_idle_digital_mode = ss_info_ptr->prev_idle_digital_mode ;
    new_info_ptr->stack_info[1].cur_idle_digital_mode = ss_info_ptr->cur_idle_digital_mode ;
    new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.hdr_active_prot = ss_info_ptr->hdr_active_prot;
    
    new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.hdr_personality = ss_info_ptr->hdr_personality ;

    if(ss_info_ptr->sys_mode == SYS_SYS_MODE_HDR)
    {
      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.hdr_hybrid = ss_info_ptr->hdr_hybrid ;
      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.hdr_active_prot = ss_info_ptr->hdr_active_prot;

      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.subnet_mask_len = ss_info_ptr->subnet_mask_len ;
      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.hdr_ln_status = ss_info_ptr->hdr_ln_status ;
      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.hdr_packet_err_rate = ss_info_ptr->hdr_packet_err_rate ;
      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.hdr_personality = ss_info_ptr->hdr_personality ;
      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.mcc = ss_info_ptr->mcc ;
      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.latitude = ss_info_ptr->latitude;
      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.longitude = ss_info_ptr->longitude;
      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.system_type = ss_info_ptr->system_type;
      new_info_ptr->stack_info[0].rat_mode_info.hdr_mode_info.is_custom_home = ss_info_ptr->is_hdr_custom_home;
    }


    /*
    ** Fill HDR related info in stack[1] under following conditions.
    ** 1. If HDR is acquired.(Either SRLTE mode of operation and csfb mode of operation)
    ** 2. In SRLTE device, if UE is csfb sub mode of operation and last service reported on stack[1] is not FULL/Limited.
    **    and hybr_1 is operational.
    ** 3. fetaure mode is not 1X_SXLTE and hybr1 is operational.
    */ 
    if(cmph_is_sxlte_second_stack_allowed_on_mode(req_as_id, CM_MODE_PREF_HDR_ONLY) &&
       (sys_srv_status_is_srv(ss_info_ptr->hdr_srv_status) ||
       (cmph_is_subs_feature_mode_1x_sxlte(req_as_id) && ss_info_ptr->hdr_hybrid && !ss_info_ptr->is_hybr_gw_operational
        && !sys_srv_status_is_srv(ss_info_ptr->gw_srv_status) 
        && (cmss_ptr()->new_srv_avl_info[req_as_id].stack_info[1].sys_mode != SYS_SYS_MODE_LTE)
        && !sys_srv_status_is_srv(cmss_ptr()->new_srv_avl_info[req_as_id].stack_info[1].srv_status)
        && !CM_IS_MODE_3GPP(cmss_ptr()->info.sys_mode))
        ||
        (!sys_srv_status_is_srv(ss_info_ptr->hdr_srv_status) &&
         (!(cmph_is_svlte_any() && sys_srv_status_is_srv(ss_info_ptr->gw_srv_status) && req_as_id == ss_info_ptr->gw_asubs_id )) &&
         sys_srv_status_is_srv(cmss_ptr()->new_srv_avl_info[req_as_id].stack_info[1].srv_status) &&
        cmss_ptr()->new_srv_avl_info[req_as_id].stack_info[1].sys_mode == SYS_SYS_MODE_HDR)
        ||
       (!cmph_is_subs_feature_mode_1x_sxlte(req_as_id) && ss_info_ptr->hdr_hybrid  && !CM_IS_MODE_3GPP(cmss_ptr()->info.sys_mode))
       ))
    {
      //hdr data in stack 1

      new_info_ptr->number_of_stacks = 2 ;

      new_info_ptr->stack_info[1].srv_status = ss_info_ptr->hdr_srv_status;
      new_info_ptr->stack_info[1].roam_status= ss_info_ptr->hdr_roam_status;
      new_info_ptr->stack_info[1].sys_id= ss_info_ptr->hdr_sys_id;

      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.is_colloc = ss_info_ptr->is_colloc;
      //new_info_ptr->stack_info[1].sys_mode= SYS_SYS_MODE_HDR;

      if(sys_srv_status_is_srv(ss_info_ptr->hdr_srv_status))
      {
          new_info_ptr->stack_info[1].sys_mode= SYS_SYS_MODE_HDR;
      }
      else
      {
          new_info_ptr->stack_info[1].sys_mode= SYS_SYS_MODE_NO_SRV;
      }

      if(cmph_ptr()->main_stack_info.pref_info.hybr_pref != CM_HYBR_PREF_OFF )
      {
        new_info_ptr->stack_info[1].is_operational = TRUE ;
      }
      new_info_ptr->stack_info[1].is_sys_forbidden= ss_info_ptr->is_sys_forbidden;
      new_info_ptr->stack_info[1].is_sys_prl_match= ss_info_ptr->is_sys_prl_match;

      new_info_ptr->stack_info[1].rssi= ss_info_ptr->hdr_rssi;
      new_info_ptr->stack_info[1].ecio= ss_info_ptr->hdr_ecio;
      new_info_ptr->stack_info[1].io= ss_info_ptr->hdr_io;
      new_info_ptr->stack_info[1].sinr= ss_info_ptr->hdr_sinr;
      new_info_ptr->stack_info[1].active_band = ss_info_ptr->hybrid_active_band;
      new_info_ptr->stack_info[1].active_channel= ss_info_ptr->hybrid_active_channel;
      new_info_ptr->stack_info[1].thr_status= ss_info_ptr->hdr_thr_status;
      new_info_ptr->stack_info[1].geo_sys_idx= ss_info_ptr->geo_sys_idx;
      new_info_ptr->stack_info[1].mode_info= ss_info_ptr->mode_info;    

      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.hdr_hybrid = ss_info_ptr->hdr_hybrid ;
      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.hdr_active_prot = ss_info_ptr->hdr_active_prot;
      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.subnet_mask_len = ss_info_ptr->subnet_mask_len ;
      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.hdr_ln_status = ss_info_ptr->hdr_ln_status ;
      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.hdr_packet_err_rate = ss_info_ptr->hdr_packet_err_rate ;
      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.hdr_personality = ss_info_ptr->hdr_personality ;
      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.is_custom_home = ss_info_ptr->is_hdr_custom_home;
      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.mcc = ss_info_ptr->mcc ;
      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.latitude = ss_info_ptr->latitude;
      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.longitude = ss_info_ptr->longitude;
      new_info_ptr->stack_info[1].rat_mode_info.hdr_mode_info.system_type = ss_info_ptr->system_type;

      new_info_ptr->stack_info[1].thr_status = ss_info_ptr->hdr_thr_status ;

      new_info_ptr->stack_info[0].prev_idle_digital_mode = ss_info_ptr->prev_idle_digital_mode ;
      new_info_ptr->stack_info[1].prev_idle_digital_mode = ss_info_ptr->prev_idle_digital_mode ;

      new_info_ptr->stack_info[0].cur_idle_digital_mode = ss_info_ptr->cur_idle_digital_mode ;
      new_info_ptr->stack_info[1].cur_idle_digital_mode = ss_info_ptr->cur_idle_digital_mode ;
      new_info_ptr->stack_info[1].bcmcs_srv_supported = ss_info_ptr->hybr_hdr_bcmcs_srv_supported ;
      new_info_ptr->stack_info[1].bcmcs_srv_status = ss_info_ptr->hybr_hdr_bcmcs_srv_status ;
      new_info_ptr->stack_info[1].simultaneous_mode= ss_info_ptr->simultaneous_mode;
      new_info_ptr->stack_info[1].available_plmn_type = ss_info_ptr->available_plmn_type ;
      if(ss_info_ptr->mode_info.cdma_info.time_info.sys_mode == SYS_SYS_MODE_HDR)
      {
        new_info_ptr->stack_info[1].mode_info.cdma_info.time_info = ss_info_ptr->mode_info.cdma_info.time_info;
      }

    }
    /*
    ** Below code is to fill hybr_2 information in stack[1] in sim
    ** for SGLTE + G hybr_2 info will go in second stack(stack[1]) of as_id_1
    ** for G + SGLTE hybr2_2 info will go in second stack(stack[1]) of as_id_2
    */
    else if(cmph_is_sxlte_second_stack_allowed_on_mode(req_as_id, CM_MODE_PREF_LTE_ONLY) &&
           (((cmph_is_subs_feature_mode_sglte(req_as_id) ||
             cmph_is_subs_feature_mode_1x_sxlte(req_as_id)) &&
         req_as_id == ss_info_ptr->gw_asubs_id )
         ||
         (!sys_srv_status_is_srv(ss_info_ptr->gw_srv_status) &&
           (sys_srv_status_is_srv(cmss_ptr()->new_srv_avl_info[req_as_id].stack_info[1].srv_status) &&
           req_as_id == ss_info_ptr->gw_asubs_id) &&
           cmss_ptr()->new_srv_avl_info[req_as_id].stack_info[1].sys_mode == SYS_SYS_MODE_LTE
         )))
    {
      // hybrid2 data in stack 1
      new_info_ptr->number_of_stacks = 2 ;

      if (ss_info_ptr->gw_sys_mode == SYS_SYS_MODE_LTE &&
          cmph_is_subs_feature_mode_1x_sxlte(ss_info_ptr->gw_asubs_id) &&
          new_info_ptr->stack_info[0].sys_mode != SYS_SYS_MODE_CDMA &&
          ss_info_ptr->is_hybr_gw_operational == TRUE)
      {
        //second stack of SxLTE got service first and first stack still has 3GPP mode_pref, need to reset
        new_info_ptr->stack_info[0].sys_mode        = SYS_SYS_MODE_NO_SRV;

        // reset srv status as well so SS event contains correct information
        new_info_ptr->stack_info[0].srv_status      = SYS_SRV_STATUS_NO_SRV;
       }

      /* For SGLTE, main stack only provides data so use only main data suspend */
      /* If filling stack2 for SVLTE then use this stack ps data suspend. */
      if(cmph_is_subs_feature_mode_1x_sxlte(req_as_id))
      {
        /* If hybr_gw operational and MAIN stack not in 3gpp service, use gw_ps_data_suspend
        */
        if((ss_info_ptr->is_hybr_gw_operational) &&
          !( sys_srv_status_is_srv(ss_info_ptr->srv_status) &&
             (CM_IS_MODE_3GPP(ss_info_ptr->sys_mode)) ) )
        {
          new_info_ptr->ps_data_suspend = ss_info_ptr->gw_ps_data_suspend;
        }
      }
      new_info_ptr->stack_info[1].is_operational= ss_info_ptr->is_hybr_gw_operational;
      new_info_ptr->stack_info[1].srv_status = ss_info_ptr->gw_srv_status;
      new_info_ptr->stack_info[1].true_srv_status = ss_info_ptr->true_gw_srv_status;
      new_info_ptr->stack_info[1].srv_domain= ss_info_ptr->gw_srv_domain;
      new_info_ptr->stack_info[1].effective_srv_domain = cmph_get_effective_srv_domain(req_as_id, ss_info_ptr->srv_domain);	
      new_info_ptr->stack_info[1].srv_capability= ss_info_ptr->gw_srv_capability;
      new_info_ptr->stack_info[1].sys_mode= ss_info_ptr->gw_sys_mode;
      new_info_ptr->stack_info[1].mode_info= ss_info_ptr->gw_mode_info;
      new_info_ptr->stack_info[1].roam_status= ss_info_ptr->gw_roam_status;
      new_info_ptr->stack_info[1].sys_id= ss_info_ptr->gw_sys_id;
      new_info_ptr->stack_info[1].is_sys_prl_match= ss_info_ptr->gw_is_sys_prl_match;
      new_info_ptr->stack_info[1].is_sys_forbidden= ss_info_ptr->gw_is_sys_forbidden;
      new_info_ptr->stack_info[1].rssi= ss_info_ptr->gw_rssi;
      new_info_ptr->stack_info[1].ecio= ss_info_ptr->gw2_ecio;
      new_info_ptr->stack_info[1].io= ss_info_ptr->gw_io;
      new_info_ptr->stack_info[1].sinr= ss_info_ptr->gw_sinr;
      new_info_ptr->stack_info[1].pathloss= ss_info_ptr->gw_pathloss;
      new_info_ptr->stack_info[1].sir= ss_info_ptr->gw_sir;
      new_info_ptr->stack_info[1].rssi2= ss_info_ptr->gw_rssi2;
      new_info_ptr->stack_info[1].rscp= ss_info_ptr->gw_rscp;
      new_info_ptr->stack_info[1].cqi_info= ss_info_ptr->gw_cqi_info;
      new_info_ptr->stack_info[1].ecio_for_display = ss_info_ptr->gw_ecio_for_display;
      new_info_ptr->is_csfb_call_active = ss_info_ptr->is_csfb_call_active;
      new_info_ptr->stack_info[1].active_band = ss_info_ptr->gw_active_band;
      new_info_ptr->stack_info[1].active_channel= ss_info_ptr->gw_active_channel;
      new_info_ptr->curr_uptime= ss_info_ptr->curr_uptime;
      new_info_ptr->stack_info[1].emerg_num_list= ss_info_ptr->gw_emerg_num_list;
      new_info_ptr->stack_info[1].cell_info= ss_info_ptr->gw_cell_info;
      new_info_ptr->def_roam_ind= ss_info_ptr->def_roam_ind;
      new_info_ptr->stack_info[1].cell_srv_ind= ss_info_ptr->gw_cell_srv_ind;
      new_info_ptr->stack_info[1].reg_reject_info= ss_info_ptr->gw_reg_reject_info;
      new_info_ptr->stack_info[1].cipher_domain= ss_info_ptr->gw_cipher_domain;
      new_info_ptr->stack_info[1].geo_sys_idx= ss_info_ptr->geo_sys_idx;

      if(ss_info_ptr->sys_mode == SYS_SYS_MODE_CDMA)
      {
      new_info_ptr->stack_info[1].rat_mode_info.cdma_mode_info.cdma_reg_prd = ss_info_ptr->cdma_reg_prd;
      new_info_ptr->stack_info[1].rat_mode_info.cdma_mode_info.frame_err_rate = ss_info_ptr->frame_err_rate;
      new_info_ptr->stack_info[1].rat_mode_info.cdma_mode_info.is_colloc = ss_info_ptr->is_colloc;
      new_info_ptr->stack_info[1].rat_mode_info.cdma_mode_info.height = ss_info_ptr->height;
      new_info_ptr->stack_info[1].rat_mode_info.cdma_mode_info.horiz_uncertainty= ss_info_ptr->horiz_uncertainty;
      new_info_ptr->stack_info[1].rat_mode_info.cdma_mode_info.vert_uncertainty= ss_info_ptr->vert_uncertainty;

      }
      new_info_ptr->stack_info[1].cell_bc_info= ss_info_ptr->gw_cell_bc_info;
      new_info_ptr->bsr_in_progress= ss_info_ptr->bsr_in_progress;
      new_info_ptr->eutra_detect_status= ss_info_ptr->eutra_detect_status;
      new_info_ptr->stack_info[1].bcmcs_srv_supported = FALSE ;
      new_info_ptr->stack_info[1].bcmcs_srv_status = SYS_BCMCS_SRV_STATUS_NO_SRV ;
      new_info_ptr->stack_info[1].simultaneous_mode= ss_info_ptr->simultaneous_mode;
      new_info_ptr->stack_info[1].lte_ims_voice_avail = ss_info_ptr->lte_ims_voice_avail;
      new_info_ptr->stack_info[1].lte_ims_emerg_avail = ss_info_ptr->lte_ims_emerg_avail;

      switch(ss_info_ptr->gw_sys_mode)// == SYS_SYS_MODE_LTE)
      {
        case  SYS_SYS_MODE_LTE:
        new_info_ptr->stack_info[1].rat_mode_info.lte_mode_info.rsrp = ss_info_ptr->gwl_rsrp;
        new_info_ptr->stack_info[1].rat_mode_info.lte_mode_info.rsrq= ss_info_ptr->gwl_rsrq;
        new_info_ptr->stack_info[1].rat_mode_info.lte_mode_info.lac= ss_info_ptr->gwl_lac;
        new_info_ptr->stack_info[1].rat_mode_info.lte_mode_info.tac= ss_info_ptr->gwl_tac;
        new_info_ptr->stack_info[1].rat_mode_info.lte_mode_info.rac_or_mme_code= ss_info_ptr->gwl_rac_or_mme_code;
        new_info_ptr->stack_info[1].rat_mode_info.lte_mode_info.embms_info = ss_info_ptr->gwl_embms_info ;
            new_info_ptr->stack_info[1].rat_mode_info.lte_mode_info.voice_support_on_lte = ss_info_ptr->voice_support_on_lte;
        new_info_ptr->stack_info[1].rat_mode_info.lte_mode_info.csg_info = ss_info_ptr->csg_info;
        break ;

        case SYS_SYS_MODE_GSM:
        new_info_ptr->stack_info[1].rat_mode_info.gsm_mode_info.rac_or_mme_code= ss_info_ptr->gwl_rac_or_mme_code;
        new_info_ptr->stack_info[1].rat_mode_info.gsm_mode_info.lac= ss_info_ptr->gwl_lac;
        new_info_ptr->stack_info[1].rat_mode_info.gsm_mode_info.csg_info = ss_info_ptr->csg_info;
        break ;

        case SYS_SYS_MODE_WCDMA:
        new_info_ptr->stack_info[1].rat_mode_info.wcdma_mode_info.lac= ss_info_ptr->gwl_lac;
        new_info_ptr->stack_info[1].rat_mode_info.wcdma_mode_info.rac_or_mme_code= ss_info_ptr->gwl_rac_or_mme_code;
        new_info_ptr->stack_info[1].rat_mode_info.wcdma_mode_info.csg_info = ss_info_ptr->csg_info;
        break ;

        case SYS_SYS_MODE_TDS:
        new_info_ptr->stack_info[1].rat_mode_info.tds_mode_info.lac= ss_info_ptr->gwl_lac;

        new_info_ptr->stack_info[1].rat_mode_info.tds_mode_info.rac_or_mme_code= ss_info_ptr->gwl_rac_or_mme_code;
        break;

        default:
        break;

      }

      new_info_ptr->stack_info[1].cell_access_info = ss_info_ptr->gw_cell_access_info ;
      new_info_ptr->stack_info[1].available_plmn_type = ss_info_ptr->available_plmn_type ;
    }

  }
  /*
  ** Information of HYBR_3 stack will go into stack[0]
  ** for sglte + g config hybr_3 info will go to second sim(as_id_2) stack[0]
  ** for g + sglte hybr_3 info will go to first sim(as_id_1) stack[0]
  */

  else if(
             ( (req_as_id == ss_info_ptr->gw_asubs_id )
              && (cmph_is_subs_feature_mode_sglte(req_as_id) || cmph_is_subs_feature_mode_1x_sxlte(req_as_id) )
             )
             || (req_as_id == ss_info_ptr->gw3_asubs_id)
         )

  {
    //hybrid3 data in stack 0

    new_info_ptr->number_of_stacks = 1 ;
    new_info_ptr->asubs_id = ss_info_ptr->gw_asubs_id ;
   
    if(req_as_id == ss_info_ptr->gw3_asubs_id)
    {
      new_info_ptr->asubs_id = ss_info_ptr->gw3_asubs_id ;
    }

     new_info_ptr->ps_data_suspend = ss_info_ptr->gw3_ps_data_suspend ;
    new_info_ptr->stack_info[0].is_operational= ss_info_ptr->is_gw3_operational;
    new_info_ptr->stack_info[0].srv_status = ss_info_ptr->gw3_srv_status;
    new_info_ptr->stack_info[0].true_srv_status = ss_info_ptr->true_gw3_srv_status;
    new_info_ptr->stack_info[0].srv_domain= ss_info_ptr->gw3_srv_domain;
    new_info_ptr->stack_info[0].effective_srv_domain = cmph_get_effective_srv_domain(req_as_id,ss_info_ptr->srv_domain);
    new_info_ptr->stack_info[0].srv_capability= ss_info_ptr->gw3_srv_capability;
    new_info_ptr->stack_info[0].sys_mode= ss_info_ptr->gw3_sys_mode;
    new_info_ptr->stack_info[0].mode_info= ss_info_ptr->gw3_mode_info;
    new_info_ptr->stack_info[0].roam_status= ss_info_ptr->gw3_roam_status;
    new_info_ptr->stack_info[0].sys_id= ss_info_ptr->gw3_sys_id;
    new_info_ptr->stack_info[0].is_sys_prl_match= ss_info_ptr->gw3_is_sys_prl_match;
    new_info_ptr->stack_info[0].is_sys_forbidden= ss_info_ptr->gw3_is_sys_forbidden;
    new_info_ptr->stack_info[0].rssi= ss_info_ptr->gw3_rssi;
    new_info_ptr->stack_info[0].ecio= ss_info_ptr->gw3_ecio;
    new_info_ptr->stack_info[0].io= ss_info_ptr->gw3_io;
    new_info_ptr->stack_info[0].sinr= ss_info_ptr->gw3_sinr;
    new_info_ptr->stack_info[0].pathloss= ss_info_ptr->gw3_pathloss;
    new_info_ptr->stack_info[0].sir= ss_info_ptr->gw3_sir;
    new_info_ptr->stack_info[0].rssi2= ss_info_ptr->gw3_rssi2;
    new_info_ptr->stack_info[0].rscp= ss_info_ptr->gw3_rscp;
    new_info_ptr->stack_info[0].cqi_info= ss_info_ptr->gw3_cqi_info;
    new_info_ptr->stack_info[0].ecio_for_display = ss_info_ptr->gw3_ecio_for_display;
    new_info_ptr->is_csfb_call_active = ss_info_ptr->is_csfb_call_active;
    new_info_ptr->stack_info[0].active_band = ss_info_ptr->gw3_active_band;
    new_info_ptr->stack_info[0].active_channel = ss_info_ptr->gw3_active_channel;
    new_info_ptr->curr_uptime= ss_info_ptr->curr_uptime;
    new_info_ptr->stack_info[0].emerg_num_list= ss_info_ptr->gw3_emerg_num_list;
    new_info_ptr->stack_info[0].cell_info= ss_info_ptr->gw3_cell_info;
    new_info_ptr->def_roam_ind= ss_info_ptr->def_roam_ind;
    new_info_ptr->stack_info[0].cell_srv_ind= ss_info_ptr->gw3_cell_srv_ind;
    new_info_ptr->stack_info[0].reg_reject_info= ss_info_ptr->gw3_reg_reject_info;
    new_info_ptr->stack_info[0].cipher_domain= ss_info_ptr->gw3_cipher_domain;
    new_info_ptr->stack_info[0].geo_sys_idx= ss_info_ptr->geo_sys_idx;

    if(ss_info_ptr->sys_mode == SYS_SYS_MODE_CDMA)
    {
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.cdma_reg_prd = ss_info_ptr->cdma_reg_prd;

    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.frame_err_rate = ss_info_ptr->frame_err_rate;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.is_colloc = ss_info_ptr->is_colloc;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.height = ss_info_ptr->height;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.horiz_uncertainty= ss_info_ptr->horiz_uncertainty;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.vert_uncertainty= ss_info_ptr->vert_uncertainty;
    }
    new_info_ptr->stack_info[0].cell_bc_info= ss_info_ptr->gw3_cell_bc_info;
    new_info_ptr->bsr_in_progress= ss_info_ptr->bsr_in_progress;
    new_info_ptr->eutra_detect_status= ss_info_ptr->eutra_detect_status;
    new_info_ptr->stack_info[0].bcmcs_srv_supported = ss_info_ptr->ss_main_bcmcs_srv_supported ;
    new_info_ptr->stack_info[0].bcmcs_srv_status = ss_info_ptr->ss_main_bcmcs_srv_status ;
    new_info_ptr->requesting_client_id = ss_info_ptr->requesting_client_id ;
    new_info_ptr->msm_id = ss_info_ptr->msm_id ;
    new_info_ptr->ipapp_info = ss_info_ptr->ipapp_info ;
    new_info_ptr->stack_info[0].simultaneous_mode= ss_info_ptr->simultaneous_mode;
    new_info_ptr->stack_info[0].available_plmn_type = ss_info_ptr->available_plmn_type ;
    new_info_ptr->stack_info[0].cell_access_info = ss_info_ptr->gw3_cell_access_info ;
    new_info_ptr->stack_info[0].lte_ims_voice_avail = ss_info_ptr->lte_ims_voice_avail;
    new_info_ptr->stack_info[0].lte_ims_emerg_avail = ss_info_ptr->lte_ims_emerg_avail;

    switch(ss_info_ptr->gw3_sys_mode)
    {
      case  SYS_SYS_MODE_LTE:
        new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.rsrp = ss_info_ptr->gw3_rsrp;
        new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.rsrq= ss_info_ptr->gw3_rsrq;
        new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.lac= ss_info_ptr->gw3_lac;
        new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.tac= ss_info_ptr->gw3_tac;
        new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.rac_or_mme_code= ss_info_ptr->gw3_rac_or_mme_code;
        new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.embms_info = ss_info_ptr->gw3_embms_info ;
        new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.voice_support_on_lte = ss_info_ptr->voice_support_on_lte;
        new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.csg_info = ss_info_ptr->csg_info;
        break ;

      case SYS_SYS_MODE_GSM:
        new_info_ptr->stack_info[0].rat_mode_info.gsm_mode_info.rac_or_mme_code= ss_info_ptr->gw3_rac_or_mme_code;
        new_info_ptr->stack_info[0].rat_mode_info.gsm_mode_info.lac= ss_info_ptr->gw3_lac;
        new_info_ptr->stack_info[0].rat_mode_info.gsm_mode_info.csg_info = ss_info_ptr->csg_info;
        break ;

      case SYS_SYS_MODE_WCDMA:
        new_info_ptr->stack_info[0].rat_mode_info.wcdma_mode_info.lac= ss_info_ptr->gw3_lac;
        new_info_ptr->stack_info[0].rat_mode_info.wcdma_mode_info.rac_or_mme_code= ss_info_ptr->gw3_rac_or_mme_code;
        new_info_ptr->stack_info[0].rat_mode_info.wcdma_mode_info.csg_info = ss_info_ptr->csg_info;
        break ;

      case SYS_SYS_MODE_TDS:
        new_info_ptr->stack_info[0].rat_mode_info.tds_mode_info.lac= ss_info_ptr->gw3_lac;
        new_info_ptr->stack_info[0].rat_mode_info.tds_mode_info.rac_or_mme_code= ss_info_ptr->gw3_rac_or_mme_code;
        break ;

      default:
        break;
    }
  }
  /*
  ** Information of HYBR_2 stack will go into stack[0]
  ** for sglte and svlte configs we had already put if condition , below if is for NON-SGLTE and NON-SVLTE
  ** hybr_2 info will go to second sim(as_id_2) stack[0]
  */

  else if(req_as_id == ss_info_ptr->gw_asubs_id )
  {
    //hybrid2 data in stack 0

    new_info_ptr->number_of_stacks = 1 ;
    new_info_ptr->asubs_id = ss_info_ptr->gw_asubs_id ;
    new_info_ptr->ps_data_suspend = ss_info_ptr->gw_ps_data_suspend ;
    new_info_ptr->stack_info[0].is_operational= ss_info_ptr->is_hybr_gw_operational;
    new_info_ptr->stack_info[0].srv_status = ss_info_ptr->gw_srv_status;
    new_info_ptr->stack_info[0].true_srv_status = ss_info_ptr->true_gw_srv_status;
    new_info_ptr->stack_info[0].srv_domain= ss_info_ptr->gw_srv_domain;
    new_info_ptr->stack_info[0].effective_srv_domain = cmph_get_effective_srv_domain(req_as_id,ss_info_ptr->srv_domain);
    new_info_ptr->stack_info[0].srv_capability= ss_info_ptr->gw_srv_capability;
    new_info_ptr->stack_info[0].sys_mode= ss_info_ptr->gw_sys_mode;
    new_info_ptr->stack_info[0].mode_info= ss_info_ptr->gw_mode_info;
    new_info_ptr->stack_info[0].roam_status= ss_info_ptr->gw_roam_status;
    new_info_ptr->stack_info[0].sys_id= ss_info_ptr->gw_sys_id;
    new_info_ptr->stack_info[0].is_sys_prl_match= ss_info_ptr->gw_is_sys_prl_match;
    new_info_ptr->stack_info[0].is_sys_forbidden= ss_info_ptr->gw_is_sys_forbidden;
    new_info_ptr->stack_info[0].rssi= ss_info_ptr->gw_rssi;
    new_info_ptr->stack_info[0].ecio= ss_info_ptr->gw2_ecio;
    new_info_ptr->stack_info[0].io= ss_info_ptr->gw_io;
    new_info_ptr->stack_info[0].sinr= ss_info_ptr->gw_sinr;
    new_info_ptr->stack_info[0].pathloss= ss_info_ptr->gw_pathloss;
    new_info_ptr->stack_info[0].sir= ss_info_ptr->gw_sir;
    new_info_ptr->stack_info[0].rssi2= ss_info_ptr->gw_rssi2;
    new_info_ptr->stack_info[0].rscp= ss_info_ptr->gw_rscp;
    new_info_ptr->stack_info[0].cqi_info= ss_info_ptr->gw_cqi_info;
    new_info_ptr->stack_info[0].ecio_for_display = ss_info_ptr->gw_ecio_for_display;
    new_info_ptr->stack_info[0].psist= ss_info_ptr->psist;
    new_info_ptr->is_csfb_call_active = ss_info_ptr->is_csfb_call_active;
    new_info_ptr->stack_info[0].active_band = ss_info_ptr->gw_active_band;
    new_info_ptr->stack_info[0].active_channel= ss_info_ptr->gw_active_channel;
    new_info_ptr->curr_uptime= ss_info_ptr->curr_uptime;
    new_info_ptr->stack_info[0].emerg_num_list= ss_info_ptr->gw_emerg_num_list;
    new_info_ptr->stack_info[0].cell_info= ss_info_ptr->gw_cell_info;
    new_info_ptr->def_roam_ind= ss_info_ptr->def_roam_ind;
    new_info_ptr->stack_info[0].cell_srv_ind= ss_info_ptr->gw_cell_srv_ind;
    new_info_ptr->stack_info[0].reg_reject_info= ss_info_ptr->gw_reg_reject_info;
    new_info_ptr->stack_info[0].cipher_domain= ss_info_ptr->gw_cipher_domain;
    new_info_ptr->stack_info[0].geo_sys_idx= ss_info_ptr->geo_sys_idx;

    if(ss_info_ptr->sys_mode == SYS_SYS_MODE_CDMA)
    {
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.cdma_reg_prd = ss_info_ptr->cdma_reg_prd;

    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.frame_err_rate = ss_info_ptr->frame_err_rate;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.is_colloc = ss_info_ptr->is_colloc;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.height = ss_info_ptr->height;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.horiz_uncertainty= ss_info_ptr->horiz_uncertainty;
    new_info_ptr->stack_info[0].rat_mode_info.cdma_mode_info.vert_uncertainty= ss_info_ptr->vert_uncertainty;
    }
    new_info_ptr->stack_info[0].cell_bc_info= ss_info_ptr->gw_cell_bc_info;
    new_info_ptr->bsr_in_progress= ss_info_ptr->bsr_in_progress;
    new_info_ptr->eutra_detect_status= ss_info_ptr->eutra_detect_status;
    new_info_ptr->stack_info[0].bcmcs_srv_supported = ss_info_ptr->ss_main_bcmcs_srv_supported ;
    new_info_ptr->stack_info[0].bcmcs_srv_status = ss_info_ptr->ss_main_bcmcs_srv_status ;
    new_info_ptr->requesting_client_id = ss_info_ptr->requesting_client_id ;
    new_info_ptr->msm_id = ss_info_ptr->msm_id ;
    new_info_ptr->ipapp_info = ss_info_ptr->ipapp_info ;
    new_info_ptr->stack_info[0].simultaneous_mode= ss_info_ptr->simultaneous_mode;



    switch(ss_info_ptr->gw_sys_mode)
    {
      case  SYS_SYS_MODE_LTE:
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.rsrp = ss_info_ptr->gwl_rsrp;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.rsrq= ss_info_ptr->gwl_rsrq;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.lac= ss_info_ptr->gwl_lac;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.tac= ss_info_ptr->gwl_tac;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.rac_or_mme_code= ss_info_ptr->gwl_rac_or_mme_code;
      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.embms_info = ss_info_ptr->gwl_embms_info ;

      new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.voice_support_on_lte = ss_info_ptr->voice_support_on_lte;
      break ;

      case SYS_SYS_MODE_GSM:
      new_info_ptr->stack_info[0].rat_mode_info.gsm_mode_info.rac_or_mme_code= ss_info_ptr->gwl_rac_or_mme_code;
      new_info_ptr->stack_info[0].rat_mode_info.gsm_mode_info.lac= ss_info_ptr->gwl_lac;
      break ;

      case SYS_SYS_MODE_WCDMA:
      new_info_ptr->stack_info[0].rat_mode_info.wcdma_mode_info.lac= ss_info_ptr->gwl_lac;
      new_info_ptr->stack_info[0].rat_mode_info.wcdma_mode_info.rac_or_mme_code= ss_info_ptr->gwl_rac_or_mme_code;
      break ;

      case SYS_SYS_MODE_TDS:
      new_info_ptr->stack_info[0].rat_mode_info.tds_mode_info.lac= ss_info_ptr->gwl_lac;

      new_info_ptr->stack_info[0].rat_mode_info.tds_mode_info.rac_or_mme_code= ss_info_ptr->gwl_rac_or_mme_code;
      break ;

      default:
      break;

    }
    new_info_ptr->stack_info[0].cell_access_info = ss_info_ptr->gw_cell_access_info ;
    new_info_ptr->stack_info[0].available_plmn_type = ss_info_ptr->available_plmn_type ;

    switch(ss_info_ptr->gw_sys_mode)
    {
      case  SYS_SYS_MODE_LTE:
        new_info_ptr->stack_info[0].rat_mode_info.lte_mode_info.csg_info = ss_info_ptr->csg_info;
        break ;

      case SYS_SYS_MODE_GSM:
        new_info_ptr->stack_info[0].rat_mode_info.gsm_mode_info.csg_info = ss_info_ptr->csg_info;
        break ;

      case SYS_SYS_MODE_WCDMA:
        new_info_ptr->stack_info[0].rat_mode_info.wcdma_mode_info.csg_info = ss_info_ptr->csg_info;
        break ;

      default:
        break;
    }

  }

  // Below prints will print both stack information of req_as_id sub
  CM_MSG_HIGH_5("is_operational[0] : %d, is_operational[1]: %d srv_status[0] :  %d, srv_status[1]: %d, number_of_stacks %d",
  new_info_ptr->stack_info[0].is_operational, new_info_ptr->stack_info[1].is_operational,
  new_info_ptr->stack_info[0].srv_status, new_info_ptr->stack_info[1].srv_status,
  new_info_ptr->number_of_stacks);
 
  CM_MSG_HIGH_4("true_srv_status[0] : %d, true_srv_status[1] : %d srv_domain[0] : %d, srv_domain[1]: %d",
  	new_info_ptr->stack_info[0].true_srv_status, new_info_ptr->stack_info[1].true_srv_status,
  	new_info_ptr->stack_info[0].srv_domain, new_info_ptr->stack_info[1].srv_domain);
 
  CM_MSG_HIGH_6("srv_capability[0] : %d, srv_capability[1] : %d sys_mode[0] : %d, sys_mode[1] : %d roam_status[0] : %d, roam_status[1] : %d", 
  	new_info_ptr->stack_info[0].srv_capability, new_info_ptr->stack_info[1].srv_capability,
  	new_info_ptr->stack_info[0].sys_mode, new_info_ptr->stack_info[1].sys_mode,
  	new_info_ptr->stack_info[0].roam_status, new_info_ptr->stack_info[1].roam_status);
  

}

/*===========================================================================

FUNCTION cmss_copy_rssi_info

DESCRIPTION
  Copy the current serving system state information ralted to RSSI into a specified buffer.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  TRUE if serving system information is valid, FALSE otherwise.

  Note that serving system information only becomes valid after cmss_init()
  returns.

SIDE EFFECTS
  none

===========================================================================*/
 void cmss_copy_rssi_info(

      cm_mm_ss_info_s_type         *ss_info_ptr,
          /* Copy serving system state info into this buffer */

      sys_modem_as_id_e_type        req_as_id,

      cm_mm_msim_ss_info_s_type    *new_info_ptr
      /* Base ss_info that gets copied into ss_info_ptr. Can be either
      ** cmss.info OR cmss.srv_avail_info
      */
  )
{
  cmss_s_type          *ss_ptr        =  cmss_ptr();
      /* Point at serving system object to be initialized */

  uint8 stack_index = 0;

  for (stack_index = 0; stack_index < new_info_ptr->number_of_stacks; stack_index++)
  {
      ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].rssi     = new_info_ptr->stack_info[stack_index].rssi;
      ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].ecio     = new_info_ptr->stack_info[stack_index].ecio;
      ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].io       = new_info_ptr->stack_info[stack_index].io;
      ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].sinr     = new_info_ptr->stack_info[stack_index].sinr;
      ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].pathloss = new_info_ptr->stack_info[stack_index].pathloss;
      ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].sir      = new_info_ptr->stack_info[stack_index].sir;
      ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].rssi2    = new_info_ptr->stack_info[stack_index].rssi2;
      ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].rscp     = new_info_ptr->stack_info[stack_index].rscp;
      ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].ecio_for_display = ss_info_ptr->ecio_for_display;
      ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].mode_info.gw_info.bit_err_rate = new_info_ptr->stack_info[stack_index].mode_info.gw_info.bit_err_rate;

      switch(ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].sys_mode)
      {
        case  SYS_SYS_MODE_LTE:
          ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].rat_mode_info.lte_mode_info.rsrp = ss_info_ptr->rsrp;
          ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].rat_mode_info.lte_mode_info.rsrq = ss_info_ptr->rsrq;
          break ;

        case SYS_SYS_MODE_GSM:
        case SYS_SYS_MODE_WCDMA:
          ss_ptr->new_srv_avl_info[req_as_id].stack_info[stack_index].ecio   = ss_info_ptr->gw_ecio;
          break;
        case SYS_SYS_MODE_TDS:
        case SYS_SYS_MODE_CDMA:
        default:
        break;
      }
  }
}

/*===========================================================================

FUNCTION cmss_reset_signal_info

DESCRIPTION
  resets the signal strength parameters uponserving system mode change.

DEPENDENCIES
  None

RETURN VALUE
  none

SIDE EFFECTS
  Changes Serving System object
===========================================================================*/
void cmss_reset_signal_info(
     cm_ss_e_type          ss
  )
{
  cmss_s_type          *ss_ptr        =  cmss_ptr();
  sys_modem_as_id_e_type   as_id  = cmph_map_cm_ss_to_subs(ss);

  sys_modem_as_id_e_type   subId_main    = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;
  
  sys_modem_as_id_e_type   subId    = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) ;
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  sys_modem_as_id_e_type   subId2   = cmph_map_cm_ss_to_subs(CM_SS_HYBR_3);
  #endif
  
  if (! (cmph_is_as_id_valid(subId_main) && 
       cmph_is_as_id_valid(subId) 
       #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
       && cmph_is_as_id_valid(subId2)
       #endif
       ))
  {
    CM_MSG_HIGH_0 ("Subs Id not valid in cmss_reset_signal_info");
    return ;
  }
 
  if (!(as_id >= SYS_MODEM_AS_ID_1 && as_id < MAX_AS_IDS))
  {
    CM_MSG_HIGH_0("as_id invalid in cmss_reset_signal_info");
    return;
  }

  if(CM_IS_MODE_3GPP(ss_ptr->new_srv_avl_info[as_id].stack_info[0].sys_mode) &&
     ss_ptr->new_srv_avl_info[as_id].stack_info[0].sys_mode != ss_ptr->info.sys_mode &&
     ss == CM_SS_MAIN)
  {
    CM_MSG_HIGH_3("CMSS MAIN: RESET RSSI, sys_mode %d->%d, as_id=%d",
      ss_ptr->new_srv_avl_info[as_id].stack_info[0].sys_mode,
      ss_ptr->info.sys_mode,
      as_id);
    ss_ptr->info.rssi = CMSS_RSSI_NO_SIGNAL;
    ss_ptr->info.rsrp =0;
    ss_ptr->info.rsrq=0;
    ss_ptr->info.rscp = CMSS_RSCP_NO_SIGNAL;
    ss_ptr->info.rssi2 = CMSS_RSSI2_NO_SIGNAL;
    ss_ptr->info.ecio = CMSS_ECIO_VALUE_NO_SIGNAL;
    ss_ptr->info.sir = CMSS_SIR_VALUE_NO_SIGNAL;
    ss_ptr->bit_err_rate = CMSS_BER_VALUE_NO_SIGNAL;
    ss_ptr->info.pathloss = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
   }
  else if(CM_IS_MODE_3GPP(ss_ptr->new_srv_avl_info[as_id].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_2)].sys_mode) &&
          ss_ptr->new_srv_avl_info[as_id].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_2)].sys_mode != ss_ptr->info.gw_sys_mode &&
          ss == CM_SS_HYBR_2)
  {
    CM_MSG_HIGH_3("CMSS HYBR2: RESET RSSI, sys_mode %d->%d, as_id=%d",
      ss_ptr->new_srv_avl_info[as_id].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_2)].sys_mode,
      ss_ptr->info.gw_sys_mode,
      as_id);
    ss_ptr->info.gw_rssi = CMSS_RSSI_NO_SIGNAL;
    //ss_ptr->info.rsrp =0;
    //ss_ptr->info.rsrq=0;
    ss_ptr->info.gw_rscp = CMSS_RSCP_NO_SIGNAL;
    ss_ptr->info.gw_rssi2 = CMSS_RSSI2_NO_SIGNAL;
    ss_ptr->info.gw_ecio = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
    ss_ptr->info.gw_sir = CMSS_SIR_VALUE_NO_SIGNAL;
    //ss_ptr->bit_err_rate = CMSS_BER_VALUE_NO_SIGNAL;
    ss_ptr->info.gw_pathloss = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
  } 
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  else if(ss == CM_SS_HYBR_3 &&
          CM_IS_MODE_3GPP(ss_ptr->new_srv_avl_info[as_id].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_3)].sys_mode) && 
          ss_ptr->new_srv_avl_info[as_id].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_3)].sys_mode != ss_ptr->info.gw3_sys_mode)
  {
    CM_MSG_HIGH_3("CMSS HYBR3: RESET RSSI, sys_mode %d->%d, as_id=%d",
      ss_ptr->new_srv_avl_info[as_id].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_3)].sys_mode,
      ss_ptr->info.gw3_sys_mode,
      as_id);
    ss_ptr->info.gw3_rssi = CMSS_RSSI_NO_SIGNAL;
    ss_ptr->info.gw3_rscp = CMSS_RSCP_NO_SIGNAL;
    ss_ptr->info.gw3_rssi2 = CMSS_RSSI2_NO_SIGNAL;
    ss_ptr->info.gw3_ecio = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
    ss_ptr->info.gw3_sir = CMSS_SIR_VALUE_NO_SIGNAL;
    ss_ptr->info.gw3_pathloss = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
  }
  #endif
}

/*===========================================================================

FUNCTION cmss_event

DESCRIPTION
  Notify the client list of a specified serving system event.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  Changes Serving System object
===========================================================================*/
void cmss_event(

    cm_ss_e_type          ss,
      /* stack whose SS info has changed */

    cm_ss_event_e_type    ss_event
        /* notify client list of this serving system event */
)
{

  cm_mm_ss_info_s_type *ss_info_ptr   = cmss_info_alloc();
      /* Allocate serving system info buffer */

  cm_mm_msim_ss_info_s_type *ss_info_ptr_new   = cmss_info_alloc_new();
      /* Allocate serving system info buffer */

  cmss_s_type          *ss_ptr        =  cmss_ptr();
      /* Point at serving system object to be initialized */

  cmph_s_type *ph_ptr = cmph_ptr();
      /* Point at Phone Object to be initialized */

  uint64               changed_fields = 0;
      /* Local variable to get bit mask for information throttled */

  uint64               changed_fields2 = 0;
      /* Extension to changed_fields */

  uint64               hybr_gw_changed_fields = 0;
      /* Local variable to get bit mask for information throttled */

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  uint64               hybr_gw3_changed_fields = 0;
      /* Local variable to get bit mask for information throttled */
  #endif

  cm_mm_msim_ss_info_s_type *new_info_ptr = NULL ;

  sys_modem_as_id_e_type req_as_id = SYS_MODEM_AS_ID_NONE ;

  uint8                max_as_id = 0;

  boolean              forcefully_send_status = TRUE ;
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( BETWEEN(ss_event, CM_SS_EVENT_NONE, CM_SS_EVENT_MAX) );
  

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (cmph_is_msim() && MAX_AS_IDS > 1 && ss_event == CM_SS_EVENT_SRV_CHANGED)
  {
    CM_MSG_HIGH_2("PRE ssevt sub0: info.sys_mode=%d, client sys_mode=%d",
                   ss_ptr->info.sys_mode,
                   ss_ptr->new_srv_avl_info[0].stack_info[0].sys_mode);
    CM_MSG_HIGH_2("PRE ssevt sub0: info.rssi=%d, client  rssi=%d",
                   ss_ptr->info.rssi,
                   ss_ptr->new_srv_avl_info[0].stack_info[0].rssi);
    CM_MSG_HIGH_2("PRE ssevt sub1: info.sys_mode=%d, client sys_mode=%d",
                   ss_ptr->info.gw_sys_mode,
                   ss_ptr->new_srv_avl_info[1].stack_info[0].sys_mode);
    CM_MSG_HIGH_2("PRE ssevt sub1: info.rssi=%d, client rssi=%d",
                   ss_ptr->info.gw_rssi,
                   ss_ptr->new_srv_avl_info[1].stack_info[0].rssi);
  }
  req_as_id = cmph_map_cm_ss_to_subs(ss);

  if (!cmph_is_as_id_valid(req_as_id))
  {
    cm_mem_free(ss_info_ptr);
    cm_mem_free(ss_info_ptr_new);
    return ;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Update the ss info object with the current throttling status
  */
  if(cmss_update_thr_status())
  {
    CM_MSG_MED_2("Thr status update %d %d",
                                 ss_ptr->info.main_thr_status.ss_thr_status,
                                  ss_ptr->info.hdr_thr_status.ss_thr_status);
  }
  #ifdef FEATURE_MMODE_TRIPLE_SIM
  if (cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_TRIPLE_SIM_TRIPLE_STANDBY)
  {
    max_as_id = 3;
  }
  else
  #endif
  if (cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_DUAL_SIM_DUAL_STANDBY ||
           cmpmprx_get_device_mode() == SYS_MODEM_DEVICE_MODE_DUAL_SIM_DUAL_ACTIVE)
  {
    max_as_id = 2;
  }
  else
  {
    max_as_id = 1;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmss_resolve_hdr_lte_srv_conflicts();
  cmss_resolve_lte_lte_srv_conflicts();
   if(ss_event == CM_SS_EVENT_SRV_CHANGED)
   {
     cmss_reset_signal_info(ss);
   }
  /* Copy serving system state information into
  ** allocated buffer.
  */
  (void) cmss_info_get( ss_info_ptr, &ss_ptr->info );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* HDR and MAIN serving parameters are throttled to avoid
  ** CM_SS_EVENT_SRV_CHANGED event being generated at rapid
  ** succession. If this event does get generated due to other
  ** factors like change in sim_state or data_suspend, then
  ** throttling gets terminated and fields are updated with right
  ** values.
  */
  
  new_info_ptr = ( cm_mm_msim_ss_info_s_type * ) cm_mem_malloc( sizeof( cm_mm_msim_ss_info_s_type ) );

  ss_ptr->new_srv_avl_info[req_as_id].changed_fields_subs = 0;
  ss_ptr->new_srv_avl_info[req_as_id].stack_info[0].changed_fields = 0;  
  ss_ptr->new_srv_avl_info[req_as_id].stack_info[0].changed_fields2 = 0;  
  ss_ptr->new_srv_avl_info[req_as_id].stack_info[0].signal_strength_changed_fields = 0;

  ss_ptr->new_srv_avl_info[req_as_id].stack_info[1].changed_fields = 0;  
  ss_ptr->new_srv_avl_info[req_as_id].stack_info[1].changed_fields2 = 0;  
  ss_ptr->new_srv_avl_info[req_as_id].stack_info[1].signal_strength_changed_fields = 0;
  
 switch (ss_event)
 {
   case CM_SS_EVENT_SRV_CHANGED:
   case CM_SS_EVENT_DCH_CELL_ID_RSP:
  {

    
    sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;
    
    uint8  stk_id = ph_ptr->ss_subs_map[CM_SS_MAIN].stack_id;
    
    /* Get curr timer - used to check if no_srv_uptime is expired */
    dword clk_time = time_get_uptime_secs();

    forcefully_send_status = FALSE ;

    ss_info_ptr->sys_sel_pref_req_id = ss_ptr->info.sys_sel_pref_req_id;
    
    if (!cmph_is_as_id_valid(subId))
    {
      cm_mem_free(ss_info_ptr);
      cm_mem_free(ss_info_ptr_new);
      cm_mem_free(new_info_ptr);
      return ;
    }


    /*
    ** update bit masks to show right values. Changed fields given to clients
    ** should be difference between last info sent to client vs current
    ** info being sent. Calculating changed fields from ss_ptr->info gives
    ** the difference between last info sent to client vs current
    ** internal values maintained by CM. Current info being sent can be
    ** different from current internal values maintained by CM
    */
   //CM_MSG_MED_2("old csg_id:%d, new csg_id:%d", ss_ptr->new_srv_avl_info.csg_info.csg_id, ss_info_ptr->csg_info.csg_id);
   //CM_MSG_MED_2("old hnb_name_length:%d, new hnb_name_length:%d", ss_ptr->srv_avail_info.csg_info.hnb_name.length, ss_info_ptr->csg_info.hnb_name.length);
   //CM_MSG_MED_1("old sys_id_type:%d sys_id:",ss_ptr->srv_avail_info.sys_id.id_type);
   //sd_misc_sys_id_print(ss_ptr->srv_avail_info.sys_id);
   sd_misc_sys_id_print(ss_info_ptr->sys_id);

      changed_fields   =
        cmss_get_ss_main_info_change (ss_info_ptr, &ss_ptr->new_srv_avl_info[subId], &changed_fields2);

      /* Special handling for the following case (only for main stack):
         ** CM needs to send client ssevt but no_srv_uptime is still running.
         ** In this case, send client with the last service status and sys mode to avoid
         ** sending no service indication to clients.
         */
      if ((((changed_fields & CM_SS_CELL_INFO_MASK) != 0) ||
          ((changed_fields2 & CM_SS_LTE_EMERG_ACCESS_BARRED_MASK) != 0 &&
	       ss_info_ptr->cell_info.emerg_access_status!= SYS_LTE_EMERG_ACCESS_UNAVAILABLE) ||
           ((changed_fields2 & CM_SS_LTE_CELL_ACCESS_STATUS_MASK) != 0) ||
           ((changed_fields & CM_SS_CELL_BROADCAST_MASK) != 0)) &&
           (changed_fields & CM_SS_SRV_STATUS_MASK) != 0 &&
           (changed_fields & CM_SS_SYS_MODE_MASK) != 0 &&
           ss_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV &&
           ss_ptr->no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE &&
           ss_ptr->no_srv_uptime > clk_time )
      {
        CM_MSG_HIGH_0("CELL INFO/cb UPDATE while no_srv_timer running");

        /* Use the last srv_status in cmss event */
        ss_info_ptr->srv_status = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status;
        ss_info_ptr->sys_mode = ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode;

        /* Make sure srv_status and sys_mode mask is not set
             */
        changed_fields = changed_fields & (~ CM_SS_SRV_STATUS_MASK);
        changed_fields = changed_fields & (~ CM_SS_SYS_MODE_MASK);
      }

    ss_ptr->info.changed_fields   |= changed_fields;
    
    ss_info_ptr->changed_fields   |= changed_fields;
    
    ss_ptr->info.changed_fields2   |= changed_fields2;
    
    ss_info_ptr->changed_fields2   |= changed_fields2;

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* If the HDR no_srv_uptime is still running do not notify clients of
    ** HDR service loss.
    */
    cmss_set_hdr_no_srv_per_uptime( ss_info_ptr );


    
    if ((cmph_ptr()->main_stack_info.pref_info.hybr_pref != CM_HYBR_PREF_OFF) &&
              (  ((sys_srv_status_is_srv(ss_info_ptr->hdr_srv_status)) &&
                  (ss_ptr->new_srv_avl_info[subId].stack_info[1].sys_mode == SYS_SYS_MODE_LTE))
             ||
                ((ss_ptr->new_srv_avl_info[subId].stack_info[1].sys_mode == SYS_SYS_MODE_HDR) &&
                  (ss_info_ptr->gw_sys_mode == SYS_SYS_MODE_LTE))
             )
            )
    {
      
      CM_MSG_HIGH_0("Second Stack previously HDR and now LTE   or  previously LTE and now HDR");
      ss_ptr->new_srv_avl_info[subId].stack_info[1].changed_fields = 0XFFFFFFFF ;
      ss_ptr->new_srv_avl_info[subId].stack_info[1].changed_fields2 = 0XFFFFFFFF ;
    }
    else if((ss_info_ptr->sys_mode == SYS_SYS_MODE_HDR)  
            || (ss_ptr->new_srv_avl_info[subId].stack_info[1].sys_mode == SYS_SYS_MODE_HDR)
            || (ss_info_ptr->hdr_srv_status  == SYS_SRV_STATUS_SRV)
           )
    {
      subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_1) ;
      
      stk_id = ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id;

      
    if (!cmph_is_as_id_valid(subId))
    {
      cm_mem_free(ss_info_ptr);
      cm_mem_free(ss_info_ptr_new);
      cm_mem_free(new_info_ptr);
      return ;
    }

    changed_fields |=
        cmss_get_ss_hdr_info_change  (ss_info_ptr, &ss_ptr->new_srv_avl_info[subId]);

    CM_MSG_HIGH_2("CMSS Change with HDR 0x%x 0x%x ",QWORD_HIGH(changed_fields),
                                       QWORD_LOW(changed_fields));

    ss_ptr->info.changed_fields   |= changed_fields;

    ss_info_ptr->changed_fields   |= changed_fields;

    ss_ptr->info.changed_fields2   |= changed_fields2;

    ss_info_ptr->changed_fields2   |= changed_fields2;
    }
    else if( cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) || cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)
            || cmph_is_msim())
    {
      /* Get hybr2 change fields only if hybr2 is required per config */
      if (!cmph_no_hybr2())
      {
        subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) ;
        
        stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_2);
        
        if (!cmph_is_as_id_valid(subId))
        {
          cm_mem_free(ss_info_ptr);
          cm_mem_free(ss_info_ptr_new);
          cm_mem_free(new_info_ptr);
          return ;
        }
        
        
        hybr_gw_changed_fields |=
            cmss_get_ss_hybr_2_info_change (ss_info_ptr, &ss_ptr->new_srv_avl_info[subId]);
  
        ss_ptr->info.hybr_gw_changed_fields   |= hybr_gw_changed_fields;
  
        ss_info_ptr->hybr_gw_changed_fields   |= hybr_gw_changed_fields;
      }

      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)


      if(cmph_is_tsts() || cmph_is_sxlte())
      {
      
      subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_3) ;
      
      stk_id = ph_ptr->ss_subs_map[CM_SS_HYBR_3].stack_id;
      
      if (!cmph_is_as_id_valid(subId))
      {
        cm_mem_free(ss_info_ptr);
        cm_mem_free(ss_info_ptr_new);
        cm_mem_free(new_info_ptr);
        return ;
      }
      
      
      hybr_gw3_changed_fields |=
        cmss_get_ss_hybr_3_info_change (ss_info_ptr, &ss_ptr->new_srv_avl_info[subId]);

      ss_ptr->info.gw3_changed_fields   |= hybr_gw3_changed_fields;

      ss_info_ptr->gw3_changed_fields   |= hybr_gw3_changed_fields;
      }
      #endif
    }

    #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)

    if(cmph_is_feature_mask(FEATURE_MODE_MASK_SGLTE_MSIM) &&
       ss == CM_SS_HYBR_2)
    {
      if (sys_srv_status_is_srv(ss_ptr->info.gw_srv_status))
      {
        /* Call Objects need to be consistent with information such as sys_mode
        ** that is informed to the clients. So srv status is informed to call
        ** objects only if clients get informed with CM_SS_EVENT_SRV_CHANGED
        */
        cmcall_proc_srv_status(ss_ptr, CM_SS_HYBR_2);
      }
    }
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    else if(ss == CM_SS_HYBR_3)
    {
      if (sys_srv_status_is_srv(ss_ptr->info.gw3_srv_status))
      {
        /* Call Objects need to be consistent with information such as sys_mode
        ** that is informed to the clients. So srv status is informed to call
        ** objects only if clients get informed with CM_SS_EVENT_SRV_CHANGED
        */
        cmcall_proc_srv_status(ss_ptr, CM_SS_HYBR_3);
      }
    }
    #endif /* FEATURE_MMODE_TRIPLE_SIM */


    /* Upon SGLTE IRAT completion, cmss_event with CM_SS_MAX is called.
      ** Need to proc cm calls for both stacks.
      */
    else if ((CMPH_SS_FEATURE_MODE(ss, ph_ptr) == SYS_SUBS_FEATURE_MODE_SGLTE) &&
               ss == CM_SS_MAX)
    {
      if (sys_srv_status_is_srv(ss_ptr->info.gw_srv_status))
      {
        cmcall_proc_srv_status(ss_ptr, CM_SS_HYBR_2);
      }

      if (sys_srv_status_is_srv(ss_ptr->info.srv_status))
      {
        cmcall_proc_srv_status(ss_ptr, CM_SS_MAIN);
      }
    }

    else
    {
      /* Call objects are updated only when there is service */
      if (sys_srv_status_is_srv(ss_ptr->info.srv_status))
      {
        /* Call Objects need to be consistent with information such as sys_mode
        ** that is informed to the clients. So srv status is informed to call
        ** objects only if clients get informed with CM_SS_EVENT_SRV_CHANGED
        */
        cmcall_proc_srv_status(ss_ptr, CM_SS_MAIN);
      }
    }
    #endif /* defined CM_GW_SUPPORTED */
    CM_MSG_HIGH_1("qmss=%d",ph_ptr->qmss_enabled);

    CM_MSG_HIGH_3("msrvstatus=%d,hsrvstatus=%d,h3srvstatus=%d",ss_ptr->main_srv_status,
                                       ss_ptr->hybr_gw_srv_status,
                                       ss_ptr->hybr_3_gw_srv_status);
  #if 0


  CM_MSG_HIGH_3("qmss=%d,can0=%d,can1=%d",ph_ptr->qmss_enabled,
                                     cmss_can_trigger_modem_reset_0,
                                     cmss_can_trigger_modem_reset_1);
  if( (ss_ptr->enable_modem_reset == TRUE) && !cmph_ss_susp_due_to_emerg(CM_SS_MAX)&& cmph_is_msim())
  {
      cmss_modem_reset_trigger_s_type* trigger;

      CM_MSG_HIGH_0("Modem Reset Processing");
    /*Modem Reset feature should be enabled in EFS*/
      if (!cmss_can_trigger_modem_reset_0)
      {
        cmss_can_trigger_modem_reset_0 = (ss_ptr->main_srv_status == SYS_SRV_STATUS_SRV);
      }

      if (!cmss_can_trigger_modem_reset_1)
      {
        cmss_can_trigger_modem_reset_1 = (ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_SRV);
      }

      if (!cmss_can_trigger_modem_reset_2)
      {
        cmss_can_trigger_modem_reset_2 = (ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_SRV);
      }

      CM_MSG_HIGH_3("can0=%d,can1=%d,can2=%d",cmss_can_trigger_modem_reset_0,
                                       cmss_can_trigger_modem_reset_1,
                                       cmss_can_trigger_modem_reset_2);

      trigger = cmss_check_if_modem_need_reset();
      if (trigger != NULL)
      {
        CM_MSG_HIGH_3("asid=%d,can0=%d,can1=%d",trigger->as_id,
                                       cmss_can_trigger_modem_reset_0,
                                       cmss_can_trigger_modem_reset_1);
        CM_MSG_HIGH_1("can2=%d",cmss_can_trigger_modem_reset_2);

        if (((trigger->as_id==SYS_MODEM_AS_ID_1)&&cmss_can_trigger_modem_reset_0)||
            ((trigger->as_id==SYS_MODEM_AS_ID_2)&&cmss_can_trigger_modem_reset_1)||
            ((trigger->as_id==SYS_MODEM_AS_ID_3)&&cmss_can_trigger_modem_reset_2))
        {
          CM_MSG_HIGH_0("calling cmss_modem_reset_start_timer()");
          cmss_modem_reset_start_timer(trigger);
        }
        else
        {
          CM_MSG_HIGH_0("cmss_modem_reset_start_timer() not called");
          cm_mem_free(trigger);
        }
      }
      else
      {
        CM_ERR_0("Trigger is NULL");
      }
  }
    #endif
  }
   break;

   case  CM_SS_EVENT_RSSI:
   case  CM_SS_EVENT_HDR_RSSI:
   case  CM_SS_EVENT_GW_RSSI:

    forcefully_send_status = FALSE ;
    cmss_get_signal_strength_info_change (ss_info_ptr, ss_ptr);
    break;
   default :
     break ;
  }

  CM_MSG_HIGH_6("CMSS Change 0x%x 0x%x, Change2 0x%x 0x%x,Hybr GW Change 0x%x 0x%x   ",
		 QWORD_HIGH(ss_info_ptr->changed_fields),
                 QWORD_LOW(ss_info_ptr->changed_fields),
		 QWORD_HIGH(ss_info_ptr->changed_fields2),
		 QWORD_LOW(ss_info_ptr->changed_fields2),
                 QWORD_HIGH(ss_info_ptr->hybr_gw_changed_fields),
                 QWORD_LOW(ss_info_ptr->hybr_gw_changed_fields)
               );

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    CM_MSG_HIGH_2("CMSS Hybr3 GW Change 0x%x 0x%x ",QWORD_HIGH(ss_info_ptr->gw3_changed_fields),
                                       QWORD_LOW(ss_info_ptr->gw3_changed_fields));
  #endif


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Debug message to indicate specific values of interest to DS client
  ** Data suspend and current mode
  */

  if ((ss_info_ptr->changed_fields & CM_SS_PS_DATA_SUSPEND_MASK) ||
      (ss_info_ptr->changed_fields & CM_SS_SYS_MODE_MASK))
  {
    CM_MSG_HIGH_2 ("Data suspend = %d, sys_mode = %d rep to clients",
                 ss_info_ptr->ps_data_suspend, ss_info_ptr->sys_mode);
  }
  if ((ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_PS_DATA_SUSPEND_MASK) ||
      (ss_info_ptr->hybr_gw_changed_fields & CM_SS_GW_SYS_MODE_MASK))
  {
    CM_MSG_HIGH_2 ("GW Data suspend = %d, GW sys_mode = %d rep to clients",
                 ss_info_ptr->gw_ps_data_suspend, ss_info_ptr->gw_sys_mode);
  }

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if ((ss_info_ptr->gw3_changed_fields & CM_SS_GW_PS_DATA_SUSPEND_MASK) ||
      (ss_info_ptr->gw3_changed_fields & CM_SS_GW_SYS_MODE_MASK))
  {
    CM_MSG_HIGH_2 ("GW3 Data suspend = %d, GW3 sys_mode = %d rep to clients",
                 ss_info_ptr->gw3_ps_data_suspend, ss_info_ptr->gw3_sys_mode);
  }
  #endif


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    switch(ss_event)
    {

      case CM_SS_EVENT_RSSI:
      case CM_SS_EVENT_HDR_RSSI:
      case CM_SS_EVENT_GW_RSSI:
        {
            
            cmss_mapping_info(ss_info_ptr , req_as_id , new_info_ptr) ;
            new_info_ptr->changed_fields_subs = ss_ptr->new_srv_avl_info[req_as_id].changed_fields_subs ;
            new_info_ptr->stack_info[0].changed_fields = ss_ptr->new_srv_avl_info[req_as_id].stack_info[0].changed_fields ;
            new_info_ptr->stack_info[0].changed_fields2 = ss_ptr->new_srv_avl_info[req_as_id].stack_info[0].changed_fields2 ;
            new_info_ptr->stack_info[0].signal_strength_changed_fields = ss_ptr->new_srv_avl_info[req_as_id].stack_info[0].signal_strength_changed_fields ;
            new_info_ptr->stack_info[1].changed_fields = ss_ptr->new_srv_avl_info[req_as_id].stack_info[1].changed_fields ;
            new_info_ptr->stack_info[1].changed_fields2 = ss_ptr->new_srv_avl_info[req_as_id].stack_info[1].changed_fields2 ;
            new_info_ptr->stack_info[1].signal_strength_changed_fields = ss_ptr->new_srv_avl_info[req_as_id].stack_info[1].signal_strength_changed_fields ;
        cmss_copy_rssi_info(ss_info_ptr , req_as_id , new_info_ptr) ;
          }

        break;

      case CM_SS_EVENT_SRV_CHANGED:
      case CM_SS_EVENT_DCH_CELL_ID_RSP:
      default:
        cmss_mapping_info(ss_info_ptr , req_as_id , new_info_ptr) ;
        if(new_info_ptr->number_of_stacks != 0)
        {
          CM_MSG_HIGH_2("no_of_stacks = %d, req_as_id %d",new_info_ptr->number_of_stacks,req_as_id);
          cmss_change_fields_mapping_info(&ss_ptr->new_srv_avl_info[req_as_id],new_info_ptr);
          cmss_change_fields2_mapping_info(&ss_ptr->new_srv_avl_info[req_as_id],new_info_ptr);    
        }

        if (ss_event == CM_SS_EVENT_SRV_CHANGED ||
            ss_event == CM_SS_EVENT_DCH_CELL_ID_RSP)
        {
          memscpy(&(ss_ptr->new_srv_avl_info[req_as_id]), sizeof(cm_mm_msim_ss_info_s_type) ,new_info_ptr ,sizeof(cm_mm_msim_ss_info_s_type));
        }
    }

    switch(ss_event)
    {
      case CM_SS_EVENT_SRV_CHANGED:
      case CM_SS_EVENT_DCH_CELL_ID_RSP:
        #if defined(FEATURE_IP_CALL)
        /* Inform CM ip application of change in serving system parameters.
        ** cmipapp is not a client to CM so this function can be called here
        */
        cmipapp_inform_srv_system_change ( new_info_ptr );
        #endif
        break;
      default:
        break;
    }

    memscpy(ss_info_ptr_new , sizeof(cm_mm_msim_ss_info_s_type) ,new_info_ptr ,sizeof(cm_mm_msim_ss_info_s_type));

    if(new_info_ptr->sys_sel_pref_req_id)
    {
      CM_MSG_HIGH_1("req_id %d", new_info_ptr->sys_sel_pref_req_id);
    }

      if(new_info_ptr->stack_info[0].changed_fields ||new_info_ptr->stack_info[0].changed_fields2 || new_info_ptr->stack_info[0].signal_strength_changed_fields ||
         new_info_ptr->stack_info[1].changed_fields ||new_info_ptr->stack_info[1].changed_fields2 || new_info_ptr->stack_info[1].signal_strength_changed_fields || forcefully_send_status ||
         new_info_ptr->changed_fields_subs)
    {

#if defined(FEATURE_QSH_EVENT_METRIC)
      /* only send srv metrics/events for srv change ss event */
      if(ss_event == CM_SS_EVENT_SRV_CHANGED)
      {
        /* update the metric CM_QSH_METRIC_SRV_INFO */
      cmdbg_chk_and_update_srv_metrics(req_as_id,
                                       CM_QSH_METRICS_CHG_TYPE_SS_EVENT);

        if(ss != CM_SS_HYBR_1)
        {
        /* update the metric CM_QSH_METRIC_SERVING_CELL_INFO */
          cmdbg_chk_and_update_serving_cell_metrics(req_as_id, ss);
        }

      /* Check and send evt to QSH if needed */
      cmdbg_qsh_chk_and_send_srv_evts(req_as_id);
      }
      else if(ss_event == CM_SS_EVENT_DCH_CELL_ID_RSP)
      {
        /* update the metric CM_QSH_METRIC_SERVING_CELL_INFO */
        cmdbg_chk_and_update_serving_cell_metrics(req_as_id, ss);
      }
#endif

      cmclient_list_ss_event_ntfy_new(ss_event , ss_info_ptr_new);
    }

  
  cmss_update_last_reported_sysmode();


  /* Auto Register */
  if( (cm_get_operator_info(SYS_MODEM_AS_ID_1) != OPERATOR_NULL) &&
      ( (ss_info_ptr->roam_status == SYS_ROAM_STATUS_OFF)||
        ( (ph_ptr->subs_feature_mode[SYS_MODEM_AS_ID_1] == SYS_SUBS_FEATURE_MODE_SGLTE)&&
          (ss_info_ptr->gw_roam_status == SYS_ROAM_STATUS_OFF) )
      )
    )
  {
    cm_auto_reg_ss_event_mdm_cb ( ss_event, ss_info_ptr );
  }
  else
  {
    CM_MSG_HIGH_0 ("Auto Register not triggered.Invalid Opr/In Roaming");
  }

  /* Reset Sys sel pref req id */
  if (ss_event == CM_SS_EVENT_SRV_CHANGED)
  {
    ss_ptr->info.sys_sel_pref_req_id = 0;

    /* Reset is_req_id_pending/2 after sending cm ss event to clients */
    if (ss == CM_SS_MAIN &&
        ss_info_ptr->sys_sel_pref_req_id != CM_DEFAULT_VALUE)
    {
      cmph_reset_req_id_pending();
    }
    else if (ss == CM_SS_HYBR_2 &&
             ss_info_ptr->sys_sel_pref_req_id != CM_DEFAULT_VALUE)
    {
      cmph_reset_req_id_pending2();
    }
    else if (ss == CM_SS_HYBR_3 &&
             ss_info_ptr->sys_sel_pref_req_id != CM_DEFAULT_VALUE)
    {
      cmph_reset_req_id_pending3();
    }
  }
  if (cmph_is_msim() && MAX_AS_IDS > 1 && ss_event == CM_SS_EVENT_SRV_CHANGED)
  {
    CM_MSG_HIGH_2("POST ssevt: info.sys_mode0=%d, info.sys_mode1=%d",
                   ss_ptr->info.sys_mode,
                   ss_ptr->info.gw_sys_mode);
    CM_MSG_HIGH_2("POST ssevt: client rssi0 =%d, client rssi1=%d",
                   ss_ptr->new_srv_avl_info[0].stack_info[0].rssi,
                   ss_ptr->new_srv_avl_info[1].stack_info[0].rssi);
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Deallocate the memory allocated dynamically after sending the ss event. */
  cm_mem_free(ss_info_ptr);
  cm_mem_free(ss_info_ptr_new);
  cm_mem_free(new_info_ptr);
} /* cmss_event() */


/* Note that serving system object functions (as opposed to misc functions)
** take a pointer to a serving system object as their first parameter.
** If their serving system pointer is NOT "const" they are capable of changing
** the serving system state.
*/




#ifdef  FEATURE_CALL_THROTTLE
/*===========================================================================

FUNCTION cmss_orig_thr_reset_tbl_entry

DESCRIPTION
  This function resets a particular entry of the oroignation throttle table

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/

static void cmss_orig_thr_reset_tbl_entry(
  cmss_orig_thr_table_s_type *thr_tbl_ptr,

  cmss_orig_thr_table_q_type *tbl_entry_ptr
    /* The pointer to the particular table entry
    */
 )
{

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

 if(thr_tbl_ptr == NULL || tbl_entry_ptr == NULL)
 {
   sys_err_fatal_null_ptr_exception();
 }
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sys_undefine_sys_id( &(tbl_entry_ptr->cmss_orig_thr_tbl.orig_call_info.sys_id ));

#ifdef FEATURE_Q_NO_SELF_QPTR
   q_delete( &(thr_tbl_ptr->cmss_orig_thr_q), &tbl_entry_ptr->link );
#else
   q_delete( &tbl_entry_ptr->link );
#endif

  cm_mem_free(tbl_entry_ptr);

  return;

} /* cmss_orig_thr_reset_tbl_entry */

#endif  /* FEATURE_CALL_THROTTLE */



/*===========================================================================

FUNCTION cmss_orig_thr_table_reset

DESCRIPTION
  Reset all the cmss_orig_thr_table information


DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_orig_thr_table_reset(

  cmss_orig_thr_table_s_type *cmss_orig_thr_tbl_ptr
    /* Throttle table pointer */

)
/*lint -esym(818,cmss_orig_thr_tbl_ptr)*/
{

  #ifdef  FEATURE_CALL_THROTTLE

  int q_counter = 0;

  cmss_orig_thr_table_q_type  *cur_ptr = NULL;
  cmss_orig_thr_table_q_type  *next_ptr = NULL;   /* Points to next link in Q */

  /*-----------------------------------------------------------------------*/
  if(cmss_orig_thr_tbl_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }
  /*-----------------------------------------------------------------------*/


  q_counter = q_cnt(&(cmss_orig_thr_tbl_ptr->cmss_orig_thr_q));

  if( q_counter > 0)
  {
      // delete all the items from the queue
      cur_ptr = q_check(&(cmss_orig_thr_tbl_ptr->cmss_orig_thr_q));
      if( NULL == cur_ptr )
      {
        sys_err_fatal_null_ptr_exception();
      }

      while((q_counter > 0) && (cur_ptr != NULL))
      {

        next_ptr = q_next(&(cmss_orig_thr_tbl_ptr->cmss_orig_thr_q), &(cur_ptr->link));
        sys_undefine_sys_id( &cur_ptr->cmss_orig_thr_tbl.orig_call_info.sys_id );

#ifdef FEATURE_Q_NO_SELF_QPTR
        q_delete( &(cmss_orig_thr_tbl_ptr->cmss_orig_thr_q), &cur_ptr->link );
#else
        q_delete( &cur_ptr->link );
#endif

        cm_mem_free(cur_ptr);

        q_counter--;
        cur_ptr = next_ptr ;
      } /* end while */
  }

  cmss_orig_thr_tbl_ptr->num_valid_entries = 0;

  #else
  SYS_ARG_NOT_USED(cmss_orig_thr_tbl_ptr);
  #endif  /* FEATURE_CALL_THROTTLE */
  return;

}/* cmss_orig_throttle_table_reset */


#ifdef CM_GW_SUPPORTED
/*===========================================================================

FUNCTION cmss_reset_gwl_signal_status

DESCRIPTION
  Reset all the cmss_gwl_signal_status information


DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_reset_gwl_signal_status(void)
{
  cmss_gwl_signal_status.signal_status_g_main.signal_strength = CMSS_RSSI_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_g_main.ecio = 0xFF; //Same as CMSS_ECIO_VALUE_INVALID_SIGNAL
  cmss_gwl_signal_status.signal_status_g_main.sir  = CMSS_SIR_VALUE_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_g_main.rscp = CMSS_RSCP_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_g_main.use_ecio_for_display  = FALSE;
  cmss_gwl_signal_status.signal_status_g_main.pathloss = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_g_main.avg_cqi_num_sample = 0;
  cmss_gwl_signal_status.signal_status_g_main.avg_cqi_val = 0;
  cmss_gwl_signal_status.signal_status_g_main.bit_error_rate = CMSS_BER_VALUE_NO_SIGNAL;

  cmss_gwl_signal_status.signal_status_g_hybr.signal_strength = CMSS_RSSI_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_g_hybr.ecio = 0xFF; //Same as CMSS_ECIO_VALUE_INVALID_SIGNAL
  cmss_gwl_signal_status.signal_status_g_hybr.sir  = CMSS_SIR_VALUE_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_g_hybr.rscp = CMSS_RSCP_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_g_hybr.use_ecio_for_display  = FALSE;
  cmss_gwl_signal_status.signal_status_g_hybr.pathloss = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_g_hybr.avg_cqi_num_sample = 0;
  cmss_gwl_signal_status.signal_status_g_hybr.avg_cqi_val = 0;
  cmss_gwl_signal_status.signal_status_g_hybr.bit_error_rate = CMSS_BER_VALUE_NO_SIGNAL;

  cmss_gwl_signal_status.signal_status_w.signal_strength = CMSS_RSSI_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_w.ecio = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
  cmss_gwl_signal_status.signal_status_w.sir  = CMSS_SIR_VALUE_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_w.rscp = CMSS_RSCP_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_w.use_ecio_for_display  = FALSE;
  cmss_gwl_signal_status.signal_status_w.pathloss = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_w.avg_cqi_num_sample = 0;
  cmss_gwl_signal_status.signal_status_w.avg_cqi_val = 0;
  cmss_gwl_signal_status.signal_status_w.bit_error_rate = CMSS_BER_VALUE_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_w.eutra_detect_status = SYS_EUTRA_DETECTION_UNKNOWN;
#ifdef FEATURE_CM_LTE
  cmss_gwl_signal_status.signal_status_lte.rssi = CMSS_RSSI_NO_SIGNAL;
  cmss_gwl_signal_status.signal_status_lte.rsrp = 0;
  cmss_gwl_signal_status.signal_status_lte.rsrq = 0;
  cmss_gwl_signal_status.signal_status_lte.sinr_valid = FALSE;
  cmss_gwl_signal_status.signal_status_lte.valid = FALSE;
#endif
} /* cmss_reset_gwl_signal_status */
#endif

/*===========================================================================

FUNCTION cmss_intl_srv_info_reset

DESCRIPTION
  Reset internal service information for the corresponding stack.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_intl_srv_info_reset( sd_ss_e_type ss )
{

  sd_si_info_s_type *intl_srv_info_ptr = cmss_intl_srv_info_ptr(cmph_map_sd_ss_type_to_cm_ss_type(ss));

  intl_srv_info_ptr->srv_status = SYS_SRV_STATUS_NO_SRV;
  intl_srv_info_ptr->is_pref_srv_acq = TRUE;
  intl_srv_info_ptr->is_redir_or_ho = FALSE;
  intl_srv_info_ptr->mode = SYS_SYS_MODE_NONE;
  intl_srv_info_ptr->sys_srv_cap = SYS_SRV_CAPABILITY_NONE;
  intl_srv_info_ptr->srv_domain = SYS_SRV_DOMAIN_NO_SRV;
  intl_srv_info_ptr->bcmcs_srv_status = SYS_BCMCS_SRV_STATUS_NO_SRV;
  intl_srv_info_ptr->cs_srv_status = SYS_SRV_STATUS_NO_SRV;
  intl_srv_info_ptr->is_more_pref_gwl_avail = PRL_GWL_PREFERRED_PREF_NONE;
  intl_srv_info_ptr->extend_srv_info = SYS_EXTEND_SRV_INFO_NONE;
  intl_srv_info_ptr->reg_domain = SYS_REG_DOMAIN_NOT_APPLICABLE;
  intl_srv_info_ptr->is_lte_scanned = FALSE;

} /*cmss_intl_srv_info_reset() */

/*===========================================================================

FUNCTION cmss_reset

DESCRIPTION
  Reset all serving system information


DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none
===========================================================================*/
static void cmss_reset( void )
{
  cmss_s_type           *ss_ptr  =  cmss_ptr();
        /* Point at serving system object to be initialized */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;

  uint8                    stk_id = cmph_ptr()->ss_subs_map[CM_SS_MAIN].stack_id;

  #ifdef FEATURE_HDR_HANDOFF
  /* Initialize CMSS IDM object.
  */
  cmssidm_init();
  #endif // FEATURE_HDR_HANDOFF

  #ifdef CM_GW_SUPPORTED
  cmss_reset_gwl_signal_status();
  #endif

  /*
  ** 1. Initialize SS object
  */
  ss_ptr->bit_err_rate                             = CMSS_BER_VALUE_NO_SIGNAL;
  ss_ptr->no_srv_uptime                            = CMSS_NO_SRV_UPTIME_NONE;
  ss_ptr->main_srv_inform_uptime                   = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
  ss_ptr->main_buffer_srv_uptime                   = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
  ss_ptr->cdma_hold_srv_uptime                     = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
  ss_ptr->hdr_srv_inform_uptime                    = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
  ss_ptr->is_pref_srv_acq                          = TRUE;
  ss_ptr->is_stable_in_svc                         = FALSE;
  ss_ptr->is_redir_or_ho                           = FALSE;
  ss_ptr->ss_main_usable                           = SD_SYS_USABLE_OK;
  ss_ptr->gw_rssi                                  = CMSS_RSSI_NO_SIGNAL;
  ss_ptr->gw_rscp                                  = CMSS_RSCP_NO_SIGNAL;
  ss_ptr->gw_ecio_for_display                      = FALSE;
  ss_ptr->gw_ecio                                  = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
  ss_ptr->gw_pathloss                              = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
  ss_ptr->info.cqi_info.gw_cqi                     = CMSS_CQI_VALUE_NO_SIGNAL;
  ss_ptr->info.cqi_info.num_cqi_samples            = 0;
  ss_ptr->gw_sir                                   = CMSS_SIR_VALUE_NO_SIGNAL;
  ss_ptr->is_colloc                                = FALSE;
  ss_ptr->is_connected_mode_oos                    = FALSE;
  ss_ptr->main_srv_status                          = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->hybr_1_srv_status                        = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->gw_cell_info.cell_id                     = CMSS_INVALID_CELL_ID_INFO;
  ss_ptr->gw_cell_info.emerg_access_status         = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;
  ss_ptr->gw_cell_info.lte_cell_access_status      = SYS_CELL_ACCESS_NONE;
  ss_ptr->cdma_ps_call_bsr_uptime                  = 0;
  
  sys_plmn_undefine_plmn_id( &ss_ptr->gw_cell_info.plmn_id );
  ss_ptr->gw_cell_info.lac_id                      = CMSS_INVALID_LAC_INFO;
  ss_ptr->gw_cell_info.arfcn                       = CMSS_INVALID_ARFCN_INFO;
  ss_ptr->gw_cell_info.bsic                        = CMSS_INVALID_BSIC_INFO;
  ss_ptr->gw_cell_info.psc                         = CMSS_INVALID_PSC_INFO;
  ss_ptr->gw_cell_info.uarfcn_dl                   = CMSS_INVALID_UARFCN_DL_INFO;
  ss_ptr->gw_cell_info.uarfcn_ul                   = CMSS_INVALID_UARFCN_UL_INFO;
  ss_ptr->gw_cell_info.refpn                       = CMSS_INVALID_REFPN_INFO;
  ss_ptr->info.cell_info.earfcn_dl                 = CMSS_INVALID_EARFCN_DL_INFO;
  ss_ptr->info.cell_info.earfcn_ul                 = CMSS_INVALID_EARFCN_UL_INFO;
  ss_ptr->enable_modem_reset                       = FALSE;

  #ifdef FEATURE_HDR_HYBRID
  ss_ptr->hdr_no_srv_uptime                        = CMSS_NO_SRV_UPTIME_NONE;
  ss_ptr->hdr_is_pref_srv_acq                      = TRUE;
  ss_ptr->hdr_is_redir_or_ho                       = FALSE;
  ss_ptr->hybr_hdr_usable                          = SD_SYS_USABLE_OK;
  #endif /* FEATURE_HDR_HYBRID */

  ss_ptr->subnet_mask_len                          = CMSS_MAX_SUBNET_MASK_LEN;

  ss_ptr->hybr_gw_srv_inform_uptime                = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
  ss_ptr->hybr_gw_is_pref_srv_acq                  = TRUE;
  ss_ptr->hybr_gw_srv_status                       = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->hybr_gw_no_srv_uptime                    = CMSS_NO_SRV_UPTIME_NONE;
  ss_ptr->hybr_gw_usable                           = SD_SYS_USABLE_OK;
  ss_ptr->hybr_gw_cell_info.lac_id                 = CMSS_INVALID_LAC_INFO;
  ss_ptr->hybr_gw_cell_info.arfcn                  = CMSS_INVALID_ARFCN_INFO;
  ss_ptr->hybr_gw_cell_info.bsic                   = CMSS_INVALID_BSIC_INFO;
  ss_ptr->hybr_gw_cell_info.psc                    = CMSS_INVALID_PSC_INFO;
  ss_ptr->hybr_gw_cell_info.uarfcn_dl              = CMSS_INVALID_UARFCN_DL_INFO;
  ss_ptr->hybr_gw_cell_info.uarfcn_ul              = CMSS_INVALID_UARFCN_UL_INFO;
  ss_ptr->hybr_gw_cell_info.refpn                  = CMSS_INVALID_REFPN_INFO;
  ss_ptr->hybr_gw_cell_info.emerg_access_status    = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;
  ss_ptr->hybr_gw_cell_info.lte_cell_access_status = SYS_CELL_ACCESS_NONE;
  ss_ptr->hybr_gw_is_connected_mode_oos            = FALSE;
  ss_ptr->hybr_gw_bit_err_rate                     = CMSS_BER_VALUE_NO_SIGNAL;
  ss_ptr->hybr_gw_rssi                             = CMSS_RSSI_NO_SIGNAL;
  ss_ptr->hybr_gw_ecio                             = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
  ss_ptr->hybr_gw_pathloss                         = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
  ss_ptr->hybr_gw_sir                              = CMSS_SIR_VALUE_NO_SIGNAL;
  ss_ptr->hybr_gw_rscp                             = CMSS_RSCP_NO_SIGNAL;
  ss_ptr->hybr_gw_ecio_for_display                 = FALSE;
  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA)|| defined(FEATURE_CM_LTE))
  ss_ptr->hybr_gw_ps_data_stt                      = CM_PS_DATA_STT_NONE;
  ss_ptr->hybr_gw_no_ps_data_uptime                = CMSS_NO_PS_DATA_UPTIME_NONE;
  #endif
  ss_ptr->hybr_gw_last_system_reported             = SYS_SYS_MODE_NO_SRV;
  ss_ptr->hybr_gw_is_pref_srv_acq                  = TRUE;

  ss_ptr->ue_init_ps_data_suspend                  = CM_SS_NONE;
  ss_ptr->ue_init_ps_data_suspend_cause            = CM_SMREG_PS_SIG_REL_REQ_CAUSE_MAX;

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  ss_ptr->hybr_3_gw_srv_inform_uptime                = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
  ss_ptr->hybr_3_gw_is_pref_srv_acq                  = TRUE;
  ss_ptr->hybr_3_gw_srv_status                       = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->hybr_3_gw_no_srv_uptime                    = CMSS_NO_SRV_UPTIME_NONE;
  ss_ptr->hybr_3_gw_usable                           = SD_SYS_USABLE_OK;
  ss_ptr->hybr_3_gw_cell_info.lac_id                 = CMSS_INVALID_LAC_INFO;
  ss_ptr->hybr_3_gw_cell_info.arfcn                  = CMSS_INVALID_ARFCN_INFO;
  ss_ptr->hybr_3_gw_cell_info.bsic                   = CMSS_INVALID_BSIC_INFO;
  ss_ptr->hybr_3_gw_cell_info.psc                    = CMSS_INVALID_PSC_INFO;
  ss_ptr->hybr_3_gw_cell_info.uarfcn_dl              = CMSS_INVALID_UARFCN_DL_INFO;
  ss_ptr->hybr_3_gw_cell_info.uarfcn_ul              = CMSS_INVALID_UARFCN_UL_INFO;
  ss_ptr->hybr_3_gw_cell_info.refpn                  = CMSS_INVALID_REFPN_INFO;
  ss_ptr->hybr_3_gw_cell_info.emerg_access_status    = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;
  ss_ptr->hybr_3_gw_cell_info.lte_cell_access_status = SYS_CELL_ACCESS_NONE;
  ss_ptr->hybr_3_gw_is_connected_mode_oos            = FALSE;
  ss_ptr->hybr_3_gw_bit_err_rate                     = CMSS_BER_VALUE_NO_SIGNAL;
  ss_ptr->hybr_3_gw_rssi                             = CMSS_RSSI_NO_SIGNAL;
  ss_ptr->hybr_3_gw_ecio                             = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
  ss_ptr->hybr_3_gw_pathloss                         = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
  ss_ptr->hybr_3_gw_sir                              = CMSS_SIR_VALUE_NO_SIGNAL;
  ss_ptr->hybr_3_gw_rscp                             = CMSS_RSCP_NO_SIGNAL;
  ss_ptr->hybr_3_gw_ecio_for_display                 = FALSE;
  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA)|| defined(FEATURE_CM_LTE))
  ss_ptr->hybr_3_gw_ps_data_stt                      = CM_PS_DATA_STT_NONE;
  ss_ptr->hybr_3_gw_no_ps_data_uptime                = CMSS_NO_PS_DATA_UPTIME_NONE;
#endif
  ss_ptr->hybr_3_gw_last_system_reported             = SYS_SYS_MODE_NO_SRV;
  ss_ptr->hybr_3_gw_is_pref_srv_acq                  = TRUE;

  ss_ptr->ue_init_ps_data_suspend                  = CM_SS_NONE;
#endif /* FEATURE_MMODE_DUAL_SIM */


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /*
  ** 2. Initialize SS object: info
  */
  ss_ptr->info.changed_fields         = 0;
  ss_ptr->info.changed_fields2        = 0;
  ss_ptr->info.signal_strength_changed_fields = 0;
  ss_ptr->info.srv_status             = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->info.true_srv_status        = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->info.srv_domain             = SYS_SRV_DOMAIN_NO_SRV;
  ss_ptr->info.srv_capability         = SYS_SRV_DOMAIN_NO_SRV;
  ss_ptr->info.sys_mode               = SYS_SYS_MODE_NO_SRV;
  ss_ptr->info.active_band            = SYS_BAND_CLASS_NONE;
  ss_ptr->info.hybrid_active_band     = SYS_BAND_CLASS_NONE;
  ss_ptr->info.active_channel         = 0;
  ss_ptr->info.hybrid_active_channel  = 0;
  ss_ptr->info.roam_status            = SYS_ROAM_STATUS_OFF;
  ss_ptr->info.is_cdma_custom_home    = FALSE;
  ss_ptr->info.is_hdr_custom_home     = FALSE;
  ss_ptr->info.hdr_active_prot        = SYS_ACTIVE_PROT_NONE;
  ss_ptr->info.hdr_personality        = SYS_PERSONALITY_NONE;
  ss_ptr->info.mcc                    = 0;
  ss_ptr->info.latitude               = 0;
  ss_ptr->info.longitude              = 0;
  ss_ptr->info.system_type            = 0;
  sys_undefine_sys_id( &ss_ptr->info.sys_id );
  sys_undefine_sys_id( &ss_ptr->info.hdr_sys_id );
  ss_ptr->info.subnet_mask_len        = CMSS_MAX_SUBNET_MASK_LEN;
  ss_ptr->info.cell_info.cell_id      = CMSS_INVALID_CELL_ID_INFO;
  ss_ptr->info.cell_info.emerg_access_status = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;
  ss_ptr->info.cell_info.lte_cell_access_status = SYS_CELL_ACCESS_NONE;
  sys_plmn_undefine_plmn_id( &ss_ptr->info.cell_info.plmn_id );
  ss_ptr->info.cell_info.lac_id       = CMSS_INVALID_LAC_INFO;
  ss_ptr->info.cell_info.arfcn        = CMSS_INVALID_ARFCN_INFO;
  ss_ptr->info.cell_info.bsic         = CMSS_INVALID_BSIC_INFO;
  ss_ptr->info.cell_info.psc          = CMSS_INVALID_PSC_INFO;
  ss_ptr->info.cell_info.uarfcn_dl    = CMSS_INVALID_UARFCN_DL_INFO;
  ss_ptr->info.cell_info.uarfcn_ul    = CMSS_INVALID_UARFCN_UL_INFO;
  ss_ptr->info.cell_info.refpn        = CMSS_INVALID_REFPN_INFO;
  ss_ptr->info.is_sys_prl_match       = FALSE;
  ss_ptr->info.is_sys_forbidden       = FALSE;
  ss_ptr->info.rssi                   = CMSS_RSSI_NO_SIGNAL;
  ss_ptr->info.ecio                   = CMSS_ECIO_VALUE_NO_SIGNAL;
  ss_ptr->info.gw_ecio                = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
  ss_ptr->info.rssi2                  = CMSS_RSSI2_NO_SIGNAL;
  ss_ptr->info.rscp                   = CMSS_RSCP_NO_SIGNAL;
  ss_ptr->info.ecio_for_display       = FALSE;
  ss_ptr->info.io                     = CMSS_IO_VALUE_NO_SIGNAL;
  ss_ptr->info.sinr                   = CMSS_SINR_VALUE_NO_SIGNAL;
  ss_ptr->info.pathloss               = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
  ss_ptr->info.sir                    = CMSS_SIR_VALUE_NO_SIGNAL;
  ss_ptr->info.psist                  = CM_PSIST_LOW;
  ss_ptr->info.is_csfb_call_active    = FALSE;
  ss_ptr->info.ps_data_suspend        = FALSE;
  ss_ptr->info.hdr_rssi               = CMSS_RSSI_NO_SIGNAL;
  ss_ptr->info.hdr_hybrid             = FALSE;
  ss_ptr->info.hdr_ecio               = CMSS_ECIO_VALUE_NO_SIGNAL;
  ss_ptr->info.hdr_io                 = CMSS_IO_VALUE_NO_SIGNAL;
  ss_ptr->info.hdr_sinr               = CMSS_SINR_VALUE_NO_SIGNAL;
  ss_ptr->info.ps_data_suspend        = FALSE;
  ss_ptr->info.hdr_thr_status.ss_thr_status  = FALSE;
  ss_ptr->info.hdr_thr_status.thr_uptime     = 0;
  ss_ptr->info.hdr_thr_status.idx            = 0;
  ss_ptr->info.hdr_thr_status.call_status    = CM_SS_ORIG_THR_REASON_NONE;
  ss_ptr->info.main_thr_status.ss_thr_status = FALSE;
  ss_ptr->info.main_thr_status.thr_uptime    = 0;
  ss_ptr->info.main_thr_status.idx           = 0;
  ss_ptr->info.main_thr_status.call_status   = CM_SS_ORIG_THR_REASON_NONE;
  ss_ptr->info.hdr_packet_err_rate    = CMSS_HDR_PER_INVALID;
  ss_ptr->info.frame_err_rate         = CMSS_FER_INVALID;
  #ifdef FEATURE_HDR_HANDOFF
  ss_ptr->info.prev_idle_digital_mode = cmssidm_get_prev_idm();
  ss_ptr->info.cur_idle_digital_mode  = cmssidm_get_curr_idm();
  #endif // FEATURE_HDR_HANDOFF
  ss_ptr->info.hdr_srv_status         = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->info.hdr_roam_status        = SYS_ROAM_STATUS_OFF;
  ss_ptr->info.hdr_ln_status          = SYS_HDR_LOCATION_NOTIFICATION_STATUS_NONE;
  ss_ptr->info.cipher_domain          = SYS_SRV_DOMAIN_NO_SRV;
  ss_ptr->info.cell_srv_ind.hs_call_status = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
  ss_ptr->info.cell_srv_ind.hs_ind    = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
  ss_ptr->info.cell_srv_ind.dtm_supp  = SYS_DTM_SUPPORT_NOT_AVAIL;
  ss_ptr->info.cell_srv_ind.egprs_supp= SYS_EGPRS_SUPPORT_NOT_AVAIL;
  ss_ptr->is_hdr_session_open         = FALSE;
  ss_ptr->info.cdma_reg_prd           = 0;
  ss_ptr->info.height                 = 0;
  ss_ptr->info.horiz_uncertainty      = 0;
  ss_ptr->info.vert_uncertainty       = 0;

  ss_ptr->info.geo_sys_idx            = 0xFFFF;
  ss_ptr->info.bsr_in_progress        = FALSE;
  ss_ptr->dch_cell_info_flgs          = 0;

  ss_ptr->info.rsrp                   = 0;
  ss_ptr->info.rsrq                   = 0;
  ss_ptr->info.lac                    = CMSS_INVALID_LAC_INFO;
  ss_ptr->info.tac                    = 0;
  ss_ptr->info.rac_or_mme_code        = 0;
  ss_ptr->info.eutra_detect_status    = SYS_EUTRA_DETECTION_UNKNOWN;
  ss_ptr->info.available_plmn_type    = SYS_REG_DOMAIN_NOT_APPLICABLE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Initialize the Hybr GW SS Info
  */

  ss_ptr->info.hybr_gw_changed_fields    = 0;
  ss_ptr->info.is_main_operational       = FALSE;
  ss_ptr->info.asubs_id                  = SYS_MODEM_AS_ID_NONE;
  ss_ptr->info.is_hybr_gw_operational    = FALSE;
  ss_ptr->info.gw_asubs_id               = SYS_MODEM_AS_ID_NONE;
  ss_ptr->info.gw_is_sys_prl_match       = FALSE;
  ss_ptr->info.gw_is_sys_forbidden       = FALSE;
  ss_ptr->info.gw_rssi                   = CMSS_RSSI_NO_SIGNAL;
  ss_ptr->info.gw_rssi2                  = CMSS_RSSI2_NO_SIGNAL;
  ss_ptr->info.gw_rscp                   = CMSS_RSCP_NO_SIGNAL;
  ss_ptr->info.gw2_ecio                  = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
  ss_ptr->info.gw_ecio_for_display       = FALSE;
  ss_ptr->info.gw_io                     = CMSS_IO_VALUE_NO_SIGNAL;
  ss_ptr->info.gw_pathloss               = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
  ss_ptr->info.gw_sir                    = CMSS_SIR_VALUE_NO_SIGNAL;
  ss_ptr->info.gw_ps_data_suspend        = FALSE;
  ss_ptr->info.gw_sinr                   = CMSS_SINR_VALUE_NO_SIGNAL;
  ss_ptr->info.gw_srv_status             = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->info.true_gw_srv_status        = SYS_SRV_STATUS_NO_SRV;
  ss_ptr->info.gw_srv_domain             = SYS_SRV_DOMAIN_NO_SRV;
  ss_ptr->info.gw_srv_capability         = SYS_SRV_DOMAIN_NO_SRV;
  ss_ptr->info.gw_sys_mode               = SYS_SYS_MODE_NO_SRV;
  ss_ptr->info.gw_active_band            = SYS_BAND_CLASS_NONE;
  ss_ptr->info.gw_active_channel         = 0;
  ss_ptr->info.gw_roam_status            = SYS_ROAM_STATUS_OFF;
  sys_undefine_sys_id( &ss_ptr->info.gw_sys_id );
  ss_ptr->hybr_gw_is_pref_srv_acq         = TRUE;
  ss_ptr->info.gw_cell_info.cell_id      = CMSS_INVALID_CELL_ID_INFO;
  ss_ptr->info.gw_cell_info.emerg_access_status = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;
  ss_ptr->info.gw_cell_info.lte_cell_access_status = SYS_CELL_ACCESS_NONE;
  sys_plmn_undefine_plmn_id( &ss_ptr->info.gw_cell_info.plmn_id );
  ss_ptr->info.gw_cell_info.lac_id       = CMSS_INVALID_LAC_INFO;
  ss_ptr->info.gw_cell_info.arfcn        = CMSS_INVALID_ARFCN_INFO;
  ss_ptr->info.gw_cell_info.bsic         = CMSS_INVALID_BSIC_INFO;
  ss_ptr->info.gw_cell_info.psc          = CMSS_INVALID_PSC_INFO;
  ss_ptr->info.gw_cell_info.uarfcn_dl   = CMSS_INVALID_UARFCN_DL_INFO;
  ss_ptr->info.gw_cell_info.uarfcn_ul    = CMSS_INVALID_UARFCN_UL_INFO;
  ss_ptr->info.gw_cell_info.refpn        = CMSS_INVALID_REFPN_INFO;

  ss_ptr->info.gw_mode_info.gw_info.bit_err_rate           = CMSS_BER_VALUE_NO_SIGNAL;
  ss_ptr->info.gw_mode_info.gw_info.sim_state              = SYS_SIM_STATE_NOT_AVAILABLE;
  ss_ptr->info.gw_mode_info.gw_info.plmn_forbidden         = FALSE;
  ss_ptr->info.gwl_lac                   = CMSS_INVALID_LAC_INFO;
  ss_ptr->info.gwl_tac                   = 0;
  ss_ptr->info.gwl_rac_or_mme_code       = 0;

  #ifdef CM_GW_SUPPORTED
  #if (!defined(FEATURE_MMODE_CDMA_800) && !defined(FEATURE_MMODE_CDMA_1900))
  cm_ss_init_mm_information( &ss_ptr->info.gw_mode_info.gw_info.mm_information );
  cm_ss_init_mm_information( &ss_ptr->info.gw_mode_info.gw_info.prev_mm_information );
  #endif
  #endif

  ss_ptr->info.gwl_rsrp                  = 0;
  ss_ptr->info.gwl_rsrq                  = 0;

  ss_ptr->info.gw_cell_srv_ind.hs_ind    = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
  ss_ptr->info.gw_cell_srv_ind.dtm_supp  = SYS_DTM_SUPPORT_NOT_AVAIL;
  ss_ptr->info.gw_cell_srv_ind.egprs_supp      = SYS_EGPRS_SUPPORT_NOT_AVAIL;
  ss_ptr->info.gw_cell_srv_ind.hs_call_status      = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;

  cm_ss_init_reg_reject_info( CM_SS_HYBR_2, &ss_ptr->info.gw_reg_reject_info );

  ss_ptr->info.gw_cipher_domain          = SYS_SRV_DOMAIN_NO_SRV;


    /* Initialize the Hybr3 GW SS Info
    */

    ss_ptr->info.gw3_changed_fields    = 0;
    ss_ptr->info.is_main_operational  = FALSE;
    ss_ptr->info.asubs_id       = SYS_MODEM_AS_ID_NONE;
    ss_ptr->info.is_gw3_operational    = FALSE;
    ss_ptr->info.gw3_asubs_id    = SYS_MODEM_AS_ID_NONE;
    ss_ptr->info.gw3_is_sys_prl_match  = FALSE;
    ss_ptr->info.gw3_is_sys_forbidden  = FALSE;
    ss_ptr->info.gw3_rssi      = CMSS_RSSI_NO_SIGNAL;
    ss_ptr->info.gw3_rssi2             = CMSS_RSSI2_NO_SIGNAL;
    ss_ptr->info.gw3_rscp      = CMSS_RSCP_NO_SIGNAL;
    ss_ptr->info.gw3_ecio        = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
    ss_ptr->info.gw3_ecio_for_display  = FALSE;
    ss_ptr->info.gw3_io      = CMSS_IO_VALUE_NO_SIGNAL;
    ss_ptr->info.gw3_pathloss    = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
    ss_ptr->info.gw3_sir             = CMSS_SIR_VALUE_NO_SIGNAL;
    ss_ptr->info.gw3_ps_data_suspend   = FALSE;
    ss_ptr->info.gw3_sinr      = CMSS_SINR_VALUE_NO_SIGNAL;
    ss_ptr->info.gw3_srv_status    = SYS_SRV_STATUS_NO_SRV;
    ss_ptr->info.true_gw3_srv_status   = SYS_SRV_STATUS_NO_SRV;
    ss_ptr->info.gw3_srv_domain    = SYS_SRV_DOMAIN_NO_SRV;
    ss_ptr->info.gw3_srv_capability    = SYS_SRV_DOMAIN_NO_SRV;
    ss_ptr->info.gw3_sys_mode    = SYS_SYS_MODE_NO_SRV;
    ss_ptr->info.gw3_active_band           = SYS_BAND_CLASS_NONE;
    ss_ptr->info.gw3_active_channel    = 0;
    ss_ptr->info.gw3_roam_status     = SYS_ROAM_STATUS_OFF;
    ss_ptr->info.gw3_cell_info.emerg_access_status = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;
    ss_ptr->info.gw3_cell_info.lte_cell_access_status = SYS_CELL_ACCESS_NONE;
    sys_undefine_sys_id( &ss_ptr->info.gw3_sys_id );
    ss_ptr->hybr_3_gw_is_pref_srv_acq  = TRUE;
    ss_ptr->info.gw3_cell_info.cell_id   = CMSS_INVALID_CELL_ID_INFO;
    sys_plmn_undefine_plmn_id( &ss_ptr->info.gw3_cell_info.plmn_id );
    ss_ptr->info.gw3_cell_info.lac_id  = CMSS_INVALID_LAC_INFO;
    ss_ptr->info.gw3_cell_info.arfcn   = CMSS_INVALID_ARFCN_INFO;
    ss_ptr->info.gw3_cell_info.bsic    = CMSS_INVALID_BSIC_INFO;
    ss_ptr->info.gw3_cell_info.psc     = CMSS_INVALID_PSC_INFO;
    ss_ptr->info.gw3_cell_info.uarfcn_dl   = CMSS_INVALID_UARFCN_DL_INFO;
    ss_ptr->info.gw3_cell_info.uarfcn_ul   = CMSS_INVALID_UARFCN_UL_INFO;
    ss_ptr->info.gw3_cell_info.refpn   = CMSS_INVALID_REFPN_INFO;
    ss_ptr->info.gw3_mode_info.gw_info.bit_err_rate   = CMSS_BER_VALUE_NO_SIGNAL;
    ss_ptr->info.gw3_mode_info.gw_info.sim_state    = SYS_SIM_STATE_NOT_AVAILABLE;
    ss_ptr->info.gw3_mode_info.gw_info.plmn_forbidden       = FALSE;

    ss_ptr->info.gw3_lac                   = CMSS_INVALID_LAC_INFO;
    ss_ptr->info.gw3_tac                   = 0;
    ss_ptr->info.gw3_rac_or_mme_code       = 0;
  #ifdef CM_GW_SUPPORTED
  #if (!defined(FEATURE_MMODE_CDMA_800) && !defined(FEATURE_MMODE_CDMA_1900))
    cm_ss_init_mm_information( &ss_ptr->info.gw3_mode_info.gw_info.mm_information );
  #endif
  #endif

    ss_ptr->info.gw3_rsrp                  = 0;
    ss_ptr->info.gw3_rsrq                  = 0;

    ss_ptr->info.gw3_cell_srv_ind.hs_ind   = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
    ss_ptr->info.gw3_cell_srv_ind.dtm_supp  = SYS_DTM_SUPPORT_NOT_AVAIL;
    ss_ptr->info.gw3_cell_srv_ind.egprs_supp     = SYS_EGPRS_SUPPORT_NOT_AVAIL;
    ss_ptr->info.gw3_cell_srv_ind.hs_call_status     = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;

    cm_ss_init_reg_reject_info( CM_SS_HYBR_3, &ss_ptr->info.gw3_reg_reject_info );

    ss_ptr->info.gw3_cipher_domain         = SYS_SRV_DOMAIN_NO_SRV;


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Initialize UMA GAN information
  */
  ss_ptr->info.gan_info.gan_state       = SYS_GW_GAN_STATE_NONE;

  ss_ptr->info.gan_info.gan_conn_status = SYS_GW_GAN_CONN_STATUS_NONE;

  ss_ptr->info.gan_info.gan_sig_chan_status
                                        = SYS_GW_GAN_SIG_CHAN_STATUS_NONE;

  memset(&(ss_ptr->info.gan_info.gan_mode_display), 0,
         sizeof(sys_gw_gan_mode_display_s_type));

  memset(&(ss_ptr->info.gan_info.gan_error), 0,
         sizeof(sys_gw_gan_error_s_type));

  /*
  ** 3.1 Initialize SS object: mode info - GW only build
  */
  #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  #if (!defined(FEATURE_MMODE_CDMA_800) && !defined(FEATURE_MMODE_CDMA_1900))
  ss_ptr->info.mode_info.gw_info.bit_err_rate           = CMSS_BER_VALUE_NO_SIGNAL;
  ss_ptr->info.mode_info.gw_info.sim_state              = SYS_SIM_STATE_NOT_AVAILABLE;
  ss_ptr->info.mode_info.gw_info.plmn_forbidden         = FALSE;

  cm_ss_init_mm_information( &ss_ptr->info.mode_info.gw_info.mm_information );
  cm_ss_init_mm_information( &ss_ptr->info.mode_info.gw_info.prev_mm_information );

  #endif /* (!defined(FEATURE_MMODE_CDMA_800) && !defined(FEATURE_MMODE_CDMA_1900)) */
  #endif /* defined CM_GW_SUPPORTED || defined(FEATURE_CM_LTE)*/

  /*
  ** 3.2 Initialize SS object: mode info - CDMA only build
  */
  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  #if ( !defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) )
  ss_ptr->info.mode_info.cdma_info.band_class      = SYS_BAND_CLASS_NONE;
  ss_ptr->info.mode_info.cdma_info.block_or_system = SYS_BLKSYS_NONE;
  ss_ptr->info.mode_info.cdma_info.reg_zone        = CM_SS_REG_ZONE_NONE;
  ss_ptr->info.mode_info.cdma_info.packet_zone     = CM_SS_PACKET_ZONE_NONE;
  ss_ptr->info.mode_info.cdma_info.bs_p_rev        = CM_SS_BS_P_REV_NONE;
  ss_ptr->info.mode_info.cdma_info.p_rev_in_use    = CM_SS_P_REV_IN_USE_NONE;
  ss_ptr->info.mode_info.cdma_info.is_registered   = FALSE;
  ss_ptr->info.mode_info.cdma_info.ccs_supported   = FALSE;
  ss_ptr->info.mode_info.cdma_info.uz_id           = CM_INVALID_UZID;
  ss_ptr->info.mode_info.cdma_info.base_id         = 0;
  ss_ptr->info.mode_info.cdma_info.base_lat        = 0;
  ss_ptr->info.mode_info.cdma_info.base_long       = 0;
  ss_ptr->info.mode_info.cdma_info.srch_win_n      = 0;
  ss_ptr->info.mode_info.cdma_info.time_info.sys_mode = SYS_SYS_MODE_NO_SRV;
  #endif /* ( !defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) ) */
  #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

  /*
  ** 3.3 Initialize SS object: mode info - MM (GW + CDMA) build
  */
  #ifdef CM_GW_SUPPORTED
  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  (void) memset( &ss_ptr->info.mode_info, 0, sizeof( cm_ss_info_u_type ) );
  ss_ptr->info.mode_info.gw_info.bit_err_rate   = CMSS_BER_VALUE_NO_SIGNAL;
  #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */
  #endif /* defined CM_GW_SUPPORTED */

  #ifdef FEATURE_BCMCS
  ss_ptr->info.hybr_hdr_bcmcs_srv_supported = FALSE;
  ss_ptr->info.hybr_hdr_bcmcs_srv_status    = SYS_BCMCS_SRV_STATUS_NO_SRV;

  ss_ptr->info.ss_main_bcmcs_srv_supported  = FALSE;
  ss_ptr->info.ss_main_bcmcs_srv_status     = SYS_BCMCS_SRV_STATUS_NO_SRV;
  #endif /* FEATURE_BCMCS */

  /* Initalize measurement response info */
  ss_ptr->info.meas_resp.sys_mode                   = SYS_SYS_MODE_NONE;
  ss_ptr->info.meas_resp.info.hdr_resp.meas_status  = CM_SS_MEAS_STATUS_NONE;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Initialize srv_avail_info object
  */


  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA)|| defined(FEATURE_CM_LTE))
  /* Initialize ps data state
  */
  ss_ptr->ps_data_stt                       = CM_PS_DATA_STT_NONE;
  ss_ptr->no_ps_data_uptime                 = CMSS_NO_PS_DATA_UPTIME_NONE;
  #endif /* FEATURE_PS_DORMANT_PWR_SAVE */



  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Initialize the Hybr GW SS srv avail Info
  */

  subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) ;

  stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_2);

  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }
  

  cm_ss_init_reg_reject_info( CM_SS_HYBR_2,
                              &ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].reg_reject_info );


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /* Initialize the Hybr3 GW SS srv avail Info
  */

   #if defined(FEATURE_MMODE_TRIPLE_SIM)|| defined(FEATURE_MMODE_SXLTE_G)


   if(cmph_is_tsts() || cmph_is_sxlte())
   {

  subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_3) ;

  stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_3);

  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }

  cm_ss_init_reg_reject_info( CM_SS_HYBR_3,
                              &ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].reg_reject_info );
   }
  #endif




/********************************************************************************************************/
#if defined(FEATURE_TRIPLE_SIM)
for(subId =SYS_MODEM_AS_ID_1 ; subId <=SYS_MODEM_AS_ID_3 ; subId++)
#else
for(subId =SYS_MODEM_AS_ID_1 ; subId <=SYS_MODEM_AS_ID_2 ; subId++)
#endif
  {
    for(stk_id =0 ; stk_id <= 1; stk_id++ )
    {
      ss_ptr->new_srv_avl_info[subId].asubs_id = SYS_MODEM_AS_ID_NONE ;
      ss_ptr->new_srv_avl_info[subId].changed_fields_subs    = 0 ;
      
      
      ss_ptr->new_srv_avl_info[subId].number_of_stacks       = 0 ;
      ss_ptr->new_srv_avl_info[subId].bsr_in_progress        = FALSE;
      ss_ptr->new_srv_avl_info[subId].eutra_detect_status    = SYS_EUTRA_DETECTION_UNKNOWN;
      ss_ptr->new_srv_avl_info[subId].gan_info.gan_state           =
                                                          SYS_GW_GAN_STATE_NONE;
      ss_ptr->new_srv_avl_info[subId].target_rat = SYS_SYS_MODE_NONE;
      ss_ptr->new_srv_avl_info[subId].gan_info.gan_conn_status     =
                                                    SYS_GW_GAN_CONN_STATUS_NONE;
      
      ss_ptr->new_srv_avl_info[subId].gan_info.gan_sig_chan_status =
                                                SYS_GW_GAN_SIG_CHAN_STATUS_NONE;
      
      memset(&(ss_ptr->new_srv_avl_info[subId].gan_info.gan_mode_display), 0,
             sizeof(sys_gw_gan_mode_display_s_type));
      
      memset(&(ss_ptr->new_srv_avl_info[subId].gan_info.gan_error), 0,
             sizeof(sys_gw_gan_error_s_type));
      
      ss_ptr->new_srv_avl_info[subId].meas_resp.sys_mode             = SYS_SYS_MODE_NONE;
      ss_ptr->new_srv_avl_info[subId].meas_resp.info.hdr_resp.meas_status  =
                                                         CM_SS_MEAS_STATUS_NONE;
      
      ss_ptr->new_srv_avl_info[subId].voice_domain           = SYS_CM_DOMAIN_SEL_DOMAIN_MAX;
      ss_ptr->new_srv_avl_info[subId].sms_domain             = SYS_CM_DOMAIN_SEL_DOMAIN_MAX;
      
      ss_ptr->new_srv_avl_info[subId].div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
      ss_ptr->new_srv_avl_info[subId].def_roam_ind = SYS_ROAM_STATUS_OFF;
      
      ss_ptr->new_srv_avl_info[subId].ps_data_suspend        = FALSE;
      /*********************************************************************************/
      #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
      #if ( !defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) )
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.cdma_info.time_info.sys_mode = SYS_SYS_MODE_NO_SRV;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.cdma_info.base_id    = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.cdma_info.base_lat   = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.cdma_info.base_long  = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.cdma_info.srch_win_n = 0;
      
      #endif /* ( !defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) ) */
      #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */
      
      
      
      #ifdef CM_GW_SUPPORTED
      #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
        (void) memset( &ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info, 0,
                                          sizeof( cm_ss_info_u_type ) );
      
      
      #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */
      #endif /* defined CM_GW_SUPPORTED */
      
      
      /**************************************************************************************/
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].changed_fields        = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].changed_fields2        = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].signal_strength_changed_fields        = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].is_operational       = FALSE;
      
      #ifdef FEATURE_BCMCS
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].bcmcs_srv_supported = FALSE;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].bcmcs_srv_status    = SYS_BCMCS_SRV_STATUS_NO_SRV;
      
      #endif /* FEATURE_BCMCS */
      
      
      
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status         = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].true_srv_status    = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode           = SYS_SYS_MODE_NO_SRV;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].roam_status        = SYS_ROAM_STATUS_OFF;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_domain         = SYS_SRV_DOMAIN_NO_SRV;  
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_capability     = SYS_SRV_DOMAIN_NO_SRV;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].active_band        = SYS_BAND_CLASS_NONE;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].active_channel         = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.gw_info.bit_err_rate
                                                = CMSS_BER_VALUE_NO_SIGNAL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.gw_info.sim_state              = SYS_SIM_STATE_NOT_AVAILABLE;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.gw_info.plmn_forbidden         = FALSE;
      
      #ifdef CM_GW_SUPPORTED
      #if (!defined(FEATURE_MMODE_CDMA_800) && !defined(FEATURE_MMODE_CDMA_1900))
      cm_ss_init_mm_information( &ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.gw_info.mm_information );
      #endif
      #endif
      
      sys_undefine_sys_id( &ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_id );
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].is_sys_prl_match   = FALSE;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].is_sys_forbidden   = FALSE;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rssi               = CMSS_RSSI_NO_SIGNAL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio               = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
      if(stk_id == 1)
      {
        ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio               = CMSS_ECIO_VALUE_NO_SIGNAL;
      }
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].io                 = CMSS_IO_VALUE_NO_SIGNAL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sinr               = CMSS_SINR_VALUE_NO_SIGNAL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].pathloss               = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sir                    = CMSS_SIR_VALUE_NO_SIGNAL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rssi2                  = CMSS_RSSI2_NO_SIGNAL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].rscp                   = CMSS_RSCP_NO_SIGNAL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cqi_info.gw_cqi                     = CMSS_CQI_VALUE_NO_SIGNAL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cqi_info.num_cqi_samples            = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].ecio_for_display       = FALSE;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].thr_status.ss_thr_status  = FALSE;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].thr_status.thr_uptime     = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].thr_status.idx            = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].thr_status.call_status = CM_SS_ORIG_THR_REASON_NONE;
      
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.cell_id  = CMSS_INVALID_CELL_ID_INFO;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.emerg_access_status = SYS_LTE_EMERG_ACCESS_UNAVAILABLE;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.lte_cell_access_status = SYS_CELL_ACCESS_NONE;
      sys_plmn_undefine_plmn_id( &ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.plmn_id );
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.lac_id   = CMSS_INVALID_LAC_INFO;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.arfcn     = CMSS_INVALID_ARFCN_INFO;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.bsic      = CMSS_INVALID_BSIC_INFO;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.psc       = CMSS_INVALID_PSC_INFO;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.uarfcn_dl = CMSS_INVALID_UARFCN_DL_INFO;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.uarfcn_ul = CMSS_INVALID_UARFCN_UL_INFO;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_info.refpn     = CMSS_INVALID_REFPN_INFO;
      
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_srv_ind.egprs_supp      = SYS_EGPRS_SUPPORT_NOT_AVAIL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_srv_ind.hs_call_status =
                                             SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_srv_ind.hs_ind    = SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cell_srv_ind.dtm_supp  = SYS_DTM_SUPPORT_NOT_AVAIL;
      
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].reg_reject_info.reject_cause = 0;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].reg_reject_info.reject_srv_domain = SYS_SRV_DOMAIN_NONE;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].reg_reject_info.csg_id = SYS_CSG_ID_INVALID;
      sys_plmn_undefine_plmn_id(&(ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].reg_reject_info.plmn));
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].cipher_domain          = SYS_SRV_DOMAIN_NO_SRV;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].geo_sys_idx            = 0xFFFF;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].lte_ims_voice_avail = FALSE;
      ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].lte_ims_emerg_avail = SYS_IMS_LTE_EMERG_SUPP_UNKNOWN;
    }
  }

/*********************************************************************************************************/

  ss_ptr->last_system_reported = SYS_SYS_MODE_NO_SRV;
  /* Initialize the cmss_orig_thr_table
  */
  cmss_orig_thr_table_reset( ss_ptr->cmss_orig_thr_tbl_ptr );

  memset(&ss_ptr->info.prl_3gpp2_mcc, 0, sizeof(sys_plmn_mcc_list));

  memset(&ss_ptr->info.prl_hdr_mcc, 0, sizeof(sys_plmn_mcc_list));

  /* current country */
  ss_ptr->current_hdr_mcc = CM_INVALID_MOBILE_COUNTRY_CODE;

  /* current country */
  ss_ptr->info.current_mcc = CM_INVALID_MOBILE_COUNTRY_CODE;

  /* Home country */
  ss_ptr->info.home_mcc    = CM_INVALID_MOBILE_COUNTRY_CODE;

  /* Clear the sid to mcc user table */
  cmss_get_sid_mcc_assoc_ptr()->sid_mcc_tbl_len = 0;

  /* Registration reject information */
  
  subId = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;

  stk_id = cmph_ptr()->ss_subs_map[CM_SS_MAIN].stack_id;

  
  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }
  

  cm_ss_init_reg_reject_info( CM_SS_MAIN, &ss_ptr->info.reg_reject_info );
  cm_ss_init_reg_reject_info( CM_SS_MAIN, &ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].reg_reject_info );

  /* Initialize default roaming indicator */
  ss_ptr->info.def_roam_ind = SYS_ROAM_STATUS_OFF;

  /* Store the values modified in stats object and inform clients */

  *(&(cmstats_ptr()->prm.cm_info.sys_sel_info.sel_sys)) = *(&(ss_ptr->info.sys_id));

  cmstats_ptr()->prm.cm_info.sys_sel_info.roam_ind =
                    (sys_stat_roam_e_type) ss_ptr->info.roam_status;

  cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK |
                                       SYS_CM_SYS_SEL_INFO_BIT_MASK);

  #ifdef FEATURE_DOMAIN_SELECTION
  ss_ptr->info.voice_support_on_lte = FALSE;
  #endif
  ss_ptr->info.lte_ims_voice_avail = FALSE;

  /* default value to LTE IMS emerg availability*/
  ss_ptr->info.lte_ims_emerg_avail = SYS_IMS_LTE_EMERG_SUPP_UNKNOWN;

  ss_ptr->info.voice_domain        = SYS_CM_DOMAIN_SEL_DOMAIN_MAX;
  ss_ptr->info.sms_domain          = SYS_CM_DOMAIN_SEL_DOMAIN_MAX;

  /* Initialize default cell access info */
  ss_ptr->info.cell_access_info.cs_bar_status = SYS_CELL_ACCESS_NONE;
  ss_ptr->info.cell_access_info.ps_bar_status = SYS_CELL_ACCESS_NONE;

   ss_ptr->info.gw_cell_access_info.cs_bar_status = SYS_CELL_ACCESS_NONE;
  ss_ptr->info.gw_cell_access_info.ps_bar_status = SYS_CELL_ACCESS_NONE;

  ss_ptr->info.gw3_cell_access_info.cs_bar_status = SYS_CELL_ACCESS_NONE;
  ss_ptr->info.gw3_cell_access_info.ps_bar_status = SYS_CELL_ACCESS_NONE;

  ss_ptr->info.target_rat = SYS_SYS_MODE_NONE;

  /* Reset div_duplex */
  ss_ptr->main_div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
  ss_ptr->hybr_gw_div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
  ss_ptr->info.div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
  ss_ptr->gw3_div_duplex = SYS_DIV_DUPLEX_UNKNOWN;

  /* Initialize irat_ctxt_target_rat */
  ss_ptr->info.irat_ctxt_target_rat = SYS_SYS_MODE_NONE;
  ss_ptr->info.gwl_irat_asubs_id    = SYS_MODEM_AS_ID_NONE;

  /*Reset embms info */
  ss_ptr->info.embms_info.embms_coverage_status = SYS_EMBMS_COVERAGE_STATUS_INVALID;
  ss_ptr->info.embms_info.trace_id = CMSS_EMBMS_TRACE_ID_NONE;
  ss_ptr->info.gwl_embms_info.embms_coverage_status = SYS_EMBMS_COVERAGE_STATUS_INVALID;
  ss_ptr->info.gwl_embms_info.trace_id = CMSS_EMBMS_TRACE_ID_NONE;
  ss_ptr->info.gw3_embms_info.embms_coverage_status = SYS_EMBMS_COVERAGE_STATUS_INVALID;
  ss_ptr->info.gw3_embms_info.trace_id = CMSS_EMBMS_TRACE_ID_NONE;

  /* Initialize/clear off CSG information */
  ss_ptr->info.csg_info.csg_id = SYS_CSG_ID_INVALID;
  memset(&(ss_ptr->info.csg_info.hnb_name),0,sizeof(sys_home_nodeb_name_type));

  /* Initialize cmss to notify ui base on its timeline */
  ss_ptr->skip_srv_ind_update = FALSE;

} /* cmss_reset() */

/*===========================================================================

FUNCTION  cmss_convert_mcc_ota_to_hpcd

DESCRIPTION
  Converts MCC from OTA format to Handset based Plus Code Dialing ( HPCD).

DEPENDENCIES

RETURN VALUE
   MCC in PRL/HPCD format

SIDE EFFECTS

===========================================================================*/
static cm_country_code_type cmss_convert_mcc_ota_to_hpcd(

    cm_country_code_type  ota_mcc
      /* OTA MCC that needs to converted to HPCD */
)
{
  /* Convert MCC from OTA format to HPCD same as PRL format MCC.
  ** As defined in IS-2000 section 2.3.1.3
  **  1. Represent the 3-digit Mobile Country Code as D1 D2 D3
  **     with the digit equal to zero being given the value of ten.
  **  2. Compute 100 * D1 + 10 * D2 + D3 - 111.
  **  3. Convert the result in step (2) to binary by
  ** a standard decimal-to-binary conversion as described in Table 2.3.1.1-1.
  ** So the follwing code is to reverse this processing
  */

  cm_country_code_type prl_mcc;
  byte                 conv_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };

  if (!BETWEEN(ota_mcc, 0, CM_MAX_MOBILE_COUNTRY_CODE_VAL))
  {
    return CM_INVALID_MOBILE_COUNTRY_CODE;
  }

  prl_mcc =  conv_arr[ ota_mcc%10 ];
  ota_mcc /= 10;
  prl_mcc += conv_arr[ ota_mcc%10 ] * 10;
  ota_mcc /= 10;
  prl_mcc += conv_arr[ ota_mcc%10 ] * 100;

  CM_MSG_HIGH_2 ("OTA MCC = %d  PRL MCC=%d", ota_mcc, prl_mcc);

  return prl_mcc;
}

/*===========================================================================

FUNCTION cmss_update_home_mcc

DESCRIPTION
  Updates home mcc either from NV_HOME_MCC_I or from NV_IMSI_MCC_I.


DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_home_mcc(void)
{
  nv_item_type *nv_item_ptr;
  cmss_s_type  *ss_ptr = cmss_ptr();

  nv_item_ptr = (nv_item_type*) cm_mem_malloc(sizeof(cmnv_data_s_type));

  /* Read Home CC and user provided sid to
  ** country code mapping from NV
  */
  cmnv_read_wait (NV_HOME_MCC_I, nv_item_ptr);
  ss_ptr->info.home_mcc = nv_item_ptr->home_mcc;

  /* If home_mcc is not in range make it invalid
  ** !!! UNIFY THESE VALUES WITH SD...Create it in sys.h !!!!!
  */
  if (!BETWEEN(nv_item_ptr->home_mcc, 0, CM_MAX_MOBILE_COUNTRY_CODE_VAL))
  {
    /* Read from NV the current NAM selection.
    */
    cmnv_read_wait( NV_CURR_NAM_I, nv_item_ptr );
    nv_item_ptr->imsi_mcc.nam = (byte)nv_item_ptr->curr_nam;

    CM_MSG_HIGH_1 (" curr_nam = %d", nv_item_ptr->imsi_mcc.nam);
    /* Read from NV the IMSI MCC.
    */
    cmnv_read_wait (NV_IMSI_MCC_I, nv_item_ptr);
    ss_ptr->info.home_mcc =
                cmss_convert_mcc_ota_to_hpcd(nv_item_ptr->imsi_mcc.imsi_mcc);
  }

  CM_MSG_HIGH_1 (" home_mcc = %d", ss_ptr->info.home_mcc);

  cm_mem_free(nv_item_ptr);
}

#ifdef FEATURE_HDR
/*===========================================================================
FUNCTION cmss_get_hdr_ecio_and_io

DESCRIPTION

  Get HDR Ec/Io and Io values.

  HDR Ec/Io and Io information is sent with CM_SS_EVENT_RSSI and
  CM_SS_EVENT_HDR_RSSI events

DEPENDENCIES

  Serving System must be initialized

RETURNS

  None

SIDE EFFECTS

  None

===========================================================================*/
static void cmss_get_hdr_ecio_and_io( int16* hdr_ecio, int* hdr_io )
{
  hdrl1_srch_get_ecio_and_io( hdr_ecio, hdr_io );
}
#endif // FEATURE_HDR

/*===========================================================================
FUNCTION cmss_gwl_get_main_signal_status

DESCRIPTION
  This function fetches the RSSI of the given mode from cmss_gwl_signal_status.

DEPENDENCIES


RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/
#ifdef CM_GW_SUPPORTED
static void cmss_gwl_get_main_signal_status(sys_sys_mode_e_type   sys_mode, void *signal_status_ptr)
{
  switch (sys_mode)
  {
    case SYS_SYS_MODE_GSM:
    {
      *((cm_signal_status_type*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_g_main));
    }
    break;
    case SYS_SYS_MODE_WCDMA:
    {
      *((cm_signal_status_type*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_w));
    }
    break;
    #ifdef FEATURE_CM_LTE
    case  SYS_SYS_MODE_LTE:
    {
      *((lte_cphy_rssi_ind_s*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_lte));
    }
    break;
    #endif

    #ifdef FEATURE_TDSCDMA
    case  SYS_SYS_MODE_TDS:
    {
      *((tds_rrc_scell_signal_status_ind_type*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_tds_main));
    }
    break;
    #endif

    default:
      CM_MSG_HIGH_1 ("Invalid mode(%d) passed to cmss_gwl_get_main_signal_status" , sys_mode);
    break;
  }
}
#endif
/*===========================================================================
FUNCTION cmss_report_rssi

DESCRIPTION
  This function report raw rssi and ecio of 1x through msgr msg

DEPENDENCIES

RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmss_report_raw_rssi(uint16 rssi, unsigned char ecio, sys_modem_as_id_e_type as_id)
{
  cm_raw_rssi_msg_type   raw_rssi_msg;
  static uint16 rssi_sent = 0;
  static unsigned char ecio_sent = 0;

  if((rssi == rssi_sent) && (rssi == CMSS_RSSI_NO_SIGNAL) && (ecio == ecio_sent) && (ecio == CMSS_RAW_ECIO_VALUE_NO_SIGNAL))
  {
    return;
  }
  memset(&raw_rssi_msg, 0, sizeof(cm_raw_rssi_msg_type));
  raw_rssi_msg.hdr.inst_id = SYS_AS_ID_TO_INST_ID(as_id);
  raw_rssi_msg.raw_rssi_1x = rssi;
  raw_rssi_msg.raw_ecio_1x = ecio;

  (void) cm_msgr_send( MM_CM_RAW_RSSI_IND, MSGR_MM_CM,
                     (msgr_hdr_s*)&raw_rssi_msg, sizeof(cm_raw_rssi_msg_type) );

  rssi_sent = rssi;
  ecio_sent = ecio;

  return;
}

/*===========================================================================
FUNCTION cmss_report_rssi

DESCRIPTION
  This function gets the RSSI. If the RSSI change exceeds the delta threshold,
  CM reports rssi change event to registered clients.

DEPENDENCIES
  Serving System and Phone objects must be initialized

RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_report_rssi (

  const void              *rpt_ptr,
    /* ptr to message received */

  cm_client_s_type        *client_ptr,
    /* pointer to a client struct */

  boolean                 ignore_updates
    /* flag to ignore any RSSI changes and always send RSSI events */

)
/*lint -esym(715,rpt_ptr)*/
{
  cmss_s_type          *ss_ptr       = cmss_ptr();
  cmph_s_type          *ph_ptr       = cmph_ptr();

  cm_mm_ss_info_s_type *ss_info_ptr   = cmss_info_alloc();
      /* Allocate serving system info buffer */

  sys_sys_mode_e_type   sys_mode     = ss_ptr->info.sys_mode;
  uint16                rssi         = ss_ptr->info.rssi;
  uint16                current_rssi = 0;
  uint8                 rssi_delta   = ph_ptr->rssi_delta;

  #ifdef FEATURE_HDR
  uint8                 io_delta     = ph_ptr->io_delta;
  #endif

  #if ( defined(FEATURE_UMTS_REPORT_ECIO) || defined(FEATURE_MMODE_CDMA_800) || \
        defined(FEATURE_MMODE_CDMA_1900) || defined (FEATURE_HDR) )
  uint8                 ecio_delta   = ph_ptr->ecio_delta;
  #endif

  #if (defined(FEATURE_HDR) || defined(FEATURE_HDR_HYBRID))
  int                   io           = ss_ptr->info.io;
  int                   current_io   = 0;
  byte                  current_sinr = 0;
  #endif

  #if (defined(FEATURE_HDR) || defined(FEATURE_HDR_HYBRID)|| \
       defined(FEATURE_CM_LTE))
  byte                  sinr         = ss_ptr->info.sinr;
  #endif

  #if (defined(FEATURE_HDR) || defined(FEATURE_HDR_HYBRID) || \
       defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
  int16                 ecio         = ss_ptr->info.ecio ;
  int16                 current_ecio = 0;
  #endif

  #if (defined CM_GW_SUPPORTED && defined(FEATURE_UMTS_REPORT_ECIO))
  int16                 gw_ecio         = ss_ptr->info.gw_ecio;
  int16                 current_gw_ecio = 0;
  #endif /* #if ...FEATURE_UMTS_REPORT_ECIO */

  #ifdef CM_GW_SUPPORTED
  int16                 pathloss         = ss_ptr->info.pathloss;
  int16                 current_pathloss = 0;
  int16                 sir              = ss_ptr->info.sir;
  int16                 current_sir      = 0;
  int16                 rscp             = ss_ptr->info.rscp;
  int16                 current_rscp     = 0;
  uint8                 sir_delta        = ph_ptr->sir_delta;
  uint8                 pathloss_delta   = ph_ptr->pathloss_delta;
  uint8                 ber              = ss_ptr->info.mode_info.gw_info.bit_err_rate;
  uint8                 current_ber      = CMSS_BER_VALUE_NO_SIGNAL;
  #ifdef FEATURE_WCDMA_L1_HS_CQI_STAT
  byte                  cqi              = ss_ptr->info.cqi_info.gw_cqi;
  byte                  current_cqi      = 0;
  uint8                 cqi_delta        = ph_ptr->cqi_delta;
  #endif /* FEATURE_WCDMA_L1_HS_CQI_STAT */
  sys_eutra_status_enum_type current_eutra_detect_status = \
    SYS_EUTRA_DETECTION_UNKNOWN;
  const                 cm_rpt_type *gw_rpt_ptr      = NULL;
  #endif

  #if ( defined CM_GW_SUPPORTED || \
         defined(FEATURE_CM_LTE))
  int16                 rssi2            = ss_ptr->info.rssi2;
  #endif

  #ifdef FEATURE_CM_LTE
  int16                 rsrp             = ss_ptr->info.rsrp;
  int16                 current_rsrp     = 0;
  int8                  rsrq             = ss_ptr->info.rsrq;
  int8                  current_rsrq     = 0;
  byte                  current_lte_sinr = 0;
  uint8                 rsrp_delta       = ph_ptr->rsrp_delta;
  uint8                 rsrq_delta       = ph_ptr->rsrq_delta;
  #endif

  #if ((defined CM_GW_SUPPORTED) && \
     defined(FEATURE_UMTS_REPORT_ECIO))
  boolean               ecio_for_display         = ss_ptr->info.ecio_for_display;
  boolean               current_ecio_for_display = FALSE;
  #endif

  boolean               report_rssi              = FALSE;
  boolean               print_messages           = TRUE;

  /* Variable cache to see if values have changed since last call */
  static boolean        is_cache_empty           = TRUE;
  /* Note: this cache will get updated on the first function call,
  **       so these initial values should not affect functionality.
  */
  static boolean        cached_ignore_updates    = FALSE;
  static uint16         cached_rssi_delta        = 0;
  static uint8          cached_io_delta          = 0;
  static int16          cached_ecio_delta        = 0;
  static uint8          cached_sir_delta         = 0;
  static uint8          cached_pathloss_delta    = 0;
  static uint8          cached_cqi_delta         = 0;

  ss_ptr->info.signal_strength_changed_fields  = 0;

  if ( is_cache_empty                                          ||
       ignore_updates                 != cached_ignore_updates ||
       ph_ptr->rssi_delta             != cached_rssi_delta     ||
       ph_ptr->io_delta               != cached_io_delta       ||
       ph_ptr->ecio_delta             != cached_ecio_delta     ||
       ph_ptr->sir_delta              != cached_sir_delta      ||
       ph_ptr->pathloss_delta         != cached_pathloss_delta ||
       ph_ptr->cqi_delta              != cached_cqi_delta )
  {
     /* Cache the new values */
     cached_ignore_updates = ignore_updates;
     cached_rssi_delta = ph_ptr->rssi_delta;
     cached_io_delta = ph_ptr->io_delta;
     cached_ecio_delta = ph_ptr->ecio_delta;
     cached_sir_delta = ph_ptr->sir_delta;
     cached_pathloss_delta = ph_ptr->pathloss_delta;
     cached_cqi_delta = ph_ptr->cqi_delta;

     is_cache_empty = FALSE;
  }
  else
  {
    /* Don't print summary messages if there is no change vs. the cache */
    print_messages = FALSE;
  }

  if (print_messages)
  {

  CM_MSG_MED_1("cmss_report_rssi(), ignore_updates=%d", ignore_updates);

  CM_MSG_MED_6("cmss_report_rssi(), rssi_delta=%d, io_delta=%d, ecio_delta=%d sir_delta=%d, pathloss_delta=%d, cqi_delta=%d",
              ph_ptr->rssi_delta, ph_ptr->io_delta , ph_ptr->ecio_delta,
              ph_ptr->sir_delta, ph_ptr->pathloss_delta , ph_ptr->cqi_delta);

 
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef CM_GW_SUPPORTED
  if( rpt_ptr != NULL )
  {
    gw_rpt_ptr = rpt_ptr;
  }
  #endif /* GSM || WCDMA */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the RSSI report is regarding MAIN stack then proceed */
  switch ( sys_mode )
  {
    case SYS_SYS_MODE_NO_SRV:
      ss_ptr->info.sinr = CMSS_SINR_VALUE_NO_SIGNAL;
      ss_ptr->info.io   = CMSS_IO_VALUE_NO_SIGNAL;
      ss_ptr->info.mode_info.gw_info.bit_err_rate
                        = CMSS_BER_VALUE_NO_SIGNAL;

      if ( rssi != CMSS_RSSI_NO_SIGNAL )
      {
        ss_ptr->info.rssi             = CMSS_RSSI_NO_SIGNAL;
        ss_ptr->info.ecio             = CMSS_ECIO_VALUE_NO_SIGNAL;
        ss_ptr->info.pathloss         = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
        ss_ptr->info.sir              = CMSS_SIR_VALUE_NO_SIGNAL;
        ss_ptr->info.gw_ecio          = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
        ss_ptr->info.rssi2            = CMSS_RSSI2_NO_SIGNAL;
        ss_ptr->info.rscp             = CMSS_RSCP_NO_SIGNAL;
        ss_ptr->info.ecio_for_display = FALSE;
        ss_ptr->info.cqi_info.gw_cqi  = CMSS_CQI_VALUE_NO_SIGNAL;

        report_rssi          = TRUE;
      }

      #ifdef CM_GW_SUPPORTED
      if (gw_rpt_ptr != NULL)
      {
        current_eutra_detect_status = \
          gw_rpt_ptr->cmd.signal_status.eutra_detect_status;

        CM_MSG_MED_2 ("rpt eutra_detect_status - %d, ss_ptr info - %d",
                    current_eutra_detect_status,
                    ss_ptr->info.eutra_detect_status);

        if (current_eutra_detect_status != ss_ptr->info.eutra_detect_status)
        {
          ss_ptr->info.eutra_detect_status = current_eutra_detect_status;
          report_rssi                  = TRUE;

          CM_MSG_MED_1 ("eutra_detect_status reported. %d",
                       ss_ptr->info.eutra_detect_status);
        } /* if the status changed */
      }
      #endif

      /*send MSGR to indicate RAW rssi and ecio */
      cmss_report_raw_rssi(CMSS_RSSI_NO_SIGNAL, CMSS_RAW_ECIO_VALUE_NO_SIGNAL,SYS_MODEM_AS_ID_1);

      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
    case SYS_SYS_MODE_AMPS:
      current_rssi = cmss_get_fm_rssi();
      ss_ptr->info.sinr = CMSS_SINR_VALUE_NO_SIGNAL;
      ss_ptr->info.io   = CMSS_IO_VALUE_NO_SIGNAL;

      if ( CMABS( rssi - current_rssi ) > rssi_delta )
      {
        ss_ptr->info.rssi             = current_rssi;
        ss_ptr->info.ecio             = CMSS_ECIO_VALUE_NO_SIGNAL;
        ss_ptr->info.pathloss         = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
        ss_ptr->info.sir              = CMSS_SIR_VALUE_NO_SIGNAL;
        ss_ptr->info.rssi2            = CMSS_RSSI2_NO_SIGNAL;
        ss_ptr->info.rscp             = CMSS_RSCP_NO_SIGNAL;
        ss_ptr->info.ecio_for_display = FALSE;
        report_rssi                   = TRUE;
      }

      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

    #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
    case SYS_SYS_MODE_CDMA:
      current_rssi = cmss_get_cdma_rssi();
      current_ecio = cmss_get_cdma_ecio();

      if ( (CMABS( rssi - current_rssi ) > rssi_delta)||
           (CMABS( ecio - current_ecio ) > ecio_delta)
         )
      {
        ss_ptr->info.rssi = current_rssi;
    if(!(sd_misc_get_ss_sys_lost(SD_SS_MAIN) == SD_SS_SYS_LOST_NO_RESOURCES))
    {

        ss_ptr->info.ecio = current_ecio;

    }
        report_rssi       = TRUE;

        CM_MSG_MED_5("C:cmss_report_rssi(), rssi = %d, current_rssi=%d report_rssi=%d, ecio=%d, current_ecio=%d", 
					rssi, current_rssi,report_rssi, ecio, current_ecio);
        
        /* There is no function provided to report Io only for CDMA
        */
        ss_ptr->info.io   = CMSS_IO_VALUE_NO_SIGNAL;
        ss_ptr->info.sinr = CMSS_SINR_VALUE_NO_SIGNAL;
      } /* if delta threshold exceeded */

      /*send MSGR to indicate RAW rssi and ecio */
      cmss_report_raw_rssi(srch_get_cdma_raw_rssi(), (unsigned char)srch_get_cdma_raw_ecio(),SYS_MODEM_AS_ID_1);

      break;
    #endif /* (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */

    #ifdef FEATURE_HDR
    case SYS_SYS_MODE_HDR:
    {
      cmss_get_hdr_ecio_and_io(&current_ecio, &current_io);
      /* Following typecast is safe: byte --> uint16. Done to retain backward
      ** compatibility of sending uint16 rssi value to CM-clients */
      current_rssi = (uint16)hdrl1_srch_get_hdr_rssi();
      hdrl1_srch_get_sinr_and_rxagc(&current_sinr,NULL);



      if ( (CMABS( rssi - current_rssi ) > rssi_delta)||
           (CMABS( io   - current_io )   > io_delta)||
           (CMABS( ecio - current_ecio ) > ecio_delta)||
           (current_sinr != sinr )
         )
      {


        /*
        ** We want to tie reporting of HDR Ec/Io and Io & SINR
        ** with HDR RSSI being reported
        */
        ss_ptr->info.rssi = current_rssi;
        ss_ptr->info.ecio = current_ecio;
        ss_ptr->info.io   = current_io;
        ss_ptr->info.sinr = current_sinr;

        report_rssi       = TRUE;

        CM_MSG_MED_4("H:cmss_report_rssi(), rssi=%d, current_rssi=%d io=%d, current_io=%d",
                   rssi, current_rssi, io, current_io);

        CM_MSG_MED_5("H:cmss_report_rssi(), ecio=%d, current_ecio=%d current_sinr=%d, sinr=%d report_rssi=%d",
                   ecio, current_ecio, current_sinr, sinr, report_rssi);


      } /* if delta threshold exceeded */

      break;
    }
    #endif /* FEATURE_HDR */

    #ifdef CM_GW_SUPPORTED
    case SYS_SYS_MODE_GSM:
    case SYS_SYS_MODE_WCDMA:
    {
      /* Update the rssi and bit err rate if there is a change.
      */

      cm_signal_status_type gw_signal_status = {0};

      cmss_gwl_get_main_signal_status(sys_mode, &gw_signal_status);

      ss_ptr->info.sinr    = CMSS_SINR_VALUE_NO_SIGNAL;
      ss_ptr->info.io      = CMSS_IO_VALUE_NO_SIGNAL;

      CM_MSG_MED_2("GW:cmss_report_rssi() sys_mode=%d,gw_signal_status.signal_strength = %d",
                 ss_ptr->info.sys_mode, gw_signal_status.signal_strength);

        #ifdef FEATURE_WCDMA_DATA_FOR_UI_BAR_DISPLAY
      #error code not present
#else
      ss_ptr->gw_rssi      = (uint16)gw_signal_status.signal_strength;
        #endif
      rssi2                = gw_signal_status.signal_strength;
      ss_ptr->bit_err_rate = gw_signal_status.bit_error_rate;

        if (sys_mode == SYS_SYS_MODE_GSM)
        {
          ss_ptr->gw_sir               = CMSS_SIR_VALUE_NO_SIGNAL;
          ss_ptr->gw_pathloss          = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
          #ifdef FEATURE_UMTS_REPORT_ECIO
          ss_ptr->gw_rscp              = CMSS_RSCP_NO_SIGNAL;
          ss_ptr->gw_ecio_for_display  = FALSE;
          /* if sys_mode is GSM always default ecio to
          ** CMSS_ECIO_VALUE_INVALID_SIGNAL
          */
          ss_ptr->gw_ecio              = CMSS_ECIO_VALUE_INVALID_SIGNAL;
          #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */
          #ifdef FEATURE_WCDMA_L1_HS_CQI_STAT
          ss_ptr->gw_cqi = CMSS_CQI_VALUE_NO_SIGNAL;
          ss_ptr->gw_cqi_num_samples = 0;
          #endif
        }
        else
        {
          ss_ptr->gw_sir               = gw_signal_status.sir;
          ss_ptr->gw_pathloss          = gw_signal_status.pathloss;
          ss_ptr->gw_rscp              = gw_signal_status.rscp;
          ss_ptr->gw_ecio_for_display  = gw_signal_status.use_ecio_for_display;
          #ifdef FEATURE_UMTS_REPORT_ECIO
           ss_ptr->gw_ecio              = gw_signal_status.ecio;
          #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */
          #ifdef FEATURE_WCDMA_L1_HS_CQI_STAT
           ss_ptr->gw_cqi               = gw_signal_status.avg_cqi_val;
           ss_ptr->gw_cqi_num_samples   = gw_signal_status.avg_cqi_num_sample;
          #endif

          if (sys_mode == SYS_SYS_MODE_WCDMA)
          {
            current_eutra_detect_status = \
              gw_signal_status.eutra_detect_status;

            CM_MSG_MED_2 ("rpt eutra_detect_status - %d, ss_ptr info - %d",
                         current_eutra_detect_status,
                         ss_ptr->info.eutra_detect_status);

            if (current_eutra_detect_status != \
                ss_ptr->info.eutra_detect_status)
            {
              ss_ptr->info.eutra_detect_status = current_eutra_detect_status;
              report_rssi                  = TRUE;

              CM_MSG_MED_1 ("eutra_detect_status reported. %d",
                           ss_ptr->info.eutra_detect_status);
            } /* if the status changed */
          }
        }

      current_rssi = ss_ptr->gw_rssi;

      CM_MSG_MED_3("GW:cmss_report_rssi() current_rssi=%d, prev rssi=%d, rssi_delta=%d",
                 current_rssi, rssi, rssi_delta);

      if ( CMABS( rssi - current_rssi ) > rssi_delta )
      {
        ss_ptr->info.rssi    = current_rssi;
        ss_ptr->info.rssi2   = rssi2;
        report_rssi          = TRUE;
      } /* if delta threshold exceeded */

      current_ber = ss_ptr->bit_err_rate;
      if ( ber != current_ber )
      {
        ss_ptr->info.mode_info.gw_info.bit_err_rate = current_ber;
        report_rssi          = TRUE;
        CM_MSG_HIGH_2 ("BER change old ber= %d new BER= %d" , ber, current_ber);
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      #ifdef FEATURE_UMTS_REPORT_ECIO
      current_gw_ecio          = ss_ptr->gw_ecio;
      current_ecio_for_display = ss_ptr->gw_ecio_for_display;
      if ( CMABS( gw_ecio - current_gw_ecio ) > ecio_delta ||
           (current_ecio_for_display != ecio_for_display) )
      {
        ss_ptr->info.gw_ecio                = current_gw_ecio;
        ss_ptr->info.ecio_for_display       = current_ecio_for_display;
        report_rssi                         = TRUE;
      } /* if delta threshold exceeded */
      #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_sir                      = ss_ptr->gw_sir;

      if ( CMABS( sir - current_sir ) >= sir_delta )
      {
        ss_ptr->info.sir      = current_sir;
        report_rssi           = TRUE;

        CM_MSG_MED_3("GW:cmss_report_rssi(), sir=%d, current_sir=%d, sir_delta=%d",
                   sir, current_sir, sir_delta);

      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_pathloss        = ss_ptr->gw_pathloss;

      if ( CMABS( pathloss - current_pathloss ) >= pathloss_delta )
      {
        CM_MSG_MED_3("GW:cmss_report_rssi(), pathloss=%d, current_pathloss=%d, pathloss_delta=%d",
                   pathloss, current_pathloss, pathloss_delta);

        ss_ptr->info.pathloss    = current_pathloss;
        report_rssi              = TRUE;
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_rscp = ss_ptr->gw_rscp;

      if ( CMABS( rscp - current_rscp ) >= CMSS_RSCP_THRESHOLD_DELTA)
      {
        CM_MSG_MED_3("GW:cmss_report_rssi(), rscp=%d, current_rscp=%d, rscp_delta=%d",
                   rscp, current_rscp, CMSS_RSCP_THRESHOLD_DELTA);

        ss_ptr->info.rscp            = current_rscp;
        report_rssi                  = TRUE;
      } /* if delta threshold exceeded */
      #ifdef FEATURE_WCDMA_L1_HS_CQI_STAT
      current_cqi = ss_ptr->gw_cqi;

      CM_MSG_MED_3 ("CQI cqi - %d, ss_ptr cqi - %d, delta - %d",
                   cqi, ss_ptr->gw_cqi, cqi_delta);

      if ( CMABS( cqi - current_cqi ) >= cqi_delta )
      {
        ss_ptr->info.cqi_info.gw_cqi = current_cqi;
        ss_ptr->info.cqi_info.num_cqi_samples = ss_ptr->gw_cqi_num_samples;
        report_rssi                  = TRUE;

        CM_MSG_MED_2 ("CQI reported. cqi: %d, num_samples: %d",
                     ss_ptr->info.cqi_info.gw_cqi,
                     ss_ptr->info.cqi_info.num_cqi_samples);
      } /* if delta threshold exceeded */
      #endif

      break;
    }
    #endif /* defined CM_GW_SUPPORTED) */

    #ifdef FEATURE_TDSCDMA
    case SYS_SYS_MODE_TDS:
    {

      /* Update the rssi and bit err rate if there is a change.
      */
      tds_rrc_scell_signal_status_ind_type tds_signal_status = {{0}};

      //values are scaled by 10 as they come directly from MSGR, divide by 10 before using it
      cmss_gwl_get_main_signal_status(SYS_SYS_MODE_TDS, &tds_signal_status);

      CM_MSG_MED_1("TDS:cmss_report_rssi() tds_signal_status.rssi/10 =%d",
                   tds_signal_status.rssi);

      /* As per TDS folks, TDS will always send negative RSSI value for TDSCDMA_RRC_SCELL_SIGNAL_STATUS_IND */
      ss_ptr->gw_rssi      = CMABS( tds_signal_status.rssi )/10;
      rssi2                = tds_signal_status.rssi/10;

      ss_ptr->gw_rscp              = tds_signal_status.rscp/10;

      #ifdef FEATURE_UMTS_REPORT_ECIO
      ss_ptr->gw_ecio              = tds_signal_status.ecio/10;
      #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */


      current_rssi = ss_ptr->gw_rssi;

      CM_MSG_MED_3("TDS:cmss_report_rssi() current rssi=%d, prev rssi=%d, rssi_delta=%d",
                 current_rssi, rssi, rssi_delta);

      if ( CMABS( rssi - current_rssi ) > rssi_delta )
      {
        ss_ptr->info.rssi    = current_rssi;
        ss_ptr->info.rssi2   = rssi2;
        report_rssi          = TRUE;

      } /* if delta threshold exceeded */


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      #ifdef FEATURE_UMTS_REPORT_ECIO
      current_gw_ecio          = ss_ptr->gw_ecio;
      if ( CMABS( gw_ecio - current_gw_ecio ) > ecio_delta )
      {
        ss_ptr->info.gw_ecio                = current_gw_ecio;
        report_rssi                         = TRUE;
      } /* if delta threshold exceeded */
      #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_rscp = ss_ptr->gw_rscp;

      if ( CMABS( rscp - current_rscp ) >= CMSS_RSCP_THRESHOLD_DELTA)
      {
        CM_MSG_MED_3("TDS:cmss_report_rssi(), rscp=%d, current_rscp=%d, rscp_delta=%d",
                   rscp, current_rscp, CMSS_RSCP_THRESHOLD_DELTA);

        ss_ptr->info.rscp            = current_rscp;
        report_rssi                  = TRUE;
      } /* if delta threshold exceeded */

      if ( tds_signal_status.in_dch == TRUE)
      {
        CM_MSG_HIGH_5("TDS:SUB1:ss_ptr->bit_err_rate= %d,old_ber= %d,new_ber=%d in_dch=%d, sir_delta=%d",
			ss_ptr->bit_err_rate, ber, tds_signal_status.bler, tds_signal_status.in_dch, sir_delta);
		
        ss_ptr->gw_sir = tds_signal_status.sinr / 10;
        ss_ptr->bit_err_rate = tds_signal_status.bler;

      
        current_sir = ss_ptr->gw_sir;

        if ( CMABS( sir - current_sir ) >= sir_delta )
        {
          ss_ptr->info.sir      = current_sir;
          report_rssi           = TRUE;
          CM_MSG_MED_3("TDS:cmss_report_rssi(), sir=%d, current_sir=%d, sir_delta=%d",
                   sir, current_sir, sir_delta);
        }//if there is difference in sinr level

        current_ber = ss_ptr->bit_err_rate;
        if ( ber != current_ber )
        {
          ss_ptr->info.mode_info.gw_info.bit_err_rate = current_ber;
          report_rssi          = TRUE;
          CM_MSG_HIGH_2 ("TDS:BER change old ber= %d new BER= %d",ber,current_ber);
        }

      } // if in_dch is valid
      else
      {
        if(ber != CMSS_BER_VALUE_NO_SIGNAL)
        {
          CM_MSG_HIGH_2 ("TDS:SUB1:Resettng the BLER value ber= %d,ss_ptr->bit_err_rate=%d",ber,ss_ptr->bit_err_rate);
          ss_ptr->info.mode_info.gw_info.bit_err_rate = 0xff;
          ss_ptr->bit_err_rate = 0xff;
          report_rssi           = TRUE;
        }
        ss_ptr->info.sinr = 0xff;
      }

      break;
    }
    #endif

    #ifdef FEATURE_CM_LTE
    case SYS_SYS_MODE_LTE:
    {
      lte_cphy_rssi_ind_s lte_rpt = {{0}};

      cmss_gwl_get_main_signal_status(SYS_SYS_MODE_LTE, &lte_rpt);

        /*lint -save -e571 */
      current_rssi = (uint16)CMABS(lte_rpt.rssi);

        CM_MSG_MED_3("LTE:cmss_report_rssi(), rssi=%d, current_rssi=%d, rssi_delta=%d",
                   rssi, current_rssi, rssi_delta);

        /*lint -restore */
        if ( CMABS( rssi - current_rssi ) > rssi_delta )
        {
          ss_ptr->info.rssi        = current_rssi;
          ss_ptr->info.rssi2       = lte_rpt.rssi;

          report_rssi              = TRUE;
        } /* if delta threshold exceeded */

      current_rsrp = lte_rpt.rsrp;
        CM_MSG_MED_3("LTE:cmss_report_rssi(), rsrp=%d, current_rsrp=%d, rsrp_delta=%d",
                   rsrp, current_rsrp, rsrp_delta);
        if ( CMABS( rsrp - current_rsrp ) >= rsrp_delta)
        {
          ss_ptr->info.rsrp        = current_rsrp;

          report_rssi              = TRUE;
        } /* if delta threshold exceeded */

      current_rsrq = lte_rpt.rsrq;
        CM_MSG_MED_3("LTE:cmss_report_rssi(), rsrq=%d, current_rsrq=%d, rsrq_delta=%d",
                      rsrq, current_rsrq, rsrq_delta);
        if ( CMABS( rsrq - current_rsrq ) >= rsrq_delta)
        {
          ss_ptr->info.rsrq        = current_rsrq;

          report_rssi              = TRUE;
        } /* if delta threshold exceeded */

      if ( lte_rpt.sinr_valid == TRUE)
        {
        current_lte_sinr = (byte)lte_rpt.log_sinr_10xdB;

          CM_MSG_MED_2("LTE:cmss_report_rssi(),sinr=%d, current_sinr=%d",
                   sinr, current_lte_sinr);

          if(current_lte_sinr != sinr )
          {
            ss_ptr->info.sinr = current_lte_sinr;
            report_rssi              = TRUE;
          } /* if there is difference in sinr level */
        } /* if sinr is valid  */

      break;
    }
    #endif /*FEATURE_CM_LTE*/

    default:
      break;
  }

  if (print_messages || report_rssi)
  {
  CM_MSG_MED_2("cmss_report_rssi(), report_rssi=%d, ignore_updates=%d",
               report_rssi, ignore_updates);
  }

  /* ===========Report SS_MAIN RSSI===============
  */
  if (( report_rssi || ignore_updates ) &&
     !(ss_ptr->info.rssi >= CMSS_RRC_RSSI_NO_SIGNAL && ph_ptr->qmss_enabled && ss_ptr->info.srv_status == SYS_SRV_STATUS_SRV))
  {
    CM_MSG_MED_1("sys mode at the time of reporting rssi %d" , sys_mode);
    /* Copy serving system state information into
    ** allocated buffer.
    */
    (void) cmss_info_get( ss_info_ptr, &ss_ptr->info );

    /*
    ** Inform the clients that the RSSI was modified.
    */


    if(client_ptr != NULL)
    {
      cmss_get_signal_strength_info_change (ss_info_ptr, ss_ptr);
      cm_client_ss_event_ntfy(client_ptr, CM_SS_EVENT_RSSI, ss_info_ptr);
    }
    else
    {
      cmss_event( CM_SS_MAIN, CM_SS_EVENT_RSSI );
    }

  } /* if ( report_rssi ) */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Report HDR RSSI, if changed
  */
  #ifdef FEATURE_HDR_HYBRID
  report_rssi  = FALSE;

  if ( cmss_is_hybr_status_on() )
  {
    switch ( ss_ptr->info.hdr_srv_status )
    {
      case SYS_SRV_STATUS_NO_SRV:
      case SYS_SRV_STATUS_PWR_SAVE:
        if (ss_ptr->info.hdr_rssi != CMSS_RSSI_NO_SIGNAL)
        {
          ss_ptr->info.hdr_rssi    = CMSS_RSSI_NO_SIGNAL;
          ss_ptr->info.hdr_sinr    = CMSS_SINR_VALUE_NO_SIGNAL;
          ss_ptr->info.hdr_io      = CMSS_IO_VALUE_NO_SIGNAL;
          ss_ptr->info.hdr_ecio    = CMSS_ECIO_VALUE_NO_SIGNAL;

          report_rssi  = TRUE;

          CM_MSG_MED_1("HY:cmss_report_rssi() : hdr_srv_status : %d",
                       ss_ptr->info.hdr_srv_status);
        }
        break;

      /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      case SYS_SRV_STATUS_LIMITED:
      case SYS_SRV_STATUS_SRV:

        rssi    = ss_ptr->info.hdr_rssi;
        ecio    = ss_ptr->info.hdr_ecio;
        io      = ss_ptr->info.hdr_io;
        sinr    = ss_ptr->info.hdr_sinr;

        cmss_get_hdr_ecio_and_io(&current_ecio, &current_io);

        current_rssi = (uint16)hdrl1_srch_get_hdr_rssi();
        hdrl1_srch_get_sinr_and_rxagc(&current_sinr,NULL);

        if ( (CMABS( rssi - current_rssi ) > rssi_delta) ||
             (CMABS( io   - current_io )   > io_delta)   ||
             (CMABS( ecio - current_ecio ) > ecio_delta) ||
             (current_sinr != sinr )
           )
        {
          /*
          ** We want to tie reporting of HDR Ec/Io and Io
          ** with HDR RSSI being reported
          */
          ss_ptr->info.hdr_rssi = current_rssi;
          ss_ptr->info.hdr_ecio = current_ecio;
          ss_ptr->info.hdr_io   = current_io;
          ss_ptr->info.hdr_sinr = current_sinr;

          report_rssi  = TRUE;

          CM_MSG_MED_5("HY:cmss_report_rssi() : rssi=%d, current_rssi=%d, rssi_delta=%d current_sinr=%d, sinr=%d",
                     rssi, current_rssi, rssi_delta, current_sinr, sinr);
          CM_MSG_MED_6("HY:cmss_report_rssi() : io=%d, current_io=%d, io_delta=%d ecio=%d, current_ecio=%d, ecio_delta=%d",
                       io, current_io, io_delta, ecio, current_ecio, ecio_delta);
         
        }
        break;

      default:
        break;
    }
  } /* if hybr on */

  if (print_messages || report_rssi )
  {
  CM_MSG_MED_2("HY:cmss_report_rssi(), report_rssi=%d, ignore_updates=%d",
               report_rssi, ignore_updates);
  }

  /* =======Report hybrid HDR RSSI========
  */
  if ( report_rssi || ignore_updates )
  {
    /* Now report CM_SS_EVENT_HDR_RSSI
    */
    if(client_ptr != NULL)
    {
      /* Copy serving system state information into
      ** allocated buffer.
      */
      (void) cmss_info_get( ss_info_ptr, &ss_ptr->info );

      cmss_get_signal_strength_info_change (ss_info_ptr, ss_ptr);
      cm_client_ss_event_ntfy(client_ptr, CM_SS_EVENT_HDR_RSSI, ss_info_ptr);
    }
    else
    {
      cmss_event( CM_SS_MAIN, CM_SS_EVENT_HDR_RSSI );
    }
  } /* if ( report_rssi ) */
  #endif /* FEATURE_HDR_HYBRID */



  /* Deallocate the dynamically allocated memory after sending the ss event. */
  cm_mem_free(ss_info_ptr);

} /* cmss_report_rssi() */
/*lint +esym(715,rpt_ptr)*/

/*===========================================================================
FUNCTION cmss_gwl_store_rssi_info

DESCRIPTION
  This function stores the RSSI value got from RR/RRC indication into
cmss_gwl_signal_status.

DEPENDENCIES


RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/
#ifdef CM_GW_SUPPORTED
static void cmss_gwl_store_rssi_info ( sys_sys_mode_e_type sys_mode, const void *signal_status_ptr)
{
  rex_enter_crit_sect(cmtask_crit_sect_ptr());
  switch (sys_mode)
  {
    case SYS_SYS_MODE_GSM:
    {
      *(&(cmss_gwl_signal_status.signal_status_g_main)) = *((cm_signal_status_type*)signal_status_ptr);
    }
    break;
    case SYS_SYS_MODE_WCDMA:
    {
      *(&(cmss_gwl_signal_status.signal_status_w)) = *((cm_signal_status_type*)signal_status_ptr);
    }
    break;
    #ifdef FEATURE_CM_LTE
    case  SYS_SYS_MODE_LTE:
    {
      *(&(cmss_gwl_signal_status.signal_status_lte)) = *((lte_cphy_rssi_ind_s*)signal_status_ptr);
    }
    break;
    #endif
    #ifdef FEATURE_TDSCDMA
    case  SYS_SYS_MODE_TDS:
    {
      *(&(cmss_gwl_signal_status.signal_status_tds_main)) = *((tds_rrc_scell_signal_status_ind_type*)signal_status_ptr);
    }
    break;
    #endif
  default:
    CM_MSG_HIGH_1 ("Invalid mode(%d) passed to cmss_gwl_store_rssi_info" , sys_mode);
    break;
  }
  rex_leave_crit_sect(cmtask_crit_sect_ptr());
}
#endif



/*===========================================================================
FUNCTION cmss_gwl_get_hybr2_signal_status

DESCRIPTION
  This function fetches the RSSI of the given mode from cmss_gwl_signal_status.

DEPENDENCIES


RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_gwl_get_hybr2_signal_status(sys_sys_mode_e_type  sys_mode, void *signal_status_ptr)
{
  #ifndef CM_GW_SUPPORTED
  SYS_ARG_NOT_USED(sys_mode);
  SYS_ARG_NOT_USED(signal_status_ptr);
  return;
  #else

  CM_MSG_HIGH_1("cmss_gwl_get_hybr2_signal_status(), mode=%d",  sys_mode);
  switch (sys_mode)
  {
    case SYS_SYS_MODE_GSM:
    {
      *((cm_signal_status_type*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_g_hybr));
    }
    break;
    case SYS_SYS_MODE_WCDMA:
    {
      *((cm_signal_status_type*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_w));
    }
    break;
    case  SYS_SYS_MODE_LTE:
    #ifdef FEATURE_CM_LTE
    {
      *((lte_cphy_rssi_ind_s*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_lte));
    }
    #endif
    break;

    case SYS_SYS_MODE_TDS:
    #ifdef FEATURE_TDSCDMA
    {
      *((tds_rrc_scell_signal_status_ind_type*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_tds_main));
    }
    #endif
    break;

    default:
      CM_MSG_HIGH_1 ("Invalid mode(%d) passed to cmss_gwl_get_hybr2_signal_status" , sys_mode);
    break;
  }
  #endif
}



/*===========================================================================
FUNCTION cmss_report_hybr_2_rssi

DESCRIPTION
  This function gets the RSSI. If the RSSI change exceeds the delta threshold,
  CM reports rssi change event to registered clients.

DEPENDENCIES
  Serving System and Phone objects must be initialized

RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_report_hybr_2_rssi (

  const void              *rpt_ptr,
    /* ptr to message received */

  cm_client_s_type        *client_ptr,
    /* pointer to a client struct */

  boolean                 ignore_updates
    /* flag to ignore any RSSI changes and always send RSSI events */

)
/*lint -esym(715,rpt_ptr)*/
{
  cmss_s_type          *ss_ptr       = cmss_ptr();
  cmph_s_type          *ph_ptr       = cmph_ptr();

  cm_mm_ss_info_s_type *ss_info_ptr;

      /* serving system info buffer */

  sys_sys_mode_e_type   sys_mode     = ss_ptr->info.gw_sys_mode;
  uint16                rssi         = ss_ptr->info.gw_rssi;
  uint16                current_rssi = 0;
  uint8                 rssi_delta   = ph_ptr->rssi_delta;

  #if defined(FEATURE_UMTS_REPORT_ECIO)
  uint8                 ecio_delta   = ph_ptr->ecio_delta;
  #endif

  #if (defined CM_GW_SUPPORTED && defined FEATURE_UMTS_REPORT_ECIO)
  int16                 gw_ecio         = ss_ptr->info.gw2_ecio;
  int16                 current_gw_ecio = 0;
  #endif /* #if ...FEATURE_UMTS_REPORT_ECIO */

  #ifdef CM_GW_SUPPORTED
  int16                 pathloss         = ss_ptr->info.gw_pathloss;
  int16                 current_pathloss = 0;
  int16                 sir              = ss_ptr->info.gw_sir;
  int16                 current_sir      = 0;
  int16                 rssi2            = ss_ptr->info.gw_rssi2;
  int16                 rscp             = ss_ptr->info.gw_rscp;
  int16                 current_rscp     = 0;
  uint8                 sir_delta        = ph_ptr->sir_delta;
  uint8                 pathloss_delta   = ph_ptr->pathloss_delta;
  uint8                 ber              = ss_ptr->info.gw_mode_info.gw_info.bit_err_rate;
  uint8                 current_ber      = CMSS_BER_VALUE_NO_SIGNAL;

  #ifdef FEATURE_CM_LTE
  int16                 rsrp             = ss_ptr->info.gwl_rsrp;
  int16                 current_rsrp     = 0;
  int8                  rsrq             = ss_ptr->info.gwl_rsrq;
  int8                  current_rsrq     = 0;
  byte                  current_lte_sinr = 0;
  uint8                 rsrp_delta       = ph_ptr->rsrp_delta;
  uint8                 rsrq_delta       = ph_ptr->rsrq_delta;
  byte                  sinr             = ss_ptr->info.gw_sinr;
  #endif

  const     cm_rpt_type *gw_rpt_ptr      = NULL;
  #endif

  #if ((defined CM_GW_SUPPORTED) && \
     defined(FEATURE_UMTS_REPORT_ECIO))
  boolean               ecio_for_display         = ss_ptr->info.gw_ecio_for_display;
  boolean               current_ecio_for_display = FALSE;
  #endif

  boolean               report_rssi              = FALSE;
  sys_modem_as_id_e_type  as_id = SYS_MODEM_AS_ID_1;

  if (cmph_is_msim())
  {
    as_id = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2);
  }

  if (!cmph_is_as_id_valid(as_id))
  {
    return ;
  } 
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if there is no hybr2 stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Allocate serving system info buffer */
  ss_info_ptr   = cmss_info_alloc();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Clear the bit mask of all the RSSI bits */
  ss_ptr->info.hybr_gw_changed_fields  &= ~(CMSS_HYBR_GW_SIG_STR_CHANGED_FIELDS_MASK);

  #ifdef CM_GW_SUPPORTED
  if( rpt_ptr != NULL )
  {
    gw_rpt_ptr = rpt_ptr;
  }
  else
  {
     SYS_ARG_NOT_USED( gw_rpt_ptr );
  }
  #else
  SYS_ARG_NOT_USED( rpt_ptr );
  #endif /* GSM || WCDMA */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Handle RSSI for Hybr GW here.
  */
  report_rssi  = FALSE;
  sys_mode     = ss_ptr->info.gw_sys_mode;
  rssi         = ss_ptr->info.gw_rssi;
  rssi_delta   = ph_ptr->rssi_delta;
  current_rssi = 0;

  CM_MSG_HIGH_3("HYBR2 RSSI: sys_mode=%d, rssi=%d, last sys_mode=%d",
                 sys_mode,rssi,
                 ss_ptr->new_srv_avl_info[as_id].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_2)].sys_mode);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch ( sys_mode )
  {
    case SYS_SYS_MODE_NO_SRV:
      ss_ptr->info.gw_sinr = CMSS_SINR_VALUE_NO_SIGNAL;
      ss_ptr->info.gw_io   = CMSS_IO_VALUE_NO_SIGNAL;
      ss_ptr->info.gw_mode_info.gw_info.bit_err_rate
                        = CMSS_BER_VALUE_NO_SIGNAL;

      if ( rssi != CMSS_RSSI_NO_SIGNAL )
      {
        ss_ptr->info.gw_rssi             = CMSS_RSSI_NO_SIGNAL;
        ss_ptr->info.gw_pathloss         = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
        ss_ptr->info.gw_sir              = CMSS_SIR_VALUE_NO_SIGNAL;
        ss_ptr->info.gw2_ecio            = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
        ss_ptr->info.gw_rssi2            = CMSS_RSSI2_NO_SIGNAL;
        ss_ptr->info.gw_rscp             = CMSS_RSCP_NO_SIGNAL;
        ss_ptr->info.gw_ecio_for_display = FALSE;

        report_rssi          = TRUE;
      }
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef CM_GW_SUPPORTED
    case SYS_SYS_MODE_GSM:
    case SYS_SYS_MODE_WCDMA:
    {
      cm_signal_status_type gw_signal_status = {0};

      CM_MSG_MED_3("cmss_report_rssi() sys_mode=%d,, rssi=%d, rssi_delta=%d",
                 sys_mode, rssi, rssi_delta);

      cmss_gwl_get_hybr2_signal_status(sys_mode, &gw_signal_status);

      rssi             = ss_ptr->info.gw_rssi;
      #ifdef FEATURE_UMTS_REPORT_ECIO
      gw_ecio          = ss_ptr->info.gw2_ecio;
      ecio_for_display = ss_ptr->info.gw_ecio_for_display;
      #endif
      sir              = ss_ptr->info.gw_sir;
      pathloss         = ss_ptr->info.gw_pathloss;
      rssi2            = ss_ptr->info.gw_rssi2;
      rscp             = ss_ptr->info.gw_rscp;
      ber              = ss_ptr->info.gw_mode_info.gw_info.bit_err_rate;

      /* Update the rssi and bit err rate if there is a change.
      */
      ss_ptr->info.gw_sinr = CMSS_SINR_VALUE_NO_SIGNAL;
      ss_ptr->info.gw_io   = CMSS_IO_VALUE_NO_SIGNAL;

      {
        #ifdef FEATURE_WCDMA_DATA_FOR_UI_BAR_DISPLAY
        #error code not present
#else
        ss_ptr->hybr_gw_rssi      = (uint16)gw_signal_status.signal_strength;
        #endif
        rssi2                = gw_signal_status.signal_strength;
        ss_ptr->hybr_gw_bit_err_rate = gw_signal_status.bit_error_rate;

        if (sys_mode == SYS_SYS_MODE_GSM)
        {
          ss_ptr->hybr_gw_sir               = CMSS_SIR_VALUE_NO_SIGNAL;
          ss_ptr->hybr_gw_pathloss          = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
          #ifdef FEATURE_UMTS_REPORT_ECIO
          ss_ptr->hybr_gw_rscp              = CMSS_RSCP_NO_SIGNAL;
          ss_ptr->hybr_gw_ecio_for_display  = FALSE;
          /* if sys_mode is GSM always default ecio to
          ** CMSS_ECIO_VALUE_INVALID_SIGNAL
          */
          ss_ptr->hybr_gw_ecio              = CMSS_ECIO_VALUE_INVALID_SIGNAL;
          #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */
        }
        else
        {
          ss_ptr->hybr_gw_sir               = gw_signal_status.sir;
          ss_ptr->hybr_gw_pathloss          = gw_signal_status.pathloss;
          ss_ptr->hybr_gw_rscp              = gw_signal_status.rscp;
          ss_ptr->hybr_gw_ecio_for_display  = gw_signal_status.use_ecio_for_display;
          #ifdef FEATURE_UMTS_REPORT_ECIO
          ss_ptr->hybr_gw_ecio              = gw_signal_status.ecio;
          #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */
        }
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_rssi                     = ss_ptr->hybr_gw_rssi;

      if ( CMABS( rssi - current_rssi ) > rssi_delta )
      {
        ss_ptr->info.gw_rssi = current_rssi;
        ss_ptr->info.gw_rssi2= rssi2;
        report_rssi          = TRUE;
      } /* if delta threshold exceeded */

      current_ber = ss_ptr->hybr_gw_bit_err_rate;

      if ( ber != current_ber )
      {
        ss_ptr->info.gw_mode_info.gw_info.bit_err_rate = current_ber;
        report_rssi          = TRUE;
        CM_MSG_HIGH_2 ("BER change old ber= %d new BER= %d" , ber, current_ber);
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      #ifdef FEATURE_UMTS_REPORT_ECIO
      current_gw_ecio          = ss_ptr->hybr_gw_ecio;
      current_ecio_for_display = ss_ptr->hybr_gw_ecio_for_display;
      if ( CMABS( gw_ecio - current_gw_ecio ) > ecio_delta ||
           (current_ecio_for_display != ecio_for_display) )
      {
        ss_ptr->info.gw2_ecio                = current_gw_ecio;
        ss_ptr->info.gw_ecio_for_display    = current_ecio_for_display;
        report_rssi                         = TRUE;
      } /* if delta threshold exceeded */
      #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_sir                      = ss_ptr->hybr_gw_sir;

      if ( CMABS( sir - current_sir ) >= sir_delta )
      {
        ss_ptr->info.gw_sir   = current_sir;
        report_rssi           = TRUE;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_pathloss        = ss_ptr->hybr_gw_pathloss;

      if ( CMABS( pathloss - current_pathloss ) >= pathloss_delta )
      {
        ss_ptr->info.gw_pathloss = current_pathloss;
        report_rssi              = TRUE;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_rscp = ss_ptr->hybr_gw_rscp;

      if ( CMABS( rscp - current_rscp ) >= CMSS_RSCP_THRESHOLD_DELTA)
      {
        ss_ptr->info.gw_rscp         = current_rscp;
        report_rssi                  = TRUE;
      } /* if delta threshold exceeded */

      break;
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #endif /* defined CM_GW_SUPPORTED) */

    /* TDS-CDMA now supported on HYBR-2 in DSDS */
    #ifdef FEATURE_TDSCDMA
    case SYS_SYS_MODE_TDS:
    {

      /* Update the rssi and bit err rate if there is a change.
      */
      tds_rrc_scell_signal_status_ind_type tds_signal_status = {{0}};

      //values are scaled by 10 as they come directly from MSGR, divide by 10 before using it
      cmss_gwl_get_hybr2_signal_status(SYS_SYS_MODE_TDS, &tds_signal_status);

      current_rssi = tds_signal_status.rssi/10;

      CM_MSG_MED_3( "TDS:cmss_report_hybr_2_rssi() current rssi=%d,, rssi=%d, rssi_delta=%d",
                 current_rssi, rssi, rssi_delta );

      /* As per TDS folks, TDS will always send negative RSSI value for TDSCDMA_RRC_SCELL_SIGNAL_STATUS_IND */
      ss_ptr->hybr_gw_rssi      = CMABS( tds_signal_status.rssi )/10;

      rssi2                     = tds_signal_status.rssi/10;

      ss_ptr->hybr_gw_rscp      = tds_signal_status.rscp/10;

      #ifdef FEATURE_UMTS_REPORT_ECIO
      ss_ptr->hybr_gw_ecio      = tds_signal_status.ecio/10;
      #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */


      current_rssi = ss_ptr->hybr_gw_rssi;
      if ( CMABS( rssi - current_rssi ) > rssi_delta )
      {
        ss_ptr->info.gw_rssi    = current_rssi;
        ss_ptr->info.gw_rssi2    = rssi2;
        report_rssi             = TRUE;

        CM_MSG_MED_3( "TDS:cmss_report_hybr_2_rssi(), rssi=%d, current_rssi=%d, rssi_delta=%d",
                   rssi, current_rssi, rssi_delta );

      } /* if delta threshold exceeded */


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      #ifdef FEATURE_UMTS_REPORT_ECIO
      current_gw_ecio          = ss_ptr->hybr_gw_ecio;
      if ( CMABS( gw_ecio - current_gw_ecio ) > ecio_delta )
      {
        ss_ptr->info.gw_ecio                = current_gw_ecio;
        report_rssi                         = TRUE;
      } /* if delta threshold exceeded */
      #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_rscp = ss_ptr->hybr_gw_rscp;

      if ( CMABS( rscp - current_rscp ) >= CMSS_RSCP_THRESHOLD_DELTA)
      {
        CM_MSG_MED_3( "TDS:cmss_report_hybr_2_rssi(), rscp=%d, current_rscp=%d, rscp_delta=%d",
                   rscp, current_rscp, CMSS_RSCP_THRESHOLD_DELTA );

        ss_ptr->info.gw_rscp            = current_rscp;
        report_rssi                     = TRUE;
      } /* if delta threshold exceeded */

      if ( tds_signal_status.in_dch == TRUE)
      {
        CM_MSG_HIGH_5("TDS:SUB2:ss_ptr->h2_bit_err_rate= %d,old_ber= %d,new_ber=%d in_dch=%d, sir_delta=%d",
			ss_ptr->hybr_gw_bit_err_rate, ber, tds_signal_status.bler, tds_signal_status.in_dch, sir_delta);
        ss_ptr->hybr_gw_sir          = tds_signal_status.sinr / 10;
        ss_ptr->hybr_gw_bit_err_rate = tds_signal_status.bler;


        current_sir = ss_ptr->hybr_gw_sir;

        if ( CMABS( sir - current_sir ) >= sir_delta )
        {
          ss_ptr->info.gw_sir      = current_sir;
          report_rssi              = TRUE;
          CM_MSG_MED_3( "TDS:cmss_report_hybr_2_rssi(), sir=%d, current_sir=%d, sir_delta=%d",
                   sir, current_sir, sir_delta );
        }//if there is difference in sinr level

        current_ber = ss_ptr->hybr_gw_bit_err_rate;
        if ( ber != current_ber )
        {
          ss_ptr->info.gw_mode_info.gw_info.bit_err_rate = current_ber;
          report_rssi          = TRUE;
          CM_MSG_HIGH_2 ( "TDS:BER change old ber= %d new BER= %d", ber, current_ber);
        }

      } // if in_dch is valid
      else
      {
        if(ber != CMSS_BER_VALUE_NO_SIGNAL)
        {
          CM_MSG_HIGH_2 ("TDS:SUB2:Resettng the BLER value ber= %d,ss_ptr->bit_err_rate=%d",ber,ss_ptr->bit_err_rate);
          ss_ptr->info.gw_mode_info.gw_info.bit_err_rate = 0xff;
          ss_ptr->hybr_gw_bit_err_rate = 0xff;
          report_rssi           = TRUE;
        }
        ss_ptr->info.gw_sir = 0xff;
      }

      break;
    }
    #endif

    #if defined FEATURE_CM_LTE
    case SYS_SYS_MODE_LTE:
    {
      lte_cphy_rssi_ind_s lte_rpt = {{0}};

      cmss_gwl_get_hybr2_signal_status(SYS_SYS_MODE_LTE, &lte_rpt);

        CM_MSG_MED_3("LTE:cmss_report_rssi(), rssi=%d, current_rssi=%d, rssi_delta=%d",
                   rssi, current_rssi, rssi_delta);

        /*lint -save -e571 */
      current_rssi = (uint16)CMABS(lte_rpt.rssi);
        /*lint -restore */
        if ( CMABS( rssi - current_rssi ) > rssi_delta )
        {
          ss_ptr->info.gw_rssi        = current_rssi;

          report_rssi                 = TRUE;
        } /* if delta threshold exceeded */

      current_rsrp = lte_rpt.rsrp;
        CM_MSG_MED_3("LTE:cmss_report_rssi(), rsrp=%d, current_rsrp=%d, rsrp_delta=%d",
                   rsrp, current_rsrp, rsrp_delta);
        if ( CMABS( rsrp - current_rsrp ) >= rsrp_delta)
        {
          ss_ptr->info.gwl_rsrp        = current_rsrp;

          report_rssi                  = TRUE;
        } /* if delta threshold exceeded */

      current_rsrq = lte_rpt.rsrq;
        CM_MSG_MED_3("LTE:cmss_report_rssi(), rsrq=%d, current_rsrq=%d, rsrq_delta=%d",
                      rsrq, current_rsrq, rsrq_delta);
        if ( CMABS( rsrq - current_rsrq ) >= rsrq_delta)
        {
          ss_ptr->info.gwl_rsrq        = current_rsrq;

          report_rssi                  = TRUE;
        } /* if delta threshold exceeded */

      if ( lte_rpt.sinr_valid == TRUE)
        {
        current_lte_sinr = (byte)lte_rpt.log_sinr_10xdB;

          CM_MSG_MED_2("LTE:cmss_report_rssi(),sinr=%d, current_sinr=%d",
                   sinr, current_lte_sinr);

          if(current_lte_sinr != sinr )
          {
            ss_ptr->info.gw_sinr = current_lte_sinr;
            report_rssi              = TRUE;
          } /* if there is difference in sinr level */
        } /* if sinr is valid  */

      break;
    }
    #endif

    default:
      break;
  }

  if (( report_rssi || ignore_updates ) &&
     !(ss_ptr->info.gw_rssi >= CMSS_RRC_RSSI_NO_SIGNAL && ph_ptr->qmss_enabled && ss_ptr->info.gw_srv_status == SYS_SRV_STATUS_SRV)
     )
  {
    /*
    ** Inform the clients that the RSSI was modified.
    */
    switch( sys_mode )
    {
      case SYS_SYS_MODE_GSM:
      case SYS_SYS_MODE_WCDMA:
      case SYS_SYS_MODE_GW:
      case SYS_SYS_MODE_LTE:
      case SYS_SYS_MODE_TDS:

        if(client_ptr != NULL)
        {
          /* Copy serving system state information into
          ** allocated buffer.
          */
          (void) cmss_info_get( ss_info_ptr, &ss_ptr->info );
          cmss_get_signal_strength_info_change (ss_info_ptr, ss_ptr);
          cm_client_ss_event_ntfy(client_ptr, CM_SS_EVENT_RSSI, ss_info_ptr);
        }
        else
        {
          cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_RSSI );
        }
        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      default:
        if(client_ptr != NULL)
        {
          cmss_get_signal_strength_info_change (ss_info_ptr, ss_ptr);
          cm_client_ss_event_ntfy(client_ptr, CM_SS_EVENT_RSSI, ss_info_ptr);
        }
        else
        {
          cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_RSSI );
        }
        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    }
  } /* if ( report_rssi ) */

    /* Deallocate the dynamically allocated memory after sending the ss event. */
  cm_mem_free(ss_info_ptr);

} /* cmss_report_hybr_2_rssi() */
/*lint +esym(715,rpt_ptr)*/
#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================
FUNCTION cmss_gwl_get_hybr3_signal_status

DESCRIPTION
  This function fetches the RSSI of the given mode from cmss_gwl_signal_status.

DEPENDENCIES


RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_gwl_get_hybr3_signal_status(sys_sys_mode_e_type  sys_mode, void *signal_status_ptr)
{
  #ifndef CM_GW_SUPPORTED
  SYS_ARG_NOT_USED(sys_mode);
  SYS_ARG_NOT_USED(signal_status_ptr);
  return;
  #else

  CM_MSG_HIGH_1("cmss_gwl_get_hybr3_signal_status(), mode=%d",  sys_mode);
  switch (sys_mode)
  {
    case SYS_SYS_MODE_GSM:
    {
      *((cm_signal_status_type*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_g_hybr_3));
    }
    break;
    case SYS_SYS_MODE_WCDMA:
    {
      *((cm_signal_status_type*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_w));
    }
    break;
    
    case  SYS_SYS_MODE_LTE:
    #ifdef FEATURE_CM_LTE
    {
      *((lte_cphy_rssi_ind_s*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_lte));
    }
    #endif
    break;
    
    case SYS_SYS_MODE_TDS:
    #if defined(FEATURE_TDSCDMA) 
    {
      *((tds_rrc_scell_signal_status_ind_type*)signal_status_ptr) = *(&(cmss_gwl_signal_status.signal_status_tds_main));
    }
    #endif
    break;

    default:
      CM_MSG_HIGH_1 ("Invalid mode(%d) passed to cmss_gwl_get_hybr3_signal_status" , sys_mode);
    break;
  }
  #endif
}

/*===========================================================================
FUNCTION cmss_report_hybr_3_rssi

DESCRIPTION
  This function gets the RSSI. If the RSSI change exceeds the delta threshold,
  CM reports rssi change event to registered clients.

DEPENDENCIES
  Serving System and Phone objects must be initialized

RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_report_hybr_3_rssi (

  const void              *rpt_ptr,
    /* ptr to message received */

  cm_client_s_type        *client_ptr,
    /* pointer to a client struct */

  boolean                 ignore_updates
    /* flag to ignore any RSSI changes and always send RSSI events */

)
/*lint -esym(715,rpt_ptr)*/
{
  cmss_s_type          *ss_ptr       = cmss_ptr();
  cmph_s_type          *ph_ptr       = cmph_ptr();

  cm_mm_ss_info_s_type *ss_info_ptr;
      /* serving system info buffer */

  sys_sys_mode_e_type   sys_mode     = ss_ptr->info.gw3_sys_mode;
  uint16                rssi         = ss_ptr->info.gw3_rssi;
  uint16                current_rssi = 0;
  uint8                 rssi_delta   = ph_ptr->rssi_delta;

  #if defined(FEATURE_UMTS_REPORT_ECIO)
  uint8                 ecio_delta   = ph_ptr->ecio_delta;
  #endif

  #if (defined CM_GW_SUPPORTED && defined FEATURE_UMTS_REPORT_ECIO)
  int16                 gw_ecio         = ss_ptr->info.gw3_ecio;
  int16                 current_gw_ecio = 0;
  #endif /* #if ...FEATURE_UMTS_REPORT_ECIO */

  #ifdef CM_GW_SUPPORTED
  int16                 pathloss         = ss_ptr->info.gw3_pathloss;
  int16                 current_pathloss = 0;
  int16                 sir              = ss_ptr->info.gw3_sir;
  int16                 current_sir      = 0;
  int16                 rssi2            = ss_ptr->info.gw3_rssi2;
  int16                 rscp             = ss_ptr->info.gw3_rscp;
  int16                 current_rscp     = 0;
  uint8                 sir_delta        = ph_ptr->sir_delta;
  uint8                 pathloss_delta   = ph_ptr->pathloss_delta;
  uint8                 ber              = ss_ptr->info.gw3_mode_info.gw_info.bit_err_rate;
  uint8                 current_ber      = CMSS_BER_VALUE_NO_SIGNAL;

  #ifdef FEATURE_CM_LTE
  int16                 rsrp             = ss_ptr->info.gw3_rsrp;
  int16                 current_rsrp     = 0;
  int8                  rsrq             = ss_ptr->info.gw3_rsrq;
  int8                  current_rsrq     = 0;
  byte                  current_lte_sinr = 0;
  uint8                 rsrp_delta       = ph_ptr->rsrp_delta;
  uint8                 rsrq_delta       = ph_ptr->rsrq_delta;
  byte                  sinr             = ss_ptr->info.gw3_sinr;
  #endif

  const     cm_rpt_type *gw_rpt_ptr      = NULL;
  #endif

  #if ((defined CM_GW_SUPPORTED) && \
     defined(FEATURE_UMTS_REPORT_ECIO))
  boolean               ecio_for_display         = ss_ptr->info.gw3_ecio_for_display;
  boolean               current_ecio_for_display = FALSE;
  #endif

  boolean               report_rssi              = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if there is no hybr2 stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Allocate serving system info buffer */
  ss_info_ptr   = cmss_info_alloc();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Clear the bit mask of all the RSSI bits */
  ss_ptr->info.gw3_changed_fields  &= ~(CMSS_HYBR_GW_SIG_STR_CHANGED_FIELDS_MASK);

  #ifdef CM_GW_SUPPORTED
  if( rpt_ptr != NULL )
  {
    gw_rpt_ptr = rpt_ptr;
  }
  else
  {
     SYS_ARG_NOT_USED( gw_rpt_ptr );
  }
  #else
  SYS_ARG_NOT_USED( rpt_ptr );
  #endif /* GSM || WCDMA */

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Handle RSSI for Hybr GW here.
  */
  report_rssi  = FALSE;
  sys_mode     = ss_ptr->info.gw3_sys_mode;
  rssi         = ss_ptr->info.gw3_rssi;
  rssi_delta   = ph_ptr->rssi_delta;
  current_rssi = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch ( sys_mode )
  {
    case SYS_SYS_MODE_NO_SRV:
      ss_ptr->info.gw3_sinr = CMSS_SINR_VALUE_NO_SIGNAL;
      ss_ptr->info.gw3_io   = CMSS_IO_VALUE_NO_SIGNAL;
      ss_ptr->info.gw3_mode_info.gw_info.bit_err_rate
                        = CMSS_BER_VALUE_NO_SIGNAL;

      if ( rssi != CMSS_RSSI_NO_SIGNAL )
      {
        ss_ptr->info.gw3_rssi             = CMSS_RSSI_NO_SIGNAL;
        ss_ptr->info.gw3_pathloss         = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
        ss_ptr->info.gw3_sir              = CMSS_SIR_VALUE_NO_SIGNAL;
        ss_ptr->info.gw3_ecio            = CMSS_ECIO_VALUE_NO_SIGNAL_UMTS;
        ss_ptr->info.gw3_rssi2            = CMSS_RSSI2_NO_SIGNAL;
        ss_ptr->info.gw3_rscp             = CMSS_RSCP_NO_SIGNAL;
        ss_ptr->info.gw3_ecio_for_display = FALSE;

        report_rssi          = TRUE;
      }
      break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef CM_GW_SUPPORTED
    case SYS_SYS_MODE_GSM:
    case SYS_SYS_MODE_WCDMA:
    {
      cm_signal_status_type gw_signal_status = {0};

      CM_MSG_MED_3("hybr3:cmss_report_hybr_3_rssi() sys_mode=%d,, rssi=%d, rssi_delta=%d",
                 sys_mode, rssi, rssi_delta);

      cmss_gwl_get_hybr3_signal_status(sys_mode, &gw_signal_status);

      rssi             = ss_ptr->info.gw3_rssi;
      #ifdef FEATURE_UMTS_REPORT_ECIO
      gw_ecio          = ss_ptr->info.gw3_ecio;
      ecio_for_display = ss_ptr->info.gw3_ecio_for_display;
      #endif
      sir              = ss_ptr->info.gw3_sir;
      pathloss         = ss_ptr->info.gw3_pathloss;
      rssi2            = ss_ptr->info.gw3_rssi2;
      rscp             = ss_ptr->info.gw3_rscp;
      ber              = ss_ptr->info.gw3_mode_info.gw_info.bit_err_rate;

      /* Update the rssi and bit err rate if there is a change.
      */
      ss_ptr->info.gw3_sinr = CMSS_SINR_VALUE_NO_SIGNAL;
      ss_ptr->info.gw3_io   = CMSS_IO_VALUE_NO_SIGNAL;

      {
        #ifdef FEATURE_WCDMA_DATA_FOR_UI_BAR_DISPLAY
        #error code not present
#else
        ss_ptr->hybr_3_gw_rssi      = (uint16)gw_signal_status.signal_strength;
        #endif
        rssi2                = gw_signal_status.signal_strength;
        ss_ptr->hybr_3_gw_bit_err_rate = gw_signal_status.bit_error_rate;

        if (sys_mode == SYS_SYS_MODE_GSM)
        {
          ss_ptr->hybr_3_gw_sir               = CMSS_SIR_VALUE_NO_SIGNAL;
          ss_ptr->hybr_3_gw_pathloss          = CMSS_PATHLOSS_VALUE_NO_SIGNAL;
          #ifdef FEATURE_UMTS_REPORT_ECIO
          ss_ptr->hybr_3_gw_rscp              = CMSS_RSCP_NO_SIGNAL;
          ss_ptr->hybr_3_gw_ecio_for_display  = FALSE;
          /* if sys_mode is GSM always default ecio to
          ** CMSS_ECIO_VALUE_INVALID_SIGNAL
          */
          ss_ptr->hybr_3_gw_ecio              = CMSS_ECIO_VALUE_INVALID_SIGNAL;
          #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */
        }
        else
        {
          ss_ptr->hybr_3_gw_sir               = gw_signal_status.sir;
          ss_ptr->hybr_3_gw_pathloss          = gw_signal_status.pathloss;
          ss_ptr->hybr_3_gw_rscp              = gw_signal_status.rscp;
          ss_ptr->hybr_3_gw_ecio_for_display  = gw_signal_status.use_ecio_for_display;
          #ifdef FEATURE_UMTS_REPORT_ECIO
          ss_ptr->hybr_3_gw_ecio              = gw_signal_status.ecio;
          #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */
        }
      }
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_rssi                     = ss_ptr->hybr_3_gw_rssi;


      if ( CMABS( rssi - current_rssi ) > rssi_delta )
      {
        ss_ptr->info.gw3_rssi = current_rssi;
        ss_ptr->info.gw3_rssi2= rssi2;
        report_rssi          = TRUE;
      } /* if delta threshold exceeded */

      current_ber = ss_ptr->hybr_3_gw_bit_err_rate;

      if ( ber != current_ber )
      {
        ss_ptr->info.gw3_mode_info.gw_info.bit_err_rate = current_ber;
        report_rssi          = TRUE;
        CM_MSG_HIGH_2 ("Hybr3: BER change old ber= %d new BER= %d" , ber, current_ber);
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      #ifdef FEATURE_UMTS_REPORT_ECIO
      current_gw_ecio          = ss_ptr->hybr_3_gw_ecio;
      current_ecio_for_display = ss_ptr->hybr_3_gw_ecio_for_display;
      if ( CMABS( gw_ecio - current_gw_ecio ) > ecio_delta ||
           (current_ecio_for_display != ecio_for_display) )
      {
        ss_ptr->info.gw3_ecio                = current_gw_ecio;
        ss_ptr->info.gw3_ecio_for_display    = current_ecio_for_display;
        report_rssi                         = TRUE;
      } /* if delta threshold exceeded */
      #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_sir                      = ss_ptr->hybr_3_gw_sir;

      if ( CMABS( sir - current_sir ) >= sir_delta )
      {
        ss_ptr->info.gw3_sir   = current_sir;
        report_rssi           = TRUE;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_pathloss        = ss_ptr->hybr_3_gw_pathloss;

      if ( CMABS( pathloss - current_pathloss ) >= pathloss_delta )
      {
        ss_ptr->info.gw3_pathloss = current_pathloss;
        report_rssi              = TRUE;
      }

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_rscp = ss_ptr->hybr_3_gw_rscp;

      if ( CMABS( rscp - current_rscp ) >= CMSS_RSCP_THRESHOLD_DELTA)
      {
        ss_ptr->info.gw3_rscp         = current_rscp;
        report_rssi                  = TRUE;
      } /* if delta threshold exceeded */

      break;
    }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #endif /* defined CM_GW_SUPPORTED) */

    /* TDS-CDMA now supported on HYBR-2 in DSDS */
    #ifdef FEATURE_TDSCDMA
    case SYS_SYS_MODE_TDS:
    {

      /* Update the rssi and bit err rate if there is a change.
      */
      tds_rrc_scell_signal_status_ind_type tds_signal_status = {{0}};

      //values are scaled by 10 as they come directly from MSGR, divide by 10 before using it
      cmss_gwl_get_hybr3_signal_status(SYS_SYS_MODE_TDS, &tds_signal_status);

      current_rssi = tds_signal_status.rssi/10;

      CM_MSG_MED_3( "hybr3: TDS:cmss_report_hybr_3_rssi() current rssi=%d,, rssi=%d, rssi_delta=%d",
                 current_rssi, rssi, rssi_delta );

      /* As per TDS folks, TDS will always send negative RSSI value for TDSCDMA_RRC_SCELL_SIGNAL_STATUS_IND */
      ss_ptr->hybr_3_gw_rssi      = CMABS( tds_signal_status.rssi )/10;

      rssi2                     = tds_signal_status.rssi/10;

      ss_ptr->hybr_3_gw_rscp      = tds_signal_status.rscp/10;

      #ifdef FEATURE_UMTS_REPORT_ECIO
      ss_ptr->hybr_3_gw_ecio      = tds_signal_status.ecio/10;
      #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */


      current_rssi = ss_ptr->hybr_3_gw_rssi;
      if ( CMABS( rssi - current_rssi ) > rssi_delta )
      {
        ss_ptr->info.gw3_rssi    = current_rssi;
        ss_ptr->info.gw3_rssi2    = rssi2;
        report_rssi             = TRUE;

        CM_MSG_MED_3( "hybr3: TDS:cmss_report_hybr_3_rssi(), rssi=%d, current_rssi=%d, rssi_delta=%d",
                   rssi, current_rssi, rssi_delta );

      } /* if delta threshold exceeded */


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      #ifdef FEATURE_UMTS_REPORT_ECIO
      current_gw_ecio          = ss_ptr->hybr_3_gw_ecio;
      if ( CMABS( gw_ecio - current_gw_ecio ) > ecio_delta )
      {
        ss_ptr->info.gw3_ecio                = current_gw_ecio;
        report_rssi                         = TRUE;
      } /* if delta threshold exceeded */
      #endif /* #ifdef FEATURE_UMTS_REPORT_ECIO */

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      current_rscp = ss_ptr->hybr_3_gw_rscp;

      if ( CMABS( rscp - current_rscp ) >= CMSS_RSCP_THRESHOLD_DELTA)
      {
        CM_MSG_MED_3( "hybr3: TDS:cmss_report_hybr_3_rssi(), rscp=%d, current_rscp=%d, rscp_delta=%d",
                   rscp, current_rscp, CMSS_RSCP_THRESHOLD_DELTA );

        ss_ptr->info.gw3_rscp            = current_rscp;
        report_rssi                     = TRUE;
      } /* if delta threshold exceeded */

      if ( tds_signal_status.in_dch == TRUE)
      {
        ss_ptr->hybr_3_gw_sir          = tds_signal_status.sinr / 10;
        ss_ptr->hybr_3_gw_bit_err_rate = tds_signal_status.bler;

        CM_MSG_MED_2( "hybr3: TDS:cmss_report_hybr_3_rssi(),in_dch=%d, sir_delta=%d",
                   tds_signal_status.in_dch, sir_delta);

        current_sir = ss_ptr->hybr_3_gw_sir;

        if ( CMABS( sir - current_sir ) >= sir_delta )
        {
          ss_ptr->info.gw3_sir      = current_sir;
          report_rssi              = TRUE;
          CM_MSG_MED_3( "hybr3:TDS:cmss_report_hybr_3_rssi(), sir=%d, current_sir=%d, sir_delta=%d",
                   sir, current_sir, sir_delta );
        }//if there is difference in sinr level

        current_ber = ss_ptr->hybr_3_gw_bit_err_rate;
        if ( ber != current_ber )
        {
          ss_ptr->info.gw3_mode_info.gw_info.bit_err_rate = current_ber;
          report_rssi          = TRUE;
          CM_MSG_HIGH_2 ( "Hybr3: TDS:BER change old ber= %d new BER= %d", ber, current_ber);
        }

      } // if in_dch is valid
      else
      {
        if(ber != CMSS_BER_VALUE_NO_SIGNAL)
        {
          CM_MSG_HIGH_2 ("TDS:hybr3:Resettng the BLER value ber= %d,ss_ptr bit_err_rate=%d",
                         ber,
                         ss_ptr->info.gw3_mode_info.gw_info.bit_err_rate);
          ss_ptr->info.gw3_mode_info.gw_info.bit_err_rate = 0xff;
          ss_ptr->hybr_3_gw_bit_err_rate = 0xff;
          report_rssi           = TRUE;
        }
        ss_ptr->info.gw3_sir = 0xff;
      }

      break;
    }
    #endif

    #if defined FEATURE_CM_LTE
    case SYS_SYS_MODE_LTE:
    {
      lte_cphy_rssi_ind_s lte_rpt = {{0}};

      cmss_gwl_get_hybr3_signal_status(SYS_SYS_MODE_LTE, &lte_rpt);

        CM_MSG_MED_3("HYBR3_LTE:cmss_report_hybr_3_rssi(), rssi=%d, current_rssi=%d, rssi_delta=%d",
                   rssi, current_rssi, rssi_delta);

        /*lint -save -e571 */
      current_rssi = (uint16)CMABS(lte_rpt.rssi);
        /*lint -restore */
        if ( CMABS( rssi - current_rssi ) > rssi_delta )
        {
          ss_ptr->info.gw3_rssi        = current_rssi;

          report_rssi                 = TRUE;
        } /* if delta threshold exceeded */

      current_rsrp = lte_rpt.rsrp;
        CM_MSG_MED_3("LTE:cmss_report_hybr_3_rssi(), rsrp=%d, current_rsrp=%d, rsrp_delta=%d",
                   rsrp, current_rsrp, rsrp_delta);
        if ( CMABS( rsrp - current_rsrp ) >= rsrp_delta)
        {
          ss_ptr->info.gw3_rsrp        = current_rsrp;

          report_rssi                  = TRUE;
        } /* if delta threshold exceeded */

      current_rsrq = lte_rpt.rsrq;
        CM_MSG_MED_3("LTE:cmss_report_hybr_3_rssi(), rsrq=%d, current_rsrq=%d, rsrq_delta=%d",
                      rsrq, current_rsrq, rsrq_delta);
        if ( CMABS( rsrq - current_rsrq ) >= rsrq_delta)
        {
          ss_ptr->info.gw3_rsrq        = current_rsrq;

          report_rssi                  = TRUE;
        } /* if delta threshold exceeded */

      if ( lte_rpt.sinr_valid == TRUE)
        {
        current_lte_sinr = (byte)lte_rpt.log_sinr_10xdB;

          CM_MSG_MED_2("LTE:cmss_report_hybr_3_rssi(),sinr=%d, current_sinr=%d",
                   sinr, current_lte_sinr);

          if(current_lte_sinr != sinr )
          {
            ss_ptr->info.gw3_sinr = current_lte_sinr;
            report_rssi              = TRUE;
          } /* if there is difference in sinr level */
        } /* if sinr is valid  */

      break;
    }
    #endif

    default:
      break;
  }

  if (( report_rssi || ignore_updates ) &&
     !(ss_ptr->info.gw3_rssi >= CMSS_RRC_RSSI_NO_SIGNAL && ph_ptr->qmss_enabled && ss_ptr->info.gw3_srv_status == SYS_SRV_STATUS_SRV)
     )
  {
    /*
    ** Inform the clients that the RSSI was modified.
    */
    switch( sys_mode )
    {
      case SYS_SYS_MODE_GSM:
      case SYS_SYS_MODE_WCDMA:
      case SYS_SYS_MODE_GW:
      case SYS_SYS_MODE_LTE:
      case SYS_SYS_MODE_TDS:

        if(client_ptr != NULL)
        {
          /* Copy serving system state information into
          ** allocated buffer.
          */
          (void) cmss_info_get( ss_info_ptr, &ss_ptr->info );
          cmss_get_signal_strength_info_change (ss_info_ptr, ss_ptr);
          cm_client_ss_event_ntfy(client_ptr, CM_SS_EVENT_RSSI, ss_info_ptr);
        }
        else
        {
          cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_RSSI );
        }
        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

      default:
        if(client_ptr != NULL)
        {
          cmss_get_signal_strength_info_change (ss_info_ptr, ss_ptr);
          cm_client_ss_event_ntfy(client_ptr, CM_SS_EVENT_RSSI, ss_info_ptr);
        }
        else
        {
          cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_RSSI );
        }
        break;
      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    }
  } /* if ( report_rssi ) */

    /* Deallocate the dynamically allocated memory after sending the ss event. */
  cm_mem_free(ss_info_ptr);

} /* cmss_report_hybr_3_rssi() */
#endif
/*===========================================================================
FUNCTION cmss_gwl_store_hybr_2_rssi_info

DESCRIPTION
  This function stores the RSSI value got from RR/RRC indication into
cmss_gwl_signal_status.

DEPENDENCIES


RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_gwl_store_hybr_2_rssi_info ( sys_sys_mode_e_type sys_mode, const void *signal_status_ptr)
{
  #ifndef CM_GW_SUPPORTED
  SYS_ARG_NOT_USED(sys_mode);
  SYS_ARG_NOT_USED(signal_status_ptr);
  return;
  #else

  CM_MSG_HIGH_1("cmss_gwl_store_hybr_2_rssi_info(), mode=%d",  sys_mode);
  rex_enter_crit_sect(cmtask_crit_sect_ptr());
  switch (sys_mode)
  {
    case SYS_SYS_MODE_GSM:
    {
      *(&(cmss_gwl_signal_status.signal_status_g_hybr)) = *((cm_signal_status_type*)signal_status_ptr);
    }
    break;
    case SYS_SYS_MODE_WCDMA:
    {
      *(&(cmss_gwl_signal_status.signal_status_w)) = *((cm_signal_status_type*)signal_status_ptr);
    }
    break;
    #ifdef FEATURE_CM_LTE
    case  SYS_SYS_MODE_LTE:
    {
      *(&(cmss_gwl_signal_status.signal_status_lte)) = *((lte_cphy_rssi_ind_s*)signal_status_ptr);
    }
    break;
    #endif

    #ifdef FEATURE_TDSCDMA
    case SYS_SYS_MODE_TDS:
    {
      *(&(cmss_gwl_signal_status.signal_status_tds_main)) = *((tds_rrc_scell_signal_status_ind_type*)signal_status_ptr);
    }
    break;
    #endif

    default:
    break;
  }
  rex_leave_crit_sect(cmtask_crit_sect_ptr());

  #endif
}

/*lint +esym(715,rpt_ptr)*/

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================
FUNCTION cmss_gwl_store_hybr_3_rssi_info

DESCRIPTION
  This function stores the RSSI value got from RR/RRC indication into
cmss_gwl_signal_status.

DEPENDENCIES


RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_gwl_store_hybr_3_rssi_info ( sys_sys_mode_e_type sys_mode, const void *signal_status_ptr)
{
  #ifndef CM_GW_SUPPORTED
  SYS_ARG_NOT_USED(sys_mode);
  SYS_ARG_NOT_USED(signal_status_ptr);
  return;
  #else

  CM_MSG_HIGH_1("cmss_gwl_store_hybr_3_rssi_info(), mode=%d",  sys_mode);
  rex_enter_crit_sect(cmtask_crit_sect_ptr());
  switch (sys_mode)
  {
    case SYS_SYS_MODE_GSM:
    {
      *(&(cmss_gwl_signal_status.signal_status_g_hybr_3)) = *((cm_signal_status_type*)signal_status_ptr);
    }
    break;
    case SYS_SYS_MODE_WCDMA:
    {
      *(&(cmss_gwl_signal_status.signal_status_w)) = *((cm_signal_status_type*)signal_status_ptr);
    }
    break;
    
    #ifdef FEATURE_CM_LTE
    case  SYS_SYS_MODE_LTE:
    {
      *(&(cmss_gwl_signal_status.signal_status_lte)) = *((lte_cphy_rssi_ind_s*)signal_status_ptr);
    }
    break;
    #endif

    #if defined(FEATURE_TDSCDMA) 
    case SYS_SYS_MODE_TDS:
    {
      *(&(cmss_gwl_signal_status.signal_status_tds_main)) = *((tds_rrc_scell_signal_status_ind_type*)signal_status_ptr);
    }
    break;
    #endif

    default:
    break;
  }
  rex_leave_crit_sect(cmtask_crit_sect_ptr());

  #endif
}

/*lint +esym(715,rpt_ptr)*/
#endif
/*===========================================================================

FUNCTION  cmss_ss_cmd_get_ss_info_para_check

DESCRIPTION
  Check parameter errors for get serving system info command

DEPENDENCIES
  none

RETURN VALUE
  CM_SS_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_ss_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ss_cmd_err_e_type  cmss_ss_cmd_get_ss_info_para_check(

  const cm_ss_cmd_s_type     *ss_cmd_ptr

)
{
  cm_ss_cmd_err_e_type   cmd_err       = CM_SS_CMD_ERR_NOERR;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Check integrity of command parameters */
  if( ss_cmd_ptr->client_ptr == CM_CLIENT_PTR_NONE )
  {
    cmd_err  = CM_SS_CMD_ERR_CLIENT_ID_P;
    CM_ERR_0( "CM_SS_CMD_ERR_CLIENT_ID_P");
  }
  else if( (ss_cmd_ptr->client_ptr)->init_mask != CM_INIT_MASK )
  {
    cmd_err  = CM_SS_CMD_ERR_CLIENT_ID_P;
    CM_ERR_0( "CM_SS_CMD_ERR_CLIENT_ID_P");
  }

  return cmd_err;

} /* cmss_ss_cmd_get_ss_info_para_check() */

#if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))

/*===========================================================================

FUNCTION  cmss_ss_cmd_get_cell_dch_info_para_check

DESCRIPTION
  Check parameter errors for get dch cell info command

DEPENDENCIES
  none

RETURN VALUE
  CM_SS_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_ss_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ss_cmd_err_e_type  cmss_ss_cmd_get_cell_dch_info_para_check(

    const cm_ss_cmd_s_type   *ss_cmd_ptr

)
{
  cm_ss_cmd_err_e_type   cmd_err       = CM_SS_CMD_ERR_NOERR;
  cmss_s_type            *ss_ptr       = cmss_ptr();
  cmph_s_type            *ph_ptr       = cmph_ptr();

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Check integrity of command parameters */
  if( ss_cmd_ptr->client_ptr == CM_CLIENT_PTR_NONE )
  {
    cmd_err  = CM_SS_CMD_ERR_CLIENT_ID_P;
    CM_ERR_0( "CM_SS_CMD_ERR_CLIENT_ID_P");
  }
  else if( (ss_cmd_ptr->client_ptr)->init_mask != CM_INIT_MASK )
  {
    cmd_err  = CM_SS_CMD_ERR_CLIENT_ID_P;
    CM_ERR_0( "CM_SS_CMD_ERR_CLIENT_ID_P");
  }

  if (ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE)
  {
    cmd_err  = CM_SS_CMD_ERR_INCORRECT_MODE_S;
    CM_ERR_0( "Not in Online Mode: CM_SS_CMD_ERR_INCORRECT_MODE_S");
  }

  if(ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_REQ)
  {
    cmd_err  = CM_SS_CMD_ERR_DUP_DCH_CMD;
    CM_MSG_MED_0( "Duplicate DCH flag: CM_SS_CMD_ERR_DUP_DCH_CMD");
  }

  /* Check whether the current system is WCDMA or not*/

  if (cmph_is_msim())
  {
    if((ss_ptr->info.gw_sys_mode != SYS_SYS_MODE_WCDMA) &&
       (cmph_is_lte_capable_on_ss(CM_SS_HYBR_2)) &&
       !cmph_is_sxlte())
    {
      cmd_err  = CM_SS_CMD_ERR_OTHER;
      CM_ERR_0( "Hybr-2:sys_mode is not WCDMA: CM_SS_CMD_ERR_SRV_STATE_S");
    }
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  else if ((ss_ptr->info.gw3_sys_mode != SYS_SYS_MODE_WCDMA) &&
           (cmph_is_lte_capable_on_ss(CM_SS_HYBR_3)))
   {
     cmd_err  = CM_SS_CMD_ERR_OTHER;
     CM_ERR_0( "Hybr-3:sys_mode is not WCDMA: CM_SS_CMD_ERR_SRV_STATE_S");
  }
  #endif
  else if ((ss_ptr->info.sys_mode != SYS_SYS_MODE_WCDMA) &&
           (cmph_is_lte_capable_on_ss(CM_SS_MAIN)))
    {
       cmd_err  = CM_SS_CMD_ERR_OTHER;
       CM_ERR_0( "sys_mode is not WCDMA: CM_SS_CMD_ERR_SRV_STATE_S");
    }
  }
  else if (ss_ptr->info.sys_mode != SYS_SYS_MODE_WCDMA)
  {
    cmd_err  = CM_SS_CMD_ERR_OTHER;
    CM_ERR_0( "sys_mode is not WCDMA: CM_SS_CMD_ERR_SRV_STATE_S");
  }
  return cmd_err;
}

#endif

#if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))

/*===========================================================================

FUNCTION  cmss_ss_cmd_ps_data_avail_para_check

DESCRIPTION
  Check parameter errors for ps data available request.

DEPENDENCIES
  none

RETURN VALUE
  CM_SS_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_ss_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ss_cmd_err_e_type  cmss_ss_cmd_ps_data_avail_para_check(

       cm_ss_cmd_s_type      *ss_cmd_ptr
)
{
  cmph_s_type            *ph_ptr     = cmph_ptr();
      /* Pointer point to phone object */

  cm_ss_cmd_err_e_type   cmd_err     = CM_SS_CMD_ERR_NOERR;
  sd_si_info_s_type      si_info;
  boolean                is_active_voice_call = FALSE;

  sd_ss_e_type ss = SD_SS_MAIN;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_cmd_ptr != NULL);
  CM_ASSERT(ph_ptr     != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if (ss_cmd_ptr == NULL)
  {
    CM_ERR_0("ss_cmd_ptr NULL ptr");
    return cmd_err;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if (cmph_is_ssim())
  {
    ss_cmd_ptr->cmd_subs = SYS_MODEM_AS_ID_1;
  }
  else if (ss_cmd_ptr->cmd_subs == SYS_MODEM_AS_ID_NONE ||
         ss_cmd_ptr->cmd_subs == SYS_MODEM_AS_ID_MAX ||
         ss_cmd_ptr->cmd_subs == SYS_MODEM_AS_ID_NO_CHANGE
  )
  {
    ss_cmd_ptr->cmd_subs = ph_ptr->default_data_subs;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  sd_si_info_ptr_get(cmph_map_subs_to_sd_ss(ss_cmd_ptr->cmd_subs), &si_info);

  if( cmcall_is_there_a_call_type_per_sub(ss_cmd_ptr->cmd_subs, CM_CALL_TYPE_VOICE, NULL)
      != CM_CALL_ID_INVALID)
  {
    is_active_voice_call = TRUE;
  }

  if( ss_cmd_ptr->client_ptr == CM_CLIENT_PTR_NONE ||
      (ss_cmd_ptr->client_ptr)->init_mask != CM_INIT_MASK
    )
  {
    /*  Make sure the client has a valid ID.
    */
    cmd_err  = CM_SS_CMD_ERR_CLIENT_ID_P;
  }
  else if( ph_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE )
  {
    /* Reject the command if phone is not online.
    */
    cmd_err = CM_SS_CMD_ERR_OFFLINE_S;
  }
  /*
  **Reject the command if:
  **1. UE is in emergency call.
  **2. UE is in active voice call with
  **  a. Service does not have PS domain.
  **  b. UE does not have service and is currently scanning for it. 
  **     We dont want the command to cause unexpected scan behaviour.
  */
  else if( cmcall_emergency_call_active() == TRUE
           ||
           (is_active_voice_call &&
            (si_info.srv_domain == SYS_SRV_DOMAIN_CS_ONLY ||
             !sys_srv_status_is_srv(si_info.srv_status))
           )
         )
  {
    /* Reject the command if we have voice call with
    ** CS_ONLY serving domain
    */
    CM_MSG_HIGH_0("ps_data_avail: error! (CS domain) ERR_SRV_STATE");
    cmd_err = CM_SS_CMD_ERR_SRV_STATE_S;
  }
  else if (is_active_voice_call && si_info.mode == SYS_SYS_MODE_CDMA )
  {
    /* Reject the call if we have voice call on 1X as
    ** no data calls could be active anyways.
    */
    CM_MSG_HIGH_0("ps_data_avail: error! (1X Voice) ERR_SRV_STATE");
    cmd_err = CM_SS_CMD_ERR_SRV_STATE_S;
  }
  else if( cmac_is_in_emergency_only())
  {
     /* Phone is in emergency, can't allow normal calls
     */
    cmd_err = CM_SS_CMD_ERR_INCORRECT_MODE_S;
  }

  /*Reject PS Data Avail cmd if ACQ DB Scan during RLF is in progress */
  ss= (sd_ss_e_type) cmph_map_subs_to_ss(ss_cmd_ptr->cmd_subs );

  if ( cmregprx_is_acq_db_in_progress(ss) )
  {
    CM_MSG_HIGH_1("ps_data_avail: subs %d rejected.Acq DB Scan in progress",
                   ss_cmd_ptr->cmd_subs);
    cmd_err = CM_SS_CMD_ERR_SRV_STATE_S;
  }

  /* If single-sim, exit here */
  if (cmph_is_ssim())
  {
    return cmd_err;
  }

  /* The remaining check is related to multi-sim */

  /* The command is only valid for default data sub */
  if ( ss_cmd_ptr->cmd_subs != ph_ptr->default_data_subs)
  {
    CM_ERR_2("ps_data_avail: cmd_subs %d != dds %d",
              ss_cmd_ptr->cmd_subs,
              ph_ptr->default_data_subs);
    cmd_err = CM_SS_CMD_ERR_SRV_STATE_S;
  }

  /* Check if the subscription on which this command is issued,
  ** is operational or not
  */
  if ( cmph_map_subs_to_ss(ss_cmd_ptr->cmd_subs ) == CM_SS_HYBR_2 &&
       !cmss_ptr()->info.is_hybr_gw_operational
     )
  {
    CM_ERR_1("ps_data_avail: Hybr2:subs %d for ps data avail is not operational",
           ss_cmd_ptr->cmd_subs);
    cmd_err = CM_SS_CMD_ERR_SRV_STATE_S;
  }

  if ( cmph_map_subs_to_ss(ss_cmd_ptr->cmd_subs ) == CM_SS_HYBR_3 &&
       !cmss_ptr()->info.is_gw3_operational
     )
  {
    CM_ERR_1("ps_data_avail: Hybr3:subs %d for ps data avail is not operational",
           ss_cmd_ptr->cmd_subs);
    cmd_err = CM_SS_CMD_ERR_SRV_STATE_S;
  }


  if ( cmph_map_subs_to_ss(ss_cmd_ptr->cmd_subs ) == CM_SS_MAIN &&
       !cmss_ptr()->info.is_main_operational
   )
  {
    CM_ERR_1("ps_data_avail: Main:subs %d for ps data avail is not operational",
           ss_cmd_ptr->cmd_subs);
    cmd_err = CM_SS_CMD_ERR_SRV_STATE_S;
  }
  {
    sys_modem_as_id_e_type  voice_asubs_id = SYS_MODEM_AS_ID_NONE;
    sys_modem_as_id_e_type  emg_asubs_id = SYS_MODEM_AS_ID_NONE;

    /* Check if there is an existing voice call
    */
    voice_asubs_id = cmcall_get_subs_id_with_call_type(CM_CALL_TYPE_VOICE);
    emg_asubs_id = cmcall_get_subs_id_with_call_type(CM_CALL_TYPE_EMERGENCY);

    /* If an emerg call exist on other subscription, return PS_DATA_FAIL
    */
    if( emg_asubs_id != SYS_MODEM_AS_ID_NONE &&
      emg_asubs_id != ss_cmd_ptr->cmd_subs)
    {
      CM_MSG_HIGH_0("ps_data_avail: Emerg call - Phone in use, reject PS_DATA_AVAIL");
      cmd_err = CM_SS_CMD_ERR_INCORRECT_MODE_S;
    }

    /* If a voice call (or) emerg call exist on other subscription, return PS_DATA_FAIL
    */
    else if (voice_asubs_id != SYS_MODEM_AS_ID_NONE &&
           voice_asubs_id != ss_cmd_ptr->cmd_subs)
    {
      if (cmph_is_sxlte() || cmph_is_dsds())
      {
        CM_MSG_HIGH_0("ps_data_avail: sxlte+g/dsds - Phone in use, reject PS_DATA_AVAIL");
        cmd_err = CM_SS_CMD_ERR_INCORRECT_MODE_S;
      }
    }
  }
  /* For DSDS and TSTS, If SUPS exist on other subscription, return INCORRECT_MODE
  */
  if ( (cmph_is_dsds() || cmph_is_tsts()) &&
       cmsups_is_there_pending_sups_on_other_subs(ss_cmd_ptr->cmd_subs) )
  {
    cmd_err = CM_SS_CMD_ERR_INCORRECT_MODE_S;
  }

  return cmd_err;

} /* cmss_ss_cmd_ps_data_avail_para_check() */
#endif /* FEATURE_PS_DORMANT_PWR_SAVE */

#ifdef FEATURE_CM_SS_MEAS
#error code not present
#endif /* FEATURE_CM_SS_MEAS */


/*===========================================================================

FUNCTION  cmss_ss_cmd_orig_thr_cmd_update_table_para_check

DESCRIPTION
  Check parameter errors for orig throttle update table request.

DEPENDENCIES
  none

RETURN VALUE
  CM_SS_CMD_ERR_NONE if no parameter related errors,
  otherwise specific cm_ss_cmd_err_e_type.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ss_cmd_err_e_type  cmss_ss_cmd_orig_thr_cmd_update_table_para_check
(
  const cm_ss_cmd_s_type      *ss_cmd_ptr
    /* Command pointer
    */
)
{
  cm_ss_cmd_err_e_type   cmd_err     = CM_SS_CMD_ERR_NOERR;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_cmd_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if( ( ss_cmd_ptr->client_ptr == CM_CLIENT_PTR_NONE ) ||
      ((ss_cmd_ptr->client_ptr)->init_mask != CM_INIT_MASK ) )
  {
    /*  Make sure the client has a valid ID.
    */
    cmd_err  = CM_SS_CMD_ERR_CLIENT_ID_P;
    CM_MSG_HIGH_0( "CM_SS_ORIG_THR_CMD_UPDATE_TABLE: ERR_CLIENT_ID_P");
  }

  if(( ss_cmd_ptr->info.call_info.call_type != CM_CALL_TYPE_PS_DATA )&&
     ( ss_cmd_ptr->info.mode != SYS_SYS_MODE_CDMA)&&
     ( ss_cmd_ptr->info.mode != SYS_SYS_MODE_HDR))
  {
    cmd_err  = CM_SS_CMD_ERR_FUNCTION_UNAVAILABLE_DUE_TO_UNDEFINED_FEATURE;
    CM_ERR_0( "CM_SS_ORIG_THR_CMD_UPDATE_TABLE: Undefined Feature");
  }
  return cmd_err;

} /* cmss_ss_cmd_orig_thr_cmd_update_table_para_check() */


/*===========================================================================

FUNCTION  cmss_client_cmd_check

DESCRIPTION
  Check for call command parameter errors and whether a specified serving system
  command is allowed in the current state of the call/phone.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmcall_init().

RETURN VALUE
  CM_SS_CMD_ERR_NONE if no error found, specific cm_ss_cmd_err_e_type otherwise.

SIDE EFFECTS
  none

===========================================================================*/
static cm_ss_cmd_err_e_type  cmss_client_cmd_check(

    cm_ss_cmd_s_type        *ss_cmd_ptr
        /* Pointer to a CM command */
)
{
  cm_ss_cmd_err_e_type    cmd_err    = CM_SS_CMD_ERR_NOERR;
      /* Initialize command error to NO-ERROR */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_cmd_ptr != NULL );
  CM_ASSERT( ss_cmd_ptr->cmd_type == CM_CMD_TYPE_SS );

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_MSG_HIGH_2( "cmss_cmd_check, cmd=%d, asubs_id=%d",
                    ss_cmd_ptr->cmd, ss_cmd_ptr->cmd_subs);


  /* Check whether command is possible.
  */
  switch( ss_cmd_ptr->cmd )
  {

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                     /*------------------------------------*/
                     /* Get a snapshot of ss information   */
                     /*------------------------------------*/

    case CM_SS_CMD_INFO_GET:
      /* check command parameter errors */
      cmd_err = cmss_ss_cmd_get_ss_info_para_check(ss_cmd_ptr);

      break;

    #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
    case CM_SS_CMD_GET_DCH_CELL_ID:
      cmd_err =  cmss_ss_cmd_get_cell_dch_info_para_check(ss_cmd_ptr);
      break;
    #endif /* FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

                     /*------------------------------------*/
                     /*      Get system measurements       */
                     /*------------------------------------*/
    #ifdef FEATURE_CM_SS_MEAS
    #error code not present
#endif /* FEATURE_CM_SS_MEAS */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
    case CM_SS_CMD_PS_DATA_AVAIL:
      /* check command parameter errors */
      cmd_err = cmss_ss_cmd_ps_data_avail_para_check(ss_cmd_ptr);

      break;
    #endif /* FEATURE_PS_DORMANT_PWR_SAVE */
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_SS_CMD_ORIG_THR_UPDATE_TBL:
      /* check command parameter errors */
      cmd_err = cmss_ss_cmd_orig_thr_cmd_update_table_para_check(ss_cmd_ptr);

      break;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:

      cmd_err = CM_SS_CMD_ERR_OTHER;
      CM_ERR_1( "Bad call command %d", (uint8) ss_cmd_ptr->cmd);

  }

  return cmd_err;

} /* cmss_client_cmd_check() */




/*===========================================================================

FUNCTION cmss_client_cmd_err

DESCRIPTION
  Notify clients of a specified serving system command error.

DEPENDENCIES
  Call object must have already been initialized with
  cmcall_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_client_cmd_err(

    const cm_ss_cmd_s_type       *ss_cmd_ptr,
        /* Pointer to a CM command */

    cm_ss_cmd_err_e_type       cmd_err
        /* Indicate the ss command error */
)
{

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_cmd_ptr != NULL );
  CM_ASSERT( ss_cmd_ptr->cmd_type == CM_CMD_TYPE_SS );
  CM_ASSERT( BETWEEN( cmd_err, CM_SS_CMD_ERR_NONE, CM_SS_CMD_ERR_MAX) );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_LOW_3("START cmss_client_cmd_err() ss_cmd=%d, cmd_err=%d, client=%p",
                  ss_cmd_ptr->cmd, cmd_err, ss_cmd_ptr->client_id );

  /* If commanding client supplied a callback function,
  ** notify this client of command error status.
  */
  if( ss_cmd_ptr->cmd_cb_func != NULL )
  {
    ss_cmd_ptr->cmd_cb_func( ss_cmd_ptr->data_block_ptr,
                             ss_cmd_ptr->cmd,
                             cmd_err );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If error status is other than NO ERROR,
  ** notify the client list of command error, as well.
  */
  if( cmd_err != CM_SS_CMD_ERR_NOERR )
  {
    CM_MSG_HIGH_3( "SS cmd err, cmd=%d, err=%d, client=%ld",
            ss_cmd_ptr->cmd, cmd_err, ss_cmd_ptr->client_id );
    cmclient_list_ss_cmd_err_ntfy( cmd_err, ss_cmd_ptr );
  }

} /* cmss_client_cmd_err() */



/*===========================================================================

FUNCTION cmss_send_ss_info

DESCRIPTION
  This function sends the serving system information to the requesting
  client.

DEPENDENCIES
  SS object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_send_ss_info(

  const cm_ss_cmd_s_type     *ss_cmd_ptr,
      /* The pointer to a serving system command */

        cm_ss_event_e_type    event_type
      /* The type of event to be sent to client */
)
{

  cm_mm_msim_ss_info_s_type          *ss_info_ptr;

  cmss_s_type                   *ss_ptr = cmss_ptr();
      /* Point at serving system object */
  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;
      
  uint8                    stk_id = cmph_ptr()->ss_subs_map[CM_SS_MAIN].stack_id;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_cmd_ptr != NULL);
  
  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
  if ( ss_ptr->info.sys_mode == SYS_SYS_MODE_CDMA )
  {
    #ifndef FEATURE_MMODE_REMOVE_1X
    ss_ptr->info.mode_info.cdma_info.is_registered = mccreg_is_registered();
    #else
    #error code not present
#endif
    ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].mode_info.cdma_info.is_registered = ss_ptr->info.mode_info.cdma_info.is_registered;
  }
  #endif /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */

  /*
  ** Get a buffer for serving system information.
  */
  ss_info_ptr = cmss_info_alloc_new();

  /*
  ** Update the RSSI in the serving system object.
  */
  cmss_report_rssi( NULL, ss_cmd_ptr->client_ptr, TRUE );

  cmss_report_hybr_2_rssi( NULL, ss_cmd_ptr->client_ptr, TRUE );

  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  cmss_report_hybr_3_rssi( NULL, ss_cmd_ptr->client_ptr, TRUE );
  #endif


  /*
  ** Copy serving system information into allocated buffer.
  */
  //(void) cmss_info_get( ss_info_ptr, &ss_ptr->srv_avail_info );
  #if defined(FEATURE_MMODE_TRIPLE_SIM)
  if(ss_cmd_ptr->cmd_subs >= SYS_MODEM_AS_ID_1 && ss_cmd_ptr->cmd_subs <= SYS_MODEM_AS_ID_3)
  #else
  if(ss_cmd_ptr->cmd_subs >= SYS_MODEM_AS_ID_1 && ss_cmd_ptr->cmd_subs <= SYS_MODEM_AS_ID_2)
  #endif
  {
    (void) cmss_info_get_new( ss_info_ptr, &ss_ptr->new_srv_avl_info[ss_cmd_ptr->cmd_subs] , ss_cmd_ptr->cmd_subs);
  }

  /*
  ** Notify only the requesting client.
  */
  cm_client_ss_event_ntfy_new( ss_cmd_ptr->client_ptr, event_type, ss_info_ptr );


  CM_MSG_HIGH_3("Send SS Event = %d, sys_mode = %d, sim_state = %d", event_type,
           ss_info_ptr->stack_info[stk_id].sys_mode, ss_info_ptr->stack_info[stk_id].mode_info.gw_info.sim_state);


  /* Deallocate the dynamically allocated memory after sending the ss event. */
  cm_mem_free(ss_info_ptr);

} /* cmss_send_ss_info() */


#if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))

/*===========================================================================

FUNCTION cmss_update_data_avail_stt

DESCRIPTION
  Update data available state based on the data suspend status and mm
  command status.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static  void cmss_update_data_avail_stt
(
        cm_ss_e_type          ss,
          /* Stack on which to process */

        boolean               data_suspend
          /* Indicate if data is suspended or not. */
)
{
  cmss_s_type                *ss_ptr      = cmss_ptr();
    /* Point at serving system object */

  boolean                    is_cmd_done;
    /* Indicate if the command is successfully send to the mm.*/

  boolean                    is_req_done  = FALSE;
    /* Indicate if the data avail request is done. */

  cm_ps_data_stt_e_type      ps_data_stt  = CM_PS_DATA_STT_NONE;
    /* Indicate the state when phone is attempting to resume data.
    */

  dword                      no_ps_data_uptime
                                          = CMSS_NO_PS_DATA_UPTIME_NONE;

  CM_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Inform clients success if the data has been resumed.
  */
  if( ! data_suspend )
  {
    /* Data has been resumed so generate success event and reset
    ** the state.
    */
    

    cmss_event( ss, CM_SS_EVENT_PS_DATA_SUCCESS );

    /* On data call getting connected, move the data call below the phone object
    ** in the priority queue.
    */
    cmss_update_ps_dormant_entry_in_queue(TRUE);
    is_req_done = TRUE;
  }
  else
  {
    /* Update the mm command status.*/
    is_cmd_done = cmss_send_mm_data_avail(ss);
    if ( ! is_cmd_done )
    {
      cmss_event( ss, CM_SS_EVENT_PS_DATA_FAIL );
      is_req_done = TRUE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If data available request is done, reset the state. Otherwise update
  ** to the next state.
  */
  if( ! is_req_done )
  {
    ps_data_stt = CM_PS_DATA_STT_RESUME;
    no_ps_data_uptime = CMSS_MAX_NO_PS_DATA_RESUME_TIME + time_get_uptime_secs();
  }
  else
  {
    ps_data_stt = CM_PS_DATA_STT_NONE;
    no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
    ss_ptr->ue_init_ps_data_suspend = CM_SS_NONE;
  }

  if(ss == CM_SS_HYBR_2 && cmph_is_msim() && !cmph_is_sxlte())
  {
    ss_ptr->hybr_gw_ps_data_stt = ps_data_stt;
    ss_ptr->hybr_gw_no_ps_data_uptime = no_ps_data_uptime;
  }
  else if( ss == CM_SS_HYBR_3  && cmph_is_msim())
  {
    ss_ptr->hybr_3_gw_ps_data_stt = ps_data_stt;
    ss_ptr->hybr_3_gw_no_ps_data_uptime = no_ps_data_uptime;
  }
  else
  {
    ss_ptr->ps_data_stt = ps_data_stt;
    ss_ptr->no_ps_data_uptime = no_ps_data_uptime;
  }

  CM_MSG_HIGH_3("PS_DATA_STATUS: ss=%d, data_suspend=%d, status=%d",
                 ss,data_suspend,ps_data_stt);
} /* cmss_update_data_avail_stt */




/*===========================================================================

FUNCTION cmss_proc_data_avail_during_lte_call

DESCRIPTION
  This function process the data available request when it comes to CM
  and an LTE call is in progress at CM level


DEPENDENCIES

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_proc_data_avail_during_lte_call( 
  boolean                  force_data_resume,
  sys_modem_as_id_e_type   lte_asubs_id
)
{
  #if defined FEATURE_CM_LTE
  cmss_s_type                *ss_ptr = cmss_ptr();
    /* Point at serving system object */

  cmph_s_type                *ph_ptr = cmph_ptr();
    /* Point at phone object */

  dword                      clk_time =  time_get_uptime_secs();
    /* Current clock time */

  cm_ps_data_stt_e_type      *ps_data_stt = NULL;

  cm_ss_e_type               cm_ss = CM_SS_MAIN;

  /* Determine ss */
  cm_ss = cmph_map_as_id_to_cm_ss(lte_asubs_id);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* svlte hybr2 data status is stored in ps_data_stt not hybr_gw_ps_data_stt */
  #ifdef FEATURE_MMODE_DUAL_SIM
  if (cmph_is_msim())
  {
    if (cm_ss == CM_SS_HYBR_2 && !cmph_is_sxlte())
    {
      ps_data_stt = &(ss_ptr->hybr_gw_ps_data_stt);
    }
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    else if (cm_ss == CM_SS_HYBR_3 && cmph_is_sxlte())
    {
      ps_data_stt = &(ss_ptr->hybr_3_gw_ps_data_stt);
    }
    #endif
    else
    {
      ps_data_stt = &(ss_ptr->ps_data_stt);
    }
  }
  else
  #endif
  {
    ps_data_stt = &(ss_ptr->ps_data_stt);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  switch (*ps_data_stt)
  {

    case CM_PS_DATA_STT_NONE:
      /* Check if all stacks are in power save.
         If all supported stacks are in pwr save, wakeup acquisition in SD
      */
      if (force_data_resume)
      {
        boolean is_wakeup     = FALSE;
        boolean is_hybr1_supp = FALSE;
        boolean is_hybr2_supp = cmss_is_hybr2_operational();
        boolean is_hybr3_supp = cmss_is_hybr3_operational();
        is_hybr1_supp = (cmss_is_hybr_status_on() &&
                        cmph_is_valid_mode_pref( CM_MODE_PREF_HDR_ONLY, lte_asubs_id));

        if( (ss_ptr->main_srv_status == SYS_SRV_STATUS_PWR_SAVE ||
             (ss_ptr->no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE &&
              cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status == \
                  SYS_SRV_STATUS_PWR_SAVE_INTERNAL))  &&
           (!is_hybr1_supp  || (is_hybr1_supp &&
             (ss_ptr->hybr_1_srv_status == SYS_SRV_STATUS_PWR_SAVE
              #if (defined (FEATURE_HDR_HYBRID))
              ||
              (ss_ptr->hdr_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE &&
               cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status == \
                   SYS_SRV_STATUS_PWR_SAVE_INTERNAL)
              #endif
              ))) &&
           (!is_hybr2_supp  || (is_hybr2_supp &&
             (ss_ptr->hybr_gw_srv_status == SYS_SRV_STATUS_PWR_SAVE ||
             (ss_ptr->hybr_gw_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE &&
              cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status == \
                  SYS_SRV_STATUS_PWR_SAVE_INTERNAL))))
                 &&
           (!is_hybr3_supp  || (cm_ss != CM_SS_HYBR_3) || (is_hybr3_supp &&
             (ss_ptr->hybr_3_gw_srv_status == SYS_SRV_STATUS_PWR_SAVE ||
             (ss_ptr->hybr_3_gw_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE &&
              cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status == \
                  SYS_SRV_STATUS_PWR_SAVE_INTERNAL))))
        )
        {
          is_wakeup = TRUE;
        }
        if (is_wakeup )
        {
          cm_orig_q_s_type          *ph_orig_para_top_ptr =
                                      cmtask_orig_para_get_top( cm_ss );

          CM_MSG_HIGH_0( "All stacks in pwr save" );

          if ( ph_orig_para_top_ptr != NULL )
          {

            /* Do not use orig mode normal since this is an LTE call
            */
            sd_ss_orig_mode_e_type             orig_mode = ph_orig_para_top_ptr->orig->orig_mode;
            cmmsc_proc_cmd_pref_sys_chgd_s_type cmd;

            CM_MSG_HIGH_2( "Waking cm_ss=%d, orig_mode=%d", cm_ss, ph_orig_para_top_ptr->orig->orig_mode );

            /* recompute the orig_mode, based on net sel mode pref */
            if( ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE &&
                CMPH_SS_NETWORK_SEL_MODE_PREF(lte_asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL )
            {
              orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
            }
            else if (ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NORMAL &&
                CMPH_SS_NETWORK_SEL_MODE_PREF(lte_asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL)
            {
              orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
            }

            /* Waiting for ok_to_orig report from SD if there is a call. */
            cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue (
               cm_ss,
               SD_SS_PREF_REAS_ORIG_RESUME,
               orig_mode,
               cmph_is_new_policy_apply(cm_ss),
               ph_orig_para_top_ptr,
               CM_ACT_UPDATE_REAS_NONE,
               &cmd
               );

            cmmsimc_proc_cmd_pref_sys_chgd(&cmd);
            }
          else
          {
            CM_ERR_0 ( "Top element on priority queue of Main Stack is NULL" );
          }
        }// is_wakeup

        /* Update ps data state */
        CM_MSG_HIGH_3("LTE_PS_DATA_AVAIL old stt %d new stt %d wait_time %d",
                    (*ps_data_stt), CM_PS_DATA_STT_SRV_ACQ, CMSS_MAX_NO_PS_DATA_SRV_TIME );
        *ps_data_stt = CM_PS_DATA_STT_SRV_ACQ;

        if(cm_ss == CM_SS_MAIN)
        {
          ss_ptr->no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
        }
        else if (cm_ss == CM_SS_HYBR_2)
        {
          ss_ptr->hybr_gw_no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
        }
        else if (cm_ss == CM_SS_HYBR_3)
        {
          ss_ptr->hybr_3_gw_no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
        }
      } // if force_data_resume
      break;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case CM_PS_DATA_STT_SRV_ACQ:
    case CM_PS_DATA_STT_RESUME:
      /* If data is not suspended on the LTE stack, report success to DS & clear state in CM
      */
      if ((cmph_is_msim() &&
           ((cm_ss == CM_SS_HYBR_2 && cmph_is_lte_capable_on_ss(CM_SS_HYBR_2) && !cmph_is_sxlte() &&
               ss_ptr->info.is_hybr_gw_operational && ss_ptr->info.gw_ps_data_suspend == FALSE) ||
             #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
             (cm_ss == CM_SS_HYBR_3 && cmph_is_lte_capable_on_ss(CM_SS_HYBR_3) &&
               ss_ptr->info.is_gw3_operational && ss_ptr->info.gw3_ps_data_suspend == FALSE) ||
             #endif
             (cm_ss == CM_SS_MAIN && cmph_is_lte_capable_on_ss(CM_SS_MAIN)&&
               ss_ptr->info.ps_data_suspend == FALSE &&
               !cmph_is_subs_feature_mode_1x_sxlte(ph_ptr->main_stack_info.asubs_id) )||
             (cm_ss == CM_SS_MAIN && cmph_is_lte_capable_on_ss(CM_SS_MAIN)
               && cmph_is_subs_feature_mode_1x_sxlte(ph_ptr->main_stack_info.asubs_id) &&
               ( (ss_ptr->info.is_hybr_gw_operational && ss_ptr->info.gw_ps_data_suspend == FALSE) ||
                 ( !ss_ptr->info.is_hybr_gw_operational && ss_ptr->info.ps_data_suspend == FALSE )
               ))
            ))
         ||
         ((!cmph_is_msim()) &&
           ( (ss_ptr->info.is_hybr_gw_operational && ss_ptr->info.gw_ps_data_suspend == FALSE) ||
             ( !ss_ptr->info.is_hybr_gw_operational && ss_ptr->info.ps_data_suspend == FALSE )
           )))
      {
        
        cmss_event(cm_ss, CM_SS_EVENT_PS_DATA_SUCCESS );

        CM_MSG_HIGH_2("LTE_PS_DATA_AVAIL old stt %d new stt %d",
                    (*ps_data_stt), CM_PS_DATA_STT_NONE);
        (*ps_data_stt) = CM_PS_DATA_STT_NONE;

        if(cm_ss == CM_SS_MAIN)
        {
          ss_ptr->no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
        }
        else if (cm_ss == CM_SS_HYBR_2)
        {
          ss_ptr->hybr_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
        }
        else if (cm_ss == CM_SS_HYBR_3)
        {
          ss_ptr->hybr_3_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
        }
      }

      /* If the timer has expired and data is still suspended, report failure to DS */
      else if((cm_ss == CM_SS_MAIN && ss_ptr->no_ps_data_uptime <= clk_time) ||
              (cm_ss == CM_SS_HYBR_2 && ss_ptr->hybr_gw_no_ps_data_uptime <= clk_time) ||
              (cm_ss == CM_SS_HYBR_3 && ss_ptr->hybr_3_gw_no_ps_data_uptime <= clk_time)
      )
      {
        CM_MSG_HIGH_2("LTE_PS_DATA_AVAIL old stt %d new stt %d",
                    (*ps_data_stt), CM_PS_DATA_STT_NONE);
        *ps_data_stt = CM_PS_DATA_STT_NONE;

        if(cm_ss  == CM_SS_MAIN)
        {
          ss_ptr->no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
        }
        else if (cm_ss == CM_SS_HYBR_2)
        {
          ss_ptr->hybr_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
        }
        else if (cm_ss == CM_SS_HYBR_3)
        {
          ss_ptr->hybr_3_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
        }

        /* If data is still suspended send data fail event */
        #ifndef FEATURE_MMODE_DUAL_SIM
        if( (!ss_ptr->info.is_hybr_gw_operational && ss_ptr->info.ps_data_suspend == TRUE &&
              cm_ss == CM_SS_MAIN) ||
            (ss_ptr->info.is_hybr_gw_operational  && ss_ptr->info.gw_ps_data_suspend == TRUE &&
             (cm_ss == CM_SS_MAIN || cm_ss == CM_SS_HYBR_2)) ||
            (ss_ptr->info.is_gw3_operational && ss_ptr->info.gw3_ps_data_suspend == TRUE &&
             cm_ss == CM_SS_HYBR_3)
        )
        #endif
        {
          cmss_event( cm_ss, CM_SS_EVENT_PS_DATA_FAIL );
        }
      }
      break;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    case CM_PS_DATA_STT_PENDING:
      if (ph_ptr->main_stack_info.pref_info.network_type == CM_MODE_PREF_NONE)
      {
        /* Update ps data state to wait for service */
        CM_MSG_HIGH_3("LTE_PS_DATA_AVAIL old stt %d new stt %d wait_time %d",
                    (*ps_data_stt), CM_PS_DATA_STT_SRV_ACQ, CMSS_MAX_NO_PS_DATA_SRV_TIME );
        *ps_data_stt = CM_PS_DATA_STT_SRV_ACQ;

        if(cm_ss == CM_SS_MAIN)
        {
          ss_ptr->no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
        }
        else if (cm_ss == CM_SS_HYBR_2)
        {
          ss_ptr->hybr_gw_no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
        }
        else if (cm_ss == CM_SS_HYBR_3)
        {
          ss_ptr->hybr_3_gw_no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
        }
      }
      /* If the timer has expired and data is still suspended, report failure to DS */
      else if((cm_ss == CM_SS_MAIN && ss_ptr->no_ps_data_uptime <= clk_time) ||
              (cm_ss == CM_SS_HYBR_2 && ss_ptr->hybr_gw_no_ps_data_uptime <= clk_time) ||
              (cm_ss == CM_SS_HYBR_3 && ss_ptr->hybr_3_gw_no_ps_data_uptime <= clk_time)
      )
      {
        CM_MSG_HIGH_2("LTE_PS_DATA_AVAIL old stt %d new stt %d ",
                    (*ps_data_stt), CM_PS_DATA_STT_NONE);
        *ps_data_stt = CM_PS_DATA_STT_NONE;

        if (cm_ss == CM_SS_MAIN)
        {
          ss_ptr->no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
        }
        else if (cm_ss == CM_SS_HYBR_2)
        {
          ss_ptr->hybr_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
        }
        else if (cm_ss == CM_SS_HYBR_3)
        {
          ss_ptr->hybr_3_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
        }

        /* If data is still suspended send data fail event */
        if (( cmph_is_msim() &&
              (((cm_ss == CM_SS_HYBR_2 && cmph_is_lte_capable_on_sub(SYS_MODEM_AS_ID_2) && !cmph_is_sxlte()) &&
                  (ss_ptr->info.is_hybr_gw_operational) && (ss_ptr->info.gw_ps_data_suspend == TRUE)) ||
               ((cm_ss == CM_SS_MAIN && cmph_is_lte_capable_on_ss(CM_SS_MAIN)) &&
                  (ss_ptr->info.ps_data_suspend == TRUE) &&
                  !cmph_is_subs_feature_mode_1x_sxlte(ph_ptr->main_stack_info.asubs_id)) ||
                  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
                  ((cm_ss == CM_SS_HYBR_3 && cmph_is_lte_capable_on_ss(CM_SS_HYBR_3)) &&
                  (ss_ptr->info.is_gw3_operational) && (ss_ptr->info.gw3_ps_data_suspend == TRUE)) ||
                  #endif
               (cm_ss == CM_SS_MAIN && cmph_is_lte_capable_on_ss(CM_SS_MAIN)
               && cmph_is_subs_feature_mode_1x_sxlte(ph_ptr->main_stack_info.asubs_id) &&
               ( (ss_ptr->info.is_hybr_gw_operational && ss_ptr->info.gw_ps_data_suspend == TRUE) ||
                 ( !ss_ptr->info.is_hybr_gw_operational && ss_ptr->info.ps_data_suspend == TRUE )
               )) ))
            ||
            ( (!cmph_is_msim()) &&
               (((!ss_ptr->info.is_hybr_gw_operational) && (ss_ptr->info.ps_data_suspend == TRUE)) ||
               ((ss_ptr->info.is_hybr_gw_operational)  && (ss_ptr->info.gw_ps_data_suspend == TRUE))) ))
        {
          cmss_event( cm_ss, CM_SS_EVENT_PS_DATA_FAIL );
        }
    }
      break;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    default:
      break;
  } //ss_ptr->ps_data_stt

  #endif
} //cmss_proc_data_avail_during_lte_call


/*===========================================================================

FUNCTION cmss_proc_data_avail

DESCRIPTION
  This function process the data available request.
  If there is calls, holds the data available request until CM gets
  ok_to_orig from SD. If ps service is not available or data is not resumed
  within certain period of time, a failure event is generated. If data is
  resumed on time, a success event is generated.

  If there is no call, send the data available request imediately and wait
  for data to be resumed. If the data is resumed within certain period of
  time, an successful event is end otherwise a failure event is triggered.

DEPENDENCIES
  SS object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_proc_data_avail(

  const cm_ss_cmd_s_type     *ss_cmd_ptr
      /* The pointer to a serving system command */

)
{
  cmss_s_type                *ss_ptr = cmss_ptr();
    /* Point at serving system object */

  cmph_s_type                *ph_ptr = cmph_ptr();
    /* Point at phone object */

  cm_mm_msim_ss_info_s_type       *ss_info_ptr;
    /* Point at serving system object */
  dword                      clk_time =  time_get_uptime_secs();
    /* Current clock time */

  cm_orig_q_s_type          *ph_orig_para_top_ptr;
    /* The pointer to the top element of the priority queue */

  cm_mode_pref_e_type     fav_mode_pref;
  cm_srv_type_e_type       srv_type;
  sys_sys_mode_e_type     sys_mode;
  cm_ss_e_type                 ss            = CM_SS_MAIN;
  sd_ss_orig_mode_e_type   orig_mode;
  sys_modem_as_id_e_type   asubs_id = SYS_MODEM_AS_ID_1;
  cm_ss_e_type             ps_call_ss = CM_SS_MAIN;
  boolean                  user_plmn_rat_selection_pending = FALSE;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_cmd_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  asubs_id = cmss_get_ss_cmd_asubs_id(ss_cmd_ptr);
  ss = cmph_map_subs_to_ss(asubs_id);

  CM_MSG_HIGH_2("ps_data_avail: Proc asubs_id=%d, ss=%d",
                   ss_cmd_ptr->cmd_subs, ss);

  /*
  ** Get a buffer for serving system information.
  */
  ss_info_ptr = cmss_info_alloc_new();
  /*
  ** Copy serving system information into allocated buffer.
  */
  (void) cmss_info_get_new( ss_info_ptr, &ss_ptr->new_srv_avl_info[ss_cmd_ptr->cmd_subs] ,ss_cmd_ptr->cmd_subs);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*
  ** Notify only the requesting client.
  **
  ** Note: Client ID is set to the begining address of the client object
  ** during the client initialization.
  */
  cm_client_ss_event_ntfy_new( ss_cmd_ptr->client_ptr,
                           CM_SS_EVENT_PS_DATA_AVAIL,
                           ss_info_ptr );

   ss_ptr->is_ps_data_pending_for_srv_cnf = FALSE;
  /* If CM is waiting for service cnf from NAS for 
   ** user plmn + RAT selection delay ps data avail.
   */
  if (cmss_is_user_plmn_rat_selection_pending(ss))
  {
    ss_ptr->ps_data_stt = CM_PS_DATA_STT_PENDING;
    ss_ptr->no_ps_data_uptime = clk_time + CMSS_MAX_PS_DATA_PENDING_TIME;
    ss_ptr->is_ps_data_pending_for_srv_cnf = TRUE;
    
    cm_mem_free(ss_info_ptr);

    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*
  ** The data available process differently within or without a call.
  **
  ** If there is a call, wait for ok_to_orig before send the cmd to MM
  ** Otherwise, send the cmd directly to MM.
  */
  if( cmcall_is_there_a_call_type_per_sub(asubs_id, CM_CALL_TYPE_PS_DATA, &ps_call_ss)
      != CM_CALL_ID_INVALID)
  {
    /* For svlte, it is possible that hybr2 has a data call */
    if (cmph_is_subs_feature_mode_1x_sxlte(asubs_id) && ps_call_ss != CM_SS_MAIN)
    {
      ss = ps_call_ss;
    }
    ph_orig_para_top_ptr = cmtask_orig_para_get_top( ss );

    /* If there is a pending get network list request, update the ps data
    ** state to pending state.
    */
    /* If CM is waiting for service cnf from NAS for 
   ** user plmn + RAT selection delay ps data avail.
   */
    user_plmn_rat_selection_pending = cmregprx_is_user_plmn_rat_selection_pending(ss);
    if (ss == CM_SS_MAIN && (ph_ptr->main_stack_info.pref_info.network_type != CM_MODE_PREF_NONE  || 
      user_plmn_rat_selection_pending))
    {
      ss_ptr->ps_data_stt = CM_PS_DATA_STT_PENDING;
      ss_ptr->no_ps_data_uptime = clk_time + CMSS_MAX_PS_DATA_PENDING_TIME;
        
      cm_mem_free(ss_info_ptr);
      return;
        
    }
    else 
    if(ss == CM_SS_HYBR_2 && !cmph_is_sxlte() &&
        (ph_ptr->hybr_2_stack_info.pref_info.network_type != CM_MODE_PREF_NONE || 
        user_plmn_rat_selection_pending))
      {
        ss_ptr->hybr_gw_ps_data_stt = CM_PS_DATA_STT_PENDING;
        ss_ptr->hybr_gw_no_ps_data_uptime = clk_time + CMSS_MAX_PS_DATA_PENDING_TIME;
        
      cm_mem_free(ss_info_ptr);
        
      return;
      }
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    else
    if( ss == CM_SS_HYBR_3 && 
        (ph_ptr->hybr_3_stack_info.pref_info.network_type != CM_MODE_PREF_NONE
        || user_plmn_rat_selection_pending))
      {
        ss_ptr->hybr_3_gw_ps_data_stt = CM_PS_DATA_STT_PENDING;
        ss_ptr->hybr_3_gw_no_ps_data_uptime = clk_time + CMSS_MAX_PS_DATA_PENDING_TIME;

      cm_mem_free(ss_info_ptr);

      return;
    }
    #endif /* FEATURE_MMODE_TRIPLE_SIM */



    /* If there is no LTE data call ( ie, it is a GW Ps data call ) */
    if (cmcall_is_no_call_in_lte_ps())
    {
      /* If there is no GW entry in priority Q, send DATA_AVAIL command to NAS
      ** directly and return
      */
      if( cmtask_orig_para_search_act_type(ss, CM_ACT_TYPE_DATA_CALL) == NULL )
      {
        CM_MSG_MED_1( "DATA AVAIL REQ with no priority Q obj, ss %d", ss);
        cmss_update_data_avail_stt( ss, ss_info_ptr->ps_data_suspend );
        /* Deallocate the dynamically allocated memory before returing. */
        cm_mem_free(ss_info_ptr);
        return;
      }

      /* otherwise update SD and get ok to orig before sending data avail indication to NAS
      */
      srv_type = cmph_get_srv_type(CM_CALL_TYPE_PS_DATA);

      /* If srv_type is AUTOMATIC, convert it based on sys mode */
      if (srv_type == CM_SRV_TYPE_AUTOMATIC)
      {
        sys_mode = sd_misc_get_acq_sys_mode(cmph_map_cm_ss_type_to_sd_ss_type(ss));
        srv_type = cmph_map_sys_mode_to_srv_type(sys_mode);
      }

      /* Compute fav_mode_pref.
      ** It is the intersection of phone's mode preference and
      ** srv_type of the call.
      */
      fav_mode_pref = cmph_misc_intersect_mode_pref( srv_type,
                                                     CMPH_SS_MODE_PREF(asubs_id, ph_ptr)
                                                   );

      /* Change the mode_pref of all data calls to computed fav_mode_pref
      */
      if (fav_mode_pref != CM_MODE_PREF_NONE)
      {
        (void)cmtask_orig_para_change_mode_pref( ss,
                                                 CM_ACT_TYPE_DATA_CALL,
                                                 fav_mode_pref,
                                                 TRUE );
      }
      else
      {
        CM_MSG_MED_0("Intersection of call_ptr's srv_type and ph_ptr's mode_pref is NONE, mode_pref not changed" );
      }

      /* UE is already having full service on GW.*/
      if( ( ss == CM_SS_MAIN &&
            ss_ptr->info.srv_status == SYS_SRV_STATUS_SRV &&
            ( ss_ptr->info.sys_mode == SYS_SYS_MODE_WCDMA ||
              ss_ptr->info.sys_mode == SYS_SYS_MODE_GSM ||
              ss_ptr->info.sys_mode == SYS_SYS_MODE_GW ||
              ss_ptr->info.sys_mode == SYS_SYS_MODE_TDS
            ) &&
            ( ss_ptr->info.srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
              ss_ptr->info.srv_domain == SYS_SRV_DOMAIN_CS_PS
            )
          )
          ||
          ( ss == CM_SS_HYBR_2 &&
            ss_ptr->info.gw_srv_status == SYS_SRV_STATUS_SRV &&
            ( ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_WCDMA ||
              ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_GSM ||
              ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_GW ||
              ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_TDS
            ) &&
            ( ss_ptr->info.gw_srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
              ss_ptr->info.gw_srv_domain == SYS_SRV_DOMAIN_CS_PS
            )
          )
        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        ||
        ( ss == CM_SS_HYBR_3 &&
          ss_ptr->info.gw3_srv_status == SYS_SRV_STATUS_SRV &&
          ( ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_WCDMA ||
            ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_GSM ||
            ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_GW ||
            ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_TDS
          ) &&
          ( ss_ptr->info.gw3_srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
            ss_ptr->info.gw3_srv_domain == SYS_SRV_DOMAIN_CS_PS
          )
        )
        #endif /* FEATURE_MMODE_TRIPLE_SIM */

       )/*lint !e774 */
      {
        /*
        ** pump the priority of all data calls over to phone object
        */
        (void)cmtask_orig_para_change_act_priority( ss,
                                                    CM_ACT_TYPE_DATA_CALL,
                                                    CM_ACT_PRIORITY_BELOW_PH,
                                                    CM_ACT_PRIORITY_80,
                                                    TRUE
                                                  );

        /* The pointer to the top element of the priority queue */
        ph_orig_para_top_ptr = cmtask_orig_para_get_top( ss );
      }

      if ( ph_orig_para_top_ptr != NULL
           &&
           (!cmph_is_msim()
            ||(cmph_is_msim() &&
               ph_orig_para_top_ptr->act_type == CM_ACT_TYPE_DATA_CALL)
          )
       )
      {
        cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

        orig_mode = ph_orig_para_top_ptr->orig->orig_mode;

        /* recompute the orig_mode, based on net sel mode pref */
        if( ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE &&
                        CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL )
        {
          orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
        }
        else if (ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NORMAL &&
                 CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL)
        {
          orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
        }

        cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue(
            ss,
            SD_SS_PREF_REAS_ORIG_RESUME,
            orig_mode,
            FALSE,
            ph_orig_para_top_ptr,
            CM_ACT_UPDATE_REAS_NONE,
            &cmd
            );

        cmmsimc_proc_cmd_pref_sys_chgd(&cmd);
        }
      else
      {
        CM_MSG_HIGH_0 ("Top element on priority queue of Main Stack is NULL");
      }

      /* Update ps data state */
      if(ss == CM_SS_HYBR_2 && cmph_is_msim() &&  !cmph_is_sxlte())
      {
        ss_ptr->hybr_gw_ps_data_stt = CM_PS_DATA_STT_SRV_ACQ;
        ss_ptr->hybr_gw_no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
      }
      else
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      if( ss == CM_SS_HYBR_3 )
      {
        ss_ptr->hybr_3_gw_ps_data_stt = CM_PS_DATA_STT_SRV_ACQ;
        ss_ptr->hybr_3_gw_no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
      }
      else
      #endif /* FEATURE_MMODE_TRIPLE_SIM */
      {
        ss_ptr->ps_data_stt = CM_PS_DATA_STT_SRV_ACQ;
        ss_ptr->no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
      }
    } //if the call is not an LTE call
    else
    {
      //if the call is an LTE call
      cmss_proc_data_avail_during_lte_call( TRUE, asubs_id);
    }
  }// if there is any data call on ss
  else
  {
    /*
    ** If coming here, the request is received without a call.
    ** Send it anyway.
    */
     CM_MSG_MED_1( "Wrong DATA AVAIL REQ, ss %d", ss);
     cmss_update_data_avail_stt( ss, ss_info_ptr->ps_data_suspend );
  }

  /* Deallocate the dynamically allocated memory after sending the ss event. */
  cm_mem_free(ss_info_ptr);

} /* cmss_proc_data_avail */
#endif /* FEATURE_PS_DORMANT_PWR_SAVE */


/*===========================================================================

FUNCTION cmss_map_sd_sid_to_sys_sid

DESCRIPTION
 Map the sd sid value to sys_sys_sid value.

DEPENDENCIES
  None.

RETURN VALUE
  none

SIDE EFFECTS
  None.


===========================================================================*/
static void cmss_map_sd_sid_to_sys_sid(

    sd_mode_e_type          sd_mode,
      /* Current serving system mode.
      */

    sys_sys_id_s_type       *sys_sid_ptr,
      /* Serving system sys SID ptr.
      */

    const sd_sid_u_type     *sd_sid_ptr
      /* serving system SD SID pointer */
)
{
  cmss_s_type * ss_ptr = cmss_ptr();

  CM_ASSERT( sd_sid_ptr  != NULL );
  CM_ASSERT( sys_sid_ptr != NULL );
  CM_ASSERT( ss_ptr      != NULL );

  switch ( sd_mode )
  {
    case SD_MODE_AMPS:
    case SD_MODE_CDMA:
      sys_sid_ptr->id_type = SYS_SYS_ID_TYPE_IS95;
      sys_sid_ptr->id.is95.sid = sd_sid_ptr->is95.sid;
      sys_sid_ptr->id.is95.nid = sd_sid_ptr->is95.nid;
      sys_sid_ptr->id.is95.mcc = sd_sid_ptr->is95.mcc;
      sys_sid_ptr->id.is95.imsi_11_12 = sd_sid_ptr->is95.imsi_11_12;
      break;

    case SD_MODE_HDR:
      sys_sid_ptr->id_type = SYS_SYS_ID_TYPE_IS856;
      /*lint -e{506} Contant value boolean for MIN */
      memscpy( sys_sid_ptr->id.is856,
               sizeof(sys_sid_ptr->id.is856),
               sd_sid_ptr->is856.sector_id,
               ARR_SIZE( sd_sid_ptr->is856.sector_id ) );

      ss_ptr->subnet_mask_len = sd_sid_ptr->is856.subnet_mask_len;
      ss_ptr->info.subnet_mask_len = sd_sid_ptr->is856.subnet_mask_len;

      break;

    case SD_MODE_GSM:
    case SD_MODE_WCDMA:
    case SD_MODE_LTE:
    case SD_MODE_TDS:
      sys_sid_ptr->id_type          = SYS_SYS_ID_TYPE_UMTS;
      sys_sid_ptr->id.plmn_lac.plmn = sd_sid_ptr->plmn.plmn_id;
      sys_sid_ptr->id.plmn_lac.lac  = sd_sid_ptr->plmn.lac;
      break;

    default:
      break;

  } /* switch ( sd_mode ) */

} /* cmss_map_sd_sid_to_sys_sid() */


#if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
/*===========================================================================

FUNCTION  cmss_identify_3gpp_serving_country

DESCRIPTION
  When camped on 3GPP resolve MCC  from PLMN ID and then use as current MCC


DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
   None

SIDE EFFECTS
  Updates current_mcc field of SS object

===========================================================================*/
/*lint -esym(528, cmss_identify_3gpp_serving_country) not referenced */
/*
** called when 3GPP system
*/
static void cmss_identify_3gpp_serving_country (void)
{

  boolean plmn_id_is_undefined;
  boolean mnc_includes_pcs_digit;
  uint32  mcc;
  uint32  mnc;
  cmss_s_type  *ss_ptr = cmss_ptr();

  /*-------------------------------------------------------------*/

  /* get MCC from PLMN */
  sys_plmn_get_mcc_mnc
    (
      ss_ptr->info.sys_id.id.plmn,
      &plmn_id_is_undefined,
      &mnc_includes_pcs_digit,
      &mcc,
      &mnc
    );


  if(mcc == 0 || plmn_id_is_undefined)
  {
    /* MCC or PLMN ID is not valid */
    ss_ptr->info.current_mcc = CM_INVALID_MOBILE_COUNTRY_CODE;
    CM_MSG_HIGH_1 ("decoded mcc or PLMN itself is not valid.set current_mcc = %d",
      ss_ptr->info.current_mcc);

  } else
  {
    ss_ptr->info.current_mcc = (cm_country_code_type) mcc;

    CM_MSG_HIGH_1 ("current_mcc = %d resolved from PLMN_ID ",
                 ss_ptr->info.current_mcc);

  }

  return;
} /* cmss_identify_3gpp_serving_country */

#endif

#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
/*===========================================================================

FUNCTION  cmss_identify_3gpp2_serving_country

DESCRIPTION
  For a given sid this is the order followed
    1> If user has resolved the sid to map to a
     MCC then that MCC is returned.

  2> MCC is derived using sid, ltm_off
     and daylt savings flag.

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
   cm_country_code_type

SIDE EFFECTS
  Updates current_mcc field of SS object

===========================================================================*/
/*lint -esym(528, cmss_identify_3gpp2_serving_country) not referenced */
/*
** called when GW on
*/
static cm_country_code_type cmss_identify_3gpp2_serving_country (void)
{

  cmutil_current_country_e_type status;

  cm_country_code_type  current_mcc = CM_INVALID_MOBILE_COUNTRY_CODE;

  cmss_sid_mcc_assoc_tbl_s_type  *sid_mcc_assoc_ptr
                               = cmss_get_sid_mcc_assoc_ptr ();
  int loop = 0;

  cmss_s_type  *ss_ptr = cmss_ptr();
  /* Pointer to SS object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If serving MCC is a value between 0 and
  ** CM_MAX_MOBILE_COUNTRY_CODE_VAL then copy
  ** or else find MCC
  */
  ss_ptr->info.current_mcc =
              cmss_convert_mcc_ota_to_hpcd(ss_ptr->info.sys_id.id.is95.mcc);

  /* Even though we received this MCC, we are not sure it is valid or not
  ** Becasue many 1x networks send garbage mcc
  ** So If HPCD algorithm indentifies the mcc using (sid, ltm, daylight)
  ** in the follwing code,if it is found that will overwrite the
  ** prl mcc which we received from the network
  */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* First check user table to see if it has already been resolved
  ** by the user. If it is copy it to current_mcc
  */
  for (loop = 0; loop < sid_mcc_assoc_ptr->sid_mcc_tbl_len; ++loop)
  {
    if (sid_mcc_assoc_ptr->sid_mcc_tbl[loop].sid ==
                                              ss_ptr->info.sys_id.id.is95.sid)
    {

      ss_ptr->info.current_mcc = sid_mcc_assoc_ptr->sid_mcc_tbl[loop].country_code;

      CM_MSG_HIGH_1 ("Copying MCC from user table %d",
                   ss_ptr->info.current_mcc);
      return ss_ptr->info.current_mcc;
    }

  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Supply sid, LTM offset, Daylt savings
  ** to identify country
  */

  status =  cmutil_identify_current_country ( ss_ptr->info.sys_id.id.is95.sid,
                                                          ss_ptr->ltm_offset,
                             (sys_daylt_savings_e_type)ss_ptr->daylt_savings,
                                                               &current_mcc);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (status == CMUTIL_CURRENT_COUNTRY_RESOLVED)
  {
    ss_ptr->info.current_mcc = current_mcc;
    CM_MSG_HIGH_1 ("MCC from resolution table %d",ss_ptr->info.current_mcc);
  }
  else
  {

    ss_ptr->info.current_mcc = CM_INVALID_MOBILE_COUNTRY_CODE;

    CM_MSG_HIGH_3 ("Logic to resolve country code failed %d %d %d",
                            ss_ptr->info.sys_id.id.is95.sid,
                                         ss_ptr->ltm_offset,
                                         ss_ptr->daylt_savings);
  }

  return ss_ptr->info.current_mcc;
} /* cmss_identify_3gpp2_serving_country () */

/*===========================================================================

FUNCTION  cmss_identify_3gpp2_mcc_from_prl

DESCRIPTION
  Get the MCC from eqprl.  If no MCC from eqprl or no eqprl, then fallback
  to HPCD table.

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
   None

SIDE EFFECTS
   None

===========================================================================*/
static void cmss_identify_3gpp2_mcc_from_prl(
  const  sys_plmn_mcc_list    *prl_mcc_list,
  cm_country_code_type         current_mcc,
  cm_country_code_type         ota_mcc
)
{

  cmss_s_type *ss_ptr = cmss_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&ss_ptr->info.prl_3gpp2_mcc, 0, sizeof(sys_plmn_mcc_list));

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* 1. if MCC from prl is valid, get MCC from eqprl
  ** 2. else if MCC from HPCD table is valid, get MCC from the table.
  ** 3. else error.
  */
  if (prl_mcc_list)
  {
    if (prl_mcc_list->count != 0)
    {
      int count = 0;
      CM_MSG_HIGH_1("3GPP2_MCC: MCC from PRL count = %d", prl_mcc_list->count);

      for (count = 0; count < prl_mcc_list->count && count < SD_PLMN_MCC_LIST_MAX; count ++)
      {
        ss_ptr->info.prl_3gpp2_mcc.mcc_list[count] = prl_mcc_list->mcc_list[count];
        ss_ptr->info.prl_3gpp2_mcc.count ++;
        CM_MSG_HIGH_2("3GPP2_MCC: MCC from PRL, index=%d, MCC=%d",
                       count, ss_ptr->info.prl_3gpp2_mcc.mcc_list[count]);
      }
      return;
    }
  }

  /* if(prl_3gpp2_mcc==NULL || prl_3gpp2_mcc->count==0) */
  if (current_mcc != CM_INVALID_MOBILE_COUNTRY_CODE)
    {
      CM_MSG_HIGH_1("3GPP2_MCC: MCC from HPCD %d", current_mcc);
      ss_ptr->info.prl_3gpp2_mcc.count = 1;
      ss_ptr->info.prl_3gpp2_mcc.mcc_list[0] = current_mcc;
    }
  else if ( (ota_mcc != CM_INVALID_MOBILE_COUNTRY_CODE) && 
            BETWEEN(ota_mcc, 0, CM_MAX_MOBILE_COUNTRY_CODE_VAL) )
  {
    CM_MSG_HIGH_1("3GPP2_MCC: MCC from OTA %d", ota_mcc);
    ss_ptr->info.prl_3gpp2_mcc.count = 1;
    ss_ptr->info.prl_3gpp2_mcc.mcc_list[0] = ota_mcc;
  }
  else
  {
    CM_MSG_HIGH_0("3GPP2_MCC: ERROR - Fail to get MCC");
  }
}

/*===========================================================================

FUNCTION  cmss_identify_hdr_mcc_from_prl

DESCRIPTION
  Get the MCC from eqprl.  If no MCC from eqprl or no eqprl, then fallback.

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
   None

SIDE EFFECTS
   None

===========================================================================*/
static void cmss_identify_hdr_mcc_from_prl(
  const  sys_plmn_mcc_list    *prl_mcc_list,
  cm_country_code_type        current_mcc,
  cm_country_code_type        ota_mcc
)
{

  cmss_s_type *ss_ptr = cmss_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&ss_ptr->info.prl_hdr_mcc, 0, sizeof(sys_plmn_mcc_list));

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* 1. if MCC from prl is valid, get MCC from eqprl
  ** 2. else if MCC from OTA is valid, get MCC from it.
  ** 3. else error.
  */
  if (prl_mcc_list)
  {
    CM_MSG_HIGH_1("HDR_MCC: MCC from PRL count = %d", prl_mcc_list->count);
    if (prl_mcc_list->count != 0)
    {
      int count = 0;
      for (count = 0; count < prl_mcc_list->count && count < SD_PLMN_MCC_LIST_MAX; count ++)
      {
        ss_ptr->info.prl_hdr_mcc.mcc_list[count] = prl_mcc_list->mcc_list[count];
        ss_ptr->info.prl_hdr_mcc.count ++;
        CM_MSG_HIGH_2("HDR_MCC: MCC from PRL, index=%d, MCC=%d",
                       count, ss_ptr->info.prl_hdr_mcc.mcc_list[count]);
      }
      return;
    }
  }

  /* if(prl_mcc_list==NULL || prl_mcc_list->count==0) */
  if ( (current_mcc != CM_INVALID_MOBILE_COUNTRY_CODE) && 
            BETWEEN(current_mcc, 0, CM_MAX_MOBILE_COUNTRY_CODE_VAL) )
  {
    CM_MSG_HIGH_1("HDR_MCC: MCC from current_mcc %d", current_mcc);
    ss_ptr->info.prl_hdr_mcc.count = 1;
    ss_ptr->info.prl_hdr_mcc.mcc_list[0] = current_mcc;
  }
  else if ( (ota_mcc != CM_INVALID_MOBILE_COUNTRY_CODE) && 
            BETWEEN(ota_mcc, 0, CM_MAX_MOBILE_COUNTRY_CODE_VAL) )
  {
    CM_MSG_HIGH_1("HDR_MCC: MCC from OTA %d", ota_mcc);
    ss_ptr->info.prl_hdr_mcc.count = 1;
    ss_ptr->info.prl_hdr_mcc.mcc_list[0] = ota_mcc;
  }
  else
  {
    CM_MSG_HIGH_0("HDR_MCC: ERROR - Fail to get MCC");
  }
}

#endif


/*===========================================================================
FUNCTION cmss_update_ps_dormant_entry_in_queue

DESCRIPTION
  Update the priority queue as below.

  Pump phone  preferences to top of the queue and change the PS call
  preferences to below phone preferences in following scenario.
  (To do alternate scanning on GW+1X).
    - Data is suspended
    - Serive is not full service.
    - PS call preferences are on top of the queue

  Pump ps call preferences to top of the queue in following scenario
  (To resume dormant data call).
    - Data is suspended
    - UE is already having full service on GW.
    - PS call preferences are below phone preferences.
    - Data available request is pending

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_update_ps_dormant_entry_in_queue( boolean change_priority  )
{

  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
  cmss_s_type            *ss_ptr = cmss_ptr();
      /* Point at serving system object */

  cmph_s_type *ph_ptr = cmph_ptr();
      /* Point at phone object */

  cm_orig_q_s_type   *ph_orig_para_top_ptr = cmtask_orig_para_get_top( CM_SS_MAIN );

  cm_mode_pref_e_type     fav_mode_pref;
  cm_srv_type_e_type      srv_type;
  sys_sys_mode_e_type     sys_mode;
  sd_ss_orig_mode_e_type  orig_mode;

  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) \
        && (defined CM_GW_SUPPORTED)

  sd_ss_mode_pref_e_type   supp_ph_mode_pref = sd_ss_get_supp_mode_pref(
                   cmph_map_cm_mode_pref_to_sd_mode_pref(ph_ptr->main_stack_info.pref_info.mode_pref),
                   cmph_map_cm_band_pref_to_sd_band_pref(ph_ptr->main_stack_info.pref_info.band_pref),
                   ph_ptr->main_stack_info.pref_info.lte_band_pref,
                   cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(ph_ptr->main_stack_info.pref_info.tds_band_pref));

  CM_MSG_HIGH_3("UPDATE_PS_ENTRY: change_priority=%d, ps_data_suspend=%d,ue_init_ps_data_suspend %d",
                  change_priority, 
                  ss_ptr->info.ps_data_suspend,
                  ss_ptr->ue_init_ps_data_suspend);

/* Move the data call below phone object and force SD with pref reas RESTORE and
  ** phone object preferences.
  */
  if( change_priority &&
     (cmtask_orig_para_search_act_type_act_priority
                                         ( CM_SS_MAIN,
                                           CM_ACT_TYPE_DATA_CALL,
                                           CM_ACT_PRIORITY_80 ) != NULL) &&
     ( (SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_GWL )
            || SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_TDS )
           )
          && SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_CDMA_HDR )
     )
    )
  {
(void)cmph_force_pref_on_the_fly(
                        CM_SS_MAX,
                        ph_ptr,
                        SD_SS_PREF_REAS_3GPP_PS_CALL_CONNECT,
                        CM_ACT_TYPE_PH_OBJ,
                        ph_ptr->main_stack_info.pref_info.pref_term,
                        ph_ptr->main_stack_info.pref_info.mode_pref,
                        ph_ptr->main_stack_info.pref_info.band_pref,
                        ph_ptr->main_stack_info.pref_info.lte_band_pref,
                        ph_ptr->main_stack_info.pref_info.tds_band_pref,
                        ph_ptr->main_stack_info.pref_info.prl_pref,
                        ph_ptr->main_stack_info.pref_info.roam_pref,
                        ph_ptr->main_stack_info.pref_info.hybr_pref,
                        ph_ptr->main_stack_info.pref_info.plmn,
                        ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                        CM_OTASP_ACT_CODE_NONE,
                        ph_ptr->main_stack_info.pref_info.acq_order_pref,
                        ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                        (cm_act_id_type)ph_ptr,
                        CM_ACT_UPDATE_REAS_USER,
                        FALSE,
                        cmph_get_acq_pri_order_per_sub(CM_SS_MAX),
                        CM_DEFAULT_VALUE,
                        ph_ptr->main_stack_info.pref_info.csg_id,
                        ph_ptr->main_stack_info.pref_info.csg_rat);

  }
  else
  /* In CDMA+(G/W/L/T) capable phone, if a data call is suspended due to loss of
  ** service, then move it's priority below that of the phone object.
  ** This ensures that a suspended data call doesn't prevent us from
  ** searching for CDMA systems.
  */
  if( ss_ptr->info.ps_data_suspend
      && !cmcall_check_for_call_state_on_ss(CM_SS_MAIN,CM_CALL_STATE_ORIG)
      && cmtask_orig_para_search_act_type_act_priority
                                         ( CM_SS_MAIN,
                                           CM_ACT_TYPE_DATA_CALL,
                                           CM_ACT_PRIORITY_80 ) != NULL
      && ( !sys_srv_status_is_full_srv(ss_ptr->info.srv_status) ||
           !sys_srv_status_is_full_srv(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status))
      && ( (SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_GWL )
            || SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_TDS )
           )
          && SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_CDMA_HDR )
    )
    )
  {
    /* This call fakes the user sending the current phone preferences down.
    ** When this happens, the data call priority is automatically moved
    ** below the phone object priority.
    */
    (void)cmph_force_pref_on_the_fly(
                        CM_SS_MAX,
                        ph_ptr,
                        SD_SS_PREF_REAS_MULTIMODE_SCAN,
                        CM_ACT_TYPE_PH_OBJ,
                        ph_ptr->main_stack_info.pref_info.pref_term,
                        ph_ptr->main_stack_info.pref_info.mode_pref,
                        ph_ptr->main_stack_info.pref_info.band_pref,
                        ph_ptr->main_stack_info.pref_info.lte_band_pref,
                        ph_ptr->main_stack_info.pref_info.tds_band_pref,
                        ph_ptr->main_stack_info.pref_info.prl_pref,
                        ph_ptr->main_stack_info.pref_info.roam_pref,
                        ph_ptr->main_stack_info.pref_info.hybr_pref,
                        ph_ptr->main_stack_info.pref_info.plmn,
                        ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                        CM_OTASP_ACT_CODE_NONE,
                        ph_ptr->main_stack_info.pref_info.acq_order_pref,
                        ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                        (cm_act_id_type)ph_ptr,
                        CM_ACT_UPDATE_REAS_USER,
                        FALSE,
                        cmph_get_acq_pri_order_per_sub(CM_SS_MAX),
                        CM_DEFAULT_VALUE,
                        ph_ptr->main_stack_info.pref_info.csg_id,
                        ph_ptr->main_stack_info.pref_info.csg_rat);

  }
  else
  #endif

  if( (ss_ptr->info.ps_data_suspend  ||
    ss_ptr->ue_init_ps_data_suspend == CM_SS_MAIN )
    && ss_ptr->info.srv_status == SYS_SRV_STATUS_SRV
    && sys_srv_status_is_full_srv(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status)
    && ss_ptr->ps_data_stt == CM_PS_DATA_STT_SRV_ACQ
    && (cmtask_orig_para_search_act_type_act_priority
                                         ( CM_SS_MAIN,
                                           CM_ACT_TYPE_DATA_CALL,
                                           CM_ACT_PRIORITY_BELOW_PH ) != NULL)
    && (ss_ptr->info.sys_mode == SYS_SYS_MODE_WCDMA ||
        ss_ptr->info.sys_mode == SYS_SYS_MODE_GSM ||
        ss_ptr->info.sys_mode == SYS_SYS_MODE_GW ||
        ss_ptr->info.sys_mode == SYS_SYS_MODE_TDS)
    && (ss_ptr->info.srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
        ss_ptr->info.srv_domain == SYS_SRV_DOMAIN_CS_PS)
   )
  {
    boolean is_srv_type_from_call = TRUE;

    /* Data is suspended
    ** UE is already having full service on GW.
    ** PS call preferences are below phone preferences.
    ** Data available request is pending
    */

    srv_type = cmph_get_srv_type_ext(CM_CALL_TYPE_PS_DATA, &is_srv_type_from_call);
    if((srv_type == CM_SRV_TYPE_NONE) && (FALSE == is_srv_type_from_call))
    {
      /* No PS data call present so we can clean up queue i.e. removing data call objects
      ** which are below PH
      */
      CM_MSG_MED_0("No PS data call present so removing data call objects from queue");
      cmph_remove_orig_mode(CM_SS_MAIN, CM_ACT_TYPE_DATA_CALL, CM_ACT_PRIORITY_BELOW_PH);
      return;
    }

    /* If srv_type is AUTOMATIC, convert it based on sys mode */
    if (srv_type == CM_SRV_TYPE_AUTOMATIC)
    {
      sys_mode = sd_misc_get_curr_acq_sys_mode ();
      srv_type = cmph_map_sys_mode_to_srv_type(sys_mode);
    }

    /* Compute fav_mode_pref.
    ** It is the intersection of phone's mode preference and
    ** srv_type of the call.
    */
    fav_mode_pref = cmph_misc_intersect_mode_pref(
                       srv_type,
                       ph_ptr->main_stack_info.pref_info.mode_pref
                       );

    /* Change the mode_pref of all data calls to computed fav_mode_pref
    */
    if (fav_mode_pref != CM_MODE_PREF_NONE)
    {
      (void)cmtask_orig_para_change_mode_pref( CM_SS_MAIN,
                                               CM_ACT_TYPE_DATA_CALL,
                                               fav_mode_pref,
                                               TRUE );
    }
    else
    {
      CM_MSG_MED_0("Intersection of call_ptr's srv_type and ph_ptr's mode_pref is NONE, mode_pref not changed" );
    }

    /*
    ** pump the priority of all data calls over to phone object
    ** phone object
    */
    (void)cmtask_orig_para_change_act_priority( CM_SS_MAIN,
                                                CM_ACT_TYPE_DATA_CALL,
                                                CM_ACT_PRIORITY_BELOW_PH,
                                                CM_ACT_PRIORITY_80,
                                                TRUE );

    /* The pointer to the top element of the priority queue */
    ph_orig_para_top_ptr = cmtask_orig_para_get_top( CM_SS_MAIN );

    if ( ph_orig_para_top_ptr!= NULL )
    {
      cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

      orig_mode = ph_orig_para_top_ptr->orig->orig_mode;

      /* recompute the orig_mode, based on net sel mode pref */
      if( ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE &&
          ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
      }
      else if (ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NORMAL &&
          ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
      }

      /* Waiting for ok_to_orig report from SD if there is a call. */
      cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue(
          CM_SS_MAIN,
          SD_SS_PREF_REAS_ORIG_RESUME,
          orig_mode,
          FALSE,
          ph_orig_para_top_ptr,
          CM_ACT_UPDATE_REAS_NONE,
          &cmd
          );

      cmmsimc_proc_cmd_pref_sys_chgd(&cmd);
    }
  }

  #endif

}
/*lint +esym(529,supp_ph_mode_pref)*/

/*===========================================================================
FUNCTION cmss_update_hybr_2_ps_dormant_entry_in_queue

DESCRIPTION
  Update the priority queue as below.

  Pump phone  preferences to top of the queue and change the PS call
  preferences to below phone preferences in following scenario.
  (To do alternate scanning on GW+1X).
    - Data is suspended
    - Serive is not full service.
    - PS call preferences are on top of the queue

  Pump ps call preferences to top of the queue in following scenario
  (To resume dormant data call).
    - Data is suspended
    - UE is already having full service on GW.
    - PS call preferences are below phone preferences.
    - Data available request is pending

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_hybr_2_ps_dormant_entry_in_queue( void )
{

  #if ( defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_TDSCDMA) )
  cmss_s_type            *ss_ptr = cmss_ptr();
      /* Point at serving system object */

  cmph_s_type            *ph_ptr = cmph_ptr();
      /* Point at phone object */

  cm_orig_q_s_type       *ph_orig_para_top_ptr =
                                      cmtask_orig_para_get_top( CM_SS_HYBR_2 );

  cm_mode_pref_e_type    fav_mode_pref;
  cm_srv_type_e_type     srv_type;
  sys_sys_mode_e_type    sys_mode;
  sd_ss_orig_mode_e_type  orig_mode;

  sys_modem_as_id_e_type   asubs_id
    = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2);

  #if (defined (CM_GW_SUPPORTED) && \
      (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)))
  sd_ss_mode_pref_e_type  supp_ph_mode_pref = SD_SS_MODE_PREF_ANY;

  if (cmph_is_msim())
  {
     supp_ph_mode_pref = sd_ss_get_supp_mode_pref(
          cmph_map_cm_mode_pref_to_sd_mode_pref(
                               ph_ptr->hybr_2_stack_info.pref_info.mode_pref),
          cmph_map_cm_band_pref_to_sd_band_pref(
                               ph_ptr->hybr_2_stack_info.pref_info.band_pref),
          ph_ptr->hybr_2_stack_info.pref_info.lte_band_pref,
          cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                               ph_ptr->hybr_2_stack_info.pref_info.tds_band_pref));

    supp_ph_mode_pref
      = sd_misc_get_common_mode_pref(supp_ph_mode_pref,
                                     cmmsc_get_cm_ss_mode_cap(CM_SS_HYBR_2));
  }
  #endif

  /* In a CDMA+GW capable phone, if a data call is suspended due to loss of
  ** service, then move it's priority below that of the phone object.
  ** This ensures that a suspended data call doesn't prevent us from
  ** searching for CDMA systems.
  */
  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) \
      && (defined CM_GW_SUPPORTED)
  if( ss_ptr->info.gw_ps_data_suspend
      && !cmcall_check_for_call_state_on_ss(CM_SS_HYBR_2,CM_CALL_STATE_ORIG)
      &&
      cmtask_orig_para_search_act_type_act_priority
                                         ( CM_SS_HYBR_2,
                                           CM_ACT_TYPE_DATA_CALL,
                                           CM_ACT_PRIORITY_80 ) != NULL
      &&
      (!sys_srv_status_is_full_srv(ss_ptr->info.gw_srv_status) ||
         !sys_srv_status_is_full_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status))
      &&
      ( ( SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_GWL ) ||
          SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_TDS )) &&
          SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_CDMA_HDR ))
    )
  {
     cm_pref_s_type         *hybr_2_pref_ptr = NULL;
     cm_pref_s_type         *hybr_3_pref_ptr = NULL;
     /* Allocate buffer only if multi-sim */
     if (cmph_is_msim())
     {
       hybr_2_pref_ptr = cm_pref_ptr();
       memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                      &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
    }

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
       hybr_3_pref_ptr = cm_pref_ptr();
       memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                      &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
    #endif
    /* This call fakes the user sending the current phone preferences down.
    ** When this happens, the data call priority is automatically moved
    ** below the phone object priority.
    */
    (void)cmph_force_pref_on_the_fly2(
                        CM_SS_HYBR_2,
                        ph_ptr,
                        SD_SS_PREF_REAS_USER,
                        CM_ACT_TYPE_PH_OBJ,
                        ph_ptr->main_stack_info.pref_info.pref_term,
                        ph_ptr->main_stack_info.pref_info.mode_pref,
                        ph_ptr->main_stack_info.pref_info.band_pref,
                        ph_ptr->main_stack_info.pref_info.lte_band_pref,
                        ph_ptr->main_stack_info.pref_info.tds_band_pref,
                        ph_ptr->main_stack_info.pref_info.prl_pref,
                        ph_ptr->main_stack_info.pref_info.roam_pref,
                        ph_ptr->main_stack_info.pref_info.hybr_pref,
                        ph_ptr->main_stack_info.pref_info.plmn,
                        ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                        ph_ptr->main_stack_info.pref_info.acq_order_pref,
                        ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                        hybr_2_pref_ptr,
                        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
                        hybr_3_pref_ptr,
                        #endif
                        CM_OTASP_ACT_CODE_NONE,
                        (cm_act_id_type)ph_ptr,
                        CM_ACT_UPDATE_REAS_USER,
                        FALSE,
                        cmph_get_acq_pri_order_per_sub(CM_SS_HYBR_2),
                        CM_DEFAULT_VALUE,
                        ph_ptr->main_stack_info.pref_info.csg_id,
                        ph_ptr->main_stack_info.pref_info.csg_rat);

     /* Free allocated buffer */
     if (hybr_2_pref_ptr)
     {
       cm_mem_free (hybr_2_pref_ptr);
     }

     /* Free allocated buffer */
     if (hybr_3_pref_ptr)
     {
       cm_mem_free (hybr_3_pref_ptr);
     }


  }
  else
  #endif

  if( ( ss_ptr->info.gw_ps_data_suspend  ||
        ss_ptr->ue_init_ps_data_suspend
      )
      && ss_ptr->info.gw_srv_status == SYS_SRV_STATUS_SRV
      && sys_srv_status_is_full_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status)
      && ss_ptr->hybr_gw_ps_data_stt == CM_PS_DATA_STT_SRV_ACQ
      && (cmtask_orig_para_search_act_type_act_priority
                                           ( CM_SS_HYBR_2,
                                             CM_ACT_TYPE_DATA_CALL,
                                             CM_ACT_PRIORITY_BELOW_PH ) != NULL)
      && (ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_WCDMA ||
          ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_GSM ||
          ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_GW ||
          ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_TDS)
      && (ss_ptr->info.gw_srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
           ss_ptr->info.gw_srv_domain == SYS_SRV_DOMAIN_CS_PS)
    )
  {
    boolean is_srv_type_from_call = TRUE;

    /* Data is suspended
    ** UE is already having full service on GW.
    ** PS call preferences are below phone preferences.
    ** Data available request is pending
    */

    srv_type = cmph_get_srv_type_ext(CM_CALL_TYPE_PS_DATA, &is_srv_type_from_call);
    if((srv_type == CM_SRV_TYPE_NONE) && (FALSE == is_srv_type_from_call))
    {
      /* No PS data call present so we can clean up queue i.e. removing data call objects
      ** which are below PH
      */
      CM_MSG_MED_0("No PS data call present so removing data call objects from queue");
      cmph_remove_orig_mode(CM_SS_HYBR_2, CM_ACT_TYPE_DATA_CALL, CM_ACT_PRIORITY_BELOW_PH);
      return;
    }

    /* If srv_type is AUTOMATIC, convert it based on sys mode */
    if (srv_type == CM_SRV_TYPE_AUTOMATIC)
    {
      sys_mode = cmss_ptr()->info.gw_sys_mode;
      srv_type = cmph_map_sys_mode_to_srv_type(sys_mode);
    }

    /* Compute fav_mode_pref.
    ** It is the intersection of phone's mode preference and
    ** srv_type of the call.
    */
    fav_mode_pref = cmph_misc_intersect_mode_pref(
                       srv_type,
                       CMPH_SS_MODE_PREF(
                       cmph_map_cm_ss_to_subs(CM_SS_HYBR_2), ph_ptr)
                       );

    /* Change the mode_pref of all data calls to computed fav_mode_pref
    */
    if (fav_mode_pref != CM_MODE_PREF_NONE)
    {
      (void)cmtask_orig_para_change_mode_pref( CM_SS_HYBR_2,
                                               CM_ACT_TYPE_DATA_CALL,
                                               fav_mode_pref,
                                               TRUE );
    }
    else
    {
      CM_MSG_MED_0("Intersection of call_ptr's srv_type and ph_ptr's mode_pref is NONE, mode_pref not changed" );
    }

    /*
    ** pump the priority of all data calls over to phone object
    ** phone object
    */
    (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_2,
                                                CM_ACT_TYPE_DATA_CALL,
                                                CM_ACT_PRIORITY_BELOW_PH,
                                                CM_ACT_PRIORITY_80,
                                                TRUE );

    /* The pointer to the top element of the priority queue */
    ph_orig_para_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_2 );

    if ( ph_orig_para_top_ptr!= NULL )
    {
      cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

      orig_mode = ph_orig_para_top_ptr->orig->orig_mode;

      /* recompute the orig_mode, based on net sel mode pref */
      if( ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE &&
          CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
      }
      else if (ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NORMAL &&
           CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL)
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
      }

      /* Waiting for ok_to_orig report from SD if there is a call. */
      cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue(
          CM_SS_HYBR_2,
          SD_SS_PREF_REAS_ORIG_RESUME,
          orig_mode,
          FALSE,
          ph_orig_para_top_ptr,
          CM_ACT_UPDATE_REAS_NONE,
          &cmd
          );

      cmmsimc_proc_cmd_pref_sys_chgd(&cmd);
    }
  }

  #endif

} /* cmss_update_hybr_2_ps_dormant_entry_in_queue */

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================
FUNCTION cmss_update_hybr_3_ps_dormant_entry_in_queue

DESCRIPTION
  Update the priority queue as below.

  Pump phone  preferences to top of the queue and change the PS call
  preferences to below phone preferences in following scenario.
  (To do alternate scanning on GW+1X).
    - Data is suspended
    - Serive is not full service.
    - PS call preferences are on top of the queue

  Pump ps call preferences to top of the queue in following scenario
  (To resume dormant data call).
    - Data is suspended
    - UE is already having full service on GW.
    - PS call preferences are below phone preferences.
    - Data available request is pending

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_hybr_3_ps_dormant_entry_in_queue( void )
{

  #if ( defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_TDSCDMA) )
  cmss_s_type            *ss_ptr = cmss_ptr();
      /* Point at serving system object */

  cmph_s_type            *ph_ptr = cmph_ptr();
      /* Point at phone object */

  cm_orig_q_s_type       *ph_orig_para_top_ptr =
                                      cmtask_orig_para_get_top( CM_SS_HYBR_3 );

  cm_mode_pref_e_type    fav_mode_pref;
  cm_srv_type_e_type     srv_type;
  sys_sys_mode_e_type    sys_mode;
  sd_ss_orig_mode_e_type  orig_mode;

  sys_modem_as_id_e_type   asubs_id
    = cmph_map_cm_ss_to_subs(CM_SS_HYBR_3);

  #if (defined (CM_GW_SUPPORTED) && \
      (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)))
  sd_ss_mode_pref_e_type  supp_ph_mode_pref = SD_SS_MODE_PREF_ANY;

  if (cmph_is_msim())
  {
     supp_ph_mode_pref = sd_ss_get_supp_mode_pref(
          cmph_map_cm_mode_pref_to_sd_mode_pref(
                               ph_ptr->hybr_3_stack_info.pref_info.mode_pref),
          cmph_map_cm_band_pref_to_sd_band_pref(
                               ph_ptr->hybr_3_stack_info.pref_info.band_pref),
          ph_ptr->hybr_3_stack_info.pref_info.lte_band_pref,
          cmph_map_cm_tds_band_pref_to_sd_tds_band_pref(
                               ph_ptr->hybr_3_stack_info.pref_info.tds_band_pref));

    supp_ph_mode_pref
      = sd_misc_get_common_mode_pref(supp_ph_mode_pref,
                                     cmmsc_get_cm_ss_mode_cap(CM_SS_HYBR_3));
  }
  #endif


  /* In a CDMA+GW capable phone, if a data call is suspended due to loss of
  ** service, then move it's priority below that of the phone object.
  ** This ensures that a suspended data call doesn't prevent us from
  ** searching for CDMA systems.
  */
  #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) \
      && (defined CM_GW_SUPPORTED) 
  if( ss_ptr->info.gw3_ps_data_suspend
      && !cmcall_check_for_call_state_on_ss(CM_SS_HYBR_3,CM_CALL_STATE_ORIG)
      &&
      cmtask_orig_para_search_act_type_act_priority
                                         ( CM_SS_HYBR_3,
                                           CM_ACT_TYPE_DATA_CALL,
                                           CM_ACT_PRIORITY_80 ) != NULL
      &&
      (!sys_srv_status_is_full_srv(ss_ptr->info.gw3_srv_status) ||
         !sys_srv_status_is_full_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status))
      &&
      ( ( SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_GWL ) ||
          SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_TDS )) &&
          SD_MODE_CONTAIN( supp_ph_mode_pref, SD_SS_MODE_PREF_CDMA_HDR ))
    )
  {

     cm_pref_s_type         *hybr_2_pref_ptr = NULL;
     cm_pref_s_type         *hybr_3_pref_ptr = NULL;
     /* Allocate buffer only if multi-sim */
     if (cmph_is_msim())
     {
       hybr_2_pref_ptr = cm_pref_ptr();
       memscpy(hybr_2_pref_ptr, sizeof(cm_pref_s_type),
                      &(ph_ptr->hybr_2_stack_info.pref_info), sizeof(cm_pref_s_type));
    }

    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
       hybr_3_pref_ptr = cm_pref_ptr();
       memscpy(hybr_3_pref_ptr, sizeof(cm_pref_s_type),
                      &(ph_ptr->hybr_3_stack_info.pref_info), sizeof(cm_pref_s_type));
    #endif

    /* This call fakes the user sending the current phone preferences down.
    ** When this happens, the data call priority is automatically moved
    ** below the phone object priority.
    */
    (void)cmph_force_pref_on_the_fly2(
                        CM_SS_HYBR_3,
                        ph_ptr,
                        SD_SS_PREF_REAS_USER,
                        CM_ACT_TYPE_PH_OBJ,
                        ph_ptr->main_stack_info.pref_info.pref_term,
                        ph_ptr->main_stack_info.pref_info.mode_pref,
                        ph_ptr->main_stack_info.pref_info.band_pref,
                        ph_ptr->main_stack_info.pref_info.lte_band_pref,
                        ph_ptr->main_stack_info.pref_info.tds_band_pref,
                        ph_ptr->main_stack_info.pref_info.prl_pref,
                        ph_ptr->main_stack_info.pref_info.roam_pref,
                        ph_ptr->main_stack_info.pref_info.hybr_pref,
                        ph_ptr->main_stack_info.pref_info.plmn,
                        ph_ptr->main_stack_info.pref_info.srv_domain_pref,
                        ph_ptr->main_stack_info.pref_info.acq_order_pref,
                        ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                        hybr_2_pref_ptr,
                        #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
                        hybr_3_pref_ptr,
                        #endif
                        CM_OTASP_ACT_CODE_NONE,
                        (cm_act_id_type)ph_ptr,
                        CM_ACT_UPDATE_REAS_USER,
                        FALSE,
                        cmph_get_acq_pri_order_per_sub(CM_SS_HYBR_3),
                        CM_DEFAULT_VALUE,
                        ph_ptr->main_stack_info.pref_info.csg_id,
                        ph_ptr->main_stack_info.pref_info.csg_rat);

     /* Free allocated buffer */
     if (hybr_2_pref_ptr)
     {
       cm_mem_free (hybr_2_pref_ptr);
     }

     /* Free allocated buffer */
     if (hybr_3_pref_ptr)
     {
       cm_mem_free (hybr_3_pref_ptr);
     }



  }
  else
  #endif

  if( ( ss_ptr->info.gw3_ps_data_suspend  ||
        ss_ptr->ue_init_ps_data_suspend
      )
      && ss_ptr->info.gw3_srv_status == SYS_SRV_STATUS_SRV
      && sys_srv_status_is_full_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status)
      && ss_ptr->hybr_3_gw_ps_data_stt == CM_PS_DATA_STT_SRV_ACQ
      && (cmtask_orig_para_search_act_type_act_priority
                                           ( CM_SS_HYBR_3,
                                             CM_ACT_TYPE_DATA_CALL,
                                             CM_ACT_PRIORITY_BELOW_PH ) != NULL)
      && (ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_WCDMA ||
          ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_GSM ||
          ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_GW ||
          ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_TDS)
      && (ss_ptr->info.gw3_srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
           ss_ptr->info.gw3_srv_domain == SYS_SRV_DOMAIN_CS_PS)
    )
  {
    boolean is_srv_type_from_call = TRUE;

    /* Data is suspended
    ** UE is already having full service on GW.
    ** PS call preferences are below phone preferences.
    ** Data available request is pending
    */

    srv_type = cmph_get_srv_type_ext(CM_CALL_TYPE_PS_DATA, &is_srv_type_from_call);
    if((srv_type == CM_SRV_TYPE_NONE) && (FALSE == is_srv_type_from_call))
    {
      /* No PS data call present so we can clean up queue i.e. removing data call objects
      ** which are below PH
      */
      CM_MSG_MED_0("No PS data call present so removing data call objects from queue");
      cmph_remove_orig_mode(CM_SS_HYBR_3, CM_ACT_TYPE_DATA_CALL, CM_ACT_PRIORITY_BELOW_PH);
      return;
    }

    /* If srv_type is AUTOMATIC, convert it based on sys mode */
    if (srv_type == CM_SRV_TYPE_AUTOMATIC)
    {
      sys_mode = cmss_ptr()->info.gw3_sys_mode;
      srv_type = cmph_map_sys_mode_to_srv_type(sys_mode);
    }

    /* Compute fav_mode_pref.
    ** It is the intersection of phone's mode preference and
    ** srv_type of the call.
    */
    fav_mode_pref = cmph_misc_intersect_mode_pref(
                       srv_type,
                       CMPH_SS_MODE_PREF(
                       cmph_map_cm_ss_to_subs(CM_SS_HYBR_3), ph_ptr)
                       );

    /* Change the mode_pref of all data calls to computed fav_mode_pref
    */
    if (fav_mode_pref != CM_MODE_PREF_NONE)
    {
      (void)cmtask_orig_para_change_mode_pref( CM_SS_HYBR_3,
                                               CM_ACT_TYPE_DATA_CALL,
                                               fav_mode_pref,
                                               TRUE );
    }
    else
    {
      CM_MSG_MED_0("Intersection of call_ptr's srv_type and ph_ptr's mode_pref is NONE, mode_pref not changed" );
    }

    /*
    ** pump the priority of all data calls over to phone object
    ** phone object
    */
    (void)cmtask_orig_para_change_act_priority( CM_SS_HYBR_3,
                                                CM_ACT_TYPE_DATA_CALL,
                                                CM_ACT_PRIORITY_BELOW_PH,
                                                CM_ACT_PRIORITY_80,
                                                TRUE );

    /* The pointer to the top element of the priority queue */
    ph_orig_para_top_ptr = cmtask_orig_para_get_top( CM_SS_HYBR_3 );

    if ( ph_orig_para_top_ptr!= NULL )
    {
      cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

      orig_mode = ph_orig_para_top_ptr->orig->orig_mode;

      /* recompute the orig_mode, based on net sel mode pref */
      if( ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE &&
          CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
      }
      else if (ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NORMAL &&
           CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL)
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
      }

      /* Waiting for ok_to_orig report from SD if there is a call. */
      cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue(
          CM_SS_HYBR_3,
          SD_SS_PREF_REAS_ORIG_RESUME,
          orig_mode,
          FALSE,
          ph_orig_para_top_ptr,
          CM_ACT_UPDATE_REAS_NONE,
          &cmd
          );

      cmmsimc_proc_cmd_pref_sys_chgd(&cmd);
    }
  }

  #endif

} /* cmss_update_hybr_3_ps_dormant_entry_in_queue */
#endif
/*===========================================================================

FUNCTION cmss_sys_mm_info_match

DESCRIPTION
  Compares the mm info fields of given input parameters


DEPENDENCIES

RETURN VALUE
  TRUE if matches, else FALSE

SIDE EFFECTS
  none

===========================================================================*/
static boolean cmss_sys_mm_info_match (

      const cmss_s_type           *ss_ptr,
      const sd_si_info_s_type     *si_info_ptr,
      sd_ss_e_type           ss
)
/*lint -esym(715,ss)*/
{
  if (ss == SD_SS_HYBR_2)
  {
    if ( ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_LTE &&
         ss_ptr->info.gw_sys_id.id_type == SYS_SYS_ID_TYPE_UMTS &&
         ss_ptr->info.gw_mode_info.gw_info.mm_information.plmn_avail == TRUE &&
         sys_plmn_match (ss_ptr->info.gw_mode_info.gw_info.mm_information.plmn,
                         si_info_ptr->sid.plmn.plmn_id))
    {
      return TRUE;
    }
    else if ( ss_ptr->info.gw_sys_id.id_type == SYS_SYS_ID_TYPE_UMTS &&
         ss_ptr->info.gw_mode_info.gw_info.mm_information.plmn_avail == TRUE &&
         sys_plmn_match (ss_ptr->info.gw_mode_info.gw_info.mm_information.plmn,
                         si_info_ptr->sid.plmn.plmn_id) &&
         ss_ptr->info.gw_mode_info.gw_info.mm_information.lac_avail == TRUE &&
         ss_ptr->info.gw_mode_info.gw_info.mm_information.lac_id ==
                                               si_info_ptr->mode_info.gwl.lac
       )
    {
      return TRUE;
    }
    else
    {
      return FALSE;
    }
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if (ss == SD_SS_HYBR_3)
  {
    
    if ( ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_LTE &&
         ss_ptr->info.gw3_sys_id.id_type == SYS_SYS_ID_TYPE_UMTS &&
         ss_ptr->info.gw3_mode_info.gw_info.mm_information.plmn_avail == TRUE &&
         sys_plmn_match (ss_ptr->info.gw3_mode_info.gw_info.mm_information.plmn,
                         si_info_ptr->sid.plmn.plmn_id))
    {
      return TRUE;
    }
    else if ( ss_ptr->info.gw3_sys_id.id_type == SYS_SYS_ID_TYPE_UMTS &&
         ss_ptr->info.gw3_mode_info.gw_info.mm_information.plmn_avail == TRUE &&
         sys_plmn_match (ss_ptr->info.gw3_mode_info.gw_info.mm_information.plmn,
                         si_info_ptr->sid.plmn.plmn_id) &&
         ss_ptr->info.gw3_mode_info.gw_info.mm_information.lac_avail == TRUE &&
         ss_ptr->info.gw3_mode_info.gw_info.mm_information.lac_id ==
                                               si_info_ptr->mode_info.gwl.lac
       )
    {
      return TRUE;
    }
    else
    {
      return FALSE;
    }
  }
  else
  #endif /* FEATURE_MMODE_TRIPLE_SIM */
  {
    if ( ss_ptr->info.sys_mode == SYS_SYS_MODE_LTE &&
         ss_ptr->info.sys_id.id_type == SYS_SYS_ID_TYPE_UMTS &&
         ss_ptr->info.mode_info.gw_info.mm_information.plmn_avail == TRUE &&
         sys_plmn_match (ss_ptr->info.mode_info.gw_info.mm_information.plmn,
                         si_info_ptr->sid.plmn.plmn_id))
    {
      return TRUE;
    }
    else if ( ss_ptr->info.sys_id.id_type == SYS_SYS_ID_TYPE_UMTS &&
         ss_ptr->info.mode_info.gw_info.mm_information.plmn_avail == TRUE &&
         sys_plmn_match (ss_ptr->info.mode_info.gw_info.mm_information.plmn,
                         si_info_ptr->sid.plmn.plmn_id) &&
         ss_ptr->info.mode_info.gw_info.mm_information.lac_avail == TRUE &&
         ss_ptr->info.mode_info.gw_info.mm_information.lac_id    ==
                                             si_info_ptr->mode_info.gwl.lac
       )
    {
      return TRUE;
    }
    else
    {
      return FALSE;
    }
  }
}
/*lint +esym(715,ss)*/

/*===========================================================================

FUNCTION  cmss_update_cdma_srv_lte_do_redir

DESCRIPTION
 Reset the timer cmss_reset_main_buffer_srv_uptime to NONE
 and update CDMA service.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_update_cdma_srv_lte_do_redir (void)
{
  cmss_s_type           *ss_ptr  =  cmss_ptr();

  /* Reset the flag */
  if (ss_ptr->main_buffer_srv_uptime != CMSS_INFORM_SRV_CHANGE_INTER_NONE)
  {
    // converting internal srv status to actual srv status
    cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status =
    sys_intl_srv_status_to_actl_srv_status(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status);
    cmss_update_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN), FALSE);

    ss_ptr->main_buffer_srv_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;

    CM_MSG_HIGH_0("RESET main_srv_buffer_uptime");
  }
}

/*===========================================================================
FUNCTION cmss_update_srv_status_for_main

DESCRIPTION
  Updates status, mode, band and channel for new service indication
  atomically.
===========================================================================*/
static void cmss_update_srv_status_for_main(

    sys_srv_status_e_type new_srv_status,
      /* New service status from SD */

    sys_sys_mode_e_type   new_sys_mode,
      /* New mode from SD */

    sys_band_class_e_type new_active_band,
      /* New band from SD */

    sys_channel_num_type  new_active_chan
      /* New channel from SD */
)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  rex_enter_crit_sect(cmtask_crit_sect_ptr());

  ss_ptr->info.srv_status = new_srv_status;
  ss_ptr->info.sys_mode = new_sys_mode;
  ss_ptr->info.active_band = new_active_band;
  ss_ptr->info.active_channel = new_active_chan;

  rex_leave_crit_sect(cmtask_crit_sect_ptr());
}

/*===========================================================================

FUNCTION cmss_is_no_srv_buffering_required

DESCRIPTION
  If NO service reported by SD due to 1x/GW subscription not
  available, immediately report it to clients and further ss
  evt's will have no srv/pwr save untill subscription is
  available again

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  boolean

SIDE EFFECTS
  none

===========================================================================*/
static boolean cmss_is_no_srv_buffering_required
(
  cm_ss_e_type ss
)
{
  boolean buffer_no_srv = TRUE;

  cmph_s_type              *ph_ptr = cmph_ptr();
  cmss_s_type              *ss_ptr = cmss_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (ss ==CM_SS_MAIN && ss_ptr->info.srv_status == SYS_SRV_STATUS_SRV &&
    ((!ph_ptr->is_gwl_subscription_available && CM_IS_MODE_3GPP(ss_ptr->info.sys_mode )) ||
       (!ph_ptr->is_cdma_subscription_available && ss_ptr->info.sys_mode == SYS_SYS_MODE_CDMA)
       #ifdef FEATURE_MMODE_DUAL_SIM
       ||!(ph_ptr->active_subs & BM(ph_ptr->main_stack_info.asubs_id))
       #endif
       )
     )
   {
     buffer_no_srv = FALSE;
   }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (ss ==CM_SS_HYBR_1
      && ss_ptr->info.hdr_srv_status == SYS_SRV_STATUS_SRV
      &&( !ph_ptr->is_cdma_subscription_available
        #ifdef FEATURE_MMODE_DUAL_SIM
        ||!(ph_ptr->active_subs & BM(ph_ptr->main_stack_info.asubs_id))
        #endif
      )
     )
   {
     buffer_no_srv = FALSE;
   }

  /* HDR service lost on Hybrid stack when Current service domain preference
  ** does not contain PS.
  */
  if ( ss ==CM_SS_HYBR_1
       && ss_ptr->info.hdr_srv_status == SYS_SRV_STATUS_SRV
       && cmmsc_get_common_domain( cmph_map_cm_srv_domain_pref_to_sd(
                                     ph_ptr->main_stack_info.pref_info.srv_domain_pref),
                                SD_SS_SRV_DOMAIN_PREF_PS_ONLY )
                                                 == SD_SS_SRV_DOMAIN_PREF_NONE
       && cmph_is_msim()
     )
  {
    buffer_no_srv = FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(ss ==CM_SS_HYBR_2
     && ( cmph_is_subs_feature_mode_1x_sxlte(cmph_map_cm_ss_to_as_id(ss)) ||
          cmph_is_subs_feature_mode_sglte(cmph_map_cm_ss_to_as_id(ss)) )
     && !ss_ptr->info.is_hybr_gw_operational
     && ss_ptr->hold_hy2_oper_flag_uptime == CMSS_NO_SRV_UPTIME_NONE
     )
  {
    buffer_no_srv = FALSE;
  }

  #ifdef FEATURE_MMODE_DUAL_SIM
  if (ss ==CM_SS_HYBR_2 && !(cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) ||
     cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) ||
     cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_2)) &&
     ss_ptr->info.gw_srv_status == SYS_SRV_STATUS_SRV &&
    ((!ph_ptr->is_hybr_gw_subscription_available )
      || !(ph_ptr->active_subs & BM(ph_ptr->hybr_2_stack_info.asubs_id)))
     )
   {
     buffer_no_srv = FALSE;
   }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
  if (ss ==CM_SS_HYBR_3 && ss_ptr->info.gw3_srv_status == SYS_SRV_STATUS_SRV &&
    ((!ph_ptr->is_hybr_gw3_subscription_available ) ||
      !(ph_ptr->active_subs & BM(ph_ptr->hybr_3_stack_info.asubs_id)))
     )
   {
     buffer_no_srv = FALSE;
   }
  #endif /*defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)*/

  #endif /* FEATURE_MMODE_DUAL_SIM */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return buffer_no_srv;
}


/*===========================================================================
FUNCTION cmss_update_srv_status_for_hybr_2

DESCRIPTION
  Updates status, mode, band and channel for new service indication
  atomically.
===========================================================================*/
/*lint -save -e528 */
static void cmss_update_srv_status_for_hybr_2(

    sys_srv_status_e_type new_srv_status,
      /* New service status from SD */

    sys_sys_mode_e_type   new_sys_mode,
      /* New mode from SD */

    sys_band_class_e_type new_active_band,
      /* New band from SD */

    sys_channel_num_type  new_active_chan
      /* New channel from SD */
)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  rex_enter_crit_sect(cmtask_crit_sect_ptr());

  ss_ptr->info.gw_srv_status = new_srv_status;
  ss_ptr->info.gw_sys_mode = new_sys_mode;
  ss_ptr->info.gw_active_band = new_active_band;
  ss_ptr->info.gw_active_channel = new_active_chan;

  rex_leave_crit_sect(cmtask_crit_sect_ptr());
}
/*lint -restore */


/*===========================================================================

FUNCTION cmss_emergency_call_active_in_cdma

DESCRIPTION
  Check if there is a CDMA emergency call in progress

DEPENDENCIES
  Call object array must have already been initialized with
  cmcall_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static boolean cmss_emergency_call_active_in_cdma(void)
{

  cmcall_s_type   *call_ptr;                    /* Call object pointer */
  cm_iterator_type call_itr;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmcall_obj_iterator_init(&call_itr);

  call_ptr = cmcall_obj_get_next(&call_itr);

  while(call_ptr != NULL)
  {
    if ( call_ptr->cmcall_mode_info.info_type == CM_CALL_MODE_INFO_CDMA &&
         call_ptr->sys_mode == SYS_SYS_MODE_CDMA &&
         call_ptr->call_type  == CM_CALL_TYPE_EMERGENCY )
    {
      return TRUE;
    } /* if ( call_ptr->call_state != CM_CALL_STATE_IDLE ) */

    call_ptr = cmcall_obj_get_next(&call_itr);
  }
  return FALSE;

}

/*===========================================================================

FUNCTION cmss_is_cdma_call_in_conv_in_svlte

DESCRIPTION
  Check if there is a CDMA call in progress in SVLTE mode when LTE no service
  is received on HYBR_2 stack

DEPENDENCIES
  Call object array must have already been initialized with
  cmcall_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static boolean cmss_is_cdma_call_in_conv_in_svlte(
    cmss_s_type               *ss_ptr,
        /* Pointer to a ss object */

    const sd_si_info_s_type   *si_info_ptr
       /* Pointer to buffer containing new service info information */
)
{
  cm_call_id_type call_id = CM_CALL_ID_INVALID;
      /* On-Going call id */

  call_id = cmcall_is_there_a_cdma_call_in_conv();
  CM_MSG_HIGH_3( " CDMA_call_id: %d, hybr_gw_oper %d, si_info_ptr_mode %d",
               call_id, ss_ptr->info.is_hybr_gw_operational, si_info_ptr->mode );

  if( cmcall_ptr(call_id) != NULL &&
      ss_ptr->info.is_hybr_gw_operational &&
      si_info_ptr->mode == SYS_SYS_MODE_LTE )
  {
     CM_MSG_HIGH_0( "LTE Service Lost while 1x call: Expire No Srv Timer Immediately");
     return TRUE;
  }

  return FALSE;
}

/*===========================================================================

FUNCTION cmss_update_hybr_2_srv_ind

DESCRIPTION
  Update the phone object per the new service indicators.

  If service state and/or roaming status is changed, Inform CM clients of
  corresponding events.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_hybr_2_srv_ind(

    cmss_s_type               *ss_ptr,
        /* Pointer to a ss object */

    const sd_si_info_s_type   *si_info_ptr
       /* Pointer to buffer containing new service info information */

)
{
  cmph_s_type              *ph_ptr          = cmph_ptr();
  
  sys_modem_as_id_e_type   subId    = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) ;

  uint8                    stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_2);

    /* Pointer to the PH Object */

  /* Temporary variables to store new srv parameters, so that they can be
  ** written to CMSS global atomically, as they are being shared outside
  ** CM task */
  sys_srv_status_e_type new_gw_srv_status =  ss_ptr->info.gw_srv_status;
  sys_srv_domain_e_type new_gw_srv_domain =  si_info_ptr->srv_domain;
  boolean is_subs_invalid = FALSE;
  /* used to identify if NO_SRV/PWR_SAVE is due to subs change */

  dword clk_time = time_get_uptime_secs();

  cm_policy_config_s_type *pm_ptr = cmpm_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );
  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( si_info_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (!cmph_is_as_id_valid(subId))
  {
    CM_MSG_HIGH_0("START cmss_update_hybr_2_srv_ind(): subs id is not valid" );
    return ;
  }

  /* Exit if non-multi-stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }
  /* If we are in full rat mode and no emergency call, ignore the service indication */
  if((subId > SYS_MODEM_AS_ID_NONE && subId < SYS_MODEM_AS_ID_NO_CHANGE) &&
     (cmph_is_subs_feature_mode_sglte(subId) || cmph_is_subs_feature_mode_normal(subId)) &&
     (pm_ptr->current_policy[subId].service_scan_mode == POLICYMAN_SVC_MODE_LIMITED ) &&
     (cmcall_is_there_a_call_type_per_sub(subId, CM_CALL_TYPE_EMERGENCY, NULL) == CM_CALL_ID_INVALID))
  {
    CM_MSG_HIGH_2("Do not process service svc_scan_mode:%d emerg_call:%d",pm_ptr->current_policy[subId].service_scan_mode,
                           cmcall_is_there_a_call_type_per_sub(subId, CM_CALL_TYPE_EMERGENCY, NULL) );
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ss_ptr->info.changed_fields  = 0;
  ss_ptr->info.changed_fields2  = 0;
  ss_ptr->info.hybr_gw_changed_fields = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
  CM_MSG_HIGH_3( "CMSS HYBR2: req_id received = %d -- %d, info.gw_rssi=%d",
                 si_info_ptr->sys_sel_pref_req_id,
                 ss_ptr->info.sys_sel_pref_req_id,
                 ss_ptr->info.gw_rssi);

  CM_MSG_HIGH_3("CMSS HYBR2: info.sys_mode=%d, info.gw_srv_status=%d, client sys_mode=%d",
                 ss_ptr->info.gw_sys_mode,
                 ss_ptr->info.gw_srv_status,
                 ss_ptr->new_srv_avl_info[subId].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_2)].sys_mode);

  /* Copy csg_info received in srv_ind report only when reported mode is W/L
   ** or there is a change in mode from W/L->some other mode (for eg. W->G)
   */
  if((si_info_ptr->mode == SYS_SYS_MODE_WCDMA || si_info_ptr->mode == SYS_SYS_MODE_LTE) ||
    ((ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_WCDMA || ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_LTE) &&
       ss_ptr->info.gw_sys_mode != si_info_ptr->mode) )
  {
  #ifdef CM_DEBUG
  #error code not present
#else
  *(&(ss_ptr->info.csg_info)) = *(&(si_info_ptr->csg_info));
  CM_MSG_MED_2("Copy csg_info for hybr2 old_mode:%d new_mode:%d", ss_ptr->info.gw_sys_mode, si_info_ptr->mode);
  #endif
  }
  else
  {
    /* Clean up if csg info is not valid */
     ss_ptr->info.csg_info.csg_id = SYS_CSG_ID_INVALID;
     memset(&(ss_ptr->info.csg_info.hnb_name),0,sizeof(sys_home_nodeb_name_type));
  }

  #if defined(CM_GW_SUPPORTED)
  if( !((ph_ptr->hybr_2_stack_info.ens_value == TRUE  &&
        ph_ptr->hybr_2_stack_info.disable_call_type_mask == CM_CALL_TYPE_VOICE_MASK)
        ||
         ph_ptr->lu_reject_auto_enabled)
       &&
       cmph_is_msim())
  {
    /* Default the values of regn reject info upon getting any service
    ** indication or confirmation from LL (Retaining this behavior for older
    ** targets which do not have MM17 requirement)
    */
    cm_ss_init_reg_reject_info( CM_SS_HYBR_2, &ss_ptr->info.gw_reg_reject_info );
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we lost service, set no_srv_uptime to uptime + CMSS_MAX_NO_SRV_TIME.
  ** The no_srv_uptime is checked periodically by the cmss_timer_proc()
  ** function. If no_srv_uptime expires before service is reacquired,
  ** cmss_timer_proc() reports to CM clients of a service lost event.
  */
  switch ( si_info_ptr->srv_status )
  {
    case SYS_SRV_STATUS_NO_SRV:
    case SYS_SRV_STATUS_NO_SRV_INTERNAL:
    {
    /* when the srv_status is no_ service and when the
      ** request ID is greater than 0 , immediatley inform the clients of the
      ** new service status.  Holidng the service status would reset the request ID and
      ** CM would never be able to inform the clients
      */

      if((si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV) && (si_info_ptr->sys_sel_pref_req_id > 0))
      {

      CM_MSG_HIGH_1("handling srv_status - no_serive req_id=%d", si_info_ptr->sys_sel_pref_req_id);
               ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
             ss_ptr->hybr_gw_no_srv_uptime = clk_time;
      }
      /* Otherwise, if we are in Low Power Mode, this means the users
      ** somehow decides to turn off the radio. Or if we are operating
      ** in SVLTE mode and there is a on-going CDMA call and service
      ** lost is reported for LTE on hybr_2 then we have to report
      ** SERVICE LOST IMMEDIATELY.
      */
      if ( (ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
           (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM) ||
           cmss_is_cdma_call_in_conv_in_svlte( ss_ptr, si_info_ptr )
         )
      {
        ss_ptr->hybr_gw_no_srv_uptime = clk_time;

        /* Reset the flag so that cmss info will be notified to clients */
        cmss_update_skip_srv_ind_update(FALSE);

        new_gw_srv_status = SYS_SRV_STATUS_NO_SRV;
        new_gw_srv_domain = SYS_SRV_DOMAIN_NO_SRV;
      }
        /* if subscription becomes unavailable or sub is inactive,
           then we can safely send no srv to clients instead of buffering */
      else if(!cmss_is_no_srv_buffering_required(CM_SS_HYBR_2))
      {
        is_subs_invalid= TRUE;
        ss_ptr->hybr_gw_no_srv_uptime = clk_time;
        new_gw_srv_status = SYS_SRV_STATUS_NO_SRV;
        new_gw_srv_domain = SYS_SRV_DOMAIN_NO_SRV;
        CM_MSG_HIGH_0("HYBR2: Not Buffering, Inform SYS_SRV_STATUS_NO_SRV ");
      }
      /* If req_id in srv ind is non default value, send it to clients right away */
      else if (si_info_ptr->sys_sel_pref_req_id != CM_DEFAULT_VALUE &&
               ph_ptr->is_req_id_pending2 &&
               (CMPH_SS_FEATURE_MODE(CM_SS_HYBR_2, ph_ptr) == SYS_SUBS_FEATURE_MODE_SGLTE))
      {
        ss_ptr->hybr_gw_no_srv_uptime = clk_time;
        new_gw_srv_status = SYS_SRV_STATUS_NO_SRV;
      }

      /* If we detect the SERVICE LOST, we added in CMSS_MAX_NO_SRV_TIME
      ** before reporting to UI. This is to improve the user experience.
      */
      else
      {

        ss_ptr->hybr_gw_no_srv_uptime =
            MIN( ss_ptr->hybr_gw_no_srv_uptime,
            (clk_time +
            cmss_get_srv_ind_uptimer_value(ss_ptr->info.gw_sys_mode,TRUE)));


        new_gw_srv_status      = si_info_ptr->srv_status;
        new_gw_srv_domain      = si_info_ptr->srv_domain;
      }

      CM_MSG_HIGH_2( "NO srv Uptimer hybr_2 %d clk_time %d",
                   ss_ptr->hybr_gw_no_srv_uptime, clk_time);

      /* Taking the backup of sd_si_info,
      ** use this info when no srv timer expires
      */
      *(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)) = *si_info_ptr;

      if(new_gw_srv_status == SYS_SRV_STATUS_NO_SRV)
      {
        /* If skip_srv_ind_update == TRUE, not update ss_ptr and not notify ui */
        if(ss_ptr->skip_srv_ind_update == TRUE)
        {
          cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status = SYS_SRV_STATUS_NO_SRV_INTERNAL;
          CM_MSG_HIGH_3("SC_SGLTE: skip_srv_ind_update=TRUE, hybr_gw_no_srv_uptime %d, clk_time %d, no_srv_uptimer %d",
                      ss_ptr->hybr_gw_no_srv_uptime,clk_time,
                      cmss_srv_ind_uptimers.hybr2_uptimers.no_srv_uptimer);
        }
        else
        {
          CM_MSG_HIGH_2("Srv Lost, si_info_ptr->srv_status %d, new_gw_srv_status=%d",
                     si_info_ptr->srv_status, new_gw_srv_status);
          cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status = new_gw_srv_status;
          cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_domain = new_gw_srv_domain;
          cmss_update_hybr_2_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_2));
        }

      /* Since we  moved out of service, clear the field */
      if (( ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_LIMITED ||
           ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_SRV
          )
         && (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode != SYS_SYS_MODE_HDR)
         )
      {

        ss_ptr->hybr_gw_srv_inform_uptime = clk_time +
            cmss_get_srv_ind_uptimer_value(ss_ptr->info.gw_sys_mode,FALSE);

      }
      else
      {
        ss_ptr->hybr_gw_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
      }
    }
      else
      {
        /* It is a internal service lost,
        ** so do not update the ss_ptr till no_srv_uptimer
        */



        CM_MSG_HIGH_3("Holding intl srv lost = %d uptime =%d,clk_time =%d",
                    si_info_ptr->srv_status, ss_ptr->hybr_gw_no_srv_uptime,clk_time);


      }
     /* reset value of IMS emerg support when service is lost */
      #if defined(FEATURE_IP_CALL) && defined(FEATURE_LTE)
      if((cmph_is_subs_feature_mode_svlte(SYS_MODEM_AS_ID_1) &&
          cmss_ptr()->info.is_hybr_gw_operational) ||
         (cmph_is_subs_feature_mode_normal(cmph_ptr()->hybr_2_stack_info.asubs_id) &&
         (cmcall_misc_is_mode_pref(cmph_get_ss_mode_pref(CM_SS_HYBR_2), CM_MODE_PREF_LTE_ONLY)))
         )
      {
        CM_MSG_LOW_0("reset lte_ims in hybr_2 no_srv" );

        cmsds_update_ims_emerg_support_on_lte(SYS_IMS_LTE_EMERG_SUPP_UNKNOWN);
      }
      #endif
    }
    break;

    case SYS_SRV_STATUS_SRV:
    case SYS_SRV_STATUS_LIMITED:
    case SYS_SRV_STATUS_LIMITED_REGIONAL:
    {

      /* Reset the no_srv_uptime.
      */
      ss_ptr->hybr_gw_no_srv_uptime   = CMSS_NO_SRV_UPTIME_NONE;

      /* Reset LTE div duplex for non-LTE*/
      if(si_info_ptr->mode != SD_MODE_LTE)
      {
        ss_ptr->hybr_gw_div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
      }
      
      /* Take the backup of sd_si_info,
      ** use this info when lmt srv timer expires
          */

      *(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)) = *si_info_ptr;

      /* clients were informed full service before,
      ** so buffering lmt or lmt_reg srv ind till timer got expired
      */
      if((si_info_ptr->is_sys_forbidden)||(ss_ptr->info.sys_sel_pref_req_id > 0))
      {
         CM_MSG_HIGH_1("hybr_2 forbidden or req_id valid %d",ss_ptr->info.sys_sel_pref_req_id);
         cmss_update_hybr_2_lmtd_srv_ind_info(ss_ptr, si_info_ptr, TRUE);
      }
      else
      if((si_info_ptr->srv_status != SYS_SRV_STATUS_SRV &&
         ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_SRV) &&
         (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode != SYS_SYS_MODE_HDR)
        )
      {
        /* uptime is CMSS_INFORM_SRV_CHANGE_TIME when srv indication
        ** transitions to LMTD from SRV. Clients can be informed
        ** once the timer expire.
        */
        ss_ptr->hybr_gw_srv_inform_uptime = clk_time +
            cmss_get_srv_ind_uptimer_value(ss_ptr->info.gw_sys_mode,FALSE);

        CM_MSG_HIGH_2("Holding LmtdSrv,hybr_gw_srv_inform_uptime =%d,clk_time =%d",
              ss_ptr->hybr_gw_srv_inform_uptime,clk_time);


        // Mark srv status as internal Lmt srv
        cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status
          = sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);

      }
      else
      {

        /* If skip_srv_ind_update == TRUE, not update ss_ptr and not notify ui */
        if(ss_ptr->skip_srv_ind_update == TRUE)
        {
          cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status
            = sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);

          CM_MSG_HIGH_1("SC_SGLTE: skip_srv_ind_update=TRUE, no notify ui hybr2_srv_status=%d",
                       si_info_ptr->srv_status);

        }
         /*if main no srv timer is running and hybr_2 get camp indication, buffer limited srv ind on
          ** hybr_2 and wait for srv_cnf or main no_srv timer expire */
         else if(ss_ptr->no_srv_uptime > clk_time &&
                si_info_ptr->mode == SYS_SYS_MODE_LTE &&
                !sys_srv_status_is_full_srv(si_info_ptr->srv_status) &&
                si_info_ptr->srv_domain == SYS_SRV_DOMAIN_CAMPED)
        {
          ss_ptr->hybr_gw_srv_inform_uptime = ss_ptr->no_srv_uptime;
          /* mark internal srv status as internal limited */
            cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status
              = sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);
          CM_MSG_HIGH_1("camp ind hold: hybr_gw_srv_inform_uptime = %d",ss_ptr->hybr_gw_srv_inform_uptime);
          
        }
        else
        {
          /* If 1x hold srv timer is enabled, and LTE service acquired on hybr2 
          ** before 1x hold srv timer expiry, check if it is full or limited service and 
          ** either reset the timer and report service or start the limited srv buffer timer.
          */
          if(ph_ptr->cdma_hold_srv_timer > 0 &&
             si_info_ptr->mode == SYS_SYS_MODE_LTE && 
             ss_ptr->cdma_hold_srv_uptime != CMSS_INFORM_SRV_CHANGE_INTER_NONE &&
             ss_ptr->cdma_hold_srv_uptime > clk_time)
          {
            /* If full service acquired, report service immediately and reset the 1x hold srv timer */
            if(si_info_ptr->srv_status == SYS_SRV_STATUS_SRV)
            {
              CM_MSG_HIGH_0("cdmaholdsrv: LTE full srv acquired; reset 1x hold srv timer and report service");

              cmss_reset_cdma_hold_srv_uptime();
              cmss_update_hybr_2_lmtd_srv_ind_info(ss_ptr, si_info_ptr, FALSE);
            }
            /* If limited or limited regional service, start limited srv buffer timer */
            else 
            {
              ss_ptr->hybr_gw_srv_inform_uptime = clk_time +
              cmss_get_srv_ind_uptimer_value(si_info_ptr->mode,FALSE);

              CM_MSG_HIGH_2("cdmaholdsrv: Holding LmtdSrv,hybr_gw_srv_inform_uptime =%d,clk_time =%d",
                            ss_ptr->hybr_gw_srv_inform_uptime,clk_time);

              /* mark internal srv status as internal limited */
              cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status
                = sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);
            }
          }
          /* if 1x hold srv timer is not enabled, the timer is not set, 
          ** or mode is not LTE, then keep legacy behavior of updating 
          ** hybr2 srv ind info to clients
          */
          else
          {
            cmss_update_hybr_2_lmtd_srv_ind_info(ss_ptr, si_info_ptr, FALSE);
          }
        }
      }
        /* reset value of IMS emerg support */
        if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
           cmss_ptr()->info.is_hybr_gw_operational)
        {
          ss_ptr->info.lte_ims_emerg_avail = SYS_IMS_LTE_EMERG_SUPP_UNKNOWN;
        }
        /* Check IMS voice support status on LTE
         */
        if (cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode == SD_MODE_LTE)
        {
          #if defined(FEATURE_IP_CALL) && defined(FEATURE_LTE)
          cmsds_update_ims_voice_support_on_lte(CM_SS_HYBR_2, si_info_ptr->lte_ims_voice_avail);
          cmsds_update_ims_emerg_support_on_lte(si_info_ptr->lte_ims_emerg_avail);
          #endif

          #ifdef FEATURE_DOMAIN_SELECTION

          /* Handle LTE full service or also limited LTE CS capability */
          if (SYS_SRV_STATUS_SRV == si_info_ptr->srv_status)
          {
            cmsds_process_srv_ind (CM_SS_HYBR_2, si_info_ptr);
            #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
            /* Handle domain selection service indication */
            if(!cmph_is_subs_feature_mode_srlte(cmph_map_cm_ss_to_subs(CM_SS_HYBR_2)))
            {
              cmsoa_process_domain_selection_srv_ind(si_info_ptr, CM_SS_HYBR_2);
            }
            #endif
          }
          #endif
        }


        #if ( defined(FEATURE_HDR_HYBRID))
        /* if 3GPP srv is available then HDR should updated to no srv, need to
        ** update hybr1 with buffered info of LTE.
        ** So updating no srv uptime and simulate clock tick for generating NO SRV event
        ** without waiting for timer kick.
        */
        if( sys_srv_status_is_srv(si_info_ptr->srv_status) &&
          (sd_misc_is_mode_pref((sd_ss_mode_pref_e_type)BM(si_info_ptr->mode),
                                  SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE)) &&
          (SYS_SRV_STATUS_NO_SRV_INTERNAL == cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status ||
           SYS_SRV_STATUS_PWR_SAVE_INTERNAL == cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status))
        {
          sys_srv_status_e_type buffered_srv_status = SYS_SRV_STATUS_NONE;

          //converting internal hdr no srv to no srv for posting srv change to clients

          CM_MSG_HIGH_1("indicate hdr no srv on hybr1 -  acquired mode=%d",
                     si_info_ptr->mode);

          buffered_srv_status =
            cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status;
          cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status =
            sys_intl_srv_status_to_actl_srv_status(buffered_srv_status);
          cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->mode = SYS_SYS_MODE_NO_SRV;

          ss_ptr->hdr_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;
          cmss_update_hybr_1_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_1));
        }
        #endif
        
        /* Reset full_srv_lost globals for HYBR stacks */
        if(cmph_is_subs_feature_mode_1x_sxlte(subId))
        {
          is_hybr1_full_srv_lost = FALSE;
          is_hybr2_full_srv_lost = FALSE;
        }
      break;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SYS_SRV_STATUS_PWR_SAVE:

      /* If skip_srv_ind_update == TRUE, not update ss_ptr and not notify ui */
      if(ss_ptr->skip_srv_ind_update == TRUE)
      {
        *(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)) = *si_info_ptr;
        CM_MSG_HIGH_1("SC_SGLTE: skip_srv_ind_update=TRUE, no notify ui hybr2_srv_status=%d",
                     si_info_ptr->srv_status);

      }


      /* if CDMA  call in place, report power save straight away to UI */
      if(cmss_is_cdma_call_in_conv_in_svlte( ss_ptr, si_info_ptr ))
      {
        *(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)) = *si_info_ptr;
        ss_ptr->hybr_gw_no_srv_uptime = clk_time;
      }
      else
      {
      /* Check if srv_status transitioned to pwr_save.
      */
      if ( new_gw_srv_status != si_info_ptr->srv_status )
      {

       /* Taking the backup of sd_si_info,
          ** use this info when no srv timer expires
          */
          *(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)) = *si_info_ptr;

          /* yes, transitioned to pwr_save on hybr_2 LTE,
          ** continue/start the no_srv timer.
          */

          if(ss_ptr->hybr_gw_no_srv_uptime == CMSS_NO_SRV_UPTIME_NONE)
          {
             sys_sys_mode_e_type temp_sys_mode = ss_ptr->info.gw_sys_mode;
             /* Since we  moved out of service, clear the field */
             ss_ptr->hybr_gw_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;

          /* Otherwise, if we are in Low Power Mode, this means the users
          ** somehow decides to turn off the radio. Then we have to report
          ** SERVICE LOST IMMEDIATELY and report srv domain also as NO_SRV
          */
          if ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
             (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM))
          {
            ss_ptr->hybr_gw_no_srv_uptime = clk_time;
            new_gw_srv_status = SYS_SRV_STATUS_PWR_SAVE;
            new_gw_srv_domain = SYS_SRV_DOMAIN_NO_SRV;
          }
              /* if subscription becomes unavailable or sub is inactive,
                 then we can safely send no srv to clients instead of buffering */
          else if(!cmss_is_no_srv_buffering_required(CM_SS_HYBR_2))
          {
            is_subs_invalid= TRUE;
            ss_ptr->hybr_gw_no_srv_uptime = clk_time;
            new_gw_srv_status = SYS_SRV_STATUS_PWR_SAVE;
            new_gw_srv_domain = SYS_SRV_DOMAIN_NO_SRV;
            CM_MSG_HIGH_0("HYBR2: Not Buffering, Inform SYS_SRV_STATUS_NO_SRV ");
          }
          else
          {
             /* Start NO_SRV timer */

             if( temp_sys_mode == SYS_SYS_MODE_NO_SRV)
             {
                CM_MSG_HIGH_1("ss_ptr->info.gw_sys_mode=%d,use GSM no_srv timer",
                           ss_ptr->info.gw_sys_mode);

                temp_sys_mode = SYS_SYS_MODE_GSM;
             }

             ss_ptr->hybr_gw_no_srv_uptime = clk_time +
             cmss_get_srv_ind_uptimer_value(temp_sys_mode,TRUE);
           }

             CM_MSG_HIGH_1("PWR_SAVE start NO_SRV timer, ss_ptr->hybr_gw_no_srv_uptime %d",
                         ss_ptr->hybr_gw_no_srv_uptime);
           }
           else
           {
             CM_MSG_HIGH_1("PWR_SAVE continue NO_SRV timer, ss_ptr->hybr_gw_no_srv_uptime %d",
                        ss_ptr->hybr_gw_no_srv_uptime);
           }

           /* Put INTERNAL_PWR_SAVE status into the buffer */
           cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status =
            sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);

       }
      /* In a sequence where
      ** 1. Inform  srv_status= pwr_save to clients
      ** 2. Received INTERNAL_NO_SRV . Started  no_srv timer and set internal srv status=NO_SRV_INTERNAL
      ** 3. Again received PWR_SAVE from SD.
      ** As last status informed was pwr_Save and latest status informed by SD is also same, reset no_srv_uptimer
      ** and set internal srv status=PWR_SAVE to reflect latest srv status .
      */
      else if(ss_ptr->hybr_gw_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE &&
              cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL)
       {
        ss_ptr->hybr_gw_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;
        cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status = si_info_ptr->srv_status;
      }/* else if(ss_ptr->hybr_gw_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE...*/

    }

    #if defined(FEATURE_WCDMA)
    #ifdef FEATURE_SEGMENT_LOADING
      if(pi_mmode_wcdma == NULL)
      {
        CM_ERR_0("pi_mmode_wcdma is NULL");
      }
      else
    #endif /* FEATURE_SEGMENT_LOADING */
      {
        /* set rrc deep sleep flag to TRUE only if SD latest action is power save
        ** with valid reason. In case by the time SRV_IND reached to CM if SD
        ** action is changed then no need to inform rrc to go into deep sleep.
        */
        if(sd_misc_is_true_power_save(SD_SS_HYBR_2) &&
           cmph_is_msim())
        {
			if(cmph_is_lte_capable_on_ss(CM_SS_HYBR_2))
			{
              #ifdef FEATURE_SEGMENT_LOADING
              IWCDMA_rrc_set_ue_in_deep_sleep(pi_mmode_wcdma, TRUE);
              #else
              rrc_set_ue_in_deep_sleep(TRUE);
              #endif /* FEATURE_SEGMENT_LOADING */
              CM_MSG_MED_0 ("calling rrc_set_ue_in_deep_sleep(TRUE)");
			}
        }
      }
    #endif /* FEATURE_WCDMA */

    break;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:
      CM_MSG_HIGH_1("Invalid srv_status %d", si_info_ptr->srv_status);
      break;

  } /* switch ( si_info_ptr->srv_status ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the priority queue if necessary. As of now, done only for:
  ** - Suspended PS data call and no/limited service.
  */
  if (cmph_is_msim() && cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) != SYS_MODEM_AS_ID_1)
  {
    cmss_update_hybr_2_ps_dormant_entry_in_queue();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update usable status.
  */
  /* This check is done so that CM code can differentiate between faked
  ** no service and a real no service. Used in
  ** cmcall_is_ok_to_end_hold_orig_period().
  */
  if(si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV &&
     si_info_ptr->mode == SD_MODE_HDR)
  {
    ss_ptr->hybr_gw_usable = SD_SYS_USABLE_UNKNOWN;
  }
  else
  {
    ss_ptr->hybr_gw_usable = si_info_ptr->usable_status;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if clients have to be notified of srv_changed.
  */
  if ( ss_ptr->info.hybr_gw_changed_fields != 0 )
  {
    /* For SVLTE chipset, update ph_ptr->is_sys_sel_pref_rsp_pending.
    */
    if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
       cmss_ptr()->info.is_hybr_gw_operational)
    {
      cmph_reset_sys_sel_pref_rsp_pending();
    }

    if((CMPH_SS_FEATURE_MODE(CM_SS_HYBR_2, ph_ptr) == SYS_SUBS_FEATURE_MODE_SGLTE) &&
       cmss_ptr()->info.is_hybr_gw_operational)
    {
      cmph_reset_sys_sel_pref_rsp_pending2();
    }

    if(cmph_is_msim())
    {
      ph_ptr->hybr_2_stack_info.is_sys_sel_pref_rsp_pending = FALSE;
    }

    /* Update the RSSI in the SS object
    */
    cmss_report_hybr_2_rssi( NULL, NULL, FALSE );

    /* Notify CM clients of any changes in the serving system information.
    */
    ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
    cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );

  } /* if ( changed_fields != 0 ) */
  else if (cmph_is_msim() &&
           (ph_ptr->hybr_2_stack_info.is_sys_sel_pref_rsp_pending) &&
            ((ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == si_info_ptr->srv_status)
             && (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode != SYS_SYS_MODE_HDR)
            )
          )
  {
    /* is_sys_sel_pref_rsp_pending flag is set means Client is waiting for
    ** response against sys_sel_pref cmd, beacuse of no change in other SS
    ** fields, set No_CHANGE_MASK and inform to client with SRV_CHANGED event
    */
    ph_ptr->hybr_2_stack_info.is_sys_sel_pref_rsp_pending = FALSE;
    ss_ptr->info.hybr_gw_changed_fields = CM_SS_NO_CHANGE_MASK;

    /* Update the RSSI in the SS object
    */
    cmss_report_hybr_2_rssi( NULL, NULL, FALSE );

    /* Notify CM clients of any changes in the serving system information.
    */
    ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
    cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );

  } /* if ( changed_fields != 0 ) */
  else if((cmss_ptr()->info.is_hybr_gw_operational) &&
           ( (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) && ph_ptr->is_sys_sel_pref_rsp_pending)
               ||
              ((CMPH_SS_FEATURE_MODE(CM_SS_HYBR_2, ph_ptr) == SYS_SUBS_FEATURE_MODE_SGLTE) && ph_ptr->is_sys_sel_pref_rsp_pending2)
            ) &&
           (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == si_info_ptr->srv_status) &&
           (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode != SYS_SYS_MODE_HDR)
           )
  {
    /* is_sys_sel_pref_rsp_pending flag is set means Client is waiting for
    ** response against sys_sel_pref cmd, beacuse of no change in other SS
    ** fields, set No_CHANGE_MASK and inform to client with SRV_CHANGED event
    */
    if (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1))
    {
      cmph_reset_sys_sel_pref_rsp_pending();
    }
    else
    {
      cmph_reset_sys_sel_pref_rsp_pending2();
    }
    ss_ptr->info.hybr_gw_changed_fields = CM_SS_NO_CHANGE_MASK;

    /* Update the RSSI in the SS object
    */
    cmss_report_hybr_2_rssi( NULL, NULL, FALSE );

    /* Notify CM clients of any changes in the serving system information.
    */
    ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
    cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );
  }

  /* If si_info_ptr carries non default req_id, srv status has not changed, and cm has not
   ** respond to clients, Inform clients now.
   */
  else if ((CMPH_SS_FEATURE_MODE(CM_SS_HYBR_2, ph_ptr) == SYS_SUBS_FEATURE_MODE_SGLTE) &&
            (cmss_ptr()->info.is_hybr_gw_operational) &&
            ph_ptr->is_req_id_pending2 &&
            si_info_ptr->sys_sel_pref_req_id != CM_DEFAULT_VALUE &&
            si_info_ptr->csg_info.csg_id == SYS_CSG_ID_INVALID)
  {
    cmph_reset_sys_sel_pref_rsp_pending2();

    /* Update the RSSI in the SS object */
    cmss_report_hybr_2_rssi( NULL, NULL, FALSE );

    ss_ptr->info.hybr_gw_changed_fields = CM_SS_NO_CHANGE_MASK;

    /* Notify CM clients of any changes in the serving system information. */
    ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
    cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))

  /* If there is a srv lost while waiting for state to resume,
  ** immediately inform client the failure.
  */
  if( ( ss_ptr->hybr_gw_ps_data_stt == CM_PS_DATA_STT_RESUME ) &&
      ( ! sys_srv_status_is_full_srv(si_info_ptr->srv_status) )
    )
  {
    ss_ptr->hybr_gw_ps_data_stt       = CM_PS_DATA_STT_NONE;
    ss_ptr->hybr_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;

    CM_MSG_MED_1("Send PS DATA AVAIL FAIL EVENT srv_status = %d ",
               si_info_ptr->srv_status);

    cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_PS_DATA_FAIL );
  }

  /* If there is a srv lost while waiting for state to resume,
  ** immediately inform client the failure.
  */
  if( cmph_is_subs_feature_mode_1x_sxlte(subId) &&
      ( ss_ptr->ps_data_stt == CM_PS_DATA_STT_RESUME ) &&
      ( ! sys_srv_status_is_full_srv(si_info_ptr->srv_status) )
    )
  {
    ss_ptr->ps_data_stt       = CM_PS_DATA_STT_NONE;
    ss_ptr->no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;

    CM_MSG_MED_1("Send PS DATA AVAIL FAIL EVENT srv_status = %d ",
               si_info_ptr->srv_status);

    cmss_event( CM_SS_MAIN, CM_SS_EVENT_PS_DATA_FAIL );
  }

  #endif
  /*------------------------------------------------------------------*/
  /* Simulate Clock tick for generating NO SRV event without wiating for timer kick  */
  /* This is to avoid scenrio where CM gets NO_SERVICE and request ID is never    */
  /* reported to the cleints even after holding for 4 seconds because the request ID */
   /*  info is reset in SD and CMREGPRX side                   */
  /*------------------------------------------------------------------*/
  if((si_info_ptr->srv_status ==SYS_SRV_STATUS_NO_SRV ) && (si_info_ptr->sys_sel_pref_req_id > 0))
  {

     cmss_hybr_2_timer_proc(0);
  }
  else if ((si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV
       || si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL
       || si_info_ptr->srv_status == SYS_SRV_STATUS_PWR_SAVE
       || si_info_ptr->srv_status == SYS_SRV_STATUS_PWR_SAVE_INTERNAL) &&
      ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
       (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM)  ||
       (is_subs_invalid)
      )
     )
  {
    cmss_hybr_2_timer_proc(0);
  }
} /* cmss_update_hybr_2_srv_ind() */

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================
FUNCTION cmss_update_srv_status_for_hybr_3

DESCRIPTION
  Updates status, mode, band and channel for new service indication
  atomically.
===========================================================================*/
/*lint -save -e528 */
static void cmss_update_srv_status_for_hybr_3(

    sys_srv_status_e_type new_srv_status,
      /* New service status from SD */

    sys_sys_mode_e_type   new_sys_mode,
      /* New mode from SD */

    sys_band_class_e_type new_active_band,
      /* New band from SD */

    sys_channel_num_type  new_active_chan
      /* New channel from SD */
)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  rex_enter_crit_sect(cmtask_crit_sect_ptr());

  ss_ptr->info.gw3_srv_status = new_srv_status;
  ss_ptr->info.gw3_sys_mode = new_sys_mode;
  ss_ptr->info.gw3_active_band = new_active_band;
  ss_ptr->info.gw3_active_channel = new_active_chan;

  rex_leave_crit_sect(cmtask_crit_sect_ptr());
}

/*===========================================================================

FUNCTION cmss_update_hybr_3_srv_ind

DESCRIPTION
  Update the phone object per the new service indicators.

  If service state and/or roaming status is changed, Inform CM clients of
  corresponding events.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_hybr_3_srv_ind(

    cmss_s_type               *ss_ptr,
        /* Pointer to a ss object */

    const sd_si_info_s_type   *si_info_ptr
       /* Pointer to buffer containing new service info information */

)
{
  cmph_s_type              *ph_ptr          = cmph_ptr();
    /* Pointer to the PH Object */
  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_3) ;
    
  uint8                    stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_3);

  /* Temporary variables to store new srv parameters, so that they can be
  ** written to CMSS global atomically, as they are being shared outside
  ** CM task */
  sys_srv_status_e_type new_gw_srv_status =  ss_ptr->info.gw3_srv_status;


  dword clk_time = time_get_uptime_secs();
  sys_srv_domain_e_type new_gw_srv_domain =  si_info_ptr->srv_domain;
  boolean is_subs_invalid = FALSE;
  /* used to identify if NO_SRV/PWR_SAVE is due to subs change */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );
  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( si_info_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if non-multi-stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }
  
  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }
  

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ss_ptr->info.changed_fields  = 0;
  ss_ptr->info.changed_fields2  = 0;
  ss_ptr->info.gw3_changed_fields = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  if(si_info_ptr->sys_sel_pref_req_id != CM_DEFAULT_VALUE
   || ss_ptr->info.sys_sel_pref_req_id != CM_DEFAULT_VALUE)
  {
    CM_MSG_HIGH_2( "HYBR_3 req_id received = %d -- %d",
                 si_info_ptr->sys_sel_pref_req_id,
                 ss_ptr->info.sys_sel_pref_req_id );
    ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
  }


  /* Copy csg_info received in srv_ind report only when reported mode is W/L
   ** or there is a change in mode from W/L->some other mode (for eg. W->G)
   */
  if((si_info_ptr->mode == SYS_SYS_MODE_WCDMA || si_info_ptr->mode == SYS_SYS_MODE_LTE) ||
     ((ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_WCDMA || ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_LTE) &&
             ss_ptr->info.gw3_sys_mode != si_info_ptr->mode) )
  {
  #ifdef CM_DEBUG
  #error code not present
#else
  *(&(ss_ptr->info.csg_info)) = *(&(si_info_ptr->csg_info));
    CM_MSG_MED_2("Copy csg_info for hybr3 old_mode:%d new_mode:%d", ss_ptr->info.gw3_sys_mode, si_info_ptr->mode);
  #endif
  }
  else
  {
    /* Clean up if csg info is not valid */
    ss_ptr->info.csg_info.csg_id = SYS_CSG_ID_INVALID;
    memset(&(ss_ptr->info.csg_info.hnb_name),0,sizeof(sys_home_nodeb_name_type));
  }

  #if defined(CM_GW_SUPPORTED)&& (defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM))
  if( !((ph_ptr->hybr_3_stack_info.ens_value == TRUE  &&
        ph_ptr->hybr_3_stack_info.disable_call_type_mask == CM_CALL_TYPE_VOICE_MASK)
        ||
         ph_ptr->lu_reject_auto_enabled))
  {
    /* Default the values of regn reject info upon getting any service
    ** indication or confirmation from LL (Retaining this behavior for older
    ** targets which do not have MM17 requirement)
    */
    cm_ss_init_reg_reject_info( CM_SS_HYBR_3, &ss_ptr->info.gw3_reg_reject_info );
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we lost service, set no_srv_uptime to uptime + CMSS_MAX_NO_SRV_TIME.
  ** The no_srv_uptime is checked periodically by the cmss_timer_proc()
  ** function. If no_srv_uptime expires before service is reacquired,
  ** cmss_timer_proc() reports to CM clients of a service lost event.
  */
  switch ( si_info_ptr->srv_status )
  {
    case SYS_SRV_STATUS_NO_SRV:
    case SYS_SRV_STATUS_NO_SRV_INTERNAL:
    {
      /* when the srv_status is no_ service and when the
      ** request ID is greater than 0 , immediatley inform the clients of the
      ** new service status.  Holidng the service status would reset the request ID and
      ** CM would never be able to inform the clients
      */

      if((si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV) && (si_info_ptr->sys_sel_pref_req_id > 0))
      {

      CM_MSG_HIGH_1("handling srv_status - no_serive req_id=%d", si_info_ptr->sys_sel_pref_req_id);
               ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
             ss_ptr->hybr_3_gw_no_srv_uptime = clk_time;
      }
      /* Otherwise, if we are in Low Power Mode, this means the users
      ** somehow decides to turn off the radio. Then we have to report
      ** SERVICE LOST IMMEDIATELY
      */
      if ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
          (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM))
      {
        ss_ptr->hybr_3_gw_no_srv_uptime = clk_time;

        /* Reset the flag so that cmss info will be notified to clients */
        cmss_update_skip_srv_ind_update(FALSE);

        new_gw_srv_status = SYS_SRV_STATUS_NO_SRV;
        new_gw_srv_domain = SYS_SRV_DOMAIN_NO_SRV;

      }
      /* if GWL subs becomes not available when in 3GPP service or 1x subs not available
            when in 1x service, we can safely send PWR SAVE to clients instead of buffering */
      else if(!cmss_is_no_srv_buffering_required(CM_SS_HYBR_3))
      {
        is_subs_invalid= TRUE;
        ss_ptr->hybr_3_gw_no_srv_uptime = clk_time;
        new_gw_srv_status = SYS_SRV_STATUS_NO_SRV;
        new_gw_srv_domain = SYS_SRV_DOMAIN_NO_SRV;
        CM_MSG_HIGH_0("HYBR3: Not Buffering, Inform SYS_SRV_STATUS_PWR_SAVE ");

      }
      /* If req_id in srv ind is non default value, send it to clients right away */
      else if (si_info_ptr->sys_sel_pref_req_id != CM_DEFAULT_VALUE &&
               ph_ptr->is_req_id_pending2)
      {
        ss_ptr->hybr_3_gw_no_srv_uptime = clk_time;
        new_gw_srv_status = SYS_SRV_STATUS_NO_SRV;
      }

      /* If we detect the SERVICE LOST, we added in CMSS_MAX_NO_SRV_TIME
      ** before reporting to UI. This is to improve the user experience.
      */
      else
      {


        ss_ptr->hybr_3_gw_no_srv_uptime =
            MIN( ss_ptr->hybr_3_gw_no_srv_uptime,
            (clk_time +
            cmss_get_srv_ind_uptimer_value(ss_ptr->info.gw3_sys_mode,TRUE)));


        new_gw_srv_status      = si_info_ptr->srv_status;
        new_gw_srv_domain      = si_info_ptr->srv_domain;
      }

      CM_MSG_HIGH_2( "NO srv Uptimer hybr_3 %d clk_time %d",
                   ss_ptr->hybr_3_gw_no_srv_uptime, clk_time);

      /* Taking the backup of sd_si_info,
      ** use this info when no srv timer expires
      */
      *(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)) = *si_info_ptr;

      if(new_gw_srv_status == SYS_SRV_STATUS_NO_SRV)
      {

        CM_MSG_HIGH_2("Hybr3:Srv Lost, si_info_ptr->srv_status %d, new_gw_srv_status=%d",
                    si_info_ptr->srv_status, new_gw_srv_status);
        cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status = new_gw_srv_status;
        cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_domain = new_gw_srv_domain;
        cmss_update_hybr_3_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_3));


        /* Since we  moved out of service, clear the field */
        if ( ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_LIMITED ||
             ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_SRV
           )
        {
  
            ss_ptr->hybr_3_gw_srv_inform_uptime = clk_time +
              cmss_get_srv_ind_uptimer_value(ss_ptr->info.gw3_sys_mode,FALSE);
  
        }
        else
        {
          ss_ptr->hybr_3_gw_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
        }
      }
      else
      {
        /* It is a internal service lost,
        ** so do not update the ss_ptr till no_srv_uptimer
        */


        CM_MSG_HIGH_3("Hybr3:Holding intl srv lost = %d uptime =%d,clk_time =%d",
                    si_info_ptr->srv_status, ss_ptr->hybr_3_gw_no_srv_uptime,clk_time);


      }
      if(cmph_is_lte_capable_on_ss(CM_SS_HYBR_3))
      {
        /* reset value of IMS emerg support when service is lost */
        ss_ptr->info.lte_ims_emerg_avail = SYS_IMS_LTE_EMERG_SUPP_UNKNOWN;
        CM_MSG_LOW_0("HYBR3: reset lte_ims_emerg_avail in hybr_3 no_srv" );
      }
    }
    break;

    case SYS_SRV_STATUS_SRV:
    case SYS_SRV_STATUS_LIMITED:
    case SYS_SRV_STATUS_LIMITED_REGIONAL:
    {
      /* If previous sysmode is not LTE, reset voice/sms domain to default first before doing
      ** voice/sms domain selection
      */
      #ifdef FEATURE_CM_LTE
      if(cmss_ptr()->info.gw3_sys_mode != SYS_SYS_MODE_LTE &&
        si_info_ptr->mode == SD_MODE_LTE
       )
      {
        cmsds_update_selected_voice_domain(CM_SS_HYBR_3, SYS_CM_DOMAIN_SEL_DOMAIN_MAX);
        cmsds_update_selected_sms_domain(CM_SS_HYBR_3, SYS_CM_DOMAIN_SEL_DOMAIN_MAX);
        cmsds_ptr()->curr_voice_dom_selected = SYS_CM_DOMAIN_SEL_DOMAIN_MAX;
        cmsds_ptr()->curr_sms_dom_selected = SYS_CM_DOMAIN_SEL_DOMAIN_MAX;
      }
      #endif

      /* Reset the no_srv_uptime.
      */
      ss_ptr->hybr_3_gw_no_srv_uptime   = CMSS_NO_SRV_UPTIME_NONE;

      /* Reset LTE div duplex for non-LTE*/
      if(si_info_ptr->mode != SD_MODE_LTE)
      {
        ss_ptr->gw3_div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
      }
      
      /* Take the backup of sd_si_info,
      ** use this info when lmt srv timer expires
          */

      *(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)) = *si_info_ptr;

      /* clients were informed full service before,
      ** so buffering lmt or lmt_reg srv ind till timer got expired
      */
      if((si_info_ptr->is_sys_forbidden)||(ss_ptr->info.sys_sel_pref_req_id > 0))
      {
         CM_MSG_HIGH_1("hybr_3 forbidden or req_id valid %d",ss_ptr->info.sys_sel_pref_req_id);
         cmss_update_hybr_3_lmtd_srv_ind_info(ss_ptr, si_info_ptr, TRUE);
      }
      else
      if((si_info_ptr->srv_status != SYS_SRV_STATUS_SRV &&
         ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_SRV)
        )
      {
        /* uptime is CMSS_INFORM_SRV_CHANGE_TIME when srv indication
        ** transitions to LMTD from SRV. Clients can be informed
        ** once the timer expire.
          */

          ss_ptr->hybr_3_gw_srv_inform_uptime = clk_time +
            cmss_get_srv_ind_uptimer_value(ss_ptr->info.gw3_sys_mode,FALSE);

          CM_MSG_HIGH_2("Holding LmtdSrv,hybr_3_gw_srv_inform_uptime =%d,clk_time =%d",
              ss_ptr->hybr_3_gw_srv_inform_uptime,clk_time);


        // Mark srv status as internal Lmt srv
        cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status
          = sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);

      }
      else
      {

        cmss_update_hybr_3_lmtd_srv_ind_info(ss_ptr, si_info_ptr, FALSE);

      }

      #if defined(FEATURE_LTE)
      /* reset value of IMS emerg support 
      ** lte_ims_emerg_avail is shared by all stacks as only 1 lte is supported for now.
      */
      if(cmph_is_lte_capable_on_ss(CM_SS_HYBR_3))
      {
        ss_ptr->info.lte_ims_emerg_avail = SYS_IMS_LTE_EMERG_SUPP_UNKNOWN;
      }
      
      /* Check IMS voice support status on LTE
       */
      if (cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->mode == SD_MODE_LTE)
      {
        #if defined(FEATURE_IP_CALL) && defined(FEATURE_LTE)
        cmsds_update_ims_voice_support_on_lte(CM_SS_HYBR_3, si_info_ptr->lte_ims_voice_avail);
        cmsds_update_ims_emerg_support_on_lte(si_info_ptr->lte_ims_emerg_avail);
        #endif

        #ifdef FEATURE_DOMAIN_SELECTION

        /* Handle LTE full service or also limited LTE CS capability */
        if (SYS_SRV_STATUS_SRV == si_info_ptr->srv_status)
        {
          cmsds_process_srv_ind (CM_SS_HYBR_3, si_info_ptr);
        }
        #endif
      }
      
      #if defined FEATURE_DOMAIN_SELECTION
      if(SYS_SRV_STATUS_SRV == si_info_ptr->srv_status &&
         (si_info_ptr->mode == SD_MODE_GSM ||
          si_info_ptr->mode == SD_MODE_WCDMA ||
          si_info_ptr->mode == SD_MODE_CDMA ||
          si_info_ptr->mode == SD_MODE_TDS))
       {
         cmsds_process_srv_ind (CM_SS_HYBR_3,si_info_ptr);
       }
      #endif
      #endif
      
      break;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SYS_SRV_STATUS_PWR_SAVE:

      /* Check if srv_status transitioned to pwr_save.
      */
      if ( new_gw_srv_status != si_info_ptr->srv_status )
      {

        /* Taking the backup of sd_si_info,
        ** use this info when no srv timer expires
        */
        *(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)) = *si_info_ptr;

        /* yes, transitioned to pwr_save on hybr_3 LTE,
        ** continue/start the no_srv timer.
        */

        if(ss_ptr->hybr_3_gw_no_srv_uptime == CMSS_NO_SRV_UPTIME_NONE)
        {
          sys_sys_mode_e_type temp_sys_mode = ss_ptr->info.gw3_sys_mode;

          /* Since we  moved out of service, clear the field */
          ss_ptr->hybr_3_gw_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;

          /* Otherwise, if we are in Low Power Mode, this means the users
          ** somehow decides to turn off the radio. Then we have to report
          ** SERVICE LOST IMMEDIATELY and report srv domain also as NO_SRV
          */
          if ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
              (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM))
          {
            ss_ptr->hybr_3_gw_no_srv_uptime = clk_time;
    
            /* Reset the flag so that cmss info will be notified to clients */
            cmss_update_skip_srv_ind_update(FALSE);
    
            new_gw_srv_status = SYS_SRV_STATUS_PWR_SAVE;
            new_gw_srv_domain = SYS_SRV_DOMAIN_NO_SRV;
    
          }
          
          /* if subscription becomes unavailable or sub is inactive,
             then we can safely send no srv to clients instead of buffering 
          */
          else if(!cmss_is_no_srv_buffering_required(CM_SS_HYBR_3))
          {
            is_subs_invalid= TRUE;
            ss_ptr->hybr_3_gw_no_srv_uptime = clk_time;
            new_gw_srv_status = SYS_SRV_STATUS_PWR_SAVE;
            new_gw_srv_domain = SYS_SRV_DOMAIN_NO_SRV;
            CM_MSG_HIGH_0("HYBR3: Not Buffering, Inform SYS_SRV_STATUS_PWR_SAVE ");
    
          }
          else
          {
            /* Start NO_SRV timer */
            if( temp_sys_mode == SYS_SYS_MODE_NO_SRV)
            {
              CM_MSG_HIGH_1("ss_ptr->info.gw3_sys_mode=%d,use GSM no_srv timer",
                         ss_ptr->info.gw3_sys_mode);

              temp_sys_mode = SYS_SYS_MODE_GSM;
            }

            ss_ptr->hybr_3_gw_no_srv_uptime = clk_time +
            cmss_get_srv_ind_uptimer_value(temp_sys_mode,TRUE);



            CM_MSG_HIGH_1("PWR_SAVE start NO_SRV timer, ss_ptr->hybr_3_gw_no_srv_uptime %d",
                        ss_ptr->hybr_3_gw_no_srv_uptime);
          }
        }
        else
        {
          CM_MSG_HIGH_1("PWR_SAVE continue NO_SRV timer, ss_ptr->hybr_3_gw_no_srv_uptime %d",
                        ss_ptr->hybr_3_gw_no_srv_uptime);
        }

          /* Put INTERNAL_PWR_SAVE status into the buffer */
          cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status =
            sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);

        }
        /* In a sequence where
        ** 1. Inform  srv_status= pwr_save to clients
        ** 2. Received INTERNAL_NO_SRV . Started  no_srv timer and set internal srv status=NO_SRV_INTERNAL
        ** 3. Again received PWR_SAVE from SD.
        ** As last status informed was pwr_Save and latest status informed by SD is also same, reset no_srv_uptimer
        ** and set internal srv status=PWR_SAVE to reflect latest srv status .
        */
        else if(ss_ptr->hybr_3_gw_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE &&
                cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL)
        {
          ss_ptr->hybr_3_gw_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;
          cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status = si_info_ptr->srv_status;
        }/* else if(ss_ptr->hybr_3_gw_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE...*/	  


      #if defined(FEATURE_WCDMA) && defined(FEATURE_MMODE_DUAL_SIM)
      #ifdef FEATURE_SEGMENT_LOADING
      if(pi_mmode_wcdma == NULL)
      {
        CM_ERR_0("pi_mmode_wcdma is NULL");
      }
      else
      #endif /* FEATURE_SEGMENT_LOADING */
      {
        /* set rrc deep sleep flag to TRUE only if SD latest action is power save
        ** with valid reason. In case by the time SRV_IND reached to CM if SD
        ** action is changed then no need to inform rrc to go into deep sleep.
        */
        if(sd_misc_is_true_power_save(SD_SS_HYBR_3))
        {
          if(cmph_is_lte_capable_on_ss(CM_SS_HYBR_3))
          {
            #ifdef FEATURE_SEGMENT_LOADING
            IWCDMA_rrc_set_ue_in_deep_sleep(pi_mmode_wcdma, TRUE);
            #else
            rrc_set_ue_in_deep_sleep(TRUE);
            #endif /* FEATURE_SEGMENT_LOADING */
            CM_MSG_MED_0 ("calling rrc_set_ue_in_deep_sleep(TRUE)");
          }
        }
      }
      #endif /* FEATURE_WCDMA && FEATURE_MMODE_DUAL_SIM */

      break;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:
      CM_MSG_HIGH_1("Invalid srv_status %d", si_info_ptr->srv_status);
      break;

  } /* switch ( si_info_ptr->srv_status ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the priority queue if necessary. As of now, done only for:
  ** - Suspended PS data call and no/limited service & serving domain is not CAMPED.
  */
  if ((si_info_ptr->srv_domain != SYS_SRV_DOMAIN_CAMPED) &&
      (cmph_is_in_emergency_cb() == FALSE))
  {
    cmss_update_hybr_3_ps_dormant_entry_in_queue();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update usable status.
  */
  /* This check is done so that CM code can differentiate between faked
  ** no service and a real no service. Used in
  ** cmcall_is_ok_to_end_hold_orig_period().
  */
  if(si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV &&
     si_info_ptr->mode == SD_MODE_HDR)
  {
    ss_ptr->hybr_3_gw_usable = SD_SYS_USABLE_UNKNOWN;
  }
  else
  {
    ss_ptr->hybr_3_gw_usable = si_info_ptr->usable_status;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if clients have to be notified of srv_changed.
  */
  if ( ss_ptr->info.gw3_changed_fields != 0 )
  {

    if(cmph_is_msim())
    {
      ph_ptr->hybr_3_stack_info.is_sys_sel_pref_rsp_pending = FALSE;
    }

    /* Update the RSSI in the SS object
    */
    cmss_report_hybr_3_rssi( NULL, NULL, FALSE );

    /* Notify CM clients of any changes in the serving system information.
    */
    ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;

    /* Notify CM clients of any changes in the serving system information.
    */
    cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_SRV_CHANGED );

  } /* if ( changed_fields != 0 ) */
  else if (cmph_is_msim() &&
           (ph_ptr->hybr_3_stack_info.is_sys_sel_pref_rsp_pending) &&
            (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == si_info_ptr->srv_status))
  {
    /* is_sys_sel_pref_rsp_pending flag is set means Client is waiting for
    ** response against sys_sel_pref cmd, beacuse of no change in other SS
    ** fields, set No_CHANGE_MASK and inform to client with SRV_CHANGED event
    */
    ph_ptr->hybr_3_stack_info.is_sys_sel_pref_rsp_pending = FALSE;
    ss_ptr->info.gw3_changed_fields = CM_SS_NO_CHANGE_MASK;

    /* Update the RSSI in the SS object
    */
      cmss_report_hybr_3_rssi( NULL, NULL, FALSE );

    /* Notify CM clients of any changes in the serving system information.
    */
    ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;

    /* Notify CM clients of any changes in the serving system information.
    */
    cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_SRV_CHANGED );

  } /* if ( changed_fields != 0 ) */


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))

  /* If there is a srv lost while waiting for state to resume,
  ** immediately inform client the failure.
  */
  if( ( ss_ptr->hybr_3_gw_ps_data_stt == CM_PS_DATA_STT_RESUME ) &&
      ( ! sys_srv_status_is_full_srv(si_info_ptr->srv_status) )
    )
  {
    ss_ptr->hybr_3_gw_ps_data_stt       = CM_PS_DATA_STT_NONE;
    ss_ptr->hybr_3_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;

    CM_MSG_MED_1("Hybr3:Send PS DATA AVAIL FAIL EVENT srv_status = %d ",
               si_info_ptr->srv_status);

    cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_PS_DATA_FAIL );
  }
  #endif
 /*------------------------------------------------------------------*/
  /* Simulate Clock tick for generating NO SRV event without wiating for timer kick  */
  /* This is to avoid scenrio where CM gets NO_SERVICE and request ID is never    */
  /* reported to the cleints even after holding for 4 seconds because the request ID */
   /*  info is reset in SD and CMREGPRX side                   */
  /*------------------------------------------------------------------*/
  if((si_info_ptr->srv_status ==SYS_SRV_STATUS_NO_SRV ) && (si_info_ptr->sys_sel_pref_req_id > 0))
  {
     cmss_hybr_3_timer_proc(0);
  }
  else if ((si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV
       || si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL
       || si_info_ptr->srv_status == SYS_SRV_STATUS_PWR_SAVE
       || si_info_ptr->srv_status == SYS_SRV_STATUS_PWR_SAVE_INTERNAL) &&
      ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
       (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM)  ||
       (is_subs_invalid)
      )
     )
  {
     cmss_hybr_3_timer_proc(0);
  }

} /* cmss_update_hybr_3_srv_ind() */
#endif
/*===========================================================================

FUNCTION cmss_update_srv_ind

DESCRIPTION
  Update the phone object per the new service indicators.

  If service state and/or roaming status is changed, Inform CM clients of
  corresponding events.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_srv_ind(

    cmss_s_type               *ss_ptr,
        /* Pointer to a phone object */

    const sd_si_info_s_type   *si_info_ptr
       /* Pointer to buffer containing new service info information */
)
/*lint -esym(529,prev_true_gw_srv_status)*/
{
  #ifdef FEATURE_HDR_HANDOFF
  sys_sys_mode_e_type      prev_idm;
    /* Remember the current idm */
  #endif // FEATURE_HDR_HANDOFF

  #ifdef FEATURE_BCMCS
  boolean                  bcmcs_supported;
  #endif

  cmph_s_type              *ph_ptr = cmph_ptr();

  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;

  uint8                    stk_id = ph_ptr->ss_subs_map[CM_SS_MAIN].stack_id;


  /* Temporary variables to store new srv parameters, so that they can be
  ** written to CMSS global atomically, as they are being shared outside
  ** CM task */
  sys_sys_mode_e_type      new_sys_mode = ss_ptr->info.sys_mode;
  sys_srv_status_e_type    new_srv_status = ss_ptr->info.srv_status;
  sys_srv_domain_e_type    new_srv_domain = si_info_ptr->srv_domain;
  boolean is_subs_invalid = FALSE;
  /* used to identify if NO_SRV/PWR_SAVE is due to subs change */

  dword clk_time = time_get_uptime_secs();
  cm_policy_config_s_type *pm_ptr = cmpm_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );
  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( si_info_ptr != NULL );

  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }
  

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we are in full rat mode and no emergency call, ignore the service indication */
  if((subId > SYS_MODEM_AS_ID_NONE && subId < SYS_MODEM_AS_ID_NO_CHANGE) &&
     (cmph_is_subs_feature_mode_sglte(subId) || 
     (cmph_is_subs_feature_mode_normal(subId) && !cmph_is_sxlte())) &&
     (pm_ptr->current_policy[subId].service_scan_mode == POLICYMAN_SVC_MODE_LIMITED ) &&
     (cmcall_is_there_a_call_type_per_sub(subId, CM_CALL_TYPE_EMERGENCY, NULL) == CM_CALL_ID_INVALID))
  {
    CM_MSG_HIGH_2("Do not process service svc_scan_mode:%d emerg_call:%d",pm_ptr->current_policy[subId].service_scan_mode,
                          cmcall_is_there_a_call_type_per_sub(subId, CM_CALL_TYPE_EMERGENCY, NULL));
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->info.changed_fields  = 0;
  ss_ptr->info.changed_fields2  = 0;
  ss_ptr->info.hybr_gw_changed_fields = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;

  /* Copy csg_info received in srv_ind report only when reported mode is W/L
   ** or there is a change in mode from W/L->some other mode (for eg. W->G)
   */
  if((si_info_ptr->mode == SYS_SYS_MODE_WCDMA || si_info_ptr->mode == SYS_SYS_MODE_LTE) ||
     ((ss_ptr->info.sys_mode == SYS_SYS_MODE_WCDMA || ss_ptr->info.sys_mode == SYS_SYS_MODE_LTE) &&
             ss_ptr->info.sys_mode != si_info_ptr->mode) )
  {
#ifdef CM_DEBUG
  #error code not present
#else
  if(si_info_ptr->csg_info.csg_id != SYS_CSG_ID_INVALID
    || ss_ptr->info.csg_info.csg_id != SYS_CSG_ID_INVALID)
  {
    *(&(ss_ptr->info.csg_info)) = *(&(si_info_ptr->csg_info));
    CM_MSG_MED_2("Copy csg_info for main old_mode:%d new_mode:%d", ss_ptr->info.sys_mode, si_info_ptr->mode);
  }
#endif
  }
  else
  {
    /* Clean up if csg info is not valid */
    ss_ptr->info.csg_info.csg_id = SYS_CSG_ID_INVALID;
    memset(&(ss_ptr->info.csg_info.hnb_name),0,sizeof(sys_home_nodeb_name_type));
  }

  #ifdef FEATURE_HDR_HANDOFF
  prev_idm              = cmssidm_get_curr_idm();

  /* Invoke IDM module to determine if IDM changed
  */
  cmssidm_proc_rpt_srv_ind_ss_main( si_info_ptr );
  #endif // FEATURE_HDR_HANDOFF

  #ifdef CM_GW_SUPPORTED
  if( !((ph_ptr->main_stack_info.ens_value == TRUE  &&
         ph_ptr->main_stack_info.disable_call_type_mask == CM_CALL_TYPE_VOICE_MASK)
         ||
         ph_ptr->lu_reject_auto_enabled )
    )
  {
    /* Default the values of regn reject info upon getting any service
    ** indication or confirmation from LL (Retaining this behavior for older
    ** targets which do not have MM17 requirement)
    */
    cm_ss_init_reg_reject_info( CM_SS_MAIN, &ss_ptr->info.reg_reject_info );
  }
  #endif
  if(si_info_ptr->sys_sel_pref_req_id != 0)
  {
    CM_MSG_HIGH_1("req_id=%d", si_info_ptr->sys_sel_pref_req_id);
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If timer for buffering is_operational flag on H2 is running, and we get a
  ** service indication on LTE system, reset the timer.
  ** This will cause the is_operational flag for Hybrid 2 stack on the outgoing
  ** SS Event to be FALSE.
  */
  if ( ( ss_ptr->hold_hy2_oper_flag_uptime != CMSS_NO_SRV_UPTIME_NONE &&
         si_info_ptr->mode == SYS_SYS_MODE_LTE &&
         sys_srv_status_is_full_srv(si_info_ptr->srv_status) )
       ||
       !cmmsc_is_device_oprt_in_LTE(cmmsimc_state_machine_ptr(cmph_map_cm_ss_to_subs(CM_SS_MAIN)))
     )
  {
      ss_ptr->hold_hy2_oper_flag_uptime = CMSS_NO_SRV_UPTIME_NONE;
      CM_MSG_HIGH_0("LTE Full Srv: Reset the hold_hy2_oper_flag_uptime");
  }

  /* If we lost service, set no_srv_uptime to uptime + CMSS_MAX_NO_SRV_TIME.
  ** The no_srv_uptime is checked periodically by the cmss_timer_proc()
  ** function. If no_srv_uptime expires before service is reacquired,
  ** cmss_timer_proc() reports to CM clients of a service lost event.
  */

  switch ( si_info_ptr->srv_status )
  {

    case SYS_SRV_STATUS_NO_SRV:
    case SYS_SRV_STATUS_NO_SRV_INTERNAL:
    {
      /* when the srv_status is no_ service and when the
      ** request ID is greater than 0 , immediatley inform the clients of the
      ** new service status.  Holidng the service status would reset the request ID and
      ** CM would never be able to inform the clients
      */

      if((si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV) && (si_info_ptr->sys_sel_pref_req_id > 0))
      {
         ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
         ss_ptr->no_srv_uptime = clk_time;
      }
      /* Otherwise, if we are in Low Power Mode, this means the users
      ** somehow decides to turn off the radio. Then we have to report
      ** SERVICE LOST IMMEDIATELY
      */
      if ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
          (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM))
      {
        ss_ptr->no_srv_uptime = clk_time;

        /* Reset the flag so that cmss info will be notified to clients */
        cmss_update_skip_srv_ind_update(FALSE);
        if( ph_ptr->lte_do_redir )
        {
          cmph_reset_lte_do_redir();
          ss_ptr->main_buffer_srv_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
        }

        /* reset 1x hold srv timer if oprt mode is LPM or FTM */
        if(ph_ptr->cdma_hold_srv_timer > 0)
        {
          CM_MSG_HIGH_0("cdmaholdsrv: OPRT mode is LPM/FTM, reset cdma_hold_srv_uptime");
          ss_ptr->cdma_hold_srv_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
        }
		
        new_srv_status = SYS_SRV_STATUS_NO_SRV;
        new_srv_domain = SYS_SRV_DOMAIN_NO_SRV;
      }

      /* If req_id in srv ind is non default value, send it to clients right away */
      else if ((CMPH_SS_FEATURE_MODE(CM_SS_MAIN, ph_ptr) == SYS_SUBS_FEATURE_MODE_SGLTE) &&
                 si_info_ptr->sys_sel_pref_req_id != CM_DEFAULT_VALUE &&
                ph_ptr->is_req_id_pending)
      {
        ss_ptr->no_srv_uptime = clk_time;
        new_srv_status = SYS_SRV_STATUS_NO_SRV;
      }

      /* if GWL subs becomes not available when in 3GPP service or 1x subs not available
          when in 1x service, we can safely send no srv to clients instead of buffering */
      else if(!cmss_is_no_srv_buffering_required(CM_SS_MAIN))
      {
        is_subs_invalid= TRUE;
        ss_ptr->no_srv_uptime = clk_time;
        new_srv_status = SYS_SRV_STATUS_NO_SRV;
        new_srv_domain = SYS_SRV_DOMAIN_NO_SRV;
        CM_MSG_HIGH_0("Not Buffering, Inform SYS_SRV_STATUS_NO_SRV ");

      }

      /* If we detect the SERVICE LOST, we added in CMSS_MAX_NO_SRV_TIME
      ** before reporting to UI. This is to improve the user experience.
      */
      else
      {
		  sys_sys_mode_e_type temp_sys_mode_no_srv = ss_ptr->info.sys_mode;
		  if( temp_sys_mode_no_srv == SYS_SYS_MODE_NO_SRV)
		  {
			  CM_MSG_HIGH_1("ss_ptr->info.sys_mode=%d,use CDMA no_srv timer",
				  ss_ptr->info.sys_mode);
			  temp_sys_mode_no_srv = SYS_SYS_MODE_CDMA;
		  }

          ss_ptr->no_srv_uptime =
            MIN( ss_ptr->no_srv_uptime,
                ( clk_time +
                cmss_get_srv_ind_uptimer_value(temp_sys_mode_no_srv,TRUE)) );
        new_srv_status = si_info_ptr->srv_status;
        new_srv_domain = si_info_ptr->srv_domain;
      }

      /* Reset LTE to DO redirection flag and timer if CDMA NO SRV is received
      ** during LTE to Do redirection. */
      if( (si_info_ptr->mode == SYS_SYS_MODE_CDMA)  &&
           ph_ptr->lte_do_redir )
      {
        cmph_reset_lte_do_redir();
        ss_ptr->main_buffer_srv_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
      }

      /* if CDMA no srv received when 1x hold srv uptime is running, then clear the timer */
      if(ph_ptr->cdma_hold_srv_timer > 0 &&
         (si_info_ptr->mode == SYS_SYS_MODE_CDMA) && 
         ss_ptr->cdma_hold_srv_uptime != CMSS_INFORM_SRV_CHANGE_INTER_NONE)
      {
        CM_MSG_HIGH_0("cdmaholdsrv: CDMA no srv received when cdma_hold_srv_uptime is not expired, reset cdma_hold_srv_uptime");
        ss_ptr->cdma_hold_srv_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
      }
  
      /* Taking the backup of sd_si_info,
      ** use this info when no srv timer expires
      */
      *(cmss_intl_srv_info_ptr(CM_SS_MAIN)) = *si_info_ptr;

      if(new_srv_status == SYS_SRV_STATUS_NO_SRV)
      {
        /* If skip_srv_ind_update == TRUE, not update ss_ptr and not notify ui */
        if(ss_ptr->skip_srv_ind_update == TRUE)
        {
          cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = SYS_SRV_STATUS_NO_SRV_INTERNAL;

          CM_MSG_HIGH_3("SC_SGLTE: skip_srv_ind_update=TRUE, no_srv_uptime %d, clk_time %d,no_srv_uptime %d",
                      ss_ptr->no_srv_uptime,clk_time,
                      cmss_srv_ind_uptimers.main_uptimers.no_srv_uptimer);
        }
        else
        {
          CM_MSG_HIGH_2("Srv Lost, si_info_ptr->srv_status %d, new_gw_srv_status=%d",
                     si_info_ptr->srv_status, new_srv_status);

          cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = new_srv_status;
          cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_domain = new_srv_domain;
          cmss_update_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN));
        }

      /* Since we  moved out of service, clear the field */

      if ( ( ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_LIMITED ) ||
         ( ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_SRV ) )

      {

          ss_ptr->main_srv_inform_uptime = clk_time +
            cmss_get_srv_ind_uptimer_value(ss_ptr->info.sys_mode,FALSE);

        }
        else
        /*lint -e{725} Ignore indentation */
        {
          ss_ptr->main_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
        }
      }
      else
      {
        /* It is a internal service lost,
        ** so do not update the ss_ptr till no_srv_uptimer
        */


          CM_MSG_HIGH_3("Holding srv lost,no_srv_uptime =%d,clk_time =%d, srv_status %d",
                      ss_ptr->no_srv_uptime,clk_time, si_info_ptr->srv_status);


      }

    }

    /* Update bsr_in_progress to FALSE when we lose the service */
    ss_ptr->info.bsr_in_progress = FALSE;

    /* reset value of IMS emerg support when service is lost */
    if((cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
       !ss_ptr->info.is_hybr_gw_operational) ||
       (cmph_is_subs_feature_mode_normal(SYS_MODEM_AS_ID_1) &&
        cmcall_misc_is_mode_pref(cmph_get_ss_mode_pref(CM_SS_MAIN), CM_MODE_PREF_LTE_ONLY))
       )
    {
      ss_ptr->info.lte_ims_emerg_avail = SYS_IMS_LTE_EMERG_SUPP_UNKNOWN;
    }

    break;

    case SYS_SRV_STATUS_SRV:
    case SYS_SRV_STATUS_LIMITED:
    case SYS_SRV_STATUS_LIMITED_REGIONAL:
    {

      /* If previous sysmode is not LTE, reset voice/sms domain to default first before doing
      ** voice/sms domain selection
      */
      #ifdef FEATURE_CM_LTE
      if(cmss_ptr()->info.sys_mode != SYS_SYS_MODE_LTE &&
        si_info_ptr->mode == SD_MODE_LTE
       )
      {
        cmsds_update_selected_voice_domain(CM_SS_MAIN, SYS_CM_DOMAIN_SEL_DOMAIN_MAX);
        cmsds_update_selected_sms_domain(CM_SS_MAIN, SYS_CM_DOMAIN_SEL_DOMAIN_MAX);
        cmsds_ptr()->curr_voice_dom_selected = SYS_CM_DOMAIN_SEL_DOMAIN_MAX;
        cmsds_ptr()->curr_sms_dom_selected = SYS_CM_DOMAIN_SEL_DOMAIN_MAX;
      }
      #endif

      /* Reset the no_srv_uptime.
      */
      ss_ptr->no_srv_uptime   = CMSS_NO_SRV_UPTIME_NONE;

      /* Reset Main LTE div duplex for non-LTE*/
      if(si_info_ptr->mode != SD_MODE_LTE)
      {
        ss_ptr->main_div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
      }

      /* Take the backup of sd_si_info,
      ** use this info when lmt srv timer expires
      */
      *(cmss_intl_srv_info_ptr(CM_SS_MAIN)) = *si_info_ptr;

      /* clients were informed full service,
      ** so buffering lmt or lmt_reg srv ind till timer got expired
      */
      if((si_info_ptr->is_sys_forbidden) || (si_info_ptr->sys_sel_pref_req_id > 0))
      {
         CM_MSG_HIGH_1("forbidden or req_id is valid %d ",si_info_ptr->sys_sel_pref_req_id);
         cmss_update_srv_ind_info(ss_ptr, si_info_ptr, TRUE);
      }
      else
      if((si_info_ptr->srv_status != SYS_SRV_STATUS_SRV &&
          ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_SRV) &&
          /* mode change is within 3gpp/3gpp2 */
              ((CM_IS_MODE_3GPP(ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode) == CM_IS_MODE_3GPP(si_info_ptr->mode)) ||
               ss_ptr->hold_hy2_oper_flag_uptime != CMSS_NO_SRV_UPTIME_NONE ||
               (cmtask_orig_para_search_orig_mode(CM_SS_MAIN, SD_SS_ORIG_MODE_1XCSFB_EMERG_ORIG) != NULL) ||
               (cmtask_orig_para_search_orig_mode(CM_SS_MAIN, SD_SS_ORIG_MODE_1XCSFB_NORMAL_ORIG) != NULL))
         )
      {
        /* uptime is CMSS_INFORM_SRV_CHANGE_TIME when srv indication
        ** transitions to LMTD from SRV. Clients can be informed
        ** once the timer expire.
      */

          ss_ptr->main_srv_inform_uptime = clk_time +
            cmss_get_srv_ind_uptimer_value(ss_ptr->info.sys_mode,FALSE);

          CM_MSG_HIGH_2("Holding LmtdSrv,main_srv_inform_uptime =%d,clk_time =%d",
                      ss_ptr->main_srv_inform_uptime,clk_time);

        //Internally mark as internal srv status Lmt
        cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);

      }
      else
      {
        /* If skip_srv_ind_update == TRUE, not update ss_ptr and not notify ui */
        if(ss_ptr->skip_srv_ind_update == TRUE)
        {
          CM_MSG_HIGH_1("SC_SGLTE: skip_srv_ind_update=TRUE, no notify ui main_srv_status=%d",
                       si_info_ptr->srv_status);

          //Internally mark as internal srv status Lmt
          cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status
            = sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);
        }

        /* Hold reporting service status for timer duration if 1x service received under the following conditions:
        ** -1x hold timer in NV is greater than 0
        ** -LTE full service on MAIN in cmss info reported to clients (note: if limited/limited regional LTE srv and moving to 1x, then report service)
        ** -sub feature mode is 1x_SXLTE -- conditions for which we are going to look for LTE
        ** -hybr2 is operational -- conditions for which we are going to look for LTE
        ** -hybr2 internal service is not LTE service
        ** -hybr1 internal service is not HDR service
        ** -LTE to DO redir timer (main_buffer_srv_uptime) is not running
        */
        else if(ph_ptr->cdma_hold_srv_timer > 0 &&
                (si_info_ptr->mode == SYS_SYS_MODE_CDMA) &&
                (ss_ptr->info.srv_status == SYS_SRV_STATUS_SRV && ss_ptr->info.sys_mode == SYS_SYS_MODE_LTE) && 
                cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) && 
                cmss_is_hybr2_operational() &&
                !( cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode == SD_MODE_LTE && 
                   sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status) ) &&
                !( cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->mode == SD_MODE_HDR && 
                   sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status) ) &&
                ss_ptr->main_buffer_srv_uptime == CMSS_INFORM_SRV_CHANGE_INTER_NONE)   
        {
          if(ss_ptr->cdma_hold_srv_uptime == CMSS_INFORM_SRV_CHANGE_INTER_NONE)
          {
            /* start the 1x hold srv timer and update internal service info pointer */
            ss_ptr->cdma_hold_srv_uptime = time_get_uptime_secs() + ph_ptr->cdma_hold_srv_timer;
            CM_MSG_HIGH_2("cdmaholdsrv: start cdma_hold_srv_uptime : %d, clk time : %d", ss_ptr->cdma_hold_srv_uptime, time_get_uptime_secs());
            cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);
            cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = si_info_ptr->mode;
          }
          else if(ss_ptr->cdma_hold_srv_uptime <= clk_time)
          {
            /* timer expired; do not hold 1x service */
            ss_ptr->cdma_hold_srv_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
            cmss_update_srv_ind_info(ss_ptr, si_info_ptr, FALSE);
          }
        }

        /* If CDMA service indication is received before the LTE to DO redir timer expiry,
        ** hold CDMA service */
        else if(ph_ptr->lte_do_redir && (si_info_ptr->mode == SYS_SYS_MODE_CDMA) )
        {
          if( cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) && ss_ptr->info.is_hybr_gw_operational &&
        ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_SRV )
          {
           // Do not hold the service
            ss_ptr->main_buffer_srv_uptime   = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
            cmss_update_srv_ind_info(ss_ptr, si_info_ptr, FALSE);
          }
          else
          {
            /* Hold reporting service status for the timer duration if CDMA service is received
            ** during LTE to DO redirection  and don't extend the timer on every SRV_IND*/
            if( ss_ptr->main_buffer_srv_uptime == CMSS_INFORM_SRV_CHANGE_INTER_NONE ){
              ss_ptr->main_buffer_srv_uptime   = time_get_uptime_secs() + cdma_srv_lte_do_redir_uptimer;
              CM_MSG_HIGH_2("start main_srv_buffer_uptime : %d, clk time : %d", ss_ptr->main_buffer_srv_uptime, time_get_uptime_secs());
              cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);
              cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = si_info_ptr->mode;
            }
    }
        }
        else
        {
          cmss_update_srv_ind_info(ss_ptr, si_info_ptr, FALSE);
        }
      }

      /* reset value of IMS emerg support */
      if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
         !ss_ptr->info.is_hybr_gw_operational)
      {
        ss_ptr->info.lte_ims_emerg_avail = SYS_IMS_LTE_EMERG_SUPP_UNKNOWN;
      }

      /* Check IMS voice support status on LTE
      */
      if (cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode == SD_MODE_LTE)
      {
        #if defined(FEATURE_IP_CALL) && defined(FEATURE_LTE)
        cmsds_update_ims_voice_support_on_lte(CM_SS_MAIN, si_info_ptr->lte_ims_voice_avail);
        cmsds_update_ims_emerg_support_on_lte(si_info_ptr->lte_ims_emerg_avail);
        #endif

        #ifdef FEATURE_DOMAIN_SELECTION

        /* Handle LTE full service or also limited LTE CS capability */
        if (SYS_SRV_STATUS_SRV == si_info_ptr->srv_status)
        {
          cmsds_process_srv_ind (CM_SS_MAIN, si_info_ptr);
        }
        #endif
      }

      if( (cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode == SD_MODE_LTE)||
           (cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode == SD_MODE_GSM) ||
           (cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode == SD_MODE_WCDMA))
      {
          #ifdef FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH
          /* Handle domain selection service indication */
          if(!cmph_is_subs_feature_mode_srlte(cmph_map_cm_ss_to_subs(CM_SS_MAIN)))
          {
            cmsoa_process_domain_selection_srv_ind(si_info_ptr, CM_SS_MAIN);
          }
          #endif
        }

      /* if HDR srv is available then hybr2 LTE should be in no srv, need to
      ** update hybr2 with buffered info of LTE.
      ** So updating no srv uptime and simulate clock tick for generating NO SRV event
      ** without waiting for timer kick.
    */
      if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
         SYS_SRV_STATUS_SRV == si_info_ptr->srv_status &&
         SD_MODE_HDR == si_info_ptr->mode &&
       SYS_SRV_STATUS_NO_SRV_INTERNAL == cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status &&
       (sd_misc_is_mode_pref((sd_ss_mode_pref_e_type)BM(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode),
                                 SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE))
      )
      {
         //converting internal no srv to  no srv for posting srv change to clients

         CM_MSG_HIGH_1("indicate no 3GPP srv on hybr2 -  acquired mode=%d",
                         si_info_ptr->mode);
         cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status = SYS_SRV_STATUS_NO_SRV;
         cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode = SYS_SYS_MODE_NO_SRV;
         ss_ptr->hybr_gw_no_srv_uptime = SYS_SRV_STATUS_NO_SRV;
         cmss_update_hybr_2_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_2));
      }

      /* if 3GPP has service on main stack, indicate HDR no service without waiting for timer kick.
           */
      #ifdef FEATURE_HDR_HYBRID
      if(  sys_srv_status_is_srv(si_info_ptr->srv_status) &&
           (sd_misc_is_mode_pref((sd_ss_mode_pref_e_type)BM(si_info_ptr->mode),
                                 SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE)) &&
          (SYS_SRV_STATUS_NO_SRV_INTERNAL == cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status ||
           SYS_SRV_STATUS_PWR_SAVE_INTERNAL == cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status ))
      {
        //converting internal no srv to  no srv for posting srv change to clients
        CM_MSG_HIGH_1("indicate hdr no srv on hybr1 -  acquired mode=%d",
                  si_info_ptr->mode);
        cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status = SYS_SRV_STATUS_NO_SRV;
        cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->mode = SYS_SYS_MODE_NO_SRV;
        ss_ptr->hdr_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

        cmss_update_hybr_1_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_1));
      }
      #endif

      #if defined(FEATURE_WCDMA)
      #ifdef FEATURE_SEGMENT_LOADING
      if(pi_mmode_wcdma == NULL)
      {
        CM_ERR_0("pi_mmode_wcdma is NULL");
      }
      else
      {
        IWCDMA_rrc_set_ue_in_deep_sleep(pi_mmode_wcdma, FALSE);
      }
      #else
        rrc_set_ue_in_deep_sleep(FALSE);
      #endif /* FEATURE_SEGMENT_LOADING */
      #endif /* FEATURE_WCDMA */

       #if defined FEATURE_DOMAIN_SELECTION
       if(SYS_SRV_STATUS_SRV == si_info_ptr->srv_status &&
         ((SD_MODE_HDR == si_info_ptr->mode && si_info_ptr->hdr_personality == SYS_PERSONALITY_EHRPD) ||
          si_info_ptr->mode == SD_MODE_GSM ||
          si_info_ptr->mode == SD_MODE_WCDMA ||
          si_info_ptr->mode == SD_MODE_CDMA ||
          si_info_ptr->mode == SD_MODE_TDS) &&
          ss_ptr->skip_srv_ind_update == FALSE)
        {
          cmsds_process_srv_ind (CM_SS_MAIN,si_info_ptr);
        }
       #endif
       break;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case SYS_SRV_STATUS_PWR_SAVE:
    {

      /* If skip_srv_ind_update == TRUE, not update ss_ptr and not notify ui */
      if(ss_ptr->skip_srv_ind_update == TRUE)
      {
        *(cmss_intl_srv_info_ptr(CM_SS_MAIN)) = *si_info_ptr;
        CM_MSG_HIGH_1("SC_SGLTE: skip_srv_ind_update=TRUE, no notify ui main_srv_status=%d",
                       si_info_ptr->srv_status);

      }

      /* Check if srv_status transitioned to pwr_save.
      */
      if ( ss_ptr->info.srv_status != si_info_ptr->srv_status )
      {
         /* Since we  moved out of service, clear the field */
         ss_ptr->main_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;

         /* Otherwise, if we are in Low Power Mode, this means the users
         ** somehow decides to turn off the radio. Then we have to report
         ** SERVICE LOST IMMEDIATELY
         */
         if ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
             (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM))
         {
           ss_ptr->no_srv_uptime = clk_time;

           CM_MSG_HIGH_1("ph_ptr->oprt_mode=%d",ph_ptr->oprt_mode);

         }

         /* if GWL subs becomes not available when in 3GPP service or 1x subs not available
           when in 1x service, we can safely send PWR SAVE to clients instead of buffering */
         else if(!cmss_is_no_srv_buffering_required(CM_SS_MAIN))
         {
           is_subs_invalid= TRUE;
           ss_ptr->no_srv_uptime = clk_time;
           new_srv_status = SYS_SRV_STATUS_PWR_SAVE;
           CM_MSG_HIGH_0("MAIN: Not Buffering, Inform SYS_SRV_STATUS_PWR_SAVE ");

         }
         /* If we detect the PWR_SAVE, we added in CMSS_MAX_NO_SRV_TIME
         ** before reporting to UI. This is to improve the user experience.
         */
         else
         {

             sys_sys_mode_e_type temp_sys_mode = ss_ptr->info.sys_mode;

             if( temp_sys_mode == SYS_SYS_MODE_NO_SRV)
             {
               CM_MSG_HIGH_1("ss_ptr->info.sys_mode=%d,use CDMA no_srv timer",
                           ss_ptr->info.sys_mode);

               temp_sys_mode = SYS_SYS_MODE_CDMA;
             }

             ss_ptr->no_srv_uptime =
               MIN( ss_ptr->no_srv_uptime,
                   ( clk_time +
                     cmss_get_srv_ind_uptimer_value(temp_sys_mode,TRUE)) );



         }

         CM_MSG_HIGH_1("PWR_SAVE NO_SRV timer, ss_ptr->no_srv_uptime=%d",
                     ss_ptr->no_srv_uptime);

         /* Taking the backup of sd_si_info,
         ** use this info when no srv timer expires
         */
         *(cmss_intl_srv_info_ptr(CM_SS_MAIN)) = *si_info_ptr;

         /* Put INTERNAL_PWR_SAVE status into the buffer */
         cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status =
           sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);

      } /* if ( ss_ptr->info.srv_status != si_info_ptr->srv_status ) */
      /* In a sequence where
      ** 1. Inform  srv_status= pwr_save to clients
      ** 2. Received INTERNAL_NO_SRV . Started  no_srv timer and set internal srv status=NO_SRV_INTERNAL
      ** 3. Again received PWR_SAVE from SD.
      ** As last status informed was pwr_Save and latest status informed by SD is also same, reset no_srv_uptimer
      ** and set internal srv status=PWR_SAVE to reflect latest srv status .
      */
      else if(ss_ptr->no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE &&
              cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL)
      {
        ss_ptr->no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;
        cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = si_info_ptr->srv_status;
      }/* else if(ss_ptr->no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE...*/

      /* When receiving power-save, we should update
      ** sys-mode to NO-SRV to avoid the confusion to CM clients.
      */
      if ( new_sys_mode != SYS_SYS_MODE_NO_SRV )
      {
        new_sys_mode = SYS_SYS_MODE_NO_SRV;
        cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = SYS_SYS_MODE_NO_SRV;
      }

      #if defined(FEATURE_WCDMA)
      #ifdef FEATURE_SEGMENT_LOADING
      if(pi_mmode_wcdma == NULL)
      {
        CM_ERR_0("pi_mmode_wcdma is NULL");
      }
      else
      #endif /* FEATURE_SEGMENT_LOADING */
      {
        /* set rrc deep sleep flag to TRUE only if SD latest action is power save
        ** with valid reason. In case by the time SRV_IND reached to CM if SD
        ** action is changed then no need to inform rrc to go into deep sleep.
        */
        if(sd_misc_is_true_power_save(SD_SS_MAIN))
        {
          if(!cmph_is_msim()
              ||
              (cmph_is_msim() &&
               cmph_is_lte_capable_on_ss(CM_SS_MAIN))
           )
          {
            #ifdef FEATURE_SEGMENT_LOADING
            IWCDMA_rrc_set_ue_in_deep_sleep(pi_mmode_wcdma, TRUE);
            #else
            rrc_set_ue_in_deep_sleep(TRUE);
            #endif /* FEATURE_SEGMENT_LOADING */
            CM_MSG_MED_0 ("calling rrc_set_ue_in_deep_sleep(TRUE)");
          }
        }
      }
      #endif /* FEATURE_WCDMA */
    }
    break;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:
      CM_MSG_HIGH_1("Invalid srv_status %d", si_info_ptr->srv_status);
      break;

  } /* switch ( si_info_ptr->srv_status ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->info.available_plmn_type = si_info_ptr->reg_domain;

  if(ss_ptr->info.available_plmn_type != SYS_REG_DOMAIN_NOT_APPLICABLE)
  {
    CM_MSG_HIGH_1("SGLTE: Updating available_plmn_type = %d",
                                          ss_ptr->info.available_plmn_type);
  }
  /* Update the priority queue if necessary. As of now, done only for:
  ** - Suspended PS data call and no/limited service & serving domain is not CAMPED.
  */
  if ((si_info_ptr->srv_domain != SYS_SRV_DOMAIN_CAMPED) &&
      (cmph_is_in_emergency_cb() == FALSE))
  {
    cmss_update_ps_dormant_entry_in_queue(FALSE);
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_HDR_HANDOFF
  /*
  ** If IDM changed, update SS object & notify CM clients of
  ** the corresponding event.
  */
  if ( cmssidm_get_curr_idm() != prev_idm )
  {
    ss_ptr->info.changed_fields |= CM_SS_IDLE_DIGITAL_MODE_MASK;
    ss_ptr->info.cur_idle_digital_mode = cmssidm_get_curr_idm();
    ss_ptr->info.prev_idle_digital_mode = cmssidm_get_prev_idm();
  }
  #endif // FEATURE_HDR_HANDOFF

  #ifdef FEATURE_CALL_THROTTLE
  /* If the new system is not throttled, update the
  ** ss object throtting status
  */
  if(cmss_update_thr_status())
  {
    ss_ptr->info.changed_fields |= CM_SS_ORIG_THR_STATUS_MASK;
  }
  #endif

  #ifdef FEATURE_BCMCS
  /*
  ** If HDR sent an explicit BCMCS status, different from the previous one,
  ** then pass it on. Used by DS to decide when to bring up/down the flows.
  */
  bcmcs_supported = cmbcmcs_srv_status_is_srv(si_info_ptr->bcmcs_srv_status);
  if(ss_ptr->info.ss_main_bcmcs_srv_supported != bcmcs_supported)
  {
    CM_MSG_HIGH_1("BCMCS supported=%d",bcmcs_supported);

    ss_ptr->info.ss_main_bcmcs_srv_supported = bcmcs_supported;
    ss_ptr->info.changed_fields |= CM_SS_MAIN_BCMCS_SRV_SUPPORTED_MASK;
  }

  if(ss_ptr->info.changed_fields &
     (CM_SS_SRV_STATUS_MASK | CM_SS_MAIN_BCMCS_SRV_SUPPORTED_MASK))

  {
    ss_ptr->info.ss_main_bcmcs_srv_status =
      cmss_compute_bcmcs_srv_status(ss_ptr->info.ss_main_bcmcs_srv_supported,
                                    ss_ptr->main_srv_status );
  }
  #endif /* FEATURE_BCMCS */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update usable status.
  */
  /* This check is done so that CM code can differentiate between faked
  ** no service and a real no service. Used in
  ** cmcall_is_ok_to_end_hold_orig_period().
  */
  if(si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV &&
     si_info_ptr->mode == SD_MODE_HDR)
  {
    ss_ptr->ss_main_usable = SD_SYS_USABLE_UNKNOWN;
  }
  else
  {
    ss_ptr->ss_main_usable = si_info_ptr->usable_status;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( (ss_ptr->main_buffer_srv_uptime != CMSS_INFORM_SRV_CHANGE_INTER_NONE) &&
      (ss_ptr->main_buffer_srv_uptime > clk_time) &&
      (si_info_ptr->mode == SYS_SYS_MODE_CDMA))
   {
     ss_ptr->info.changed_fields = 0;
     ss_ptr->info.changed_fields2 = 0;
   }

  /* if 1x hold srv timer not expired, set changed fields to 0 */
  if( ph_ptr->cdma_hold_srv_timer > 0 &&
      (ss_ptr->cdma_hold_srv_uptime != CMSS_INFORM_SRV_CHANGE_INTER_NONE) &&
      (ss_ptr->cdma_hold_srv_uptime > clk_time) &&
      (si_info_ptr->mode == SYS_SYS_MODE_CDMA) )
   {
     ss_ptr->info.changed_fields = 0;
     ss_ptr->info.changed_fields2 = 0;
   }

  /* If timer running, LTE full srv not rcvd yet. Buffer LTE
  ** srv indication.
  */
  if( ss_ptr->hold_hy2_oper_flag_uptime != CMSS_NO_SRV_UPTIME_NONE &&
      si_info_ptr->mode == SYS_SYS_MODE_LTE)
  {
    CM_MSG_HIGH_0("hold_hy2_oper_flag_uptime timer running. Reset Changed_fields");
    ss_ptr->info.changed_fields = 0;
    ss_ptr->info.changed_fields2 = 0;
  }

  /* Check if clients have to be notified of srv_changed.
  */
  if ( (ss_ptr->info.changed_fields != 0) ||(ss_ptr->info.changed_fields2 != 0))
  {
    /* Because of change in any SS fileds client will recieve
    ** SRV_CHANGED event, making below flag to default value ie FALSE
    ** because after recieving this event client will not wait any more
    ** for SS event againt sys_sel_pref cmd
    */
    /* check if the changed fields is BSR mask only, and sys sel pref rsp is pending, and serving status is same
    then add No Change to the mask */
    if( (ph_ptr->is_sys_sel_pref_rsp_pending == TRUE) &&
    (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == si_info_ptr->srv_status) &&
    (ss_ptr->info.changed_fields == CM_SS_BSR_PROGRESS_MASK)
    )
    {
      ss_ptr->info.changed_fields |= CM_SS_NO_CHANGE_MASK;
    }

    cmph_reset_sys_sel_pref_rsp_pending();

    /* Update the RSSI in the SS object
    */
    cmss_report_rssi( NULL, NULL, FALSE );

    /* Notify CM clients of any changes in the serving system information.
    */
    ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;

    cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );

  }
  else if ((ph_ptr->is_sys_sel_pref_rsp_pending) &&

           (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == si_info_ptr->srv_status))

  {
    /* is_sys_sel_pref_rsp_pending flag is set means Client is waiting for
    ** response against sys_sel_pref cmd, beacuse of no change in other SS
    ** fields, set No_CHANGE_MASK and inform to client with SRV_CHANGED event
    */
    ss_ptr->info.changed_fields = CM_SS_NO_CHANGE_MASK;
    ss_ptr->info.changed_fields2 = CM_SS_NO_CHANGE_MASK;

    cmph_reset_sys_sel_pref_rsp_pending();

    /* Update the RSSI in the SS object
    */
    cmss_report_rssi( NULL, NULL, FALSE );

    /* Notify CM clients of any changes in the serving system information.
    */
    ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
    cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );

  }/* if ( changed_fields != 0 ) */

  /* If si_info_ptr carries non default req_id, srv status has not changed, and cm has not
   ** respond to clients, Inform clients now.
   */
  else if ( ph_ptr->is_req_id_pending &&
            si_info_ptr->sys_sel_pref_req_id != CM_DEFAULT_VALUE &&
            si_info_ptr->csg_info.csg_id == SYS_CSG_ID_INVALID)
  {
    ss_ptr->info.changed_fields = CM_SS_NO_CHANGE_MASK;
    ss_ptr->info.changed_fields2 = CM_SS_NO_CHANGE_MASK;

    cmph_reset_sys_sel_pref_rsp_pending();

    /* Update the RSSI in the SS object */
    cmss_report_rssi( NULL, NULL, FALSE );

    /* Notify CM clients of any changes in the serving system information. */
    ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;
    cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
  /* If there is a srv lost while waiting for state to resume,
  ** immediately inform client the failure.
  */
  if( ( ss_ptr->ps_data_stt == CM_PS_DATA_STT_RESUME ) &&
      ( ! sys_srv_status_is_full_srv(si_info_ptr->srv_status) )
    )
  {
    ss_ptr->ps_data_stt = CM_PS_DATA_STT_NONE;
    ss_ptr->no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;

    CM_MSG_MED_1("Send PS DATA AVAIL FAIL EVENT srv_status = %d ",
               si_info_ptr->srv_status);

    cmss_event( CM_SS_MAIN, CM_SS_EVENT_PS_DATA_FAIL );
  }
  #endif
  /*------------------------------------------------------------------*/
  /* Simulate Clock tick for generating NO SRV event without wiating for timer kick  */
  /* This is to avoid scenrio where CM gets NO_SERVICE and request ID is never    */
  /* reported to the cleints even after holding for 4 seconds because the request ID */
   /*  info is reset in SD and CMREGPRX side                   */
  /*------------------------------------------------------------------*/
  if((si_info_ptr->srv_status ==SYS_SRV_STATUS_NO_SRV ) && (si_info_ptr->sys_sel_pref_req_id > 0))
  {

     cmss_timer_proc(0);
  }

  /*------------------------------------------------------------------*/
  /* Simulate Clock tick for generating NO SRV event without wiating for timer kick  */
  /* This is to avoid scenrio where CM gets ful service before clock tick after getting */
  /* NO SRV in LPM\subs not available                                                                                              */
  /*------------------------------------------------------------------*/
  else if ((si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV
       || si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL
       || si_info_ptr->srv_status == SYS_SRV_STATUS_PWR_SAVE
         || si_info_ptr->srv_status == SYS_SRV_STATUS_PWR_SAVE_INTERNAL) &&
      ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
       (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM) ||
       (is_subs_invalid)
      )
     )
  {
    cmss_timer_proc(0);
  }
} /* cmss_update_srv_ind() */
/*lint +esym(529,prev_true_gw_srv_status)*/


#ifdef FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE

/*===========================================================================
FUNCTION  cmss_get_si_info

DESCRIPTION
  This function copy the service system information
  to si_info_ptr from ss_ptr structure.

DEPENDENCIES
  Serving System must be initialized

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/
static void cmss_get_si_info (

  sd_si_info_s_type               *si_info_ptr,
    /* si_info_ptr to store previous value */

  const cmss_s_type               *ss_ptr,
    /* ss_ptr to get current cmss info */

  cm_ss_e_type                    ss

)
{

  if( ss == CM_SS_HYBR_2)
  {
    /* Update required si_info_ptr field with the previous values
    ** use in cmss_update_srv_ind
    */
    si_info_ptr->srv_status             =  ss_ptr->info.gw_srv_status;
    si_info_ptr->is_pref_srv_acq        =  ss_ptr->hybr_gw_is_pref_srv_acq;
    si_info_ptr->band                   =  ss_ptr->info.gw_active_band;
    si_info_ptr->chan                   =  ss_ptr->info.gw_active_channel;
    si_info_ptr->is_sys_prl_match       =  ss_ptr->info.gw_is_sys_prl_match;
    si_info_ptr->is_sys_forbidden       =  ss_ptr->info.gw_is_sys_forbidden;
    si_info_ptr->srv_domain             =  ss_ptr->info.gw_srv_domain;
    si_info_ptr->usable_status          =  ss_ptr->hybr_gw_usable;
    si_info_ptr->roam                   =  ( sd_roam_e_type )ss_ptr->info.gw_roam_status;
    si_info_ptr->sys_srv_cap            =  ( sys_srv_capability_e_type )ss_ptr->info.gw_srv_capability;
    si_info_ptr->mode                   =  (sys_sys_mode_e_type)ss_ptr->info.gw_sys_mode;
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 )
  {
    /* Update required si_info_ptr field with the previous values
    ** use in cmss_update_srv_ind
    */
    si_info_ptr->srv_status             =  ss_ptr->info.gw3_srv_status;
    si_info_ptr->is_pref_srv_acq        =  ss_ptr->hybr_3_gw_is_pref_srv_acq;
    si_info_ptr->band                   =  ss_ptr->info.gw3_active_band;
    si_info_ptr->chan                   =  ss_ptr->info.gw3_active_channel;
    si_info_ptr->is_sys_prl_match       =  ss_ptr->info.gw3_is_sys_prl_match;
    si_info_ptr->is_sys_forbidden       =  ss_ptr->info.gw3_is_sys_forbidden;
    si_info_ptr->srv_domain             =  ss_ptr->info.gw3_srv_domain;
    si_info_ptr->usable_status          =  ss_ptr->hybr_3_gw_usable;
    si_info_ptr->roam                   =  ( sd_roam_e_type )ss_ptr->info.gw3_roam_status;
    si_info_ptr->sys_srv_cap            =  ( sys_srv_capability_e_type )ss_ptr->info.gw3_srv_capability;
    si_info_ptr->mode                   =  (sys_sys_mode_e_type)ss_ptr->info.gw3_sys_mode;
  }
  else
  #endif /* FEATURE_MMODE_TRIPLE_SIM */
  {
    /* Update required si_info_ptr field with the previous values
    ** use in cmss_update_srv_ind
    */
    si_info_ptr->srv_status             =  ss_ptr->info.srv_status;
    si_info_ptr->is_pref_srv_acq        =  ss_ptr->is_pref_srv_acq;
    si_info_ptr->is_stable_in_svc       =  ss_ptr->is_stable_in_svc;
    si_info_ptr->is_redir_or_ho         =  ss_ptr->is_redir_or_ho;
    si_info_ptr->band                   =  ss_ptr->info.active_band;
    si_info_ptr->chan                   =  ss_ptr->info.active_channel;
    si_info_ptr->is_sys_prl_match       =  ss_ptr->info.is_sys_prl_match;
    si_info_ptr->is_sys_forbidden       =  ss_ptr->info.is_sys_forbidden;
    si_info_ptr->srv_domain             =  ss_ptr->info.srv_domain;
    si_info_ptr->is_colloc              =  ss_ptr->is_colloc;
    si_info_ptr->usable_status          =  ss_ptr->ss_main_usable ;
    si_info_ptr->roam                   =  ( sd_roam_e_type )ss_ptr->info.roam_status;
    si_info_ptr->sys_srv_cap            =  ( sys_srv_capability_e_type )ss_ptr->info.srv_capability;
    si_info_ptr->mode                   =  (sys_sys_mode_e_type)ss_ptr->info.sys_mode;
  }
}
#endif /* FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE */


#if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
/*===========================================================================
FUNCTION  cmss_process_conn_mode_service_status_rpt

DESCRIPTION
  This function gets the service system information
  when UE is OOS in connected mode.

DEPENDENCIES
  Serving System must be initialized

RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmss_process_conn_mode_service_status_rpt(

  const void                    *rpt_ptr
     /* ptr to message received */
)
/*lint -esym(715,rpt_ptr)*/
{
  #ifndef FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE
  SYS_ARG_NOT_USED(rpt_ptr);
  return;

  #else
  cmss_s_type                     *ss_ptr         = cmss_ptr();
  sd_si_info_s_type                si_info_ptr;
  sys_conn_mode_ss_ind_s_type      conn_mode_srv_status;

  boolean                          report_change = FALSE;
  /* Send CM_SS_EVENT_SRV_CHANGED to UI only iff This become TRUE */

  boolean                          plmn_status   = TRUE;
  /* To check match between previous and new plmn_ids */

  const cm_rpt_type                *gw_rpt_ptr;

  cm_ss_e_type                     ss = CM_SS_MAIN;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( rpt_ptr == NULL )
  {
    CM_MSG_MED_0("Received report is NULL, ignoring the report");
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_0("CM is processing conn_mode_srv_status report");

  gw_rpt_ptr      = rpt_ptr;

  #ifdef FEATURE_CM_DEBUG_BUFFER
  cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_CONN_MODE_SERVICE_STATUS_IND, ((void*)&(gw_rpt_ptr->cmd.conn_mode_srv_status)));
  #endif
  
  /* Now Update the ss_ptr required field with current new values
  */
  conn_mode_srv_status  = gw_rpt_ptr->cmd.conn_mode_srv_status.conn_mode_ss_ind;

  /* Determine ss base on asubs_id and rat */
  if (conn_mode_srv_status.rat == SYS_RAT_GSM_RADIO_ACCESS)
  {
    ss = cmph_determine_ss_per_rat(gw_rpt_ptr->cmd.conn_mode_srv_status.as_id,
                                                    SYS_SYS_MODE_GSM);
  }
  else if (conn_mode_srv_status.rat == SYS_RAT_UMTS_RADIO_ACCESS)
  {
    ss = cmph_determine_ss_per_rat(gw_rpt_ptr->cmd.conn_mode_srv_status.as_id,
                                                    SYS_SYS_MODE_WCDMA);
  }
  else if (conn_mode_srv_status.rat == SYS_RAT_TDS_RADIO_ACCESS)
  {
    ss = cmph_determine_ss_per_rat(gw_rpt_ptr->cmd.conn_mode_srv_status.as_id,
                                                    SYS_SYS_MODE_TDS);
  }

  #ifdef FEATURE_OOSC_USER_ACTION
  /* Store new status of OOSC status
  */
  if(ss == CM_SS_HYBR_3)
  {
    ss_ptr->hybr_3_gw_is_connected_mode_oos = conn_mode_srv_status.is_connected_mode_oos;
  }
  else if(ss == CM_SS_HYBR_2)
  {
    ss_ptr->hybr_gw_is_connected_mode_oos = conn_mode_srv_status.is_connected_mode_oos;
  }
  else
  {
    ss_ptr->is_connected_mode_oos = conn_mode_srv_status.is_connected_mode_oos;
  }

  /* As per RRC requirement Ignore conn_mode_srv_status report below:
  */
  if((conn_mode_srv_status.is_connected_mode_oos == FALSE) &&
     (conn_mode_srv_status.service_status != SYS_SRV_STATUS_SRV))
  {
    CM_MSG_HIGH_2("Ignore conn_mode_srv_status report: srv_status: %d, flag_status: %d ",
                 conn_mode_srv_status.service_status,ss_ptr->is_connected_mode_oos );
    return;
  }
  #endif

  /* Update required si_info_ptr field with the previous values
  ** use in cmss_update_srv_ind
  */
  cmss_get_si_info(&si_info_ptr, ss_ptr, ss);

  si_info_ptr.sys_sel_pref_req_id = CM_DEFAULT_VALUE;

  switch(conn_mode_srv_status.rat)
  {
    case SYS_RAT_GSM_RADIO_ACCESS:
      si_info_ptr.mode         = SYS_SYS_MODE_GSM;
      break;

    case SYS_RAT_UMTS_RADIO_ACCESS:
      si_info_ptr.mode         = SYS_SYS_MODE_WCDMA;
      break;

    case SYS_RAT_TDS_RADIO_ACCESS:
      si_info_ptr.mode         = SYS_SYS_MODE_TDS;
      break;

    default:
      CM_MSG_HIGH_1("UNEXPECTED RAT TYPE: %d", conn_mode_srv_status.rat);
      break;
  }

  if(ss == CM_SS_HYBR_2 )
  {
    if ((si_info_ptr.mode == SYS_SYS_MODE_GSM) || (si_info_ptr.mode == SYS_SYS_MODE_WCDMA))
    {
      cm_signal_status_type gw_signal_status = {0};

      CM_MSG_HIGH_2("Updating rssi, mode=%d, rssi=%d", si_info_ptr.mode,
                   conn_mode_srv_status.signal_strength);

      cmss_gwl_get_hybr2_signal_status(si_info_ptr.mode, &gw_signal_status);
      gw_signal_status.signal_strength = (int16)conn_mode_srv_status.signal_strength;
      cmss_gwl_store_hybr_2_rssi_info( si_info_ptr.mode, &gw_signal_status);
    }
    ss_ptr->info.gw_sys_id.id_type     = SYS_SYS_ID_TYPE_UMTS;
    ss_ptr->hybr_gw_srv_inform_uptime  = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
    si_info_ptr.sid.plmn.plmn_id       = conn_mode_srv_status.selected_plmn;
    si_info_ptr.sid.plmn.lac           = ss_ptr->info.gw_sys_id.id.plmn_lac.lac;
    si_info_ptr.srv_status             = conn_mode_srv_status.service_status;
    si_info_ptr.roam                   = ( sd_roam_e_type )conn_mode_srv_status.roam_status;

    plmn_status = sys_plmn_match(ss_ptr->info.gw_sys_id.id.plmn_lac.plmn,si_info_ptr.sid.plmn.plmn_id );

    if( ss_ptr->info.gw_srv_status  != si_info_ptr.srv_status )
    {
      report_change = TRUE;
    }
    else if ( ss_ptr->info.gw_srv_status != SYS_SRV_STATUS_NO_SRV )
    {
      if ( ( !plmn_status ) ||
           ( ss_ptr->info.gw_sys_mode != si_info_ptr.mode ) ||
           ( ss_ptr->info.gw_rssi     != ss_ptr->gw_rssi  ) )
      {
        report_change = TRUE;
      }
    }
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(ss == CM_SS_HYBR_3 )
  {
    if ((si_info_ptr.mode == SYS_SYS_MODE_GSM) || (si_info_ptr.mode == SYS_SYS_MODE_WCDMA))
    {
      cm_signal_status_type gw_signal_status = {0};

      CM_MSG_HIGH_2("Hybr3:Updating rssi, mode=%d, rssi=%d", si_info_ptr.mode,
                   conn_mode_srv_status.signal_strength);

      cmss_gwl_get_hybr3_signal_status(si_info_ptr.mode, &gw_signal_status);
      gw_signal_status.signal_strength = (int16)conn_mode_srv_status.signal_strength;
      cmss_gwl_store_hybr_3_rssi_info( si_info_ptr.mode, &gw_signal_status);
    }
    ss_ptr->info.gw3_sys_id.id_type     = SYS_SYS_ID_TYPE_UMTS;
    ss_ptr->hybr_3_gw_srv_inform_uptime  = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
    si_info_ptr.sid.plmn.plmn_id       = conn_mode_srv_status.selected_plmn;
    si_info_ptr.sid.plmn.lac           = ss_ptr->info.gw3_sys_id.id.plmn_lac.lac;
    si_info_ptr.srv_status             = conn_mode_srv_status.service_status;
    si_info_ptr.roam                   = ( sd_roam_e_type )conn_mode_srv_status.roam_status;

    plmn_status = sys_plmn_match(ss_ptr->info.gw3_sys_id.id.plmn_lac.plmn,si_info_ptr.sid.plmn.plmn_id );

    if( ss_ptr->info.gw3_srv_status  != si_info_ptr.srv_status )
    {
      report_change = TRUE;
    }
    else if ( ss_ptr->info.gw3_srv_status != SYS_SRV_STATUS_NO_SRV )
    {
      if ( ( !plmn_status ) ||
           ( ss_ptr->info.gw3_sys_mode != si_info_ptr.mode ) ||
           ( ss_ptr->info.gw3_rssi     != ss_ptr->gw_rssi  ) )
      {
        report_change = TRUE;
      }
    }
  }
  else
  #endif /* FEATURE_MMODE_TRIPLE_SIM */
  {
    if ((si_info_ptr.mode == SYS_SYS_MODE_GSM) || (si_info_ptr.mode == SYS_SYS_MODE_WCDMA))
    {
      cm_signal_status_type gw_signal_status = {0};

      cmss_gwl_get_main_signal_status(si_info_ptr.mode, &gw_signal_status);
      gw_signal_status.signal_strength = (int16)conn_mode_srv_status.signal_strength;
      cmss_gwl_store_rssi_info( si_info_ptr.mode, &gw_signal_status);
    }
    #ifdef FEATURE_TDSCDMA
    else if (si_info_ptr.mode == SYS_SYS_MODE_TDS)
    {
      tds_rrc_scell_signal_status_ind_type tds_scell_signal_status = {{0}};

      cmss_gwl_get_main_signal_status(SYS_SYS_MODE_TDS, &tds_scell_signal_status);
      tds_scell_signal_status.rssi = (int16)conn_mode_srv_status.signal_strength;
      cmss_gwl_store_rssi_info( SYS_SYS_MODE_TDS, &tds_scell_signal_status);
    }
    #endif
    ss_ptr->info.sys_id.id_type        = SYS_SYS_ID_TYPE_UMTS;
    ss_ptr->main_srv_inform_uptime     = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
    si_info_ptr.sid.plmn.plmn_id       = conn_mode_srv_status.selected_plmn;
    si_info_ptr.sid.plmn.lac           = ss_ptr->info.sys_id.id.plmn_lac.lac;
    si_info_ptr.srv_status             = conn_mode_srv_status.service_status;
    si_info_ptr.roam                   = ( sd_roam_e_type )conn_mode_srv_status.roam_status;

    /* Update UI with CM_SS_EVENT_SRV_CHANGED event only iff :
    ** 1. previous srv_status and current srv_status both is not equal,
    ** 2. previous srv_status and current srv_status both is equal and
    **    both srv_status is not equal to SYS_SRV_STATUS_NO_SRV    and
    **    there is a change in either one of them : plmn/sys_mode/rssi
    */
    plmn_status = sys_plmn_match(ss_ptr->info.sys_id.id.plmn_lac.plmn,si_info_ptr.sid.plmn.plmn_id );

    if( ss_ptr->info.srv_status  != si_info_ptr.srv_status )
    {
      report_change = TRUE;
    }
    else if ( ss_ptr->info.srv_status != SYS_SRV_STATUS_NO_SRV )
    {
      if ( ( !plmn_status ) ||
           ( ss_ptr->info.sys_mode != si_info_ptr.mode ) ||
           ( ss_ptr->info.rssi     != ss_ptr->gw_rssi  ) )
      {
        report_change = TRUE;
      }
    }
  }

  if( report_change )
  {
    CM_MSG_HIGH_1("CM_SS_EVENT_SRV_CHANGED event: srv_status: %d ", si_info_ptr.srv_status);

    if(ss == CM_SS_HYBR_2)
    {
      cmss_update_hybr_2_srv_ind(ss_ptr, &si_info_ptr);
    }
    else
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if(ss == CM_SS_HYBR_3 && ( cmph_is_tsts() || cmph_is_sxlte() ))
    {
      cmss_update_hybr_3_srv_ind(ss_ptr, &si_info_ptr);
    }
    else
    #endif
    {
      cmss_update_srv_ind(ss_ptr, &si_info_ptr);
    }
  }
  #endif
}
/*lint +esym(715,rpt_ptr)*/
#endif


#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))

/*===========================================================================
FUNCTION cmss_get_fm_rssi

DESCRIPTION
  This function convert FM RSSI in the DB (database) to RSSI in positive dBm

DEPENDENCIES
  Phone is in the analog mode

RETURNS
  positive dBm from 86 dBM to 113 dBm

SIDE EFFECTS
  none

===========================================================================*/
static uint16 cmss_get_fm_rssi (void)
{

  db_items_value_type cmph_db;
  uint16              rssi;

  db_get( DB_RSSI, &cmph_db );

  /* convert to RSSI in dBm; also make it positive */
  rssi = (uint16)( -(-113+ (sint31)( (cmph_db.rssi * 33) >> 8 ) ) );

  return rssi;

} /* cmss_get_fm_rssi() */



/*===========================================================================
FUNCTION cmss_get_cdma_rssi

DESCRIPTION
  This function gets the CDMA RSSI from the DB

DEPENDENCIES
  Phone is in the digital mode

RETURNS
  positive dBm from 75 dBm to 125 dBm

SIDE EFFECTS
  none

===========================================================================*/
static uint16 cmss_get_cdma_rssi (void)
{
  #ifndef FEATURE_MMODE_REMOVE_1X
  #ifdef FEATURE_JCDMA

  return (srch_get_cdma_raw_rssi());

  #else

  db_items_value_type cmph_db;

  db_get( DB_CDMA_RSSI,&cmph_db );

  return cmph_db.cdma_rssi ;

  #endif /* FEATURE_JCDMA */
  #else
  #error code not present
#endif
} /* cmss_get_cdma_rssi() */


/*===========================================================================
FUNCTION cmss_get_cdma_ecio

DESCRIPTION
  This function gets the CDMA ECIO from searcher

DEPENDENCIES
  Phone is in the digital mode

RETURNS
  negative Ec/IO value in 0.5 dBm steps.

SIDE EFFECTS
  none

===========================================================================*/
static byte cmss_get_cdma_ecio( void )
{
    #ifndef FEATURE_MMODE_REMOVE_1X
    byte ecio = CMSS_ECIO_VALUE_NO_SIGNAL;

    ecio = srch_get_cdma_raw_ecio();

    /* Limit the ecio value to 14 (-7) */
    ecio = (ecio < CMSS_ECIO_VALUE_MAX)?CMSS_ECIO_VALUE_MAX:ecio;

    return ecio;
    #else
    #error code not present
#endif
} /* cmss_get_cdma_ecio() */


/*===========================================================================

FUNCTION cmss_xlat_band_class

DESCRIPTION
  translate to CM band class enum

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  CM band class enum

SIDE EFFECTS
  none

===========================================================================*/
static sys_band_class_e_type cmss_xlat_band_class(

    byte band_class
)
{

  return ((sys_band_class_e_type) band_class);

} /* cmss_xlat_band_class() */



/*===========================================================================

FUNCTION cmss_xlat_block_or_system
DESCRIPTION
  translate to CM block or system enum

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  CM block or system enum

SIDE EFFECTS
  none

===========================================================================*/
static sys_blksys_e_type  cmss_xlat_block_or_system(

       nv_block_or_sys_enum_type block_or_system

)
{

  sys_blksys_e_type cm_block_or_system=SYS_BLKSYS_NONE;

  switch(block_or_system)
  {
    case NV_PCS_BLOCK_A:
      cm_block_or_system = SYS_BLKSYS_PCS_A;
      break;
    case NV_PCS_BLOCK_B:
      cm_block_or_system = SYS_BLKSYS_PCS_B;
      break;
    case NV_PCS_BLOCK_C:
      cm_block_or_system = SYS_BLKSYS_PCS_C;
      break;
    case NV_PCS_BLOCK_D:
      cm_block_or_system = SYS_BLKSYS_PCS_D;
      break;
    case NV_PCS_BLOCK_E:
      cm_block_or_system = SYS_BLKSYS_PCS_E;
      break;
    case NV_PCS_BLOCK_F:
      cm_block_or_system = SYS_BLKSYS_PCS_F;
      break;
    case NV_PCS_BLOCK_G:
      cm_block_or_system = SYS_BLKSYS_PCS_G;
      break;
    case NV_PCS_BLOCK_H:
      cm_block_or_system = SYS_BLKSYS_PCS_H;
      break;
    case NV_PCS_BLOCK_I:
      cm_block_or_system = SYS_BLKSYS_PCS_I;
      break;
    case NV_PCS_BLOCK_J:
      cm_block_or_system = SYS_BLKSYS_PCS_J;
      break;
    case NV_PCS_BLOCK_K:
      cm_block_or_system = SYS_BLKSYS_PCS_K;
      break;
    case NV_PCS_BLOCK_L:
      cm_block_or_system = SYS_BLKSYS_PCS_L;
      break;
    case NV_CELLULAR_SYS_A:
      cm_block_or_system = SYS_BLKSYS_PCS_CELL_A;
      break;
    case NV_CELLULAR_SYS_B:
      cm_block_or_system = SYS_BLKSYS_PCS_CELL_B;
      break;

    default:
      CM_ERR_0("invalid block or system");
      break;
  }

  return cm_block_or_system;
} /* cmss_xlat_block_or_system() */



/*===========================================================================

FUNCTION cmss_band_and_block_update

DESCRIPTION
  Update band and blcok or system informatio

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  if update action is  CMSS_INFO_UPDATE_A_TO_N or CMSS_INFO_UPDATE_D_TO_N
  then srv_sys_info_ptr can be set to NULL

===========================================================================*/
static void cmss_band_and_block_update(
    cmss_update_act_e_type  action,
       /* update action */
    cmss_s_type             *ss_ptr,
       /* SS object pointer */
    const cm_srv_sys_info_type    *srv_sys_info_ptr
      /* serving system info pointer */

)
{

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_ptr           != NULL);
  CM_ASSERT(srv_sys_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch(action)
  {
    case CMSS_INFO_UPDATE_N_TO_D:
    case CMSS_INFO_UPDATE_A_TO_D:
    case CMSS_INFO_UPDATE_N_TO_A:
    case CMSS_INFO_UPDATE_D_TO_A:
    case CMSS_INFO_UPDATE_A_TO_A:
    case CMSS_INFO_UPDATE_D_TO_D:
      ss_ptr->info.mode_info.cdma_info.band_class      = cmss_xlat_band_class(srv_sys_info_ptr->band_class);
      ss_ptr->info.mode_info.cdma_info.block_or_system = cmss_xlat_block_or_system(srv_sys_info_ptr->block_or_system);
      break;

    case CMSS_INFO_UPDATE_A_TO_N:
    case CMSS_INFO_UPDATE_D_TO_N:
      ss_ptr->info.mode_info.cdma_info.band_class      = SYS_BAND_CLASS_NONE;
      ss_ptr->info.mode_info.cdma_info.block_or_system = SYS_BLKSYS_NONE;
      break;

    default:
      CM_ERR_0("Invalid SID update action");
      break;
  }

} /* cmss_band_and_block_update() */



/*===========================================================================

FUNCTION cmss_srv_status_update

DESCRIPTION
  Update srv state info

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_srv_status_update(

    cmss_update_act_e_type  action,
       /* update action */
    cmss_s_type             *ss_ptr
       /* SS object pointer */

)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_ptr           != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch(action)
  {
    case CMSS_INFO_UPDATE_N_TO_D:
    case CMSS_INFO_UPDATE_N_TO_A:
      ss_ptr->info.srv_status      = SYS_SRV_STATUS_SRV;
      ss_ptr->main_srv_status      = SYS_SRV_STATUS_SRV;
      ss_ptr->info.changed_fields |= CM_SS_SRV_STATUS_MASK;
      break;

    case CMSS_INFO_UPDATE_A_TO_A:
    case CMSS_INFO_UPDATE_A_TO_D:
    case CMSS_INFO_UPDATE_D_TO_D:
    case CMSS_INFO_UPDATE_D_TO_A:
      break;

    case CMSS_INFO_UPDATE_A_TO_N:
    case CMSS_INFO_UPDATE_D_TO_N:
      ss_ptr->info.srv_status      = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->main_srv_status      = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->info.changed_fields |= CM_SS_SRV_STATUS_MASK;
      break;

    default:
      CM_ERR_0("Invalid Srv status update action");
      break;

  }
} /* cmss_srv_status_update() */



/*===========================================================================

FUNCTION cmss_sid_update

DESCRIPTION
  Update SID info

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  if update action is  CMSS_INFO_UPDATE_A_TO_N or CMSS_INFO_UPDATE_D_TO_N
  then srv_sys_info_ptr can be set to NULL

===========================================================================*/
static void cmss_sid_update(

    cmss_update_act_e_type        action,
       /* update action */

    cmss_s_type                   *ss_ptr,
       /* SS object pointer */

    const cm_srv_sys_info_type    *srv_sys_info_ptr
      /* serving system info pointer */

)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_ptr           != NULL);
  CM_ASSERT(srv_sys_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch(action)
  {
    case CMSS_INFO_UPDATE_N_TO_D:
    case CMSS_INFO_UPDATE_A_TO_D:
    case CMSS_INFO_UPDATE_N_TO_A:
    case CMSS_INFO_UPDATE_D_TO_A:
    case CMSS_INFO_UPDATE_A_TO_A:
    case CMSS_INFO_UPDATE_D_TO_D:

      if( srv_sys_info_ptr->rcv_fields & CM_SS_SID_MASK )
      {
        if(ss_ptr->info.sys_id.id.is95.sid != srv_sys_info_ptr->sid)
        {
          ss_ptr->info.sys_id.id.is95.sid  = srv_sys_info_ptr->sid;
          ss_ptr->info.changed_fields     |= CM_SS_SID_MASK;
          ss_ptr->info.changed_fields     |= CM_SS_SYS_ID_MASK;
        }
      }

      /* Store the values modified in stats object and inform clients */
      memscpy( &cmstats_ptr()->prm.cm_info.sys_sel_info.sel_sys,
               sizeof (sys_sys_id_s_type),
               &ss_ptr->info.sys_id,
               sizeof (sys_sys_id_s_type));

      cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK );

      break;

    case CMSS_INFO_UPDATE_A_TO_N:
    case CMSS_INFO_UPDATE_D_TO_N:

        ss_ptr->info.sys_id.id.is95.sid  = CM_SS_SID_NONE;
        ss_ptr->info.changed_fields     |= CM_SS_SID_MASK;
        ss_ptr->info.changed_fields     |= CM_SS_SYS_ID_MASK;

        /* Store the values modified in stats object and inform clients */
        memscpy( &cmstats_ptr()->prm.cm_info.sys_sel_info.sel_sys,
                 sizeof (sys_sys_id_s_type),
                 &ss_ptr->info.sys_id,
                 sizeof (sys_sys_id_s_type));

        cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK );

      break;

    default:
      CM_ERR_0("Invalid SID update action");
      break;

  }

} /* cmss_sid_update() */



/*===========================================================================

FUNCTION cmss_nid_update

DESCRIPTION
  Update NID info

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  if update action is  CMSS_INFO_UPDATE_A_TO_N or CMSS_INFO_UPDATE_D_TO_N
  then srv_sys_info_ptr can be set to NULL

===========================================================================*/
static void cmss_nid_update(
    cmss_update_act_e_type  action,
       /* update action */
    cmss_s_type             *ss_ptr,
       /* SS object pointer */
    const cm_srv_sys_info_type    *srv_sys_info_ptr
      /* serving system info pointer */

)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_ptr           != NULL);
  CM_ASSERT(srv_sys_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch(action)
  {
    case CMSS_INFO_UPDATE_N_TO_D:
    case CMSS_INFO_UPDATE_A_TO_D:
    case CMSS_INFO_UPDATE_D_TO_D:

      if( srv_sys_info_ptr->rcv_fields & CM_SS_NID_MASK )
      {
        if(ss_ptr->info.sys_id.id.is95.nid != srv_sys_info_ptr->nid)
        {
          ss_ptr->info.sys_id.id.is95.nid  = srv_sys_info_ptr->nid;
          ss_ptr->info.changed_fields     |= CM_SS_NID_MASK;
          ss_ptr->info.changed_fields     |= CM_SS_SYS_ID_MASK;
        }
      }

      /* Store the values modified in stats object and inform clients */
      *(&(cmstats_ptr()->prm.cm_info.sys_sel_info.sel_sys)) = *(&(ss_ptr->info.sys_id));

      cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK );

      break;

    case CMSS_INFO_UPDATE_D_TO_A:

      if(ss_ptr->info.sys_id.id.is95.nid != CM_SS_NID_NONE)
      {
        ss_ptr->info.sys_id.id.is95.nid  = CM_SS_NID_NONE;
        ss_ptr->info.changed_fields     |= CM_SS_NID_MASK;
        ss_ptr->info.changed_fields     |= CM_SS_SYS_ID_MASK;
      }

      /* Store the values modified in stats object and inform clients */
      *(&(cmstats_ptr()->prm.cm_info.sys_sel_info.sel_sys)) = *(&(ss_ptr->info.sys_id));

      cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK );

      break;

    case CMSS_INFO_UPDATE_N_TO_A:
    case CMSS_INFO_UPDATE_A_TO_A:
    case CMSS_INFO_UPDATE_A_TO_N:

      break;

    case CMSS_INFO_UPDATE_D_TO_N:

      ss_ptr->info.sys_id.id.is95.nid  = CM_SS_NID_NONE;
      ss_ptr->info.changed_fields     |= CM_SS_NID_MASK;
      ss_ptr->info.changed_fields     |= CM_SS_SYS_ID_MASK;
      break;

    default:
      CM_ERR_0("Invalid NID update action");
      break;

  }

} /* cmss_nid_update() */



/*===========================================================================

FUNCTION cmss_is95_sys_id_update

DESCRIPTION
  Update the IS95 system identifier

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_is95_sys_id_update(
    cmss_update_act_e_type  action,
       /* update action */
    cmss_s_type             *ss_ptr,
       /* SS object pointer */
    const cm_srv_sys_info_type    *srv_sys_info_ptr
      /* serving system info pointer */

)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_ptr           != NULL);
  CM_ASSERT(srv_sys_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  cmss_sid_update( action, ss_ptr, srv_sys_info_ptr );
  cmss_nid_update( action, ss_ptr, srv_sys_info_ptr );

  /*
  ** If the SID and NID are set to "none", then undefine the
  ** system ID.
  */
  if (ss_ptr->info.changed_fields & CM_SS_SYS_ID_MASK)
  {
    if ((ss_ptr->info.sys_id.id.is95.sid == CM_SS_SID_NONE ) &&
        (ss_ptr->info.sys_id.id.is95.nid == CM_SS_NID_NONE )    )
    {
      sys_undefine_sys_id( &ss_ptr->info.sys_id );
    }
    else
    {
      ss_ptr->info.sys_id.id_type = SYS_SYS_ID_TYPE_IS95;
    }

    /* Store the values modified in stats object and inform clients */
    *(&(cmstats_ptr()->prm.cm_info.sys_sel_info.sel_sys)) = *(&(ss_ptr->info.sys_id));

   cmstats_update_stats_and_post_event( SYS_CM_PH_PREF_BIT_MASK );

  }

} /* cmss_is95_sys_id_update() */



/*===========================================================================

FUNCTION cmss_reg_zone_update

DESCRIPTION
  Update registration zone info

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  if update action is  CMSS_INFO_UPDATE_A_TO_N or CMSS_INFO_UPDATE_D_TO_N
  then srv_sys_info_ptr can be set to NULL

===========================================================================*/
static void cmss_reg_zone_update(
    cmss_update_act_e_type  action,
       /* update action */
    cmss_s_type             *ss_ptr,
       /* SS object pointer */
    const cm_srv_sys_info_type    *srv_sys_info_ptr
      /* serving system info pointer */

)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_ptr           != NULL);
  CM_ASSERT(srv_sys_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch(action)
  {
    case CMSS_INFO_UPDATE_N_TO_D:
    case CMSS_INFO_UPDATE_A_TO_D:
    case CMSS_INFO_UPDATE_D_TO_D:

      if( srv_sys_info_ptr->rcv_fields & CM_SS_REG_ZONE_MASK )
      {
        if(ss_ptr->info.mode_info.cdma_info.reg_zone != srv_sys_info_ptr->reg_zone)
        {
          ss_ptr->info.mode_info.cdma_info.reg_zone  = srv_sys_info_ptr->reg_zone;
          ss_ptr->info.changed_fields     |= CM_SS_REG_ZONE_MASK;
        }
      }
      break;

    case CMSS_INFO_UPDATE_D_TO_A:

      if(ss_ptr->info.mode_info.cdma_info.reg_zone != CM_SS_REG_ZONE_NONE)
      {
        ss_ptr->info.mode_info.cdma_info.reg_zone  = CM_SS_REG_ZONE_NONE;
        ss_ptr->info.changed_fields     |= CM_SS_REG_ZONE_MASK;
      }
      break;

    case CMSS_INFO_UPDATE_N_TO_A:
    case CMSS_INFO_UPDATE_A_TO_A:
    case CMSS_INFO_UPDATE_A_TO_N:

      break;

    case CMSS_INFO_UPDATE_D_TO_N:

      ss_ptr->info.mode_info.cdma_info.reg_zone  = CM_SS_REG_ZONE_NONE;
      ss_ptr->info.changed_fields     |= CM_SS_REG_ZONE_MASK;
      break;

    default:
      CM_ERR_0("Invalid registration zone update action");
      break;

  }

} /* cmss_reg_zone_update() */



/*===========================================================================

FUNCTION cmss_packet_zone_update

DESCRIPTION
  Update packet zone info

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  if update action is  CMSS_INFO_UPDATE_A_TO_N or CMSS_INFO_UPDATE_D_TO_N
  then srv_sys_info_ptr can be set to NULL

===========================================================================*/
static void cmss_packet_zone_update(
    cmss_update_act_e_type  action,
       /* update action */
    cmss_s_type             *ss_ptr,
       /* SS object pointer */
    const cm_srv_sys_info_type    *srv_sys_info_ptr
      /* serving system info pointer */

)
{

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_ptr           != NULL);
  CM_ASSERT(srv_sys_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch(action)
  {
    case CMSS_INFO_UPDATE_N_TO_D:
    case CMSS_INFO_UPDATE_A_TO_D:
    case CMSS_INFO_UPDATE_D_TO_D:

      if( srv_sys_info_ptr->rcv_fields & CM_SS_PACKET_ZONE_MASK )
      {
        if(ss_ptr->info.mode_info.cdma_info.packet_zone != srv_sys_info_ptr->packet_zone)
        {
          ss_ptr->info.mode_info.cdma_info.packet_zone  = srv_sys_info_ptr->packet_zone;
          ss_ptr->info.changed_fields        |= CM_SS_PACKET_ZONE_MASK;
        }
      }
      break;

    case CMSS_INFO_UPDATE_D_TO_A:

      if(ss_ptr->info.mode_info.cdma_info.packet_zone != CM_SS_PACKET_ZONE_NONE)
      {
        ss_ptr->info.mode_info.cdma_info.packet_zone  = CM_SS_PACKET_ZONE_NONE;
        ss_ptr->info.changed_fields        |= CM_SS_PACKET_ZONE_MASK;
      }
      break;

    case CMSS_INFO_UPDATE_N_TO_A:
    case CMSS_INFO_UPDATE_A_TO_A:
    case CMSS_INFO_UPDATE_A_TO_N:

      break;

    case CMSS_INFO_UPDATE_D_TO_N:

      ss_ptr->info.mode_info.cdma_info.packet_zone  = CM_SS_PACKET_ZONE_NONE;
      ss_ptr->info.changed_fields        |= CM_SS_PACKET_ZONE_MASK;
      break;

    default:
      CM_ERR_0("Invalid packet zone update action");
      break;

  }

} /* cmss_packet_zone_update() */



/*===========================================================================

FUNCTION cmss_p_rev_update

DESCRIPTION
  Update protocol revision info

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  if update action is  CMSS_INFO_UPDATE_A_TO_N or CMSS_INFO_UPDATE_D_TO_N
  then srv_sys_info_ptr can be set to NULL


===========================================================================*/
static void cmss_p_rev_update(
    cmss_update_act_e_type  action,
       /* update action */
    cmss_s_type             *ss_ptr,
       /* SS object pointer */
    const cm_srv_sys_info_type    *srv_sys_info_ptr
      /* serving system info pointer */

)
{
  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_ASSERT(ss_ptr           != NULL);
  CM_ASSERT(srv_sys_info_ptr != NULL);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch(action)
  {
    case CMSS_INFO_UPDATE_N_TO_D:
    case CMSS_INFO_UPDATE_A_TO_D:
    case CMSS_INFO_UPDATE_D_TO_D:

      if( srv_sys_info_ptr->rcv_fields & CM_SS_BS_P_REV_MASK )
      {
        if(ss_ptr->info.mode_info.cdma_info.bs_p_rev != srv_sys_info_ptr->bs_p_rev)
        {
          ss_ptr->info.mode_info.cdma_info.bs_p_rev  = srv_sys_info_ptr->bs_p_rev;
          ss_ptr->info.changed_fields     |= CM_SS_BS_P_REV_MASK;
        }

      }

      if( srv_sys_info_ptr->rcv_fields & CM_SS_P_REV_IN_USE_MASK )
      {

        if(ss_ptr->info.mode_info.cdma_info.p_rev_in_use != srv_sys_info_ptr->p_rev_in_use)
        {
          ss_ptr->info.mode_info.cdma_info.p_rev_in_use  = srv_sys_info_ptr->p_rev_in_use;
          ss_ptr->info.changed_fields         |= CM_SS_P_REV_IN_USE_MASK;
        }

      }

      #ifdef FEATURE_IS2000_REL_A_SVD
      if ( ss_ptr->info.mode_info.cdma_info.ccs_supported != srv_sys_info_ptr->ccs_supported )
      {
        ss_ptr->info.mode_info.cdma_info.ccs_supported = srv_sys_info_ptr->ccs_supported;
        ss_ptr->info.changed_fields          |= CM_SS_CCS_SUPPORTED_MASK;
      }
      #else
      ss_ptr->info.mode_info.cdma_info.ccs_supported = FALSE;
      #endif

      break;


    case CMSS_INFO_UPDATE_N_TO_A:
    case CMSS_INFO_UPDATE_A_TO_A:
    case CMSS_INFO_UPDATE_A_TO_N:

      break;

    case CMSS_INFO_UPDATE_D_TO_A:
    case CMSS_INFO_UPDATE_D_TO_N:

      ss_ptr->info.mode_info.cdma_info.bs_p_rev      = CM_SS_BS_P_REV_NONE;
      ss_ptr->info.mode_info.cdma_info.p_rev_in_use  = CM_SS_P_REV_IN_USE_NONE;
      ss_ptr->info.changed_fields         |= CM_SS_BS_P_REV_MASK;
      ss_ptr->info.changed_fields         |= CM_SS_P_REV_IN_USE_MASK;
      break;

    default:
      CM_ERR_0("Invalid p_rev update action");
      break;

  }

} /* cmss_p_rev_update() */

/*===========================================================================

FUNCTION cmss_info_new

DESCRIPTION
  New serving system info is available.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none
===========================================================================*/
static void cmss_info_new( void )
{
  /* Client just needs an indication that new SS info is available, currently
  ** there is no need to fill in the individual fields.
  */
  cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_NEW);

} /* end cmss_info_new() */



/*===========================================================================

FUNCTION cmss_info_update

DESCRIPTION
  Update serving system info

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  if update action is  CMSS_INFO_UPDATE_A_TO_N or CMSS_INFO_UPDATE_D_TO_N
  then srv_sys_info_ptr can be set to NULL


===========================================================================*/
static void cmss_info_update(

    cmss_update_act_e_type  action,
       /* update action */

    const cm_srv_sys_info_type    *srv_sys_info_ptr
      /* serving system info pointer */

)
{
  cmss_s_type               *ss_ptr = cmss_ptr();
        /* Point at serving system object */

  cmss_srv_status_update( action, ss_ptr );
  cmss_band_and_block_update(action, ss_ptr, srv_sys_info_ptr );
  cmss_is95_sys_id_update( action, ss_ptr, srv_sys_info_ptr );
  cmss_reg_zone_update( action, ss_ptr, srv_sys_info_ptr );
  cmss_packet_zone_update( action, ss_ptr, srv_sys_info_ptr );
  cmss_p_rev_update( action, ss_ptr, srv_sys_info_ptr );

} /* cmss_info_update() */


#if ( defined(FEATURE_HDR_HYBRID))

/*===========================================================================
FUNCTION cmss_update_srv_status_for_hybr_1

DESCRIPTION
  Updates status, band and channel for new service indication
  atomically.
===========================================================================*/
/*lint -save -e528 */
static void cmss_update_srv_status_for_hybr_1(

    sys_srv_status_e_type new_srv_status,
      /* New service status from SD */

    sys_band_class_e_type new_active_band,
      /* New band from SD */

    sys_channel_num_type  new_active_chan
      /* New channel from SD */
)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  rex_enter_crit_sect(cmtask_crit_sect_ptr());

  ss_ptr->info.hdr_srv_status = new_srv_status;
  ss_ptr->info.hybrid_active_band = new_active_band;
  ss_ptr->info.hybrid_active_channel = new_active_chan;

  rex_leave_crit_sect(cmtask_crit_sect_ptr());
}
/*lint -restore */

/*===========================================================================

FUNCTION cmss_update_hybr_1_srv_ind

DESCRIPTION
  Update the serving system object per the new HDR service indicators.

  If service state and/or roaming status is changed, Inform CM clients of
  corresponding events.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_hybr_1_srv_ind(

    cmss_s_type         *ss_ptr,
        /* Pointer to a serving system object */

    const sd_si_info_s_type   *si_info_ptr
       /* Pointer to buffer containing new service info information */
)
/*lint -esym(529,prev_true_gw_srv_status)*/
/*lint -esym(529,ph_ptr)*/
{


  #ifdef FEATURE_HDR_HANDOFF
  sys_sys_mode_e_type      prev_idm = cmssidm_get_curr_idm();
   /* Remember the current idle digital mode */
  #endif // FEATURE_HDR_HANDOFF

  #ifdef FEATURE_BCMCS
  boolean bcmcs_supported;
  #endif

  cmph_s_type *ph_ptr = cmph_ptr();

  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_1) ;

  uint8                    stk_id = ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id;


  sys_srv_status_e_type    new_srv_status = ss_ptr->info.hdr_srv_status;
  boolean is_subs_invalid = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Valid only when hdr_hybrid is defined.
  */
  #if !( defined (FEATURE_HDR_HYBRID))
  CM_ERR_0(" hybrid not defined");
  return;
  #endif  /* FEATURE_HDR_HYBRID */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );
  CM_ASSERT( si_info_ptr != NULL );

  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }
  


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->info.changed_fields  = 0;
  ss_ptr->info.changed_fields2  = 0;
  ss_ptr->info.hybr_gw_changed_fields = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->info.sys_sel_pref_req_id = si_info_ptr->sys_sel_pref_req_id;

  #ifdef FEATURE_HDR_HANDOFF
  /* Invoke IDM module to determine if IDM changed
  */
  cmssidm_proc_rpt_srv_ind_ss_hdr( si_info_ptr, FALSE );
  #endif // FEATURE_HDR_HANDOFF

  #ifdef CM_GW_SUPPORTED
  if( !((ph_ptr->main_stack_info.ens_value == TRUE  &&
         ph_ptr->main_stack_info.disable_call_type_mask == CM_CALL_TYPE_VOICE_MASK)
         ||
         ph_ptr->lu_reject_auto_enabled )
    )
  {
    /* Default the values of regn reject info upon getting any service
    ** indication or confirmation from LL. (Retaining this behavior for older
    ** targets which do not have MM17 requirement)
    */
    cm_ss_init_reg_reject_info( CM_SS_MAIN, &ss_ptr->info.reg_reject_info );
  }
  #endif

   /* If HDR service indication is received before the LTE to DO redir timer expiry,
   **  report service on main immediately
   */
   if(ph_ptr->lte_do_redir)
   {
     cmph_reset_lte_do_redir();
     if(ss_ptr->main_buffer_srv_uptime != CMSS_INFORM_SRV_CHANGE_INTER_NONE)
     {
       cmss_update_cdma_srv_lte_do_redir();
     }
   }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we lost service, set no_srv_uptime to uptime + CMSS_MAX_NO_SRV_TIME.
  ** The no_srv_uptime is checked periodically by the cmss_timer_proc()
  ** function. If no_srv_uptime expires before service is reacquired,
  ** cmss_timer_proc() reports to CM clients of a service lost event.
  */
  switch ( si_info_ptr->srv_status )
  {
    case SYS_SRV_STATUS_NO_SRV:
    case SYS_SRV_STATUS_NO_SRV_INTERNAL:
    {
      dword clk_time = time_get_uptime_secs();
      new_srv_status = si_info_ptr->srv_status;
      /* if emergency call is active then send no service indication straight away without buffering */
      if(cmss_emergency_call_active_in_cdma())
      {
        ss_ptr->hdr_no_srv_uptime = clk_time;
      }
      /* Otherwise, if we are in Low Power Mode, this means the users
      ** somehow decides to turn off the radio. Then we have to report
      ** SERVICE LOST IMMEDIATELY
      */
      if ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
          (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM))
      {
        ss_ptr->hdr_no_srv_uptime = clk_time;
        cmss_update_skip_srv_ind_update(FALSE);
        new_srv_status = SYS_SRV_STATUS_NO_SRV;
      }
      /* if GWL subs becomes not available when in 3GPP service or 1x subs not available
         when in 1x/hdr service, we can safely send no srv to clients instead of buffering */
      else if(!cmss_is_no_srv_buffering_required(CM_SS_HYBR_1))
      {
        is_subs_invalid= TRUE;
        ss_ptr->hdr_no_srv_uptime = clk_time;
        new_srv_status = SYS_SRV_STATUS_NO_SRV;
        CM_MSG_HIGH_0("HYBR1:Not Buffering, Inform SYS_SRV_STATUS_NO_SRV ");
      }
      else
      {
        ss_ptr->hdr_no_srv_uptime   = MIN( ss_ptr->hdr_no_srv_uptime,
            clk_time + cmss_rat_srv_ind_uptimers.hdr_uptimers.no_srv_uptimer );
      }

      /* Taking the backup of sd_si_info,
      ** use this info when no srv timer expires
      */
      *(cmss_intl_srv_info_ptr(CM_SS_HYBR_1)) = *si_info_ptr;

      if(new_srv_status == SYS_SRV_STATUS_NO_SRV)
      {
        CM_MSG_HIGH_0("Not a Internal Srv Lost");
        cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status = new_srv_status;
        cmss_update_hybr_1_no_srv_ind_info(ss_ptr,
                                            cmss_intl_srv_info_ptr(CM_SS_HYBR_1));

      /* Since we  moved out of service, clear the field */
        if (( ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_LIMITED ||
             ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_SRV
           )&&
           (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode == SYS_SYS_MODE_HDR)
           )
      {

          ss_ptr->hdr_srv_inform_uptime =
            clk_time + cmss_rat_srv_ind_uptimers.hdr_uptimers.srv_uptimer;

      }
      else
      {
        ss_ptr->hdr_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
      }
    }
      else
      {
        /* It is a internal service lost,
        ** so do not update the ss_ptr till no_srv_uptimer
        */
         CM_MSG_HIGH_4("srv_status %d, Holding srv lost ,hdr uptime=%d,clk_time=%d,rat_no_srv_uptimer=%d", si_info_ptr->srv_status,
                       ss_ptr->hdr_no_srv_uptime,clk_time,
                       cmss_rat_srv_ind_uptimers.hdr_uptimers.no_srv_uptimer);

      }
    }

    break;

    case SYS_SRV_STATUS_SRV:
    case SYS_SRV_STATUS_LIMITED:
    {
      dword                    clk_time   = time_get_uptime_secs();

      /* Reset the no_srv_uptime.
      */
      ss_ptr->hdr_no_srv_uptime   = CMSS_NO_SRV_UPTIME_NONE;

      /* Take the backup of sd_si_info,
      ** use this info when lmt srv timer expires
      */
      *(cmss_intl_srv_info_ptr(CM_SS_HYBR_1)) = *si_info_ptr;

      /* clients were informed full service before,
      ** so buffering lmt or lmt_reg srv ind till timer got expired
      */
      if((si_info_ptr->srv_status != SYS_SRV_STATUS_SRV &&
         ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == SYS_SRV_STATUS_SRV)/* &&
         (ss_ptr->srv_avail_info.sys_mode == si_info_ptr->mode)*/
         && (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode == SYS_SYS_MODE_HDR)
         )
      {
        /* uptime is CMSS_INFORM_SRV_CHANGE_TIME when srv indication
        ** transitions to LMTD from SRV. Clients can be informed
        ** once the timer expire.
          */

          ss_ptr->hdr_srv_inform_uptime   =
            clk_time + cmss_rat_srv_ind_uptimers.hdr_uptimers.srv_uptimer;

          CM_MSG_HIGH_3("Holding LmtdSrv,hdr_srv_inform_uptime =%d,clk_time =%d,rat_srv_uptime=%d",
                    ss_ptr->hdr_srv_inform_uptime,clk_time,
                    cmss_rat_srv_ind_uptimers.hdr_uptimers.srv_uptimer);


        // Mark srv status as internal Lmt srv
        cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status = sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);
      }
      else
      {
        cmss_update_hybr_1_lmtd_srv_ind_info(ss_ptr, si_info_ptr, FALSE);

        /* For svlte,
        ** if HDR srv is available then hybr2 3GPP should be in no srv, need to
        ** update hybr2 with buffered info of LTE.
        ** So updating no srv uptime and simulate clock tick for generating NO SRV event
        ** without waiting for timer kick.
        */
        if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
           SYS_SRV_STATUS_SRV == si_info_ptr->srv_status &&
           SD_MODE_HDR == si_info_ptr->mode &&
           ((SYS_SRV_STATUS_NO_SRV_INTERNAL == cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status) ||
             (SYS_SRV_STATUS_PWR_SAVE_INTERNAL == cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status))&&
           (sd_misc_is_mode_pref((sd_ss_mode_pref_e_type)BM(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode),
                                   SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE)))
        {
          sys_srv_status_e_type buffered_srv_status = SYS_SRV_STATUS_NONE;

          /* converting internal no srv/pwr save to  no srv/pwr save
          ** for posting srv change to clients
          */
          CM_MSG_HIGH_1("indicate 3GPP no srv on hybr2 -  acquired mode=%d",
                        si_info_ptr->mode);
          buffered_srv_status =
            cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status;
          cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status =
            sys_intl_srv_status_to_actl_srv_status(buffered_srv_status);

          cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode = SYS_SYS_MODE_NO_SRV;
          ss_ptr->hybr_gw_no_srv_uptime =  CMSS_NO_SRV_UPTIME_NONE;

          cmss_update_hybr_2_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_2));
        }

        if( SYS_SRV_STATUS_SRV == si_info_ptr->srv_status &&
            SD_MODE_HDR == si_info_ptr->mode &&
            (SYS_SRV_STATUS_NO_SRV_INTERNAL == cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status) &&
            (sd_misc_is_mode_pref((sd_ss_mode_pref_e_type)BM(cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode),
                                   SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE)))
        {
            //converting internal no srv to  no srv for posting srv change to clients

            CM_MSG_HIGH_1("indicate 3GPP no srv on main -  acquired mode=%d",
                        si_info_ptr->mode);
            cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = SYS_SRV_STATUS_NO_SRV;
            cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = SYS_SYS_MODE_NO_SRV;
            ss_ptr->no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;
            cmss_update_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN));
        }
      }

      #if defined FEATURE_DOMAIN_SELECTION
      if( SYS_SRV_STATUS_SRV == si_info_ptr->srv_status &&
              SD_MODE_HDR == si_info_ptr->mode &&
        si_info_ptr->hdr_personality == SYS_PERSONALITY_EHRPD)
      {
        cmsds_process_srv_ind (CM_SS_HYBR_1,si_info_ptr);
      }
      #endif

      
      /* When no_srv on 1x on MAIN and we have HDR service on hybr1, update current_mcc with
       ** current_hdr_mcc
       */
      if( !sys_srv_status_is_full_srv(ss_ptr->info.srv_status) &&
           si_info_ptr->srv_status == SYS_SRV_STATUS_SRV)
      {
         ss_ptr->info.current_mcc = ss_ptr->current_hdr_mcc;
         CM_MSG_HIGH_2("current mcc: %d main_srv_status:%d",ss_ptr->info.current_mcc,ss_ptr->info.srv_status);
      }

      cmss_identify_hdr_mcc_from_prl(&(si_info_ptr->plmn_mcc_list),
                                     ss_ptr->info.current_mcc,
                                     ss_ptr->info.mcc);

      /* Reset full_srv_lost globals for HYBR stacks */
      if(cmph_is_subs_feature_mode_1x_sxlte(subId))
      {
        is_hybr1_full_srv_lost = FALSE;
        is_hybr2_full_srv_lost = FALSE;
      }
    }
    break;


    case SYS_SRV_STATUS_PWR_SAVE:
    {
      /* Check if srv_status transitioned to pwr_save.
      */
      if ( ss_ptr->hybr_1_srv_status  != si_info_ptr->srv_status )
      {

        dword clk_time = time_get_uptime_secs();

        if(cmss_emergency_call_active_in_cdma())
        {
          ss_ptr->hdr_no_srv_uptime = clk_time;
        }
        /* Otherwise, if we are in Low Power Mode, this means the users
        ** somehow decides to turn off the radio. Then we have to report
        ** SERVICE LOST IMMEDIATELY
        */
        if ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
           (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM))
        {
          ss_ptr->hdr_no_srv_uptime = clk_time;
        }
        /* if GWL subs becomes not available when in 3GPP service or 1x subs not available
        when in 1x service, we can safely send PWR SAVE to clients instead of buffering */
        else if(!cmss_is_no_srv_buffering_required(CM_SS_HYBR_1))
        {
          is_subs_invalid= TRUE;
          ss_ptr->hdr_no_srv_uptime = clk_time;
          CM_MSG_HIGH_0("HYBR1: Not Buffering, Inform SYS_SRV_STATUS_PWR_SAVE ");
        }
        /* If we detect the PWR_SAVE, we added in CMSS_MAX_NO_SRV_TIME
        ** before reporting to UI. This is to improve the user experience.
        */
        else
        {
          ss_ptr->hdr_no_srv_uptime   = MIN( ss_ptr->hdr_no_srv_uptime,
            clk_time + cmss_rat_srv_ind_uptimers.hdr_uptimers.no_srv_uptimer );
        }

        /* Taking the backup of sd_si_info,
        ** use this info when no srv timer expires
        */
        *(cmss_intl_srv_info_ptr(CM_SS_HYBR_1)) = *si_info_ptr;

        /* Put INTERNAL_PWR_SAVE status into the buffer */
        cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status =
          sys_actl_srv_status_to_intl_srv_status(si_info_ptr->srv_status);

        /* It is power save indication,
        ** so do not update the ss_ptr till no_srv_uptimer expires
        */
        CM_MSG_HIGH_2("Holding PWR_SAVE, uptime =%d,clk_time =%d",
                    ss_ptr->hdr_no_srv_uptime,clk_time);

      } /* if ( ss_ptr->info.srv_status != si_info_ptr->srv_status ) */
      /* In a sequence where
      ** 1. Inform  srv_status= pwr_save to clients
      ** 2. Received INTERNAL_NO_SRV . Started  no_srv timer and set internal srv status=NO_SRV_INTERNAL
      ** 3. Again received PWR_SAVE from SD.
      ** As last status informed was pwr_Save and latest status informed by SD is also same, reset no_srv_uptimer
      ** and set internal srv status=PWR_SAVE to reflect latest srv status .
      */
      else if(ss_ptr->hdr_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE &&
              cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL)
      {
        ss_ptr->hdr_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;
        cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status = si_info_ptr->srv_status;
      }/* else if(ss_ptr->hdr_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE...*/
    }
    break;

    default:
      CM_MSG_HIGH_1("Invalid srv_status %d", si_info_ptr->srv_status);
      break;

  } /* switch ( si_info_ptr->srv_status ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the hybrid HDR usable status.
  */
  /* This check is done so that CM code can differentiate between faked
  ** no service and a real no service. Used in
  ** cmcall_is_ok_to_end_hold_orig_period().
  */
  if(si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV &&
     si_info_ptr->mode == SD_MODE_HDR )
  {
    ss_ptr->hybr_hdr_usable = SD_SYS_USABLE_UNKNOWN;
  }
  else
  {
    ss_ptr->hybr_hdr_usable = si_info_ptr->usable_status;
  }


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_HDR_HANDOFF
  /*
  ** If IDM changed, update SS object & notify CM clients of
  ** the corresponding event.
  */
  if ( cmssidm_get_curr_idm() != prev_idm )
  {
    ss_ptr->info.changed_fields |= CM_SS_IDLE_DIGITAL_MODE_MASK;
    ss_ptr->info.cur_idle_digital_mode = cmssidm_get_curr_idm();
    ss_ptr->info.prev_idle_digital_mode = cmssidm_get_prev_idm();
  }
  #endif // FEATURE_HDR_HANDOFF

  #ifdef FEATURE_CALL_THROTTLE
  /* If the new system is not throttled, update the
  ** ss object throtting status
  */
  if(cmss_update_thr_status())
  {
    ss_ptr->info.changed_fields |= CM_SS_ORIG_THR_STATUS_MASK;
  }
  #endif

  #ifdef FEATURE_BCMCS
  /*
  ** If HDR sent an explicit BCMCS status, different from the previous one,
  ** then pass it on. Used by DS to decide when to bring up/down the flows.
  */
  bcmcs_supported = cmbcmcs_srv_status_is_srv(si_info_ptr->bcmcs_srv_status);
  if(ss_ptr->info.hybr_hdr_bcmcs_srv_supported != bcmcs_supported)
  {
    CM_MSG_HIGH_1("BCMCS supported=%d",bcmcs_supported);

    ss_ptr->info.hybr_hdr_bcmcs_srv_supported = bcmcs_supported;
    ss_ptr->info.changed_fields |= CM_SS_HYBR_HDR_BCMCS_SRV_SUPPORTED_MASK;
  }
  if(ss_ptr->info.changed_fields &
     (CM_SS_HDR_SRV_STATUS_MASK | CM_SS_HYBR_HDR_BCMCS_SRV_SUPPORTED_MASK))
  {
    ss_ptr->info.hybr_hdr_bcmcs_srv_status =
      cmss_compute_bcmcs_srv_status(ss_ptr->info.hybr_hdr_bcmcs_srv_supported,
                                    ss_ptr->info.hdr_srv_status );
  }
  #endif /* FEATURE_BCMCS */


  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if clients have to be notified of srv_changed.
  */
  if ( ss_ptr->info.changed_fields != 0 )
  {
    /* Because of change in any SS fileds client will recieve
    ** SRV_CHANGED event, making below flag to default value ie FALSE
    ** because after recieving this event client will not wait any more
    ** for SS event againt sys_sel_pref cmd
    */
    cmph_reset_sys_sel_pref_rsp_pending();

    /* Update the RSSI in the SS object
    */
    cmss_report_rssi( NULL, NULL, FALSE );

    /* Notify CM clients of any changes in the serving system information.
    */
    cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );

  }
  else if ((ph_ptr->is_sys_sel_pref_rsp_pending) &&
           (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].srv_status == si_info_ptr->srv_status) &&
           (ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].sys_mode == SYS_SYS_MODE_HDR)
           )
  {
    /* is_network_mode_pref_change flag is set means Client is waiting for
    ** response against sys_sel_pref cmd, beacuse of no change in other SS
    ** fields, set No_CHANGE_MASK and inform to client with SRV_CHANGED event
    */
    cmph_reset_sys_sel_pref_rsp_pending();
    ss_ptr->info.changed_fields |= CM_SS_NO_CHANGE_MASK;

    /* Update the RSSI in the SS object
    */
    cmss_report_rssi( NULL, NULL, FALSE );

    /* Notify CM clients of any changes in the serving system information.
    */
    cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );

  }/* if ( changed_fields != 0 ) */

#if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
  /* If there is a srv lost while waiting for state to resume,
  ** immediately inform client the failure.
  */
  if( ( ss_ptr->ps_data_stt == CM_PS_DATA_STT_RESUME ) &&
      ( ! sys_srv_status_is_full_srv(si_info_ptr->srv_status) )
    )
  {
    ss_ptr->ps_data_stt = CM_PS_DATA_STT_NONE;
    ss_ptr->no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;

    CM_MSG_MED_1("Send PS DATA AVAIL FAIL EVENT srv_status = %d ",
               si_info_ptr->srv_status);

    cmss_event( CM_SS_MAIN, CM_SS_EVENT_PS_DATA_FAIL );
  }
  #endif

  /*------------------------------------------------------------------*/
  /* Simulate Clock tick for generating NO SRV event without wiating for timer kick  */
  /* This is to avoid scenrio where CM gets ful service before clock tick after getting */
  /* NO SRV in LPM\subs not available                                                                                              */
  /*------------------------------------------------------------------*/
  else if ((si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV
            || si_info_ptr->srv_status == SYS_SRV_STATUS_NO_SRV_INTERNAL
            || si_info_ptr->srv_status == SYS_SRV_STATUS_PWR_SAVE
            || si_info_ptr->srv_status == SYS_SRV_STATUS_PWR_SAVE_INTERNAL) &&
           ((ph_ptr->oprt_mode == SYS_OPRT_MODE_LPM) ||
            (ph_ptr->oprt_mode == SYS_OPRT_MODE_FTM) ||
            (is_subs_invalid))
          )
  {
    cmss_timer_proc(0);
  }
} /* cmss_update_hybr_1_srv_ind() */
/*lint +esym(529,prev_true_gw_srv_status)*/

#endif /* #if ( defined(FEATURE_HDR_HYBRID)) */



/*===========================================================================

FUNCTION cmss_map_sd_mode_to_cm_mode

DESCRIPTION
  Map SD mode to CM system mode

DEPENDENCIES
  None

RETURN VALUE
  CM system mode

SIDE EFFECTS
  None

===========================================================================*/
sys_sys_mode_e_type   cmss_map_sd_mode_to_cm_mode(

       sd_mode_e_type        sd_mode
          /* sd system mode.
          */
)
{
  /* Map CM OTASP activation code to SD band.
  */
  switch( sd_mode )
  {
    case SD_MODE_AMPS:    return SYS_SYS_MODE_AMPS;
    case SD_MODE_CDMA:    return SYS_SYS_MODE_CDMA;
    case SD_MODE_HDR:     return SYS_SYS_MODE_HDR;
    case SD_MODE_WCDMA:   return SYS_SYS_MODE_WCDMA;
    case SD_MODE_GSM:     return SYS_SYS_MODE_GSM;
    case SD_MODE_LTE:     return SYS_SYS_MODE_LTE;
    case SD_MODE_INACT:   return SYS_SYS_MODE_NO_SRV;
    case SD_MODE_TDS:     return SYS_SYS_MODE_TDS;
    default:
      CM_ERR_1( "sd_mode %d",sd_mode);
      /*lint -save -e527 Unreachable
      **     CM_ERR exits when CM_DEBUG is on
      */
      return SYS_SYS_MODE_NO_SRV;
      /*lint -restore */
  }

} /* map_sd_mode_to_cm_mode() */
#endif /* FEATURE_MMODE_CDMA_800, FEATURE_MMODE_CDMA_1900 */

/*===========================================================================

FUNCTION cmss_map_reg_emergtype_to_cm_emergtype

DESCRIPTION
  Emergency type bit masks from REG get mapped to CM type bit masks

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  CM bit masks

SIDE EFFECTS
  None.

===========================================================================*/
uint32 cmss_map_reg_emergtype_to_cm_emergtype (

       byte reg_emerg_num_type
          /* Emergency number type
          */
)
{

  #if defined(CM_GW_SUPPORTED)

  uint32 cm_emerg_num_type = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (CM_TYPE_CONTAIN (reg_emerg_num_type, CM_EMERGENCY_NUM_TYPE_POLICE))
  {
    cm_emerg_num_type |= CM_EMERG_NUM_TYPE_POLICE_MASK;
  }

  if (CM_TYPE_CONTAIN (reg_emerg_num_type, CM_EMERGENCY_NUM_TYPE_AMBULANCE))
  {
    cm_emerg_num_type |= CM_EMERG_NUM_TYPE_AMBULANCE_MASK;
  }

  if (CM_TYPE_CONTAIN (reg_emerg_num_type, CM_EMERGENCY_NUM_TYPE_FIRE_BRIGADE))
  {
    cm_emerg_num_type |= CM_EMERG_NUM_TYPE_FIRE_BRIGADE_MASK;
  }

  if (CM_TYPE_CONTAIN (reg_emerg_num_type, CM_EMERGENCY_NUM_TYPE_MARINE_GUARD))
  {
    cm_emerg_num_type |= CM_EMERG_NUM_TYPE_MARINE_GUARD_MASK;
  }

  if (CM_TYPE_CONTAIN (reg_emerg_num_type, CM_EMERGENCY_NUM_TYPE_MOUNTAIN_RESCUE))
  {
    cm_emerg_num_type |= CM_EMERG_NUM_TYPE_MOUNTAIN_RESCUE_MASK;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  return cm_emerg_num_type;

  #else

  SYS_ARG_NOT_USED (reg_emerg_num_type);

  return 0;

  #endif /* CM_GW_SUPPORTED */

} /* cmss_map_reg_emergtype_to_cm_emergtype () */

/*===========================================================================

FUNCTION cm_ss_init_reg_reject_info

DESCRIPTION
  This function initializes a SS registration reject information structure.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cm_ss_init_reg_reject_info(

    cm_ss_e_type               ss,
      /* stack whose structure needs to be initialized */

    cm_reg_reject_info_s_type  *cm_reg_reject_info_ptr
        /* The SS regn reject info structure to be initialized */
)
{
  cmss_s_type         *ss_ptr = cmss_ptr();

  CM_ASSERT (ss_ptr != NULL);

  if ( cm_reg_reject_info_ptr != NULL )
  {
    cm_reg_reject_info_ptr->reject_cause = 0;
    cm_reg_reject_info_ptr->reject_srv_domain = SYS_SRV_DOMAIN_NONE;
    cm_reg_reject_info_ptr->reg_rej_rat = SYS_RAT_NONE;
    

    if(ss == CM_SS_HYBR_2)
    {
      ss_ptr->hybr_gw_cs_reg_reject_cause = 0;
      ss_ptr->hybr_gw_ps_reg_reject_cause = 0;
    }
    else
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if(ss == CM_SS_HYBR_3)
    {
      ss_ptr->hybr_3_gw_cs_reg_reject_cause = 0;
      ss_ptr->hybr_3_gw_ps_reg_reject_cause = 0;
    }
    else
    #endif
    {
      ss_ptr->cs_reg_reject_cause = 0;
      ss_ptr->ps_reg_reject_cause = 0;
    }

    cm_reg_reject_info_ptr->csg_id = SYS_CSG_ID_INVALID;
    sys_plmn_undefine_plmn_id(&(cm_reg_reject_info_ptr->plmn));

  } /* if ( cm_reg_reject_info_ptr != NULL ) */
  else
  {
    CM_ERR_0("Null pointer passed for cm_reg_reject_info_ptr");
  }

  SYS_ARG_NOT_USED(ss);

} /* cm_ss_init_reg_reject_info() */
/*===========================================================================
FUNCTION CMSS_CONVERT_RRC_PLMN_ID_TO_SYS_PLMN_ID

DESCRIPTION
  This function converts from the RRC PLMN ID format (1 BCD digit per byte)
  to the NAS PLMN_id_T format (2 BCD digits per byte).

DEPENDENCIES
  None

RETURN VALUE
  PLMN ID converted to PLMN_id_T format (3 byte array - 2 BCD digits/byte)

SIDE EFFECTS
  None
===========================================================================*/
sys_plmn_id_s_type cmss_convert_rrc_plmn_id_to_sys_plmn_id(
  lte_rrc_plmn_s plmn_id  /* PLMN id provided by LTE RRC */
)
{
  sys_plmn_id_s_type sys_plmn_id;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (plmn_id.num_mnc_digits == 2)
  {
    plmn_id.mnc[2] = 0x0F;
  }

  /* ----------------------------------------
  ** PLMN octet 1 = MCC digit 2 | MCC digit 1
  ** ---------------------------------------- */
  sys_plmn_id.identity[0] = (byte) ((plmn_id.mcc[1] << 4) + plmn_id.mcc[0]);

  /* ----------------------------------------
  ** PLMN octet 2 = MNC digit 3 | MCC digit 3
  ** ---------------------------------------- */
  sys_plmn_id.identity[1] = (byte) ((plmn_id.mnc[2] << 4) + plmn_id.mcc[2]);

  /* ----------------------------------------
  ** PLMN octet 3 = MNC digit 2 | MNC digit 1
  ** ---------------------------------------- */
  sys_plmn_id.identity[2] = (byte) ((plmn_id.mnc[1] << 4) + plmn_id.mnc[0]);

  return sys_plmn_id;
}

#ifdef CM_GW_SUPPORTED

/*===========================================================================

FUNCTION cm_ss_init_mm_information

DESCRIPTION
  This function initializes a mobility management information structure.  The
  fields are marked as "unavailable".  The initialization occurs in the task
  context of the caller.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static boolean cm_ss_is_mm_information_same(

    sys_mm_information_s_type  *mm_info1_ptr,
    sys_mm_information_s_type  *mm_info2_ptr
        /* The mobility management information structure to be initialized */
)
{
  boolean ret_val = TRUE;
  
  if (mm_info1_ptr != NULL && mm_info2_ptr != NULL &&
      ( mm_info1_ptr->plmn_avail                        != mm_info2_ptr->plmn_avail                         ||
        mm_info1_ptr->full_name_avail                   != mm_info2_ptr->full_name_avail                    ||
        mm_info1_ptr->short_name_avail                  != mm_info2_ptr->short_name_avail                   ||
        mm_info1_ptr->univ_time_and_time_zone_avail     != mm_info2_ptr->univ_time_and_time_zone_avail      ||
        mm_info1_ptr->time_zone_avail                   != mm_info2_ptr->time_zone_avail                    ||
        mm_info1_ptr->lsa_identity_avail                != mm_info2_ptr->lsa_identity_avail                 ||
        mm_info1_ptr->daylight_saving_adj_avail         != mm_info2_ptr->daylight_saving_adj_avail          ||
        mm_info1_ptr->lac_avail                         != mm_info2_ptr->lac_avail                          || 
        !sys_plmn_match(mm_info1_ptr->plmn, mm_info2_ptr->plmn)                                             ||
        mm_info1_ptr->full_name.length                  != mm_info2_ptr->full_name.length                   ||
        memcmp(mm_info1_ptr->full_name.name, mm_info2_ptr->full_name.name, 
           MIN(sizeof(mm_info1_ptr->full_name.name), sizeof(mm_info2_ptr->full_name.name)))                         ||
        mm_info1_ptr->full_name.spare_bits              != mm_info2_ptr->full_name.spare_bits               ||
        mm_info1_ptr->short_name.length                 != mm_info2_ptr->short_name.length                  ||
        memcmp(mm_info1_ptr->short_name.name, mm_info2_ptr->short_name.name, 
           MIN(sizeof(mm_info1_ptr->short_name.name), sizeof(mm_info2_ptr->short_name.name)))                       ||
        mm_info1_ptr->short_name.spare_bits             != mm_info2_ptr->short_name.spare_bits              ||
        mm_info1_ptr->univ_time_and_time_zone.day       != mm_info2_ptr->univ_time_and_time_zone.day        ||
        mm_info1_ptr->univ_time_and_time_zone.month     != mm_info2_ptr->univ_time_and_time_zone.month      ||
        mm_info1_ptr->univ_time_and_time_zone.year      != mm_info2_ptr->univ_time_and_time_zone.year       ||
        mm_info1_ptr->univ_time_and_time_zone.hour      != mm_info2_ptr->univ_time_and_time_zone.hour       ||
        mm_info1_ptr->univ_time_and_time_zone.minute    != mm_info2_ptr->univ_time_and_time_zone.minute     ||
        mm_info1_ptr->univ_time_and_time_zone.second    != mm_info2_ptr->univ_time_and_time_zone.second     ||
        mm_info1_ptr->univ_time_and_time_zone.time_zone != mm_info2_ptr->univ_time_and_time_zone.time_zone  ||  
        mm_info1_ptr->time_zone                         != mm_info2_ptr->time_zone                          ||
        mm_info1_ptr->lsa_identity.type                 != mm_info2_ptr->lsa_identity.type                  ||
        mm_info1_ptr->lsa_identity.identity[0]          != mm_info2_ptr->lsa_identity.identity[0]           ||
        mm_info1_ptr->lsa_identity.identity[1]          != mm_info2_ptr->lsa_identity.identity[1]           ||
        mm_info1_ptr->lsa_identity.identity[2]          != mm_info2_ptr->lsa_identity.identity[2]           ||
        mm_info1_ptr->daylight_saving_adj               != mm_info2_ptr->daylight_saving_adj                ||
        mm_info1_ptr->lac_id                            != mm_info2_ptr->lac_id                             ||
        mm_info1_ptr->rat                               != mm_info2_ptr->rat                                ||
        mm_info1_ptr->full_name.coding_scheme           != mm_info2_ptr->full_name.coding_scheme            ||
        mm_info1_ptr->short_name.coding_scheme          != mm_info2_ptr->short_name.coding_scheme           ||
        mm_info1_ptr->full_name.add_country_initials    != mm_info2_ptr->full_name.add_country_initials     ||
        mm_info1_ptr->short_name.add_country_initials    != mm_info2_ptr->short_name.add_country_initials 
        
      )

  )
  {
    ret_val = FALSE;           
  } /* if ( mm_information_ptr != NULL ) */
  CM_MSG_HIGH_0("mm_info is not same");
  return ret_val;
} /* cm_ss_init_mm_information() */


/*===========================================================================

FUNCTION cm_ss_init_mm_information

DESCRIPTION
  This function initializes a mobility management information structure.  The
  fields are marked as "unavailable".  The initialization occurs in the task
  context of the caller.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cm_ss_init_mm_information(

    sys_mm_information_s_type  *mm_information_ptr
        /* The mobility management information structure to be initialized */
)
{
  CM_MSG_HIGH_0("cm_ss_init_mm_information");
  if ( mm_information_ptr != NULL )
  {
    mm_information_ptr->plmn_avail                    = FALSE;
    mm_information_ptr->full_name_avail               = FALSE;
    mm_information_ptr->short_name_avail              = FALSE;
    mm_information_ptr->univ_time_and_time_zone_avail = FALSE;
    mm_information_ptr->time_zone_avail               = FALSE;
    mm_information_ptr->lsa_identity_avail            = FALSE;
    mm_information_ptr->daylight_saving_adj_avail     = FALSE;
    mm_information_ptr->lac_avail                     = FALSE;

    sys_plmn_undefine_plmn_id( &mm_information_ptr->plmn );

    mm_information_ptr->full_name.length = 0;
    (void) memset( mm_information_ptr->full_name.name,
                   ' ',
                   SYS_MAX_FULL_NAME_CHARS );
    mm_information_ptr->full_name.spare_bits = 0;

    mm_information_ptr->short_name.length = 0;
    (void) memset( mm_information_ptr->short_name.name,
                   ' ',
                   SYS_MAX_SHORT_NAME_CHARS );
    mm_information_ptr->short_name.spare_bits = 0;

    mm_information_ptr->univ_time_and_time_zone.day       = 1;
    mm_information_ptr->univ_time_and_time_zone.month     = 1;
    mm_information_ptr->univ_time_and_time_zone.year      = 1;
    mm_information_ptr->univ_time_and_time_zone.hour      = 1;
    mm_information_ptr->univ_time_and_time_zone.minute    = 1;
    mm_information_ptr->univ_time_and_time_zone.second    = 1;
    mm_information_ptr->univ_time_and_time_zone.time_zone = 0;

    mm_information_ptr->time_zone = 0;

    mm_information_ptr->lsa_identity.type        = SYS_LSA_ID_TYPE_UNIVERSAL;
    mm_information_ptr->lsa_identity.identity[0] = 0;
    mm_information_ptr->lsa_identity.identity[1] = 0;
    mm_information_ptr->lsa_identity.identity[2] = 0;

    mm_information_ptr->daylight_saving_adj = SYS_DAY_SAV_ADJ_NO_ADJUSTMENT;
    mm_information_ptr->lac_id                   = 0;
    mm_information_ptr->rat                             = SYS_RAT_NONE;
    mm_information_ptr->full_name.coding_scheme         = SYS_NW_NAME_CODING_SCHEME_NONE;
    mm_information_ptr->short_name.coding_scheme        = SYS_NW_NAME_CODING_SCHEME_NONE;
    mm_information_ptr->full_name.add_country_initials  = FALSE;
    mm_information_ptr->short_name.add_country_initials = FALSE;
    
  } /* if ( mm_information_ptr != NULL ) */
  else
  {
    CM_ERR_0("Null pointer passed to cm_ss_init_mm_information");
  }

} /* cm_ss_init_mm_information() */


/*===========================================================================

FUNCTION cmss_process_mm_info_ind_rpt
DESCRIPTION
  This function processes a mobility management indication event
  reported by the lower software layer.


DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_process_mm_info_ind_rpt
(
  cm_ss_e_type                 ss,
    /* SS on which the info is updated */

  sys_mm_information_s_type    mm_info
    /* The mobility management information to be processed */
)
{
  cmss_s_type                 *ss_ptr = cmss_ptr();
  CM_MSG_HIGH_2("cmss_process_mm_info_ind_rpt ss %d, rat %d",ss, mm_info.rat);
  if ( ss_ptr != NULL )
  {
    /*
    ** Indicate that the mobility information has changed.
    */
    if( ss == CM_SS_HYBR_2 )
    {
      ss_ptr->info.hybr_gw_changed_fields = CM_SS_GW_MOBILITY_MGMT_MASK;
      ss_ptr->info.gw_mode_info.gw_info.mm_information = mm_info;
    }
    else
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if( ss == CM_SS_HYBR_3 )
    {
      ss_ptr->info.gw3_changed_fields = CM_SS_GW_MOBILITY_MGMT_MASK;
      ss_ptr->info.gw3_mode_info.gw_info.mm_information = mm_info;
    }
    else
    #endif /* FEATURE_MMODE_TRIPLE_SIM */
    {
      ss_ptr->info.changed_fields = CM_SS_MOBILITY_MGMT_MASK;
      ss_ptr->info.mode_info.gw_info.mm_information = mm_info;
    }

    /*
    ** Inform the clients that the serving system was modified.
    */
    cmss_event( ss, CM_SS_EVENT_SRV_CHANGED );

  }

} /* cmss_process_mm_info_ind_rpt */


/*===========================================================================

FUNCTION cmss_process_reg_reject_ind_rpt

DESCRIPTION
  This function processes a registration reject indication event
  reported by the lower layer.


DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_process_reg_reject_ind_rpt
(
  const void           *rpt_ptr
    /* ptr to message received */
)
{

  cmss_s_type              *ss_ptr             = cmss_ptr();
    /* Pointer to serving system object.
    */
  const cm_rpt_type        *gw_rpt_ptr         = rpt_ptr;

  const cm_reg_reject_ind_s_type *reg_reject_ind_ptr        =
                                    &gw_rpt_ptr->cmd.reg_reject_ind;
    /* Pointer to registration reject indication
    */

  cm_reg_reject_info_s_type  *reg_reject_info      = NULL;

  cm_ss_e_type                ss;
    /* stack on which this report is recieved */

  byte                        *cs_reg_reject_cause = NULL;

  byte                        *ps_reg_reject_cause = NULL;

  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;

  uint8                    stk_id = cmph_ptr()->ss_subs_map[CM_SS_MAIN].stack_id;


  CM_ASSERT (ss_ptr != NULL);

  CM_MSG_HIGH_4(" LL->CMSS: LU reject, domain = %d, cause = %d. reg_reject_ind_rpt:is_hybr_gw_operational=%d, gw_srv_status=%d",
                 reg_reject_ind_ptr->reject_domain,
                 reg_reject_ind_ptr->reject_cause,
              (int)ss_ptr->info.is_hybr_gw_operational,
              (int)ss_ptr->info.gw_srv_status);

 

  if( cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
      ss_ptr->info.is_hybr_gw_operational &&
      sys_srv_status_is_srv(ss_ptr->info.gw_srv_status))
  {
    ss = CM_SS_HYBR_2;
  }
  else
  {
    ss = cmph_map_as_id_stack_id_to_ss(reg_reject_ind_ptr->as_id,reg_reject_ind_ptr->stack_id);
  }

  if( ss == CM_SS_HYBR_2 )
  {
    reg_reject_info = &ss_ptr->info.gw_reg_reject_info;
    cs_reg_reject_cause = &ss_ptr->hybr_gw_cs_reg_reject_cause;
    ps_reg_reject_cause = &ss_ptr->hybr_gw_ps_reg_reject_cause;
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 )
  {
    reg_reject_info = &ss_ptr->info.gw3_reg_reject_info;
    cs_reg_reject_cause = &ss_ptr->hybr_3_gw_cs_reg_reject_cause;
    ps_reg_reject_cause = &ss_ptr->hybr_3_gw_ps_reg_reject_cause;
  }
  else
  #endif /* FEATURE_MMODE_TRIPLE_SIM */
  {
    reg_reject_info = &ss_ptr->info.reg_reject_info;
    cs_reg_reject_cause = &ss_ptr->cs_reg_reject_cause;
    ps_reg_reject_cause = &ss_ptr->ps_reg_reject_cause;
  }

  /*
  ** Indicate that the registration was rejected
  */
  reg_reject_info->reject_srv_domain = reg_reject_ind_ptr->reject_domain;
  reg_reject_info->reject_cause      = reg_reject_ind_ptr->reject_cause;
  reg_reject_info->csg_id        = reg_reject_ind_ptr->csg_id;
  reg_reject_info->reg_rej_rat       = reg_reject_ind_ptr->rat;

  /* Save reject cause in CM's internal place-holder as per the domain it was
  ** received on.
  */
  if( reg_reject_ind_ptr->reject_domain == SYS_SRV_DOMAIN_CS_ONLY )
  {
    /* Update CS reject cause */
    *cs_reg_reject_cause = reg_reject_ind_ptr->reject_cause;
  }
  else if( reg_reject_ind_ptr->reject_domain == SYS_SRV_DOMAIN_PS_ONLY )
  {
    /* Update PS reject cause */
    *ps_reg_reject_cause = reg_reject_ind_ptr->reject_cause;
  }
  else if(reg_reject_ind_ptr->reject_domain == SYS_SRV_DOMAIN_CS_PS)
  {
    /* Update both reject causes */
    *cs_reg_reject_cause = reg_reject_ind_ptr->reject_cause;
    *ps_reg_reject_cause = reg_reject_ind_ptr->reject_cause;
  }


  /*
  ** Inform the clients that the registration was rejected
  */
  cmss_event( ss, CM_SS_EVENT_REG_REJECT );

  /* update srv_avail_info in ss ptr so when next SRV_CHANGED event sent, lu reject bit masks can be correctly set
  ** srv_avail_info is only updated when SRV_CHANGED event. when sending REG_REJECT info, so srv_avail_info won't
  ** have latest reg_reject info.
  */
  
  subId = cmph_map_cm_ss_to_subs(ss) ;

  stk_id = cmss_map_ss_to_stack_info(ss);;
  
  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }
  
  
  ss_ptr->new_srv_avl_info[subId].stack_info[stk_id].reg_reject_info = ss_ptr->info.reg_reject_info;

} /* cmss_process_reg_reject_ind_rpt */

/*===========================================================================

FUNCTION cmss_update_cell_access_ind

DESCRIPTION
  This function processes a cell access indication report from LL
  and send corresponding event to clients


DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_cell_access_ind
(
  const void           *rpt_ptr
    /* ptr to message received */
)
{

  cmss_s_type           *ss_ptr         =  cmss_ptr();
    /* Pointer to serving system object.
    */
  const cm_rpt_type     *gw_rpt_ptr     =  rpt_ptr;

  const cm_cell_access_ind_s_type *cell_access_ind_ptr    =
                                       &gw_rpt_ptr->cmd.cell_access_ind;
    /* Pointer to Cell access indication
    */

  cm_ss_e_type           ss             =  CM_SS_MAIN;
    /* stack on which this report is recieved */

  if (cmph_is_msim())
  {
    ss = cmph_map_subs_to_ss(cell_access_ind_ptr->as_id);
  }

  CM_MSG_HIGH_4 ("LL->CMSS: cell_access_ind, as_id=%d, ss=%d cs_bar_status - %d, ps_bar_status - %d", 
  	cell_access_ind_ptr->as_id, ss, cell_access_ind_ptr->cell_access_status.cs_bar_status,
                 cell_access_ind_ptr->cell_access_status.ps_bar_status);

  CM_ASSERT (ss_ptr != NULL);

  /*
  ** Copy LL indication values to SS info
  */
  if(ss == CM_SS_MAIN )
  {

  ss_ptr->info.cell_access_info.cs_bar_status =
             cell_access_ind_ptr->cell_access_status.cs_bar_status;
  ss_ptr->info.cell_access_info.ps_bar_status =
             cell_access_ind_ptr->cell_access_status.ps_bar_status;
  }
  #ifdef FEATURE_MMODE_DUAL_SIM
  else if(ss == CM_SS_HYBR_2)
  {
    ss_ptr->info.gw_cell_access_info.cs_bar_status =
             cell_access_ind_ptr->cell_access_status.cs_bar_status;
    ss_ptr->info.gw_cell_access_info.ps_bar_status =
             cell_access_ind_ptr->cell_access_status.ps_bar_status;
  }
  #endif
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  else if(ss == CM_SS_HYBR_3)
  {
    ss_ptr->info.gw3_cell_access_info.cs_bar_status =
             cell_access_ind_ptr->cell_access_status.cs_bar_status;
    ss_ptr->info.gw3_cell_access_info.ps_bar_status =
             cell_access_ind_ptr->cell_access_status.ps_bar_status;
  }
  #endif
  /*
  ** Inform the clients about the cell access information
  */
  cmss_event( ss, CM_SS_EVENT_CELL_ACCESS_IND );

} /* cmss_update_cell_access_ind */

/*===========================================================================

FUNCTION cmss_process_cb_info_rpt

DESCRIPTION
  This function processes a cell broadcast info report from LL
  and send corresponding event to clients


DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_process_cb_info_rpt
(
  const void           *rpt_ptr
    /* ptr to message received */
)
{

  cmss_s_type           *ss_ptr         =  cmss_ptr();
    /* Pointer to serving system object.
    */
  const cm_rpt_type     *gw_rpt_ptr     =  rpt_ptr;

  const sys_cell_broadcast_info_s_type *cb_ind_ptr  =
                                    &gw_rpt_ptr->cmd.cell_bc_info;
    /* Pointer to CB indication
    */

  cm_ss_e_type           ss             =  CM_SS_MAIN;
    /* stack on which this report is recieved */

  ss = cmph_determine_ss_per_domain(cb_ind_ptr->subscription_id,
                                    SYS_SRV_DOMAIN_CS_ONLY);

  CM_ASSERT (ss_ptr != NULL);

 
  CM_MSG_HIGH_3 (" LL->CMSS: Cell broadcast info recd from LL: subs_id: %d, ss: %d cb cap: %d",
                cb_ind_ptr->subscription_id,
                ss,
                cb_ind_ptr->cell_bc_capability);

  /* Send cmss event only if all the following are true
   ** if there is a change in bc_capablity
   ** and if sys_mode is G/W
   ** and if service status is limited/full service
   */
  if (ss == CM_SS_HYBR_2)
  {
    if (ss_ptr->info.gw_cell_bc_info.cell_bc_capability != cb_ind_ptr->cell_bc_capability
        && ((ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_GSM)
        || (ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_WCDMA))
        && sys_srv_status_is_srv(ss_ptr->info.gw_srv_status))
    {
      ss_ptr->info.gw_cell_bc_info.subscription_id    = cb_ind_ptr->subscription_id;
      ss_ptr->info.gw_cell_bc_info.cell_bc_capability = cb_ind_ptr->cell_bc_capability;

      /*
         ** Inform the clients about the cb change event
         */
      cmss_event( ss, CM_SS_EVENT_SRV_CHANGED );
    }

    /* Update the new value */
    else
    {
      ss_ptr->info.gw_cell_bc_info.subscription_id    = cb_ind_ptr->subscription_id;
      ss_ptr->info.gw_cell_bc_info.cell_bc_capability = cb_ind_ptr->cell_bc_capability;
    }
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if (ss == CM_SS_HYBR_3)
  {
    if (ss_ptr->info.gw3_cell_bc_info.cell_bc_capability != cb_ind_ptr->cell_bc_capability
        && ((ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_GSM)
        || (ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_WCDMA))
        && sys_srv_status_is_srv(ss_ptr->info.gw3_srv_status))
    {
      ss_ptr->info.gw3_cell_bc_info.subscription_id    = cb_ind_ptr->subscription_id;
      ss_ptr->info.gw3_cell_bc_info.cell_bc_capability = cb_ind_ptr->cell_bc_capability;

      /*
         ** Inform the clients about the cb change event
         */
      cmss_event( ss, CM_SS_EVENT_SRV_CHANGED );
    }

    /* Update the new value */
    else
    {
      ss_ptr->info.gw3_cell_bc_info.subscription_id    = cb_ind_ptr->subscription_id;
      ss_ptr->info.gw3_cell_bc_info.cell_bc_capability = cb_ind_ptr->cell_bc_capability;
    }
  }
  else
  #endif
  {
    if (ss_ptr->info.cell_bc_info.cell_bc_capability != cb_ind_ptr->cell_bc_capability
        && ((ss_ptr->info.sys_mode == SYS_SYS_MODE_GSM)
        || (ss_ptr->info.sys_mode == SYS_SYS_MODE_WCDMA))
        && sys_srv_status_is_srv(ss_ptr->info.srv_status ))
    {
      ss_ptr->info.cell_bc_info.subscription_id    = cb_ind_ptr->subscription_id;
      ss_ptr->info.cell_bc_info.cell_bc_capability = cb_ind_ptr->cell_bc_capability;

      /*
         ** Inform the clients about the cb change event
         */
      cmss_event( ss, CM_SS_EVENT_SRV_CHANGED );
    }

    /* Update the new value */
    else
    {
      ss_ptr->info.cell_bc_info.subscription_id    = cb_ind_ptr->subscription_id;
      ss_ptr->info.cell_bc_info.cell_bc_capability = cb_ind_ptr->cell_bc_capability;
    }
  }


} /* cmss_update_cell_access_ind */
/*===========================================================================

FUNCTION cmss_update_home_nodeb_name_ind

DESCRIPTION
  This function processes home nodeb name ind from NAS and
  sends corresponding ss event to clients


DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_update_home_nodeb_name_ind
(
  const void           *rpt_ptr
    /* ptr to message received */
)
{
  cmss_s_type           *ss_ptr     = cmss_ptr();
    /* Pointer to serving system object.
    */
  const cm_rpt_type     *gw_rpt_ptr = rpt_ptr;

  if( gw_rpt_ptr == NULL )
  {
    CM_ERR_0("Invalid cell_info_prt");
    return;
  }

  CM_MSG_HIGH_4("Old csg id - %d New csg id - %d Old home node name length - %d New home node name length - %d",
             ss_ptr->info.csg_info.csg_id, gw_rpt_ptr->cmd.home_nodeb_name.csg_info.csg_id,
            ss_ptr->info.csg_info.hnb_name.length,gw_rpt_ptr->cmd.home_nodeb_name.csg_info.hnb_name.length);


  if((ss_ptr->info.csg_info.csg_id == gw_rpt_ptr->cmd.home_nodeb_name.csg_info.csg_id) &&
      (cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status == SYS_SRV_STATUS_SRV ||
      cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status == SYS_SRV_STATUS_SRV ))
  {

    *(&(ss_ptr->info.csg_info.hnb_name)) = *(&(gw_rpt_ptr->cmd.home_nodeb_name.csg_info.hnb_name));
    CM_MSG_HIGH_1("LL->CMSS:ss ptr hnb name length %d",ss_ptr->info.csg_info.hnb_name.length);

    /*
     ** Inform the clients about the hnb name change event
     */
    #ifdef FEATURE_MMODE_SC_SVLTE
    if(ss_ptr->info.is_hybr_gw_operational)
    {
      cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );
    }
    else
    #endif
    {
      cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
    }

  }
  else
  {
    CM_MSG_HIGH_0("Current csg id doesnt match with new csg id");
  }

}




/*===========================================================================

FUNCTION cmss_add_srv_domain_comp

DESCRIPTION
   Add a srv domain component to srv_domain_val

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  New srv domain type

SIDE EFFECTS
  none

===========================================================================*/
static sys_srv_domain_e_type cmss_add_srv_domain_comp
(
   sys_srv_domain_e_type  srv_domain_val,
     /* Srv domain value to be added with new component
     */

   sys_srv_domain_e_type   srv_domain_comp
     /* Srv domain component to be added to srv_domain_val
     */
)
{

  CM_ASSERT (INRANGE (srv_domain_val, SYS_SRV_DOMAIN_NO_SRV, SYS_SRV_DOMAIN_CS_PS));

  CM_ASSERT (INRANGE (srv_domain_comp, SYS_SRV_DOMAIN_CS_ONLY, SYS_SRV_DOMAIN_PS_ONLY));

  /* Add CS component to value
  */
  if (srv_domain_comp == SYS_SRV_DOMAIN_CS_ONLY)
  {
    if (srv_domain_val == SYS_SRV_DOMAIN_PS_ONLY)
    {
      srv_domain_val = SYS_SRV_DOMAIN_CS_PS;
    }
    else if (srv_domain_val == SYS_SRV_DOMAIN_NO_SRV)
    {
      srv_domain_val = SYS_SRV_DOMAIN_CS_ONLY;
    }
    else
    {
      if ( !( (srv_domain_val == SYS_SRV_DOMAIN_CS_ONLY) ||
              (srv_domain_val == SYS_SRV_DOMAIN_CS_PS)
            )
         )
      {
        CM_ERR_1 ("unexpected srv_domain_val %d", srv_domain_val);
      }

    }
  }


  /* Add PS component to value
  */
  if (srv_domain_comp == SYS_SRV_DOMAIN_PS_ONLY)
  {
    if (srv_domain_val == SYS_SRV_DOMAIN_CS_ONLY)
    {
      srv_domain_val = SYS_SRV_DOMAIN_CS_PS;
    }
    else if (srv_domain_val == SYS_SRV_DOMAIN_NO_SRV)
    {
      srv_domain_val = SYS_SRV_DOMAIN_PS_ONLY;
    }
    else
    {
      if ( !( (srv_domain_val == SYS_SRV_DOMAIN_PS_ONLY) ||
              (srv_domain_val == SYS_SRV_DOMAIN_CS_PS)
            )
         )
      {
        CM_ERR_1 ("unexpected srv_domain_val %d", srv_domain_val);
      }

    }
  }

  return srv_domain_val;

}/* cmss_add_srv_domain_comp */

/*===========================================================================

FUNCTION cmss_process_cipher_ind_rpt

DESCRIPTION
  This function receives ciphering indication from MM and calculates
  the correct indication to be sent to clients

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_process_cipher_ind_rpt
(
  cm_cipher_ind_s_type  cipher_info
    /* Ciphering indication to be processed */
)
{

  cmss_s_type            *ss_ptr           = cmss_ptr();
  sys_srv_domain_e_type  current_ciph_dom  = SYS_SRV_DOMAIN_NO_SRV;

  sys_srv_domain_e_type  *ss_cipher_domain_ptr
                                           = NULL;

  cm_ss_e_type           ss                = CM_SS_MAIN;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT (ss_ptr != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss = cmph_map_as_id_stack_id_to_ss(cipher_info.as_id,cipher_info.stack_id);
  CM_MSG_HIGH_2 ("LL->CMSS: cipher_ind_rpt as_id: %d ss: %d", cipher_info.as_id, ss);

  if( ss == CM_SS_HYBR_2 )
  {
    ss_cipher_domain_ptr = &ss_ptr->info.gw_cipher_domain;
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 )
  {
    ss_cipher_domain_ptr = &ss_ptr->info.gw3_cipher_domain;
  }
  else
  #endif /* FEATURE_MMODE_TRIPLE_SIM */
  {
    ss_cipher_domain_ptr = &ss_ptr->info.cipher_domain;
  }

  /* Validity check on cipher indication received
  */
  if (!INRANGE(cipher_info.cipher_domain, SYS_SRV_DOMAIN_NO_SRV,
                                          SYS_SRV_DOMAIN_PS_ONLY)
     )
  {
    CM_ERR_1 ("Invalid cipher domain %d", cipher_info.cipher_domain);
    return;
  }

  /*
  ** Get current ciphering domain
  */
  current_ciph_dom = *ss_cipher_domain_ptr;

  /* Add ciphering domain report to cipher domain field in SS object,
  ** if cipher status given by SM is TRUE. Else remove ciphering
  ** domain field in SS object.
  */
  CM_MSG_HIGH_2 ("Cipher status %d, domain %d", cipher_info.cipher_status,
                 cipher_info.cipher_domain);
  if (cipher_info.cipher_status == TRUE)
  {
    *ss_cipher_domain_ptr = cmss_add_srv_domain_comp (*ss_cipher_domain_ptr,
                                               cipher_info.cipher_domain);
  }
  else
  {
    *ss_cipher_domain_ptr = cmss_remove_srv_domain_comp (*ss_cipher_domain_ptr,
                                                 cipher_info.cipher_domain);
  }

  /* If there is change in SS object's ciphering domain field, report clients
  */
  if (current_ciph_dom != *ss_cipher_domain_ptr)
  {
    if(ss == CM_SS_HYBR_2)
    {
      ss_ptr->info.hybr_gw_changed_fields = CM_SS_GW_SRV_IND_MASK;
    }
    else
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if(ss == CM_SS_HYBR_3)
    {
      ss_ptr->info.gw3_changed_fields = CM_SS_GW_SRV_IND_MASK;
    }
    else
    #endif /* FEATURE_MMODE_TRIPLE_SIM */
    {
      ss_ptr->info.changed_fields = CM_SS_SRV_IND_MASK;
    }

    /*
    ** Inform the clients that the serving system was modified.
    */
    cmss_event( ss, CM_SS_EVENT_SRV_CHANGED );

  }

  CM_MSG_HIGH_2 (" MM reported cipher_domain = %d, SS obj cipher domain = %d",
                cipher_info.cipher_domain, *ss_cipher_domain_ptr);

} /* cmss_process_cipher_ind_rpt */



/*===========================================================================

FUNCTION cmss_rel_cipher_ind

DESCRIPTION
  This function removes the ciphering indication for a particular domain if
  it is active and informs clients.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_rel_cipher_ind
(
  sys_srv_domain_e_type cipher_domain
    /* Domain of ciphering to be removed
    */
)
{

  cmss_s_type            *ss_ptr           = cmss_ptr();
  sys_srv_domain_e_type  current_ciph_dom  = SYS_SRV_DOMAIN_NO_SRV;
  sys_srv_domain_e_type  *ss_cipher_domain_ptr = NULL;
  cm_ss_e_type           ss                = CM_SS_MAIN;


  CM_ASSERT (ss_ptr != NULL);

  CM_ASSERT (INRANGE (cipher_domain, SYS_SRV_DOMAIN_CS_ONLY, SYS_SRV_DOMAIN_PS_ONLY));

  if (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1))
  {
    if((ss_ptr->info.is_hybr_gw_operational) &&
       (ss_ptr->info.gw_cipher_domain != SYS_SRV_DOMAIN_NO_SRV))
    {
      ss = CM_SS_HYBR_2;
    }
  }
  else if (cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1))
  {
    ss = cmph_determine_ss_per_domain(SYS_MODEM_AS_ID_1,
                                      cipher_domain);
  }

  if (ss == CM_SS_HYBR_2)
  {
    ss_cipher_domain_ptr = &ss_ptr->info.gw_cipher_domain;
  }
  else
  {
    ss_cipher_domain_ptr = &ss_ptr->info.cipher_domain;
  }

  /*
  ** Get current ciphering domain
  */
  current_ciph_dom = *ss_cipher_domain_ptr;

  /* Remove ciphering domain requested, from SS object's ciphering domain
  ** field
  */
  *ss_cipher_domain_ptr = cmss_remove_srv_domain_comp (*ss_cipher_domain_ptr,
                                                        cipher_domain);

  /* If there is change in SS object ciphering domain field, report clients
  */
  if (current_ciph_dom != *ss_cipher_domain_ptr)
  {
    if (ss == CM_SS_HYBR_2)
    {
      ss_ptr->info.hybr_gw_changed_fields = CM_SS_GW_SRV_IND_MASK;
    }
    else
    {
      ss_ptr->info.changed_fields = CM_SS_SRV_IND_MASK;
    }

    /*
    ** Inform the clients that the serving system was modified.
    */
    cmss_event( ss, CM_SS_EVENT_SRV_CHANGED );

  }

  CM_MSG_HIGH_3 (" LL->CMSS: cipher_domain being rel = %d, SS=%d obj cipher domain = %d",
                cipher_domain, ss, *ss_cipher_domain_ptr);

} /* cmss_rel_cipher_ind */


/*===========================================================================

FUNCTION cmss_process_emerg_num_list_ind_rpt

DESCRIPTION
  This function receives ciphering indication from MM and calculates
  the correct indication to be sent to clients

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_process_emerg_num_list_ind_rpt
(
  const cm_rpt_type  *cm_rpt_ptr
    /* Pointer to cm report */
)
{
  #if defined(CM_GW_SUPPORTED)

  const cm_emergency_num_list_ind_s_type *emerg_num_list_ptr;
    /* Pointer to emergenyc number list */

  cmss_s_type              *ss_ptr    = cmss_ptr();
    /* Pointer to serving system object. */

  cm_emerg_num_list_s_type *emerg_ss_info_ptr;
    /* Pointer to emergency number list in ss object */

  int                       elist_cnt = 0;
    /* List of emergency numbers*/

  byte                      emerg_num_in_bcd   [CM_MAX_NUMBER_CHARS];
    /* Hold the bcd format of emergency number
    ** Size of emerg_num_in_bcd should be CMSS_MAX_EMERG_BCD_NUM_LEN + 2 bytes
    ** (1 byte for BCD_LEN + 1 byte for BCD_NT_NPI)
    */

  int                       num_entry = 0;
    /* Loops through emergency numbers */

  byte                      ascii_buff [CM_MAX_NUMBER_CHARS];
    /* Ascii buffer length */

  cm_ss_e_type              ss        = CM_SS_MAIN;

  int                      emerg_num_count;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT(cm_rpt_ptr);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize the variables
  */
  emerg_num_list_ptr = &cm_rpt_ptr->cmd.emerg_num_list;

  ss = cmph_map_as_id_stack_id_to_ss(emerg_num_list_ptr->as_id,emerg_num_list_ptr->stack_id);
  CM_MSG_HIGH_2 ("LL->CMSS: emerg_num_list_ind, as_id: %d ss: %d", emerg_num_list_ptr->as_id, ss);

  if( ss == CM_SS_HYBR_2 )
  {
    emerg_ss_info_ptr = &ss_ptr->info.gw_emerg_num_list;
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 )
  {
    emerg_ss_info_ptr = &ss_ptr->info.gw3_emerg_num_list;
  }
  else
  #endif /* FEATURE_MMODE_TRIPLE_SIM */


  {
    emerg_ss_info_ptr = &ss_ptr->info.emerg_num_list;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* count of emergency numbers
  */
  elist_cnt = emerg_num_list_ptr->emergency_number_list.emergency_num_count;

  emerg_num_count =  cm_util_cm_max_emergency_num_count();

  CM_MSG_HIGH_1 ("CM_EMERGENCY_NUM_LIST_IND: List len = %d", elist_cnt);

  /* Forcing the maximum numbers that can be given
  */
  if (elist_cnt > emerg_num_count)
  {
    CM_ERR_1 ("Emerg List greater than %d", emerg_num_count);
    elist_cnt = emerg_num_count;
  }

  /* Copy the length of emerg call numbers to SS object
  */
  emerg_ss_info_ptr->num_list_len = elist_cnt;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Loop through the emerg numbers and copy them in ss object
  */
  for (num_entry=0;  num_entry < elist_cnt && num_entry <
                   (int) ARR_SIZE (emerg_ss_info_ptr->num_list); ++num_entry)
  {

    /* Initialize the num buffer
    */
    cm_num_init (&emerg_ss_info_ptr->num_list[num_entry].num);

    /* Set the digit mode to 8 bit ascii
    */
    emerg_ss_info_ptr->num_list[num_entry].num.digit_mode =
                                                 CM_DIGIT_MODE_8BIT_ASCII;

    /* Convert number type from reg to cm bit masks
    */
    emerg_ss_info_ptr->num_list[num_entry].num_type =
    cmss_map_reg_emergtype_to_cm_emergtype (
      emerg_num_list_ptr->emergency_number_list.emergency_number[num_entry].type
    );

    /******************************************************************
    ************ convert number in bcd to cm_num_s_type****************
    ******************************************************************/

    /* cm_util_bcd_to_ascii() expects bcd length to include number type.
    ** First byte of bcd digit that CM gets for incoming calls, is a number
    ** type. Length of the number sent to CM is one byte more than the length
    ** of the e-number. cm_util_bcd_to_ascii() expects the same, so copy
    ** length as is.
    **
    */
    emerg_num_in_bcd[BCD_LEN] = emerg_num_list_ptr->emergency_number_list.
                                     emergency_number[num_entry].length ;

    /* Presentation indicaton (PI) should be absent in bcd number.
    ** If PI is present cm_util_bcd_to_ascii() expects one extra byte to have
    ** Presentation information.
    */
    emerg_num_in_bcd[BCD_NT_NPI] = CM_EXTENSION_BIT;

    /* If given BCD is greater than CMSS_MAX_EMERG_BCD_NUM_LEN, copy
    ** till CMSS_MAX_EMERG_BCD_NUM_LEN
    */
    if (emerg_num_list_ptr->emergency_number_list.emergency_number[num_entry].length
        > CMSS_MAX_EMERG_BCD_NUM_LEN)
    {
      emerg_num_in_bcd[BCD_LEN] = CMSS_MAX_EMERG_BCD_NUM_LEN + 1;
    }

    /* Copy BCD number */
    memscpy( &emerg_num_in_bcd[BCD_NUM],
             ( ( ARR_SIZE(emerg_num_in_bcd) - BCD_NUM ) *  sizeof(emerg_num_in_bcd[0]) ),
             emerg_num_list_ptr->emergency_number_list.emergency_number[num_entry].number,
            MIN(sizeof(emerg_num_list_ptr->emergency_number_list.emergency_number[num_entry].number),emerg_num_in_bcd[BCD_LEN] - 1)
           );

    /* Convert BCD number to ascii
    */
    cm_util_bcd_num_to_ascii_num( emerg_num_in_bcd, ascii_buff, sizeof(ascii_buff) );

    /* Copy ascii string to number buffer
    */
    if ( ascii_buff[0] != 0 )
    {
      emerg_ss_info_ptr->num_list[num_entry].num.len = memscpy( emerg_ss_info_ptr->num_list[num_entry].num.buf,
                                                                sizeof( emerg_ss_info_ptr->num_list[num_entry].num.buf ),
                                                                ascii_buff,
                                                                strlen((char *)ascii_buff) ) ;
    }

    CM_MSG_HIGH_2 ("Len of emerg number %d is %d", num_entry,
                  (byte )strlen((char *)ascii_buff));
  } /* for */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmss_event ( ss, CM_SS_EVENT_EMERG_NUM_LIST);

  #else

  SYS_ARG_NOT_USED (cm_rpt_ptr);

  #endif /* CM_GW_SUPPORTED */

} /* cmss_process_emerg_num_list_ind_rpt() */


/*===========================================================================

FUNCTION cmss_process_cell_supp_services_rpt

DESCRIPTION
  This function receives cell supported services to be sent out to the clients.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_process_cell_supp_services_rpt
(
  const cm_rpt_type  *cm_rpt_ptr
    /* Pointer to cm report */
)
{

#if defined(FEATURE_HSDPA) || defined(FEATURE_GSM_DTM)

  cmss_s_type                      *ss_ptr             = cmss_ptr();
    /* Pointer to serving system object.
    */

  const cm_cell_service_ind_s_type *cell_service_ind_ptr;
    /* Pointer to cell service indications */

  cm_cell_srv_ind_s_type           *cell_srv_ind;
    /* Current cell info */

  cm_ss_e_type                     ss                 = CM_SS_MAIN;
    /* SS on which this report is being recieved */

  sys_sys_mode_e_type              sys_mode;
    /* Sys mode of the SS */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize local variables
  */
  cell_service_ind_ptr  = &cm_rpt_ptr->cmd.cell_service_ind;

  
  #ifdef FEATURE_CM_DEBUG_BUFFER
  // Disabling as of now as it eats up many entries
  //cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_CELL_SERVICES_IND, ((void*)&(cm_rpt_ptr->cmd.cell_service_ind)));
  #endif
  
  ss = cmph_map_as_id_stack_id_to_ss(cell_service_ind_ptr->as_id,cell_service_ind_ptr->stack_id);

  if( ss == CM_SS_HYBR_2 )
  {
    cell_srv_ind = &ss_ptr->info.gw_cell_srv_ind;
    sys_mode     = ss_ptr->info.gw_sys_mode;
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 )
  {
    cell_srv_ind = &ss_ptr->info.gw3_cell_srv_ind;
    sys_mode     = ss_ptr->info.gw3_sys_mode;
  }
  else
  #endif /* FEATURE_MMODE_TRIPLE_SIM */
  {
    cell_srv_ind = &ss_ptr->info.cell_srv_ind;
    sys_mode     = ss_ptr->info.sys_mode;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_6("HS srv %d, ss_ptr supp HS %d | DTM srv %d, ss_ptr supp DTM %d | EGPRS srv %d, ss_ptr supp EGPRS %d",
                cell_service_ind_ptr->hsdpa_hsupa_support,
                cell_srv_ind->hs_ind,
                cell_service_ind_ptr->dtm_support, cell_srv_ind->dtm_supp,
                cell_service_ind_ptr->egprs_support,
                cell_srv_ind->egprs_supp);

  if ( !(BETWEEN (cell_service_ind_ptr->hsdpa_hsupa_support, SYS_HS_IND_NONE,
                 SYS_HS_IND_MAX))
       ||
       !(BETWEEN (cell_service_ind_ptr->dtm_support, SYS_DTM_SUPPORT_NONE,
                  SYS_DTM_SUPPORT_MAX))
       ||
       !(BETWEEN (cell_service_ind_ptr->egprs_support, SYS_EGPRS_SUPPORT_NONE,
                  SYS_EGPRS_SUPPORT_MAX))
     )
  {
    CM_ERR_0 (" One of the cell supp services out of range");
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Copy HSDPA ind in SS obj and send event only if in
  ** WCDMA and ind value has changed
  */
  if (cell_service_ind_ptr->hsdpa_hsupa_support != cell_srv_ind->hs_ind)
  {
    cell_srv_ind->hs_ind = cell_service_ind_ptr->hsdpa_hsupa_support;

    if (sys_mode == SYS_SYS_MODE_WCDMA ||
        sys_mode == SYS_SYS_MODE_TDS)
    {
      cmss_event ( ss, CM_SS_EVENT_SRV_CHANGED);
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Copy DTM ind in SS obj and send event only if in
  ** GSM and ind value has changed
  */
  if (cell_service_ind_ptr->dtm_support != cell_srv_ind->dtm_supp)
  {
    cell_srv_ind->dtm_supp = cell_service_ind_ptr->dtm_support;

    if (sys_mode == SYS_SYS_MODE_GSM)
    {
      cmss_event ( ss, CM_SS_EVENT_SRV_CHANGED);
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Copy EGPRS ind in SS obj and send event only if in GSM and
  ** EGPRS ind value has changed
  */
  if (cell_service_ind_ptr->egprs_support != cell_srv_ind->egprs_supp)
  {
    cell_srv_ind->egprs_supp = cell_service_ind_ptr->egprs_support;

    if (sys_mode == SYS_SYS_MODE_GSM)
    {
      cmss_event ( ss, CM_SS_EVENT_SRV_CHANGED);
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #else

  SYS_ARG_NOT_USED (cm_rpt_ptr);

  #endif /* FEATURE_GW_CELL_SUPP_SERVICES */

} /* cmss_process_cell_supp_services_rpt () */


/*===========================================================================

FUNCTION cm_map_band_mask_to_band_class

DESCRIPTION
  Map band mask to band class

DEPENDENCIES
  None.

RETURN VALUE
  Band.

SIDE EFFECTS
  None.

===========================================================================*/
static  sys_band_class_e_type            cm_map_band_mask_to_band_class(

        sys_band_mask_e_type    band_mask
          /* Band mapped to band mask.
          */
)
{
  static const sys_sband_e_type band_pref_bit_tbl[] =
  {
    SYS_SBAND_BC1,
    SYS_SBAND_BC3,
    SYS_SBAND_BC4,
    SYS_SBAND_BC5,
    SYS_SBAND_BC6,
    SYS_SBAND_BC7,
    SYS_SBAND_BC10,
    SYS_SBAND_BC11,
    SYS_SBAND_BC12,
    SYS_SBAND_BC14,
    SYS_SBAND_BC15,
    SYS_SBAND_BC16,
    SYS_SBAND_BC17,
    SYS_SBAND_BC18,
    SYS_SBAND_BC19,
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    SYS_SBAND_GSM_450,
    SYS_SBAND_GSM_480,
    SYS_SBAND_GSM_DCS_1800,
    SYS_SBAND_GSM_EGSM_900,
    SYS_SBAND_GSM_PGSM_900,
    SYS_SBAND_GSM_RGSM_900,
    SYS_SBAND_GSM_PCS_1900,
    SYS_SBAND_GSM_850,
    SYS_SBAND_GSM_750,

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    SYS_SBAND_WCDMA_I_IMT_2000,
    SYS_SBAND_WCDMA_II_PCS_1900,
    SYS_SBAND_WCDMA_III_1700,
    SYS_SBAND_WCDMA_IV_1700,
    SYS_SBAND_WCDMA_V_850,
    SYS_SBAND_WCDMA_VI_800,
    SYS_SBAND_WCDMA_VII_2600,
    SYS_SBAND_WCDMA_VIII_900,
    SYS_SBAND_WCDMA_IX_1700,
    SYS_SBAND_WCDMA_XI_1500,
    SYS_SBAND_WCDMA_XIX_850
  };

  /* KW: This is an initialization, so array size should be equal to no. of
  ** entries in the initializer
  */
  static const sys_band_class_e_type band_val[] =
  {
    SYS_BAND_BC1,
    SYS_BAND_BC3,
    SYS_BAND_BC4,
    SYS_BAND_BC5,
    SYS_BAND_BC6,
    SYS_BAND_BC7,
    SYS_BAND_BC10,
    SYS_BAND_BC11,
    SYS_BAND_BC12,
    SYS_BAND_BC14,
    SYS_BAND_BC15,
    SYS_BAND_BC16,
    SYS_BAND_BC17,
    SYS_BAND_BC18,
    SYS_BAND_BC19,

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    SYS_BAND_GSM_450,
    SYS_BAND_GSM_480,
    SYS_BAND_GSM_DCS_1800,
    SYS_BAND_GSM_EGSM_900,
    SYS_BAND_GSM_PGSM_900,
    SYS_BAND_GSM_RGSM_900,
    SYS_BAND_GSM_PCS_1900,
    SYS_BAND_GSM_850,
    SYS_BAND_GSM_750,

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    SYS_BAND_WCDMA_I_IMT_2000,
    SYS_BAND_WCDMA_II_PCS_1900,
    SYS_BAND_WCDMA_III_1700,
    SYS_BAND_WCDMA_IV_1700,
    SYS_BAND_WCDMA_V_850,
    SYS_BAND_WCDMA_VI_800,
    SYS_BAND_WCDMA_VII_2600,
    SYS_BAND_WCDMA_VIII_900,
    SYS_BAND_WCDMA_IX_1700,
    SYS_BAND_WCDMA_XI_1500,
    SYS_BAND_WCDMA_XIX_850
  };

  word i;

  CM_ASSERT( ARR_SIZE(band_pref_bit_tbl) == ARR_SIZE(band_val) );

  /* Map the specified band preferences to its corresponding band.
  */
  if( SD_BAND_CONTAIN( band_mask, SYS_SBAND_BC0_A ) || SD_BAND_CONTAIN( band_mask, SYS_SBAND_BC0_B ))
    return SYS_BAND_BC0;

  for(i=0; i<ARR_SIZE(band_pref_bit_tbl); i++)
  {
    if( SD_BAND_CONTAIN( band_mask, SYS_BM_64BIT(band_pref_bit_tbl[i]) ) )
    {
      return band_val[i];
    }
  }

  return SYS_BAND_CLASS_MAX;

} /* cm_map_band_mask_to_band_class */

/*===========================================================================

FUNCTION cmss_process_cell_info_rpt

DESCRIPTION
  This function receives cell info from RRC/RR to be sent out to the clients.
  SRV change event sent to client only if change in cell_id or plmn_id

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_process_cell_info_rpt
(
  const void           *rpt_ptr,
    /* ptr to message received */

  const sys_sys_mode_e_type  as_sys_mode
    /* AS RAT to update the cell info. */
)
{
  cmss_s_type           *ss_ptr     = cmss_ptr();
  /* Pointer to serving system object.
  */
  int                   i;
  const cm_rpt_type     *gw_rpt_ptr = rpt_ptr;

  cm_ss_e_type          ss          = CM_SS_MAIN;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( gw_rpt_ptr == NULL )
  {
    CM_ERR_0("Invalid cell_info_prt");
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set the falg if the response is due to DCH_CELL_INFO_CNF  */
  #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined(FEATURE_WCDMA))

  if (gw_rpt_ptr->hdr.cmd == CM_RRC_DCH_CELL_INFO_CNF)
  {
    ss_ptr->dch_cell_info_flgs |= CMSS_IS_DCH_CELL_INFO_RES;
  }
  else
  {
    ss_ptr->dch_cell_info_flgs &= ~(CMSS_IS_DCH_CELL_INFO_RES);
  }
  #endif

  /* Determine cm_ss */
  ss = cmph_determine_ss_per_rat(gw_rpt_ptr->asubs_id, as_sys_mode);

  CM_MSG_HIGH_4 ("Cell_info on as_id=%d, ss=%d ,lac info: old lac %d, new lac %d", gw_rpt_ptr->asubs_id, ss,
               ss_ptr->gw_cell_info.lac_id, gw_rpt_ptr->cmd.cell_info.lac_id);
  CM_MSG_HIGH_6 ("lac info: old lac %d, new lac %d, as_sys_mode %d ,Old plmn info: %d, %d %d",
               ss_ptr->gw_cell_info.lac_id, gw_rpt_ptr->cmd.cell_info.lac_id,
               as_sys_mode,ss_ptr->gw_cell_info.plmn_id.identity[0],
               ss_ptr->gw_cell_info.plmn_id.identity[1],
              ss_ptr->gw_cell_info.plmn_id.identity[2]);

  CM_MSG_HIGH_5 ("New plmn info: %d, %d %d ,arfcn info: old arfcn %d, new arfcn %d", 
               gw_rpt_ptr->cmd.cell_info.plmn_id.identity[0],
              gw_rpt_ptr->cmd.cell_info.plmn_id.identity[1],
              gw_rpt_ptr->cmd.cell_info.plmn_id.identity[2],
               ss_ptr->gw_cell_info.arfcn, gw_rpt_ptr->cmd.cell_info.arfcn);
  
  CM_MSG_HIGH_6 ("bsic info: old bsic %d, new bsic %d psc info: old psc %d, new psc %d, arfcn_dl info: old uarfcn_dl %d, new uarfcn_dl %d",
               ss_ptr->gw_cell_info.bsic, gw_rpt_ptr->cmd.cell_info.bsic,
               ss_ptr->gw_cell_info.psc, gw_rpt_ptr->cmd.cell_info.psc,
               ss_ptr->gw_cell_info.uarfcn_dl, gw_rpt_ptr->cmd.cell_info.uarfcn_dl);

  CM_MSG_HIGH_6 ("uarfcn_ul info: old uarfcn_ul %d, new uarfcn_ul %d, refpn info: old refpn %d, new refpn %d, Band info: old band %d, new band %d",
               ss_ptr->gw_cell_info.uarfcn_ul, gw_rpt_ptr->cmd.cell_info.uarfcn_ul,
               ss_ptr->gw_cell_info.refpn, gw_rpt_ptr->cmd.cell_info.refpn,
               ss_ptr->gw_cell_info.current_band, gw_rpt_ptr->cmd.cell_info.current_band);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Copy CELL_ID, LAC, PLMN, ARFCN, BSIC, PSC, down link UARFCN,
  ** uplink UARFCN, PN Number,info in SS obj
  */
  if( ss == CM_SS_HYBR_2)
  {
    ss_ptr->hybr_gw_cell_info.cell_id                   = gw_rpt_ptr->cmd.cell_info.cell_id;
    ss_ptr->hybr_gw_cell_info.lac_id                    = gw_rpt_ptr->cmd.cell_info.lac_id;
    ss_ptr->hybr_gw_cell_info.as_sys_mode               = as_sys_mode;
    ss_ptr->hybr_gw_cell_info.tac                       = 0;

    for ( i=0; i<3; i++ )
    {
      ss_ptr->hybr_gw_cell_info.plmn_id.identity[i]     = gw_rpt_ptr->cmd.cell_info.plmn_id.identity[i];
    }
    ss_ptr->hybr_gw_cell_info.arfcn                     = gw_rpt_ptr->cmd.cell_info.arfcn;
    ss_ptr->hybr_gw_cell_info.bsic                      = gw_rpt_ptr->cmd.cell_info.bsic;
    ss_ptr->hybr_gw_cell_info.psc                       = gw_rpt_ptr->cmd.cell_info.psc;
    ss_ptr->hybr_gw_cell_info.uarfcn_dl                 = gw_rpt_ptr->cmd.cell_info.uarfcn_dl;
    ss_ptr->hybr_gw_cell_info.uarfcn_ul                 = gw_rpt_ptr->cmd.cell_info.uarfcn_ul;
    ss_ptr->hybr_gw_cell_info.refpn                     = gw_rpt_ptr->cmd.cell_info.refpn;
    ss_ptr->hybr_gw_cell_info.current_band              = gw_rpt_ptr->cmd.cell_info.current_band;

    /* update only iff cell_id or plmn_id or rat gets changed
    */
    if((ss_ptr->hybr_gw_cell_info.cell_id != ss_ptr->info.gw_cell_info.cell_id) ||
       (ss_ptr->hybr_gw_cell_info.as_sys_mode != ss_ptr->info.gw_cell_info.as_sys_mode) ||
       (ss_ptr->hybr_gw_cell_info.plmn_id.identity[0] != ss_ptr->info.gw_cell_info.plmn_id.identity[0])||
       (ss_ptr->hybr_gw_cell_info.plmn_id.identity[1] != ss_ptr->info.gw_cell_info.plmn_id.identity[1])||
       (ss_ptr->hybr_gw_cell_info.plmn_id.identity[2] != ss_ptr->info.gw_cell_info.plmn_id.identity[2])||
       (ss_ptr->hybr_gw_cell_info.current_band!= ss_ptr->info.gw_cell_info.current_band)
       #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
       || (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
       #endif
       )
    {
      ss_ptr->info.gw_cell_info.cell_id    = ss_ptr->hybr_gw_cell_info.cell_id;
      ss_ptr->info.gw_cell_info.lac_id     = ss_ptr->hybr_gw_cell_info.lac_id;
      ss_ptr->info.gw_cell_info.as_sys_mode = ss_ptr->hybr_gw_cell_info.as_sys_mode;
      ss_ptr->info.gw_cell_info.tac        = ss_ptr->hybr_gw_cell_info.tac;

      for ( i=0; i<3; i++ )
      {
        ss_ptr->info.gw_cell_info.plmn_id.identity[i]
                                = ss_ptr->hybr_gw_cell_info.plmn_id.identity[i];
      }
      ss_ptr->info.gw_cell_info.arfcn      = ss_ptr->hybr_gw_cell_info.arfcn;
      ss_ptr->info.gw_cell_info.bsic       = ss_ptr->hybr_gw_cell_info.bsic;
      ss_ptr->info.gw_cell_info.psc        = ss_ptr->hybr_gw_cell_info.psc;
      ss_ptr->info.gw_cell_info.uarfcn_dl  = ss_ptr->hybr_gw_cell_info.uarfcn_dl;
      ss_ptr->info.gw_cell_info.uarfcn_ul  = ss_ptr->hybr_gw_cell_info.uarfcn_ul;
      ss_ptr->info.gw_cell_info.refpn      = ss_ptr->hybr_gw_cell_info.refpn;

 /*Updating bands */
      ss_ptr->info.gw_cell_info.current_band = ss_ptr->hybr_gw_cell_info.current_band;

      CM_MSG_MED_2 ("Band info: updated active band in ss_ptr->info %d current band in ssptr.info %d",
                   ss_ptr->info.gw_active_band, ss_ptr->info.gw_cell_info.current_band );

      if(ss_ptr->info.is_hybr_gw_operational)
      {
        ss_ptr->info.hybr_gw_changed_fields = 0;
      }
      /* Reset info for changed_field before sending event*/
      ss_ptr->info.changed_fields         = 0;
      ss_ptr->info.changed_fields2        = 0;

      CM_MSG_MED_0("SRV_CHANGED event for cell info on HYBR_GW");

       #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
       if (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
       {
         cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_DCH_CELL_ID_RSP );
       }
       else
       #endif
       {
         cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );
       }
      #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
      if (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
      {
        ss_ptr->dch_cell_info_flgs = 0;
      }
      #endif
    }
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3)
  {
    if(cmph_is_tsts() || cmph_is_sxlte())
    {
    ss_ptr->hybr_3_gw_cell_info.cell_id                   = gw_rpt_ptr->cmd.cell_info.cell_id;
    ss_ptr->hybr_3_gw_cell_info.lac_id                    = gw_rpt_ptr->cmd.cell_info.lac_id;
    ss_ptr->hybr_3_gw_cell_info.as_sys_mode               = as_sys_mode;
    ss_ptr->hybr_3_gw_cell_info.tac                       = 0;

    for ( i=0; i<3; i++ )
    {
      ss_ptr->hybr_3_gw_cell_info.plmn_id.identity[i]     = gw_rpt_ptr->cmd.cell_info.plmn_id.identity[i];
    }
    ss_ptr->hybr_3_gw_cell_info.arfcn                     = gw_rpt_ptr->cmd.cell_info.arfcn;
    ss_ptr->hybr_3_gw_cell_info.bsic                      = gw_rpt_ptr->cmd.cell_info.bsic;
    ss_ptr->hybr_3_gw_cell_info.psc                       = gw_rpt_ptr->cmd.cell_info.psc;
    ss_ptr->hybr_3_gw_cell_info.uarfcn_dl                 = gw_rpt_ptr->cmd.cell_info.uarfcn_dl;
    ss_ptr->hybr_3_gw_cell_info.uarfcn_ul                 = gw_rpt_ptr->cmd.cell_info.uarfcn_ul;
    ss_ptr->hybr_3_gw_cell_info.refpn                     = gw_rpt_ptr->cmd.cell_info.refpn;

    /* update only iff cell_id or plmn_id get changed
    */
    if((ss_ptr->hybr_3_gw_cell_info.cell_id != ss_ptr->info.gw3_cell_info.cell_id) ||
       (ss_ptr->hybr_3_gw_cell_info.as_sys_mode != ss_ptr->info.gw3_cell_info.as_sys_mode) ||
       (ss_ptr->hybr_3_gw_cell_info.plmn_id.identity[0] != ss_ptr->info.gw3_cell_info.plmn_id.identity[0])||
       (ss_ptr->hybr_3_gw_cell_info.plmn_id.identity[1] != ss_ptr->info.gw3_cell_info.plmn_id.identity[1])||
       (ss_ptr->hybr_3_gw_cell_info.plmn_id.identity[2] != ss_ptr->info.gw3_cell_info.plmn_id.identity[2])
     #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
       || (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
     #endif
       )
    {
      ss_ptr->info.gw3_cell_info.cell_id    = ss_ptr->hybr_3_gw_cell_info.cell_id;
      ss_ptr->info.gw3_cell_info.lac_id     = ss_ptr->hybr_3_gw_cell_info.lac_id;
      ss_ptr->info.gw3_cell_info.as_sys_mode = ss_ptr->hybr_3_gw_cell_info.as_sys_mode;
      ss_ptr->info.gw3_cell_info.tac        = ss_ptr->hybr_3_gw_cell_info.tac;

      for ( i=0; i<3; i++ )
      {
        ss_ptr->info.gw3_cell_info.plmn_id.identity[i]
                                = ss_ptr->hybr_3_gw_cell_info.plmn_id.identity[i];
      }
      ss_ptr->info.gw3_cell_info.arfcn      = ss_ptr->hybr_3_gw_cell_info.arfcn;
      ss_ptr->info.gw3_cell_info.bsic       = ss_ptr->hybr_3_gw_cell_info.bsic;
      ss_ptr->info.gw3_cell_info.psc        = ss_ptr->hybr_3_gw_cell_info.psc;
      ss_ptr->info.gw3_cell_info.uarfcn_dl  = ss_ptr->hybr_3_gw_cell_info.uarfcn_dl;
      ss_ptr->info.gw3_cell_info.uarfcn_ul  = ss_ptr->hybr_3_gw_cell_info.uarfcn_ul;
      ss_ptr->info.gw3_cell_info.refpn      = ss_ptr->hybr_3_gw_cell_info.refpn;

      if(ss_ptr->info.is_gw3_operational)
      {
        ss_ptr->info.gw3_changed_fields = 0;
      }
      /* Reset info for changed_field before sending event*/
      ss_ptr->info.changed_fields         = 0;
      ss_ptr->info.changed_fields2        = 0;

      CM_MSG_MED_0("SRV_CHANGED event for cell info on HYBR_3_GW");

       #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
       if (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
       {
         cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_DCH_CELL_ID_RSP );
       }
       else
       #endif
       {
         cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_SRV_CHANGED );
       }
      #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
      if (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
      {
        ss_ptr->dch_cell_info_flgs = 0;
      }
      #endif
    }
  }
  }
  else
  #endif /* FEATURE_MMODE_TRIPLE_SIM */
  {
    ss_ptr->gw_cell_info.cell_id           = gw_rpt_ptr->cmd.cell_info.cell_id;
    ss_ptr->gw_cell_info.lac_id            = gw_rpt_ptr->cmd.cell_info.lac_id;
    ss_ptr->gw_cell_info.as_sys_mode       = as_sys_mode;
    ss_ptr->gw_cell_info.tac               = 0;

    for ( i=0; i<3; i++ )
    {
      ss_ptr->gw_cell_info.plmn_id.identity[i]     = gw_rpt_ptr->cmd.cell_info.plmn_id.identity[i];
    }
    ss_ptr->gw_cell_info.arfcn             = gw_rpt_ptr->cmd.cell_info.arfcn;
    ss_ptr->gw_cell_info.bsic              = gw_rpt_ptr->cmd.cell_info.bsic;
    ss_ptr->gw_cell_info.psc               = gw_rpt_ptr->cmd.cell_info.psc;
    ss_ptr->gw_cell_info.uarfcn_dl         = gw_rpt_ptr->cmd.cell_info.uarfcn_dl;
    ss_ptr->gw_cell_info.uarfcn_ul         = gw_rpt_ptr->cmd.cell_info.uarfcn_ul;
    ss_ptr->gw_cell_info.refpn             = gw_rpt_ptr->cmd.cell_info.refpn;
    ss_ptr->gw_cell_info.current_band      = gw_rpt_ptr->cmd.cell_info.current_band;
    CM_MSG_MED_1 ("Band info: updated current band in cmss ptr %d", ss_ptr->gw_cell_info.current_band);

    if((ss_ptr->gw_cell_info.cell_id != ss_ptr->info.cell_info.cell_id)||
       (ss_ptr->gw_cell_info.as_sys_mode != ss_ptr->info.cell_info.as_sys_mode) ||
       (ss_ptr->gw_cell_info.plmn_id.identity[0] != ss_ptr->info.cell_info.plmn_id.identity[0])||
       (ss_ptr->gw_cell_info.plmn_id.identity[1] != ss_ptr->info.cell_info.plmn_id.identity[1])||
       (ss_ptr->gw_cell_info.plmn_id.identity[2] != ss_ptr->info.cell_info.plmn_id.identity[2])||
       (ss_ptr->gw_cell_info.current_band != ss_ptr->info.cell_info.current_band)
       #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined(FEATURE_WCDMA))
       || (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
       #endif
       )
    {
      ss_ptr->info.cell_info.cell_id       = ss_ptr->gw_cell_info.cell_id;
      ss_ptr->info.cell_info.lac_id        = ss_ptr->gw_cell_info.lac_id;
      ss_ptr->info.cell_info.as_sys_mode   = ss_ptr->gw_cell_info.as_sys_mode;
      ss_ptr->info.cell_info.tac           = ss_ptr->gw_cell_info.tac;

      for ( i=0; i<3; i++ )
      {
        ss_ptr->info.cell_info.plmn_id.identity[i]    = ss_ptr->gw_cell_info.plmn_id.identity[i];
      }
      ss_ptr->info.cell_info.arfcn         = ss_ptr->gw_cell_info.arfcn;
      ss_ptr->info.cell_info.bsic          = ss_ptr->gw_cell_info.bsic;
      ss_ptr->info.cell_info.psc           = ss_ptr->gw_cell_info.psc;
      ss_ptr->info.cell_info.uarfcn_dl     = ss_ptr->gw_cell_info.uarfcn_dl;
      ss_ptr->info.cell_info.uarfcn_ul     = ss_ptr->gw_cell_info.uarfcn_ul;
      ss_ptr->info.cell_info.refpn         = ss_ptr->gw_cell_info.refpn;

      /*Updating bands*/
      ss_ptr->info.cell_info.current_band  = ss_ptr->gw_cell_info.current_band;

      CM_MSG_MED_2 ("Band info: updated active band in ss_ptr->info %d current band in ssptr.info %d",
                 ss_ptr->info.active_band, ss_ptr->info.cell_info.current_band );


      if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) && ss_ptr->info.is_hybr_gw_operational)
      {
        ss_ptr->info.hybr_gw_changed_fields = 0;
      }

      /* Reset info for changed_field before sending event*/
      ss_ptr->info.changed_fields         = 0;
      ss_ptr->info.changed_fields2        = 0;

      CM_MSG_MED_0("CM sending SRV_CHANGED event for cell info");

       #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined(FEATURE_WCDMA))
       if(ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
       {
         cmss_event( CM_SS_MAIN, CM_SS_EVENT_DCH_CELL_ID_RSP );
       }
       else
       #endif
       {
         cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
       }
      #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
      if (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
      {

        ss_ptr->dch_cell_info_flgs = 0;
      }
      #endif

    }
    else
    {
      CM_MSG_MED_0 ("No Change in Cell info, NO EVENT sent to client");
    }
  }
} /* cmss_process_cell_info_rpt */

#ifdef FEATURE_CM_LTE
/*===========================================================================

FUNCTION cmss_read_emerg_barring_params

DESCRIPTION
  This function receives emergency ac barring info from LTE RRC to be sent out to the clients.
  
DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cmss_read_emerg_barring_params
(
    lte_rrc_barring_update_ind_s   *barring_update_ind
)
{
  cm_ss_e_type            cm_ss    = CM_SS_MAIN;
  sys_modem_as_id_e_type  asubs_id = SYS_MODEM_AS_ID_1;
  cmss_s_type             *ss_ptr = cmss_ptr();
  boolean                 is_changed  = FALSE;

  #ifdef FEATURE_MMODE_DUAL_SIM
  if(cmph_is_msim())
  {
    asubs_id = INST_ID_TO_SYS_AS_ID(barring_update_ind->msg_hdr.inst_id);
  }
  #endif

  cm_ss = cmph_determine_ss_per_rat(asubs_id, SYS_SYS_MODE_LTE);

  if( cm_ss == CM_SS_HYBR_2)
  {
    if(ss_ptr->info.gw_cell_info.emerg_access_status !=\
       barring_update_ind->emergency_access_barred)
    {
      CM_MSG_HIGH_2 ("LL->CMSS: Emerg_access_status: old status = %d, new status = %d",
                   ss_ptr->info.gw_cell_info.emerg_access_status,
                   barring_update_ind->emergency_access_barred);

      ss_ptr->info.gw_cell_info.emerg_access_status = \
        barring_update_ind->emergency_access_barred;

      is_changed = TRUE;

      sd_ss_update_emerg_bar_status(ss_ptr->info.gw_cell_info.emerg_access_status );

    }
    if(is_changed)
    {
      cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );
    }
  }
  else if( cm_ss == CM_SS_HYBR_3)
  {
    if(ss_ptr->info.gw3_cell_info.emerg_access_status !=\
       barring_update_ind->emergency_access_barred)
    {
      CM_MSG_HIGH_2 ("LL->CMSS: Hybr3 Emerg_access_status: old status = %d, new status = %d",
                   ss_ptr->info.gw3_cell_info.emerg_access_status,
                   barring_update_ind->emergency_access_barred);

      ss_ptr->info.gw3_cell_info.emerg_access_status = \
        barring_update_ind->emergency_access_barred;

      is_changed = TRUE;

      sd_ss_update_emerg_bar_status(ss_ptr->info.gw3_cell_info.emerg_access_status );

    }
    if(is_changed)
    {
      cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_SRV_CHANGED );
    }
  }  
  else
  {
    if(ss_ptr->info.cell_info.emerg_access_status !=\
        barring_update_ind->emergency_access_barred)
    {
      CM_MSG_HIGH_2 ("LL->CMSS: Emerg_access_status: old status = %d, new status = %d",
                   ss_ptr->info.cell_info.emerg_access_status,
                   barring_update_ind->emergency_access_barred);

      ss_ptr->info.cell_info.emerg_access_status = \
        barring_update_ind->emergency_access_barred;

      is_changed = TRUE;

      sd_ss_update_emerg_bar_status(ss_ptr->info.cell_info.emerg_access_status );
    }

    if(is_changed)
    {
      cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
    }
  }
}
/*===========================================================================

FUNCTION cmss_update_lte_cell_info

DESCRIPTION
  This function receives cell info from LTE RRC to be sent out to the clients.
  SRV change event sent to client only if svc_status is AVAILABLE and there's
  change in cell_id.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_update_lte_cell_info
(
  const lte_rrc_service_ind_s           *rpt_ptr
    /* ptr to message received */
)
{
  cmss_s_type             *ss_ptr                  = cmss_ptr();
  boolean                 is_changed               = FALSE;
  cm_ss_e_type            cm_ss                       = CM_SS_MAIN;
  sys_modem_as_id_e_type  asubs_id = SYS_MODEM_AS_ID_1;
  sys_plmn_id_s_type       plmn_id;

  #ifdef FEATURE_DOMAIN_SELECTION
  cmsds_s_type           *sds_ptr                 = cmsds_ptr();
  /* Pointer to domain selection object. .*/
  #endif
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT( rpt_ptr != NULL );

  #ifdef FEATURE_DOMAIN_SELECTION
  sds_ptr->plmn_id = cmss_convert_rrc_plmn_id_to_sys_plmn_id(rpt_ptr->camped_svc_info.selected_plmn);
  CM_MSG_HIGH_3 ("RRC Plmn info: %d, %d %d", sds_ptr->plmn_id.identity[0],
               sds_ptr->plmn_id.identity[1],
              sds_ptr->plmn_id.identity[2]);
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_3 ("cmss_update_lte_cell_info srv_status = %d, tac = %d, ss = %d",
              rpt_ptr->svc_status, rpt_ptr->camped_svc_info.tac, cm_ss);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* When svc_status is AVAILABLE, if the cell_id/RAT is different from
  ** from the last one, update ss_ptr and send SS event.
  */
  if (rpt_ptr->svc_status == LTE_RRC_SVC_STATUS_AVAILABLE)
  {
    CM_MSG_HIGH_1("cmss_update_lte_cell_info:is_hybr_gw_operational=%d",
                (int)ss_ptr->info.is_hybr_gw_operational);
    plmn_id = \
          cmss_convert_rrc_plmn_id_to_sys_plmn_id(rpt_ptr->camped_svc_info.selected_plmn);

    /* In SVLTE config, CM could receive service status info from NAS after
    ** receiving LTE RRC report. So update gw_cell_info on receiving cell id
    ** change from LTE RRC irrespective of the current service status.
    */
    #ifdef FEATURE_MMODE_DUAL_SIM
    if(cmph_is_msim())
    {
      asubs_id = INST_ID_TO_SYS_AS_ID(rpt_ptr->msg_hdr.inst_id);
    }
    #endif

    /* Determine cm_ss base on LTE rat and asubs_id */
    cm_ss = cmph_determine_ss_per_rat(asubs_id, SYS_SYS_MODE_LTE);

    if( cm_ss == CM_SS_HYBR_2)
    {
      if((ss_ptr->info.gw_cell_info.cell_id != rpt_ptr->camped_svc_info.cell_identity ) ||
         (ss_ptr->info.gw_cell_info.tac != rpt_ptr->camped_svc_info.tac) ||
         (ss_ptr->info.gw_cell_info.plmn_id.identity[0] !=  plmn_id.identity[0]) ||
         (ss_ptr->info.gw_cell_info.plmn_id.identity[1] !=  plmn_id.identity[1]) ||
         (ss_ptr->info.gw_cell_info.plmn_id.identity[2] !=  plmn_id.identity[2])
        )
      {

        CM_MSG_HIGH_3 ("Cell_info: old cell_id %d, new cell_id %d, div_duplex:%d",
                     ss_ptr->info.gw_cell_info.cell_id,
                     rpt_ptr->camped_svc_info.cell_identity, rpt_ptr->div_duplex);

        /* Update the downlink frequency information */
        ss_ptr->info.gw_cell_info.earfcn_dl = rpt_ptr->camped_svc_info.earfcn;

        ss_ptr->hybr_gw_div_duplex  =
          cmss_map_lte_rrc_div_duplex_to_sys_val(rpt_ptr->div_duplex);

        ss_ptr->info.gw_cell_info.cell_id = \
          rpt_ptr->camped_svc_info.cell_identity;

        ss_ptr->info.gw_cell_info.as_sys_mode = SYS_SYS_MODE_LTE;

        ss_ptr->info.gw_cell_info.tac = rpt_ptr->camped_svc_info.tac;

        ss_ptr->info.gw_cell_info.lac_id = CMSS_INVALID_LAC_INFO;

        ss_ptr->info.gw_cell_info.psc = rpt_ptr->camped_svc_info.phy_cell_id;

        ss_ptr->info.gw_cell_info.plmn_id = plmn_id;
        // should add gw_div_duplex if QMI starts to check.

        is_changed = TRUE;
      }


      if(ss_ptr->info.gw_cell_info.lte_cell_access_status !=\
         (sys_cell_access_status_e_type)rpt_ptr->camped_svc_info.cell_access_status)
      {
        CM_MSG_HIGH_2 ("LTE_cell_access_status: old status = %d, new status = %d",
                     ss_ptr->info.gw_cell_info.lte_cell_access_status,
                     rpt_ptr->camped_svc_info.cell_access_status);

        ss_ptr->info.gw_cell_info.lte_cell_access_status = \
          (sys_cell_access_status_e_type)rpt_ptr->camped_svc_info.cell_access_status;

        is_changed = TRUE;

      }
      if(is_changed)
      {
        cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );
      }
    }
    else if (cm_ss == CM_SS_HYBR_3) 
    {
      if((ss_ptr->info.gw3_cell_info.cell_id != rpt_ptr->camped_svc_info.cell_identity ) ||
         (ss_ptr->info.gw3_cell_info.tac != rpt_ptr->camped_svc_info.tac) ||
         (ss_ptr->info.gw3_cell_info.plmn_id.identity[0] !=  plmn_id.identity[0]) ||
         (ss_ptr->info.gw3_cell_info.plmn_id.identity[1] !=  plmn_id.identity[1]) ||
         (ss_ptr->info.gw3_cell_info.plmn_id.identity[2] !=  plmn_id.identity[2])
        )
      {

        CM_MSG_HIGH_3 ("Cell_info: old cell_id %d, new cell_id %d, div_duplex:%d",
                     ss_ptr->info.gw3_cell_info.cell_id,
                     rpt_ptr->camped_svc_info.cell_identity, rpt_ptr->div_duplex);

        /* Update the downlink frequency information */
        ss_ptr->info.gw3_cell_info.earfcn_dl = rpt_ptr->camped_svc_info.earfcn;

        ss_ptr->gw3_div_duplex  =
          cmss_map_lte_rrc_div_duplex_to_sys_val(rpt_ptr->div_duplex);

        ss_ptr->info.gw3_cell_info.cell_id = \
          rpt_ptr->camped_svc_info.cell_identity;

        ss_ptr->info.gw3_cell_info.as_sys_mode = SYS_SYS_MODE_LTE;

        ss_ptr->info.gw3_cell_info.tac = rpt_ptr->camped_svc_info.tac;

        ss_ptr->info.gw3_cell_info.lac_id = CMSS_INVALID_LAC_INFO;

        ss_ptr->info.gw3_cell_info.psc = rpt_ptr->camped_svc_info.phy_cell_id;

        ss_ptr->info.gw3_cell_info.plmn_id = plmn_id;
        // should add gw_div_duplex if QMI starts to check.

        is_changed = TRUE;
      }

      if(ss_ptr->info.gw3_cell_info.lte_cell_access_status !=\
         (sys_cell_access_status_e_type)rpt_ptr->camped_svc_info.cell_access_status)
      {
        CM_MSG_HIGH_2 ("LTE_cell_access_status: old status = %d, new status = %d",
                     ss_ptr->info.gw3_cell_info.lte_cell_access_status,
                     rpt_ptr->camped_svc_info.cell_access_status);

        ss_ptr->info.gw3_cell_info.lte_cell_access_status = \
          (sys_cell_access_status_e_type)rpt_ptr->camped_svc_info.cell_access_status;

        is_changed = TRUE;

      }
      if(is_changed)
      {
        cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_SRV_CHANGED );
      }
    }
    else
    {
      if((ss_ptr->info.cell_info.cell_id != rpt_ptr->camped_svc_info.cell_identity ) ||
         (ss_ptr->info.cell_info.tac!= rpt_ptr->camped_svc_info.tac) ||
         (ss_ptr->info.cell_info.plmn_id.identity[0] !=  plmn_id.identity[0]) ||
         (ss_ptr->info.cell_info.plmn_id.identity[1] !=  plmn_id.identity[1]) ||
         (ss_ptr->info.cell_info.plmn_id.identity[2] !=  plmn_id.identity[2])
        )
      {

        CM_MSG_HIGH_3 ("Cell_info: old cell_id %d, new cell_id %d, div_duplex:%d",
                     ss_ptr->info.cell_info.cell_id,
                     rpt_ptr->camped_svc_info.cell_identity, rpt_ptr->div_duplex);

        /* Update the downlink frequency information */
        ss_ptr->info.cell_info.earfcn_dl = rpt_ptr->camped_svc_info.earfcn;

        ss_ptr->main_div_duplex =
          cmss_map_lte_rrc_div_duplex_to_sys_val(rpt_ptr->div_duplex);

        ss_ptr->info.cell_info.cell_id = \
          rpt_ptr->camped_svc_info.cell_identity;

        ss_ptr->info.cell_info.as_sys_mode = SYS_SYS_MODE_LTE;

        ss_ptr->info.cell_info.tac = rpt_ptr->camped_svc_info.tac;

        ss_ptr->info.cell_info.lac_id = CMSS_INVALID_LAC_INFO;

        ss_ptr->info.cell_info.psc = rpt_ptr->camped_svc_info.phy_cell_id;

        ss_ptr->info.cell_info.plmn_id = plmn_id;

        is_changed = TRUE;

      }

      if(ss_ptr->info.cell_info.lte_cell_access_status !=\
         (sys_cell_access_status_e_type)rpt_ptr->camped_svc_info.cell_access_status)
      {
        CM_MSG_HIGH_2 ("LTE_cell_access_status: old status = %d, new status = %d",
                     ss_ptr->info.gw_cell_info.lte_cell_access_status,
                     rpt_ptr->camped_svc_info.cell_access_status);

        ss_ptr->info.cell_info.lte_cell_access_status = \
          (sys_cell_access_status_e_type)rpt_ptr->camped_svc_info.cell_access_status;

        is_changed = TRUE;

      }

      if(is_changed)
      {
        cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
      }

    }
  }

}

#endif /* FEATURE_CM_LTE */

/*===========================================================================

FUNCTION cmss_process_gan_info_rpt

DESCRIPTION
  This function receives gan info from GAN library to be sent out to the
  clients.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_process_gan_info_rpt
(
  const cm_rpt_type  *cm_rpt_ptr
    /* pointer to CM report received */
)
{

  SYS_ARG_NOT_USED(cm_rpt_ptr);

} /* cmss_process_gan_info_rpt */

/*===========================================================================

FUNCTION cmss_process_hspa_call_status_rpt

DESCRIPTION
  This function sends call specific indication on High speed techonology.
  This includes call in progress, call released on HSDPA, HSUPA.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_process_hspa_call_status_rpt
(
  const cm_rpt_type  *cm_rpt_ptr
    /* Pointer to cm report */
)
/*lint -esym(715,cm_rpt_ptr)*/
/*lint -esym(529,ss_ptr)*/
{

  #if defined(FEATURE_HSDPA) && defined(FEATURE_HSPA_CALL_STATUS_IND)

  cmss_s_type              *ss_ptr             = cmss_ptr();
    /* Pointer to serving system object.
    */

  const cm_hspa_call_status_ind_s_type  *hs_call_status_ind_ptr =
                          &cm_rpt_ptr->cmd.hspa_call_status_ind;

  cm_ss_e_type              ss                 = CM_SS_MAIN;
    /* Stack on which this info is recieved */

  cm_cell_srv_ind_s_type    *cell_srv_ind;
    /* Current cell info */

  sys_sys_mode_e_type       sys_mode;
    /* Sys mode of the SS */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_3("LL->CMSS: HS call reported %d subs id %d CM ss_ptr supp has HS service %d",
  hs_call_status_ind_ptr->hs_call_status_ind, hs_call_status_ind_ptr->as_id, ss_ptr->info.cell_srv_ind.hs_call_status);


  if ( !(BETWEEN (hs_call_status_ind_ptr->hs_call_status_ind, SYS_HS_IND_NONE,
                  SYS_HS_IND_MAX))
     )
  {
    CM_ERR_0 (" HSPA call status out of range");
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* get the stack info based on the subs id */
  ss  = cmph_determine_ss_per_rat(hs_call_status_ind_ptr->as_id, SYS_SYS_MODE_WCDMA);

  /* get the stack based ss info */
  if( ss == CM_SS_HYBR_2 )
  {
    cell_srv_ind = &ss_ptr->info.gw_cell_srv_ind;
    sys_mode     = ss_ptr->info.gw_sys_mode;
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if( ss == CM_SS_HYBR_3 )
  {
    cell_srv_ind = &ss_ptr->info.gw3_cell_srv_ind;
    sys_mode     = ss_ptr->info.gw3_sys_mode;
  }
  else
  #endif /* FEATURE_MMODE_TRIPLE_SIM */
  {
    cell_srv_ind = &ss_ptr->info.cell_srv_ind;
    sys_mode     = ss_ptr->info.sys_mode;
  }

  if (hs_call_status_ind_ptr->hs_call_status_ind != cell_srv_ind->hs_call_status)
  {
    cell_srv_ind->hs_call_status = hs_call_status_ind_ptr->hs_call_status_ind;

    if (sys_mode == SYS_SYS_MODE_WCDMA ||
        sys_mode == SYS_SYS_MODE_TDS)
    {
      cmss_event(ss, CM_SS_EVENT_SRV_CHANGED);
    }
  }
  #else /* of FEATURE_HSDPA */
  SYS_ARG_NOT_USED(cm_rpt_ptr);
  #endif /* FEATURE_HSDPA && FEATURE_HSPA_CALL_STATUS_IND */

} /* cmss_process_hspa_call_status_rpt () */
/*lint +esym(715,cm_rpt_ptr)*/
/*lint +esym(529,ss_ptr)*/

#endif /* FEATURE_WCDMA, FEATURE_GSM */


#if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))

/*===========================================================================

FUNCTION cmss_proc_data_avail_ok_to_orig

DESCRIPTION
   Process the data available request upon ok to orig from SD.


DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static  void  cmss_proc_data_avail_ok_to_orig
(
        const cmss_s_type              *ss_ptr,
           /* Pointer to a phone object */

        const cm_ok_to_orig_type       *ok_to_orig_ptr
           /* Pointer to the CM_SRV_IND_INFO_F report.
           */
)
{
  CM_ASSERT( ss_ptr != NULL );

  CM_ASSERT( ok_to_orig_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* PS Data Available Request to MM.
  ** If there is ps service, send the data available request to MM and
  ** update the ps data state.
  */
  if((ok_to_orig_ptr->ss == SD_SS_MAIN &&
      ( ss_ptr->ps_data_stt == CM_PS_DATA_STT_SRV_ACQ ) &&
      ( ok_to_orig_ptr->si_ok_to_orig.srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
        ok_to_orig_ptr->si_ok_to_orig.srv_domain == SYS_SRV_DOMAIN_CS_PS )
     )
     ||
     ( cmph_is_msim() &&
        ok_to_orig_ptr->ss == SD_SS_HYBR_2 &&
      ( ss_ptr->hybr_gw_ps_data_stt == CM_PS_DATA_STT_SRV_ACQ ) &&
      ( ok_to_orig_ptr->si_ok_to_orig.srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
        ok_to_orig_ptr->si_ok_to_orig.srv_domain == SYS_SRV_DOMAIN_CS_PS )
     )
     ||
     (  cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
        ok_to_orig_ptr->ss == SD_SS_HYBR_2 &&
      ( ss_ptr->ps_data_stt == CM_PS_DATA_STT_SRV_ACQ ) &&
      ( ok_to_orig_ptr->si_ok_to_orig.srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
        ok_to_orig_ptr->si_ok_to_orig.srv_domain == SYS_SRV_DOMAIN_CS_PS )
     )
     ||
     ( cmph_is_msim() &&
        ok_to_orig_ptr->ss == SD_SS_HYBR_3 &&
      ( ss_ptr->hybr_3_gw_ps_data_stt == CM_PS_DATA_STT_SRV_ACQ ) &&
      ( ok_to_orig_ptr->si_ok_to_orig.srv_domain == SYS_SRV_DOMAIN_PS_ONLY ||
        ok_to_orig_ptr->si_ok_to_orig.srv_domain == SYS_SRV_DOMAIN_CS_PS )
     )

    )
  {
    cmss_update_data_avail_stt( cmph_map_sd_ss_type_to_cm_ss_type(ok_to_orig_ptr->ss),
                                ok_to_orig_ptr->si_ok_to_orig.ps_data_suspend );
  }

}/* cmss_update_data_avail_state */
#endif /* FEATURE_PS_DORMANT_PWR_SAVE */

#ifdef FEATURE_CALL_THROTTLE
/*===========================================================================

FUNCTION cmss_is_hard_failure_throttle_reason

DESCRIPTION
  This function checks if the throttle reason given is a hard failure one.
  For such reasons, the system will be throttled for longer fixed durations
  or till a new system is acquired

DEPENDENCIES
  None.

RETURN VALUE
  TRUE for hard failures
  FALSE otherwise

SIDE EFFECTS
  None.
===========================================================================*/

static boolean cmss_is_hard_failure_throttle_reason(

  cm_ss_orig_thr_reasons_e_type    thr_reason
    /* The throttle reason
    */
)
{
  switch(thr_reason)
  {
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Auth failure on EHRPD system
    */
    case CM_SS_ORIG_THR_DS_PPP_AUTH_FAILURE_PERMANENT:
      return TRUE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:
      return FALSE;
  }
}

/*===========================================================================

FUNCTION cmss_orig_thr_tbl_entry_info_put

DESCRIPTION
  This function initializes the table entry information from the status

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  TRUE if the entry inserted into the table has a non zero throttle time.

SIDE EFFECTS
  None.
===========================================================================*/

static boolean cmss_orig_thr_tbl_entry_info_put(

  cmss_orig_thr_table_entry_s_type *tbl_entry_ptr,
    /* Pointer to the table entry
    */

  cm_ss_orig_thr_call_status_s_type *thr_call_status
    /* Information about the current call status
    */
)
{

  dword uptime = time_get_uptime_secs();
  cmph_s_type *ph_ptr = cmph_ptr();
  unsigned int r_value = 0;
  unsigned int accolc  = 0;

  SYS_ARG_NOT_CONST(thr_call_status);

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT( tbl_entry_ptr != NULL );
  CM_ASSERT( ph_ptr        != NULL );
  CM_ASSERT( thr_call_status != NULL );
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* Initialize the throttle entry
  */

  tbl_entry_ptr->idx                        = 1;
  tbl_entry_ptr->orig_call_info.call_type   = thr_call_status->call_type;
  tbl_entry_ptr->orig_call_info.sys_id      = thr_call_status->sys_id;
  tbl_entry_ptr->orig_call_info.mode_info   = thr_call_status->mode_info;
  tbl_entry_ptr->orig_call_info.call_status = thr_call_status->call_status;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If the throttle reason is a hard failure, do fixed time throttling
  */
  if(cmss_is_hard_failure_throttle_reason(thr_call_status->call_status))
  {
    CM_MSG_MED_0("Hard failure thr");

    /* Depending on the access overload class, add a random amount of time. This
    ** is to avoid overloading the network once the throttling timer expires
    */

   /*Get r_value */
   if ((ph_ptr->accolc < 10) && (ph_ptr->accolc != 0))
   {
     accolc = (unsigned int)(ph_ptr->accolc * CMSS_ORIG_THR_RND_INT *1000);
     r_value = ROUNDOFF(accolc, 1000);
   }
   else
   {
     r_value = 0;
   }
   tbl_entry_ptr->thr_uptime    = uptime + cmss_ptr()->hard_fail_thr_period + r_value;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If the throttle reason is not a hard failure, follow telescopic throttling
  */
  else
  {
    if( (int) ph_ptr->accolc < 10)
    {
       /* If the time is not zero then randomize it with access overload class  */
      if (thr_time[1] != 0)
      {
        /*Get r_value */
        accolc = (unsigned int)(ph_ptr->accolc * CMSS_ORIG_THR_RND_INT *1000);
        r_value = ROUNDOFF(accolc, 1000);
      }
      else
      {
        r_value = 0;
      }

      tbl_entry_ptr->thr_uptime    = uptime + thr_time[1] + r_value;
    }
    else
    {
      tbl_entry_ptr->thr_uptime    = uptime + thr_time[1];
    }
  } // if (cmss_is_hard_failure_throttle_reason())
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_MED_3( "Orig. Thr. Tbl. uptime %d curr uptime %d failure %d",
                                         tbl_entry_ptr->thr_uptime,
                                                            uptime,
                                     thr_call_status->call_status );
  return CM_BOOLEAN(tbl_entry_ptr->thr_uptime > uptime) ;

} /* cmss_orig_thr_tbl_entry_info_put */



/*===========================================================================

FUNCTION cmss_orig_thr_proc_update_tbl

DESCRIPTION
  This function should be called to update the origination throttle table,
  to clear one entry of the origination table

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  True if throttling
  False otherwise.

SIDE EFFECTS
  None.

===========================================================================*/
static boolean cmss_orig_thr_proc_update_tbl(
  const cm_ss_cmd_s_type     *ss_cmd_ptr
    /* Pointer to the SS command
    */
)
{
  /* Pointer to serving system object.
  */
  cmss_s_type              *ss_ptr               = cmss_ptr();
  boolean                   curr_thr_status      = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT(ss_cmd_ptr != NULL);
  CM_ASSERT(ss_ptr     != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch(ss_cmd_ptr->info.orig_thr_act)
  {
    case CM_SS_ORIG_THR_RESET_TBL:
      curr_thr_status = CM_BOOLEAN (ss_ptr->info.main_thr_status.ss_thr_status ||
                             ss_ptr->info.hdr_thr_status.ss_thr_status );
      cmss_orig_thr_table_reset(ss_ptr->cmss_orig_thr_tbl_ptr);
      cmss_event( CM_SS_MAIN, CM_SS_EVENT_ORIG_THR_TBL_UPDATE);
      if( curr_thr_status )
      {
        cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED);
      }
      return( FALSE );

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_SS_ORIG_THR_UPDATE_SS:

    /* We are ignoring NID, so replace it with the wild card nid
    */
    {
      cm_ss_orig_thr_call_status_s_type call_info = ss_cmd_ptr->info.call_info;
      if( call_info.sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
      {
        call_info.sys_id.id.is95.nid  = SD_WILDCARD_NID;
      }
      return( cmss_orig_thr_update_tbl_entry_with_call_status(
                                              ss_ptr->cmss_orig_thr_tbl_ptr,
                                              &call_info ));
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    case CM_SS_ORIG_THR_UPDATE_CURR_SS:
    {
      cm_ss_orig_thr_call_status_s_type call_info =
                                                  ss_cmd_ptr->info.call_info;

      call_info.mode_info.cdma_info = ss_ptr->info.mode_info.cdma_info;

      /* Figure out which sys_id to use
      */
      switch( ss_cmd_ptr->info.mode )
      {
        case SYS_SYS_MODE_CDMA:
          call_info.sys_id = ss_ptr->info.sys_id;
          call_info.mode_info.cdma_info.band_class = ss_ptr->info.active_band;
          break;

        case SYS_SYS_MODE_HDR:


          if( ss_ptr->info.hdr_hybrid )
          {
            call_info.sys_id = ss_ptr->info.hdr_sys_id;
            call_info.mode_info.cdma_info.band_class = ss_ptr->info.hybrid_active_band;
          }
          else
          {
            call_info.sys_id = ss_ptr->info.sys_id;
            call_info.mode_info.cdma_info.band_class = ss_ptr->info.active_band;
          }

          break;

        default:
           CM_ERR_1(" Wrong sys mode %d for throttle",ss_cmd_ptr->info.mode);
           return FALSE;
        } /* switch( mode ) */

        /* We are ignoring NID, so replace it with the wild card nid
        */

        if( call_info.sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
        {
          call_info.sys_id.id.is95.nid  = SD_WILDCARD_NID;
        }

        return ( cmss_orig_thr_update_tbl_entry_with_call_status(
                                              ss_ptr->cmss_orig_thr_tbl_ptr,
                                              &call_info ));

    } /* case CM_SS_ORIG_THR_UPDATE_CURR_SS */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    default:
      CM_ERR_1(" Unknown throttle action %d ",ss_cmd_ptr->info.orig_thr_act);
      return FALSE;

  }/* switch(ss_cmd_ptr->info.orig_thr_act) */

}/* cmss_orig_thr_proc_update_tbl */

#endif /* FEATURE_CALL_THROTTLE */

#ifdef FEATURE_CM_SS_MEAS
#error code not present
#endif /* FEATURE_CM_SS_MEAS */

/*===========================================================================

FUNCTION cmss_send_ims_emerg_capability

DESCRIPTION
  Send the IMS emergency capability to LTE RRC

DEPENDENCIES

RETURN VALUE


SIDE EFFECTS
  none

===========================================================================*/

static void cmss_send_ims_emerg_capability(boolean ims_emg_supp)
{

  cm_ims_emerg_cap_ind_s_type  *ind_primitive = NULL;
  static boolean prev_sent_ims_cap = FALSE;

  /* skip sending ims emerg cap */
  if(prev_sent_ims_cap == ims_emg_supp)
  {
    return;
  }

  ind_primitive = (cm_ims_emerg_cap_ind_s_type *)cm_mem_malloc
                     (sizeof(cm_ims_emerg_cap_ind_s_type));

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ind_primitive->ims_emergency_supp = ims_emg_supp;
  ind_primitive->msg_hdr.inst_id= SYS_AS_ID_TO_INST_ID(cmph_get_sub_with_lte_cap());

  (void) cm_msgr_send( MM_CM_IMS_EMERG_CAP_SUPP_IND, MSGR_MM_CM,
      (msgr_hdr_s*)ind_primitive, sizeof(cm_ims_emerg_cap_ind_s_type) );

  /* Free allocated client message buffer */
  cm_mem_free (ind_primitive);

  prev_sent_ims_cap = ims_emg_supp;


}

/*===========================================================================

FUNCTION cmss_inform_ipapp_reg_status

DESCRIPTION
  Sends SS event to clients reporting ip app registration status.


DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_inform_ipapp_reg_status
(

  const  cm_ip_app_reg_status_type        *app_reg_status_ptr
     /* App registration status */
)
{
  cmss_s_type              *ss_ptr               = cmss_ptr();
    /* Pointer to serving system object */
  boolean                  is_ims_voice_avail    = FALSE;
    /* Indicates the availability of IMS voice */
  uint8                    cap_index=0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ipapp reg status */
  ss_ptr->info.ipapp_info.reg_status     = app_reg_status_ptr->ipapp_reg_status;

  for(cap_index=0;cap_index<CMIPAPP_CAP_ARR_MAX;cap_index++)
  {
  /* Call type's that app can service */
    ss_ptr->info.ipapp_info.call_type_mask[cap_index] = app_reg_status_ptr->call_type_mask[cap_index];
    /* The mode preference over which SIP is registered */
    ss_ptr->info.ipapp_info.sys_mode[cap_index]       = app_reg_status_ptr->sys_mode[cap_index];
  }

  /* cause for registration, de-registration */
  ss_ptr->info.ipapp_info.cause          = (int)app_reg_status_ptr->ipapp_cause;

  /* Warning info tied to registration */
  ss_ptr->info.ipapp_info.warn_info      = app_reg_status_ptr->warn_info;

  if(app_reg_status_ptr->ipapp_reg_status == CM_IPAPP_REG_STATUS_REGISTERED ||
     app_reg_status_ptr->ipapp_reg_status == CM_IPAPP_REG_STATUS_DEREGISTERED)
  {
    /* Update the DDTM status.
    */
    cmph_update_ddtm_status( cmph_ptr() );
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  for(cap_index=0;cap_index<CMIPAPP_CAP_ARR_MAX;cap_index++)
  {
    if ((app_reg_status_ptr->call_type_mask[cap_index] & CM_CALL_TYPE_VOICE_MASK) &&
        (app_reg_status_ptr->sys_mode[cap_index] & SYS_SYS_MODE_MASK_LTE))
  {
    if (app_reg_status_ptr->ipapp_reg_status == CM_IPAPP_REG_STATUS_REGISTERED)
    {
      is_ims_voice_avail = TRUE;
    }

    (void)cmss_send_mm_ims_reg_info(is_ims_voice_avail);
  }

    if((app_reg_status_ptr->call_type_mask[cap_index] & CM_CALL_TYPE_EMERG_MASK) &&
       (app_reg_status_ptr->sys_mode[cap_index] & SYS_SYS_MODE_MASK_LTE) &&
     (app_reg_status_ptr->ipapp_reg_status == CM_IPAPP_REG_STATUS_REGISTERED))
  {
    (void)cmss_send_ims_emerg_capability(TRUE);
  }
  else
  {
    (void)cmss_send_ims_emerg_capability(FALSE);
  }
  }

  cmss_event ( CM_SS_MAIN, CM_SS_EVENT_IPAPP_REG_STATUS);

} /* cmss_inform_ipapp_reg_status () */


#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
/*===========================================================================

FUNCTION cmss_report_hdr_pkt_err_rate

DESCRIPTION
  This function receives hdr packet error rate from HDR CP
  which needs to be sent out to clients.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_report_hdr_pkt_err_rate
(
  const cm_mc_rpt_type  *cm_rpt_ptr
    /* pointer to CM report received */
)
{
    /* Pointer to serving system object.
    */
  cmss_s_type          *ss_ptr       = cmss_ptr();

    /* Current sys mode
    */
  sys_sys_mode_e_type   sys_mode     = ss_ptr->info.sys_mode;

  ss_ptr->info.signal_strength_changed_fields  = 0;

  if( cm_rpt_ptr != NULL )
  {
    CM_MSG_MED_3("HDR PER indication old PER= %d new PER=%d, current sys mode = %d",
                  ss_ptr->info.hdr_packet_err_rate,
                  cm_rpt_ptr->hdr_per.hdr_per_info,
                  sys_mode);

    if(sys_mode == SYS_SYS_MODE_HDR)
    {
        /* copying new hdr_per value from HDR report */
      ss_ptr->info.hdr_packet_err_rate = cm_rpt_ptr->hdr_per.hdr_per_info;

      cmss_event( CM_SS_MAIN, CM_SS_EVENT_RSSI );
    }
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Report HDR RSSI, if changed
    */
    #ifdef FEATURE_HDR_HYBRID
    if ( cmss_is_hybr_status_on() )
    {
      CM_MSG_MED_1 ("HDR Hybrid mode with %d hdr_srv_status",
                                         ss_ptr->info.hdr_srv_status);
      switch ( ss_ptr->info.hdr_srv_status )
      {
        case SYS_SRV_STATUS_NO_SRV:
        case SYS_SRV_STATUS_PWR_SAVE:
          ss_ptr->info.hdr_packet_err_rate = CMSS_HDR_PER_INVALID;
          cmss_event( CM_SS_MAIN, CM_SS_EVENT_HDR_RSSI );
          break;

        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        case SYS_SRV_STATUS_LIMITED:
        case SYS_SRV_STATUS_SRV:
          ss_ptr->info.hdr_packet_err_rate = cm_rpt_ptr->hdr_per.hdr_per_info;
          cmss_event( CM_SS_MAIN, CM_SS_EVENT_HDR_RSSI );
          break;
        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
        default:
          break;
        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      }
    } /* if hybr on */
    #endif /*  #ifdef FEATURE_HDR_HYBRID */
  } /* cm_rpt_ptr != NULL */
}


/*===========================================================================

FUNCTION cmss_report_frame_err_rate

DESCRIPTION
  This function receives frame error rate from 1x CP
  which needs to be sent out to clients.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_report_frame_err_rate
(
  const cm_mc_rpt_type  *cm_rpt_ptr
    /* pointer to CM report received */
)
{
    /* Pointer to serving system object.
    */
  cmss_s_type          *ss_ptr       = cmss_ptr();

  ss_ptr->info.signal_strength_changed_fields  = 0;

  if( cm_rpt_ptr != NULL )
  {
    CM_MSG_MED_2 ("FER indication old FER= %d new FER=%d",
                 ss_ptr->info.frame_err_rate, cm_rpt_ptr->fer.fer_info);

      /* copying new fer value from 1xCP report */
    ss_ptr->info.frame_err_rate = cm_rpt_ptr->fer.fer_info;

    cmss_event( CM_SS_MAIN, CM_SS_EVENT_RSSI );
  }
}
#endif /* #if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)) */


/**--------------------------------------------------------------------------
** Functions - external
** --------------------------------------------------------------------------
*/


/*===========================================================================

FUNCTION cmss_ptr

DESCRIPTION
  Return a pointer to the one and only serving system object.

  The serving system object is responsible for:
  1. Processing MC serving system related notifications.
  2. Notifying the client list of serving system events.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
cmss_s_type  *cmss_ptr( void )
{
  static cmss_s_type cmss;       /* The one and only serving system object */

  return &cmss;

} /* cmss_ptr() */

/*===========================================================================

FUNCTION cmss_intl_srv_info

DESCRIPTION
  Return a pointer to current serving system info

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
sd_si_info_s_type  *cmss_intl_srv_info_ptr( cm_ss_e_type ss)
{
    /* Internal SRV information  */
  static cmss_intl_srv_info_s_type cmss_intl_srv_info;

  switch(ss)
  {
    case CM_SS_MAIN:
      return &cmss_intl_srv_info.main_si_info;
      break;

    case CM_SS_HYBR_1:
      return &cmss_intl_srv_info.hybr_si_info;
      break;

    case CM_SS_HYBR_2:
      return &cmss_intl_srv_info.hybr2_si_info;
      break;

    case CM_SS_HYBR_3:
      return &cmss_intl_srv_info.hybr3_si_info;
      break;


    default:
      CM_ERR_0("Invalis SS");
  }

  return NULL;
} /* cmss_intl_srv_info() */

/*===========================================================================

FUNCTION cmss_nv_refresh

DESCRIPTION
  Reading NV items in serving system object.


DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_nv_refresh(

   uint8             refresh_subs_mask
    /* Subs mask whose NVs need to be refreshed
    */

)
{

  cmss_s_type    *ss_ptr  =  cmss_ptr();
      /* Point at serving system object to be initialized */

  cmss_sid_mcc_assoc_tbl_s_type *sid_mcc_assoc_tbl_ptr = NULL;
      /* Get sid to country association ptr */

  int loop = 0;
      /* For loop interator */

  nv_item_type* nv_item_ptr = NULL;

  /* All ss NVs are for as id 1 as of now . So if there is no change
     to as id 1, no need to proceed */
  if (!(refresh_subs_mask & SYS_MODEM_AS_ID_1_MASK) )
  {
    CM_MSG_MED_0("MCFGrefresh: no CMSS update");
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*                       READ NV ITEMS                                   */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Copy pointer to sid-mcc assoc table */
  sid_mcc_assoc_tbl_ptr = cmss_get_sid_mcc_assoc_ptr();

  nv_item_ptr = (nv_item_type* )cm_mem_malloc(sizeof(cmnv_data_s_type));

  cmss_update_home_mcc();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmnv_read_wait (NV_USR_SID_TO_MCC_ASSOC_TBL_I, nv_item_ptr);

  /* Check the length for validity */
  if (!BETWEEN(nv_item_ptr->usr_sid_to_mcc_assoc_tbl.tbl_len, 0, NV_SID_TO_MCC_TBL_LEN))
  {
    sid_mcc_assoc_tbl_ptr->sid_mcc_tbl_len = 0;
  }
  else
  {
    sid_mcc_assoc_tbl_ptr->sid_mcc_tbl_len =
                            nv_item_ptr->usr_sid_to_mcc_assoc_tbl.tbl_len;
  }

  /* Copy sid to mcc table from NV*/
  for (loop=0;loop<sid_mcc_assoc_tbl_ptr->sid_mcc_tbl_len;++loop)
  {
    /* Copy sid 0-15th bits */
    sid_mcc_assoc_tbl_ptr->sid_mcc_tbl[loop].sid =
         ((uint16)nv_item_ptr->usr_sid_to_mcc_assoc_tbl.sid_to_mcc_list[loop]) & 0xFFFF;

    /* Copy country code 16-31 bits */
    sid_mcc_assoc_tbl_ptr->sid_mcc_tbl[loop].country_code =
       ((uint16)(nv_item_ptr->usr_sid_to_mcc_assoc_tbl.sid_to_mcc_list[loop] >> 16)) & 0xFFFF;

  }


  CM_MSG_HIGH_3 (" sid to mcc tbl len = %d. first entry sid %d mcc %d",
  				 sid_mcc_assoc_tbl_ptr->sid_mcc_tbl_len,
                 ((uint16)nv_item_ptr->usr_sid_to_mcc_assoc_tbl.sid_to_mcc_list[0]) & 0xFFFF,
                 ((uint16)(nv_item_ptr->usr_sid_to_mcc_assoc_tbl.sid_to_mcc_list[0] >> 16)) & 0xFFFF);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmnv_read_wait (NV_HS_BASED_PLUS_DIAL_SETTING_I, nv_item_ptr);

  ss_ptr->info.plus_dial_setting =
    (cm_hs_based_plus_dial_e_type) nv_item_ptr->hs_based_plus_dial_setting;


  CM_MSG_HIGH_1 ("plus dial setting = %d", nv_item_ptr->hs_based_plus_dial_setting);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #if defined FEATURE_CALL_THROTTLE && defined FEATURE_EHRPD

  cmnv_read_wait (NV_HARD_FAIL_THR_TIME_I, nv_item_ptr);
  ss_ptr->hard_fail_thr_period = (dword) nv_item_ptr->hard_fail_thr_time;

  CM_MSG_MED_1 ("hard fail thr period = %d", nv_item_ptr->hard_fail_thr_time);
  #endif

  cm_mem_free(nv_item_ptr);

  #ifdef FEATURE_CALL_THROTTLE
  {
    dword call_thr_num;
    dword call_thr_timer;
    int32 size_to_read = sizeof(dword);
    unsigned int i;

    /* Make sure thr_time is deallocated first if its not NULL, 
    ** before allocating new memory for it 
    ** Condition : This should be MCFG refresh on sub1, thus refrsh_subs_mask 
    ** should not have all AS_ID mask ( set during normal power up, this check
    ** is primarily needed for UTs).Also, refresh_subs_mask should be set to 
    ** AS_ID_1_MASK 
    */
    if(((refresh_subs_mask & SYS_MODEM_AS_ID_1_MASK) 
          && (refresh_subs_mask != SYS_MODEM_AS_ID_ALL_ACTIVE_MASK))
        && thr_time != NULL)
    {
      cm_mem_free(thr_time);
      thr_time = NULL;
    } 
   
    /* read JCDMA throttle parameters from EFS */

    if ( (cmefs_read ( CMEFS_JCDMA_CALL_THROTTLE_NUM,
                        (byte*)&call_thr_num,
                        &size_to_read)) &&
        (cmefs_read ( CMEFS_JCDMA_CALL_THROTTLE_TIME,
                        (byte*)&call_thr_timer,
                        &size_to_read)))
    {
      /* range check for call throttle number of timer, if not valid use default
      */
      if(!INRANGE(call_thr_num,1,JCDMA_CALL_THROT_NUM_DEFAULT))
      {
        call_thr_num = JCDMA_CALL_THROT_NUM_DEFAULT;
      }

      /* range check for call throttle timer, if not valid use default
      */
      if(!INRANGE(call_thr_timer,1,JCDMA_CALL_THROT_TIMER_DEFAULT))
      {
        call_thr_timer = JCDMA_CALL_THROT_TIMER_DEFAULT;
      }

      /* allocate and initialize thr_time obj
      */
      thr_time = (dword *)cm_mem_malloc(call_thr_num*sizeof(dword));

      for(i=0;i<(call_thr_num-1);i++)
      {
        thr_time[i] = 0;
      }

      thr_time[call_thr_num-1] = call_thr_timer;

      cmss_orig_thr_max_timer = call_thr_num;

      CM_MSG_HIGH_1("Use JCDMA call throttle parameter, max_timer_index=%d",
                  cmss_orig_thr_max_timer);

    }
    /* If JCDMA throttle parameters not configured use default for vzw*/
    else
    {
       thr_time = (dword *)cm_mem_malloc((CMSS_ORIG_THR_MAX_TIMER_INDEX_DFT)*sizeof(dword));
       memscpy( thr_time, ((CMSS_ORIG_THR_MAX_TIMER_INDEX_DFT)*sizeof(dword)),
                thr_time_dft, CMSS_ORIG_THR_MAX_TIMER_INDEX_DFT*sizeof(dword) );

       cmss_orig_thr_max_timer = CMSS_ORIG_THR_MAX_TIMER_INDEX_DFT;
       CM_MSG_HIGH_1("Use default call throttle parameter, max_timer_index=%d",
                   cmss_orig_thr_max_timer);
    }
  }
  #endif /*FEATURE_CALL_THROTTLE*/

  #if defined(FEATURE_CM_LTE)
  {
    int32 size_of_idm_timer_value_to_read = sizeof(dword);
    if (cmefs_read ( CMEFS_IDM_TIMER_VALUE,
                     (byte*)&(ss_ptr->idm_timer_value),
                     &size_of_idm_timer_value_to_read))
    {
      CM_MSG_MED_1("Read IDM timer value %d",ss_ptr->idm_timer_value);
    }
    else
    {
      ss_ptr->idm_timer_value = CMSS_IDM_HANDDOWN_TIME_DEFAULT;
      CM_MSG_MED_1("EFS read error. IDM timer default value %d",
                 ss_ptr->idm_timer_value);
    }

    if(cmefs_get(CMEFS_LTE_DO_IRAT_DURATION,
                  (byte *)&cdma_srv_lte_do_redir_uptimer,
                  sizeof(cdma_srv_lte_do_redir_uptimer),
                  SYS_MODEM_AS_ID_1)
      )
    {
      CM_MSG_HIGH_1("LTE DO redir duration %d",cdma_srv_lte_do_redir_uptimer);
    }
    else{
      cdma_srv_lte_do_redir_uptimer = CMSS_LTE_DO_IRAT_DURATION;
      CM_MSG_HIGH_0("Default LTE DO redir duration set");
    }
  }
  #endif /* FEATURE_CM_LTE */

  /*
  ** Read NV/EFS for RAT-based service indication hold timers.
  */
  cmss_read_rat_srv_ind_uptimers();

  /*
  ** If RAT-based service indication hold timers are not available,
  ** set default rat based service indication hold timers.
  */
  if (!cmss_rat_srv_ind_uptimers.is_valid)
  {
    cmss_set_default_rat_srv_ind_uptimers();
  }
} /* cmss_nv_refresh() */


/*===========================================================================

FUNCTION cmss_init

DESCRIPTION
  Initializing the serving system object.

  This function must be called before the serving system object
  is being used, in any way, place, or form.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_init( void )
{

  cmss_s_type    *ss_ptr  =  cmss_ptr();
      /* Point at serving system object to be initialized */

  boolean disable_global_mode = FALSE;
  uint8   local_efs_read_timer = 0;
  int32   efs_item_size = sizeof(boolean);

  #if (defined(FEATURE_GSM) && defined(FEATURE_GSM_RR_CELL_CALLBACK))
  boolean               rr_cb_reg_status = FALSE;
  #endif
 
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );

  /* Verify object was not already initialized.
  ** and then mark object as initialized.
  */
  CM_ASSERT( ! CM_INIT_CHECK(ss_ptr->init_mask) );
  CM_INIT_MARK( ss_ptr->init_mask );


  #ifdef  FEATURE_CALL_THROTTLE
  /* Get the pointer to the cmss_orig_throttle_table_ptr
  */
  ss_ptr->cmss_orig_thr_tbl_ptr = cmss_orig_thr_tbl_init();
  #endif  /* FEATURE_CALL_THROTTLE */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Initialize SS object
  */
  cmss_reset();

  // Initialize internal service info object
  cmss_intl_srv_info_reset(SD_SS_MAIN);
  cmss_intl_srv_info_reset(SD_SS_HYBR_1);
  cmss_intl_srv_info_reset(SD_SS_HYBR_2);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*                       READ NV ITEMS                                   */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  cmss_nv_refresh(SYS_MODEM_AS_ID_ALL_ACTIVE_MASK);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*                       REGISTER FOR CALLBACKS                          */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #if (defined(FEATURE_GSM) && defined(FEATURE_GSM_RR_CELL_CALLBACK))
  /* Register cm_cell_info_rr_cb callback function with RR */
  #ifdef FEATURE_CM_NEW_RR_CELL_INFO_INTERFACE
  /*lint -e{611} */
    #ifdef FEATURE_MMODE_DUAL_SIM
      rr_cb_reg_status = geran_multisim_eng_mode_register_callback( ENG_MODE_SCELL_INFO ,  (void*)cm_cell_info_rr_cb
                          , SYS_MODEM_AS_ID_1);

      rr_cb_reg_status = geran_multisim_eng_mode_register_callback( ENG_MODE_SCELL_INFO ,  (void*)cm_hybr_2_cell_info_rr_cb
                          , SYS_MODEM_AS_ID_2);

      #ifdef FEATURE_MMODE_TRIPLE_SIM
        rr_cb_reg_status = geran_multisim_eng_mode_register_callback( ENG_MODE_SCELL_INFO ,  (void*)cm_hybr_3_cell_info_rr_cb
                          , SYS_MODEM_AS_ID_3);
      #endif

    #else
      rr_cb_reg_status =
      geran_eng_mode_register_callback(ENG_MODE_SCELL_INFO, (void*)cm_cell_info_rr_cb);
    #endif

  #else
  /* When Dual Standby is enabled, register callbacks per subscription
  */
  #ifdef FEATURE_MMODE_DUAL_SIM
  rr_cb_reg_status = rr_ds_register_cell_change_ind_cb(SYS_MODEM_AS_ID_1,
                                                         cm_cell_info_rr_cb);

  rr_cb_reg_status = rr_ds_register_cell_change_ind_cb(SYS_MODEM_AS_ID_2,
                                                         cm_hybr_2_cell_info_rr_cb);

  #ifdef FEATURE_MMODE_TRIPLE_SIM
  rr_cb_reg_status = rr_ds_register_cell_change_ind_cb(SYS_MODEM_AS_ID_3,
                                                         cm_hybr_3_cell_info_rr_cb);
  #endif
  #else
  rr_cb_reg_status = rr_register_cell_change_ind_cb(cm_cell_info_rr_cb);
  #endif
  #endif /* FEATURE_CM_NEW_RR_CELL_INFO_INTERFACE */
  if(rr_cb_reg_status)
  {
    CM_MSG_HIGH_0("Registered with RR for cell info change notification");
  }
  else
  {
    CM_ERR_0("Cell_info callback function not registered with RR");
  }
  #endif /* FEATURE_GSM && FEATURE_GSM_RR_CELL_CALLBACK */

  #if (defined(FEATURE_WCDMA) && !defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH))
  /* Register cm_cell_info_rrc_cb callback function with RRC */
  #ifdef FEATURE_SEGMENT_LOADING
  if(pi_mmode_wcdma == NULL)
  {
    CM_ERR_0("pi_mmode_wcdma is NULL");
  }
  else
  {     
    if(IWCDMA_rrc_register_serving_cell_change_ind_cb(pi_mmode_wcdma,
                                                      cm_cell_info_rrc_cb))
  #else
  {
    if(rrc_register_serving_cell_change_ind_cb(i,cm_cell_info_rrc_cb))
  #endif /* FEATURE_SEGMENT_LOADING */
    {
      CM_MSG_HIGH_0("Registered with RRC for cell info change notification");
    }
    else
    {
      CM_ERR_0( "Cell_info callback function not registered with RRC");
    }
  }
  #endif /* FEATURE_WCDMA && !FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH */

  #if defined(FEATURE_TDSCDMA)
  /* Register cm_cell_info_rrc_cb callback function with TDS RRC */
  #ifdef FEATURE_SEGMENT_LOADING
  if(pi_mmode_tdscdma == NULL)
  {
    CM_ERR_0("pi_mmode_tdscdma is NULL");
  }
  else
  {
    if(ITDSCDMA_tdsrrc_register_serving_cell_change_ind_cb(pi_mmode_tdscdma,
            cm_cell_info_tdsrrc_cb))
  #else
  {
    if(tdsrrc_register_serving_cell_change_ind_cb(cm_cell_info_tdsrrc_cb))
  #endif
    {
      CM_MSG_HIGH_0("Registered with TDS RRC for cell info change notification");
    }
    else
    {
      CM_ERR_0( "Cell_info callback function not registered with TDS RRC");
    }
  }
  #endif

  /*
  ** Start the RSSI update timer.
  */
  (void) cmtask_rssi_timer_start( CM_RSSI_TIME );

  #ifdef CM_GW_SUPPORTED
  (void) rex_set_timer( &cm_gwl_rssi_timer, CM_GWL_RSSI_TIME );
   CM_MSG_HIGH_1("rex_set_timer(%d)", CM_GWL_RSSI_TIME);
  #endif

  /*
  ** Initialize the Modem Reset timer.
  */
  #if 0

  if( ss_ptr->enable_modem_reset == TRUE)
  {
    cmss_modem_reset_timer_init();
  }
  #endif

  /* Read EFS file to determine whether moving to global mode 
  ** is disabled when CM receives full service lost
  */
  if(cmefs_read(CMEFS_DISABLE_GLOBAL_MODE,
                (byte*)&disable_global_mode,
                &efs_item_size)
     )
  {
    disable_global_mode = (boolean)disable_global_mode;
    
    if(disable_global_mode > TRUE ||
       disable_global_mode < FALSE)
    {
      ss_ptr->disable_global_mode = FALSE;
      CM_MSG_HIGH_2 ("EFS: disable_global_mode invalid value %d, default to %d",
                    disable_global_mode, ss_ptr->disable_global_mode);
    }
    else
    {
      ss_ptr->disable_global_mode = disable_global_mode;
      CM_MSG_HIGH_1 ("EFS read succ. disable_global_mode = %d",
                    ss_ptr->disable_global_mode);
    }
  }
  else
  {
    ss_ptr->disable_global_mode = FALSE;
    CM_ERR_1 ("Failed to read /nv/item_files/modem/mmode/disable_global_mode, default to %d",
            ss_ptr->disable_global_mode);
  }

  /* Read the Timer value for holding the is_operational flag on Hybrid2 stk */
  efs_item_size = sizeof(ss_ptr->hold_hy2_oper_flag_timer_value);
  if(cmefs_read(CMEFS_HOLD_HY2_OPER_FLAG_TIMER,
                (byte*)&local_efs_read_timer,
                &efs_item_size))
  {
    ss_ptr->hold_hy2_oper_flag_timer_value = local_efs_read_timer;
    CM_MSG_HIGH_1 ("EFS read succ. hold_hy2_oper_timer = %d",
                                                ss_ptr->hold_hy2_oper_flag_timer_value);
  }
  else
  {
    ss_ptr->hold_hy2_oper_flag_timer_value = 2; /* enabled by default. */
    CM_MSG_HIGH_0("Failed to read /nv/item_files/modem/mmode/hold_hy2_oper_timer disabling the feature");
  }

  ss_ptr->hold_hy2_oper_flag_uptime = CMSS_NO_SRV_UPTIME_NONE;  
} /* cmss_init() */

/*===========================================================================
FUNCTION cmss_report_raw_3gpp_service

DESCRIPTION
  This function report original 3gpp service status from NAS to IMS without delay

DEPENDENCIES

RETURNS
  none

SIDE EFFECTS
  none

===========================================================================*/

static void cmss_report_raw_3gpp_service
( 
  sys_srv_status_e_type      srv_status,
  sys_srv_domain_e_type      srv_domain,
  sys_sys_mode_e_type        rat,
  sd_ss_e_type               ss
)
{
  cm_3gpp_service_status_s_type   service_status_msg;
  sys_modem_as_id_e_type   as_id    = cmph_map_cm_ss_to_subs((cm_ss_e_type)ss) ;

  memset(&service_status_msg, 0, sizeof(cm_3gpp_service_status_s_type));
  service_status_msg.rat = rat;
  service_status_msg.srv_domain = srv_domain;
  service_status_msg.srv_status = srv_status;
  service_status_msg.msg_hdr.inst_id= SYS_AS_ID_TO_INST_ID(as_id);

  CM_MSG_HIGH_3("cmss_report_raw_3gpp_service: rat=%d, status=%d, srv_dom=%d",rat, srv_status, srv_domain);
  (void) cm_msgr_send( MM_CM_3GPP_SRV_IND, MSGR_MM_CM,
                     (msgr_hdr_s*)&service_status_msg, sizeof(cm_3gpp_service_status_s_type) );

  return;
}


/*===========================================================================

  FUNCTION cmss_sd_rpt_proc

  DESCRIPTION
    Process reports from System Determination.


  DEPENDENCIES
    Serving system object must have already been initialized with
    cmss_init().

  RETURN VALUE
    none

  SIDE EFFECTS
    none

===========================================================================*/
void cmss_sd_rpt_proc(

  const cm_hdr_type   *rpt_ptr
    /* Pointer to SD report */
)
{

  /*lint -e{826} */
  const cm_sd_rpt_u_type  *sd_rpt_ptr = (cm_sd_rpt_u_type *) rpt_ptr;
    /* Pointer to SD report */

  cmss_s_type                   *ss_ptr = cmss_ptr();
      /* Point at serving system object */

  sys_srv_status_e_type         prev_srv_status_ss = SYS_SRV_STATUS_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( sd_rpt_ptr != NULL );
  CM_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* This is a MC notification, so:
  ** 1. Updating appropriate serving system object fields.
  ** 2. Notifying clients of event.
  */
  switch( sd_rpt_ptr->hdr.cmd )
  {
    /* Service Indicators information is changed.
    */
    case CM_SRV_IND_INFO_F:
      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_SRV_IND_INFO_F, ((void*)&(sd_rpt_ptr->srv_ind_info)));
      #endif
      CM_MSG_HIGH_3("Proc CM_SRV_IND: mode %d srv_domain %d is_stable_in_svc %d", 
                       sd_rpt_ptr->srv_ind_info.si_info.mode, 
                       sd_rpt_ptr->srv_ind_info.si_info.srv_domain, 
                       sd_rpt_ptr->srv_ind_info.si_info.is_stable_in_svc);

      if(CM_IS_MODE_3GPP(sd_rpt_ptr->srv_ind_info.si_info.mode))
      {
        cmss_report_raw_3gpp_service(sd_rpt_ptr->srv_ind_info.si_info.srv_status, sd_rpt_ptr->srv_ind_info.si_info.srv_domain,
                                      sd_rpt_ptr->srv_ind_info.si_info.mode, sd_rpt_ptr->srv_ind_info.ss);
      }
      
      switch(sd_rpt_ptr->srv_ind_info.ss)
      {
        case SD_SS_MAIN:
          /* Store the prev status so that so it can be used in
                     cmpref2_proc_rpt_srv_ind
                */
            prev_srv_status_ss = cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status;
          #ifdef FEATURE_OOSC_USER_ACTION
          if ((ss_ptr->is_connected_mode_oos) &&
              (sd_rpt_ptr->srv_ind_info.si_info.srv_status == SYS_SRV_STATUS_SRV))
          {
            CM_MSG_HIGH_0("Ignoring Full Service notification due to OOSC status");
          }
          else
          #endif
          {
            cmss_update_srv_ind( ss_ptr, &sd_rpt_ptr->srv_ind_info.si_info );
          }
          cmpsm_proc_srv_ind (  &sd_rpt_ptr->srv_ind_info.si_info  );
          break;

        case SD_SS_HYBR_2:
          /* Store the prev status so that so it can be used in
                     cmpref2_proc_rpt_srv_ind
                */
            prev_srv_status_ss = cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status;
          #ifdef FEATURE_OOSC_USER_ACTION
          if ((ss_ptr->hybr_gw_is_connected_mode_oos) &&
              (sd_rpt_ptr->srv_ind_info.si_info.srv_status == SYS_SRV_STATUS_SRV))
          {
            CM_MSG_HIGH_0("Ignoring Full Service notification due to OOSC status");
          }
          else
          #endif
          {
            if (cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK_SSIM))
            {
              ss_ptr->info.changed_fields = 0;
            }
            cmss_update_hybr_2_srv_ind( ss_ptr, &sd_rpt_ptr->srv_ind_info.si_info );
          }
          break;
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        case SD_SS_HYBR_3:
         /* Store the prev status so that so it can be used in
                     cmpref2_proc_rpt_srv_ind
                */
          if(cmph_is_tsts() || cmph_is_sxlte())
          {
            prev_srv_status_ss = cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status;
          #ifdef FEATURE_OOSC_USER_ACTION
          if ((ss_ptr->hybr_3_gw_is_connected_mode_oos) &&
              (sd_rpt_ptr->srv_ind_info.si_info.srv_status == SYS_SRV_STATUS_SRV))
          {
            CM_MSG_HIGH_0("Ignoring Full Service notification due to OOSC status");
          }
          else
          #endif
          {
            if (cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK_SSIM))
            {
              ss_ptr->info.changed_fields = 0;
            }
            cmss_update_hybr_3_srv_ind( ss_ptr, &sd_rpt_ptr->srv_ind_info.si_info );
          }
          }
          break;
          #endif

        #if defined(FEATURE_HDR)
        case SD_SS_HYBR_1:
          cmss_update_hybr_1_srv_ind( ss_ptr, &sd_rpt_ptr->srv_ind_info.si_info );
          break;
        #endif  /* FEATURE_HDR */

        default:
          CM_MSG_MED_1("unrecognized SS indicator =%d",
                    sd_rpt_ptr->srv_ind_info.ss);
      } /*switch sd_rpt_ptr->srv_ind.info.ss */

       /* Reset the timers if G/W/T service is acquired and no LTE service
          */
       cmcall_ssac_process_srv_update();

       CM_MSG_HIGH_3("ss = %d, prev_srv_status_ss = %d Status recvdd in sd_rpt_ptr=%d ", sd_rpt_ptr->srv_ind_info.ss, prev_srv_status_ss, sd_rpt_ptr->srv_ind_info.si_info.srv_status);
      
       CM_MSG_HIGH_4("After updating, ss_ptr->info.srv_status=%d, intl_serv_status on MAIN=%d ss_ptr->info.gw_srv_status=%d, intl_serv_status on Hybrid2 =%d ", 
	   				ss_ptr->info.srv_status, 
	   				cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status,
       			    ss_ptr->info.gw_srv_status,
       			    cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status);
	   
       /* cmsoa has a dependency on cmss rpt processing being done first
       ** Once 1x MCC list has been calculated, do CMSOA processing
       */
       #if (defined(FEATURE_LTE_TO_1X) && defined(FEATURE_MMODE_SC_SVLTE)) || defined(FEATURE_MMODE_DYNAMIC_SV_OPERATION_SWITCH)
       cmsoa_sd_rpt_proc   (rpt_ptr);
       #endif
       cmmsimc_proc_rpt_srv_ind(sd_rpt_ptr,prev_srv_status_ss);

       /* Reset the sys sel pref id here */
       {
          (void)cmtask_orig_para_compare_func_req_id_reset((cm_ss_e_type)sd_rpt_ptr->srv_ind_info.ss,
                                                                                                 sd_rpt_ptr->srv_ind_info.si_info.sys_sel_pref_req_id);
       }

      break;

    case CM_OK_TO_ORIG_F:
      #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
      cmss_proc_data_avail_ok_to_orig( ss_ptr, &sd_rpt_ptr->ok_to_orig );
      #endif /* FEATURE_PS_DORMANT_PWR_SAVE */
      break;

    case CM_IP_APP_REG_STATUS:
      /* App registration status
      */
      cmss_inform_ipapp_reg_status (&sd_rpt_ptr->ip_app_reg_status);
      break;

    case CM_SRV_LOST_F:

      #ifdef FEATURE_EOOS
      #error code not present
#endif
      break;

    case CM_FULL_SRV_LOST_F:
            /* Full Service is lost, might need to switch to global mode
      */
        
      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_FULL_SRV_LOST_F, ((void*)&(sd_rpt_ptr->full_srv_lost)));
      #endif
      cmss_proc_full_srv_lost( sd_rpt_ptr->full_srv_lost.ss );

      cmpsm_proc_full_srv_lost ( sd_rpt_ptr->full_srv_lost.ss );
      break;

    case CM_IRAT_COMPLETE:
    {
      /* SGLTE: Process when IRAT across the stack is completed. Service should
      ** be notified to clients.
      */
      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_IRAT_COMPLETE, NULL);
      #endif
      cmss_proc_irat_complete();
      break;
    }

    default:
      break;

  } /* switch( sd_rpt_ptr->hdr.cmd ) */

} /* cmss_sd_rpt_proc() */

/*===========================================================================

FUNCTION cmss_client_cmd_proc

DESCRIPTION
  Process clients' ss commands

DEPENDENCIES
  SS object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_client_cmd_proc(

    cm_ss_cmd_s_type  *ss_cmd_ptr
        /* pointer to a CM command */
)
{

#if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
  cmss_s_type               *ss_ptr     = cmss_ptr();
#endif
  /*lint -esym(529, ss_ptr) not referenced */
      /* Point at serving system object */

  cm_ss_cmd_err_e_type       ss_cmd_err;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  CM_ASSERT( ss_cmd_ptr != NULL );
  CM_ASSERT( ss_cmd_ptr->cmd_type == CM_CMD_TYPE_SS );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /* Start by checking whether this is a valid command
  ** relative to the current state of the call/phone.
  */
  ss_cmd_err = cmss_client_cmd_check( ss_cmd_ptr );

  /*
  ** Notify clients of command processing status.
  ** If error found, return.
  */
  cmss_client_cmd_err( ss_cmd_ptr, ss_cmd_err );
  if( ss_cmd_err != CM_SS_CMD_ERR_NOERR )
  {
    return;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  switch(ss_cmd_ptr->cmd)
  {

    case CM_SS_CMD_INFO_GET:
      cmss_send_ss_info( ss_cmd_ptr, CM_SS_EVENT_INFO );
      break;

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
    case CM_SS_CMD_PS_DATA_AVAIL:
      cmss_proc_data_avail( ss_cmd_ptr );
      break;
    #endif /* FEATURE_PS_DORMANT_PWR_SAVE */

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef  FEATURE_CALL_THROTTLE
    case CM_SS_CMD_ORIG_THR_UPDATE_TBL:
      (void) cmss_orig_thr_proc_update_tbl( ss_cmd_ptr );
      break;

    #endif  /* FEATURE_CALL_THROTTLE */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #ifdef  FEATURE_CM_SS_MEAS
    #error code not present
#endif  /* FEATURE_CM_SS_MEAS */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
    case CM_SS_CMD_GET_DCH_CELL_ID:
      /*--------------------------------------------------------------------------*/
      /* Set DCH Cell ID req to TRUE and ignore all RRC_CELL_IND before CELL_CNF  */
      /* Send Get DCH Cell Info Req to RRC                                        */
      /*--------------------------------------------------------------------------*/
      ss_ptr->dch_cell_info_flgs |= CMSS_IS_DCH_CELL_INFO_REQ;
      cmwll_send_rrc_get_dch_cell_info_req();
      break;
    #endif /* FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   default:

     CM_ERR_1( "Bad SS command %d", (uint8) ss_cmd_ptr->cmd);

  }

} /* cmss_client_cmd_proc() */
  /*lint +esym(529, ss_ptr) not referenced */

#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))

/*===========================================================================

FUNCTION cmss_otasp_reset_subscription

DESCRIPTION
  If subscription is from NV, send NAM changed to 1xCP.
  If subscription is from card, reset the card through MMGSDI.
DEPENDENCIES
  Call object must have already been initialized with
  cmcall_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_otasp_reset_subscription(void)
{

  cmph_s_type    *ph_ptr  =  cmph_ptr();
    /* Point at phone object to be initialized */

  CM_ASSERT (ph_ptr != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If OTASP commit is pending */
  if (ph_ptr->is_otasp_commit_pending)
  {
    /* If subscription is from card, reset the card */
    if( cmph_get_cdma_subs_from_card_sent() )
    {
      CM_MSG_HIGH_0("Card reset sent for OTASP comm");

      /* Send card power-down cmd to MMGSDI.
      */
      if(mmgsdi_card_pdown(cm_mmgsdi_get_client_id(),
                           MMGSDI_SLOT_1,
                           cmmmgsdi_generic_cb,
                           MMGSDI_CARD_POWER_DOWN_NOTIFY_GSDI,
                           0 ) != MMGSDI_SUCCESS
        )
      {
        CM_ERR_0("Unable to power-down card");
      }

      /* Send card power-up cmd to MMGSDI upon receiving
         MMGSDI_CARD_PDOWN_CNF and MMGSDI_CARD_ERROR_EVT
      */
    }
    /* else if subscription from NV, send NAM change */
    else
    {
      CM_MSG_HIGH_0("Nam change being sent for OTASP comm");

      /* Send a NAM change command to MC to force SD to reload NAM.
      */
      cmph_send_nam_change_to_mc( ph_ptr, ph_ptr->curr_nam );
      ph_ptr->is_otasp_commit_pending = FALSE;
    }
  }

} /* cmss_otasp_reset_subscription () */


/*===========================================================================

FUNCTION cmss_mc_rpt_proc

DESCRIPTION
  Process MC reports


DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_mc_rpt_proc(

  const cm_hdr_type   *rpt_ptr
    /* Pointer to MC report */
)
{
  /*lint -save -e826 */
  cm_mc_rpt_type    *cm_mc_rpt_ptr = (cm_mc_rpt_type *) rpt_ptr;
  /*lint -restore */
        /* Pointer to MC report */

  cmss_s_type                   *ss_ptr        = cmss_ptr();
      /* Point at serving system object */

  cm_ss_cdma_info_s_type        *cdma_info_ptr;
      /* Pointer to the CDMA specific serving system information */

  cmss_update_act_e_type        action         = CMSS_INFO_UPDATE_ACT_NONE;
      /* update action */

  sys_sys_mode_e_type           prev_sys_mode;
      /* Previous service state variable */

  sys_srv_status_e_type         prev_srv_status;
      /* Previous service state variable */

  #ifdef FEATURE_HDR_HANDOFF
  sys_sys_mode_e_type           prev_idm = cmssidm_get_curr_idm();
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( cm_mc_rpt_ptr != NULL );
  CM_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cdma_info_ptr = &ss_ptr->info.mode_info.cdma_info;

  /* This is a MC notification, so:
  ** 1. Updating appropriate serving system object fields.
  ** 2. Notifying clients of event.
  */
  switch( cm_mc_rpt_ptr->hdr.cmd )
  {
    case CM_EXIT_TC_F:
      /* Check and send subscription change.
      ** After OTASP call is ended subscription change is sent only after
      ** traffic is brought down. Check is made to
      ** see if subscription change has to be sent to network.
      */
      cmss_otasp_reset_subscription();

      return;

    /* Serving system info
    */
    case CM_SRV_SYS_INFO_F:

      prev_sys_mode               = ss_ptr->info.sys_mode;
      prev_srv_status             = ss_ptr->info.srv_status;
      ss_ptr->info.changed_fields = 0;
      ss_ptr->info.changed_fields2 = 0;

      if ( sys_srv_status_is_srv( ss_ptr->info.srv_status ))
      {
        cdma_info_ptr->band_class      =
          cmss_xlat_band_class( cm_mc_rpt_ptr->srv_sys_info.band_class);
        cdma_info_ptr->block_or_system =
          cmss_xlat_block_or_system( cm_mc_rpt_ptr->srv_sys_info.block_or_system);

          /* serving state not changed */
          if ( prev_sys_mode == SYS_SYS_MODE_AMPS )
          {
            action = CMSS_INFO_UPDATE_A_TO_A;
          }
          else if ( prev_sys_mode == SYS_SYS_MODE_CDMA )
          {
            action = CMSS_INFO_UPDATE_D_TO_D;
          }

      }

      /* Check if someone has registered for just the SRV Info event.
      */
      cmss_info_new();
      if( action != CMSS_INFO_UPDATE_ACT_NONE )
      {
        cmss_info_update( action, &cm_mc_rpt_ptr->srv_sys_info );
      }

      /* Update the RSSI if the service status changed.
      */
      if( ss_ptr->info.srv_status != prev_srv_status )
      {
        cmss_report_rssi( NULL, NULL, FALSE );
      }

      if ( ss_ptr->info.changed_fields != 0 )
      {
        /*
        ** Inform the clients that the serving system was modified.
        */
        cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
      }

      break;

    #ifdef FEATURE_JCDMA
    /* Registration Succeeded
    */
    case CM_REG_SUCCESS_F:
      cmss_event( CM_SS_MAIN, CM_SS_EVENT_REG_SUCCESS);
      break;

    /* Registration Failed
    */
    case CM_REG_FAILURE_F:
      cmss_event( CM_SS_MAIN, CM_SS_EVENT_REG_FAILURE);
      break;
    #endif /* FEATURE_JCDMA */

    case CM_PSIST_F:

      if( ss_ptr->info.psist != cm_mc_rpt_ptr->psist.psist )
      {
        ss_ptr->info.psist = cm_mc_rpt_ptr->psist.psist;
        ss_ptr->info.changed_fields |= CM_SS_PSIST_CHGD_MASK;
        cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
        cmph_update_ddtm_status(cmph_ptr());
      }
      break;

    case CM_HDR_LOCATION_NOTIFICATION_STATUS_F:

      #ifdef FEATURE_HDR_HANDOFF
      /* Location notification status report from HDR
      */
      ss_ptr->info.hdr_ln_status = cm_mc_rpt_ptr->ln_status_info.ln_status;
      cmss_event( CM_SS_MAIN, CM_SS_EVENT_HDR_LN_STATUS);
      cmssidm_proc_rpt_hdr_ln_status( ss_ptr->info.hdr_ln_status );

      /* If IDM changed, notify CM clients of the corresponding event.
      */
      if ( cmssidm_get_curr_idm() != prev_idm )
      {
        ss_ptr->info.changed_fields        |= CM_SS_IDLE_DIGITAL_MODE_MASK;
        ss_ptr->info.cur_idle_digital_mode  = cmssidm_get_curr_idm();
        ss_ptr->info.prev_idle_digital_mode = cmssidm_get_prev_idm();
        cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );

      }
      #endif

      break;

    case CM_HDR_SESSION_OPEN_FAILED:
    case CM_HDR_SESSION_CLOSED:

      #ifdef FEATURE_DEDICATED_C2K_MODE
      if( ss_ptr->is_hdr_session_open )
      {
        CM_MSG_HIGH_0("DCM: HDR session failed/closed");
        ss_ptr->is_hdr_session_open = FALSE;
        cmph_update_ddtm_status(cmph_ptr());
      }

      cmcall_timer_proc( 0 );
      cmxsms_timer_proc( 0 );
      #endif

      break;

    case CM_HDR_PER_INFO_IND_F:
      cmss_report_hdr_pkt_err_rate(cm_mc_rpt_ptr);
      break;

    case CM_FER_INFO_IND_F:
      cmss_report_frame_err_rate(cm_mc_rpt_ptr);
      break;

    #ifdef FEATURE_CM_SS_MEAS
    #error code not present
#endif /* FEATURE_CM_SS_MEAS */

    case CM_OTASP_STATUS_F:
      if(cm_mc_rpt_ptr->otasp_status.otasp_code == CM_OTASP_STATUS_COMMITTED)
      {
        cmss_update_home_mcc();
      }
      break;

    /* Notify when voice_support_on_lte changes upon receiving 1xcsfb report
      ** only when LTE is in full service and PS domain
      */
    case CM_1XCSFB_STATUS_F:
      if( (ss_ptr->info.changed_fields & CM_SS_VOICE_SUPPORT_ON_LTE_MASK) &&
          ss_ptr->info.sys_mode == SYS_SYS_MODE_LTE &&
          ss_ptr->info.srv_status == SYS_SRV_STATUS_SRV &&
          ss_ptr->info.srv_domain == SYS_SRV_DOMAIN_PS_ONLY)
      {

        CM_MSG_HIGH_1("1xCSFB: mask set, voice_support_on_lte=%d",
                    ss_ptr->info.voice_support_on_lte);
        cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
      }

      break;


    default:
      break;

  }

} /* cmss_mc_rpt_proc() */
#endif   /* FEATURE_MMODE_CDMA_800 || FEATURE_MMODE_CDMA_1900 */


/*===========================================================================

FUNCTION cmss_timer_proc

DESCRIPTION
  Process timer events.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_timer_proc(

     cm_timer_event_type    timer_event
       /* Indicate specific timer event.
       **
       ** Note that currently timer event is not being used
       */
)
/*lint -esym(715,timer_event) */
{

  cmss_s_type           *ss_ptr = cmss_ptr();
      /* Point at SS object */

  cmph_s_type           *ph_ptr = cmph_ptr();
      /* Point at Phone object */

  sys_modem_as_id_e_type   subId = cmph_map_cm_ss_to_subs(CM_SS_MAIN) ;

  uint8                    stk_id = ph_ptr->ss_subs_map[CM_SS_MAIN].stack_id;

  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
  cm_orig_q_s_type          *ph_orig_para_top_ptr =
                                      cmtask_orig_para_get_top( CM_SS_MAIN );
      /* The pointer to the top element of the priority queue */

  sd_ss_orig_mode_e_type   orig_mode;

  #endif
  dword                 clk_time = time_get_uptime_secs();
      /* Current clock time */

  #ifdef FEATURE_HDR_HANDOFF
  sys_sys_mode_e_type   prev_idm = cmssidm_get_curr_idm();
    /* Remember the current idle digital mode. */
  #endif // FEATURE_HDR_HANDOFF

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );
  #if ( defined(FEATURE_HDR_HYBRID)  ||\
      (defined(FEATURE_GSM) || defined(FEATURE_WCDMA)) )
  CM_ASSERT( ph_ptr != NULL );
  #endif


  if (!cmph_is_as_id_valid(subId))
  {
    return ;
  }
  

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->info.changed_fields = 0;

  /* For targets with System Determination 2.0 support we register a
  ** callback function with system determination during power-up
  ** initialization. This function is called by SD whenever the system
  ** indicators information is changed.
  */

  /* if the is_operational buffer timer expired, reset it.
  */
  if ( ss_ptr->hold_hy2_oper_flag_uptime != CMSS_NO_SRV_UPTIME_NONE &&
       ss_ptr->hold_hy2_oper_flag_uptime <= clk_time )
  {
    CM_MSG_HIGH_0("hold_hy2_oper_flag_uptime expired");
    ss_ptr->hold_hy2_oper_flag_uptime = CMSS_NO_SRV_UPTIME_NONE;
  }

  /* If CMPH_MAX_NO_SRV_TIME expired since we lost service, do the
  ** following:
  */

  /*
  ** We need not inform the client of NO_SRV if it has already
  ** been notified.
  **
  ** If the client has already been notified then no_srv_uptim
  ** will be > 0.
  **
  ** We need to inform clients in case if we are buffering NO_SRV internally
  */

  if(  ss_ptr->no_srv_uptime   <= clk_time &&
       ss_ptr->skip_srv_ind_update == FALSE &&
      (!sys_srv_status_is_srv( ss_ptr->main_srv_status ) ||
       !sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status)
      )
    )
  {
    /* In case if we are buffereing internal no service then update
    ** with the buffered information.
    */
    if(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status
        == SYS_SRV_STATUS_NO_SRV_INTERNAL)
    {
      CM_MSG_HIGH_0("Handling internal no srv");
      //converting internal no srv to  no srv for posting srv change to clients
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_update_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN));
      #ifdef FEATURE_DOMAIN_SELECTION
      cmsds_update_and_send_sms_dom_sel_ind(CM_SS_MAIN, SYS_CM_DOMAIN_SEL_DOMAIN_NO_SMS, SYS_SYS_MODE_NO_SRV);
      #endif
    }

    /* In case if we are buffereing internal pwr save,
    ** map it back to pwr save.
    */
    if(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status
            == SYS_SRV_STATUS_PWR_SAVE_INTERNAL)
    {
      CM_MSG_HIGH_0("Handling internal pwr save");
      //converting internal pwr save to  pwr save for posting srv change to clients
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = SYS_SRV_STATUS_PWR_SAVE;
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = SYS_SYS_MODE_NO_SRV;
      #ifdef FEATURE_DOMAIN_SELECTION
      cmsds_update_and_send_sms_dom_sel_ind(CM_SS_MAIN, SYS_CM_DOMAIN_SEL_DOMAIN_NO_SMS, SYS_SYS_MODE_NO_SRV);
      #endif
    }

    /* Set the service state to no-service and the preferred acquisition
    ** indicator to FALSE.
    */

    ss_ptr->no_srv_uptime        = CMSS_NO_SRV_UPTIME_NONE;

    if(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status
        == SYS_SRV_STATUS_NO_SRV)
    {
      ss_ptr->info.srv_status      = SYS_SRV_STATUS_NO_SRV;

      ss_ptr->is_pref_srv_acq      = FALSE;
      ss_ptr->is_stable_in_svc     = FALSE;

      ss_ptr->info.sys_mode        = SYS_SYS_MODE_NO_SRV;
      ss_ptr->info.changed_fields |= CM_SS_SYS_MODE_MASK;
    }
    else
    {
      CM_MSG_HIGH_0("Set PWR_SAVE info and update clients");

      ss_ptr->main_srv_status=cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status;

      /* Update srv_domain_pref */
      ss_ptr->info.srv_domain =
        cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_domain;

      ss_ptr->info.changed_fields |= CM_SS_SRV_DOMAIN_MASK;
      CM_MSG_HIGH_1 ("Informed srv_domain %d to clients in PWR_SAVE",
                   ss_ptr->info.srv_domain);

      /* When reporting power-save, we should update
      ** sys-mode to NO-SRV to avoid the confusion to CM clients.
      */
      if(cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode != SYS_SYS_MODE_NO_SRV )
      {
        cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = SYS_SYS_MODE_NO_SRV;
        ss_ptr->info.changed_fields |= CM_SS_SYS_MODE_MASK;
      }
      cmss_update_srv_status_for_main(
        cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status,
        cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode,
        cmss_intl_srv_info_ptr(CM_SS_MAIN)->band,
        cmss_intl_srv_info_ptr(CM_SS_MAIN)->chan);

      }

    ss_ptr->info.changed_fields |= CM_SS_SRV_STATUS_MASK;

    /* Update the RSSI in the SS object */
    cmss_report_rssi( NULL, NULL, FALSE );

    /* If roaming status changed, notify CM clients of the corresponding
    ** event.
    */
    if((ss_ptr->info.roam_status != SYS_ROAM_STATUS_OFF) &&
      (ss_ptr->is_connected_mode_oos != TRUE))
    {
      ss_ptr->info.roam_status     = SYS_ROAM_STATUS_OFF;
      ss_ptr->info.changed_fields |= CM_SS_ROAM_STATUS_MASK;
    }

    cmstats_ptr()->prm.cm_info.sys_sel_info.roam_ind =
                      ( sys_stat_roam_e_type ) ss_ptr->info.roam_status;
    cmstats_update_stats_and_post_event( SYS_CM_SYS_SEL_INFO_BIT_MASK );

    #if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
    /*
    ** If the PLMN changed or there is no service, then clear the mobility
    ** management information.
    */
    if(CM_IS_MODE_3GPP(ss_ptr->last_system_reported))
    {
      /*
      ** Store the MM_INFO before going OOS.
      */
      ss_ptr->info.mode_info.gw_info.prev_mm_information = ss_ptr->info.mode_info.gw_info.mm_information;

      /*
      ** Reset the MM_INFO
      */
      cm_ss_init_mm_information( &ss_ptr->info.mode_info.gw_info.mm_information );
      ss_ptr->info.changed_fields |= CM_SS_MOBILITY_MGMT_MASK;
    }
    #endif   /* FEATURE_WCDMA || FEATURE_GSM || FEATURE_CM_LTE */
  }

  /* If the system on main or hybrid stack is not being throttled
  ** anymore generate a srv changed event
  ** This happens with two conditions:
  ** 1) The throttle time has expired
  ** 2.a) The thr_status either TRUE (means the system is being throttled
  ** and now is no longer throttled)
  ** 2.b) or the thr_status becomes FALSE while the avail_info.thr_status
  ** still indicates TRUE. This means the system was throttle, but due to
  ** timer expiration, now it's no longer throttled. However, the status
  ** has been updated from other places before get checked in time_proc
  ** function
  */
  if((( ss_ptr->info.main_thr_status.ss_thr_status !=
        ss_ptr->new_srv_avl_info[subId].stack_info[cmss_map_ss_to_stack_info(CM_SS_MAIN)].thr_status.ss_thr_status ) &&
      ss_ptr->info.main_thr_status.thr_uptime < clk_time) ||
     (( ss_ptr->info.hdr_thr_status.ss_thr_status !=
        ss_ptr->new_srv_avl_info[subId].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_1)].thr_status.ss_thr_status)&&
        (ss_ptr->new_srv_avl_info[subId].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_1)].sys_mode == SYS_SYS_MODE_HDR) &&
      (ss_ptr->info.hdr_thr_status.thr_uptime < clk_time)) ||
          ( ss_ptr->info.main_thr_status.ss_thr_status &&
      ss_ptr->info.main_thr_status.thr_uptime < clk_time) ||
          ( ss_ptr->info.hdr_thr_status.ss_thr_status &&
      ss_ptr->info.hdr_thr_status.thr_uptime < clk_time)
    )
  {
    CM_MSG_HIGH_4("Throttle timer expired, info.main_thr_status=%d, avail.main_thr_status=%d info.hdr_thr_status=%d, avail.hdr_thr_status=%d",
                ss_ptr->info.main_thr_status.ss_thr_status,
                ss_ptr->new_srv_avl_info[subId].stack_info[cmss_map_ss_to_stack_info(CM_SS_MAIN)].thr_status.ss_thr_status,
                ss_ptr->info.hdr_thr_status.ss_thr_status,
                ss_ptr->new_srv_avl_info[subId].stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_1)].thr_status.ss_thr_status);

    ss_ptr->info.changed_fields |= CM_SS_ORIG_THR_STATUS_MASK;
  }

  if( (ss_ptr->main_buffer_srv_uptime != CMSS_INFORM_SRV_CHANGE_INTER_NONE) &&
      (ss_ptr->main_buffer_srv_uptime <= clk_time) )
  {
      // buffer changed fields
      uint64  changed_fields = ss_ptr->info.changed_fields;

      cmss_update_cdma_srv_lte_do_redir();
      cmph_reset_lte_do_redir();
      //Add buffered changed fields back
      ss_ptr->info.changed_fields |= changed_fields;


   }

  /* if 1x hold srv timer expired, hybr2 becomes non-operational, or hybr2 got pwr save,
  ** reset timer and report service to clients immediately 
  */
  if( ph_ptr->cdma_hold_srv_timer > 0 && 
      ss_ptr->cdma_hold_srv_uptime != CMSS_INFORM_SRV_CHANGE_INTER_NONE &&
      (ss_ptr->cdma_hold_srv_uptime <= clk_time || 
       ss_ptr->info.is_hybr_gw_operational == FALSE ||
       cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status == SYS_SRV_STATUS_PWR_SAVE_INTERNAL) )
  {
    // buffer changed fields
    uint64  changed_fields = ss_ptr->info.changed_fields;
    
    cmss_reset_cdma_hold_srv_uptime();
    
    //Add buffered changed fields back
    ss_ptr->info.changed_fields |= changed_fields;
  }
  
  /* Check to end throttling for MAIN and report change in serving
  ** system parameters.
  */
  if ((sys_srv_status_is_srv( ss_ptr->main_srv_status ) ||
       sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status)
       ) && (ss_ptr->main_srv_inform_uptime <= clk_time)
       && ss_ptr->skip_srv_ind_update == FALSE
     )
  {

    if((cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status ==
        SYS_SRV_STATUS_LIMITED_INTERNAL ) ||
       (cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status ==
        SYS_SRV_STATUS_LIMITED_REGIONAL_INTERNAL )
      )
    {
      // buffer changed fields
      uint64  changed_fields = ss_ptr->info.changed_fields;

      CM_MSG_HIGH_0("Handling internal lmtd srv");

      // converting internal srv status to actual srv status
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status =
      sys_intl_srv_status_to_actl_srv_status(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status);

      cmss_update_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN), TRUE);
      #ifdef FEATURE_DOMAIN_SELECTION
      cmsds_update_and_send_sms_dom_sel_ind(CM_SS_MAIN, SYS_CM_DOMAIN_SEL_DOMAIN_NO_SMS, SYS_SYS_MODE_NO_SRV);
      #endif

      //Add buffered changed fields back
      ss_ptr->info.changed_fields |= changed_fields;

    }

    /* srv_avail_info holds serving system parameters last reported to clients by
    ** CM_SS_EVENT_SRV_CHANGED. cmss_update_ss_bit_mask () computes the change in
    ** parameters that need to be reported to clients.
    */
    ss_ptr->info.changed_fields |=
              cmss_get_ss_main_info_change (&ss_ptr->info, &ss_ptr->new_srv_avl_info[subId],
                                            &ss_ptr->info.changed_fields2);

    /* Update srv_avail_info if we find srv parameters have changed */
    if (ss_ptr->info.changed_fields != 0)
    {
      /* main_srv_inform_uptime is incremented only if there is a change in
      ** ss_ptr->info from the last time CM_SS_EVENT_SRV_CHANGED was
      ** reported to client. If there is no change this field is cleared
      */

        ss_ptr->main_srv_inform_uptime = clk_time +
          cmss_get_srv_ind_uptimer_value(ss_ptr->info.sys_mode,FALSE);


    } /* if (ss_ptr->info.changed_fields != 0) */
    else
    {
      ss_ptr->main_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
    }
  }

  /* Check to end throttling for HDR and report change in serving
  ** system parameters.
  */
  if ((sys_srv_status_is_srv( ss_ptr->hybr_1_srv_status )
       #ifdef FEATURE_HDR_HYBRID
       || sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status)
       #endif
       ) &&
      (ss_ptr->hdr_srv_inform_uptime <= clk_time) &&
      (ss_ptr->hdr_srv_inform_uptime != CMSS_NO_SRV_UPTIME_NONE))
  {
    #ifdef FEATURE_HDR_HYBRID
    if((cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status ==
        SYS_SRV_STATUS_LIMITED_INTERNAL ) ||
       (cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status ==
        SYS_SRV_STATUS_LIMITED_REGIONAL_INTERNAL )
      )
    {
      // buffer changed fields
      uint64  changed_fields = ss_ptr->info.changed_fields;

      CM_MSG_HIGH_0("Handling hybr_1 internal lmtd srv");

      // converting internal srv status to actual srv status
      cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status =
      sys_intl_srv_status_to_actl_srv_status(cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status);

      cmss_update_hybr_1_lmtd_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_1), TRUE);

      //Add buffered changed fields back
      ss_ptr->info.changed_fields |= changed_fields;

    }
    #endif

    /* srv_avail_info holds serving system parameters last reported to clients by
    ** CM_SS_EVENT_SRV_CHANGED. cmss_update_ss_bit_mask () computes the change in
    ** parameters that need to be reported to clients.
    */
    
    subId = cmph_map_cm_ss_to_subs(CM_SS_HYBR_1) ;
    
    stk_id = ph_ptr->ss_subs_map[CM_SS_HYBR_1].stack_id;

    
    if (!cmph_is_as_id_valid(subId))
    {
      return ;
    }

    ss_ptr->info.changed_fields |=
              cmss_get_ss_hdr_info_change (&ss_ptr->info, &ss_ptr->new_srv_avl_info[subId]);

    /* Update srv_avail_info if we find srv parameters have changed */
    if (ss_ptr->info.changed_fields != 0)
    {
      /* hdr_srv_inform_uptime is incremented only if there is a change in
      ** ss_ptr->info from the last time CM_SS_EVENT_SRV_CHANGED was
      ** reported to client. If there is no change this field is cleared
      */

        ss_ptr->hdr_srv_inform_uptime =
          clk_time + cmss_rat_srv_ind_uptimers.hdr_uptimers.srv_uptimer;


    } /* if (ss_ptr->info.changed_fields != 0) */
    else
    {
      ss_ptr->hdr_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
    }
  }


  #if (defined (FEATURE_HDR_HYBRID))
  /*
  ** No service timer expired OR
  ** Service domain doesnt contain PS in Multisim device
  ** AND
  ** Device is still in OOS on Hybrid stack.
  */
  if( ( ss_ptr->hdr_no_srv_uptime <= clk_time ||
        ( cmph_is_msim()&&
          cmmsc_get_common_domain( cmph_map_cm_srv_domain_pref_to_sd(ph_ptr->main_stack_info.pref_info.srv_domain_pref),
                                 SD_SS_SRV_DOMAIN_PREF_PS_ONLY )
                                                 == SD_SS_SRV_DOMAIN_PREF_NONE
          && ss_ptr->hdr_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE
        )
      )
       &&

      (!sys_srv_status_is_srv( ss_ptr->hybr_1_srv_status) ||
       !sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status)
      )
    )
  {
    /* Set the service state to no-service and the preferred acquisition
    ** indicator to FALSE.
    */

    if((cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status
        == SYS_SRV_STATUS_NO_SRV_INTERNAL) ||
       (cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status
        == SYS_SRV_STATUS_PWR_SAVE_INTERNAL))
    {
      // buffer changed fields
      uint64  changed_fields = ss_ptr->info.changed_fields;

      CM_MSG_HIGH_0("Handling hybr_1 internal no srv");

      if (cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status
        == SYS_SRV_STATUS_NO_SRV_INTERNAL)
      {
        //converting internal no srv to  no srv for posting srv change to clients
        cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status = SYS_SRV_STATUS_NO_SRV;
      }
      else
      {
        //converting internal pwr save to  pwr save for posting srv change to clients
        cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status = SYS_SRV_STATUS_PWR_SAVE;
      }

      cmss_update_hybr_1_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_1));

      //Add buffered changed fields back
      ss_ptr->info.changed_fields |= changed_fields;

    }

    ss_ptr->info.changed_fields |= CM_SS_HDR_SRV_STATUS_MASK;

    ss_ptr->hdr_is_pref_srv_acq                     = FALSE;
    ss_ptr->hybr_1_is_pref_srv_acq                     = FALSE;

    ss_ptr->hdr_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

    /* If roaming status changed, notify CM clients of the corresponding
    ** event.
    */
    if(( ss_ptr->info.hdr_roam_status != SYS_ROAM_STATUS_OFF )&&
      (ss_ptr->is_connected_mode_oos != TRUE))
    {
      ss_ptr->info.hdr_roam_status = SYS_ROAM_STATUS_OFF;
      ss_ptr->info.changed_fields |= CM_SS_HDR_ROAM_STATUS_MASK;
    }
	
    #ifdef FEATURE_HDR_HANDOFF
      /* Invoke IDM module to determine if IDM changed
      */
      cmssidm_proc_rpt_srv_ind_ss_hdr(  cmss_intl_srv_info_ptr(CM_SS_HYBR_1), TRUE );
    #endif
  }
  #endif /* FEATURE_HDR_HYBRID */

  #ifdef FEATURE_HDR_HANDOFF
  /* Invoke the IDM module's timer proc.
  */
  cmssidm_proc_timer();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** If IDM changed, update SS object & notify CM clients of
  ** the corresponding event.
      */
  if ( cmssidm_get_curr_idm() != prev_idm )
  {
    ss_ptr->info.changed_fields |= CM_SS_IDLE_DIGITAL_MODE_MASK;
    ss_ptr->info.cur_idle_digital_mode = cmssidm_get_curr_idm();
    ss_ptr->info.prev_idle_digital_mode = cmssidm_get_prev_idm();
  }
  #endif // FEATURE_HDR_HANDOFF


  /* If main or hybrid instance serving status changed, recompute the BCMCS
  ** serving status.
  */
  #ifdef FEATURE_BCMCS
  if( ss_ptr->info.changed_fields & CM_SS_SRV_STATUS_MASK )
  {
    ss_ptr->info.ss_main_bcmcs_srv_status =
      cmss_compute_bcmcs_srv_status(ss_ptr->info.ss_main_bcmcs_srv_supported,
                                    ss_ptr->info.srv_status );
  }

  #ifdef FEATURE_HDR_HYBRID
  if( ss_ptr->info.changed_fields & CM_SS_HDR_SRV_STATUS_MASK)
  {
    ss_ptr->info.hybr_hdr_bcmcs_srv_status =
      cmss_compute_bcmcs_srv_status(ss_ptr->info.hybr_hdr_bcmcs_srv_supported,
                                    ss_ptr->info.hdr_srv_status );
  }
  #endif /* FEATURE_HDR_HYBRID */
  #endif /* FEATURE_BCMCS */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Special handling for the following case (only HDR to LTE IRAT case):
  ** CM needs to send client IDM ssevt but gw_no_srv_uptime is still running.
  ** In this case, send client with the last service status and sys mode to avoid
  ** sending no service indication to clients.
  */
  #if defined(FEATURE_HDR_HANDOFF)
  if ( cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
    ss_ptr->info.is_hybr_gw_operational &&
    ss_ptr->info.changed_fields == CM_SS_IDLE_DIGITAL_MODE_MASK &&
    ((ss_ptr->new_srv_avl_info[subId].stack_info[1].sys_mode == SYS_SYS_MODE_LTE) && 
    (sys_srv_status_is_srv(ss_ptr->new_srv_avl_info[subId].stack_info[1].srv_status))) &&
    ss_ptr->info.gw_srv_status == SYS_SRV_STATUS_NO_SRV &&
    ss_ptr->hybr_gw_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE &&
    ss_ptr->hybr_gw_no_srv_uptime > clk_time )
  {
  CM_MSG_HIGH_0("Don't send IDM change since gw_no_srv_timer is not expired");

  ss_ptr->info.changed_fields = 0;

  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( ss_ptr->info.changed_fields != 0 )
  {
    /* Because of change in any SS fileds client will recieve
    ** SRV_CHANGED event, making below flag to default value ie FALSE
    ** because after recieving this event client will not wait any more
    ** for SS event againt sys_sel_pref cmd
    */
    cmph_reset_sys_sel_pref_rsp_pending();

    /* Update the RSSI in the SS object
    */
    cmss_report_rssi( NULL, NULL, FALSE );

    /* Inform the clients that the serving system was modified.
    */
    cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
  }

  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA)) || defined FEATURE_CM_LTE
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* In the middle of ps data available request, check ps data uptimer.
  ** If timeout, reset ps data available state and timer and info failure to
  ** clients.
  */
  if(cmcall_is_no_call_in_lte_ps())
  {
    if( ( ss_ptr->ps_data_stt != CM_PS_DATA_STT_NONE ) &&
        ( ss_ptr->no_ps_data_uptime <= clk_time )
      )
    {
      /* 30 seconds timer is expired and we did't get ok to orig or 2 mins NAS timer
      ** expired and data is not resumed. So update the priority queue.
      */
    cmss_update_ps_dormant_entry_in_queue(FALSE);

      ss_ptr->ps_data_stt = CM_PS_DATA_STT_NONE;
      ss_ptr->no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;

      /* If data is still suspended send data fail event */
      if(ss_ptr->info.ps_data_suspend == TRUE )
      {
        CM_MSG_MED_0("Send PS DATA AVAIL FAIL EVENT due to timeout");

        cmss_event( CM_SS_MAIN, CM_SS_EVENT_PS_DATA_FAIL );
      }
    }

    /* If get network list request is done or service cnf is received for
    ** user plmn + RAT selection, move ps data avail request to
    ** waiting for ok_to_orig.
    */
    if( ss_ptr->ps_data_stt == CM_PS_DATA_STT_PENDING &&
        ((ph_ptr->main_stack_info.pref_info.network_type == CM_MODE_PREF_NONE ) && 
        !cmregprx_is_user_plmn_rat_selection_pending(CM_SS_MAIN) ))
    {
        ss_ptr->is_ps_data_pending_for_srv_cnf = FALSE;
        if ( ph_orig_para_top_ptr != NULL )
        {
          cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

          orig_mode = ph_orig_para_top_ptr->orig->orig_mode;

          /* recompute the orig_mode, based on net sel mode pref */
          if( ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE &&
              ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
          {
            orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
          }
          else if (ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NORMAL &&
              ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
          {
            orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
          }

          cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue(
              CM_SS_MAIN,
              SD_SS_PREF_REAS_ORIG_RESUME,
              orig_mode,
              FALSE,
              ph_orig_para_top_ptr,
              CM_ACT_UPDATE_REAS_NONE,
              &cmd
              );

          cmmsimc_proc_cmd_pref_sys_chgd(&cmd);

          /* Update ps data state */
          ss_ptr->ps_data_stt = CM_PS_DATA_STT_SRV_ACQ;
          ss_ptr->no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
        }
        else
        {
          CM_ERR_0 ("Top element on priority queue of Main Stack is NULL");
        }
      }
  } // if no call in LTE PS
  else
  {
    /* If in LTE data call, process data avail*/
    cmss_proc_data_avail_during_lte_call( FALSE, cmph_map_cm_ss_to_as_id(CM_SS_MAIN));
  }
  #endif /* FEATURE_GWL */
} /* cmss_timer_proc() */
/*lint +esym(715,timer_event) */


/*===========================================================================

FUNCTION cmss_hybr_2_timer_proc

DESCRIPTION
  Process timer events.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_hybr_2_timer_proc(

     cm_timer_event_type    timer_event
       /* Indicate specific timer event.
       **
       ** Note that currently timer event is not being used
       */
)
/*lint -esym(715,timer_event) */
{

  cmss_s_type           *ss_ptr = cmss_ptr();
      /* Point at SS object */

  cmph_s_type           *ph_ptr = cmph_ptr();

      /* Point at Phone object */

      
     
  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
  cm_orig_q_s_type      *ph_orig_para_top_ptr =
                                      cmtask_orig_para_get_top( CM_SS_HYBR_2 );
      /* The pointer to the top element of the priority queue */

  sd_ss_orig_mode_e_type   orig_mode;
  #endif

  dword                 clk_time = time_get_uptime_secs();
      /* Current clock time */

  sys_modem_as_id_e_type   asubs_id
    = cmph_map_cm_ss_to_subs(CM_SS_HYBR_2);

  sys_srv_status_e_type buffered_srv_status = SYS_SRV_STATUS_NONE;

  if (!cmph_is_as_id_valid(asubs_id))
  {
    return ;
  }
  

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );
  #if ( defined(FEATURE_HDR_HYBRID) ||\
      (defined(FEATURE_GSM) || defined(FEATURE_WCDMA)) )
  CM_ASSERT( ph_ptr != NULL );
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if non-multi-stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit hybr2 is not operational  and already informed to clients*/
  if (!ss_ptr->info.is_hybr_gw_operational &&
      cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK_SSIM) &&
      !ss_ptr->new_srv_avl_info[SYS_MODEM_AS_ID_1].stack_info[1].is_operational
  )
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->info.hybr_gw_changed_fields = 0;

  /* For targets with System Determination 2.0 support we register a
  ** callback function with system determination during power-up
  ** initialization. This function is called by SD whenever the system
  ** indicators information is changed.
  */

  /* If CMPH_MAX_NO_SRV_TIME expired since we lost service, do the
  ** following:
  */

  /*
  ** We need not inform the client of NO_SRV if it has already
  ** been notified.
  **
  ** If the client has already been notified then no_srv_uptim
  ** will be > 0.
  */
  if(  ss_ptr->hybr_gw_no_srv_uptime   <= clk_time &&
      (!sys_srv_status_is_srv( ss_ptr->hybr_gw_srv_status )  ||
       !sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status)
      ) &&
      ss_ptr->skip_srv_ind_update == FALSE
    )
  {
    if((cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status
        == SYS_SRV_STATUS_NO_SRV_INTERNAL) ||
       (cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status
        == SYS_SRV_STATUS_PWR_SAVE_INTERNAL))
    {
      CM_MSG_HIGH_0("Mapping hybr2 internal no srv/pwr save back");

      /* converting internal no srv/pwr save to  no srv/pwr save
      ** for posting srv change to clients. */
      buffered_srv_status = cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status;
      cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status =
        sys_intl_srv_status_to_actl_srv_status(buffered_srv_status);

    }

    if(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status
        == SYS_SRV_STATUS_NO_SRV)
    {
      cmss_update_hybr_2_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_2));

      ss_ptr->info.gw_srv_status        = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->hybr_gw_is_pref_srv_acq   = FALSE;
      ss_ptr->info.gw_sys_mode = SYS_SYS_MODE_NO_SRV;
      ss_ptr->info.hybr_gw_changed_fields |= CM_SS_GW_SYS_MODE_MASK;

    }
    else
    {
      CM_MSG_HIGH_0("Set PWR_SAVE info and update clients");

      ss_ptr->hybr_gw_srv_status=
        cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status;

      /* Update srv_domain_pref */
      ss_ptr->info.gw_srv_domain =
        cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_domain;

      ss_ptr->info.hybr_gw_changed_fields |= CM_SS_GW_SRV_DOMAIN_MASK;
      CM_MSG_HIGH_1 ("Informed gw_srv_domain %d to clients in PWR_SAVE",
                   ss_ptr->info.gw_srv_domain);

      /* When reporting power-save, we should update
      ** sys-mode to NO-SRV to avoid the confusion to CM clients.
      */
      if(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode != SYS_SYS_MODE_NO_SRV )
      {
        cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode = SYS_SYS_MODE_NO_SRV;
        ss_ptr->info.hybr_gw_changed_fields |= CM_SS_GW_SYS_MODE_MASK;
      }
      cmss_update_srv_status_for_hybr_2(
                cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status,
                cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode,
                cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->band,
                cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->chan);

    }

    /* Set the service state to no-service and the preferred acquisition
    ** indicator to FALSE.
    */
    ss_ptr->hybr_gw_no_srv_uptime        = CMSS_NO_SRV_UPTIME_NONE;

    ss_ptr->info.hybr_gw_changed_fields |= CM_SS_GW_SRV_STATUS_MASK;

    /* Update the RSSI in the SS object */
    cmss_report_hybr_2_rssi( NULL, NULL, FALSE );

    /* If roaming status changed, notify CM clients of the corresponding
    ** event.
    */
    if(( ss_ptr->info.gw_roam_status != SYS_ROAM_STATUS_OFF )&&
      (ss_ptr->hybr_gw_is_connected_mode_oos != TRUE))
    {
      ss_ptr->info.gw_roam_status     = SYS_ROAM_STATUS_OFF;
      ss_ptr->info.hybr_gw_changed_fields |= CM_SS_GW_ROAM_STATUS_MASK;
    }

    #ifdef CM_GW_SUPPORTED
    /*
    ** If the PLMN changed or there is no service, then clear the mobility
    ** management information.
    */
    if(ss_ptr->hybr_gw_last_system_reported == SYS_SYS_MODE_GSM ||
       ss_ptr->hybr_gw_last_system_reported == SYS_SYS_MODE_WCDMA ||
       ss_ptr->hybr_gw_last_system_reported == SYS_SYS_MODE_LTE )
    {
      /*
      ** Store the MM_INFO before going OOS.
      */
      ss_ptr->info.gw_mode_info.gw_info.prev_mm_information = ss_ptr->info.gw_mode_info.gw_info.mm_information;

      /*
      ** Reset MM_INFO
      */
      cm_ss_init_mm_information( &ss_ptr->info.gw_mode_info.gw_info.mm_information );
      ss_ptr->info.hybr_gw_changed_fields |= CM_SS_GW_MOBILITY_MGMT_MASK;
    }
    #endif   /* FEATURE_WCDMA || FEATURE_GSM */
  }

  /* Check to end throttling for MAIN and report change in serving
  ** system parameters.
  */
  if ((sys_srv_status_is_srv( ss_ptr->hybr_gw_srv_status ) ||
       sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status)
      ) &&
      (ss_ptr->hybr_gw_srv_inform_uptime <= clk_time))
  {

    if((cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status ==
                          SYS_SRV_STATUS_LIMITED_INTERNAL ) ||
       (cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status ==
                          SYS_SRV_STATUS_LIMITED_REGIONAL_INTERNAL )
      )
    {
      // buffer changed fields
      uint64  changed_fields = ss_ptr->info.hybr_gw_changed_fields;

      CM_MSG_HIGH_0("Handling hybr2 internal lmtd srv");
      // converting internal srv status to actual srv status
      cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status =
      sys_intl_srv_status_to_actl_srv_status(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status);

      cmss_update_hybr_2_lmtd_srv_ind_info(ss_ptr,
                                           cmss_intl_srv_info_ptr(CM_SS_HYBR_2), TRUE);
      //Add buffered changed fields back
      ss_ptr->info.hybr_gw_changed_fields |= changed_fields;
    }

    /* srv_avail_info holds serving system parameters last reported to clients by
    ** CM_SS_EVENT_SRV_CHANGED. cmss_update_ss_bit_mask () computes the change in
    ** parameters that need to be reported to clients.
    */
    ss_ptr->info.hybr_gw_changed_fields |=
              cmss_get_ss_hybr_2_info_change (&ss_ptr->info, &ss_ptr->new_srv_avl_info[asubs_id]);

    /* Update srv_avail_info if we find srv parameters have changed */
    if (ss_ptr->info.hybr_gw_changed_fields != 0)
    {
      /* hybr_gw_srv_inform_uptime is incremented only if there is a change in
      ** ss_ptr->info from the last time CM_SS_EVENT_SRV_CHANGED was
      ** reported to client. If there is no change this field is cleared
      */

        ss_ptr->hybr_gw_srv_inform_uptime = clk_time +
          cmss_get_srv_ind_uptimer_value(ss_ptr->info.gw_sys_mode,FALSE);

    } /* if (ss_ptr->info.changed_fields != 0) */
    else
    {
      ss_ptr->hybr_gw_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( ss_ptr->info.hybr_gw_changed_fields != 0 )
  {
    /* Inform the clients that the serving system was modified.
    */
    if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
       cmss_ptr()->info.is_hybr_gw_operational)
    {
      cmph_reset_sys_sel_pref_rsp_pending();
    }

    if((CMPH_SS_FEATURE_MODE(CM_SS_HYBR_2, ph_ptr) == SYS_SUBS_FEATURE_MODE_SGLTE) &&
       cmss_ptr()->info.is_hybr_gw_operational)
    {
      cmph_reset_sys_sel_pref_rsp_pending2();
    }

    if(cmph_is_msim())
    {
      ph_ptr->hybr_2_stack_info.is_sys_sel_pref_rsp_pending = FALSE;
    }

    /* Update the RSSI in the SS object
    */
    cmss_report_hybr_2_rssi( NULL, NULL, FALSE );

    cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );
  }

    /* In the middle of ps data available request, check ps data uptimer.
  ** If timeout, reset ps data available state and timer and info failure to
  ** clients.
  */
  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
  if( cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
      ( ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_LTE ) &&
      ( ss_ptr->ps_data_stt != CM_PS_DATA_STT_NONE ) &&
      ( ss_ptr->no_ps_data_uptime <= clk_time )
    )
  {
    ss_ptr->ps_data_stt = CM_PS_DATA_STT_NONE;
    ss_ptr->no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
    /* If data is still suspended send data fail event */
    if(ss_ptr->info.gw_ps_data_suspend == TRUE )
    {
      cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_PS_DATA_FAIL);

      CM_MSG_MED_0("Send PS DATA AVAIL FAIL EVENT due to timeout");
    }
  }
  #endif

  /* Exit if not multi-sim or hybr2 for sub1 */
  if (!cmph_is_msim() || cmph_map_cm_ss_to_subs(CM_SS_HYBR_2) == SYS_MODEM_AS_ID_1)
  {
    return;
  }

  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(cmcall_is_no_call_in_lte_ps())
  {

  /* In the middle of ps data available request, check ps data uptimer.
  ** If timeout, reset ps data available state and timer and info failure to
  ** clients.
  */
  if( ( ss_ptr->hybr_gw_ps_data_stt != CM_PS_DATA_STT_NONE ) &&
      ( ss_ptr->hybr_gw_no_ps_data_uptime <= clk_time )
    )
  {
    /* 30 seconds timer is expired and we did't get ok to orig or 2 mins NAS timer
    ** expired and data is not resumed. So update the priority queue.
    */
    cmss_update_hybr_2_ps_dormant_entry_in_queue();

    ss_ptr->hybr_gw_ps_data_stt = CM_PS_DATA_STT_NONE;
    ss_ptr->hybr_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
    cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_PS_DATA_FAIL);

    CM_MSG_MED_0("Send PS DATA AVAIL FAIL EVENT due to timeout");
  }


  /* If get network list request is done, move ps data avail request to
  ** waiting for ok_to_orig.
  */
  if( ss_ptr->hybr_gw_ps_data_stt == CM_PS_DATA_STT_PENDING &&
      ph_ptr->hybr_2_stack_info.pref_info.network_type == CM_MODE_PREF_NONE && 
        !cmregprx_is_user_plmn_rat_selection_pending(CM_SS_HYBR_2) )
  {
    if ( ph_orig_para_top_ptr != NULL )
    {
      cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;

      orig_mode = ph_orig_para_top_ptr->orig->orig_mode;

      /* recompute the orig_mode, based on net sel mode pref */
      if( ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE &&
          CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
      }
      else if (ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NORMAL &&
            CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL)
      {
        orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
      }

      /* Waiting for ok_to_orig report from SD if there is a call. */
      cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue(
          CM_SS_HYBR_2,
          SD_SS_PREF_REAS_ORIG_RESUME,
          orig_mode,
          FALSE,
          ph_orig_para_top_ptr,
          CM_ACT_UPDATE_REAS_NONE,
          &cmd
          );

      cmmsimc_proc_cmd_pref_sys_chgd(&cmd);

      /* Update ps data state */
      ss_ptr->hybr_gw_ps_data_stt = CM_PS_DATA_STT_SRV_ACQ;
      ss_ptr->hybr_gw_no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
    }
    else
    {
      CM_ERR_0 ("Top element on priority queue of hybr2 Stack is NULL");
    }
  }
  }
  else
  {
    /* If in LTE data call, process data avail*/
    cmss_proc_data_avail_during_lte_call( FALSE, cmph_map_cm_ss_to_as_id(CM_SS_HYBR_2));
  }

  #endif
} /* cmss_hybr_2_timer_proc() */
/*lint +esym(715,timer_event) */

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================

FUNCTION cmss_hybr_3_timer_proc

DESCRIPTION
  Process timer events.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_hybr_3_timer_proc(

     cm_timer_event_type    timer_event
       /* Indicate specific timer event.
       **
       ** Note that currently timer event is not being used
       */
)
/*lint -esym(715,timer_event) */
{

  cmss_s_type           *ss_ptr = cmss_ptr();
      /* Point at SS object */

  cmph_s_type           *ph_ptr = cmph_ptr();
      
  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA)) && defined FEATURE_MMODE_TRIPLE_SIM || defined(FEATURE_MMODE_SXLTE_G)
  cm_orig_q_s_type      *ph_orig_para_top_ptr =
                                      cmtask_orig_para_get_top( CM_SS_HYBR_3 );
      /* The pointer to the top element of the priority queue */

  sd_ss_orig_mode_e_type   orig_mode;
  #endif

  dword                 clk_time = time_get_uptime_secs();
      /* Current clock time */

  sys_modem_as_id_e_type   asubs_id
    = cmph_map_cm_ss_to_subs(CM_SS_HYBR_3);



  sys_srv_status_e_type buffered_srv_status = SYS_SRV_STATUS_NONE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );
  #if ( defined(FEATURE_HDR_HYBRID) ||\
      (defined(FEATURE_GSM) || defined(FEATURE_WCDMA)) )
  CM_ASSERT( ph_ptr != NULL );
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if non-multi-stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }

  if (!cmph_is_as_id_valid(asubs_id))
  {
    return ;
  }
  

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit hybr3 is not operational */
  if (!cmss_ptr()->info.is_gw3_operational &&
      cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK_SSIM)
  )
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ss_ptr->info.gw3_changed_fields = 0;

  /* For targets with System Determination 2.0 support we register a
  ** callback function with system determination during power-up
  ** initialization. This function is called by SD whenever the system
  ** indicators information is changed.
  */

  /* If CMPH_MAX_NO_SRV_TIME expired since we lost service, do the
  ** following:
  */

  /*
  ** We need not inform the client of NO_SRV if it has already
  ** been notified.
  **
  ** If the client has already been notified then no_srv_uptim
  ** will be > 0.
  */
  if(  ss_ptr->hybr_3_gw_no_srv_uptime   <= clk_time &&
      (!sys_srv_status_is_srv( ss_ptr->hybr_3_gw_srv_status )  ||
       !sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status)
      )
    )
  {
    if((cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status
        == SYS_SRV_STATUS_NO_SRV_INTERNAL) ||
       (cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status
        == SYS_SRV_STATUS_PWR_SAVE_INTERNAL))
    {
      CM_MSG_HIGH_0("HYBR3: timer_proc: Mapping hybr3 internal no srv/pwr save back");

      /* converting internal no srv/pwr save to  no srv/pwr save
      ** for posting srv change to clients. */
      buffered_srv_status = cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status;
      cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status =
        sys_intl_srv_status_to_actl_srv_status(buffered_srv_status);
      #ifdef FEATURE_DOMAIN_SELECTION
      cmsds_update_and_send_sms_dom_sel_ind(CM_SS_HYBR_3, SYS_CM_DOMAIN_SEL_DOMAIN_NO_SMS, SYS_SYS_MODE_NO_SRV);
      #endif
    }

    if(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status
        == SYS_SRV_STATUS_NO_SRV)
    {
      cmss_update_hybr_3_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_3));

      ss_ptr->info.gw3_srv_status        = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->hybr_3_gw_is_pref_srv_acq   = FALSE;
      ss_ptr->info.gw3_sys_mode = SYS_SYS_MODE_NO_SRV;
      ss_ptr->info.gw3_changed_fields |= CM_SS_GW_SYS_MODE_MASK;

    }
    else
    {
      CM_MSG_HIGH_0("HYBR3: timer_proc: Set PWR_SAVE info and update clients");

      ss_ptr->hybr_3_gw_srv_status=
        cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status;

      /* Update srv_domain_pref */
      ss_ptr->info.gw3_srv_domain =
        cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_domain;

      ss_ptr->info.gw3_changed_fields |= CM_SS_GW_SRV_DOMAIN_MASK;
      CM_MSG_HIGH_1 ("Hybr3 : Informed gw3_srv_domain %d to clients in PWR_SAVE",
                   ss_ptr->info.gw3_srv_domain);

      /* When reporting power-save, we should update
      ** sys-mode to NO-SRV to avoid the confusion to CM clients.
      */
      if(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->mode != SYS_SYS_MODE_NO_SRV )
      {
        cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->mode = SYS_SYS_MODE_NO_SRV;
        ss_ptr->info.gw3_changed_fields |= CM_SS_GW_SYS_MODE_MASK;
      }
      cmss_update_srv_status_for_hybr_3(
                cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status,
                cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->mode,
                cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->band,
                cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->chan);

    }

    /* Set the service state to no-service and the preferred acquisition
    ** indicator to FALSE.
    */
    ss_ptr->hybr_3_gw_no_srv_uptime        = CMSS_NO_SRV_UPTIME_NONE;

    ss_ptr->info.gw3_changed_fields |= CM_SS_GW_SRV_STATUS_MASK;

    /* Update the RSSI in the SS object */
    cmss_report_hybr_3_rssi( NULL, NULL, FALSE );

    /* If roaming status changed, notify CM clients of the corresponding
    ** event.
    */
    if(( ss_ptr->info.gw3_roam_status != SYS_ROAM_STATUS_OFF )&&
      (ss_ptr->hybr_3_gw_is_connected_mode_oos != TRUE))
    {
      ss_ptr->info.gw3_roam_status     = SYS_ROAM_STATUS_OFF;
      ss_ptr->info.gw3_changed_fields |= CM_SS_GW_ROAM_STATUS_MASK;
    }

    #ifdef CM_GW_SUPPORTED
    /*
    ** If the PLMN changed or there is no service, then clear the mobility
    ** management information.
    */
    if(ss_ptr->hybr_3_gw_last_system_reported == SYS_SYS_MODE_GSM ||
       ss_ptr->hybr_3_gw_last_system_reported == SYS_SYS_MODE_WCDMA ||
       ss_ptr->hybr_3_gw_last_system_reported == SYS_SYS_MODE_LTE )
    {

      /*
      ** Store the MM_INFO before going OOS.
      */
      ss_ptr->info.gw3_mode_info.gw_info.prev_mm_information = ss_ptr->info.gw3_mode_info.gw_info.mm_information;

      /*
      ** Reset MM_INFO
      */

      cm_ss_init_mm_information( &ss_ptr->info.gw3_mode_info.gw_info.mm_information );
      ss_ptr->info.gw3_changed_fields |= CM_SS_GW_MOBILITY_MGMT_MASK;
    }
    #endif   /* FEATURE_WCDMA || FEATURE_GSM */
  }

  /* Check to end throttling for MAIN and report change in serving
  ** system parameters.
  */
  if ((sys_srv_status_is_srv( ss_ptr->hybr_3_gw_srv_status ) ||
       sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status)
      ) &&
      (ss_ptr->hybr_3_gw_srv_inform_uptime <= clk_time))
  {

    if((cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status ==
                          SYS_SRV_STATUS_LIMITED_INTERNAL ) ||
       (cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status ==
                          SYS_SRV_STATUS_LIMITED_REGIONAL_INTERNAL )
      )
    {
      // buffer changed fields
      uint64  changed_fields = ss_ptr->info.gw3_changed_fields;

      CM_MSG_HIGH_0("HYBR3: timer_proc: Handling hybr3 internal lmtd srv");
      // converting internal srv status to actual srv status
      cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status =
      sys_intl_srv_status_to_actl_srv_status(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status);

      cmss_update_hybr_3_lmtd_srv_ind_info(ss_ptr,
                                           cmss_intl_srv_info_ptr(CM_SS_HYBR_3), TRUE);
      #ifdef FEATURE_DOMAIN_SELECTION
      cmsds_update_and_send_sms_dom_sel_ind(CM_SS_HYBR_3, SYS_CM_DOMAIN_SEL_DOMAIN_NO_SMS, SYS_SYS_MODE_NO_SRV);
      #endif
      //Add buffered changed fields back
      ss_ptr->info.gw3_changed_fields |= changed_fields;
    }

    /* srv_avail_info holds serving system parameters last reported to clients by
    ** CM_SS_EVENT_SRV_CHANGED. cmss_update_ss_bit_mask () computes the change in
    ** parameters that need to be reported to clients.
    */
    ss_ptr->info.gw3_changed_fields |=
              cmss_get_ss_hybr_3_info_change (&ss_ptr->info, &ss_ptr->new_srv_avl_info[asubs_id]);

    /* Update srv_avail_info if we find srv parameters have changed */
    if (ss_ptr->info.gw3_changed_fields != 0)
    {
      /* hybr_gw_srv_inform_uptime is incremented only if there is a change in
      ** ss_ptr->info from the last time CM_SS_EVENT_SRV_CHANGED was
      ** reported to client. If there is no change this field is cleared
      */

        ss_ptr->hybr_3_gw_srv_inform_uptime = clk_time +
          cmss_get_srv_ind_uptimer_value(ss_ptr->info.gw3_sys_mode,FALSE);

    } /* if (ss_ptr->info.changed_fields != 0) */
    else
    {
      ss_ptr->hybr_3_gw_srv_inform_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( ss_ptr->info.gw3_changed_fields != 0 )
  {
    /* Inform the clients that the serving system was modified.
    */
    if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) &&
       cmss_ptr()->info.is_hybr_gw_operational)
    {
      cmph_reset_sys_sel_pref_rsp_pending();
    }

    if((CMPH_SS_FEATURE_MODE(CM_SS_HYBR_3, ph_ptr) == SYS_SUBS_FEATURE_MODE_SGLTE) &&
       cmss_ptr()->info.is_gw3_operational)
    {
      cmph_reset_sys_sel_pref_rsp_pending2();
    }

    if(cmph_is_msim())
    {
      ph_ptr->hybr_2_stack_info.is_sys_sel_pref_rsp_pending = FALSE;
    }
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      ph_ptr->hybr_3_stack_info.is_sys_sel_pref_rsp_pending = FALSE;
      #endif


    /* Update the RSSI in the SS object
    */
    cmss_report_hybr_3_rssi( NULL, NULL, FALSE );

    cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_SRV_CHANGED );
  }

  /* Exit if not multi-sim */
  if (!cmph_is_msim())
  {
    return;
  }

  #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA)) && defined FEATURE_MMODE_TRIPLE_SIM || defined(FEATURE_MMODE_SXLTE_G)
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(cmcall_is_no_call_in_lte_ps())
  {

    /* In the middle of ps data available request, check ps data uptimer.
    ** If timeout, reset ps data available state and timer and info failure to
    ** clients.
    */
    if( ( ss_ptr->hybr_3_gw_ps_data_stt != CM_PS_DATA_STT_NONE ) &&
        ( ss_ptr->hybr_3_gw_no_ps_data_uptime <= clk_time )
      )
    {
      /* 30 seconds timer is expired and we did't get ok to orig or 2 mins NAS timer
      ** expired and data is not resumed. So update the priority queue.
      */
      cmss_update_hybr_3_ps_dormant_entry_in_queue();
  
      ss_ptr->hybr_3_gw_ps_data_stt = CM_PS_DATA_STT_NONE;
      ss_ptr->hybr_3_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
      cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_PS_DATA_FAIL);
  
      CM_MSG_MED_0("HYBR3: timer_proc: Send PS DATA AVAIL FAIL EVENT due to timeout");
    }


    /* If get network list request is done, move ps data avail request to
    ** waiting for ok_to_orig.
    */
    if( ss_ptr->hybr_3_gw_ps_data_stt == CM_PS_DATA_STT_PENDING &&
      ph_ptr->hybr_3_stack_info.pref_info.network_type == CM_MODE_PREF_NONE && 
        !cmregprx_is_user_plmn_rat_selection_pending(CM_SS_HYBR_3) )
    {
      if ( ph_orig_para_top_ptr != NULL )
      {
        cmmsc_proc_cmd_pref_sys_chgd_s_type  cmd;
  
        orig_mode = ph_orig_para_top_ptr->orig->orig_mode;
  
        /* recompute the orig_mode, based on net sel mode pref */
        if( ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NONE &&
            CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL )
        {
          orig_mode = SD_SS_ORIG_MODE_MANUAL_IDLE;
        }
        else if (ph_orig_para_top_ptr->orig->orig_mode == SD_SS_ORIG_MODE_NORMAL &&
              CMPH_SS_NETWORK_SEL_MODE_PREF(asubs_id, ph_ptr) == CM_NETWORK_SEL_MODE_PREF_MANUAL)
        {
          orig_mode = SD_SS_ORIG_MODE_MANUAL_ORIG;
        }
  
        /* Waiting for ok_to_orig report from SD if there is a call. */
        cmmsc_pack_cmd_for_pref_sys_chgd_per_top_queue(
            CM_SS_HYBR_3,
            SD_SS_PREF_REAS_ORIG_RESUME,
            orig_mode,
            FALSE,
            ph_orig_para_top_ptr,
            CM_ACT_UPDATE_REAS_NONE,
            &cmd
            );
  
        cmmsimc_proc_cmd_pref_sys_chgd(&cmd);
  
        /* Update ps data state */
        ss_ptr->hybr_3_gw_ps_data_stt = CM_PS_DATA_STT_SRV_ACQ;
        ss_ptr->hybr_3_gw_no_ps_data_uptime = clk_time + CMSS_MAX_NO_PS_DATA_SRV_TIME;
      }
      else
      {
        CM_ERR_0 ("HYBR3: timer_proc: Top element on priority queue of hybr3 Stack is NULL");
      }
    }
  }
  else
  {
    /* If in LTE data call, process data avail*/
    cmss_proc_data_avail_during_lte_call( FALSE, cmph_map_cm_ss_to_as_id(CM_SS_HYBR_3));
  }
  #endif
} 
/*lint +esym(715,timer_event) */
#endif
/*===========================================================================
FUNCTION cmss_rssi_timer_handle

DESCRIPTION
  This function check the rssi. If RSSI change exceeds the delta threshold,
  CM reports rssi change event to registered clients.

DEPENDENCIES
  Phone object must be initialized

RETURNS
  none
SIDE EFFECTS
  none

===========================================================================*/
#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
void cmss_rssi_timer_handle ( void )
{
  cmss_report_rssi(NULL, NULL, FALSE);

  cmss_report_hybr_2_rssi (NULL, NULL, FALSE );
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  cmss_report_hybr_3_rssi (NULL, NULL, FALSE );
  #endif

} /* cmss_rssi_timer_handle() */
#endif

/*===========================================================================
FUNCTION cmss_gwl_rssi_timer_handle

DESCRIPTION
  This function check the rssi. If RSSI change exceeds the delta threshold,
  CM reports rssi change event to registered clients.

DEPENDENCIES
  Phone object must be initialized

RETURNS
  none
SIDE EFFECTS
  none

===========================================================================*/
#ifdef CM_GW_SUPPORTED
void cmss_gwl_rssi_timer_handle ( void )
{
  cmss_report_rssi(NULL, NULL, FALSE);
  cmss_report_hybr_2_rssi (NULL, NULL, FALSE );
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  cmss_report_hybr_3_rssi (NULL, NULL, FALSE );
  #endif

} /* cmss_gwl_rssi_timer_handle() */
#endif


#ifdef FEATURE_HDR_HANDOFF

/*===========================================================================
FUNCTION cmss_send_idle_digital_mode_event

DESCRIPTION
  This function sends the idle digital mode event

DEPENDENCIES
  Serving System object must be initialized

RETURNS
  None

SIDE EFFECTS
  none

===========================================================================*/
void cmss_send_idle_digital_mode_event
(
  void
)
{
  cmss_s_type          *ss_ptr  =  cmss_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_0("IDM - cmss_send_idle_digital_mode_event");

  ss_ptr->info.changed_fields        |= CM_SS_IDLE_DIGITAL_MODE_MASK;
  ss_ptr->info.cur_idle_digital_mode  = cmssidm_get_curr_idm();
  ss_ptr->info.prev_idle_digital_mode = cmssidm_get_prev_idm();
  cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );

} /* cmss_send_idle_digital_mode_event() */
#endif // FEATURE_HDR_HANDOFF

#if (defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)

/*===========================================================================

FUNCTION cmss_process_sim_state_chgd_rpt

DESCRIPTION
  Update the Serving system object per the new sim_state.

  If sim state is changed, Inform CM clients of corresponding event.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_process_sim_state_chgd_rpt(

       cmss_s_type            *ss_ptr,
         /* Pointer to a SS object */

       const cm_rpt_type      *sim_rpt
         /* New sim State.
         */
)
{
  sys_sim_state_e_type    sim_state = SYS_SIM_STATE_NONE;

  cm_ss_e_type            ss        = CM_SS_MAIN;
  boolean                 notify   = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );
  CM_ASSERT( sim_rpt != NULL );
  CM_ASSERT_ENUM_IS_INRANGE(sim_rpt->cmd.sim_state_chgd.sim_state, SYS_SIM_STATE_MAX);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  sim_state = sim_rpt->cmd.sim_state_chgd.sim_state;

  ss = cmph_map_sd_ss_type_to_cm_ss_type(sim_rpt->cmd.sim_state_chgd.ss);

  if ( ss == CM_SS_HYBR_2 )
  {
    /*
    ** Determine if the SIM state has changed.
    */
    if ( ss_ptr->info.gw_mode_info.gw_info.sim_state != sim_state )
    {
      /*
      ** Always indicate that the service has changed.
      */
      if(sim_state == SYS_SIM_STATE_AVAILABLE)
      {
        /* Clearing the CS/PS Reject causes and Reg. reject info when SIM is Changed
           So the Clients can be updated with refreshed Reject parameters */
        cm_ss_init_reg_reject_info(CM_SS_HYBR_2, &ss_ptr->info.gw_reg_reject_info);
      }

      ss_ptr->info.hybr_gw_changed_fields = CM_SS_GW_SRV_IND_MASK;

      ss_ptr->info.gw_mode_info.gw_info.sim_state = sim_state;
      ss_ptr->info.hybr_gw_changed_fields |= CM_SS_GW_SIM_STATE_MASK;

      notify = TRUE;
    }
  }
  else
    #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
    if ( ss == CM_SS_HYBR_3  
       && (cmph_is_tsts() || cmph_is_sxlte()) )
    {
      /*
      ** Determine if the SIM state has changed.
      */
      if ( ss_ptr->info.gw3_mode_info.gw_info.sim_state != sim_state )
      {
        if(sim_state == SYS_SIM_STATE_AVAILABLE)
        {
          /* Clearing the CS/PS Reject causes and Reg. reject info when SIM is Changed
             So the Clients can be updated with refreshed Reject parameters */
          cm_ss_init_reg_reject_info(CM_SS_HYBR_3, &ss_ptr->info.gw3_reg_reject_info);
        }

        /*
        ** Always indicate that the service has changed.
        */
        ss_ptr->info.gw3_changed_fields = CM_SS_GW_SRV_IND_MASK;

        ss_ptr->info.gw3_mode_info.gw_info.sim_state = sim_state;
        ss_ptr->info.gw3_changed_fields |= CM_SS_GW_SIM_STATE_MASK;

        notify = TRUE;
      }
    }
    else
  #endif
  {
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    switch( ss_ptr->info.sys_mode )
    {
       case SYS_SYS_MODE_CDMA:
       case SYS_SYS_MODE_HDR:
       /* Ignoring as sim_state is not applicable to cdma_info */
         break;
       default:
         /*
         ** Determine if the SIM state has changed.
         */
         if ( ss_ptr->info.mode_info.gw_info.sim_state != sim_state )
         {
           /*
           ** Always indicate that the service has changed.
           */

          if(sim_state == SYS_SIM_STATE_AVAILABLE)
          {
             /* Clearing the CS/PS Reject causes and Reg. reject info when SIM is Changed
                So the Clients can be updated with refreshed Reject parameters */
             cm_ss_init_reg_reject_info(CM_SS_MAIN, &ss_ptr->info.reg_reject_info);
          }
           ss_ptr->info.changed_fields = CM_SS_SRV_IND_MASK;

           ss_ptr->info.mode_info.gw_info.sim_state = sim_state;
           ss_ptr->info.changed_fields |= CM_SS_SIM_STATE_MASK;
           notify = TRUE;
         }
         break;
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Inform the clients that the serving system was modified.
  */
  if ( notify )
  {
    cmss_event( ss, CM_SS_EVENT_SRV_CHANGED );
  }

} /* cmss_process_sim_state_chgd_rpt() */
#endif /* (defined CM_GW_SUPPORTED || defined(FEATURE_CM_LTE)) */

/*===========================================================================

FUNCTION cmss_process_data_suspend_rpt

DESCRIPTION
  Update the Serving system object per the new data suspend state.

  If data suspend state is changed, Inform CM clients of corresponding event.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void  cmss_process_data_suspend_rpt(

      boolean             data_suspend
        /* New data suspend State.
        */
)
{
  #if !(defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  SYS_ARG_NOT_USED(data_suspend);
  return;

  #else

  cmss_s_type         *ss_ptr = cmss_ptr();
    /* Pointer to a SS object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Always indicate that the service has changed.
  */
  ss_ptr->info.changed_fields = CM_SS_SRV_IND_MASK;

  /*
  ** Determine if the Suspended flag has changed.
  */
  if ( ss_ptr->info.ps_data_suspend != data_suspend )
  {
    ss_ptr->info.ps_data_suspend = data_suspend;
    ss_ptr->info.changed_fields  = CM_SS_PS_DATA_SUSPEND_MASK;

   #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
    /* Print error message if data_suspend is false when there is limited or
    ** no service
    */
    if( !data_suspend )
    {
      if( !sys_srv_status_is_full_srv(ss_ptr->info.srv_status) )
      {
        CM_ERR_2( "Invalid ps_data_suspend flag %d for current srv_status %d",
                data_suspend,
                ss_ptr->info.srv_status);
      }

      /* If data resumed, info client that data available request succeed.
      ** And reset the ps data state.*/
      if( ss_ptr->ps_data_stt == CM_PS_DATA_STT_RESUME )
      {
        cmss_event(CM_SS_MAIN, CM_SS_EVENT_PS_DATA_SUCCESS );
        /* On data call getting connected, move the data call below the phone object
        ** in the priority queue.
        */
        cmss_update_ps_dormant_entry_in_queue(TRUE);
        ss_ptr->ps_data_stt = CM_PS_DATA_STT_NONE;
        ss_ptr->no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
      }
    }
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


    if (cmcall_is_no_call_in_lte_ps())
    {
      /* Update the priority queue if necessary. As of now, done only for:
      ** - Suspended PS data call and no/limited service.
      */
    cmss_update_ps_dormant_entry_in_queue(FALSE);
    }
    else
    {
      cmss_proc_data_avail_during_lte_call( FALSE, cmph_map_cm_ss_to_as_id(CM_SS_MAIN));
    }
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Inform the clients that the serving system was modified.
  */
  if ( ss_ptr->info.changed_fields != CM_SS_SRV_IND_MASK )
  {
     cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
  }

  #endif
} /* cmss_process_data_suspend_rpt() */


/*===========================================================================

FUNCTION cmss_process_hybr_2_data_suspend_rpt

DESCRIPTION
  Update the Serving system object per the new data suspend state.

  If data suspend state is changed, Inform CM clients of corresponding event.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void  cmss_process_hybr_2_data_suspend_rpt(

      boolean             data_suspend
        /* New data suspend State.
        */
)
{
  #if !(defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  SYS_ARG_NOT_USED(data_suspend);
  return;

  #else

  cmss_s_type         *ss_ptr = cmss_ptr();
    /* Pointer to a SS object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Always indicate that the service has changed.
  */
  ss_ptr->info.hybr_gw_changed_fields = CM_SS_GW_SRV_IND_MASK;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Determine if the Suspended flag has changed.
  */
  if ( ss_ptr->info.gw_ps_data_suspend != data_suspend )
  {
    ss_ptr->info.gw_ps_data_suspend = data_suspend;
    ss_ptr->info.hybr_gw_changed_fields  = CM_SS_GW_PS_DATA_SUSPEND_MASK;

    #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
    /* Print error message if data_suspend is false when there is limited or
    ** no service
    */
    if( !data_suspend )
    {
      if( !sys_srv_status_is_full_srv(ss_ptr->info.gw_srv_status) )
      {
        CM_ERR_2( "Invalid ps_data_suspend flag %d for current srv_status %d",
                data_suspend, ss_ptr->info.gw_srv_status);
      }

      /* If data resumed, info client that data available request succeed.
      ** And reset the ps data state.*/
      if( ss_ptr->hybr_gw_ps_data_stt == CM_PS_DATA_STT_RESUME )
      {
        cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_PS_DATA_SUCCESS );
        ss_ptr->hybr_gw_ps_data_stt = CM_PS_DATA_STT_NONE;
        ss_ptr->hybr_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
      }
    }
    #endif /* FEATURE_PS_DORMANT_PWR_SAVE */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Update the priority queue if necessary. As of now, done only for:
    ** - Suspended PS data call and no/limited service.
    */
    if (cmph_map_cm_ss_to_as_id(CM_SS_HYBR_2) != SYS_MODEM_AS_ID_1)
    {
      cmss_update_hybr_2_ps_dormant_entry_in_queue();
    }

    if (!cmcall_is_no_call_in_lte_ps())
    {
      /* For LTE call case, check the data suspend flag and update CM state
      */
      cmss_proc_data_avail_during_lte_call( FALSE, cmph_map_cm_ss_to_as_id(CM_SS_HYBR_2));
    }

  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Inform the clients that the serving system was modified.
  */
  if ( ss_ptr->info.hybr_gw_changed_fields != CM_SS_GW_SRV_IND_MASK )
  {
    cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );
  }

  #endif
} /* cmss_process_hybr_2_data_suspend_rpt() */

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================

FUNCTION cmss_process_hybr_3_data_suspend_rpt

DESCRIPTION
  Update the Serving system object per the new data suspend state.

  If data suspend state is changed, Inform CM clients of corresponding event.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void  cmss_process_hybr_3_data_suspend_rpt(

      boolean             data_suspend
        /* New data suspend State.
        */
)
{
  #if !(defined CM_GW_SUPPORTED || defined FEATURE_CM_LTE)
  SYS_ARG_NOT_USED(data_suspend);
  return;

  #else

  cmss_s_type         *ss_ptr = cmss_ptr();
    /* Pointer to a SS object */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( ss_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  if (!((cmph_is_tsts() || cmph_is_sxlte()) ))
  {
    return ;
  }
  /*
  ** Always indicate that the service has changed.
  */
  ss_ptr->info.gw3_changed_fields = CM_SS_GW_SRV_IND_MASK;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Determine if the Suspended flag has changed.
  */
  if ( ss_ptr->info.gw3_ps_data_suspend != data_suspend )
  {
    ss_ptr->info.gw3_ps_data_suspend = data_suspend;
    ss_ptr->info.gw3_changed_fields  = CM_SS_GW_PS_DATA_SUSPEND_MASK;

    #if (defined(FEATURE_GSM) || defined(FEATURE_WCDMA))
    /* Print error message if data_suspend is false when there is limited or
    ** no service
    */
    if( !data_suspend )
    {
      if( !sys_srv_status_is_full_srv(ss_ptr->info.gw3_srv_status) )
      {
        CM_ERR_2( "Hybr3:Invalid ps_data_suspend flag %d for current srv_status %d",
                data_suspend, ss_ptr->info.gw3_srv_status);
      }

      /* If data resumed, info client that data available request succeed.
      ** And reset the ps data state.*/
      if( ss_ptr->hybr_3_gw_ps_data_stt == CM_PS_DATA_STT_RESUME )
      {
        cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_PS_DATA_SUCCESS );
        ss_ptr->hybr_3_gw_ps_data_stt = CM_PS_DATA_STT_NONE;
        ss_ptr->hybr_3_gw_no_ps_data_uptime = CMSS_NO_PS_DATA_UPTIME_NONE;
      }

      /* Update the priority queue if necessary. As of now, done only for:
      ** - Suspended PS data call and no/limited service.
      */
      cmss_update_hybr_3_ps_dormant_entry_in_queue();
    }
    #endif /* FEATURE_PS_DORMANT_PWR_SAVE */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    if (!cmcall_is_no_call_in_lte_ps())
    {
      /* For LTE call case, check the data suspend flag and update CM state
      */
      cmss_proc_data_avail_during_lte_call( FALSE, cmph_map_cm_ss_to_as_id(CM_SS_HYBR_3));
    }

  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
  ** Inform the clients that the serving system was modified.
  */
  if ( ss_ptr->info.gw3_changed_fields != CM_SS_GW_SRV_IND_MASK )
  {
    cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_SRV_CHANGED );
  }

  #endif
} /* cmss_process_hybr_3_data_suspend_rpt() */

#endif
#ifdef FEATURE_CM_LTE

/*===========================================================================

FUNCTION cmss_map_lte_embms_avail_to_sys_embms_avail

DESCRIPTION
  Maps the LTE coverage status value received from LTE to SYS value.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static sys_embms_coverage_status_e_type cmss_map_lte_embms_avail_to_sys_embms_avail(

  lte_rrc_embms_coverage_status_e coverage_status

)
{
  CM_MSG_HIGH_1( "Map LTE eMBMS Coverage %d to SYS eMBMS",
                 coverage_status );

  switch ( coverage_status )
  {
    case LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE:
      return SYS_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE;

    case LTE_RRC_EMBMS_COVERAGE_STATUS_AVAILABLE:
      return SYS_EMBMS_COVERAGE_STATUS_AVAILABLE;

    case LTE_RRC_EMBMS_COVERAGE_STATUS_UNKNOWN:
      return SYS_EMBMS_COVERAGE_STATUS_UNKNOWN;

    case LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE:
      return SYS_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE;

    case LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_E911:
      return SYS_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_E911;

    default:
      return SYS_EMBMS_COVERAGE_STATUS_INVALID;
  }
}


/*===========================================================================

FUNCTION cmss_msgr_rpt_proc

DESCRIPTION
  Process reports from the LTE lower layers.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_msgr_rpt_proc(

  const void          *rpt_ptr
    /* Pointer to the report sent by Message Router */
)
{
  const cm_lte_sys_u_type *cm_rpt_ptr = (cm_lte_sys_u_type *) rpt_ptr;
  cmss_s_type           *ss_ptr       = cmss_ptr();
  cm_ss_e_type             ss         = CM_SS_MAIN;

  if (CM_MSGR_MSG_CPHY_RSSI(cm_rpt_ptr->lte_rssi_ind.msgr_hdr.id))
  {
    CM_MSG_MED_0("LTE->CM: recvd LTE_CPHY_RSSI_IND");
    cmss_gwl_store_rssi_info( SYS_SYS_MODE_LTE,
                             (void *) (&(cm_rpt_ptr->lte_rssi_ind)));
  }

  CM_MSG_HIGH_2("regprx states m %d, h2 %d",\
      cmregprx_get_stack_info_ptr(SD_SS_MAIN)->state,
      cmregprx_get_stack_info_ptr(SD_SS_HYBR_2)->state);

  if (CM_MSGR_MSG_LTE_RRC_EMBMS(cm_rpt_ptr->lte_embms_coverage_state_ind.msg_hdr.id))
  {
    sys_modem_as_id_e_type as_id 
    = INST_ID_TO_SYS_AS_ID(cm_rpt_ptr->lte_embms_coverage_state_ind.msg_hdr.inst_id);

    CM_MSG_HIGH_3 ("LTE->CM: recvd LTE_RRC_EMBMS_COV_STATE_IND : eMBMS coverage = %d, trace id =%d, inst_id =%d",
                   cm_rpt_ptr->lte_embms_coverage_state_ind.coverage_status,
                   cm_rpt_ptr->lte_embms_coverage_state_ind.debug_trace_id,
                   cm_rpt_ptr->lte_embms_coverage_state_ind.msg_hdr.inst_id);

    if(SYS_MODEM_AS_ID_1 == as_id)
    {
      if (cmph_is_subs_feature_mode_1x_sxlte(as_id) &&
              cmregprx_get_stack_info_ptr(SD_SS_HYBR_2)->state == CMREGPRX_STATE_ACTIVE)
      {
        ss = CM_SS_HYBR_2;
      }
      else if(ss_ptr->info.sys_mode == SYS_SYS_MODE_LTE &&
             ss_ptr->info.is_main_operational)
      {
        ss = CM_SS_MAIN;
      }
      else
      {
        CM_ERR_0("Unexpected EMBMS info, when CM have no LTE service");
      }
    }
    else
    {
      ss = cmph_map_subs_to_ss(as_id);
    }
    CM_MSG_MED_2 ("as_id %d, ss %d",as_id,ss);


    if(ss == CM_SS_HYBR_3 &&
         ss_ptr->info.gw3_embms_info.embms_coverage_status  != \
              cmss_map_lte_embms_avail_to_sys_embms_avail(
                cm_rpt_ptr->lte_embms_coverage_state_ind.coverage_status ))
    {
          /* Update the eMBMS availibility */
        ss_ptr->info.gw3_embms_info.embms_coverage_status  =
           cmss_map_lte_embms_avail_to_sys_embms_avail( cm_rpt_ptr->lte_embms_coverage_state_ind.coverage_status );

          ss_ptr->info.gw3_embms_info.trace_id  =
        cm_rpt_ptr->lte_embms_coverage_state_ind.debug_trace_id;

        cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_SRV_CHANGED );
     }
     else if(ss == CM_SS_HYBR_2 &&
         ss_ptr->info.gwl_embms_info.embms_coverage_status  != \
              cmss_map_lte_embms_avail_to_sys_embms_avail(
                cm_rpt_ptr->lte_embms_coverage_state_ind.coverage_status ))
     {
          /* Update the eMBMS availibility */
        ss_ptr->info.gwl_embms_info.embms_coverage_status  =
           cmss_map_lte_embms_avail_to_sys_embms_avail( cm_rpt_ptr->lte_embms_coverage_state_ind.coverage_status );

          ss_ptr->info.gwl_embms_info.trace_id  =
        cm_rpt_ptr->lte_embms_coverage_state_ind.debug_trace_id;

          cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );
      }
      else if ( ss_ptr->info.embms_info.embms_coverage_status  != \
         cmss_map_lte_embms_avail_to_sys_embms_avail(
            cm_rpt_ptr->lte_embms_coverage_state_ind.coverage_status ))
      {
        /* Update the eMBMS availibility */
        ss_ptr->info.embms_info.embms_coverage_status =
           cmss_map_lte_embms_avail_to_sys_embms_avail( cm_rpt_ptr->lte_embms_coverage_state_ind.coverage_status );

        ss_ptr->info.embms_info.trace_id  =
          cm_rpt_ptr->lte_embms_coverage_state_ind.debug_trace_id;

        cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
      }
      else
      {
        CM_MSG_HIGH_2("ignored: ss %d, coverage_status %d",ss, cm_rpt_ptr->lte_embms_coverage_state_ind.coverage_status);
      }
    }
}
#endif

#ifdef FEATURE_TDSCDMA
/*===========================================================================

FUNCTION cmss_msgr_tds_rpt_proc

DESCRIPTION
  Process reports from the TDS lower layers.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_msgr_tds_rpt_proc(

  const void          *rpt_ptr
    /* Pointer to the report sent by Message Router */
)
{
  const cm_tds_sys_u_type *cm_rpt_ptr = (cm_tds_sys_u_type *) rpt_ptr;

  if (CM_MSGR_MSG_TDS_RRC_SCELL_SIGNAL_STATUS(cm_rpt_ptr->tds_rrc_scell_sig_ind.msg_hdr.id))
  {
    CM_MSG_MED_0("Main:recvd TDS_RRC_SCELL_SIGNAL_STATUS");
    cmss_gwl_store_rssi_info( SYS_SYS_MODE_TDS,
                             (void *) (&(cm_rpt_ptr->tds_rrc_scell_sig_ind)));
  }
}

#ifdef FEATURE_MMODE_DUAL_SIM
/*===========================================================================

FUNCTION cmss_msgr_tds_rpt_proc_hybr_2

DESCRIPTION
  Process reports from the TDS lower layers.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_msgr_hybr_2_tds_rpt_proc(

  const void          *rpt_ptr
    /* Pointer to the report sent by Message Router */
)
{
  const cm_tds_sys_u_type *cm_rpt_ptr = (cm_tds_sys_u_type *) rpt_ptr;

  if (CM_MSGR_MSG_TDS_RRC_SCELL_SIGNAL_STATUS(cm_rpt_ptr->tds_rrc_scell_sig_ind.msg_hdr.id))
  {
    CM_MSG_MED_0("Hybr2:recvd TDS_RRC_SCELL_SIGNAL_STATUS");
    cmss_gwl_store_hybr_2_rssi_info( SYS_SYS_MODE_TDS,
                                     (void *) (&(cm_rpt_ptr->tds_rrc_scell_sig_ind)));
  }
}
#endif


#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================

FUNCTION cmss_msgr_tds_rpt_proc_hybr_3

DESCRIPTION
  Process reports from the TDS lower layers.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_msgr_hybr_3_tds_rpt_proc(

  const void          *rpt_ptr
    /* Pointer to the report sent by Message Router */
)
{
  const cm_tds_sys_u_type *cm_rpt_ptr = (cm_tds_sys_u_type *) rpt_ptr;

  if (CM_MSGR_MSG_TDS_RRC_SCELL_SIGNAL_STATUS(cm_rpt_ptr->tds_rrc_scell_sig_ind.msg_hdr.id))
  {
    CM_MSG_MED_0("Hybr3:recvd TDS_RRC_SCELL_SIGNAL_STATUS");
    cmss_gwl_store_hybr_3_rssi_info( SYS_SYS_MODE_TDS,
                                     (void *) (&(cm_rpt_ptr->tds_rrc_scell_sig_ind)));
  }
}
#endif
#endif

/*===========================================================================

FUNCTION cmss_delay_data_suspend_store

DESCRIPTION
  Store the value of Data suspend for processing after IRAT completion.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_delay_data_suspend_store( boolean data_sus, sys_modem_as_id_e_type asubs_id )
{
  if (!cmph_is_subs_feature_mode_sglte(asubs_id))
  {
    return;
  }

  CM_MSG_HIGH_3("SC_SGLTE: data_suspend_valid=%d, Overwriting Data suspend %d with %d",
  	data_suspend_valid, data_suspend_store, data_sus);
  if ( data_suspend_valid == TRUE )
  {
    data_suspend_store = data_sus;
  }
  else
  {
    data_suspend_store = data_sus;
    data_suspend_valid = TRUE;
  }
}

/*===========================================================================

FUNCTION cmss_delay_data_suspend_retrieve

DESCRIPTION
  Retrieve the previously stored value of Data suspend for processing.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static boolean cmss_delay_data_suspend_retrieve (boolean *data_sus)
{
  if ( !cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) ||
       (data_sus == NULL)
      )
  {
    return FALSE;
  }

  CM_MSG_HIGH_2("SC_SGLTE: IRAT complete, process data_suspend %d, valid %d",
                                                        data_suspend_store,
                                                        data_suspend_valid);

  if (data_suspend_valid == TRUE)
  {
    *data_sus = data_suspend_store;
    data_suspend_valid = FALSE;
    return TRUE;
  }

  return FALSE;
}

/*===========================================================================

FUNCTION cmss_rpt_proc

DESCRIPTION
  Process reports from the lower layers.

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_rpt_proc(

  const cm_hdr_type   *rpt_ptr
    /* Pointer to LL report */
)
{
  #if !(defined(CM_GW_SUPPORTED) || defined(FEATURE_CM_LTE))
  SYS_ARG_NOT_USED(rpt_ptr);
  return;

  #else

  const cm_rpt_type   *cm_rpt_ptr = (cm_rpt_type *) rpt_ptr;
    /* Pointer to LL report */

  cmss_s_type       *ss_ptr       = cmss_ptr();
    /* Pointer to serving system object */

  cm_ss_e_type        ss = CM_SS_MAIN;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( cm_rpt_ptr != NULL );

  #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
  if ((ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_REQ) &&
      (cm_rpt_ptr->hdr.cmd == CM_RRC_CELL_INFO_IND))
  {
    /* All "CM_RRC_CELL_INFO_IND" reports will be ignored while expecting "CM_RRC_DCH_CELL_INFO_CNF" */
    CM_MSG_HIGH_0("Recv CELL_INFO_IND while waiting for CELL_INFO_CNF, so ignoring evnt");
    return;
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Do command specific processing as follows:
  ** 1. Updating appropriate phone object fields.
  ** 2. Notifying clients of event if necessary.
  */
  switch( cm_rpt_ptr->hdr.cmd )
  {
    case CM_RR_STATUS_IND:
    case CM_RRC_STATUS_IND:
      {
        sys_sys_mode_e_type sys_mode = SYS_SYS_MODE_NONE;
        cm_ss_e_type            cm_ss      = CM_SS_MAIN;

        if(CM_RR_STATUS_IND == cm_rpt_ptr->hdr.cmd)
        {
          sys_mode = SYS_SYS_MODE_GSM;
        }
        else
        {
          sys_mode = SYS_SYS_MODE_WCDMA;
        }

        /* Determine cm_ss */
        cm_ss = cmph_determine_ss_per_rat(cm_rpt_ptr->asubs_id, sys_mode);
        CM_MSG_HIGH_3("status_ind, sys_mode=%d, asubs_id=%d, ss=%d", sys_mode, cm_rpt_ptr->asubs_id, cm_ss);

        if(cm_ss == CM_SS_HYBR_2)
        {
            cmss_gwl_store_hybr_2_rssi_info( sys_mode, (void *) &cm_rpt_ptr->cmd.signal_status);
          break;
        }
        else
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
        if(cm_ss == CM_SS_HYBR_3)
        {
            cmss_gwl_store_hybr_3_rssi_info( sys_mode, (void *) &cm_rpt_ptr->cmd.signal_status);
          break;
        }
        else
        #endif /* FEATURE_MMODE_TRIPLE_SIM */
        {
          cmss_gwl_store_rssi_info( sys_mode, (void *) &cm_rpt_ptr->cmd.signal_status);
        }
      }
      break;

    case CM_MM_INFORMATION_IND:
    {
      sys_modem_stack_id_e_type   stack_id = SYS_MODEM_STACK_ID_1;
      CM_MSG_HIGH_1("mm_information_ind, as_id=%d", cm_rpt_ptr->cmd.mm_information_ind.as_id);

      /* Determine is_stack_id for SVLTE HYBR-2*/
      if (cmph_is_subs_feature_mode_1x_sxlte(cm_rpt_ptr->cmd.mm_information_ind.as_id))
      {
        if( cmss_ptr()->info.is_hybr_gw_operational &&
          ((sys_srv_status_is_srv(cmss_ptr()->info.gw_srv_status) &&
          cmss_ptr()->info.gw_sys_mode == SYS_SYS_MODE_LTE) ||
          (cm_rpt_ptr->cmd.mm_information_ind.info.rat == SYS_RAT_LTE_RADIO_ACCESS)))
        {
          stack_id = 2;
        }
        else
        {
          stack_id = 0;
        }
      }
      else
      {
        stack_id = (uint8)cm_rpt_ptr->cmd.mm_information_ind.stack_id;
      }
      ss = cmph_map_subs_stack_to_ss(cm_rpt_ptr->cmd.mm_information_ind.as_id,stack_id);

      cmss_process_mm_info_ind_rpt(ss,
                  cm_rpt_ptr->cmd.mm_information_ind.info );

      break;
    }

    case CM_SIM_STATE_CHGD_F:
      cmss_process_sim_state_chgd_rpt( ss_ptr, cm_rpt_ptr );
      break;

    case CM_DATA_SUSPEND_CHGD_F:
      /* If  LTE service is in main stack,
           ** update hybr_2(LTE) stack info if LTE has service.
      */
      #ifdef FEATURE_CM_DEBUG_BUFFER
      cmdbg_add_to_dbg_buffer(CM_BUFF_RPT_TYPE, CM_DATA_SUSPEND_CHGD_F, ((void*)&(cm_rpt_ptr->cmd.data_suspend_chgd)));
      #endif
      if( cm_rpt_ptr->cmd.data_suspend_chgd.ss == SD_SS_HYBR_2 )
      {
        cmss_process_hybr_2_data_suspend_rpt(
                                       cm_rpt_ptr->cmd.data_suspend_chgd.data_suspend );
      }
      #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
      else if( cm_rpt_ptr->cmd.data_suspend_chgd.ss == SD_SS_HYBR_3 )
      {
        cmss_process_hybr_3_data_suspend_rpt(
                                       cm_rpt_ptr->cmd.data_suspend_chgd.data_suspend );
      }
      #endif
      else
      {
        /* If the data resume received while CM still skipping srv_update (IRAT)
        ** requeue the command to CM queue so that it will be processed after
        ** IRAT is complete.
        */
        if ( ss_ptr->skip_srv_ind_update == TRUE &&
             cm_rpt_ptr->cmd.data_suspend_chgd.data_suspend == FALSE &&
             ss_ptr->info.ps_data_suspend != cm_rpt_ptr->cmd.data_suspend_chgd.data_suspend &&
             cmph_is_subs_feature_mode_sglte(cm_rpt_ptr->asubs_id))
        {
          cmss_delay_data_suspend_store( cm_rpt_ptr->cmd.data_suspend_chgd.data_suspend, cm_rpt_ptr->asubs_id );
        }
        else
        {
          cmss_process_data_suspend_rpt( cm_rpt_ptr->cmd.data_suspend_chgd.data_suspend );
        }
      }
      break;

    case CM_CIPHER_IND:
      cmss_process_cipher_ind_rpt(cm_rpt_ptr->cmd.cipher_ind);
      break;

    case CM_EMERGENCY_NUM_LIST_IND:
      cmss_process_emerg_num_list_ind_rpt (cm_rpt_ptr);
      break;

    case CM_CELL_SERVICES_IND:
      cmss_process_cell_supp_services_rpt (cm_rpt_ptr);
      break;

    case CM_HSPA_CALL_STATUS_IND:
      cmss_process_hspa_call_status_rpt (cm_rpt_ptr);
      break;

    case CM_CONN_MODE_SERVICE_STATUS_IND:
      cmss_process_conn_mode_service_status_rpt(cm_rpt_ptr);
      break;

    case CM_RR_CELL_INFO_IND:
      cmss_process_cell_info_rpt(cm_rpt_ptr,SYS_SYS_MODE_GSM);
      break;

    #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) &&  defined(FEATURE_WCDMA))
    case CM_RRC_DCH_CELL_INFO_CNF:
    #endif
    case CM_RRC_CELL_INFO_IND:
      cmss_process_cell_info_rpt(cm_rpt_ptr,SYS_SYS_MODE_WCDMA);
      break;

    case CM_REG_REJECT_IND:
      cmss_process_reg_reject_ind_rpt(cm_rpt_ptr);
      break;

    case CM_GAN_INFO_IND:
      cmss_process_gan_info_rpt(cm_rpt_ptr);
      break;

    case CM_CELL_ACCESS_IND:
      cmss_update_cell_access_ind(cm_rpt_ptr);
      break;

    case CM_RR_CELL_BROADCAST_INFO_IND:
    case CM_RRC_CELL_BROADCAST_INFO_IND:
      cmss_process_cb_info_rpt(cm_rpt_ptr);
      break;
    case CM_HOME_NODEB_NAME_IND:
      cmss_update_home_nodeb_name_ind(cm_rpt_ptr);
      break;
    default:
      break;

  } /* switch( cm_rpt_ptr->hdr.cmd ) */

  #endif
} /* cmss_rpt_proc() */

/*===========================================================================

FUNCTION cmss_generic_rpt_proc

DESCRIPTION
  Process Generic reports in CMSS


DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_generic_rpt_proc(

  const cm_hdr_type   *rpt_ptr
    /* Pointer to generic reports */
)
{
  const cm_generic_rpt_s_type *gen_rpt_ptr = (cm_generic_rpt_s_type *)rpt_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT( gen_rpt_ptr != NULL );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch(gen_rpt_ptr->hdr.cmd)
  {
    case CM_MMGSDI_CARD_RPT:
      switch(gen_rpt_ptr->generic_rpt.mmgsdi_card_rpt.evt)
      {
        case MMGSDI_SUBSCRIPTION_READY_EVT:
          cmss_update_home_mcc();
          break;

        default:
          break;
      }
      break;

    case CM_SOA_MSG_MCC:
      /* Store the hdr mcc received, in local buffer**/
      if ((gen_rpt_ptr->generic_rpt.mcc_msg.ss == SD_SS_HYBR_1) ||
          (gen_rpt_ptr->generic_rpt.mcc_msg.ss == SD_SS_MAIN))
      {
      cmss_ptr()->current_hdr_mcc = (cm_country_code_type)gen_rpt_ptr->generic_rpt.mcc_msg.mcc;
      }
      break;

    default:
      break;
  }
} /* cmss_generic_rpt_proc */


/*===========================================================================

FUNCTION cmss_proc_hdr_reselect

DESCRIPTION
  This function should be called when the HDRMC reports Hdr reselect or not
  good for traffic.
  Implemented only for backwards compatability.

DEPENDENCIES
  cmssidm_init() should have been called previously.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
void                           cmss_proc_hdr_reselect
(
        void
)
{

  #ifdef FEATURE_HDR_HANDOFF

  /* Pointer to serving system object.
  */
  cmss_s_type              *ss_ptr               = cmss_ptr();
  sys_sys_mode_e_type      prev_idm = cmssidm_get_curr_idm();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Process the HDR_RESELECT event report.
  */
  ss_ptr->info.changed_fields = 0;

  cmssidm_proc_hdr_reselect();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If IDM changed, notify CM clients of the corresponding event.
  */
  if ( cmssidm_get_curr_idm() != prev_idm )
  {
    ss_ptr->info.changed_fields |= CM_SS_IDLE_DIGITAL_MODE_MASK;
    ss_ptr->info.cur_idle_digital_mode = cmssidm_get_curr_idm();
    ss_ptr->info.prev_idle_digital_mode = cmssidm_get_prev_idm();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Generate IDM event if changed_fields is not zero.
  */
  if ( ss_ptr->info.changed_fields != 0 )
  {
    /* Inform the clients that the serving system was modified.
    */
    cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
  }
  #endif // FEATURE_HDR_HANDOFF
}


/*===========================================================================

FUNCTION cmss_proc_call_connected

DESCRIPTION
  This function should be called when the call enters conversation.

DEPENDENCIES
  cmssidm_init() should have been called previously.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
void                           cmss_proc_call_connected
(
        const cmcall_s_type                  *call_ptr
           /* Pointer to call object which entered conversation.
           */
)
/*lint -esym(714,cmss_proc_call_connected) */
/*lint -esym(765,cmss_proc_call_connected)
** Can't be static, used by cmxcall.c, can't externalize through cmss.h as then we
** run into circular header inclusion between cmxcall.c and cmss.h
*/
/*lint -esym(715,call_ptr)*/
{
   /* Pointer to serving system object.
  */

  #ifdef FEATURE_HDR_HANDOFF
  cmss_s_type              *ss_ptr               = cmss_ptr();
  sys_sys_mode_e_type      prev_idm = cmssidm_get_curr_idm();

  ss_ptr->info.changed_fields = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Process the call connected event report.
  */
  cmssidm_proc_call_connected( call_ptr );

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If IDM changed, notify CM clients of the corresponding event.
  */
  if ( cmssidm_get_curr_idm() != prev_idm )
  {
    ss_ptr->info.changed_fields        |= CM_SS_IDLE_DIGITAL_MODE_MASK;
    ss_ptr->info.cur_idle_digital_mode  = cmssidm_get_curr_idm();
    ss_ptr->info.prev_idle_digital_mode = cmssidm_get_prev_idm();
    cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );

  }
  #endif // FEATURE_HDR_HANDOFF


} /* cmss_proc_call_connected */
/*lint +esym(715,call_ptr)*/


/*===========================================================================

FUNCTION cmss_proc_call_ended

DESCRIPTION
  This function should be called to process the call end event from
  CMCALL.

DEPENDENCIES
  cmssidm_init() should have been called previously.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
void                           cmss_proc_call_ended
(
        void
)
{

  #ifdef FEATURE_HDR_HANDOFF
  /* Pointer to serving system object.
  */
  cmss_s_type              *ss_ptr               = cmss_ptr();
  sys_sys_mode_e_type      prev_idm = cmssidm_get_curr_idm();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Process the call ended event report.
  */
  ss_ptr->info.changed_fields = 0;
  cmssidm_proc_call_ended();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If IDM changed, notify CM clients of the corresponding event.
  */
  if ( cmssidm_get_curr_idm() != prev_idm )
  {
    ss_ptr->info.changed_fields |= CM_SS_IDLE_DIGITAL_MODE_MASK;
    ss_ptr->info.cur_idle_digital_mode = cmssidm_get_curr_idm();
    ss_ptr->info.prev_idle_digital_mode = cmssidm_get_prev_idm();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Generate IDM event if changed_fields is not zero.
  */
  if ( ss_ptr->info.changed_fields != 0 )
  {
    /* Inform the clients that the serving system was modified.
    */
    cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );
  }
  #endif // FEATURE_HDR_HANDOFF
}

#ifdef FEATURE_EOOS
#error code not present
#endif

/*===========================================================================
FUNCTION cmss_send_manual_scan_fail_ind

DESCRIPTION
   Sends manual scan fail indication

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
static void cmss_send_manual_scan_fail_ind(sd_ss_e_type ss)
{
  cm_manual_scan_fail_ind_s_type  *ind = NULL;
  sys_modem_as_id_e_type asubs_id = cmph_map_cm_ss_to_as_id(
        cmph_map_sd_ss_type_to_cm_ss_type(ss));

  CM_MSG_HIGH_1("Sending manual scan fail ind, asubs_id=%d", asubs_id);

  ind = (cm_manual_scan_fail_ind_s_type *)cm_mem_malloc
                      (sizeof(cm_manual_scan_fail_ind_s_type));
  if(ind != NULL)
  {
    ind->msg_hdr.inst_id = SYS_AS_ID_TO_INST_ID(asubs_id);
     (void) cm_msgr_send( MM_CM_MANUAL_SCAN_FAIL_IND, MSGR_MM_CM,
                         (msgr_hdr_s*)ind, sizeof(cm_manual_scan_fail_ind_s_type) );
    cm_mem_free (ind);
  }
  else
  {
    CM_ERR_0("Unable to allocate memory for manual_scan_fail_ind");
  }
}

/*===========================================================================

FUNCTION cmss_proc_full_srv_lost

DESCRIPTION
   Process the service indication from SD/RRC.


DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void                           cmss_proc_full_srv_lost
(
        sd_ss_e_type           ss
            /* Instance on which service was lost
            */
)
{

  cmph_s_type *ph_ptr = cmph_ptr();
  cmss_s_type *ss_ptr = cmss_ptr();
  sd_ss_band_pref_e_type band_3gpp   = (SD_MODE_CONTAIN (ph_ptr->mode_capability, SD_SS_MODE_PREF_GSM) |
                                      SD_MODE_CONTAIN (ph_ptr->mode_capability, SD_SS_MODE_PREF_WCDMA));
  sd_ss_band_pref_e_type band_3gpp2 =
                            (SD_MODE_CONTAIN (ph_ptr->mode_capability, SD_SS_MODE_PREF_CDMA) |
                            SD_MODE_CONTAIN (ph_ptr->mode_capability, SD_SS_MODE_PREF_HDR) );
  cm_network_sel_mode_pref_e_type int_net_sel_mode = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
  cm_mode_pref_e_type             mode_pref_to_force = CM_MODE_PREF_AUTOMATIC;
  cm_mode_pref_e_type             mode_pref_to_check = CM_MODE_PREF_NONE;
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;

  /*
  mode_pref_to_check: This variable is used to check if current mode_pref of AS_ID_1 is same as this variable, CM should not force it again.
  If L/H is there in rat_disabled_mask then this variable will not have L/H.

  mode_pref_to_force: This variable is used to force the new mode_pref on AS_ID_1. This will have mode_pref we want to force as well L/H (if it was in rat_disabled_mask),
  so that it should again get added to rat_disabled_mask.
  */
  if ((CMPH_SS_MODE_PREF(SYS_MODEM_AS_ID_1, ph_ptr) == CM_MODE_PREF_LTE_ONLY) ||
      // Below check is needed for a case where SUB 1 was configured as L only and DDS switched to SUB 2
      (CMPH_SS_MODE_PREF(SYS_MODEM_AS_ID_1, ph_ptr) == CM_MODE_PREF_NONE &&
        cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, SYS_MODEM_AS_ID_1)))
  {
    mode_pref_to_force = CM_MODE_PREF_LTE_ONLY;
  }
  else if (!sd_misc_is_mode_pref(cmph_map_cm_mode_pref_to_sd_mode_pref(CMPH_SS_MODE_PREF(SYS_MODEM_AS_ID_1, ph_ptr)),
                           SD_SS_MODE_PREF_LTE ) &&
                           !(cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, SYS_MODEM_AS_ID_1)))
  {

    mode_pref_to_force = CM_MODE_PREF_CDMA_HDR_GW;
  }
  else if(ph_ptr->main_stack_info.pref_info.mode_pref == CM_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE)
  {
    /*Sub is already in global mode*/
    mode_pref_to_force = CM_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE;
  }
  else if(ph_ptr->main_stack_info.pref_info.mode_pref == CM_MODE_PREF_CDMA_HDR_GSM_LTE)
  {
    /*Sub is already in global mode in W disabled target*/
    mode_pref_to_force = CM_MODE_PREF_CDMA_HDR_GSM_LTE;
  }

  mode_pref_to_check = mode_pref_to_force;

   if ((cmph_is_msim() && ph_ptr->default_data_subs != SYS_MODEM_AS_ID_1) ||
       (ph_ptr->default_data_subs == SYS_MODEM_AS_ID_1 && ph_ptr->main_stack_info.pref_info.srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_ONLY))
  {
    if (cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_LTE, SYS_MODEM_AS_ID_1))
    {
      mode_pref_to_check = cm_remove_mode_pref_components(mode_pref_to_check, 1,
                                                                    SD_SS_MODE_PREF_GWL_LTE);
    }

    if (cmph_rat_disabled_mask_contain(ph_ptr, SYS_SYS_MODE_HDR, SYS_MODEM_AS_ID_1))
    {
      mode_pref_to_check = cm_remove_mode_pref_components(mode_pref_to_check, 1,
                                                                    SD_SS_MODE_PREF_HDR);
    }
  }

  if (ph_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_ASSERT_ENUM_IS_INRANGE(ss, SD_SS_MAX);


  /*Cancel Modem Reset Timer (if Running) as Stack is in valid acq state*/

  #if 0

  if ( cmss_modem_reset_trigger!= NULL )
  {
    CM_MSG_HIGH_0("Modem Reset Timer Running. Check status");
    if ( (  (cmss_modem_reset_trigger->as_id == SYS_MODEM_AS_ID_1) && (ss == SD_SS_MAIN)&&
            (ph_ptr->active_subs & SYS_MODEM_AS_ID_1_MASK))||
         (  (cmss_modem_reset_trigger->as_id == SYS_MODEM_AS_ID_2) && (ss == SD_SS_HYBR_2)&&
            (ph_ptr->active_subs & SYS_MODEM_AS_ID_2_MASK)) ||
         (  (cmss_modem_reset_trigger->as_id == SYS_MODEM_AS_ID_3) && (ss == SD_SS_HYBR_3)&&
            (ph_ptr->active_subs & SYS_MODEM_AS_ID_3_MASK))
       )
    {
      CM_MSG_HIGH_0("Cancel Modem Reset Timer. Sub in valid ACQ State");
      timer_clr(&cmss_modem_reset_timer, T_MIN);
      cmss_modem_reset_timer_fired=FALSE;
      cm_mem_free(cmss_modem_reset_trigger);
      cmss_modem_reset_trigger=NULL;
    }
  }
  #endif

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(!ss_ptr->disable_global_mode)
  {
    switch( ss )
    {
      case SD_SS_MAIN:
        /* Main stack lost service, sync the WLAN stack
        */
       CM_MSG_HIGH_5("full_srv_lost ss %d, main_stack_info net_type %d, mode_pref %d, band_3gpp %d, band_3gpp2 %d",
                ss,ph_ptr->main_stack_info.pref_info.network_type,
                ph_ptr->main_stack_info.pref_info.mode_pref,
                band_3gpp, band_3gpp2);
       CM_MSG_HIGH_3("full_srv_lost ph_ptr->mode_capability %d, main_stack_info net_sel_mode_pref %d, operator %d",
                ph_ptr->mode_capability,
                ph_ptr->main_stack_info.pref_info.network_sel_mode_pref,
                cm_get_operator_info(SYS_MODEM_AS_ID_1));



        if( ph_ptr->main_stack_info.pref_info.network_type == CM_MODE_PREF_NONE &&
          (ph_ptr->main_stack_info.pref_info.mode_pref != mode_pref_to_check ||
          ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL
          )&&
          band_3gpp && band_3gpp2 &&
          cm_get_operator_info(SYS_MODEM_AS_ID_1) == OPERATOR_CT &&
          mode_pref_to_force != CM_MODE_PREF_LTE_ONLY
          )
        {
          /* For SGLTE or 1x SxLTE cases when there is still service on HYBR2,
          * do not force AUTO mode pref for Sub1
          */
          if((cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) || cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)) 
          && cmss_ptr()->info.gw_srv_status == SYS_SRV_STATUS_SRV)
          {
            break;
          }
          
          if ( ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC)
          {
            int_net_sel_mode = CM_NETWORK_SEL_MODE_PREF_NO_CHANGE;
          }

          CM_MSG_HIGH_1("full_srv_lost: explorer with AUTO, net_sel_mode updated to %d",
                        int_net_sel_mode);

          (void)cm_ph_cmd_sys_sel_pref_per_subs( NULL,
                          NULL,
                          CM_CLIENT_ID_ANONYMOUS,
                          SYS_MODEM_AS_ID_1,
                          mode_pref_to_force,
                          CM_PREF_TERM_PERMANENT,
                          0,
                          CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                          CM_BAND_PREF_NO_CHANGE,
                          CM_PRL_PREF_NO_CHANGE,
                          CM_ROAM_PREF_NO_CHANGE,
                          CM_HYBR_PREF_NO_CHANGE,
                          CM_SRV_DOMAIN_PREF_NO_CHANGE,
                          int_net_sel_mode,
                          NULL
                          );
        }


         break;


      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
      default:

        break;

      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    }
  }
  else
  {
    CM_MSG_HIGH_0("Global mode is disabled by EFS");
    
    /* Send manual scan fail indication to AP for global mode */
    switch(ss)
    {
      case SD_SS_MAIN:
        if(ph_ptr->main_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
        {
          cmss_send_manual_scan_fail_ind(ss);
        }
        break;

      case SD_SS_HYBR_2:
        if(ph_ptr->hybr_2_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
        {
          cmss_send_manual_scan_fail_ind(ss);
        }
        break;

      #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
      case SD_SS_HYBR_3:
        if(ph_ptr->hybr_3_stack_info.pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
        {
          cmss_send_manual_scan_fail_ind(ss);
        }
        break;
      #endif

      default:
        break;
    }
  }

  /* Report full service lost to Policy Manager */
  as_id = cmph_map_cm_ss_to_subs(cmph_map_sd_ss_type_to_cm_ss_type(ss));
  if(ss == SD_SS_HYBR_1)
  {
    is_hybr1_full_srv_lost = TRUE;
  }
  else if(ss == SD_SS_HYBR_2)
  {
    is_hybr2_full_srv_lost = TRUE;
  }

  if(as_id == SYS_MODEM_AS_ID_1 && (ss == SD_SS_HYBR_1 || ss == SD_SS_HYBR_2) &&
     (cmph_is_subs_feature_mode_svlte(as_id) || 
      cmph_is_subs_feature_mode_srlte(as_id)) &&
     !((ss_ptr->info.hdr_hybrid && !ss_ptr->info.is_hybr_gw_operational &&
      is_hybr1_full_srv_lost)
      ||
      (!ss_ptr->info.hdr_hybrid && ss_ptr->info.is_hybr_gw_operational &&
      is_hybr2_full_srv_lost)
      ||
      (ss_ptr->info.hdr_hybrid && ss_ptr->info.is_hybr_gw_operational &&
      is_hybr1_full_srv_lost && is_hybr2_full_srv_lost))
     )
  {
    /* In SxLTE on Sub1, do not send full service lost to PM for
    ** second stack until all operational hybrid stacks have scanned
    ** and indicated full service lost
    */
    CM_MSG_HIGH_5("full_srv_lost, SxLTE, ss %d, full_srv_lost: hybr1 %d hybr2 %d, hdr_hybrid = %d, hybr_gw_oper = %d",
                  ss, is_hybr1_full_srv_lost, is_hybr2_full_srv_lost,
                  ss_ptr->info.hdr_hybrid, ss_ptr->info.is_hybr_gw_operational);
  }
  else
  {
    cmpmprx_report_full_srv_lost(
      as_id,
      (sys_modem_stack_id_e_type)cmss_map_ss_to_stack_info(cmph_map_sd_ss_type_to_cm_ss_type(ss)));
  }
  
  return;

} /* cmss_proc_full_srv_lost */

#ifdef FEATURE_CALL_THROTTLE

/*===========================================================================

FUNCTION cmss_orig_thr_add_table_enrty

DESCRIPTION
  This function adds a new entry to the origination throttle table

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
The throttle status of the added entry

SIDE EFFECTS
  None.
===========================================================================*/
static boolean cmss_orig_thr_add_tbl_entry
(

  cmss_orig_thr_table_s_type *thr_tbl_ptr,
    /* Pointer to the origination throttle table
    */

  cm_ss_orig_thr_call_status_s_type *thr_call_status
    /* Information about the current call status
    */
)
{

  boolean is_throttled   = FALSE;
  dword min_adj_time     = (dword) (-1);
  dword curr_adj_time    = 0;
  int q_counter = 0;

  cmss_orig_thr_table_q_type  *q_new_item_ptr = NULL;
  cmss_orig_thr_table_q_type  *q_item_ptr = NULL;
  cmss_orig_thr_table_q_type  *q_temp_item_ptr = NULL;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(thr_tbl_ptr == NULL || thr_call_status == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if there is a empty slot in the orig throttle table
  */
  q_counter = q_cnt(&(thr_tbl_ptr->cmss_orig_thr_q ));

  if(thr_tbl_ptr->num_valid_entries < CMSS_ORIG_THR_TABLE_MAX_ENTRIES)
  {
   /* Add this entry in the orig throttle table
      */
    q_new_item_ptr = (cmss_orig_thr_table_q_type *)cm_mem_malloc( sizeof(cmss_orig_thr_table_q_type));
    (void) q_link( q_new_item_ptr, &q_new_item_ptr->link );  /* init link */

    is_throttled = cmss_orig_thr_tbl_entry_info_put(
                                        &(q_new_item_ptr->cmss_orig_thr_tbl),
                                        thr_call_status );
    thr_tbl_ptr->num_valid_entries++;

    // check if this is the first entry into queue
    if ( q_counter == 0 )
    {
      q_put( &(thr_tbl_ptr->cmss_orig_thr_q), &q_new_item_ptr->link);
    }
    else
    {
      /* Insert the new system at the beginning of the queue*/
#ifdef FEATURE_Q_NO_SELF_QPTR
      q_insert( &(thr_tbl_ptr->cmss_orig_thr_q),
             & q_new_item_ptr->link,
             & ((cmss_orig_thr_table_q_type*) q_check( &(thr_tbl_ptr->cmss_orig_thr_q) ))->link );
#else
      q_insert( & q_new_item_ptr->link,
             & ((cmss_orig_thr_table_q_type*) q_check( &(thr_tbl_ptr->cmss_orig_thr_q) ))->link );

#endif /* FEATURE_Q_NO_SELF_QPTR */
    }

    CM_MSG_HIGH_2(" Added new entry to Orig. Thr. Tbl. Slots avail. %d. Added bc 0x%x",
                                  thr_tbl_ptr->num_valid_entries,
    							  thr_call_status->mode_info.cdma_info.band_class);

    sd_misc_sys_id_print( thr_call_status->sys_id );

    return is_throttled ;

  }

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, we need to remove the oldest entry in the orig throttle
  ** table and add this item into Q
    */

  if(  q_counter  > 0)
  {
    q_item_ptr = q_check(&(thr_tbl_ptr->cmss_orig_thr_q));
    if( NULL == q_item_ptr )
    {
      sys_err_fatal_null_ptr_exception();
    }
  }

  for(; (q_counter > 0) && (q_item_ptr != NULL); q_counter--)
  {
     if(cmss_is_hard_failure_throttle_reason (
             q_item_ptr->cmss_orig_thr_tbl.orig_call_info.call_status))

    {
      curr_adj_time = q_item_ptr->cmss_orig_thr_tbl.thr_uptime -
                                        cmss_ptr()->hard_fail_thr_period;
    }
    else
    {
      curr_adj_time = q_item_ptr->cmss_orig_thr_tbl.thr_uptime -
                      thr_time[q_item_ptr->cmss_orig_thr_tbl.idx];

      CM_ASSERT( q_item_ptr->cmss_orig_thr_tbl.thr_uptime >=
               thr_time[q_item_ptr->cmss_orig_thr_tbl.idx] );
    }

    if( curr_adj_time < min_adj_time )
    {
       min_adj_time = curr_adj_time;
//       ins_pos      = i;
       q_temp_item_ptr = q_item_ptr;
    }
    q_item_ptr = q_next(&(thr_tbl_ptr->cmss_orig_thr_q), &(q_item_ptr->link));
  }

 if(q_temp_item_ptr != NULL)
  {
    sd_misc_sys_id_print(
            q_temp_item_ptr->cmss_orig_thr_tbl.orig_call_info.sys_id );
#ifdef FEATURE_Q_NO_SELF_QPTR
    q_delete( &(thr_tbl_ptr->cmss_orig_thr_q), &q_temp_item_ptr->link );
#else
    q_delete( &q_temp_item_ptr->link );
#endif

  (void) memset( &q_temp_item_ptr->cmss_orig_thr_tbl.orig_call_info.mode_info, 0,
                 sizeof( cm_ss_orig_thr_ss_info_u_type ));

    cm_mem_free(q_temp_item_ptr);
    CM_MSG_HIGH_0( "Deleted entry from Orig. Thr. Tbl.");

  }
  /* Add this entry in the orig throttle table
  */
  q_new_item_ptr = (cmss_orig_thr_table_q_type *)cm_mem_malloc( sizeof(cmss_orig_thr_table_q_type));
  (void) q_link( q_new_item_ptr, &q_new_item_ptr->link );  /* init link */

  is_throttled = cmss_orig_thr_tbl_entry_info_put(
                                    &(q_new_item_ptr->cmss_orig_thr_tbl),
                                    thr_call_status);

  q_counter = q_cnt(&(thr_tbl_ptr->cmss_orig_thr_q ));
// check if this is the first entry into queue
  if ( q_counter == 0 )
  {
    q_put( &(thr_tbl_ptr->cmss_orig_thr_q), &q_new_item_ptr->link);
  }
  else
  {
    /* Insert the new system at the beginning of the queue*/
#ifdef FEATURE_Q_NO_SELF_QPTR
    q_insert( &(thr_tbl_ptr->cmss_orig_thr_q),
           & q_new_item_ptr->link,
           & ((cmss_orig_thr_table_q_type*) q_check( &(thr_tbl_ptr->cmss_orig_thr_q) ))->link );
#else
    q_insert( & q_new_item_ptr->link,
           & ((cmss_orig_thr_table_q_type*) q_check( &(thr_tbl_ptr->cmss_orig_thr_q) ))->link );

#endif /* FEATURE_Q_NO_SELF_QPTR */
  }

  return is_throttled ;

} /* cmss_orig_thr_add_tbl_entry */



/*===========================================================================

FUNCTION cmss_orig_thr_update_tbl_entry

DESCRIPTION
  This function should be called to update a particular origination throttle
  table with the call status

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  The throttle status of the updated entry.

SIDE EFFECTS
  None.
===========================================================================*/

static boolean cmss_orig_thr_update_tbl_entry(

  cmss_orig_thr_table_entry_s_type *tbl_entry_ptr,
    /* The pointer to the particular table entry
    */

  const cm_ss_orig_thr_call_status_s_type *thr_call_status
    /* The throttle status of the call
    */
)
{
  cmph_s_type  *ph_ptr = cmph_ptr();
  dword        uptime  = time_get_uptime_secs();
  unsigned int r_value = 0;
  unsigned int accolc  = 0;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT( tbl_entry_ptr != NULL );
  CM_ASSERT( ph_ptr != NULL );
  CM_ASSERT( thr_call_status != NULL );
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Update the table entry with the new throttle status
  */
  tbl_entry_ptr->orig_call_info.call_status = thr_call_status->call_status;
  tbl_entry_ptr->orig_call_info.call_type   = thr_call_status->call_type;
  tbl_entry_ptr->orig_call_info.sys_id      = thr_call_status->sys_id;
  tbl_entry_ptr->orig_call_info.mode_info   = thr_call_status->mode_info;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* If the throttle reason is a hard failure , use fixed time throttling
  */
  if(cmss_is_hard_failure_throttle_reason(thr_call_status->call_status))
  {
    tbl_entry_ptr->thr_uptime = uptime + cmss_ptr()->hard_fail_thr_period;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If the throttle reason is not a hard failure , use telescopic throttling
  ** which is determined by the thr_time[idx]. For non jcdma, when the system
  ** has been throttled  cmss_orig_thr_max_timer times, any further
  ** throttling causes the throttle time to be set to the maximum value (15 mins)
  ** For JCDMA , the counter is reset once this happens.
  */
  else
  {
    if(tbl_entry_ptr->idx < cmss_orig_thr_max_timer - 1)
    {
      tbl_entry_ptr->idx++;
    }
    else if(cm_is_jcdma_enable())
    {
      /* Restart the counter to 1.
      */
      tbl_entry_ptr->idx = 1;
    }

    tbl_entry_ptr->thr_uptime                 = time_get_uptime_secs() +
                                              thr_time[tbl_entry_ptr->idx];

    CM_MSG_MED_2("Orig Thr Tbl idx=%d, cmss_orig_thr_max_timer=%d ",tbl_entry_ptr->idx,cmss_orig_thr_max_timer);

    /* Check if we are starting the timer, if we are then randomize the
    ** backoff time
    */
    if( (tbl_entry_ptr->idx > 0) && (thr_time[tbl_entry_ptr->idx - 1] == 0) &&
        (thr_time[tbl_entry_ptr->idx] !=0) && ((int) ph_ptr->accolc < 10) )
    {
      /*Get r_value */
      accolc = (unsigned int)(ph_ptr->accolc * CMSS_ORIG_THR_RND_INT *1000);
      r_value = ROUNDOFF(accolc, 1000);

      tbl_entry_ptr->thr_uptime+= r_value;
    }
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_2( " Orig. Thr. Tbl. updated thr uptime %d uptime %d",
                                            tbl_entry_ptr->thr_uptime,
                                            time_get_uptime_secs());
  sd_misc_sys_id_print( tbl_entry_ptr->orig_call_info.sys_id );

  if(  tbl_entry_ptr->thr_uptime > uptime)
  {
    return TRUE;
  }

  return FALSE;
} /* cmss_orig_thr_update_tbl_entry */


/*===========================================================================

FUNCTION cmss_is_orig_successful

DESCRIPTION
  This function checks if the throttle reason given is one of the reasons for
  call success

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  is the call was successful
  FALSE otherwise

SIDE EFFECTS
  None.
===========================================================================*/

static boolean cmss_is_orig_successful(
  cm_ss_orig_thr_reasons_e_type thr_reason
    /* The end reason
    */
)
{
  switch(thr_reason)
  {

    case CM_SS_ORIG_THR_DS_MIP_UP_SUCCESS:
      /* MIP Success
      */
    case CM_SS_ORIG_THR_DS_PPP_UP_SUCCESS:
     /* PPP Success
     */
    case CM_SS_ORIG_THR_DS_V6_SUCCESS:
     /* IPv6 setup Success
     */
      return TRUE;

    default:
      return FALSE;
  }
}


/*===========================================================================

FUNCTION cmss_orig_thr_update_tbl_entry_with_call_status

DESCRIPTION
  This function should be called to update the origination throttle table
  with the call status

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  The throttle status of the added/modified entry.

SIDE EFFECTS
  None.
===========================================================================*/
boolean cmss_orig_thr_update_tbl_entry_with_call_status
(
  cmss_orig_thr_table_s_type *thr_tbl_ptr,
    /* Pointer to the origination throttle table
    */
  cm_ss_orig_thr_call_status_s_type *thr_call_status
    /* Information about the current call status
    */
)
/*lint -esym(818, thr_call_status)
*/
{
  boolean       is_throttled           = FALSE;

  cmss_orig_thr_table_q_type* thr_tbl_entry_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(thr_tbl_ptr == NULL || thr_call_status == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  thr_tbl_entry_ptr = cmss_orig_thr_get_orig_tbl_entry(
                           thr_tbl_ptr,
                           thr_call_status->sys_id,
                           thr_call_status->mode_info.cdma_info.band_class,
                           thr_call_status->mode_info.cdma_info.packet_zone );

  if( thr_tbl_entry_ptr != NULL )
  {
    if( cmss_is_orig_successful(thr_call_status->call_status) )
    {
      /* Reset the entry as the call was succesful
      */
      CM_MSG_HIGH_0( "Reseting Orig. Thr. Tbl. entry");
      sd_misc_sys_id_print( thr_tbl_entry_ptr->cmss_orig_thr_tbl.orig_call_info.sys_id );
      cmss_orig_thr_reset_tbl_entry( thr_tbl_ptr, thr_tbl_entry_ptr );
      thr_tbl_entry_ptr = NULL;
      if (thr_tbl_ptr->num_valid_entries)
      {
      thr_tbl_ptr->num_valid_entries--;
      }

    } /* cmss_is_orig_successful */
    else
    {

      /* Calls are not throttled if uptime >= Thrttl time, so CM-clients
      ** may need to update Thrttl tbl. so allow the update, else
      ** ignore.
      */
      if( time_get_uptime_secs() >= thr_tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime )
      {
        is_throttled = cmss_orig_thr_update_tbl_entry(
                                       &(thr_tbl_entry_ptr->cmss_orig_thr_tbl), thr_call_status );
      }
      else
      {
        /* We should never get here.
        */
        CM_MSG_HIGH_0("curr sys not throttled, no need to update tbl");
        CM_ASSERT( FALSE );
      }

    } /* else cmss_is_call_successful */

  } /* if( thr_tbl_entry_ptr != NULL ) */
  else
  {
    /* We did not find a match for the SID/PZID in the table, add a new
    ** entry. If we need to add new throttling information, add this entry
    **  in the origination throttle table.
    */
    if( !cmss_is_orig_successful( thr_call_status->call_status ))
    {
      is_throttled = cmss_orig_thr_add_tbl_entry( thr_tbl_ptr, thr_call_status );
    }

    /* Else, return FALSE
    */
    else
    {
      CM_MSG_HIGH_0(" Orig. Thr. Tbl. Entry not found");
      sd_misc_sys_id_print( thr_call_status->sys_id );

      return FALSE;
    }
  }/* else if( thr_tbl_entry_ptr != NULL ) */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* We either added a new entry or modified an existing entry, so need to
  ** report this to the clients
  */
  cmss_event( CM_SS_MAIN, CM_SS_EVENT_ORIG_THR_TBL_UPDATE );

  /* If throttle status changed, informed clients.
  */
  cmss_misc_set_ss_info_thr_status();

  return ( is_throttled );

}/* cmss_orig_thr_update_tbl_with_call_status */
/*lint +esym(818, thr_call_status)
*/

/*===========================================================================

FUNCTION cmss_map_call_end_status_thr_status

DESCRIPTION
  This function maps the call_end status to the throttle status

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  Throttle reason.

SIDE EFFECTS
  None.
===========================================================================*/
static cm_ss_orig_thr_reasons_e_type cmss_map_call_end_status_to_thr_status
(
  cm_call_end_e_type call_end_status
    /* The call end reason
    */
)
{
  switch(call_end_status)
  {
    /* Received Intercept from BS
    */
    case CM_CALL_END_INTERCEPT:
      return( CM_SS_ORIG_THR_CM_INTERCEPT );

    /* SO Reject
    */
    case CM_CALL_END_REL_SO_REJ:
       return( CM_SS_ORIG_THR_CM_REL_SO_REJ );

    default:
      return( CM_SS_ORIG_THR_REASON_NONE );

  } /* switch */
} /* cmss_map_call_end_status_to_thr_status */


/*===========================================================================

FUNCTION cmss_check_if_orig_thr_end_status

DESCRIPTION
  This function checks is the origination needs to be throttled due to
  indication from lower layers

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  True if end status needs to be throttled
  False otherwise.

SIDE EFFECTS
  None.
===========================================================================*/

static boolean cmss_check_if_orig_thr_end_status(
  cm_call_end_e_type end_status
    /* Call end reason
    */
)
{
 switch(end_status)
   {
      case CM_CALL_END_INTERCEPT:
      case CM_CALL_END_REL_SO_REJ:
       return TRUE;
       /* Return true for all the above cases
       */
     default:
       return FALSE;
 } /* switch (end_status) */
}/* cmss_check_if_orig_thr_end_status */


/*===========================================================================

FUNCTION cmss_check_if_orig_thr_true

DESCRIPTION
  This function checks is the origination needs to be throttled

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  True if the origination needs to be throttled
  False otherwise.

SIDE EFFECTS
  None.
===========================================================================*/
boolean cmss_check_if_orig_thr_true
(
  sys_sys_id_s_type           sys_id,
    /* The sys id of the system, SID,NID/PZID
    */

  sys_band_class_e_type       band_class,
    /* The band class information
    */

  cmss_orig_thr_table_s_type *thr_tbl_ptr,
    /* Origination throttle table pointer
    */

  cm_call_type_e_type         call_type,
    /* Call type - VOICE, SMS, E911, etc
    */

  uint16                      packet_zone
    /* The packet zone id
    */

)
{

  dword uptime = time_get_uptime_secs();
  cmss_orig_thr_table_q_type *thr_tbl_entry_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(thr_tbl_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  
  sd_misc_sys_id_print( sys_id );

  thr_tbl_entry_ptr = cmss_orig_thr_get_orig_tbl_entry(
                           thr_tbl_ptr, sys_id, band_class, packet_zone );

  if( thr_tbl_entry_ptr == NULL )
  {
    return FALSE;
  }

  CM_MSG_HIGH_2(" Orig. Thr. uptime %d curr uptime %d",
                                  thr_tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime, uptime);
  if( call_type != CM_CALL_TYPE_NONE )
  {
    return( CM_BOOLEAN
            (
             ( call_type == thr_tbl_entry_ptr->cmss_orig_thr_tbl.orig_call_info.call_type )
                         &&
             ( uptime     < thr_tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime )
            )
           );

  }
  if( uptime < thr_tbl_entry_ptr->cmss_orig_thr_tbl.thr_uptime )
  {
    return TRUE;
  }

  return FALSE;

} /* cmss_check_if_orig_thr_true */


/*===========================================================================

FUNCTION cmss_initialize_thr_status

DESCRIPTION
  This function initializes the throttle status pointer to the values passed

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
static void cmss_initialize_thr_status(

  cm_ss_orig_thr_call_status_s_type *throttle_status,
    /* The pointer to be initialized
    */

  cm_call_type_e_type                call_type,
    /* Call Type
    */

  cm_call_end_e_type                 end_status,
    /* Call end status
    */

  const cmss_s_type                       *ss_ptr,
    /* Pointer to the ss object
    */
  boolean                            is_hdr_sys_id
    /* Flag to use hdr_sys_id
    */
)
{

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT(throttle_status != NULL);
  CM_ASSERT(ss_ptr          != NULL);
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  throttle_status->call_type    = call_type;
  throttle_status->mode_info.cdma_info = ss_ptr->info.mode_info.cdma_info;
  throttle_status->call_status  =
                          cmss_map_call_end_status_to_thr_status(end_status);

  if( !is_hdr_sys_id )
  {
    throttle_status->sys_id     = ss_ptr->info.sys_id;
    throttle_status->mode_info.cdma_info.band_class = ss_ptr->info.active_band;
  }
  else
  {
    throttle_status->sys_id     = ss_ptr->info.hdr_sys_id;
    throttle_status->mode_info.cdma_info.band_class = ss_ptr->info.hybrid_active_band;
  }

  return;
} /* cmss_initialize_thr_status */



/*===========================================================================

FUNCTION cmss_check_if_orig_thr_and_add_entry

DESCRIPTION
  This function checks if the call origination needs to be throttled, and
  if it needs to be throttled then adds a entry in the origination throttle
  table

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  True: If the call is throttled and the entry made in the table
  False: Otherwise

SIDE EFFECTS
  None.
===========================================================================*/
boolean cmss_check_if_orig_thr_and_add_entry(
  const cmss_s_type          *ss_ptr,
    /* The pointer to the serving system object
    */

  cm_call_type_e_type   call_type,
    /* Call type - VOICE, SMS, E911, etc
    */
  cm_call_end_e_type    end_status,
    /* Call end status
    */
  boolean               is_hdr
    /* Flag to use hdr_sys_id
    */
 )
{

  boolean is_orig_throttle = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  CM_ASSERT( ss_ptr != NULL );
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if( call_type != CM_CALL_TYPE_PS_DATA )
  {
    return FALSE;
  }

  is_orig_throttle = cmss_check_if_orig_thr_end_status( end_status );

  if( is_orig_throttle )
  {
    cm_ss_orig_thr_call_status_s_type throttle_status;

    if( !is_hdr )
    {
      cmss_initialize_thr_status( &throttle_status,
                                   call_type,
                                   end_status,
                                   ss_ptr,
                                   FALSE );
    }
    else
    {
      cmss_initialize_thr_status( &throttle_status,
                                   call_type,
                                   end_status,
                                   ss_ptr,
                                   TRUE );
    }

    /* We are ignoring NID, so replace it with the wild card nid
    */

    if( throttle_status.sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
    {
      throttle_status.sys_id.id.is95.nid  = SD_WILDCARD_NID;
    }

    is_orig_throttle =  cmss_orig_thr_update_tbl_entry_with_call_status(
                                               ss_ptr->cmss_orig_thr_tbl_ptr,
                                               &throttle_status );
    return( is_orig_throttle ) ;

  } /* if(is_orig_throttle) */

  return FALSE;
}/* cmss_check_if_orig_thr_add_entry */


/*===========================================================================

FUNCTION cmss_misc_set_ss_info_thr_status

DESCRIPTION
  This function ssets the ss_thr_status of the ss object

DEPENDENCIES

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/

void cmss_misc_set_ss_info_thr_status()
{
  if(cmss_update_thr_status())
  {
    cmss_event(CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED);
  }
  return;

}/* cmss_misc_set_ss_info_thr_status */

#endif /* FEATURE_CALL_THROTTLE */


sys_sys_mode_e_type cmss_map_access_tech_to_sys_mode
(
  sys_radio_access_tech_e_type rat
)
{
  sys_sys_mode_e_type sys_mode = SYS_SYS_MODE_NO_SRV;

  switch(rat)
  {
    case SYS_RAT_GSM_RADIO_ACCESS:
      sys_mode = SYS_SYS_MODE_GSM;
      break;
    
    case SYS_RAT_UMTS_RADIO_ACCESS:
      sys_mode = SYS_SYS_MODE_WCDMA;
      break;
    
    case SYS_RAT_LTE_RADIO_ACCESS:
      sys_mode = SYS_SYS_MODE_LTE;
      break;
    
    case SYS_RAT_TDS_RADIO_ACCESS:
      sys_mode = SYS_SYS_MODE_TDS;
      break;
    
    default:
      sys_mode = SYS_SYS_MODE_NO_SRV;
      break;
  }

  return sys_mode;
  
}

/*===========================================================================

FUNCTION cmss_get_ss_main_info_change

DESCRIPTION
  Compares the serving system information change and returns
  a bit mask holding difference.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  Bit Mask indicating which of the Serving System parameters changed

SIDE EFFECTS
  none

===========================================================================*/
static uint64 cmss_get_ss_main_info_change(

    const cm_mm_ss_info_s_type     *new_srv_info,
        /*  New SS information */

    const cm_mm_msim_ss_info_s_type  *old_srv_info,
        /*  Old SS information */

    uint64 *changed_fields2
)
/*lint -esym(715,changed_fields2)*/
/*lint -esym(818,changed_fields2)*/
{

  uint8                             stk_id =  cmss_map_ss_to_stack_info(CM_SS_MAIN);

      /* Records the changes in SS parameters between new_srv_info and old_srv_info */
  uint64                        changed_fields = 0;

  /* Point at serving system object to be initialized */
  #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined(FEATURE_WCDMA))
  cmss_s_type          *ss_ptr        =  cmss_ptr();
  #endif
  /*lint -esym(529, ss_ptr) not referenced */


  const sys_time_info_s_type         *old_time = &(old_srv_info->stack_info[0].mode_info.cdma_info.time_info);

  const sys_time_info_s_type         *new_time = CDMA_TIME_PTR(new_srv_info);

  if ((new_srv_info != NULL) && (old_srv_info != NULL))
  {
    /*
    ** If service state changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->srv_status != old_srv_info->stack_info[stk_id].srv_status )
    {
      changed_fields |= CM_SS_SRV_STATUS_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If true service status changed,
    ** then also notify CM clients of the event.
    */
    if (new_srv_info->true_srv_status != old_srv_info->stack_info[stk_id].true_srv_status )
    {
      changed_fields |= CM_SS_TRUE_SRV_STATUS_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If system mode changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->sys_mode != old_srv_info->stack_info[stk_id].sys_mode )
    {
      changed_fields |= CM_SS_SYS_MODE_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If active band changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->active_band != old_srv_info->stack_info[stk_id].active_band )
    {
      changed_fields |= CM_SS_ACTIVE_BAND_MASK;
    }

    /*
    ** If active chan changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->active_channel != old_srv_info->stack_info[stk_id].active_channel )
    {
      changed_fields |= CM_SS_ACTIVE_CHANNEL_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If roaming status changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->roam_status != old_srv_info->stack_info[stk_id].roam_status )
    {
      changed_fields |= CM_SS_ROAM_STATUS_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If srv domain changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->srv_domain != old_srv_info->stack_info[stk_id].srv_domain )
    {
      changed_fields |= CM_SS_SRV_DOMAIN_MASK;
    }


    /* Set the mask if SRV_EVENT_CHANGED is in response to CM_SS_CMD_GET_DCH_CELL_ID */
    #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined(FEATURE_WCDMA))

    /* Set the mask if SS event is due to CELL_INFO_CNF from RRC */
    if(new_srv_info->sys_mode == SYS_SYS_MODE_WCDMA)
    {
    if (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
    {
      changed_fields |= CM_SS_CELLID_DCH_MASK;
    }
    else
    {
      ss_ptr->info.changed_fields &= (~CM_SS_CELLID_DCH_MASK);
    }
    }
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If srv capability changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->srv_capability != old_srv_info->stack_info[stk_id].srv_capability )
    {
      changed_fields |= CM_SS_SRV_CAPABILITY_MASK;
    }

    /*
    ** If the system identifier has changed, notify CM clients of the
    ** corresponding event.
    */
    if ( !cmss_sys_id_match( new_srv_info->sys_id, old_srv_info->stack_info[stk_id].sys_id ) )
    {
      changed_fields |= CM_SS_SYS_ID_MASK;

      #ifdef CM_GW_SUPPORTED
      /*
      ** If the PLMN changed or there is no service, then clear the mobility
      ** management information.
      */
      if (((CM_IS_MODE_3GPP(old_srv_info->stack_info[stk_id].sys_mode))||(CM_IS_MODE_3GPP(new_srv_info->sys_mode)))
        && new_srv_info->sys_mode == cmss_map_access_tech_to_sys_mode(new_srv_info->mode_info.gw_info.mm_information.rat))
      {
        changed_fields |= CM_SS_MOBILITY_MGMT_MASK;
      }

      #endif  /* FEATURE_WCDMA || FEATURE_GSM */

      /*
      ** Decide whether the SID and NID Mask fields need to be set also.
      */
      if ((new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_IS95) &&
          (old_srv_info->stack_info[stk_id].sys_id.id_type == SYS_SYS_ID_TYPE_IS95))
      {
        if (new_srv_info->sys_id.id.is95.nid != old_srv_info->stack_info[stk_id].sys_id.id.is95.nid)
        {
          changed_fields |= CM_SS_NID_MASK;
        }

        if (new_srv_info->sys_id.id.is95.sid != old_srv_info->stack_info[stk_id].sys_id.id.is95.sid)
        {
          changed_fields |= CM_SS_SID_MASK;
        }
        if( new_srv_info->sys_id.id.is95.mcc != old_srv_info->stack_info[stk_id].sys_id.id.is95.mcc )
        {
          changed_fields |= CM_SS_MCC_MASK;
        }

        if(new_srv_info->sys_id.id.is95.imsi_11_12 != old_srv_info->stack_info[stk_id].sys_id.id.is95.imsi_11_12 )
        {
          changed_fields |= CM_SS_IMSI_11_12_MASK;
        }
      }
      else if ((new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_IS95) &&
               (old_srv_info->stack_info[stk_id].sys_id.id_type != SYS_SYS_ID_TYPE_IS95))
      {
         changed_fields |= CM_SS_NID_MASK;
         changed_fields |= CM_SS_SID_MASK;
         changed_fields |= CM_SS_MCC_MASK;
         changed_fields |= CM_SS_IMSI_11_12_MASK;
      }
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If default roaming indicator changed, notify CM clients of the
    ** corresponding event.
    */
    if ( new_srv_info->def_roam_ind != old_srv_info->def_roam_ind )
    {
      changed_fields |= CM_SS_DEF_ROAM_IND_MASK;
    }

    /*
    ** If prl match status changed, notify CM clients of the
    ** corresponding event.
    */
    if ( new_srv_info->is_sys_prl_match != old_srv_info->stack_info[stk_id].is_sys_prl_match )
    {
      changed_fields |= CM_SS_SYS_PRL_MATCH_MASK;
    }

    /*
    ** If system forbidden status changed, notify CM clients of the
    ** corresponding event.
    */
    if ( new_srv_info->is_sys_forbidden != old_srv_info->stack_info[stk_id].is_sys_forbidden )
    {
      changed_fields |= CM_SS_SYS_FORBIDDEN_MASK;
    }


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** Check if any mode specific info changed - base station lat or long or
    ** base id or srch_win_n.
    */
    if ( new_srv_info->sys_mode == SYS_SYS_MODE_CDMA  &&
         old_srv_info->stack_info[stk_id].sys_mode == new_srv_info->sys_mode &&
         ( new_srv_info->mode_info.cdma_info.base_lat !=
                                 old_srv_info->stack_info[stk_id].mode_info.cdma_info.base_lat ||
           new_srv_info->mode_info.cdma_info.base_long !=
                                 old_srv_info->stack_info[stk_id].mode_info.cdma_info.base_long ||
           new_srv_info->mode_info.cdma_info.base_id !=
                                     old_srv_info->stack_info[stk_id].mode_info.cdma_info.base_id ||
           new_srv_info->mode_info.cdma_info.srch_win_n !=
                                     old_srv_info->stack_info[stk_id].mode_info.cdma_info.srch_win_n
         )
       )
    {
      changed_fields |= CM_SS_BASE_STATION_PARMS_CHGD_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If throttle status on main (1x or non hybrid HDR)
    ** has changed notify CM clients of the corresponding event.
    */
    #ifdef FEATURE_CALL_THROTTLE
    if (   new_srv_info->main_thr_status.ss_thr_status !=
           old_srv_info->stack_info[stk_id].thr_status.ss_thr_status
       )
    {
      changed_fields |= CM_SS_ORIG_THR_STATUS_MASK;
    }
    #endif /* FEATURE_CALL_THROTTLE */

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If the HDR system identifier has changed, notify CM clients of the
    ** corresponding event.
    */
    #ifdef FEATURE_HDR_HYBRID

    if(new_srv_info->sys_mode == SYS_SYS_MODE_HDR || new_srv_info->gw_sys_mode == SYS_SYS_MODE_HDR)
    {
      if ( !cmss_sys_id_match( new_srv_info->hdr_sys_id, old_srv_info->stack_info[1].sys_id ) )
    {
      changed_fields |= CM_SS_HDR_SYS_ID_MASK;
    }
    }
    #endif /* FEATURE_HYBR_HDR */

    if( new_srv_info->psist != old_srv_info->stack_info[stk_id].psist )
    {
      changed_fields |= CM_SS_PSIST_CHGD_MASK;
    }
    #if defined (FEATURE_LTE_TO_1X)
    if( new_srv_info->is_csfb_call_active != old_srv_info->is_csfb_call_active )
    {
      changed_fields |= CM_SS_CSFB_CALL_ACTIVE_MASK;
    }
    #endif
    #ifdef FEATURE_BCMCS
    if( new_srv_info->ss_main_bcmcs_srv_status !=
          old_srv_info->stack_info[stk_id].bcmcs_srv_status )
    {
      changed_fields |= CM_SS_MAIN_BCMCS_SRV_STATUS_MASK;
    }
    #endif
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*lint -save -e539 -e525 */
    /* If HS indication has changed, set mask
    */
    if( new_srv_info->cell_srv_ind.hs_ind
    != old_srv_info->stack_info[stk_id].cell_srv_ind.hs_ind )
    {
      changed_fields |= CM_SS_SRV_IND_MASK;
    }

  /* If HS call indication has changed, set mask
    */
  if ( new_srv_info->cell_srv_ind.hs_call_status
       != old_srv_info->stack_info[stk_id].cell_srv_ind.hs_call_status)
    {
      changed_fields |= CM_SS_SRV_IND_MASK;
    }

    /* If DTM indication has changed, set mask
    */
    if ( new_srv_info->cell_srv_ind.dtm_supp
    != old_srv_info->stack_info[stk_id].cell_srv_ind.dtm_supp )
    {
      changed_fields |= CM_SS_SRV_IND_MASK;
    }
    /* If EGPRS indication has changed, set mask
    */
    if ( new_srv_info->cell_srv_ind.egprs_supp
    != old_srv_info->stack_info[stk_id].cell_srv_ind.egprs_supp )
    {
      changed_fields |= CM_SS_SRV_IND_MASK;
    }

    /*
    ** Check if cell_info specific info changed
    */

    if ((new_srv_info->cell_info.cell_id != old_srv_info->stack_info[stk_id].cell_info.cell_id )||
    (new_srv_info->cell_info.as_sys_mode != old_srv_info->stack_info[stk_id].cell_info.as_sys_mode ) ||
        (new_srv_info->cell_info.plmn_id.identity[0] != old_srv_info->stack_info[stk_id].cell_info.plmn_id.identity[0]) ||
        (new_srv_info->cell_info.plmn_id.identity[1] != old_srv_info->stack_info[stk_id].cell_info.plmn_id.identity[1]) ||
        (new_srv_info->cell_info.plmn_id.identity[2] != old_srv_info->stack_info[stk_id].cell_info.plmn_id.identity[2]))

    {
      changed_fields |= CM_SS_CELL_INFO_MASK;
    }


    if(new_srv_info->cell_info.emerg_access_status != old_srv_info->stack_info[stk_id].cell_info.emerg_access_status)
    {
      *changed_fields2 |= CM_SS_LTE_EMERG_ACCESS_BARRED_MASK;
    }

    if(new_srv_info->cell_info.lte_cell_access_status != old_srv_info->stack_info[stk_id].cell_info.lte_cell_access_status)
    {
      *changed_fields2 |= CM_SS_LTE_CELL_ACCESS_STATUS_MASK;
    }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

 /*lint -restore */

  #ifdef FEATURE_HDR

  /* If HDR active protocol is changed, set mask
  */
  

  if(new_srv_info->sys_mode == SYS_SYS_MODE_HDR || new_srv_info->hdr_srv_status == SYS_SRV_STATUS_SRV 
    || old_srv_info->stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_1)].sys_mode == SYS_SYS_MODE_HDR)
  {
    if( new_srv_info->hdr_active_prot != old_srv_info->stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_1)].rat_mode_info.hdr_mode_info.hdr_active_prot )
  {
    changed_fields |= CM_SS_HDR_ACTIVE_PROT_MASK;
  }

  /* If HDR personality is changed, set mask
  */

    if( new_srv_info->hdr_personality != old_srv_info->stack_info[cmss_map_ss_to_stack_info(CM_SS_HYBR_1)].rat_mode_info.hdr_mode_info.hdr_personality )
  {
    changed_fields |= CM_SS_HDR_PERSONALITY_MASK;
  }
  }
  #endif //FEATURE_HDR

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if ((new_srv_info->sys_mode == SYS_SYS_MODE_WCDMA)
      ||
      (new_srv_info->sys_mode == SYS_SYS_MODE_GSM)
      ||
      (new_srv_info->sys_mode == SYS_SYS_MODE_LTE))
  {
    transition_rats = TRUE;
  }

  /*
  ** If there is a CDMA time change, notify clients
  ** Note that the UE may traverse between 3GPP and 3GPP2, and the
  ** new_time, old_time are part of the union.
  */
  /* Transition to CDMA or HDR */
  if ( ( new_srv_info->sys_mode == SYS_SYS_MODE_CDMA||
         new_srv_info->sys_mode == SYS_SYS_MODE_HDR))
  {
    if ( old_srv_info->stack_info[stk_id].sys_mode == SYS_SYS_MODE_CDMA||
         old_srv_info->stack_info[stk_id].sys_mode == SYS_SYS_MODE_HDR)
    {
      transition_rats = FALSE;
      if(new_time->sys_mode != old_time->sys_mode)
      {
        CM_MSG_HIGH_2("time:main-old mode %d new mode %d",
                               old_time->sys_mode,
                               new_time->sys_mode);
        changed_fields |= CM_SS_CDMA_TIME_CHGD_MASK;
      }
    }
    else
    {
      transition_rats = TRUE;
      changed_fields |= CM_SS_CDMA_TIME_CHGD_MASK;
    }
      /* The new service is CDMA or HDR */
    if (new_time->sys_mode == SYS_SYS_MODE_CDMA)
    {
       if( (new_time->time.cdma_time.daylt_savings !=
           old_time->time.cdma_time.daylt_savings) ||
          (new_time->time.cdma_time.ltm_offset !=
          old_time->time.cdma_time.ltm_offset) ||
          (new_time->time.cdma_time.lp_sec !=
          old_time->time.cdma_time.lp_sec) )
       {
         changed_fields |= CM_SS_CDMA_TIME_CHGD_MASK;

       CM_MSG_HIGH_6("time:cdma - old daylt %d new daylt %d old ltm %d, new ltm %d old lpsec %d new lpsec %d",
                            old_time->time.cdma_time.daylt_savings,
                            new_time->time.cdma_time.daylt_savings,
                    old_time->time.cdma_time.ltm_offset,
                   new_time->time.cdma_time.ltm_offset,
                   old_time->time.cdma_time.lp_sec,
                   new_time->time.cdma_time.lp_sec);
       }
    }//if (new_time->sys_mode == SYS_SYS_MODE_CDMA)
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    if (new_time->sys_mode == SYS_SYS_MODE_HDR)
    {
       if( (new_time->time.hdr_time.ltm_offset != old_time->time.hdr_time.ltm_offset) ||
           (new_time->time.hdr_time.lp_sec     != old_time->time.hdr_time.lp_sec) )
       {
          changed_fields |= CM_SS_CDMA_TIME_CHGD_MASK;
          CM_MSG_HIGH_4("time:hdr - old ltm %d new ltm %d old lpsec %d new lpsec %d ",
                 old_time->time.hdr_time.ltm_offset,
                 new_time->time.hdr_time.ltm_offset,
             old_time->time.hdr_time.lp_sec,
             new_time->time.hdr_time.lp_sec);
		  
       }
    } //if (new_time->sys_mode == SYS_SYS_MODE_HDR)
  } // time conditions
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*
  ** If in GW service, LAC or RAC changed, notify CM clients of the corresponding
  ** event.
  */
  if ( new_srv_info->srv_status == SYS_SRV_STATUS_SRV &&
       (new_srv_info->sys_mode  == SYS_SYS_MODE_GSM ||
        new_srv_info->sys_mode  == SYS_SYS_MODE_WCDMA ||
        new_srv_info->sys_mode  == SYS_SYS_MODE_TDS) 
        )
  {

  
    switch(new_srv_info->sys_mode)
    {
      case SYS_SYS_MODE_GSM:        
      if(new_srv_info->rac_or_mme_code !=  old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.rac_or_mme_code)
      {
        changed_fields |= CM_SS_LAC_TAC_RAC_CHGD_MASK;
      }
      if(new_srv_info->lac !=  old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.lac)
      {
        changed_fields |= CM_SS_LAC_TAC_RAC_CHGD_MASK;
      }
      break ;
  
      case SYS_SYS_MODE_WCDMA:
      if(new_srv_info->lac !=  old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.lac)
      {
        changed_fields |= CM_SS_LAC_TAC_RAC_CHGD_MASK;
      }
    
      if(new_srv_info->rac_or_mme_code!=old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.rac_or_mme_code)
      {
        changed_fields |= CM_SS_LAC_TAC_RAC_CHGD_MASK;
      }
      break ;
  
      case SYS_SYS_MODE_TDS:
      if(new_srv_info->lac !=  old_srv_info->stack_info[stk_id].rat_mode_info.tds_mode_info.lac )
      {
        changed_fields |= CM_SS_LAC_TAC_RAC_CHGD_MASK;
      }
    
      if(new_srv_info->rac_or_mme_code!= old_srv_info->stack_info[stk_id].rat_mode_info.tds_mode_info.rac_or_mme_code)
  {
    changed_fields |= CM_SS_LAC_TAC_RAC_CHGD_MASK;
  }
      break ;

      default:
      break;

    }
  }

  #ifdef FEATURE_CM_LTE
  /*
  ** If in LTE service, TAC or RAC changed, notify CM clients of the corresponding
  ** event.
  */
  if ( new_srv_info->srv_status == SYS_SRV_STATUS_SRV &&
       new_srv_info->sys_mode   == SYS_SYS_MODE_LTE 
     )
  {
    if(new_srv_info->tac !=  old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.tac)
  {
    changed_fields |= CM_SS_LAC_TAC_RAC_CHGD_MASK;
  }
    if(new_srv_info->rac_or_mme_code !=  old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.rac_or_mme_code)
    {
      changed_fields |= CM_SS_LAC_TAC_RAC_CHGD_MASK;
    }
    
    if(new_srv_info->embms_info.embms_coverage_status !=  old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status)
    {
      changed_fields |= CM_SS_LTE_EMBMS_INFO_MASK;
    }
  }

  /*
  ** If div_duplex of  MAIN/HYBR2 info is changed, notify CM clients
  ** of the corresponding event.
  */

  if((cmss_ptr()->main_div_duplex != old_srv_info->div_duplex )
     && cmss_ptr()->main_div_duplex != SYS_DIV_DUPLEX_UNKNOWN
     && (!cmss_ptr()->info.is_hybr_gw_operational ||
         cmph_is_subs_feature_mode_sglte(SYS_MODEM_AS_ID_1) ||
         cmph_is_lte_capable_on_sub(SYS_MODEM_AS_ID_1)))
  {
    changed_fields |= CM_SS_DIV_DUPLEX_MASK;
  }
  else if((cmss_ptr()->hybr_gw_div_duplex != old_srv_info->div_duplex )
          && cmss_ptr()->hybr_gw_div_duplex != SYS_DIV_DUPLEX_UNKNOWN
          && (cmss_ptr()->info.is_hybr_gw_operational &&
            (cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1) )))
  {
    changed_fields |= CM_SS_DIV_DUPLEX_MASK;
  }


  /*
  ** If voice over PS indication changed, notify CM clients of the corresponding
  ** event.
  */
  if(new_srv_info->lte_ims_voice_avail != old_srv_info->stack_info[stk_id].lte_ims_voice_avail)
  {
    changed_fields |= CM_SS_LTE_IMS_VOICE_AVAIL_MASK;
  }
  /* update if there is change to emerg bearer support over LTE
  */
  if((!(cmph_is_subs_feature_mode_svlte(SYS_MODEM_AS_ID_1)) || !(cmss_ptr()->info.is_hybr_gw_operational) ) &&
    (cmcall_misc_is_mode_pref((cmph_get_ss_mode_pref(CM_SS_MAIN)), CM_MODE_PREF_LTE_ONLY)) &&
    (new_srv_info->lte_ims_emerg_avail != old_srv_info->stack_info[stk_id].lte_ims_emerg_avail))
  {
    *changed_fields2 |= CM_SS_LTE_IMS_EMERG_AVAIL_MASK;
  }

  #ifdef FEATURE_DOMAIN_SELECTION
  if (new_srv_info->voice_domain != old_srv_info->voice_domain)
  {
    *changed_fields2 |= CM_SS_LTE_VOICE_DOMAIN_CHANGED_MASK;
  }

  if (new_srv_info->sms_domain != old_srv_info->sms_domain)
  {
    *changed_fields2 |= CM_SS_LTE_SMS_DOMAIN_CHANGED_MASK;
  }
  #endif


  if( new_srv_info->available_plmn_type != old_srv_info->stack_info[stk_id].available_plmn_type )
  {
    *changed_fields2 |= CM_SS_SGLTE_REG_DOMAIN_CHANGED_MASK;
  }


  #endif

  if ( old_srv_info->stack_info[stk_id].cell_bc_info.cell_bc_capability !=
       new_srv_info->cell_bc_info.cell_bc_capability)
  {
    changed_fields |= CM_SS_CELL_BROADCAST_MASK;
    CM_MSG_MED_0 ("Cell Broadcast chg");
  }

  if( old_srv_info->bsr_in_progress !=
       new_srv_info->bsr_in_progress)
  {
    changed_fields |= CM_SS_BSR_PROGRESS_MASK;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  switch(new_srv_info->sys_mode)
  {
    case  SYS_SYS_MODE_LTE:        
      if ( !(old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->csg_info.csg_id == SYS_CSG_ID_INVALID) && 
    ( 0 != memcmp(&(old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.csg_info), &(new_srv_info->csg_info), sizeof(sys_csg_info_s_type)) || \
      ( (new_srv_info->csg_info.csg_id != SYS_CSG_ID_INVALID ) && \
            (new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS ) && \
            (!cmss_sys_id_match( new_srv_info->sys_id, old_srv_info->stack_info[stk_id].sys_id ))))
     )
  {
    changed_fields |= CM_SS_CSG_INFO_CHANGED_MASK;
    CM_MSG_HIGH_1 ("CSG Information Changed. new CSG_ID=%d",new_srv_info->csg_info.csg_id);
  }

      break;

    case  SYS_SYS_MODE_GSM:        
      if ( !(old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->csg_info.csg_id == SYS_CSG_ID_INVALID) && 
    ( 0 != memcmp(&(old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.csg_info), &(new_srv_info->csg_info), sizeof(sys_csg_info_s_type)) || \
    ( (new_srv_info->csg_info.csg_id != SYS_CSG_ID_INVALID ) && \
            (new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS ) && \
            (!cmss_sys_id_match( new_srv_info->sys_id, old_srv_info->stack_info[stk_id].sys_id ))))
      )
      {
        changed_fields |= CM_SS_CSG_INFO_CHANGED_MASK;
        CM_MSG_MED_1 ("CSG GSM Information Changed. new CSG_ID=%d",new_srv_info->csg_info.csg_id);
      }

      break ;
      
    case  SYS_SYS_MODE_WCDMA:        
      if ( !(old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->csg_info.csg_id == SYS_CSG_ID_INVALID) && 
    ( 0 != memcmp(&(old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.csg_info), &(new_srv_info->csg_info), sizeof(sys_csg_info_s_type)) || \
    ( (new_srv_info->csg_info.csg_id != SYS_CSG_ID_INVALID ) && \
            (new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS ) && \
            (!cmss_sys_id_match( new_srv_info->sys_id, old_srv_info->stack_info[stk_id].sys_id ))))
      )
      {
        changed_fields |= CM_SS_CSG_INFO_CHANGED_MASK;
        CM_MSG_MED_1 ("CSG WCDMA Information Changed. new CSG_ID=%d",new_srv_info->csg_info.csg_id);
      }

      break ;

      default:
      break;



  }

  if( new_srv_info->reg_reject_info.reject_cause != old_srv_info->stack_info[stk_id].reg_reject_info.reject_cause ||
    new_srv_info->reg_reject_info.reject_srv_domain != old_srv_info->stack_info[stk_id].reg_reject_info.reject_srv_domain)
  {
    *changed_fields2 |= CM_SS_LU_REJECT_MASK;
    CM_MSG_MED_0 ("LU reject info chg");
  }


  if ( old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.voice_support_on_lte !=
       new_srv_info->voice_support_on_lte )
  {
    changed_fields |= CM_SS_VOICE_SUPPORT_ON_LTE_MASK;
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  } /* if ((new_srv_info != NULL) && (old_srv_info != NULL)) */

  return changed_fields;

} /* cmss_get_ss_main_info_change () */
/*lint +esym(715,changed_fields2)*/
/*lint +esym(818,changed_fields2)*/



/*===========================================================================
FUNCTION cmss_get_ss_hybr_2_info_change

DESCRIPTION
  Compares the serving system information change and returns
  a bit mask holding difference.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  Bit Mask indicating which of the Serving System parameters changed

SIDE EFFECTS
  none

===========================================================================*/
static uint64 cmss_get_ss_hybr_2_info_change(

    const cm_mm_ss_info_s_type     *new_srv_info,
        /*  New SS information */

    const cm_mm_msim_ss_info_s_type     *old_srv_info
        /*  Old SS information */
)
{
  uint8                    stk_id =  cmss_map_ss_to_stack_info(CM_SS_HYBR_2);

  uint64                        changed_fields = 0;

  
  #if defined(FEATURE_MMODE_DUAL_SIM)
  /*lint -esym(529, ss_ptr) not referenced */
  #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
    cmss_s_type          *ss_ptr        =  cmss_ptr();
  #endif
  /* Point at serving system object to be initialized */
  #endif

      /* Records the changes in SS parameters between new_srv_info and old_srv_info */

  if ((new_srv_info != NULL) && (old_srv_info != NULL))
  {
    /*
    ** If service state changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw_srv_status != old_srv_info->stack_info[stk_id].srv_status )
    {
      changed_fields |= CM_SS_GW_SRV_STATUS_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If true service status changed,
    ** then also notify CM clients of the event.
    */
    if (new_srv_info->true_gw_srv_status != old_srv_info->stack_info[stk_id].true_srv_status )
    {
      changed_fields |= CM_SS_GW_TRUE_SRV_STATUS_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If system mode changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw_sys_mode != old_srv_info->stack_info[stk_id].sys_mode )
    {
      changed_fields |= CM_SS_GW_SYS_MODE_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /* Set the mask if SRV_EVENT_CHANGED is in response to CM_SS_CMD_GET_DCH_CELL_ID*/
    #ifdef FEATURE_MMODE_DUAL_SIM
        /* Unless it's dual sim configuration, DCH mask(WCDMA) should not be set
        for HYBR2 stack */
    #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
        
        if(new_srv_info->gw_sys_mode == SYS_SYS_MODE_WCDMA)
        {
          if (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
          {
            changed_fields |= CM_SS_GW_CELLID_DCH_MASK;
          }
          else
          {
            ss_ptr->info.hybr_gw_changed_fields &= (~CM_SS_GW_CELLID_DCH_MASK);
          }
        }
    #endif
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If active band changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw_active_band != old_srv_info->stack_info[stk_id].active_band )
    {
      changed_fields |= CM_SS_GW_ACTIVE_BAND_MASK;
    }

    /*
    ** If active chan changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw_active_channel != old_srv_info->stack_info[stk_id].active_channel )
    {
      changed_fields |= CM_SS_GW_ACTIVE_CHANNEL_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If roaming status changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw_roam_status != old_srv_info->stack_info[stk_id].roam_status )
    {
      changed_fields |= CM_SS_GW_ROAM_STATUS_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If srv domain changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw_srv_domain != old_srv_info->stack_info[stk_id].srv_domain )
    {

      changed_fields |= CM_SS_GW_SRV_DOMAIN_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If srv capability changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw_srv_capability != old_srv_info->stack_info[stk_id].srv_capability )
    {
      changed_fields |= CM_SS_GW_SRV_CAPABILITY_MASK;
    }

    /*
    ** If the system identifier has changed, notify CM clients of the
    ** corresponding event.
    */
    if ( !cmss_sys_id_match( new_srv_info->gw_sys_id, old_srv_info->stack_info[stk_id].sys_id ) )
    {
      changed_fields |= CM_SS_GW_SYS_ID_MASK;

      #ifdef CM_GW_SUPPORTED
      /*
      ** If the PLMN changed or there is no service, then clear the mobility
      ** management information.
      */
      
      if (((CM_IS_MODE_3GPP(old_srv_info->stack_info[stk_id].sys_mode))||(CM_IS_MODE_3GPP(new_srv_info->gw_sys_mode)))
        && new_srv_info->gw_sys_mode == cmss_map_access_tech_to_sys_mode(new_srv_info->gw_mode_info.gw_info.mm_information.rat))
      {
        changed_fields |= CM_SS_GW_MOBILITY_MGMT_MASK;
      }
      #endif  /* FEATURE_WCDMA || FEATURE_GSM */

    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If default roaming indicator changed, notify CM clients of the
    ** corresponding event.

    if ( new_srv_info->def_roam_ind != old_srv_info->def_roam_ind )
    {
      changed_fields |= CM_SS_DEF_ROAM_IND_MASK;
    }*/

    /*
    ** If prl match status changed, notify CM clients of the
    ** corresponding event.
    */
    if ( new_srv_info->gw_is_sys_prl_match != old_srv_info->stack_info[stk_id].is_sys_prl_match )
    {
      changed_fields |= CM_SS_GW_SYS_PRL_MATCH_MASK;
    }

    /*
    ** If system forbidden status changed, notify CM clients of the
    ** corresponding event.
    */
    if ( new_srv_info->gw_is_sys_forbidden != old_srv_info->stack_info[stk_id].is_sys_forbidden )
    {
      changed_fields |= CM_SS_GW_SYS_FORBIDDEN_MASK;
    }

    /*
    ** If in GW service, LAC or RAC changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw_srv_status == SYS_SRV_STATUS_SRV &&
         (new_srv_info->gw_sys_mode  == SYS_SYS_MODE_GSM ||
          new_srv_info->gw_sys_mode  == SYS_SYS_MODE_WCDMA ||
          new_srv_info->gw_sys_mode  == SYS_SYS_MODE_TDS) 
          )
    {

    
      switch(new_srv_info->gw_sys_mode)
      {
      
        case SYS_SYS_MODE_GSM:        
        if(new_srv_info->gwl_rac_or_mme_code !=  old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.rac_or_mme_code)
        {
          changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
        }
        if(new_srv_info->gwl_lac !=  old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.lac)
        {
          changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
        }
        break ;
      
        case SYS_SYS_MODE_WCDMA:
        if(new_srv_info->gwl_lac !=  old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.lac)
        {
          changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
        }
        
        if(new_srv_info->gwl_rac_or_mme_code!=old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.rac_or_mme_code)
        {
          changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
        }
        break ;
      
        case SYS_SYS_MODE_TDS:
        if(new_srv_info->gwl_lac !=  old_srv_info->stack_info[stk_id].rat_mode_info.tds_mode_info.lac )
    {
      changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
    }

        if(new_srv_info->gwl_rac_or_mme_code!= old_srv_info->stack_info[stk_id].rat_mode_info.tds_mode_info.rac_or_mme_code)
        {
          changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
        }
        break ;

        default:
        break;

      }
    }

    #ifdef FEATURE_CM_LTE
    if(new_srv_info->gw_sys_mode == SYS_SYS_MODE_LTE)
    {
      if (new_srv_info->gwl_tac != old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.tac ||
          new_srv_info->gwl_rac_or_mme_code != old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.rac_or_mme_code)
    {
      changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
    }
    }
    #endif
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*lint -save -e539 -e525 */
    /* If HS indication has changed, set mask
    */
    if( new_srv_info->gw_cell_srv_ind.hs_ind !=
        old_srv_info->stack_info[stk_id].cell_srv_ind.hs_ind )
    {
      changed_fields |= CM_SS_GW_SRV_IND_MASK;
    }

    /* If HS call indication has changed, set mask
    */
    if ( new_srv_info->gw_cell_srv_ind.hs_call_status !=
         old_srv_info->stack_info[stk_id].cell_srv_ind.hs_call_status)
    {
      changed_fields |= CM_SS_GW_SRV_IND_MASK;
    }

    /* If DTM indication has changed, set mask
    */
    if ( new_srv_info->gw_cell_srv_ind.dtm_supp
    != old_srv_info->stack_info[stk_id].cell_srv_ind.dtm_supp )
    {
      changed_fields |= CM_SS_GW_SRV_IND_MASK;
    }
    /* If EGPRS indication has changed, set mask
    */
    if ( new_srv_info->gw_cell_srv_ind.egprs_supp
    != old_srv_info->stack_info[stk_id].cell_srv_ind.egprs_supp )
    {
      changed_fields |= CM_SS_GW_SRV_IND_MASK;
    }

    #ifdef FEATURE_DOMAIN_SELECTION
    if (new_srv_info->voice_domain != old_srv_info->voice_domain)
    {
      changed_fields |= CM_SS_GW_LTE_VOICE_DOMAIN_CHANGED_MASK;
    }

    if (new_srv_info->sms_domain != old_srv_info->sms_domain)
    {
      changed_fields |= CM_SS_GW_LTE_SMS_DOMAIN_CHANGED_MASK;
    }

/*****************************************************************/
    if (new_srv_info->lte_ims_voice_avail != old_srv_info->stack_info[stk_id].lte_ims_voice_avail)
    {
      changed_fields |= CM_SS_GW_LTE_IMS_VOICE_AVAIL_MASK;
    }
    if(((cmph_is_subs_feature_mode_svlte(SYS_MODEM_AS_ID_1) &&
        cmss_ptr()->info.is_hybr_gw_operational) ||
       (cmph_is_subs_feature_mode_normal(cmph_ptr()->hybr_2_stack_info.asubs_id) &&
       (cmcall_misc_is_mode_pref(cmph_get_ss_mode_pref(CM_SS_HYBR_2), CM_MODE_PREF_LTE_ONLY))))&&
       (new_srv_info->lte_ims_emerg_avail != old_srv_info->stack_info[stk_id].lte_ims_emerg_avail))
    {
      changed_fields |= CM_SS_GW_LTE_IMS_EMERG_AVAIL_MASK;
    }
    #endif

    /*
    ** Check if cell_info specific info changed
    */
    if((new_srv_info->gw_cell_info.cell_id != old_srv_info->stack_info[stk_id].cell_info.cell_id )||
       (new_srv_info->gw_cell_info.as_sys_mode != old_srv_info->stack_info[stk_id].cell_info.as_sys_mode ) ||
       (new_srv_info->gw_cell_info.plmn_id.identity[0] != old_srv_info->stack_info[stk_id].cell_info.plmn_id.identity[0]) ||
       (new_srv_info->gw_cell_info.plmn_id.identity[1] != old_srv_info->stack_info[stk_id].cell_info.plmn_id.identity[1]) ||
       (new_srv_info->gw_cell_info.plmn_id.identity[2] != old_srv_info->stack_info[stk_id].cell_info.plmn_id.identity[2]) ||
       (new_srv_info->gw_cell_info.earfcn_dl != old_srv_info->stack_info[stk_id].cell_info.earfcn_dl)
      )
    {
      changed_fields |= CM_SS_GW_CELL_INFO_MASK;
    }

    if(new_srv_info->gw_cell_info.emerg_access_status != old_srv_info->stack_info[stk_id].cell_info.emerg_access_status)
    {
      changed_fields |= CM_SS_GW_LTE_EMERG_ACCESS_BARRED_MASK;
    }

    if(new_srv_info->gw_cell_info.lte_cell_access_status != old_srv_info->stack_info[stk_id].cell_info.lte_cell_access_status)
    {
      changed_fields |= CM_SS_GW_LTE_CELL_ACCESS_STATUS_MASK;
    }
    if ( old_srv_info->stack_info[stk_id].cell_bc_info.cell_bc_capability !=
         new_srv_info->gw_cell_bc_info.cell_bc_capability)
    {
      changed_fields |= CM_SS_GW_CELL_BROADCAST_MASK;
      CM_MSG_MED_0 ("GW Cell Broadcast chg ");
    }
    if(new_srv_info->gw_sys_mode == SYS_SYS_MODE_LTE)
    {
      if( new_srv_info->embms_info.embms_coverage_status !=
              old_srv_info->stack_info[0].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status)
      {
        changed_fields |= CM_SS_LTE_EMBMS_INFO_MASK;
      }
  
      if( new_srv_info->gwl_embms_info.embms_coverage_status !=
          old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status)
      {
        changed_fields |= CM_SS_GW_LTE_EMBMS_INFO_MASK;
      }
    }
    if( new_srv_info->gw_reg_reject_info.reject_cause != old_srv_info->stack_info[stk_id].reg_reject_info.reject_cause ||
      new_srv_info->gw_reg_reject_info.reject_srv_domain != old_srv_info->stack_info[stk_id].reg_reject_info.reject_srv_domain)
    {
      changed_fields |= CM_SS_GW_LU_REJECT_MASK;
      CM_MSG_MED_0 ("GW LU reject info chg ");
    }


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    switch(new_srv_info->gw_sys_mode)
    {

        case  SYS_SYS_MODE_LTE:
        if ( !(old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->csg_info.csg_id == SYS_CSG_ID_INVALID) && 
      ( 0 != memcmp(&(old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.csg_info), &(new_srv_info->csg_info), sizeof(sys_csg_info_s_type)) || \
      ( (new_srv_info->csg_info.csg_id != SYS_CSG_ID_INVALID ) && \
              (new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS ) && \
              (!cmss_sys_id_match( new_srv_info->sys_id, old_srv_info->stack_info[stk_id].sys_id ))))
           )
        {
          changed_fields |= CM_SS_CSG_INFO_CHANGED_MASK;
          CM_MSG_HIGH_1 ("HYBR2 LTE CSG Information Changed. new CSG_ID=%d",new_srv_info->csg_info.csg_id);
        }
        break;

        case  SYS_SYS_MODE_GSM:
        if ( !(old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->csg_info.csg_id == SYS_CSG_ID_INVALID) && 
      ( 0 != memcmp(&(old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.csg_info), &(new_srv_info->csg_info), sizeof(sys_csg_info_s_type)) || \
      ( (new_srv_info->csg_info.csg_id != SYS_CSG_ID_INVALID ) && \
              (new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS ) && \
              (!cmss_sys_id_match( new_srv_info->sys_id, old_srv_info->stack_info[stk_id].sys_id ))))
        )
        {
          changed_fields |= CM_SS_CSG_INFO_CHANGED_MASK;
          CM_MSG_HIGH_1 ("HYBR2 GSM CSG Information Changed. new CSG_ID=%d",new_srv_info->csg_info.csg_id);
        }
        break;

        case  SYS_SYS_MODE_WCDMA:
        if ( !(old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->csg_info.csg_id == SYS_CSG_ID_INVALID) && 
      ( 0 != memcmp(&(old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.csg_info), &(new_srv_info->csg_info), sizeof(sys_csg_info_s_type)) || \
        ( (new_srv_info->csg_info.csg_id != SYS_CSG_ID_INVALID ) && \
              (new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS ) && \
              (!cmss_sys_id_match( new_srv_info->sys_id, old_srv_info->stack_info[stk_id].sys_id ))))
       )
    {
      changed_fields |= CM_SS_CSG_INFO_CHANGED_MASK;
      CM_MSG_HIGH_1 ("HYBR2 CSG Information Changed. new CSG_ID=%d",new_srv_info->csg_info.csg_id);
    }
        break;
        default:
        break;

      }
    if(new_srv_info->sys_mode == SYS_SYS_MODE_LTE)
    {
      if ( old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.voice_support_on_lte !=
   new_srv_info->voice_support_on_lte )
    {
      changed_fields |= CM_SS_GW_VOICE_SUPPORT_ON_LTE_MASK;
    }
    }
    /*lint -restore */


    if((cmss_ptr()->hybr_gw_div_duplex != old_srv_info->div_duplex )
       && (cmss_ptr()->hybr_gw_div_duplex != SYS_DIV_DUPLEX_UNKNOWN) 
       && (cmss_ptr()->info.is_hybr_gw_operational &&
           cmph_is_lte_capable_on_sub(SYS_MODEM_AS_ID_2)))
    {
      changed_fields |= CM_SS_GW_DIV_DUPLEX_MASK;
    }

  } /* if ((new_srv_info != NULL) && (old_srv_info != NULL)) */

  return changed_fields;

} /* cmss_get_ss_hybr_2_info_change () */
/*lint +esym(529, ss_ptr) not referenced */

#if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
/*===========================================================================
FUNCTION cmss_get_ss_hybr_3_info_change

DESCRIPTION
  Compares the serving system information change and returns
  a bit mask holding difference.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  Bit Mask indicating which of the Serving System parameters changed

SIDE EFFECTS
  none

===========================================================================*/
static uint64 cmss_get_ss_hybr_3_info_change(

    const cm_mm_ss_info_s_type     *new_srv_info,
        /*  New SS information */

    const cm_mm_msim_ss_info_s_type     *old_srv_info
        /*  Old SS information */
)
{

  uint64                        changed_fields = 0;
      /* Records the changes in SS parameters between new_srv_info and old_srv_info */

  uint8                    stk_id = cmss_map_ss_to_stack_info(CM_SS_HYBR_3);
  #if defined(FEATURE_MMODE_DUAL_SIM)
  /*lint -esym(529, ss_ptr) not referenced */
  #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
  cmss_s_type          *ss_ptr        =  cmss_ptr();
  #endif
  /* Point at serving system object to be initialized */
  #endif

  if ((new_srv_info != NULL) && (old_srv_info != NULL))
  {
    /*
    ** If service state changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw3_srv_status != old_srv_info->stack_info[stk_id].srv_status )
    {
      changed_fields |= CM_SS_GW_SRV_STATUS_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If true service status changed,
    ** then also notify CM clients of the event.
    */
    if (new_srv_info->true_gw3_srv_status != old_srv_info->stack_info[stk_id].true_srv_status )
    {
      changed_fields |= CM_SS_GW_TRUE_SRV_STATUS_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If system mode changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw3_sys_mode != old_srv_info->stack_info[stk_id].sys_mode )
    {
      changed_fields |= CM_SS_GW_SYS_MODE_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/



    /* Set the mask if SRV_EVENT_CHANGED is in response to CM_SS_CMD_GET_DCH_CELL_ID*/
    #ifdef FEATURE_MMODE_DUAL_SIM
    /* Unless it's dual sim configuration, DCH mask(WCDMA) should not be set
    for HYBR2 stack */
    #if (defined(FEATURE_WCDMA_CM_CID_UPDATE_IN_DCH) && defined (FEATURE_WCDMA))
    
    if(new_srv_info->gw3_sys_mode == SYS_SYS_MODE_WCDMA)
    {
    if (ss_ptr->dch_cell_info_flgs & CMSS_IS_DCH_CELL_INFO_RES)
    {
      changed_fields |= CM_SS_GW_CELLID_DCH_MASK;
    }
    else
    {
      ss_ptr->info.gw3_changed_fields &= (~CM_SS_GW_CELLID_DCH_MASK);
    }
    }
    #endif
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If active band changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw3_active_band != old_srv_info->stack_info[stk_id].active_band )
    {
      changed_fields |= CM_SS_GW_ACTIVE_BAND_MASK;
    }

    /*
    ** If active chan changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw3_active_channel != old_srv_info->stack_info[stk_id].active_channel )
    {
      changed_fields |= CM_SS_GW_ACTIVE_CHANNEL_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If roaming status changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw3_roam_status != old_srv_info->stack_info[stk_id].roam_status )
    {
      changed_fields |= CM_SS_GW_ROAM_STATUS_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If srv domain changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw3_srv_domain != old_srv_info->stack_info[stk_id].srv_domain )
    {

      changed_fields |= CM_SS_GW_SRV_DOMAIN_MASK;
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If srv capability changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw3_srv_capability != old_srv_info->stack_info[stk_id].srv_capability )
    {
        changed_fields |= CM_SS_GW_SRV_CAPABILITY_MASK;
    }

    /*
    ** If the system identifier has changed, notify CM clients of the
    ** corresponding event.
    */
    if ( !cmss_sys_id_match( new_srv_info->gw3_sys_id, old_srv_info->stack_info[stk_id].sys_id ) )
    {
      changed_fields |= CM_SS_GW_SYS_ID_MASK;

      #ifdef CM_GW_SUPPORTED
      /*
      ** If the PLMN changed or there is no service, then clear the mobility
      ** management information.
      */
      if (((CM_IS_MODE_3GPP(old_srv_info->stack_info[stk_id].sys_mode))||(CM_IS_MODE_3GPP(new_srv_info->gw3_sys_mode)))
        && new_srv_info->gw3_sys_mode == cmss_map_access_tech_to_sys_mode(new_srv_info->gw3_mode_info.gw_info.mm_information.rat))
      {
        changed_fields |= CM_SS_GW_MOBILITY_MGMT_MASK;
      }
      #endif  /* FEATURE_WCDMA || FEATURE_GSM */

    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*
    ** If default roaming indicator changed, notify CM clients of the
    ** corresponding event.

    if ( new_srv_info->def_roam_ind != old_srv_info->def_roam_ind )
    {
      changed_fields |= CM_SS_DEF_ROAM_IND_MASK;
    }*/

    /*
    ** If prl match status changed, notify CM clients of the
    ** corresponding event.
    */
    if ( new_srv_info->gw3_is_sys_prl_match != old_srv_info->stack_info[stk_id].is_sys_prl_match )
    {
      changed_fields |= CM_SS_GW_SYS_PRL_MATCH_MASK;
    }

    /*
    ** If system forbidden status changed, notify CM clients of the
    ** corresponding event.
    */
    if ( new_srv_info->gw3_is_sys_forbidden != old_srv_info->stack_info[stk_id].is_sys_forbidden )
    {
      changed_fields |= CM_SS_GW_SYS_FORBIDDEN_MASK;
    }

    /*
    ** If in GW service, LAC or RAC changed, notify CM clients of the corresponding
    ** event.
    */
    if ( new_srv_info->gw3_srv_status == SYS_SRV_STATUS_SRV &&
         (new_srv_info->gw3_sys_mode  == SYS_SYS_MODE_GSM ||
          new_srv_info->gw3_sys_mode  == SYS_SYS_MODE_WCDMA ||
          new_srv_info->gw3_sys_mode  == SYS_SYS_MODE_TDS) 
          )
    {
       switch(new_srv_info->gw3_sys_mode)
       {
      
         case SYS_SYS_MODE_GSM:        
          if(new_srv_info->gw3_rac_or_mme_code !=  old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.rac_or_mme_code)
          {
            changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
          }

          break ;
      
        case SYS_SYS_MODE_WCDMA:

          if(new_srv_info->gw3_rac_or_mme_code!=old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.rac_or_mme_code)
          {
            changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
          }
          break ;
      
        case SYS_SYS_MODE_TDS:

        
          if(new_srv_info->gw3_rac_or_mme_code!= old_srv_info->stack_info[stk_id].rat_mode_info.tds_mode_info.rac_or_mme_code)
          {
            changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
          }
          break ;
        default:
          break;

      }
    }
    
    #ifdef FEATURE_CM_LTE
    if(new_srv_info->gw3_sys_mode == SYS_SYS_MODE_LTE)
    {
      if (new_srv_info->gw3_tac != old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.tac ||
          new_srv_info->gw3_rac_or_mme_code != old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.rac_or_mme_code)
      {
        changed_fields |= CM_SS_GWL_LAC_TAC_RAC_CHGD_MASK;
      }
    }
    #endif

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    /*lint -save -e539 -e525 */
    /* If HS indication has changed, set mask
    */
    if( new_srv_info->gw3_cell_srv_ind.hs_ind !=
        old_srv_info->stack_info[stk_id].cell_srv_ind.hs_ind )
    {
      changed_fields |= CM_SS_GW_SRV_IND_MASK;
    }

    /* If HS call indication has changed, set mask
    */
    if ( new_srv_info->gw3_cell_srv_ind.hs_call_status !=
         old_srv_info->stack_info[stk_id].cell_srv_ind.hs_call_status)
    {
      changed_fields |= CM_SS_GW_SRV_IND_MASK;
    }

    /* If DTM indication has changed, set mask
    */
    if ( new_srv_info->gw3_cell_srv_ind.dtm_supp
    != old_srv_info->stack_info[stk_id].cell_srv_ind.dtm_supp )
    {
      changed_fields |= CM_SS_GW_SRV_IND_MASK;
    }
    /* If EGPRS indication has changed, set mask
    */
    if ( new_srv_info->gw3_cell_srv_ind.egprs_supp
    != old_srv_info->stack_info[stk_id].cell_srv_ind.egprs_supp )
    {
      changed_fields |= CM_SS_GW_SRV_IND_MASK;
    }

    #ifdef FEATURE_DOMAIN_SELECTION
    if (new_srv_info->voice_domain != old_srv_info->voice_domain)
    {
      changed_fields |= CM_SS_GW_LTE_VOICE_DOMAIN_CHANGED_MASK;
    }

    if (new_srv_info->sms_domain != old_srv_info->sms_domain)
    {
      changed_fields |= CM_SS_GW_LTE_SMS_DOMAIN_CHANGED_MASK;
    }

    /*****************************************************************/
    if(new_srv_info->gw3_sys_mode == SYS_SYS_MODE_LTE)
    {
      if (new_srv_info->lte_ims_voice_avail != old_srv_info->stack_info[stk_id].lte_ims_voice_avail)
      {
        changed_fields |= CM_SS_GW_LTE_IMS_VOICE_AVAIL_MASK;
      }
      if((cmcall_misc_is_mode_pref(cmph_get_ss_mode_pref(CM_SS_HYBR_3), CM_MODE_PREF_LTE_ONLY)) &&
       (new_srv_info->lte_ims_emerg_avail != old_srv_info->stack_info[stk_id].lte_ims_emerg_avail))
      {
        changed_fields |= CM_SS_GW_LTE_IMS_EMERG_AVAIL_MASK;
      }
    }
    #endif

    /*
    ** Check if cell_info specific info changed
    */
    if((new_srv_info->gw3_cell_info.cell_id != old_srv_info->stack_info[stk_id].cell_info.cell_id )||
       (new_srv_info->gw3_cell_info.as_sys_mode != old_srv_info->stack_info[stk_id].cell_info.as_sys_mode ) ||
       (new_srv_info->gw3_cell_info.plmn_id.identity[0] != old_srv_info->stack_info[stk_id].cell_info.plmn_id.identity[0]) ||
       (new_srv_info->gw3_cell_info.plmn_id.identity[1] != old_srv_info->stack_info[stk_id].cell_info.plmn_id.identity[1]) ||
       (new_srv_info->gw3_cell_info.plmn_id.identity[2] != old_srv_info->stack_info[stk_id].cell_info.plmn_id.identity[2]) ||
       (new_srv_info->gw3_cell_info.earfcn_dl != old_srv_info->stack_info[stk_id].cell_info.earfcn_dl)
      )
    {
      changed_fields |= CM_SS_GW_CELL_INFO_MASK;
    }

    if(new_srv_info->gw3_cell_info.emerg_access_status != old_srv_info->stack_info[stk_id].cell_info.emerg_access_status)
    {
      changed_fields |= CM_SS_GW_LTE_EMERG_ACCESS_BARRED_MASK;
    }

    if(new_srv_info->gw3_cell_info.lte_cell_access_status != old_srv_info->stack_info[stk_id].cell_info.lte_cell_access_status)
    {
      changed_fields |= CM_SS_GW_LTE_CELL_ACCESS_STATUS_MASK;
    }
    if ( old_srv_info->stack_info[stk_id].cell_bc_info.cell_bc_capability !=
         new_srv_info->gw3_cell_bc_info.cell_bc_capability)
    {
      changed_fields |= CM_SS_GW_CELL_BROADCAST_MASK;
      CM_MSG_MED_0 ("GW3 Cell Broadcast chg ");
    }

    if(new_srv_info->gw3_sys_mode == SYS_SYS_MODE_LTE)
    {
    if( new_srv_info->gw3_embms_info.embms_coverage_status !=
        old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status)
    {
      changed_fields |= CM_SS_GW_LTE_EMBMS_INFO_MASK;
      CM_MSG_MED_0 ("GW3 EMBMS_INFO chg ");
    }
    }
    if( new_srv_info->gw3_reg_reject_info.reject_cause != old_srv_info->stack_info[stk_id].reg_reject_info.reject_cause ||
      new_srv_info->gw3_reg_reject_info.reject_srv_domain != old_srv_info->stack_info[stk_id].reg_reject_info.reject_srv_domain)
    {
      changed_fields |= CM_SS_GW_LU_REJECT_MASK;
      CM_MSG_MED_0 ("GW3 LU reject info chg ");
    }


    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    switch(new_srv_info->gw3_sys_mode)
    {

      case  SYS_SYS_MODE_LTE:
      if ( !(old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->csg_info.csg_id == SYS_CSG_ID_INVALID) && 
     ( 0 != memcmp(&(old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.csg_info), &(new_srv_info->csg_info), sizeof(sys_csg_info_s_type)) || \
       ( (new_srv_info->csg_info.csg_id != SYS_CSG_ID_INVALID ) && \
             (new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS ) && \
             (!cmss_sys_id_match( new_srv_info->sys_id, old_srv_info->stack_info[stk_id].sys_id ))))
         )
      {
        changed_fields |= CM_SS_CSG_INFO_CHANGED_MASK;
        CM_MSG_HIGH_1 ("HYBR3 LTE CSG Information Changed. new CSG_ID=%d",new_srv_info->csg_info.csg_id);
      }
      break ;

      case  SYS_SYS_MODE_GSM:
      if ( !(old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->csg_info.csg_id == SYS_CSG_ID_INVALID) && 
     ( 0 != memcmp(&(old_srv_info->stack_info[stk_id].rat_mode_info.gsm_mode_info.csg_info), &(new_srv_info->csg_info), sizeof(sys_csg_info_s_type)) || \
     ( (new_srv_info->csg_info.csg_id != SYS_CSG_ID_INVALID ) && \
             (new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS ) && \
             (!cmss_sys_id_match( new_srv_info->sys_id, old_srv_info->stack_info[stk_id].sys_id ))))
         )
      {
        changed_fields |= CM_SS_CSG_INFO_CHANGED_MASK;
        CM_MSG_HIGH_1 ("HYBR3 GSM CSG Information Changed. new CSG_ID=%d",new_srv_info->csg_info.csg_id);
      }
      break ;

      case  SYS_SYS_MODE_WCDMA:
      if ( !(old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.csg_info.csg_id == SYS_CSG_ID_INVALID && new_srv_info->csg_info.csg_id == SYS_CSG_ID_INVALID) && 
     ( 0 != memcmp(&(old_srv_info->stack_info[stk_id].rat_mode_info.wcdma_mode_info.csg_info), &(new_srv_info->csg_info), sizeof(sys_csg_info_s_type)) || \
     ( (new_srv_info->csg_info.csg_id != SYS_CSG_ID_INVALID ) && \
             (new_srv_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS ) && \
             (!cmss_sys_id_match( new_srv_info->sys_id, old_srv_info->stack_info[stk_id].sys_id ))))
       )
      {
        changed_fields |= CM_SS_CSG_INFO_CHANGED_MASK;
        CM_MSG_HIGH_1 ("HYBR3 CSG Information Changed. new CSG_ID=%d",new_srv_info->csg_info.csg_id);
      }
      break ;
        
      default:
        break;

    }

    if(new_srv_info->gw3_sys_mode == SYS_SYS_MODE_LTE)
    {
      if ( old_srv_info->stack_info[stk_id].rat_mode_info.lte_mode_info.voice_support_on_lte !=
           new_srv_info->voice_support_on_lte )
      {
        changed_fields |= CM_SS_GW_VOICE_SUPPORT_ON_LTE_MASK;
      }
    }
      
    /*lint -restore */

    if(cmss_ptr()->gw3_div_duplex != old_srv_info->div_duplex &&
      cmss_ptr()->gw3_div_duplex != SYS_DIV_DUPLEX_UNKNOWN &&
      cmph_is_lte_capable_on_ss(CM_SS_HYBR_3)
    )
    {
      changed_fields |= CM_SS_GW_DIV_DUPLEX_MASK;
    } 
  } /* if ((new_srv_info != NULL) && (old_srv_info != NULL)) */

  return changed_fields;

} /* cmss_get_ss_hybr_3_info_change () *//*lint +esym(529, ss_ptr) not referenced */
#endif

/*===========================================================================

FUNCTION cmss_is_cdma_svd_supported

DESCRIPTION
  This function should be called to check if SVD is supported on 1x.

DEPENDENCIES
  cmss_init() should have been called previously.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
boolean                                         cmss_is_cdma_svd_supported
(
        void
)
{
  /* Pointer to serving system object.
  */
  cmss_s_type              *ss_ptr               = cmss_ptr();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Check if we have service on 1x and ccs is supported.
  */
  if ( sys_srv_status_is_srv(ss_ptr->info.srv_status) &&
       ss_ptr->info.sys_mode == SYS_SYS_MODE_CDMA &&
       ss_ptr->info.mode_info.cdma_info.ccs_supported
     )
  {
    /* CCS supported.
    */
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* CCS not supported.
  */
  return FALSE;

} /* cmss_is_cdma_svd_supported() */


/*===========================================================================

FUNCTION cmss_get_ss_hdr_info_change

DESCRIPTION
  Compares the serving system information change and returns
  a bit mask holding difference.

DEPENDENCIES
  Phone object must have already been initialized with
  cmph_init().

RETURN VALUE
  Bit Mask indicating which of the Serving System parameters changed

SIDE EFFECTS
  none

===========================================================================*/
static uint64 cmss_get_ss_hdr_info_change(

    const cm_mm_ss_info_s_type     *new_srv_info,
        /*  New SS information */

    const cm_mm_msim_ss_info_s_type     *old_srv_info
        /*  Old SS information */
)
{
  uint8                                stk_id=cmss_map_ss_to_stack_info(CM_SS_HYBR_1);

  uint64                        changed_fields = 0;
        /* Records the changes in SS parameters between new_srv_info and old_srv_info */

  const sys_time_info_s_type         *old_time = &(old_srv_info->stack_info[stk_id].mode_info.cdma_info.time_info);

  const sys_time_info_s_type         *new_time = CDMA_TIME_PTR(new_srv_info);

  if ((new_srv_info != NULL) && (old_srv_info != NULL))
  {

    CM_MSG_HIGH_2 ("Entering changed fields info for hdr: changed_fields= %d , stk_id = %d ",
                 changed_fields,stk_id);

    if (new_srv_info->hdr_srv_status != old_srv_info->stack_info[stk_id].srv_status)
    {
      changed_fields |= CM_SS_HDR_SRV_STATUS_MASK;
    }

    if (new_srv_info->hdr_roam_status != old_srv_info->stack_info[stk_id].roam_status)
    {
      changed_fields |= CM_SS_HDR_ROAM_STATUS_MASK;
    }

    /*
    ** If the HDR system identifier has changed, notify CM clients of the
    ** corresponding event.
    */
    if ( !cmss_sys_id_match( new_srv_info->hdr_sys_id,
                             old_srv_info->stack_info[stk_id].sys_id ) )
    {
      changed_fields |= CM_SS_HDR_SYS_ID_MASK;
    }

    if (new_srv_info->subnet_mask_len!= old_srv_info->stack_info[stk_id].rat_mode_info.hdr_mode_info.subnet_mask_len)
    {
      changed_fields |= CM_SS_HDR_SYS_ID_MASK;
      CM_MSG_MED_0("subnet_mask_len changed");
    }

    #ifdef FEATURE_BCMCS
    if( new_srv_info->hybr_hdr_bcmcs_srv_status !=
          old_srv_info->stack_info[stk_id].bcmcs_srv_status )
    {
      changed_fields |= CM_SS_HYBR_HDR_BCMCS_SRV_STATUS_MASK;
    }
    #endif

    /* If throttle status on hybrid HDR
    ** has changed notify CM clients of the corresponding event.
    */
    #ifdef FEATURE_CALL_THROTTLE
    if (  new_srv_info->hdr_thr_status.ss_thr_status !=
          old_srv_info->stack_info[stk_id].thr_status.ss_thr_status
       )
    {
      changed_fields |= CM_SS_ORIG_THR_STATUS_MASK;
    }
    #endif


    /* If the HDR active protocol is changed, set the mask.
    */
    if( new_srv_info->hdr_active_prot != old_srv_info->stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_active_prot )
    {
      changed_fields |= CM_SS_HDR_ACTIVE_PROT_MASK;
    }

    /* If the HDR personality is changed, set the mask.
    */
    if( new_srv_info->hdr_personality != old_srv_info->stack_info[stk_id].rat_mode_info.hdr_mode_info.hdr_personality )
    {
      changed_fields |= CM_SS_HDR_PERSONALITY_MASK;
    }

    /* If the HYBRID active band is changed, set the mask.
    */
    if (new_srv_info->hybrid_active_band != old_srv_info->stack_info[stk_id].active_band )
    {
      changed_fields |= CM_SS_HYBRID_ACTIVE_BAND_MASK;
    }

    /* If the HYBRID active channel is changed, set the mask.
    */
    if (new_srv_info->hybrid_active_channel != old_srv_info->stack_info[stk_id].active_channel )
    {
      changed_fields |= CM_SS_HYBRID_ACTIVE_CHANNEL_MASK;
    }

    /*
       ** If there is a CDMA time change, notify clients.
       ** The old_time, new_time are defined within a union. Do not allow
       ** accessing them if the previous srv info was of 3GPP.
    */

    if ((old_srv_info->stack_info[0].sys_mode != SYS_SYS_MODE_WCDMA)
         &&
         (old_srv_info->stack_info[0].sys_mode != SYS_SYS_MODE_GSM)
         &&
         (old_srv_info->stack_info[0].sys_mode != SYS_SYS_MODE_LTE)
         &&
         (transition_rats == FALSE))
    {
       if (old_time->sys_mode != new_time->sys_mode)
       {
          CM_MSG_HIGH_2("time:hybr- old mode %d new mode %d",
                                    old_time->sys_mode,
                                    new_time->sys_mode);
          changed_fields |= CM_SS_CDMA_TIME_CHGD_MASK;
       }
    }
    if (new_time->sys_mode == SYS_SYS_MODE_HDR)
    {
       if( (new_time->time.hdr_time.ltm_offset !=
           old_time->time.hdr_time.ltm_offset) ||
           (new_time->time.hdr_time.lp_sec !=
           old_time->time.hdr_time.lp_sec) )
       {
          changed_fields |= CM_SS_CDMA_TIME_CHGD_MASK;
          CM_MSG_HIGH_4("time:hybr- old ltm %d new ltm %d old lpsec %d new lpsec %d ",
                     old_time->time.hdr_time.ltm_offset,
                     new_time->time.hdr_time.ltm_offset,     
                 old_time->time.hdr_time.lp_sec,
                 new_time->time.hdr_time.lp_sec);
		  
                transition_rats = FALSE;
       }
    }
  } /* if ((new_srv_info != NULL) && (old_srv_info != NULL)) */
  CM_MSG_HIGH_2 ("changed fields info for hdr: changed_fields= %d , stk_id = %d ",
               changed_fields,stk_id);

  return changed_fields;

} /* cmss_get_ss_hdr_info_change () */


/*===========================================================================
FUNCTION cmss_get_srv_status_for_main

DESCRIPTION
  Copies quick service info into output buffer for MAIN atomically.
===========================================================================*/
static void cmss_get_srv_status_for_main(

    cm_service_status_s_type *srv_info
)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  CM_ASSERT(srv_info != NULL);

  rex_enter_crit_sect(cmtask_crit_sect_ptr());
  if(ss_ptr->info.srv_status == SYS_SRV_STATUS_PWR_SAVE)
  {
    srv_info->srv_status = SYS_SRV_STATUS_NO_SRV;
  }
  else
  {
    srv_info->srv_status = ss_ptr->info.srv_status;
    srv_info->sys_mode = ss_ptr->info.sys_mode;
    srv_info->band = ss_ptr->info.active_band;
    srv_info->chan = ss_ptr->info.active_channel;
  }
  rex_leave_crit_sect(cmtask_crit_sect_ptr());
}

/*===========================================================================
FUNCTION cmss_get_srv_status_for_hybr_1

DESCRIPTION
  Copies quick service info into output buffer for HYBR_1 atomically.
===========================================================================*/
static void cmss_get_srv_status_for_hybr_1(

    cm_service_status_s_type *srv_info
)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  CM_ASSERT(srv_info != NULL);

  rex_enter_crit_sect(cmtask_crit_sect_ptr());
  if(!ss_ptr->info.hdr_hybrid ||
     ss_ptr->info.hdr_srv_status == SYS_SRV_STATUS_PWR_SAVE)
  {
    srv_info->srv_status = SYS_SRV_STATUS_NO_SRV;
  }
  else
  {
    srv_info->srv_status = ss_ptr->info.hdr_srv_status;
    srv_info->sys_mode = SYS_SYS_MODE_HDR;
    srv_info->band = ss_ptr->info.hybrid_active_band;
    srv_info->chan = ss_ptr->info.hybrid_active_channel;
  }
  rex_leave_crit_sect(cmtask_crit_sect_ptr());
}

/*===========================================================================
FUNCTION cmss_get_srv_status_for_hybr_2

DESCRIPTION
  Copies quick service info into output buffer for HYBR_2 atomically.
===========================================================================*/
static void cmss_get_srv_status_for_hybr_2(

    cm_service_status_s_type *srv_info
)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  CM_ASSERT(srv_info != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if non-multi-stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  srv_info->srv_status = SYS_SRV_STATUS_NO_SRV;
  /* Check if HYBR_2 stack is functional:
     1. Dual SIM
     2. SVLTE
  */
  if(ss_ptr->info.is_hybr_gw_operational)
  {
    rex_enter_crit_sect(cmtask_crit_sect_ptr());

    if(ss_ptr->info.gw_srv_status == SYS_SRV_STATUS_PWR_SAVE)
    {
      srv_info->srv_status = SYS_SRV_STATUS_NO_SRV;
    }
    else
    {
      srv_info->srv_status = ss_ptr->info.gw_srv_status;
      srv_info->sys_mode = ss_ptr->info.gw_sys_mode;
      srv_info->band = ss_ptr->info.gw_active_band;
      srv_info->chan = ss_ptr->info.gw_active_channel;
    }

    rex_leave_crit_sect(cmtask_crit_sect_ptr());
  }
}
/*===========================================================================
FUNCTION cmss_get_srv_status_for_hybr_3

DESCRIPTION
  Copies quick service info into output buffer for HYBR_3 atomically.
===========================================================================*/
static void cmss_get_srv_status_for_hybr_3(

    cm_service_status_s_type *srv_info
)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  CM_ASSERT(srv_info != NULL);

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Exit if non-multi-stack */
  if (!cmph_is_feature_mask(FEATURE_MODE_MASK_MSTACK))
  {
    return;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  srv_info->srv_status = SYS_SRV_STATUS_NO_SRV;
  /* Check if HYBR_3 stack is functional:
     1. Dual SIM
     2. SVLTE
  */
  if(ss_ptr->info.is_gw3_operational)
  {
    rex_enter_crit_sect(cmtask_crit_sect_ptr());

    if(ss_ptr->info.gw3_srv_status == SYS_SRV_STATUS_PWR_SAVE)
    {
      srv_info->srv_status = SYS_SRV_STATUS_NO_SRV;
    }
    else
    {
      srv_info->srv_status = ss_ptr->info.gw3_srv_status;
      srv_info->sys_mode = ss_ptr->info.gw3_sys_mode;
      srv_info->band = ss_ptr->info.gw3_active_band;
      srv_info->chan = ss_ptr->info.gw3_active_channel;
    }

    rex_leave_crit_sect(cmtask_crit_sect_ptr());
  }
}

/*===========================================================================

FUNCTION cmss_get_service_status_per_stack

DESCRIPTION
  Copies quick service info into output buffer for given stack.

DEPENDENCIES
  cmss_init()

RETURN VALUE
  None

SIDE EFFECTS
  none

===========================================================================*/
void cmss_get_service_status_per_stack(

    cm_ss_e_type ss,
      /* Stack for which we need provide service info */

    cm_service_status_s_type *srv_info
      /* Buffer to hold service info for the given stack */
)
{
  CM_ASSERT_ENUM_IS_INRANGE(ss, CM_SS_MAX);
  CM_ASSERT(srv_info != NULL);

  switch(ss)
  {
    case CM_SS_MAIN:
     cmss_get_srv_status_for_main(srv_info);
     break;

    case CM_SS_HYBR_1:
      cmss_get_srv_status_for_hybr_1(srv_info);
      break;

    case CM_SS_HYBR_2:
      cmss_get_srv_status_for_hybr_2(srv_info);
      break;

    case CM_SS_HYBR_3:
      cmss_get_srv_status_for_hybr_3(srv_info);
      break;


    default:
      break;
  }

} /* cmss_get_service_status_per_stack */


/*===========================================================================

===========================================================================*/

void cmss_get_camped_srv_info(

  sd_ss_e_type ss,
  sys_srv_status_e_type *srv_status

)
{
  if(ss == SD_SS_MAIN)
  {
    *srv_status = cmss_ptr()->info.srv_status;
  }
  else if(ss == SD_SS_HYBR_2)
  {
    *srv_status = cmss_ptr()->info.gw_srv_status;
  }
  else if(ss == SD_SS_HYBR_3)
  {
    *srv_status = cmss_ptr()->info.gw3_srv_status;
  }

  /* Currently don't have service, CAMP_IND means we're moving to LIMITED */
  if (!sys_srv_status_is_srv(*srv_status))
  {
    *srv_status = SYS_SRV_STATUS_LIMITED;
  }
}

/*===========================================================================

FUNCTION cmss_send_mm_ps_data_avail_req

DESCRIPTION
  Send the ps data available request to MM

DEPENDENCIES

RETURN VALUE
  Return TRUE if the command is successfully send. Otherwise FALSE.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmss_send_mm_data_avail(

        cm_ss_e_type      ss
          /* Stack on which the data is available */

)
/*lint -esym(715,ss)*/
{

  #ifdef CM_GW_SUPPORTED

  mm_cmd_type                   *mm_ptr;
      /* MM command pointer */

  mm_ptr = mm_cm_get_cmd_buf(MMCM_PS_DATA_AVAILABLE_REQ);

  if (mm_ptr == NULL)
  {
    CM_ERR_0("CM_SS_CMD_PS_DATA_AVAIL: out of MM cmd buffer");
    return FALSE;
  }

  mm_ptr->cmd.cm_mm_ps_data_ready_req.as_id = cmph_determine_as_id_to_ll_per_ss(ss);

  mm_put_cmd( mm_ptr );

  CM_MSG_HIGH_0("Send PS DATA AVAIL REQ to MM");

  return TRUE;

  #else /* ! (FEATURE_GSM || FEATURE_WCDMA) */

  return TRUE;

  #endif /* FEATURE_GSM || FEATURE_WCDMA */

}
/*lint +esym(715,ss)*/

/*===========================================================================

FUNCTION cmss_send_mm_ims_reg_info

DESCRIPTION
  Send the IMS registration Info to MM

DEPENDENCIES

RETURN VALUE
  Return TRUE if the command is successfully send. Otherwise FALSE.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmss_send_mm_ims_reg_info(

        boolean      is_ims_voice_avail
          /* Indicates whether IMS voice is avaialble or not*/
)
/*lint -esym(715,is_ims_voice_avail)*/
{

  #ifdef FEATURE_CM_LTE

  mm_cmd_type                   *mm_ptr;
      /* MM command pointer */

  mm_ptr = mm_cm_get_cmd_buf(MMCM_IMS_REGISTRATION_INFO);

  if (mm_ptr == NULL)
  {
    CM_ERR_0("MMCM_IMS_REGISTRATION_INFO: out of MM cmd buffer");
    return FALSE;
  }

  mm_ptr->cmd.cm_mm_ims_registration_info.ims_registration_status = is_ims_voice_avail;

  mm_put_cmd( mm_ptr );

  CM_MSG_HIGH_1("Send IMS REG INFO to MM %d", is_ims_voice_avail);

  return TRUE;

  #else /* ! (FEATURE_GSM || FEATURE_WCDMA) */

  return TRUE;

  #endif /* FEATURE_GSM || FEATURE_WCDMA */

}
/*lint  +esym(715,is_ims_voice_avail)*/

/*===========================================================================

FUNCTION cmss_sys_id_match

DESCRIPTION
  Verfies if two system identities are equal or not.

DEPENDENCIES

RETURN VALUE
  Return TRUE if identities are equal. Otherwise FALSE.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmss_sys_id_match(
  sys_sys_id_s_type     sys_id_1,
  sys_sys_id_s_type     sys_id_2
)
{
   if( sys_sys_id_match( sys_id_1, sys_id_2) )
   {
     if( sys_lac_match(sys_id_1,sys_id_2) )
     {
       return TRUE;
     }
   }

   CM_MSG_HIGH_0("cmss_sys_id_match failed");
   return FALSE;
}


/*===========================================================================

FUNCTION cmss_is856_sys_id_match

DESCRIPTION
  Verifies if two IS856 system identities are equal or not.
  The subnet mask to be used is obtained from cmss_ptr()

DEPENDENCIES
  subnet mask length shonld be updated correctly in cmss_ptr()

RETURN VALUE
  Return TRUE if subnet ids are equal. Otherwise FALSE.

SIDE EFFECTS
  none

===========================================================================*/
boolean cmss_is856_sys_id_match(
  sys_sys_id_s_type     sys_id_1,
  sys_sys_id_s_type     sys_id_2
)
{
  /* Mask table to isolate MSB bits within a byte.
  */
  static const  byte mask_tbl[] = { 0x00, 0x80, 0xC0, 0xE0,
                                    0xF0, 0xF8, 0xFC, 0xFE };
  byte          mask_len = cmss_ptr()->subnet_mask_len;
  byte          i        = 0;
  byte          mask     = 0;

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Parameter checks
  */
  CM_ASSERT(sys_id_1.id_type == SYS_SYS_ID_TYPE_IS856);
  CM_ASSERT(sys_id_2.id_type == SYS_SYS_ID_TYPE_IS856);
  CM_ASSERT(sys_id_1.id.is856 != NULL);
  CM_ASSERT(sys_id_2.id.is856 != NULL);

  if(mask_len > CMSS_MAX_SUBNET_MASK_LEN )
  {
    CM_MSG_MED_1("Incorrect mask_len %d", mask_len);
    mask_len = CMSS_MAX_SUBNET_MASK_LEN;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* compare subnet id
  */
  for( i=0;i < mask_len / 8 ; i++ )
  {
    if(sys_id_1.id.is856[i] != sys_id_2.id.is856[i] )
    {
      return FALSE;
    }
  }
  /* Check the reminder, as needed.
  */
  if( i < ARR_SIZE(sys_id_1.id.is856) )
  {
    mask = mask_tbl[ mask_len & 0x0007 ];

    if( (sys_id_1.id.is856[i] & mask) !=
        (sys_id_2.id.is856[i] & mask) )
    {
      return FALSE;
    }
  }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* If we got here, the two Subnet IDs match - return TRUE.
  */
  return TRUE;

} /* cmss_is856_sys_id_match */

/*===========================================================================

FUNCTION cmss_inform_target_rat

DESCRIPTION
   Notify client of target RAT when doing eHRPD to LTE reselection


DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cmss_inform_target_rat
(
    sys_sys_mode_e_type     target_rat
)
{
#ifdef FEATURE_MMODE_LTE_RESEL
  cmss_s_type * ss_ptr = cmss_ptr();

  if(ss_ptr->info.target_rat != target_rat)
  {
    CM_MSG_HIGH_1("Sending tRAT=%d",target_rat);

    ss_ptr->info.target_rat = target_rat;
    ss_ptr->info.changed_fields = CM_SS_RESEL_TARGET_RAT_MASK;

    cmss_event(CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED);

    ss_ptr->info.changed_fields = 0;
  }
#else
  SYS_ARG_NOT_USED(target_rat);
#endif

  return;

}

#ifdef FEATURE_CM_LTE
/*===========================================================================
@FUNCTION cmss_map_lte_rrc_div_duplex_to_sys_val

@DESCRIPTION
 Maps LTE RRC DIV Duplex info to CM SYS Enum value.

@DEPENDENCIES
  None.

@RETURN VALUE
 CM SYS enum value for div_duplex

@SIDE EFFECTS
  None.

@x
===========================================================================*/

static sys_div_duplex_e_type cmss_map_lte_rrc_div_duplex_to_sys_val(
    lte_rrc_div_duplex_e  lte_rrc_div
    /**< lte rrc division duplex */
)
{
  sys_div_duplex_e_type    sys_div_duplex;

  switch( lte_rrc_div )
   {
    case LTE_RRC_NONE_DIV_DUPLEX:
      sys_div_duplex = SYS_DIV_DUPLEX_NONE;
      break;

    case LTE_RRC_FREQ_DIV_DUPLEX:
      sys_div_duplex = SYS_DIV_DUPLEX_FREQ;
      break;

    case LTE_RRC_TIME_DIV_DUPLEX:
      sys_div_duplex = SYS_DIV_DUPLEX_TIME;
      break;

       default:
      CM_MSG_MED_1( "Can't map LTE RRC Div duplex : %d", lte_rrc_div);
      sys_div_duplex = SYS_DIV_DUPLEX_UNKNOWN;
      break;
   }

  return sys_div_duplex;

}
#endif

/*===========================================================================

FUNCTION cmss_inform_ctxt_transfer_event

DESCRIPTION
   Notify client of target RAT when doing 3GPP CONTEXT TRANSFER


DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cmss_inform_ctxt_transfer_event
(
    sys_radio_access_tech_e_type       target_rat,

    sys_modem_as_id_e_type             asubs_id
      /* The ASUBS_ID on which the context transfer happens. */
)
{
#ifdef FEATURE_CM_LTE
  cmss_s_type * ss_ptr = cmss_ptr();
  sys_sys_mode_e_type   sys_mode;


  sys_mode = cmss_map_access_tech_to_sys_mode(target_rat);

  if(sys_mode != SYS_SYS_MODE_NO_SRV)
  {
    ss_ptr->info.irat_ctxt_target_rat = sys_mode;
    ss_ptr->info.gwl_irat_asubs_id    = asubs_id;

    CM_MSG_HIGH_2("Sending 3GPP IRAT_CTXT_TRANSFER =%d on asubs_id=%d",
                sys_mode,asubs_id);

    cmss_event(CM_SS_MAIN, CM_SS_EVENT_IRAT_CTXT_TRANSFER);
  }

  #else
  SYS_ARG_NOT_USED(target_rat);
  #endif

  return;
}

/*===========================================================================

FUNCTION cmss_is_3gpp_in_srv

DESCRIPTION
   Check if G/W/L/TDS is in service

DEPENDENCIES
  none

RETURN VALUE
  TRUE if in service
  FASLE otherwise

SIDE EFFECTS
  none

===========================================================================*/
boolean cmss_is_3gpp_in_srv
(
  sys_sys_mode_e_type  mode,
  /* Mode to check against */

  boolean              check_only_full_srv
  /* Indicate if check only full srv */
)
{
  cmss_s_type * ss_ptr = cmss_ptr();
  boolean       is_srv = FALSE;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Return here if not 3GPP mode
   */
  if (!(BM(mode) & BM(SYS_SYS_MODE_GSM))
      &&
      !(BM(mode) & BM(SYS_SYS_MODE_WCDMA))
      &&
      !(BM(mode) & BM(SYS_SYS_MODE_LTE))
      &&
      !(BM(mode) & BM(SYS_SYS_MODE_TDS)))
  {
    CM_ERR_0("Mode is not 3GPP");
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_3( "check_only_full_srv %d, ss_ptr->info.srv_status %d, ss_ptr->info.sys_mode %d",
               check_only_full_srv, ss_ptr->info.srv_status, ss_ptr->info.sys_mode );

  /* Check if in srv on main stack
   */
  if(check_only_full_srv)
  {
    is_srv = sys_srv_status_is_full_srv(ss_ptr->info.srv_status);
  }
  else
  {
    is_srv = sys_srv_status_is_srv(ss_ptr->info.srv_status);
  }

  if ( SD_MODE_CONTAIN( BM(mode),BM(ss_ptr->info.sys_mode) )
       &&
       is_srv)
  {
    return TRUE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  CM_MSG_HIGH_3( "check_only_full_srv %d, ss_ptr->info.gw_srv_status %d, ss_ptr->info.gw_sys_mode %d",
               check_only_full_srv, ss_ptr->info.gw_srv_status, ss_ptr->info.gw_sys_mode );

  /* Check if in srv on hybr2 stack
   */
  if(check_only_full_srv)
  {
    is_srv = sys_srv_status_is_full_srv(ss_ptr->info.gw_srv_status);
  }
  else
  {
    is_srv = sys_srv_status_is_srv(ss_ptr->info.gw_srv_status);
  }

  if (SD_MODE_CONTAIN( BM(mode),BM(ss_ptr->info.gw_sys_mode) )
      &&
      is_srv)
  {
    return TRUE;
  }

  /* Check if in srv on hybr3 stack
   */
  #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
  if(check_only_full_srv)
  {
    is_srv = sys_srv_status_is_full_srv(ss_ptr->info.gw3_srv_status);
  }
  else
  {
    is_srv = sys_srv_status_is_srv(ss_ptr->info.gw3_srv_status);
  }

  if (SD_MODE_CONTAIN( BM(mode),BM(ss_ptr->info.gw3_sys_mode) )
      &&
      is_srv)
  {
    return TRUE;
  }
  #endif



  return FALSE;

}

/*===========================================================================

FUNCTION cmss_resolve_hdr_lte_srv_conflicts

DESCRIPTION
   This will make sure LTE and HDR will not be notified to clients as full
   service at a time.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cmss_resolve_hdr_lte_srv_conflicts()
{
  cmss_s_type          *ss_ptr        =  cmss_ptr();

  #ifdef FEATURE_HDR_HYBRID
  //LTE(on main) and HDR is having full service at a time, need to resolve
  if(sys_srv_status_is_srv(ss_ptr->info.srv_status)
     && sd_misc_is_mode_pref((sd_ss_mode_pref_e_type)BM(ss_ptr->info.sys_mode),
                              SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE)
     && sys_srv_status_is_srv(ss_ptr->info.hdr_srv_status)
     )
  {
    int no_srv_uptimer_is_running
      = (ss_ptr->no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE) ? 1 : 0;

    int hdr_no_srv_uptimer_is_running
      = (ss_ptr->hdr_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE) ? 1 : 0;

    CM_MSG_HIGH_5("Resolve LTE-main-HDR: sys_mode %d srv_stat %d hdr_srv_stat %d no_srv_uptime %d HDR_no_srv_uptime %d",
                ss_ptr->info.sys_mode,ss_ptr->info.srv_status, ss_ptr->info.hdr_srv_status,
                no_srv_uptimer_is_running, hdr_no_srv_uptimer_is_running);
    

    // timer running on main but no timer running hdr
    if( (no_srv_uptimer_is_running)
      && !(hdr_no_srv_uptimer_is_running) )
    {
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = SYS_SYS_MODE_NO_SRV;

      ss_ptr->info.srv_status = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->info.sys_mode = SYS_SYS_MODE_NO_SRV;
      ss_ptr->no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

      cmss_update_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN));
    }
    else
    // timer running on hdr but no timer running main
    if( !(no_srv_uptimer_is_running)
      && (hdr_no_srv_uptimer_is_running) )
    {
      cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->mode = SYS_SYS_MODE_NO_SRV;

      ss_ptr->info.hdr_srv_status = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->hdr_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

      cmss_update_hybr_1_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_1));
    }
    // timers are running in both hdr & main
    else
    {
      CM_MSG_HIGH_0("Both timers are runing...");
    }
  }
#endif

  #ifdef FEATURE_HDR_HYBRID
  //LTE(on hybr2) and HDR is having full service at a time, need to resolve
  if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)
     && sys_srv_status_is_srv(ss_ptr->info.gw_srv_status)
     && sd_misc_is_mode_pref((sd_ss_mode_pref_e_type)BM(ss_ptr->info.gw_sys_mode),
                              SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE)
     && sys_srv_status_is_srv(ss_ptr->info.hdr_srv_status)
     )
  {
    int hybr2_no_srv_uptimer_is_running
      = (ss_ptr->hybr_gw_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE) ? 1 : 0;

    int hdr_no_srv_uptimer_is_running
      = (ss_ptr->hdr_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE) ? 1 : 0;

    CM_MSG_HIGH_5("Resolve LTE-hy2-HDR: sys_mode %d srv_stat %d hdr_srv_stat %d no_srv_uptime %d HDR_no_srv_uptime %d",
                ss_ptr->info.gw_sys_mode, ss_ptr->info.gw_srv_status,ss_ptr->info.hdr_srv_status,
                hybr2_no_srv_uptimer_is_running, hdr_no_srv_uptimer_is_running);
    

    // timer running on hybr2 but no timer running hdr
    if( (hybr2_no_srv_uptimer_is_running )
      && !(hdr_no_srv_uptimer_is_running ) )
    {
      cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode = SYS_SYS_MODE_NO_SRV;

      ss_ptr->info.gw_srv_status = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->info.gw_sys_mode = SYS_SYS_MODE_NO_SRV;
      ss_ptr->hybr_gw_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

      cmss_update_hybr_2_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_2));
    }
    else
    // no timer running on hybr2 but timer running hdr
    if( !(hybr2_no_srv_uptimer_is_running )
      && (hdr_no_srv_uptimer_is_running ) )
    {
      cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->mode = SYS_SYS_MODE_NO_SRV;

      ss_ptr->info.hdr_srv_status = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->hdr_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

      cmss_update_hybr_1_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_1));
    }
    else
    // timers running are running in both hdr & hybr2
    {
      CM_MSG_HIGH_0("Both timers are runing...");
    }
  }
  #endif

  //GW(on main) and LTE on hybr2 having full service at a time, need to resolve
  if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)
     && sys_srv_status_is_srv(ss_ptr->info.srv_status)
     && sd_misc_is_mode_pref((sd_ss_mode_pref_e_type)BM(ss_ptr->info.sys_mode),
                              SD_SS_MODE_PREF_TDS_GSM_WCDMA_LTE)
     && sys_srv_status_is_srv(ss_ptr->info.gw_srv_status)
     )
  {
    int no_srv_uptimer_is_running
      = (ss_ptr->no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE) ? 1 : 0;

    int hybr_no_srv_uptimer_is_running
      = (ss_ptr->hybr_gw_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE) ? 1 : 0;

    CM_MSG_HIGH_5("Resolve GW-main-LTE-hy2: sys_mode %d srv_stat %d gw_srv_stat %d no_srv_uptime %d hy_no_srv_uptime %d",
                 ss_ptr->info.sys_mode,ss_ptr->info.srv_status,ss_ptr->info.gw_srv_status,
                no_srv_uptimer_is_running, hybr_no_srv_uptimer_is_running);
   

    // timer running on main for GW but no timer running hybr2(LTE)
    if( (no_srv_uptimer_is_running)
      && !(hybr_no_srv_uptimer_is_running) )
    {
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = SYS_SYS_MODE_NO_SRV;

      ss_ptr->info.srv_status = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->info.sys_mode = SYS_SYS_MODE_NO_SRV;
      ss_ptr->no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

      cmss_update_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN));
    }
    else
    // timer is not running on main for GW but running on hybr2(LTE)
    if( !(no_srv_uptimer_is_running )
      && (hybr_no_srv_uptimer_is_running ) )
    {
      cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode = SYS_SYS_MODE_NO_SRV;

      ss_ptr->info.gw_srv_status = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->info.gw_sys_mode = SYS_SYS_MODE_NO_SRV;
      ss_ptr->hybr_gw_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

      cmss_update_hybr_2_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_2));
    }
    else
    // timers running are running in both Main & hybr2
    {
      CM_MSG_HIGH_0("Both timers are runing...");
    }
  }

  //HDR on main and LTE on hybr2 are having full service at a time, need to resolve
  if(cmph_is_subs_feature_mode_1x_sxlte(SYS_MODEM_AS_ID_1)
     && sys_srv_status_is_srv(ss_ptr->info.srv_status)
     && (ss_ptr->info.sys_mode == SYS_SYS_MODE_HDR)
     && sys_srv_status_is_srv(ss_ptr->info.gw_srv_status)
     && ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_LTE
     )
  {
    int no_srv_uptimer_is_running
      = (ss_ptr->no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE) ? 1 : 0;

    int hybr_no_srv_uptimer_is_running
      = (ss_ptr->hybr_gw_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE) ? 1 : 0;

    CM_MSG_HIGH_5("Resolve HDR-main-LTE-hy2: sys_mode %d, srv_stat %d , gw_srv_stat %d, no_srv_uptime %d,hy_no_srv_uptim %d ",
                ss_ptr->info.sys_mode,ss_ptr->info.srv_status,ss_ptr->info.gw_srv_status,
                no_srv_uptimer_is_running, hybr_no_srv_uptimer_is_running);
    

    // timer running on main for HDR but no timer running hybr2(LTE)
    if( (no_srv_uptimer_is_running)
      && !(hybr_no_srv_uptimer_is_running ) )
    {
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = SYS_SYS_MODE_NO_SRV;

      ss_ptr->info.srv_status = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->info.sys_mode = SYS_SYS_MODE_NO_SRV;
      ss_ptr->no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

      cmss_update_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN));
    }
    else
    // timer is not running on main for HDR but running on hybr2(LTE)
    if( !(no_srv_uptimer_is_running )
      && (hybr_no_srv_uptimer_is_running) )
    {
      cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode = SYS_SYS_MODE_NO_SRV;

      ss_ptr->info.gw_srv_status = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->info.gw_sys_mode = SYS_SYS_MODE_NO_SRV;
      ss_ptr->hybr_gw_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

      cmss_update_hybr_2_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_2));
    }
    else
    // timers running are running in both hdr & hybr2
    {
      CM_MSG_HIGH_0("Both timers are runing...");
    }
  }

  #ifdef FEATURE_HDR_HYBRID
  //HDR on main and HDR on hdr stack are having full service at a time, need to resolve
  if(sys_srv_status_is_srv(ss_ptr->info.srv_status)
     && (ss_ptr->info.sys_mode == SYS_SYS_MODE_HDR)
     && sys_srv_status_is_srv(ss_ptr->info.hdr_srv_status)
     )
  {
    int no_srv_uptimer_is_running
      = (ss_ptr->no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE) ? 1 : 0;

    int hdr_no_srv_uptimer_is_running
      = (ss_ptr->hdr_no_srv_uptime != CMSS_NO_SRV_UPTIME_NONE) ? 1 : 0;

    CM_MSG_HIGH_5("Resolve HDR-main-hdr: sys_mode %d , main srv_status %d , hdr_srv_status %d, Main hdr uptimers Info: no_srv_uptimer on=%d,HDR uptimers Info: no_srv_uptimer on=%d ",
                ss_ptr->info.sys_mode,ss_ptr->info.srv_status,ss_ptr->info.hdr_srv_status,
                no_srv_uptimer_is_running, hdr_no_srv_uptimer_is_running);
   

    // timer running on main for HDR but no timer running on HDR stack
    if( (no_srv_uptimer_is_running )
      && !(hdr_no_srv_uptimer_is_running ) )
    {
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = SYS_SYS_MODE_NO_SRV;

      ss_ptr->info.srv_status = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->info.sys_mode = SYS_SYS_MODE_NO_SRV;
      ss_ptr->no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

      cmss_update_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN));
    }
    else
    // timer is not running on main for HDR but running on hybr2(LTE)
    if( !(no_srv_uptimer_is_running )
      && (hdr_no_srv_uptimer_is_running) )
    {
      cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_intl_srv_info_ptr(CM_SS_HYBR_1)->mode = SYS_SYS_MODE_NO_SRV;

      ss_ptr->info.hdr_srv_status = SYS_SRV_STATUS_NO_SRV;
      ss_ptr->hdr_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

      cmss_update_hybr_1_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_1));
    }
    else
    // timers running are running in both hdr & hybr2
    {
      CM_MSG_HIGH_0("Both timers are runing...");
    }
  }
  #endif

}

/*===========================================================================

FUNCTION cmss_resolve_lte_lte_srv_conflicts

DESCRIPTION
   This will make sure LTE on SUB 1 and LTE on SUB 2will not be notified to clients at the same time
   service at a time.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cmss_resolve_lte_lte_srv_conflicts()
{
  cmss_s_type          *ss_ptr        =  cmss_ptr();
  cmph_s_type* ph_ptr = cmph_ptr();
  
  /*Condition 1 : Multi SIM - SXLTE+G / 7+5 Configuration;
       Condition 2 : Multi SIM - NORMAL+NORMAL*/

  if( ( cmph_is_sub2_map_to_hybr3() && (ss_ptr->info.gw3_sys_mode == SYS_SYS_MODE_LTE)&&
        ( ss_ptr->info.sys_mode == SYS_SYS_MODE_LTE || ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_LTE))||
      ( cmph_is_msim() && !cmph_is_sub2_map_to_hybr3() && (ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_LTE)&&
        ( ss_ptr->info.sys_mode == SYS_SYS_MODE_LTE)))
  {
    CM_MSG_HIGH_3("Resolving conflict of main sys_mode(%d),hybr2 sys_mode(%d), hybr3 sys_mode(%d)",
                ss_ptr->info.sys_mode,ss_ptr->info.gw_sys_mode,ss_ptr->info.gw3_sys_mode);
    /*Mark NON DDS Sub as NO_SRV*/   
    switch (ph_ptr->default_data_subs)
    {
      case SYS_MODEM_AS_ID_1:
	  	/*Map LTE service of SUB 2 to NO SRV as SUB 2 is non DDS*/
        if(cmph_is_sub2_map_to_hybr3())
        {
          cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status = SYS_SRV_STATUS_NO_SRV;
          cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->mode = SYS_SYS_MODE_NO_SRV;

          ss_ptr->info.gw3_srv_status = SYS_SRV_STATUS_NO_SRV;
          ss_ptr->info.gw3_sys_mode = SYS_SYS_MODE_NO_SRV;
          ss_ptr->hybr_3_gw_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;
          #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
          cmss_update_hybr_3_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_3));
          #endif
          /*Inform SUB 2 SRV Info change to clients*/
          cmss_event( CM_SS_HYBR_3, CM_SS_EVENT_SRV_CHANGED );
        }
		else
        {
          cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status = SYS_SRV_STATUS_NO_SRV;
          cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode = SYS_SYS_MODE_NO_SRV;

          ss_ptr->info.gw_srv_status = SYS_SRV_STATUS_NO_SRV;
          ss_ptr->info.gw_sys_mode = SYS_SYS_MODE_NO_SRV;
          ss_ptr->hybr_gw_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;

          cmss_update_hybr_2_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_2));
          /*Inform SUB 2 SRV Info change to clients*/
          cmss_event( CM_SS_HYBR_2, CM_SS_EVENT_SRV_CHANGED );
        }
        break;

        case SYS_MODEM_AS_ID_2:
        /*Map LTE service of SUB 1 to NO SRV as SUB 1 is non DDS*/
        if( ss_ptr->info.sys_mode == SYS_SYS_MODE_LTE)
        {
          cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = SYS_SRV_STATUS_NO_SRV;
          cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode = SYS_SYS_MODE_NO_SRV;

          ss_ptr->info.srv_status = SYS_SRV_STATUS_NO_SRV;
          ss_ptr->info.sys_mode = SYS_SYS_MODE_NO_SRV;
          ss_ptr->no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;
  
          cmss_update_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN));
        }
        if( cmph_is_sub2_map_to_hybr3() && (ss_ptr->info.gw_sys_mode == SYS_SYS_MODE_LTE))
        {
          cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status = SYS_SRV_STATUS_NO_SRV;
          cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode = SYS_SYS_MODE_NO_SRV;
			
          ss_ptr->info.gw_srv_status = SYS_SRV_STATUS_NO_SRV;
          ss_ptr->info.gw_sys_mode = SYS_SYS_MODE_NO_SRV;
          ss_ptr->hybr_gw_no_srv_uptime = CMSS_NO_SRV_UPTIME_NONE;
			  
          cmss_update_hybr_2_no_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_HYBR_2));
        }
        /*Inform SUB 1 SRV Info change to clients*/
        cmss_event( CM_SS_MAIN, CM_SS_EVENT_SRV_CHANGED );

        break;
		
	  default:
	  	break;
	}
  }
}

/*===========================================================================


#if 0
static void cmss_modem_reset_timer_init(void)
{
  CM_MSG_HIGH_0("cmss_modem_reset_timer_init() called");
  timer_def(&cmss_modem_reset_timer,&cmss_modem_reset_timer_group,NULL,0,cmss_modem_reset_timer_expire_handler,(timer_cb_data_type)cmss_modem_reset_trigger);
}

static cmss_modem_reset_trigger_s_type* cmss_check_if_modem_need_reset()
{
  cmss_s_type* ss_ptr = cmss_ptr();
  sys_srv_status_e_type srv_status_0 = ss_ptr->main_srv_status;
  sys_srv_status_e_type srv_status_1 = ss_ptr->hybr_gw_srv_status;
  sys_srv_status_e_type srv_status_2 = ss_ptr->hybr_3_gw_srv_status;

  cmph_s_type* ph_ptr = cmph_ptr();
  sys_oprt_mode_e_type oprt_mode = ph_ptr->oprt_mode;

  boolean has_cs_call_0 = cmcall_check_if_gw_cs_call_active(CM_CALL_STATE_NONE,CM_SS_MAIN);
  boolean has_active_ps_call_0 = cmcall_check_if_ps_call_active(CM_SS_MAIN);

  boolean has_cs_call_1 = cmcall_check_if_gw_cs_call_active(CM_CALL_STATE_NONE,CM_SS_HYBR_2);
  boolean has_active_ps_call_1 = cmcall_check_if_ps_call_active(CM_SS_HYBR_2);

  boolean has_cs_call_2 = cmcall_check_if_gw_cs_call_active(CM_CALL_STATE_NONE,CM_SS_HYBR_3);
  boolean has_active_ps_call_2 = cmcall_check_if_ps_call_active(CM_SS_HYBR_3);

  cmss_modem_reset_trigger_s_type* trigger=NULL;

  CM_MSG_HIGH_1("cmss_check_if_modem_need_reset(),oprt mode=%d",oprt_mode);

  CM_MSG_HIGH_0("srv_status_0=%d,cs0=%d,ps0=%d");
  CM_MSG_HIGH_3("srv_status_1=%d,cs1=%d,ps1=%d",srv_status_1,has_cs_call_1,has_active_ps_call_1);
  CM_MSG_HIGH_3("srv_status_2=%d,cs2=%d,ps2=%d",srv_status_2,has_cs_call_2,has_active_ps_call_2);

  if( (cmss_can_trigger_modem_reset_0 == TRUE) &&
       (cmss_can_trigger_modem_reset_1 == TRUE)
       &&(!cmph_is_tsts() || cmss_can_trigger_modem_reset_2 == TRUE)
       )
  {
    CM_MSG_HIGH_2("SUB1=%d,SUB2=%d.Enable Modem Reset Feature",cmss_can_trigger_modem_reset_0,cmss_can_trigger_modem_reset_1);
  }
  else
  {
    CM_MSG_HIGH_2("SUB1=%d,SUB2=%d.Modem Reset Feature not enabled",cmss_can_trigger_modem_reset_0,cmss_can_trigger_modem_reset_1);
    trigger=NULL;
    return trigger;
  }

  // Stop the timer if the triggered sub has acquired service

  if ( cmss_modem_reset_trigger!= NULL )
  {
    CM_MSG_HIGH_0("Modem Reset Timer Running. Check status");

    if ( (  (cmss_modem_reset_trigger->as_id == SYS_MODEM_AS_ID_1) && !((srv_status_0 == SYS_SRV_STATUS_NO_SRV)
           && (ph_ptr->active_subs & SYS_MODEM_AS_ID_1_MASK))) ||
         (  (cmss_modem_reset_trigger->as_id == SYS_MODEM_AS_ID_2) && !((srv_status_1 == SYS_SRV_STATUS_NO_SRV)
         && (ph_ptr->active_subs & SYS_MODEM_AS_ID_2_MASK))) ||
         (  (cmss_modem_reset_trigger->as_id == SYS_MODEM_AS_ID_3) && !((srv_status_2 == SYS_SRV_STATUS_NO_SRV)
         && (ph_ptr->active_subs & SYS_MODEM_AS_ID_3_MASK)))
       )
    {
      CM_MSG_HIGH_0("Cancel Modem Reset Timer. Sub recovered");
      timer_clr(&cmss_modem_reset_timer, T_MIN);
      cmss_modem_reset_timer_fired=FALSE;
      cm_mem_free(cmss_modem_reset_trigger);
      cmss_modem_reset_trigger=NULL;
    }
  }

  if ((oprt_mode == SYS_OPRT_MODE_ONLINE) && (srv_status_0 == SYS_SRV_STATUS_NO_SRV)\
    && (ph_ptr->active_subs & SYS_MODEM_AS_ID_1_MASK)\
    &&(!has_cs_call_1)&&(!has_active_ps_call_1) && (!has_cs_call_2) &&(!has_active_ps_call_2))
  {
    CM_MSG_HIGH_0("SUB0 OOS,generate a reset trigger");
    trigger = cm_mem_malloc(sizeof(cmss_modem_reset_trigger_s_type));
    trigger->as_id = SYS_MODEM_AS_ID_1;
    trigger->time = 0xffff;
  }
  else if ((oprt_mode == SYS_OPRT_MODE_ONLINE)&&(srv_status_1 == SYS_SRV_STATUS_NO_SRV)\
    && (ph_ptr->active_subs & SYS_MODEM_AS_ID_2_MASK)\
    &&(!has_cs_call_0)&&(!has_active_ps_call_0) && (!has_cs_call_2) &&(!has_active_ps_call_2))
  {
    CM_MSG_HIGH_0("SUB1 OOS,generate a reset trigger");
    trigger = cm_mem_malloc(sizeof(cmss_modem_reset_trigger_s_type));
    trigger->as_id = SYS_MODEM_AS_ID_2;
    trigger->time = 0xffff;
  }
  else if ((cmph_is_tsts()) && ((oprt_mode == SYS_OPRT_MODE_ONLINE)&&\
    (srv_status_2 == SYS_SRV_STATUS_NO_SRV)&&(ph_ptr->active_subs & SYS_MODEM_AS_ID_3_MASK)\
    &&(!has_cs_call_0)&&(!has_active_ps_call_0) && (!has_cs_call_1) &&(!has_active_ps_call_1)))
  {
    CM_MSG_HIGH_0("SUB2 OOS,generate a reset trigger");
    trigger = cm_mem_malloc(sizeof(cmss_modem_reset_trigger_s_type));
    trigger->as_id = SYS_MODEM_AS_ID_3;
    trigger->time = 0xffff;
  }
  else
  {
    trigger = NULL;
  }

  return trigger;
}

static void cmss_modem_reset_start_timer(cmss_modem_reset_trigger_s_type *trigger)
{
  if (trigger == NULL)
  {
    CM_ERR_0("TRIGGER IS NULL,ERROR");
    return;
  }

  if (cmss_modem_reset_trigger != NULL)
  {
    CM_MSG_HIGH_0("TRIGGER exists,ignore");
    cm_mem_free(trigger);
  }
  else
  {
    cmss_modem_reset_trigger = trigger;
  }

  if (!cmss_modem_reset_timer_fired)
  {
    CM_MSG_HIGH_0("modem reset timer fired");
    timer_set(&cmss_modem_reset_timer, CMSS_MODEM_RESET_TIMER_EXPIRE_TIME, 0, T_MIN);
    cmss_modem_reset_timer_fired=TRUE;
  }

}

static void cmss_modem_reset_timer_expire_handler(timer_cb_data_type data)
{
  cm_generic_rpt_s_type *cm_generic_rpt_ptr;
  CM_MSG_HIGH_0("MODEM RESET timer expired");

  if ((cm_generic_rpt_ptr = cm_generic_rpt_get_buf_else_err_fatal())!=NULL)
  {
    cm_generic_rpt_ptr->hdr.cmd = CM_MODEM_RESET_TIMER_RPT;
    cm_generic_rpt(cm_generic_rpt_ptr);
  }
}

void cmss_process_modem_reset_rpt(void)
{
  cmss_s_type* ss_ptr = cmss_ptr();
  sys_srv_status_e_type srv_status_0 = ss_ptr->main_srv_status;
  sys_srv_status_e_type srv_status_1 = ss_ptr->hybr_gw_srv_status;
  sys_srv_status_e_type srv_status_2 = ss_ptr->hybr_3_gw_srv_status;

  cmph_s_type* ph_ptr = cmph_ptr();
  sys_oprt_mode_e_type oprt_mode = ph_ptr->oprt_mode;

  boolean has_cs_call_0 = cmcall_check_if_gw_cs_call_active(CM_CALL_STATE_NONE,CM_SS_MAIN);
  boolean has_active_ps_call_0 = cmcall_check_if_ps_call_active(CM_SS_MAIN);

  boolean has_cs_call_1 = cmcall_check_if_gw_cs_call_active(CM_CALL_STATE_NONE,CM_SS_HYBR_2);
  boolean has_active_ps_call_1 = cmcall_check_if_ps_call_active(CM_SS_HYBR_2);

  boolean has_cs_call_2 = cmcall_check_if_gw_cs_call_active(CM_CALL_STATE_NONE,CM_SS_HYBR_3);
  boolean has_active_ps_call_2 = cmcall_check_if_ps_call_active(CM_SS_HYBR_3);

  boolean lpm = FALSE;
  sys_modem_as_id_e_type trigger_sub = (cmss_modem_reset_trigger!=NULL)?cmss_modem_reset_trigger->as_id:SYS_MODEM_AS_ID_1;

  cmss_modem_reset_trigger_s_type* new_trigger = NULL;

  CM_MSG_HIGH_0("process modem reset rpt.");

  CM_MSG_HIGH_1("cmss_process_modem_reset_rpt(),oprt mode=%d",oprt_mode);

  CM_MSG_HIGH_0("srv_status_0=%d,cs1=%d,ps1=%d");
  CM_MSG_HIGH_3("srv_status_1=%d,cs1=%d,ps1=%d",srv_status_1,has_cs_call_1,has_active_ps_call_1);
  CM_MSG_HIGH_3("srv_status_2=%d,cs2=%d,ps2=%d",srv_status_2,has_cs_call_2,has_active_ps_call_2);
  CM_MSG_HIGH_1("cmss_process_modem_reset_rpt()trigger_sub=%d",trigger_sub);

  if (trigger_sub == SYS_MODEM_AS_ID_1)
  {
    lpm = ((oprt_mode == SYS_OPRT_MODE_ONLINE) && (srv_status_0 == SYS_SRV_STATUS_NO_SRV)&&(!has_cs_call_1)&&(!has_active_ps_call_1)\
        && (!has_cs_call_2) &&(!has_active_ps_call_2));
  }

  if (trigger_sub == SYS_MODEM_AS_ID_2)
  {
    lpm = ((oprt_mode == SYS_OPRT_MODE_ONLINE)&&(srv_status_1 == SYS_SRV_STATUS_NO_SRV)&&(!has_cs_call_0)&&(!has_active_ps_call_0)\
             && (!has_cs_call_2) &&(!has_active_ps_call_2));
  }

  if(cmph_is_tsts() && trigger_sub == SYS_MODEM_AS_ID_3)
  {
    lpm = ((oprt_mode == SYS_OPRT_MODE_ONLINE)&&(srv_status_2 == SYS_SRV_STATUS_NO_SRV)&&(!has_cs_call_0)&&(!has_active_ps_call_0)\
             && (!has_cs_call_1) &&(!has_active_ps_call_1));
  }

  if (lpm)
  {
    CM_MSG_HIGH_0("ENTER lpm due to modem reset");
    cm_ph_cmd_oprt_mode(NULL,NULL,CM_CLIENT_ID_ANONYMOUS,SYS_OPRT_MODE_LPM);
  }

  cmss_modem_reset_timer_fired = FALSE;
  if (cmss_modem_reset_trigger != NULL)
  {
    cm_mem_free(cmss_modem_reset_trigger);
  }
  cmss_modem_reset_trigger = NULL;

  if (!lpm)
  {
    CM_MSG_HIGH_0("trigger sub becomes OK, check the other");
    if (trigger_sub != SYS_MODEM_AS_ID_1)
    {
      lpm = ((oprt_mode == SYS_OPRT_MODE_ONLINE) && (srv_status_0 == SYS_SRV_STATUS_NO_SRV)&&(!has_cs_call_1)&&(!has_active_ps_call_1)\
        && (!has_cs_call_2) &&(!has_active_ps_call_2));
    }

    if (trigger_sub != SYS_MODEM_AS_ID_2)
    {
       lpm = ((oprt_mode == SYS_OPRT_MODE_ONLINE)&&(srv_status_1 == SYS_SRV_STATUS_NO_SRV)&&(!has_cs_call_0)&&(!has_active_ps_call_0)\
                && (!has_cs_call_2) &&(!has_active_ps_call_2));
    }

    if (cmph_is_tsts() && trigger_sub != SYS_MODEM_AS_ID_3)
    {
      lpm = ((oprt_mode == SYS_OPRT_MODE_ONLINE)&&(srv_status_2 == SYS_SRV_STATUS_NO_SRV)&&(!has_cs_call_0)&&(!has_active_ps_call_0)\
               && (!has_cs_call_1) &&(!has_active_ps_call_1));
    }

    if (lpm)
    {
      new_trigger = cmss_check_if_modem_need_reset();
      if (new_trigger != NULL)
      {
        if (((new_trigger->as_id==SYS_MODEM_AS_ID_1)&&cmss_can_trigger_modem_reset_0)||
            ((new_trigger->as_id==SYS_MODEM_AS_ID_2)&&cmss_can_trigger_modem_reset_1)||
            ((new_trigger->as_id==SYS_MODEM_AS_ID_3)&&cmss_can_trigger_modem_reset_2))
        {
          cmss_modem_reset_start_timer(new_trigger);
        }
        else
        {
          cm_mem_free(new_trigger);
        }
      }
    }
  }
}
#endif
/*===========================================================================

FUNCTION cmss_clear_reg_reject_info

DESCRIPTION
   Clear the registration reject info in ss ptr and sends srv_change event if needed


DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

void cmss_clear_reg_reject_info
(
  sys_plmn_service_state_s_type  *srv_info_ptr ,
  sd_ss_e_type      ss
){

  cmss_s_type * ss_ptr = cmss_ptr();
  cm_reg_reject_info_s_type *reg_reject_info = NULL;

  if( ss == SD_SS_HYBR_2 )
  {
    reg_reject_info = &ss_ptr->info.gw_reg_reject_info;
  }
  else if (ss== SD_SS_MAIN)
  {
    reg_reject_info = &ss_ptr->info.reg_reject_info;
  }
  else if (ss == SD_SS_HYBR_3)
 {
    reg_reject_info = &ss_ptr->info.gw3_reg_reject_info;
  }

  else
  {
    return ;
  }
  if(  (reg_reject_info->reject_srv_domain != SYS_SRV_DOMAIN_NONE
        ||
        reg_reject_info->reject_cause != 0)
     )
    {
      reg_reject_info->reject_srv_domain = SYS_SRV_DOMAIN_NONE ;
      reg_reject_info->reject_cause = 0 ;
      cmss_event(cmph_map_sd_ss_type_to_cm_ss_type(ss), CM_SS_EVENT_SRV_CHANGED);
      CM_MSG_HIGH_1("Clear reject cause, %d",ss);
    }
}
/*===========================================================================

FUNCTION cmss_proc_irat_complete

DESCRIPTION
   Process the IRAT complete indication from CMREGPRX by notified the infor.
   to clients.


DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void  cmss_proc_irat_complete ( void )
{
  cmss_s_type             *ss_ptr = cmss_ptr();
    /* Point at serving system object */
  boolean                 data_suspend_delay = FALSE;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Reset skip_srv_ind_update so that srv_ind will be notified to clients base on its
  ** timeline.
  */
  if(ss_ptr->skip_srv_ind_update == TRUE)
  {
    cmss_update_skip_srv_ind_update(FALSE);

    /* Update Main service info database with new service status */
    if(sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status))
    {
      cmss_update_srv_ind_info(ss_ptr,
                                    cmss_intl_srv_info_ptr(CM_SS_MAIN),
                                    FALSE);
    }
    else
    {
      cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_update_no_srv_ind_info(ss_ptr,
                                  cmss_intl_srv_info_ptr(CM_SS_MAIN));
    }

    /* Then update Hybr-2 service info database with new service status */
    if(sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status))
    {
      cmss_update_hybr_2_lmtd_srv_ind_info(ss_ptr,
                                           cmss_intl_srv_info_ptr(CM_SS_HYBR_2),
                                           FALSE);
    }
    else
    {
      cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status = SYS_SRV_STATUS_NO_SRV;
      cmss_update_hybr_2_no_srv_ind_info(ss_ptr,
                                         cmss_intl_srv_info_ptr(CM_SS_HYBR_2));
    }

    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    /* Notify CM clients */
    cmss_event(CM_SS_MAX, CM_SS_EVENT_SRV_CHANGED);

    if (cmss_delay_data_suspend_retrieve(&data_suspend_delay))
    {
      cmss_process_data_suspend_rpt(data_suspend_delay);
    }
  }
}

/*===========================================================================

FUNCTION cmss_reset_cell_info_upon_hybr_gw_change

DESCRIPTION
  Reset gw cell info id when Hybr2 stack is removed(hybr gw not operational)
  Reset main cell info when hybr gw becomes operational

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.
===========================================================================*/
void cmss_reset_cell_info_upon_hybr_gw_change
(
  boolean  is_hybr_gw_operational,

  sys_modem_as_id_e_type              asubs_id
)
{
  cmss_s_type             *ss_ptr = cmss_ptr();

  if(!is_hybr_gw_operational  && cmph_is_subs_feature_mode_svlte(asubs_id) )
  {
    ss_ptr->info.gw_cell_info.cell_id = CMSS_INVALID_CELL_ID_INFO;
    CM_MSG_HIGH_1("Reset GW cell info as hybr gw is : %d",is_hybr_gw_operational);
  }

}


/*===========================================================================

FUNCTION cmss_get_ss_operational_flag

DESCRIPTION
  Get the operational flag for the specified cm_ss.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if the specified stack is operational.

SIDE EFFECTS
  None.
===========================================================================*/
boolean    cmss_get_ss_operational_flag
(
        cm_ss_e_type  cm_ss
)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  if (cm_ss == CM_SS_MAIN || cm_ss == CM_SS_HYBR_1)
  {
    return (ss_ptr->info.is_main_operational);
  }

  else if (cm_ss == CM_SS_HYBR_2)
  {
    return (ss_ptr->info.is_hybr_gw_operational);
  }

  else if (cm_ss == CM_SS_HYBR_3)
  {
    return (ss_ptr->info.is_gw3_operational);
  }

  else
  {
    CM_ERR_1("Invalid cm_ss = %d", cm_ss);
    return FALSE;
  }
}


/*===========================================================================

===========================================================================*/

sys_modem_stack_id_e_type cmss_map_msc_stack_to_ssevt_idx(

  sys_modem_as_id_e_type as_id,
  sd_ss_e_type sd_ss
)
{
  int msc_idx = cmmsc_mapping_ss_to_stack_idx(
                                    cmph_map_sd_ss_type_to_cm_ss_type(sd_ss));

  if(cmph_is_subs_feature_mode_sglte(as_id))
  {
    switch(msc_idx)
    {
      case 0:
        return SYS_MODEM_STACK_ID_1;
      case 1:
        return SYS_MODEM_STACK_ID_2;
    }
  }
  else
  {
    switch(msc_idx)
    {
      case 0:
        return SYS_MODEM_STACK_ID_1;
      case 1:
      case 2:
        return SYS_MODEM_STACK_ID_2;
    }
  }

  return SYS_MODEM_STACK_ID_1;
}


/*===========================================================================

FUNCTION cmss_send_mcc_msg

DESCRIPTION
  This functions sends a messages to generic report queues updating the latest
  MCC that has been detected. This MCC information would be used in prediction
  algorithm.

DEPENDENCIES
  none

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_send_mcc_msg( const sd_mcc_rpt_s_type *sd_rpt )
{
  cm_generic_rpt_s_type   *soa_rpt_ptr = NULL;
  soa_rpt_ptr             = cm_generic_rpt_get_buf_else_err_fatal();

  if (soa_rpt_ptr == NULL)
  {
    sys_err_fatal_null_ptr_exception();
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  soa_rpt_ptr->hdr.cmd = CM_SOA_MSG_MCC;

  soa_rpt_ptr->generic_rpt.mcc_msg.ss = sd_rpt->ss;
  soa_rpt_ptr->generic_rpt.mcc_msg.mcc = sd_rpt->mcc;
  soa_rpt_ptr->generic_rpt.mcc_msg.plmn_id = sd_rpt->plmn_id;
  soa_rpt_ptr->generic_rpt.mcc_msg.mode = sd_rpt->mode;
  soa_rpt_ptr->generic_rpt.mcc_msg.srv_status = sd_rpt->srv_status;

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  CM_MSG_HIGH_0("CMSOA: cmsoa send mcc_msg()");

  cm_generic_rpt(soa_rpt_ptr);
}

/*===========================================================================

FUNCTION cmss_get_gw_sim_state_ss

DESCRIPTION
  Get the sim state for the corresponding stack.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
 sys_sim_state_e_type cmss_get_gw_sim_state_ss(

   cm_ss_e_type ss

 )
 {
    /* Pointer to serving system object */
   cmss_s_type       *ss_ptr       = cmss_ptr();


   if ( ss == CM_SS_HYBR_2 )
   {
     return(ss_ptr->info.gw_mode_info.gw_info.sim_state);
   }
   else
   #if defined(FEATURE_MMODE_TRIPLE_SIM) || defined(FEATURE_MMODE_SXLTE_G)
   if ( ss == CM_SS_HYBR_3 )
   {
     return(ss_ptr->info.gw3_mode_info.gw_info.sim_state);
   }
   else
   #endif
   {
     return(ss_ptr->info.mode_info.gw_info.sim_state);
   }
}

/*===========================================================================

FUNCTION cmss_get_no_srv_uptime

DESCRIPTION
  Get the no_srv_uptime for the corresponding stack.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
dword cmss_get_no_srv_uptime( cm_ss_e_type cm_ss)
{
  switch(cm_ss)
  {
     case CM_SS_MAIN:
       return cmss_ptr()->no_srv_uptime;

     #if (defined (FEATURE_HDR_HYBRID))
     case CM_SS_HYBR_1:
       return cmss_ptr()->hdr_no_srv_uptime;
     #endif

     case CM_SS_HYBR_2:
       return cmss_ptr()->hybr_gw_no_srv_uptime;

     case CM_SS_HYBR_3:
       return cmss_ptr()->hybr_3_gw_no_srv_uptime;

     default:
       CM_MSG_HIGH_1("Invalid CM SS %d for no_srv_uptime",cm_ss);
       return CMSS_NO_SRV_UPTIME_NONE;
  }
}

/*===========================================================================

FUNCTION cmss_reset_sys_id_info

DESCRIPTION
  clears the plmn id information in cmss structure

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/

 void cmss_reset_sys_id_info(void)

 {

   cmss_s_type           *ss_ptr  =  cmss_ptr();

   sys_modem_as_id_e_type as_id_val = SYS_MODEM_AS_ID_NONE ;
   int stack_id_val = 0 ;
   

        /* Point at serving system object to be initialized */
   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   sys_undefine_sys_id( &ss_ptr->info.sys_id);
   sys_undefine_sys_id( &ss_ptr->info.hdr_sys_id );
   sys_undefine_sys_id( &ss_ptr->info.gw_sys_id);
   sys_undefine_sys_id( &ss_ptr->info.gw3_sys_id );

   /********************************************************************************************************/
   #if defined(FEATURE_TRIPLE_SIM)
   for(as_id_val =SYS_MODEM_AS_ID_1 ; as_id_val <=SYS_MODEM_AS_ID_3 ; as_id_val++)
   #else
   for(as_id_val =SYS_MODEM_AS_ID_1 ; as_id_val <=SYS_MODEM_AS_ID_2 ; as_id_val++)
   #endif
   {
    for(stack_id_val =0 ; stack_id_val <= 1; stack_id_val++ )
    {
     sys_undefine_sys_id( &ss_ptr->new_srv_avl_info[as_id_val].stack_info[stack_id_val].sys_id );
    }

   }

   return;

 }

 /*===========================================================================
 
 FUNCTION cmss_get_true_sys_mode
 
 DESCRIPTION
   Gets true sys mode taking buffered service indications into consideration
 
 DEPENDENCIES
   Serving system object must have already been initialized with
   cmss_init().
 
 RETURN VALUE
   actual sys mode of that stack
 
 SIDE EFFECTS
   none
 
 ===========================================================================*/
 sys_sys_mode_e_type cmss_get_true_sys_mode(cm_ss_e_type ss)
 {
   if(ss < CM_SS_MAIN || ss > CM_SS_HYBR_3)
   {
     ss = CM_SS_MAIN;
   }
   if((cmss_intl_srv_info_ptr(ss)->srv_status ==
       SYS_SRV_STATUS_LIMITED_INTERNAL ) ||
      (cmss_intl_srv_info_ptr(ss)->srv_status ==
       SYS_SRV_STATUS_LIMITED_REGIONAL_INTERNAL )
     )
   {
     return cmss_intl_srv_info_ptr(ss)->mode;
   }

   
   if((cmss_intl_srv_info_ptr(ss)->srv_status ==
       SYS_SRV_STATUS_NO_SRV_INTERNAL) ||
      (cmss_intl_srv_info_ptr(ss)->srv_status ==
       SYS_SRV_STATUS_PWR_SAVE_INTERNAL )
     )
   {
     return SYS_SYS_MODE_NO_SRV;
   }

   #if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
   if(ss == CM_SS_HYBR_3)
   {
     return cmss_ptr()->info.gw3_sys_mode;
   }
   else
   #endif
   if (ss == CM_SS_HYBR_2)
   {
     return cmss_ptr()->info.gw_sys_mode;
   }
   else
   {
     return cmss_ptr()->info.sys_mode;
   }
 }

/*===========================================================================

FUNCTION cmph_evaluate_effect_srv_domain_send_ss_event

DESCRIPTION
  send SS Event to clients if effective service domain is updated

DEPENDENCIES
  None

RETURN VALUE
  boolean

SIDE EFFECTS
  None.

===========================================================================*/
void cmss_evaluate_effect_srv_domain_send_ss_event(void)
{

  cmss_s_type                   *ss_ptr = cmss_ptr();
  /* Point at serving system object */

  cm_mm_msim_ss_info_s_type          *ss_info_ptr_new;

  sys_srv_domain_e_type  new_effective_domain = SYS_SRV_DOMAIN_NONE;

  new_effective_domain = cmph_get_effective_srv_domain(SYS_MODEM_AS_ID_1, ss_ptr->new_srv_avl_info[SYS_MODEM_AS_ID_1].stack_info[0].srv_domain);

  if(new_effective_domain != ss_ptr->new_srv_avl_info[SYS_MODEM_AS_ID_1].stack_info[0].effective_srv_domain
	  && ss_ptr->info.sys_mode == SYS_SYS_MODE_CDMA)
  {
	/*
    ** Get a buffer for serving system information.
    */

    ss_info_ptr_new = cmss_info_alloc_new();

	(void) cmss_info_get_new( ss_info_ptr_new, &ss_ptr->new_srv_avl_info[SYS_MODEM_AS_ID_1], SYS_MODEM_AS_ID_1);
    
	/*update the ss ptr new effective domain*/
	ss_ptr->new_srv_avl_info[SYS_MODEM_AS_ID_1].stack_info[0].effective_srv_domain = new_effective_domain;
	ss_info_ptr_new->stack_info[0].effective_srv_domain = new_effective_domain;
        ss_info_ptr_new->stack_info[0].changed_fields = 0;
	ss_info_ptr_new->stack_info[0].changed_fields2 = 0;
	ss_info_ptr_new->stack_info[0].changed_fields2 |= CM_SS_EVT_EFFECTV_SRV_DOMAIN_MASK;

	cmclient_list_ss_event_ntfy_new(CM_SS_EVENT_SRV_CHANGED , ss_info_ptr_new);
	cm_mem_free(ss_info_ptr_new);
  }
  return;

}

/*===========================================================================

FUNCTION cmss_remove_srv_domain_comp

DESCRIPTION
   Remvoe a srv domain component from srv_domain_val

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  New srv domain type

SIDE EFFECTS
  none

===========================================================================*/
static sys_srv_domain_e_type cmss_remove_srv_domain_comp
(
   sys_srv_domain_e_type  srv_domain_val,
     /* Srv domain value that needs to have a component removed
     */

   sys_srv_domain_e_type  srv_domain_comp
     /* Srv domain component that needs to be removed
     */
)
{

  CM_ASSERT (INRANGE (srv_domain_val, SYS_SRV_DOMAIN_NO_SRV, SYS_SRV_DOMAIN_CS_PS));

  CM_ASSERT (INRANGE (srv_domain_comp, SYS_SRV_DOMAIN_CS_ONLY, SYS_SRV_DOMAIN_PS_ONLY));

  /* Remove CS component from value
  */
  if (srv_domain_comp == SYS_SRV_DOMAIN_CS_ONLY)
  {
    if (srv_domain_val == SYS_SRV_DOMAIN_CS_PS)
    {
      srv_domain_val = SYS_SRV_DOMAIN_PS_ONLY;
    }
    else if (srv_domain_val == SYS_SRV_DOMAIN_CS_ONLY)
    {
      srv_domain_val = SYS_SRV_DOMAIN_NO_SRV;
    }
  }


  /* Remove PS component from value
  */
  if (srv_domain_comp == SYS_SRV_DOMAIN_PS_ONLY)
  {
    if (srv_domain_val == SYS_SRV_DOMAIN_CS_PS)
    {
      srv_domain_val = SYS_SRV_DOMAIN_CS_ONLY;
    }
    else if (srv_domain_val == SYS_SRV_DOMAIN_PS_ONLY)
    {
      srv_domain_val = SYS_SRV_DOMAIN_NO_SRV;
    }
  }

  return srv_domain_val;

}/* cmss_remove_srv_domain_comp */

/*===========================================================================

FUNCTION cmss_remove_srv_domain_comp

DESCRIPTION
   Remvoe a srv domain component from srv_domain_val

DEPENDENCIES
  Serving System object must have already been initialized with
  cmss_init().

RETURN VALUE
  New srv domain type

SIDE EFFECTS
  none

===========================================================================*/

sys_srv_domain_e_type cmph_get_effective_srv_domain(
	sys_modem_as_id_e_type  as_id, 

	/*
	 subs id information
	*/

	sys_srv_domain_e_type srv_domain
	
	/* registered service domain
	*/
	
	)
{

	cmph_s_type                  *ph_ptr  = cmph_ptr ();

    cm_srv_domain_pref_e_type    prst_srv_domain_pref = CM_SRV_DOMAIN_PREF_NONE;

	if (!(srv_domain > SYS_SRV_DOMAIN_NO_SRV && srv_domain < SYS_SRV_DOMAIN_CAMPED))
	{
	  return srv_domain;
	}

	if(as_id == SYS_MODEM_AS_ID_1)
	{
      prst_srv_domain_pref = ph_ptr->prst_main_stack_info[ph_ptr->curr_nam].srv_domain_pref;
	}
	#if defined(FEATURE_MMODE_SXLTE_G) || defined(FEATURE_MMODE_TRIPLE_SIM)
	else if((as_id == SYS_MODEM_AS_ID_2 && cmph_is_sxlte()) || (as_id == SYS_MODEM_AS_ID_3) )
	{
	  prst_srv_domain_pref = ph_ptr->prst_hybr_3_stack_info[ph_ptr->curr_nam].srv_domain_pref;
	}
    #endif
	else if(as_id == SYS_MODEM_AS_ID_2)
	{
      prst_srv_domain_pref = ph_ptr->prst_hybr_2_stack_info[ph_ptr->curr_nam].srv_domain_pref;
	}

	if( (ph_ptr->standby_pref != SYS_MODEM_DS_PREF_SINGLE_STANDBY) &&
		((ph_ptr->default_data_subs != as_id && (cmpmprx_get_num_of_active_data() != 2))
		|| ((cmpmprx_get_num_of_active_data() == 2) && prst_srv_domain_pref != CM_SRV_DOMAIN_PREF_CS_PS)) 
	  )
	{
	   return cmss_remove_srv_domain_comp (srv_domain, SYS_SRV_DOMAIN_PS_ONLY);
	}
	else
	{
		return srv_domain;
	}
 
}

/*===========================================================================
FUNCTION  cmss_reset_cdma_hold_srv_uptime

DESCRIPTION
 Reset cdma_hold_srv_uptime to NONE and update CDMA service.

DEPENDENCIES


RETURN VALUE
  none

SIDE EFFECTS
  none

===========================================================================*/
void cmss_reset_cdma_hold_srv_uptime(void)
{
  cmss_s_type *ss_ptr = cmss_ptr();

  if (cmph_ptr()->cdma_hold_srv_timer > 0 && 
      ss_ptr->cdma_hold_srv_uptime!= CMSS_INFORM_SRV_CHANGE_INTER_NONE)
  {
    // converting internal srv status to actual srv status
    cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status =
    sys_intl_srv_status_to_actl_srv_status(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status);

    // update 1x srv info to clients
    cmss_update_srv_ind_info(ss_ptr, cmss_intl_srv_info_ptr(CM_SS_MAIN), FALSE);

    // reset 1x hold srv uptime
    ss_ptr->cdma_hold_srv_uptime = CMSS_INFORM_SRV_CHANGE_INTER_NONE;

    CM_MSG_HIGH_0("cdmaholdsrv: RESET cdma_hold_srv_uptime");
  }
}

/*===========================================================================

FUNCTION cmss_start_hy2_oper_flag_timer

DESCRIPTION
  Start the timer to buffer the value of is_operational flag on the outgoing
  CM SS Events.

DEPENDENCIES
  Serving system object must have already been initialized with
  cmss_init().

RETURN VALUE
  None

SIDE EFFECTS
  none

===========================================================================*/
 void cmss_start_hy2_oper_flag_timer( void )
{
  cmss_s_type *ss_ptr  =  cmss_ptr();

  if (ss_ptr->hold_hy2_oper_flag_uptime != CMSS_NO_SRV_UPTIME_NONE)
  {
    CM_ERR_1("Hybrid2 stack is_operational flag already being buffered for %d",
             ss_ptr->hold_hy2_oper_flag_uptime - time_get_uptime_secs());
    return;
  }

  ss_ptr->hold_hy2_oper_flag_uptime = time_get_uptime_secs() +
                                      ss_ptr->hold_hy2_oper_flag_timer_value;

  CM_MSG_HIGH_2("Buffer Hybrid2 is_operational flag till time: %d, curr_time: %d",ss_ptr->hold_hy2_oper_flag_uptime,time_get_uptime_secs());
  return;
}

/*===========================================================================
  FUNCTION cmss_is_ss_in_full_srv

  DESCRIPTION
    Tells if given ss is in full service or not.

  DEPENDENCIES

  RETURN VALUE
    true if in full service
    false if not

  SIDE EFFECTS
    none
===========================================================================*/
boolean cmss_is_ss_in_full_srv(cm_ss_e_type cm_ss)
{
  if ( ((cm_ss == CM_SS_MAIN || cm_ss == CM_SS_MAX) && 
                    sys_srv_status_is_full_srv(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status))    
     ||
     ((cm_ss == CM_SS_HYBR_2) && 
                    sys_srv_status_is_full_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status))
     ||
     ((cm_ss == CM_SS_HYBR_3) && 
                   sys_srv_status_is_full_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status))
    )     
  {
    return TRUE;
  }
    
  return FALSE;
    
}

/*===========================================================================
  FUNCTION cmss_is_ss_in_lmtd_srv

  DESCRIPTION
    Tells if given ss is in limited service or not.

  DEPENDENCIES

  RETURN VALUE
    true if in full service
    false if not

  SIDE EFFECTS
    none
===========================================================================*/
boolean cmss_is_ss_in_lmtd_srv(cm_ss_e_type cm_ss)
{
  if ( ((cm_ss == CM_SS_MAIN || cm_ss == CM_SS_MAX) && 
                    sys_srv_status_is_lmtd_srv(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status))    
     ||
     ((cm_ss == CM_SS_HYBR_2) && 
                    sys_srv_status_is_lmtd_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status))
     ||
     ((cm_ss == CM_SS_HYBR_3) && 
                   sys_srv_status_is_lmtd_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status))
    )     
  {
    return TRUE;
  }
    
  return FALSE;
    
}
/*===========================================================================

FUNCTION cmss_get_intl_srv_lte_ss

DESCRIPTION
  Returns the ss which has LTE from the internal service information

DEPENDENCIES
  none

RETURN VALUE
  cm_ss_e_type - ss which has LTE
  CM_SS_NONE - if no ss has LTE

SIDE EFFECTS
  none

===========================================================================*/
cm_ss_e_type cmss_get_intl_srv_lte_ss()
{
  if(cmss_intl_srv_info_ptr(CM_SS_MAIN)->mode == SD_MODE_LTE &&
     sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_MAIN)->srv_status))
  {
    return CM_SS_MAIN;
  }
  else if(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->mode == SD_MODE_LTE &&
          sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_2)->srv_status))
  {
    return CM_SS_HYBR_2;
  }
  else if(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->mode == SD_MODE_LTE &&
          sys_srv_status_is_srv(cmss_intl_srv_info_ptr(CM_SS_HYBR_3)->srv_status))
  {
    return CM_SS_HYBR_3;
  }
  else
  {
    return CM_SS_NONE;
  }
}
