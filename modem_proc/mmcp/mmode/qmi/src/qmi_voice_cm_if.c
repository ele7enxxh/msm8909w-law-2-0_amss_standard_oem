/*===========================================================================

                         Q M I _ V O I C E _ C M _ I F . C

DESCRIPTION

 The Data Services Qualcomm Voice service CM interface source file.

EXTERNALIZED FUNCTIONS

  qmi_voice_cm_if_init()
    Initialize internal data structures.
     

Copyright (c) 2004-2015 QUALCOMM Technologies Incorporated.
All Rights Reserved.
Qualcomm Confidential and Proprietary.
===========================================================================*/
/*===========================================================================
                      EDIT HISTORY FOR FILE

  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/mmcp/mmode/qmi/src/qmi_voice_cm_if.c#1 $ $DateTime:$ $Author:$

when        who    what, where, why
--------    ---    ----------------------------------------------------------
04/26/09    sk     Created Module.
===========================================================================*/

/*===========================================================================
 
  INCLUDE FILES FOR MODULE
 
===========================================================================*/

#include "mmcp_variation.h"
#include "comdef.h"
#include "customer.h"

#ifdef FEATURE_QMI_SERVICE_SPLIT

#include "amssassert.h"
#include "dsm.h"
#include "nv.h"
#include "cm.h"
#include "msg.h"
#include "err.h"
#include "modem_mem.h"
#include "qmi_voice_cm_if.h"
#include "qmi_voice_cmd_list.h"
#include "qmi_voice_call_list.h"
#include "qmi_voice_cm_sups.h"
#include "qmi_voice_cm_util.h"
#include  "qmi_voice.h"
#include "qm_comdef.h"
#include "mm.h"
#ifdef FEATURE_DUAL_SIM
#include  "cm_dualsim.h"
#endif /*FEATURE_DUAL_SIM*/
#include  "pbmlib.h"
#include "qmi_mmode_task_cmd.h"
#include "qmi_mmode_msgr_msg.h"
#include "ref_cnt_obj.h"
#include "qm_nv.h"
#include "qm_util.h"
#include "qm_efs.h"
#include "qmi_voice_msgr_if.h"

/*===========================================================================

                            CONSTANT DEFINITIONS

===========================================================================*/

/*===========================================================================

                                DATA TYPES

===========================================================================*/


/*===========================================================================

                               INTERNAL DATA

===========================================================================*/
#ifndef FEATURE_NO_QMI_VOICE
#define QMI_VOICE_CM_IF_INVALID_CUG_INDEX 0xFFFF

/*Unknown call id*/
#define QMI_VOICE_CC_CAUSE_NORMAL_CALL_CLEARING  16

/* Values for call status indication event */
#define QMI_VOICE_CM_IF_CALL_ORIGINATION   0X00
#define QMI_VOICE_CM_IF_CALL_ANSWER        0x01
#define QMI_VOICE_CM_IF_CALL_END           0x03
#define QMI_VOICE_CM_IF_CALL_INCOMING      0x05
#define QMI_VOICE_CM_IF_CALL_CONNECT       0x06

#define QMI_VOICE_CM_IF_GET_MODEM_CONFIG_ITEM 0x01

/*Unknown call id*/
#define QCRIL_QMI_VOICE_UNKNOWN_CONN_ID  0xFF

#define QMI_VOICE_CM_IF_ITC_AUX_SPEECH_4  4 /* per GSM 04.08 table 10.72 */
#define QMI_VOICE_CM_IF_ITC_AUX_SPEECH_6  6 /* per GSM 04.08 table 10.72 */

/* OTASP Numbers*/
#define QMI_VOICE_CM_IF_OTASP_NUM 11
#define QMI_VOICE_CM_IF_MAX_OTASP_NUM_LENGTH 81
#define QMI_VOICE_NV_OTASP_NUMBER_START 99

#define QMI_VOICE_IP_PRESENTATION_NUM_ALLOWED      0x00 
#define QMI_VOICE_IP_PRESENTATION_NUM_RESTRICTED   0x01

#define QMI_VOICE_CM_IF_EMERG_CAT_MANUAL_ECALL  (1<<5)
#define QMI_VOICE_CM_IF_EMERG_CAT_AUTO_ECALL    (1<<6)

//The maximum value ACMMAX can take
#define QMI_VOICE_CM_IF_AOC_MAX_NEW_MAX                  0xFFFFFF
//Only bits 0, 1 and 2 may be high
#define QMI_VOICE_CM_IF_AOC_MAX_INFO_MASK                0x07
//Bit masks for each AOC info component
#define QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_ACM      (1<<0)
#define QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_ACMMAX   (1<<1)
#define QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_CCM      (1<<2)


typedef enum
{
  QMI_VOICE_CM_IF_SRV_TYPE_AUTOMATIC  = 0x01,
  QMI_VOICE_CM_IF_SRV_TYPE_GSM   = 0x02,
  QMI_VOICE_CM_IF_SRV_TYPE_WCDMA = 0x03,
  QMI_VOICE_CM_IF_SRV_TYPE_CDMA_AUTOMATIC = 0x04,
  QMI_VOICE_CM_IF_SRV_TYPE_GSM_WCDMA   = 0x05,
  QMI_VOICE_CM_IF_SRV_TYPE_LTE  = 0x06,
  QMI_VOICE_CM_IF_SRV_TYPE_TDSCDMA = 0x07,
  QMI_VOICE_CM_IF_SRV_TYPE_GSM_WCDMA_TDSCDMA = 0x08,
  QMI_VOICE_CM_IF_SRV_TYPE_CS_ONLY  = 0x09,
  QMI_VOICE_CM_IF_SRV_TYPE_MAX = 0xFF
} qmi_voice_cm_if_srv_type_e_type;

/* C.S005-D Table 3.7.5.16-2. 1 Mandatory Control Tags and Display Text Tags */
typedef enum 
{
  QMI_VOICE_CM_IF_DISPLAY_TAG_BLANK                    = 0x80,
  QMI_VOICE_CM_IF_DISPLAY_TAG_SKIP                     = 0x81,
  QMI_VOICE_CM_IF_DISPLAY_TAG_CONTINUATION             = 0x82,
  QMI_VOICE_CM_IF_DISPLAY_TAG_CALLED_ADDRESS           = 0x83,
  QMI_VOICE_CM_IF_DISPLAY_TAG_CAUSE                    = 0x84,
  QMI_VOICE_CM_IF_DISPLAY_TAG_PROGRESS_INDICATOR       = 0x85,
  QMI_VOICE_CM_IF_DISPLAY_TAG_NOTIFICATION_INDICATOR   = 0x86,
  QMI_VOICE_CM_IF_DISPLAY_TAG_PROMPT                   = 0x87,
  QMI_VOICE_CM_IF_DISPLAY_TAG_ACCUMULATED_DIGITS       = 0x88,
  QMI_VOICE_CM_IF_DISPLAY_TAG_STATUS                   = 0x89,
  QMI_VOICE_CM_IF_DISPLAY_TAG_INBAND                   = 0x8A,
  QMI_VOICE_CM_IF_DISPLAY_TAG_CALLING_ADDRESS          = 0x8B,
  QMI_VOICE_CM_IF_DISPLAY_TAG_REASON                   = 0x8C,
  QMI_VOICE_CM_IF_DISPLAY_TAG_CALLING_PARTY_NAME       = 0x8D,
  QMI_VOICE_CM_IF_DISPLAY_TAG_CALLED_PARTY_NAME        = 0x8E,
  QMI_VOICE_CM_IF_DISPLAY_TAG_ORIGINAL_CALLED_NAME     = 0x8F,
  QMI_VOICE_CM_IF_DISPLAY_TAG_REDIRECTING_NAME         = 0x90,
  QMI_VOICE_CM_IF_DISPLAY_TAG_CONNECTED_NAME           = 0x91,
  QMI_VOICE_CM_IF_DISPLAY_TAG_ORIGINATING_RESTRICTIONS = 0x92,
  QMI_VOICE_CM_IF_DISPLAY_TAG_DATE_AND_TIME_OF_DAY     = 0x93,
  QMI_VOICE_CM_IF_DISPLAY_TAG_CALL_APPEARANCE_ID       = 0x94,
  QMI_VOICE_CM_IF_DISPLAY_TAG_FEATURE_ADDRESS          = 0x95,
  QMI_VOICE_CM_IF_DISPLAY_TAG_REDIRECTION_NAME         = 0x96,
  QMI_VOICE_CM_IF_DISPLAY_TAG_REDIRECTION_NUMBER       = 0x97,
  QMI_VOICE_CM_IF_DISPLAY_TAG_REDIRECTING_NUMBER       = 0x98,
  QMI_VOICE_CM_IF_DISPLAY_TAG_ORIGINAL_CALLED_NUMBER   = 0x99,
  QMI_VOICE_CM_IF_DISPLAY_TAG_CONNECTED_NUMBER         = 0x9A,
  QMI_VOICE_CM_IF_DISPLAY_TAG_TEXT                     = 0x9E
}qmi_voice_cm_if_display_tag;

typedef struct
{
  cm_call_id_type                call_id;
  cm_call_event_user_data_s_type user_data;
} qmi_voice_cm_if_uus_data_s_type;

typedef struct
{
  uint32    handle;
  boolean                     is_alpha_available;
  qmi_voice_cm_if_alpha_id_s  alpha_id;
}qmi_voice_cm_if_sups_alpha_info;

typedef struct
{
  cm_als_line_e_type               curr_line;
  cm_als_line_e_type               prev_line;
  byte                             itc_aux_val;
}qmi_voice_cm_if_line_info_s_type;

typedef struct
{
  uint8			  num_len;
  uint8			  num_buf[QMI_VOICE_CM_IF_MAX_OTASP_NUM_LENGTH];
}qmi_voice_cm_if_otasp_num_s_type;

typedef struct
{ 
  boolean                          is_non_std_otasp_num_available;                           
  qmi_voice_cm_if_otasp_num_s_type num[QMI_VOICE_CM_IF_OTASP_NUM];
}qmi_voice_cm_if_otasp_info_s_type;

typedef struct
{
  boolean                  waiting_call_id_valid;
  cm_call_id_type          waiting_call_id;
  boolean                  held_call_id_valid;
  cm_call_id_type          held_call_id;
}qmi_voice_cm_if_mng_calls_info_s_type;

typedef struct
{
  cm_call_id_type eCall_id;
  cm_client_id_type eCall_client_id;
  uint8             as_id;
}qmi_voice_cm_if_eCall_info_s_type;

static struct qmi_voice_cm_if_info_type
{
  uint8                            clir;
  int                              call_fail_cause;
  cm_client_id_type                cm_client_id;
  qmi_voice_cm_if_uus_data_s_type  uus_data;
  qmi_voice_cm_if_sups_alpha_info  sups_alpha_info;
  qmi_voice_cm_if_line_info_s_type als;
  qmi_voice_cm_if_otasp_info_s_type otasp_info;
  qmi_voice_cm_if_mng_calls_info_s_type mng_calls_info;
  qmi_voice_cm_if_eCall_info_s_type  eCall_info;
  voice_handover_state_enum_v02 ho_state;
  uint8  raw_call_fail_cause;
} cm_if_info;

typedef struct
{
 int                                cause;
 qmi_voice_cm_if_end_reason_e_type  reason;
}qmi_voice_cm_if_cause_to_end_reason_table_s_type;

voice_info_rec_ind_msg_v02 info_record_buf;

static nv_item_type nv_buf;

/*===========================================================================

                    EXTERNAL FUNCTION PROTOTYPES

===========================================================================*/



/*===========================================================================

                    INTERNAL FUNCTION PROTOTYPES

===========================================================================*/

/* ---Command callbacks and respective handlers--- */
static void qmi_voice_cm_if_callsvc_command_callback
(
  void                   *data_block_ptr,
  cm_call_cmd_e_type     call_cmd,
  cm_call_cmd_err_e_type call_cmd_err
);

static void qmi_voice_cm_if_callsvc_exten_command_callback
(
  void                         *data_block_ptr,
  cm_call_cmd_e_type            call_cmd,
  cm_call_cmd_err_e_type        call_cmd_err,
  cm_call_cmd_err_cause_e_type  call_cmd_err_cause,
  cm_alpha_s_type               alpha
);

static void qmi_voice_cm_if_call_cmd_exten_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
);

static void qmi_voice_cm_if_call_cmd_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
);


static void qmi_voice_cm_if_inbandsvc_command_callback
(
  void                    *data_block_ptr,
  cm_inband_cmd_e_type     inband_cmd,
  cm_inband_cmd_err_e_type inband_cmd_err
);
static void qmi_voice_cm_if_inband_cmd_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
);


static void qmi_voice_cm_if_sups_command_callback
(
  void                    *data_block_ptr,
  cm_sups_cmd_e_type     sups_cmd,
  cm_sups_cmd_err_e_type sups_cmd_err
);

static void qmi_voice_cm_if_sups_exten_command_callback
(
  void                    *data_block_ptr,
  cm_sups_cmd_e_type     sups_cmd,
  cm_sups_cmd_err_e_type sups_cmd_err,
  cm_sups_cmd_err_cause_e_type err_cause,
  cm_alpha_s_type              alpha
);

static void qmi_voice_cm_if_sups_cmd_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
);

static void qmi_voice_cm_if_sups_cmd_exten_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
);


static void qmi_voice_cm_if_ph_command_callback
(
  void                    *data_block_ptr,
  cm_ph_cmd_e_type        ph_cmd,
  cm_ph_cmd_err_e_type    ph_cmd_err
);
static void qmi_voice_cm_if_ph_cmd_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
);

void qmi_voice_cm_if_ecall_orig_exten_info_cb 
(
  void                             *data_block_ptr,
  ecall_session_status_type         session_status,
  cm_call_id_type                   call_id,
  cm_client_id_type                 client_id,
  ecall_call_orig_exten_info_s_type exten_info
);

static void qmi_voice_cm_if_ecall_orig_info_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
);

static void qmi_voice_cm_if_call_cmd_err_cb 
(
  cm_call_id_type              call_id,
  cm_client_id_type            client_id,
  cm_call_cmd_e_type           cmd,
  cm_call_cmd_err_e_type       cmd_err
);

static void qmi_voice_cm_if_call_cmd_err_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
);


/* ---Event callbacks and respective handlers--- */
static void qmi_voice_cm_if_call_evt_cb 
(
  cm_call_event_e_type call_event, 
  const cm_mm_call_info_s_type *call_info_ptr
);
static void qmi_voice_cm_if_call_evt_cb_handler
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_sups_evt_cb 
(
  cm_sups_event_e_type sups_event, 
  const cm_sups_info_s_type *sups_info_ptr
);

static void qmi_voice_cm_if_fill_sups_ntwk_resp
(
  qmi_voice_cm_if_evt_e_type event,
  qmi_voice_cm_if_sups_ind_s *ind,
  cm_sups_info_s_type *sups_info_ptr
);

static void qmi_voice_cm_if_sups_evt_cb_handler
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
);

static void qmi_voice_cm_if_inband_evt_cb 
(
  cm_inband_event_e_type inband_event, 
  const cm_inband_info_s_type *inband_info_ptr
);
static void qmi_voice_cm_if_inband_evt_cb_handler
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_inband_info_s_type *inband_info_ptr
);

static void qmi_voice_cm_if_ph_evt_cb
(
  cm_ph_event_e_type ph_event, 
  const cm_ph_info_s_type *ph_info_ptr
);
static void qmi_voice_cm_if_ph_evt_cb_handler
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_ph_info_s_type *ph_info_ptr
);

static void qmi_voice_cm_if_ss_evt_cb
( 
  cm_ss_event_e_type evt, 
  const cm_mm_msim_ss_info_s_type *ss_info
);
static void qmi_voice_cm_if_ss_evt_cb_handler
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_msim_ss_info_s_type *ss_info_ptr
);


/* ---CM Error to QMI Error Mapping function prototypes--- */
static qmi_error_e_type qmi_voice_cm_if_map_call_error_to_qmi
( 
  cm_call_cmd_err_e_type cm_err 
);

static boolean qmi_voice_cm_if_is_jcdma_build
( 
  void
);

static qmi_error_e_type qmi_voice_cm_if_map_inband_error_to_qmi
( 
  cm_inband_cmd_err_e_type  cm_err
);

static qmi_error_e_type qmi_voice_cm_if_map_sups_error_to_qmi
( 
  cm_sups_cmd_err_e_type cm_err 
);

static qmi_voice_cm_if_failure_cause_e_type qmi_voice_cm_if_map_sups_event_error_to_qmi
(
  ie_cm_ss_error_s_type ss_error,
  ie_cm_cc_cause_s_type cc_cause
);

static qmi_error_e_type qmi_voice_cm_if_map_ph_error_to_qmi
( 
  cm_ph_cmd_err_e_type cm_err 
);

/* ---Helper functions prototypes--- */
static cm_client_id_type qmi_voice_cm_if_get_clientid
(
  void
);

static boolean qmi_voice_cm_if_process_info_rec
(
  qmi_voice_cm_if_evt_e_type e, 
  const cm_mm_call_info_s_type *p 
);

static void qmi_voice_cm_if_gen_info_rec_ind
(
  voice_info_rec_ind_msg_v02 *ind
);

static void qmi_voice_cm_if_extract_call_end_reason
(
  cm_mm_call_info_s_type *call_info_ptr
);

static cm_srv_type_e_type qmi_voice_cm_if_map_qmi_to_cm_srv_type
(
  qmi_voice_cm_if_srv_type_e_type  qmi_srv_type
);

static qmi_voice_cm_if_end_reason_e_type qmi_voice_cm_if_map_cause_to_end_reason
(
  int  cause_val
);

static qmi_voice_cm_if_end_reason_e_type qmi_voice_cm_if_map_ota_rej_cause_to_end_reason
(
  int  rej_cause_val
);

static void qmi_voice_cm_if_force_state_transition_to_wait_amss_event
(
  uint32                     handle,
  int                        cmd,
  qmi_voice_cm_if_evt_e_type pending_event_id
);

static void qmi_voice_cm_if_read_otasp
(
  void
);

static void qmi_voice_cm_if_itc_aux_init
(
  uint8 *itc_val
);

boolean qmi_voice_cm_if_is_dial_call_type_valid
(
  qmi_voice_cm_if_call_type_e_type call_type
);

qmi_error_e_type qmi_voice_cm_if_validate_dial_call_params
(
  voice_dial_call_req_msg_v02 *in_data_ptr
);

ecall_type_of_call qmi_voice_cm_if_map_qmi_to_eCall_type
(
  qmi_voice_cm_if_eCall_type_e_type ecall_type
);


/* ---CM Interface Event Processing functions--- */
/* Call events */
static void qmi_voice_cm_if_call_event_orig
(
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_call_event_incom
(
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_call_event_setup_ind
(
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_call_event_user_data_ind
(
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_fill_and_send_sups_notification_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_call_info_s_type *call_info_ptr
);

void qmi_voice_cm_if_callsvc_event_modify_complete_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_call_info_s_type *call_info_ptr
);

void qmi_voice_cm_if_call_switch_codec_cnf
(
  qmi_voice_cm_if_evt_e_type  event,
  cm_mm_call_info_s_type     *call_info_ptr
);

void qmi_voice_cm_if_call_modified_ind
(
  cm_mm_call_info_s_type *call_info_ptr
);

void qmi_voice_cm_if_call_modify_accept_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_call_mod_to_sups
(
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_send_additional_call_info_ind
(
  cm_mm_call_info_s_type *call_info_ptr
);
static void qmi_voice_cm_if_call_l2ack_call_hold
(
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_call_speech_codec_info_ind
(
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_send_conference_participant_update_ind
(
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_report_rat_change
(
  cm_mm_call_info_s_type *call_info_ptr
);

static void qmi_voice_cm_if_call_encryption_req
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voicei_call_encryption_resp
( 
  const qmi_voice_cm_if_info_item_s *const data_ptr
);

IxErrnoType qmi_voice_call_list_update_secure_call_info
(
  cm_call_id_type call_id,
  boolean is_secure_call
);

void qmi_voice_cm_if_call_encryption_callback
(
  void					*data_block_ptr,
  cm_call_cmd_e_type	 call_cmd,
  cm_call_cmd_err_e_type call_cmd_err
);

void qmi_voice_cm_if_secure_call_functionality_info
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

/* Sups events */
static void qmi_voice_cm_if_sups_event_interrogate_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
);

static void qmi_voice_cm_if_sups_event_activate_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
);

static void qmi_voice_cm_if_sups_event_deactivate_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
);

static void qmi_voice_cm_if_sups_event_erase_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
);

static void qmi_voice_cm_if_sups_event_register_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
);

static void qmi_voice_cm_if_sups_event_process_uss_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
);

static void qmi_voice_cm_if_sups_event_reg_password_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
);

void qmi_voice_cm_if_sups_event_get_password_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
);

void qmi_voice_cm_if_sups_event_send_ussd_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *cm_info
);

void qmi_voice_cm_if_sups_event_send_ussd_release_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *cm_info
);

void qmi_voice_cm_if_sups_event_sups_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *cm_info,
  qmi_voice_cm_if_cc_result_e_type cc_result
);

static void qmi_voice_cm_if_send_mt_page_miss_ind
(
  cm_mm_call_info_s_type *call_info_ptr,
  uint8     as_id
);

static void qmi_voice_cm_if_send_cc_result_info_ind
(
  cm_cc_result_e_type            cc_result,
  cm_alpha_s_type                alpha,
  uint8                          as_id
);


/* ---CM Interface wrapper functions--- */
static void qmi_voice_cm_if_dial_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_send_flash
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_answer_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_setup_answer
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_end_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_get_call_info
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_get_all_call_info
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_set_preferred_privacy
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_burst_dtmf
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_start_cont_dtmf
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_stop_cont_dtmf
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_get_clir
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_get_call_forwarding
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_get_clip
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_get_colp
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_get_call_waiting
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_get_call_barring
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_change_call_barring_pwd
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_manage_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_release_held_or_waiting
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_release_active_accept_held_or_waiting
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_hold_active_accept_waiting_or_held
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_hold_all_except_specified_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_make_conference_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_explicit_call_transfer
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_release_specified_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_end_all_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_local_hold_unhold
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_sups_set_sups_service
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_sups_set_sups_service_call_forward
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_sups_set_sups_service_call_barring
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_sups_set_sups_service_call_waiting
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_sups_set_sups_service_clip
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_sups_set_sups_service_colp
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_sups_set_sups_service_colr
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_answer_ussd
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_sups_orig_ussd
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_set_modem_config
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_get_modem_config
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_sups_orig_ussd_no_wait
(
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_als_set_line_switching
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_als_select_line
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_aoc_reset_acm
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_aoc_set_acmmax
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_aoc_get_call_meter_info
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_send_aoc_low_funds_ind
(
  uint8 as_id
);

static void qmi_voice_cm_if_sups_manage_ip_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_sups_get_colr
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_als_get_selected_line
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_als_get_line_switching_status
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

static void qmi_voice_cm_if_ip_gen_param_destructor(
  void *me
  );

static void qmi_voice_cm_if_barr_list_ptr_destructor(
  void *me
  );

static void qmi_voice_cm_if_sups_get_cnap
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
);

void qmi_voice_cm_if_process_cmd
(
  qmi_mmode_cmd_enum_type        cmd,
  void                   * user_data_ptr
);

struct qmi_voice_cm_if_call_event_s
{
  cm_call_event_e_type beg;
  cm_call_event_e_type end;
};

struct qmi_voice_cm_if_sups_event_s
{
  cm_sups_event_e_type beg;
  cm_sups_event_e_type end;
};

struct qmi_voice_cm_if_inband_event_s
{
  cm_inband_event_e_type beg;
  cm_inband_event_e_type end;
};

struct qmi_voice_cm_if_ph_event_s
{
  cm_ph_event_e_type beg;
  cm_ph_event_e_type end;
};

/* ---CM Interface wrapper functions--- */
void qmi_voice_cm_if_originate_eCall
(
  qmi_voice_cm_if_info_item_s *const params_ptr
);


/*===========================================================================
  FUNCTION QMI_VOICE_IMS_EXTN_HANDLE_SRVCC_COMPLETE()

  DESCRIPTION
    Handle the SRVCC complete for other IMS cases

  PARAMETERS
    call_info_ptr:  cm_mm_call_info_s_type
    
  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void  qmi_voice_ims_extn_handle_srvcc_complete
(
  cm_mm_call_info_s_type *call_info_ptr,
  uint8 as_id  
);

/*===========================================================================
            
                        EXTERNAL FUNCTION DEFINITIONS

===========================================================================*/


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_INIT()

  DESCRIPTION
    Initialize CM interface for Qmi Voice service

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_init
(
  void
)
{
  #ifndef FEATURE_NO_QMI_VOICE
  uint8 i; 

 const struct qmi_voice_cm_if_call_event_s call_event_list[] = {
   { CM_CALL_EVENT_ORIG, CM_CALL_EVENT_CONNECT },
   { CM_CALL_EVENT_PRIVACY, CM_CALL_EVENT_CALLER_ID },
   { CM_CALL_EVENT_SIGNAL, CM_CALL_EVENT_EXT_DISP},
   { CM_CALL_EVENT_EXT_BRST_INTL, CM_CALL_EVENT_SETUP_IND},
   { CM_CALL_EVENT_MNG_CALLS_CONF, CM_CALL_EVENT_TRANSFERRED_CALL },
   { CM_CALL_EVENT_REDIRECTING_NUMBER, CM_CALL_EVENT_REDIRECTING_NUMBER },
   { CM_CALL_EVENT_ORIG_MOD_TO_SS, CM_CALL_EVENT_USER_DATA_IND },
   { CM_CALL_EVENT_MODIFY_IND, CM_CALL_EVENT_MODIFY_IND },
   { CM_CALL_EVENT_LINE_CTRL, CM_CALL_EVENT_LINE_CTRL },
   { CM_CALL_EVENT_MODIFY_COMPLETE_CONF, CM_CALL_EVENT_MODIFY_COMPLETE_CONF },
   { CM_CALL_EVENT_MPTY_CALL_IND, CM_CALL_EVENT_OTASP_STATUS },
   { CM_CALL_EVENT_PROGRESS_EARLY_MEDIA, CM_CALL_EVENT_PROGRESS_EARLY_MEDIA },
   { CM_CALL_EVENT_CALL_ON_HOLD_BY_REMOTE, CM_CALL_EVENT_CALL_RETRIEVE_BY_REMOTE },
   { CM_CALL_EVENT_SPEECH_CODEC_INFO, CM_CALL_EVENT_SPEECH_CODEC_INFO },
   { CM_CALL_EVENT_HO_START, CM_CALL_EVENT_HO_COMPLETE },
   { CM_CALL_EVENT_CONFERENCE_INFO,CM_CALL_EVENT_JOIN_CONFERENCE},
   { CM_CALL_EVENT_HO_CANCEL,CM_CALL_EVENT_HO_CANCEL},
   { CM_CALL_EVENT_MT_CALL_PAGE_FAIL, CM_CALL_EVENT_MT_CALL_PAGE_FAIL },
   { CM_CALL_EVENT_RAT_CHANGE,CM_CALL_EVENT_RAT_CHANGE},
   { CM_CALL_EVENT_VOIP_CALL_END_CNF,CM_CALL_EVENT_VOIP_CALL_END_CNF},
   { CM_CALL_EVENT_CC_RESULT_INFO,CM_CALL_EVENT_E911_ORIG_FAIL},
   { CM_CALL_EVENT_SWITCH_CODEC_CNF, CM_CALL_EVENT_SWITCH_CODEC_CNF },
   { CM_CALL_EVENT_ABRV_ALERT, CM_CALL_EVENT_ABRV_ALERT},
   };

 const struct qmi_voice_cm_if_inband_event_s inband_event_list[] = { 
   { CM_INBAND_EVENT_REV_BURST_DTMF, CM_INBAND_EVENT_FWD_STOP_CONT_DTMF },
   { CM_INBAND_EVENT_IP_START_DTMF_IND, CM_INBAND_EVENT_IP_STOP_DTMF_IND }};   

 const struct qmi_voice_cm_if_sups_event_s sups_event_list[] = { 
   { CM_SUPS_EVENT_REGISTER, CM_SUPS_EVENT_PROCESS_USS_CONF },
   { CM_SUPS_EVENT_USS_NOTIFY_IND, CM_SUPS_EVENT_USS_NOTIFY_IND },
   { CM_SUPS_EVENT_USS_IND, CM_SUPS_EVENT_USS_IND },
   { CM_SUPS_EVENT_RELEASE_USS_IND, CM_SUPS_EVENT_GET_PASSWORD_IND },
   { CM_SUPS_EVENT_SS_MOD_TO_ORIG, CM_SUPS_EVENT_CC_RESULT_INFO } };

  const struct qmi_voice_cm_if_ph_event_s  ph_event_list[] = { 
    { CM_PH_EVENT_SUBSCRIPTION_AVAILABLE, CM_PH_EVENT_SUBSCRIPTION_AVAILABLE },
    { CM_PH_EVENT_SELECTED_LINE, CM_PH_EVENT_SELECTED_LINE },
    { CM_PH_EVENT_INFO, CM_PH_EVENT_INFO },
    { CM_PH_EVENT_OPRT_MODE, CM_PH_EVENT_OPRT_MODE},
    { CM_PH_EVENT_RESET_ACM_COMPLETED, CM_PH_EVENT_RESET_ACM_COMPLETED },
    { CM_PH_EVENT_SET_ACMMAX_COMPLETED, CM_PH_EVENT_SET_ACMMAX_COMPLETED },
    { CM_PH_EVENT_FUNDS_LOW, CM_PH_EVENT_FUNDS_LOW } };

  cm_ss_event_e_type ss_event_list[] = { 
    CM_SS_EVENT_SRV_CHANGED,
    CM_SS_EVENT_INFO
  };

  qmi_mmode_set_cmd_handler(QMI_MMODE_CMD_VOICE_CM_IF_CB, qmi_voice_cm_if_process_cmd);

  /* Initialize the CM client */
  if( CM_CLIENT_OK != cm_client_init( CM_CLIENT_TYPE_RM_NETWORK_INTERFACE,
                                      &cm_if_info.cm_client_id) )
  {
    QM_MSG_ERROR("CM client initialization failed!");
    return;
  }

  /*******************Register for CM events*******************/

  /* CM call events */
  QM_MSG_MED_1("client_id = %d", qmi_voice_cm_if_get_clientid());
  for ( i = 0; i < QMI_VOICE_CM_IF_ARR_SIZE( call_event_list ); i++ )
  {
    if ( cm_mm_client_call_reg( qmi_voice_cm_if_get_clientid(), 
                                qmi_voice_cm_if_call_evt_cb, 
                                CM_CLIENT_EVENT_REG,
                                call_event_list[ i ].beg, 
                                call_event_list[ i ].end, 
                                qmi_voice_cm_if_call_cmd_err_cb
                              ) != CM_CLIENT_OK ) 
    {
      QM_MSG_ERROR_2("Fail to register CM Call event %d -> %d", call_event_list[ i ].beg, call_event_list[ i ].end);
    }
  }

  /* CM inband events */
  for ( i = 0; i < QMI_VOICE_CM_IF_ARR_SIZE( inband_event_list ); i++ )
  {
    if ( cm_mm_client_inband_reg( qmi_voice_cm_if_get_clientid(), 
                                  qmi_voice_cm_if_inband_evt_cb, 
                                  CM_CLIENT_EVENT_REG,
                                  inband_event_list[ i ].beg, 
                                  inband_event_list[ i ].end, 
                                  NULL
                                ) != CM_CLIENT_OK ) 
    {
      QM_MSG_ERROR_2("Fail to register CM Inband event %d->%d", inband_event_list[ i ].beg, inband_event_list[ i ].end);
    }
  }

  /* CM sups events */
  for ( i = 0; i < QMI_VOICE_CM_IF_ARR_SIZE( sups_event_list ); i++ )
  {
    if ( cm_client_sups_reg( qmi_voice_cm_if_get_clientid(), 
                             qmi_voice_cm_if_sups_evt_cb, 
                             CM_CLIENT_EVENT_REG,
                             sups_event_list[ i ].beg, 
                             sups_event_list[ i ].end, 
                             NULL 
                           ) != CM_CLIENT_OK ) 
    {
      QM_MSG_HIGH_2("Fail to register CM Sups event :  %d->%d", sups_event_list[ i ].beg, sups_event_list[ i ].end);
    }
  }

  /* CM ph events */
  for ( i = 0; i < QMI_VOICE_CM_IF_ARR_SIZE( ph_event_list ); i++ )
  {
    if ( cm_client_ph_reg( qmi_voice_cm_if_get_clientid(), 
                             qmi_voice_cm_if_ph_evt_cb, 
                             CM_CLIENT_EVENT_REG,
                             ph_event_list[ i ].beg, 
                             ph_event_list[ i ].end, 
                             NULL 
                           ) != CM_CLIENT_OK ) 
    {
      QM_MSG_HIGH_2("Fail to register CM Ph event :  %d->%d", ph_event_list[ i ].beg, ph_event_list[ i ].end);
    }
  }

  /* CM ss events */
  for ( i = 0; i < QMI_VOICE_CM_IF_ARR_SIZE( ss_event_list ); i++ )
  {
    if( cm_mm_client_ss_reg_msim( qmi_voice_cm_if_get_clientid(),
                                  qmi_voice_cm_if_ss_evt_cb, 
                                  CM_CLIENT_EVENT_REG,
                                  ss_event_list[i],
                                  ss_event_list[i],
                                  NULL,
                                  SYS_MODEM_AS_ID_1_MASK|SYS_MODEM_AS_ID_2_MASK 
                           ) != CM_CLIENT_OK ) 
    {
      QM_MSG_HIGH_1("Fail to register CM SS event :  %d", ss_event_list[ i ]);
    }
  }

  /**************************************/

    /* Activate QMI CM client */
  if ( cm_client_act( qmi_voice_cm_if_get_clientid()) != CM_CLIENT_OK )
  {
    QM_MSG_HIGH_1("Fail to activate CM client %d", qmi_voice_cm_if_get_clientid());
    return;
  }

  /* Initialize command list, call list, connection ids */
  qmi_voice_cmd_list_init();
  qmi_voice_call_list_init();
  qmi_voice_cm_util_init();

  if ( !cm_ss_cmd_get_ss_info(NULL, NULL, qmi_voice_cm_if_get_clientid()) )
  {
    QM_MSG_ERROR("cm_ss_cmd_get_ss_info failed");
  }

  /* Initialize the CLIR value */
  cm_if_info.clir = 0x00;

  /* Initialize the call fail cause */
  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_REL_NORMAL;

  /* read the non std OTASP numbers from NV */
  qmi_voice_cm_if_read_otasp();

  /* Initialize uus info */
  cm_if_info.uus_data.call_id = 0xFF;
  memset(&cm_if_info.uus_data.user_data,0,sizeof(cm_call_event_user_data_s_type));

  /* initialize info rec indication buffer */
  memset((void *)&(info_record_buf), 0, sizeof(info_record_buf)); 

  /* Initialize the ALS data */
  cm_if_info.als.curr_line = CM_ALS_LINE_01;
  cm_if_info.als.prev_line = CM_ALS_LINE_01;

  /* Check if ITC has been set to 1 in EFS. If yes the ITC to be set in bearer
  capability will be 6 otherwise it will be 4. All this is applicable only when
  ALS feature is being used and line selected is 2 */
  qmi_voice_cm_if_itc_aux_init(&cm_if_info.als.itc_aux_val);

  /* Initialize the mng calls info */
  memset(&cm_if_info.mng_calls_info, 0, sizeof(cm_if_info.mng_calls_info));
  cm_if_info.mng_calls_info.waiting_call_id = 0xFF;
  cm_if_info.mng_calls_info.held_call_id = 0xFF;

  cm_if_info.eCall_info.eCall_id = CM_CALL_ID_INVALID;
  cm_if_info.eCall_info.eCall_client_id = CM_CLIENT_ID_ANONYMOUS;
  cm_if_info.eCall_info.as_id = QMI_VOICE_CM_IF_AS_ID_INVALID;

  #endif /* !FEATURE_NO_QMI_VOICE */
} /* qmi_voice_cm_if_init */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_RESPONSE_ERROR()

  DESCRIPTION
    Invoke the error response from Voice service.

  PARAMETERS
    handle                     : Holds the address of qmi_cmd_buf_type ptr 
                                 (Uniquely identifies a command.)
    cmd                        : Voice command identifier
    err_val                    : Unique CM Interface error
    rem_entry_from_cmd_list    : To decide if cmdlist entry is to be removed
    ignore_if_entry_not_found  : Ignore when entry not found in cmdlist

  RETURN VALUE
    Pointer to event name string

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_response_error
(
  uint32                      handle,
  uint16                      cmd,
  qmi_error_e_type            err_val,
  boolean                     rem_entry_from_cmd_list,
  boolean                     ignore_if_entry_not_found
)
{
  boolean item_found_in_cmd_list = TRUE;
  qmi_mmode_cmd_data_buf_type * data_ptr;
  /*-----------------------------------------------------------------------*/

  data_ptr = qmi_mmode_get_cmd_data_buf();

  if(NULL == data_ptr)
  {
	  qmi_voice_cmd_fatal();
    return;
  }

  data_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(data_ptr->cmd.cm_if_data_ptr)));
  if( NULL == data_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(data_ptr);
    return;
  }
 
  memset(data_ptr->cmd.cm_if_data_ptr, 0, sizeof(*(data_ptr->cmd.cm_if_data_ptr)));


  /*-----------------------------------------------------------------------*/

  if ( rem_entry_from_cmd_list )
  {
    /* check if entry is found in cmd list */
    if ( qmi_voice_cmd_list_free( handle ) != E_SUCCESS )
    {
      if (!ignore_if_entry_not_found)
      {
        QM_MSG_ERROR("Entry not found in cmd list ");
      }
      item_found_in_cmd_list = FALSE;
    }
  }

  if (!item_found_in_cmd_list && ignore_if_entry_not_found)
  {
    /* Ignore */
  }
  else
  {
    /* Fill the response params */

    /* Fill the common data */
    data_ptr->cmd.cm_if_data_ptr->header.handle = handle;
    QM_MSG_ERROR_1("qmi_voice_cm_if_response_error:  cmd %d", cmd);    
    switch(cmd)
    {
      case QMI_VOICE_CM_IF_CMD_DIAL_CALL:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_DIAL_CALL_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.dial_call_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.dial_call_resp.resp.result = QMI_RESULT_FAILURE_V01;
      break;

      case QMI_VOICE_CM_IF_CMD_ANSWER_CALL:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_ANSWER_CALL_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.answer_call_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.answer_call_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_SETUP_ANSWER:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SETUP_ANSWER_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.setup_answer_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.setup_answer_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_END_CALL:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_END_CALL_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.end_call_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.end_call_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIR:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIR_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.resp.result = QMI_RESULT_FAILURE_V01;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
        break;

      case QMI_VOICE_CM_IF_CMD_ALS_GET_LINE_SWITCHING_STATUS:
         data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_ALS_GET_LINE_SWITCHING_STATUS_RESP;
         data_ptr->cmd.cm_if_data_ptr->data.get_line_switch_status_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_line_switch_status_resp.resp.result = QMI_RESULT_FAILURE_V01;
         break;

      case QMI_VOICE_CM_IF_CMD_ALS_GET_SELECTED_LINE:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_ALS_GET_SELECTED_LINE_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_selected_line_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_selected_line_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_FORWARDING:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_FORWARDING_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.resp.result = QMI_RESULT_FAILURE_V01;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
        break;

      case QMI_VOICE_CM_IF_CMD_GET_CALL_INFO:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_GET_CALL_INFO_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_call_info_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_call_info_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_SEND_FLASH:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SEND_FLASH_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.send_flash_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.send_flash_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_SET_PREFERRED_PRIVACY:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SET_PREFERRED_PRIVACY_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.set_pref_privacy_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.set_pref_privacy_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_BURST_DTMF:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_BURST_DTMF_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.burst_dtmf_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.burst_dtmf_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_START_CONT_DTMF:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_START_CONT_DTMF_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.start_cont_dtmf_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.start_cont_dtmf_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_STOP_CONT_DTMF:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_STOP_CONT_DTMF_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.stop_cont_dtmf_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.stop_cont_dtmf_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;


      case QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_CALLS:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_CALLS_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.manage_calls_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.manage_calls_resp.resp.result = QMI_RESULT_FAILURE_V01;
      memset(&cm_if_info.mng_calls_info, 0, sizeof(cm_if_info.mng_calls_info));
      cm_if_info.mng_calls_info.waiting_call_id = 0xFF;
      cm_if_info.mng_calls_info.held_call_id = 0xFF;
      break;

      case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIP:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIP_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.resp.result = QMI_RESULT_FAILURE_V01;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      break;

      case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_WAITING:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_WAITING_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.resp.result = QMI_RESULT_FAILURE_V01;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      break;

      case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_BARRING:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_BARRING_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.get_call_barring_resp.error = err_val;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_call_barring_resp.is_alpha_available = cm_if_info.sups_alpha_info.is_alpha_available;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_call_barring_resp.alpha_id),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_call_barring_resp.alpha_id)), &(cm_if_info.sups_alpha_info.alpha_id),sizeof(qmi_voice_cm_if_alpha_id_s));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      break;

      case QMI_VOICE_CM_IF_CMD_SUPS_SET_CALL_BARRING:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_SET_CALL_BARRING_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.resp.result = QMI_RESULT_FAILURE_V01;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      break;

      case QMI_VOICE_CM_IF_CMD_SUPS_SET_SUPS_SERVICE:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_SET_SUPS_SERVICE_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.alpha_ident_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.alpha_ident.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.alpha_ident.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.alpha_ident.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.alpha_ident.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      break;

      case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.resp.result = QMI_RESULT_FAILURE_V01;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
        break;

      case QMI_VOICE_CM_IF_CMD_SUPS_ANSWER_USSD:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_ANSWER_USSD_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.answer_ussd_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.answer_ussd_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_SUPS_CANCEL_USSD:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_CANCEL_USSD_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.cancel_ussd_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.cancel_ussd_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_SET_MODEM_CONFIG:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SET_MODEM_CONFIG_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.set_config_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.set_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_GET_MODEM_CONFIG:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_GET_MODEM_CONFIG_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_config_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_ALS_SET_LINE_SWITCHING:
       data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_ALS_SET_LINE_SWITCHING_RESP;
       data_ptr->cmd.cm_if_data_ptr->data.set_line_switch_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.set_line_switch_resp.resp.result = QMI_RESULT_FAILURE_V01;
       break;

      case QMI_VOICE_CM_IF_CMD_ALS_SELECT_LINE:
       data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_ALS_SELECT_LINE_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.select_line_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.reset_acm_resp.resp.result = QMI_RESULT_FAILURE_V01;
       break;

      case QMI_VOICE_CM_IF_CMD_AOC_RESET_ACM:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_AOC_RESET_ACM_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.reset_acm_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.reset_acm_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_AOC_SET_ACMMAX:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_AOC_SET_ACMMAX_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.set_acmmax_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.set_acmmax_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

      case QMI_VOICE_CM_IF_CMD_AOC_GET_CALL_METER_INFO:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_AOC_GET_CALL_METER_INFO_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_call_meter_info_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_call_meter_info_resp.resp.result = QMI_RESULT_FAILURE_V01;
        break;

     case QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.mng_ip_calls_resp.resp.error = (qmi_error_type_v01)err_val;
      if(err_val) data_ptr->cmd.cm_if_data_ptr->data.mng_ip_calls_resp.resp.result = QMI_RESULT_FAILURE_V01;
      break;

       

      case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_NO_WAIT:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_NO_WAIT_IND;
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.error_valid = TRUE;
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.error = (qmi_error_type_v01)err_val;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
        break;

      case QMI_VOICE_CM_IF_CMD_SUPS_GET_COLP:
        data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_COLP_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.resp.result = QMI_RESULT_FAILURE_V01;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
        break;

     case QMI_VOICE_CM_IF_CMD_SUPS_GET_COLR:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_COLR_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.resp.result = QMI_RESULT_FAILURE_V01;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
        break;

     case QMI_VOICE_CM_IF_CMD_SUPS_GET_CNAP:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CNAP_RESP;
        data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.resp.result = QMI_RESULT_FAILURE_V01;
        if(err_val == QMI_ERR_CARD_CALL_CONTROL_FAILED && handle == cm_if_info.sups_alpha_info.handle)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
        break;

     case QMI_VOICE_CM_IF_CMD_SRVCC_CALL_CONFIG:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SRVCC_CALL_CONFIG_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.set_srvcc_resp.error = err_val;
      break;

     case QMI_VOICE_CM_IF_CMD_CALL_ENCRYPTION:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_CALL_ENCRYPTION_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.call_encryption_resp.resp.error = (qmi_error_type_v01)err_val;
      if (err_val) data_ptr->cmd.cm_if_data_ptr->data.call_encryption_resp.resp.result = QMI_RESULT_FAILURE_V01;
      break;

     /* Cases for Other commands */
      default:
        QM_MSG_ERROR_1("qmi_voice_cm_if_response_error:  Invalid cmd %d", cmd);
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
    } /* switch */
  }
  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CB, data_ptr);
}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_RESPONSE_SUCCESS()

  DESCRIPTION
    Invoke the success response from Voice service.

  PARAMETERS
    handle                     : Holds the address of qmi_cmd_buf_type ptr 
                                 (Uniquely identifies a command.)
    cmd                        : Voice command identifier
    response                   : Ptr to response data sent to control point
    response_len               : Length of the response data
    remove_entry_from_cmd_list : To decide if cmdlist entry is to be removed

  RETURN VALUE
    Pointer to event name string

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_response_success
(
  uint32           handle,
  uint16           cmd,
  void*            response,
  size_t           response_len,
  boolean          remove_entry_from_cmd_list
)
{
  qmi_mmode_cmd_data_buf_type * data_ptr;
  /*-----------------------------------------------------------------------*/
  //QMI VOICE qmi_voice_cm_if_response_success
  data_ptr = qmi_mmode_get_cmd_data_buf();
  
  if(NULL == data_ptr)
  {
	  qmi_voice_cmd_fatal();
    return;
  }
  data_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(data_ptr->cmd.cm_if_data_ptr)));
  if( NULL == data_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(data_ptr);
    return;
  }
 
  memset(data_ptr->cmd.cm_if_data_ptr, 0, sizeof(*(data_ptr->cmd.cm_if_data_ptr)));


  /*-----------------------------------------------------------------------*/

  if ( remove_entry_from_cmd_list )
  {
    /* Remove the entry from cmd list */
    qmi_voice_cmd_list_free( handle );
  }

  /* Fill the common data */
  data_ptr->cmd.cm_if_data_ptr->header.handle = handle;

  QM_MSG_MED_3("qmi_voice_cm_if_response_success:: cmd %s (%d); p_response: %x",
               qmi_voice_cm_if_lookup_cmd_name(cmd), cmd, response);
  /* Fill the response params */
  switch (cmd)
  {
    case QMI_VOICE_CM_IF_CMD_DIAL_CALL:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_DIAL_CALL_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.dial_call_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.dial_call_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_ANSWER_CALL:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_ANSWER_CALL_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.answer_call_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.answer_call_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SETUP_ANSWER:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SETUP_ANSWER_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.setup_answer_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.setup_answer_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_END_CALL:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_END_CALL_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.end_call_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.end_call_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIR:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIR_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp), response, response_len);
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_clir_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_FORWARDING:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_FORWARDING_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp), response, response_len);
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_call_fwd_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_GET_CALL_INFO:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_GET_CALL_INFO_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_call_info_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_call_info_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_GET_ALL_CALL_INFO:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_GET_ALL_CALL_INFO_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_all_call_info_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_all_call_info_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SEND_FLASH:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SEND_FLASH_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.send_flash_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.send_flash_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SET_PREFERRED_PRIVACY:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SET_PREFERRED_PRIVACY_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.set_pref_privacy_resp.resp.error = QMI_ERR_NONE_V01;
      break;

    case QMI_VOICE_CM_IF_CMD_BURST_DTMF:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_BURST_DTMF_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.burst_dtmf_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.burst_dtmf_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_START_CONT_DTMF:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_START_CONT_DTMF_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.start_cont_dtmf_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.start_cont_dtmf_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_STOP_CONT_DTMF:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_STOP_CONT_DTMF_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.stop_cont_dtmf_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.stop_cont_dtmf_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_CALLS:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_CALLS_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.manage_calls_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.manage_calls_resp), response, response_len);
      }
      memset(&cm_if_info.mng_calls_info, 0, sizeof(cm_if_info.mng_calls_info));
      cm_if_info.mng_calls_info.waiting_call_id = 0xFF;
      cm_if_info.mng_calls_info.held_call_id = 0xFF;
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIP:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIP_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp), response, response_len);
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_clip_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_WAITING:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_WAITING_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp), response, response_len);
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_call_waiting_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_BARRING:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_BARRING_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_call_barring_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_call_barring_resp), response, response_len);
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_call_barring_resp.is_alpha_available = cm_if_info.sups_alpha_info.is_alpha_available;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_call_barring_resp.alpha_id),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_call_barring_resp.alpha_id)), &(cm_if_info.sups_alpha_info.alpha_id),sizeof(qmi_voice_cm_if_alpha_id_s));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_SET_CALL_BARRING:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_SET_CALL_BARRING_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp), response, response_len);
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.set_call_barring_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_SET_SUPS_SERVICE:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_SET_SUPS_SERVICE_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp), response, response_len);
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.alpha_ident_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.alpha_ident.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.alpha_ident.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.alpha_ident.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.set_sups_resp.alpha_ident.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp), response, response_len);
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_ANSWER_USSD:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_ANSWER_USSD_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.answer_ussd_resp.resp.error = QMI_ERR_NONE_V01;
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_CANCEL_USSD:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_CANCEL_USSD_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.cancel_ussd_resp.resp.error= QMI_ERR_NONE_V01;
      break;

    case QMI_VOICE_CM_IF_CMD_SET_MODEM_CONFIG:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SET_MODEM_CONFIG_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.set_config_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.set_config_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_GET_MODEM_CONFIG:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_GET_MODEM_CONFIG_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_config_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_config_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_ALS_SET_LINE_SWITCHING:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_ALS_SET_LINE_SWITCHING_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.set_line_switch_resp.resp.error = QMI_ERR_NONE_V01;
      break;

    case QMI_VOICE_CM_IF_CMD_ALS_SELECT_LINE:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_ALS_SELECT_LINE_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.select_line_resp.resp.error = QMI_ERR_NONE_V01;
      break;

    case QMI_VOICE_CM_IF_CMD_AOC_RESET_ACM:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_AOC_RESET_ACM_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.reset_acm_resp.resp.error = QMI_ERR_NONE_V01;
      break;

    case QMI_VOICE_CM_IF_CMD_AOC_SET_ACMMAX:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_AOC_SET_ACMMAX_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.set_acmmax_resp.resp.error = QMI_ERR_NONE_V01;
      break;

    case QMI_VOICE_CM_IF_CMD_AOC_GET_CALL_METER_INFO:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_AOC_GET_CALL_METER_INFO_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.get_call_meter_info_resp.resp.error = QMI_ERR_NONE_V01;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_call_meter_info_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_call_meter_info_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SRVCC_CALL_CONFIG:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SRVCC_CALL_CONFIG_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.set_srvcc_resp.error = QMI_ERR_NONE;
      break;

    case QMI_VOICE_CM_IF_CMD_ALS_GET_LINE_SWITCHING_STATUS:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_ALS_GET_LINE_SWITCHING_STATUS_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_line_switch_status_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_line_switch_status_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_ALS_GET_SELECTED_LINE:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_ALS_GET_SELECTED_LINE_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_selected_line_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_selected_line_resp), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.mng_ip_calls_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.mng_ip_calls_resp), response, response_len);
      }
      break;


    case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_NO_WAIT:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_NO_WAIT_IND;
      if(response != NULL)
      {
        //Copying from ORIG_USSD_RESP strucure
        voice_orig_ussd_resp_msg_v02 *orig_ussd_resp = (voice_orig_ussd_resp_msg_v02 *)response;
        if(orig_ussd_resp->resp.result)
        {
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.error_valid = TRUE;
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.error = orig_ussd_resp->resp.error;
        }
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.failure_cause_valid  = orig_ussd_resp->failure_cause_valid;
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.failure_cause        = orig_ussd_resp->failure_cause;
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id_valid       = orig_ussd_resp->alpha_id_valid;
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id             = orig_ussd_resp->alpha_id;
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.uss_info_valid       = orig_ussd_resp->uss_info_valid;
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.uss_info             = orig_ussd_resp->uss_info;
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.uss_info_utf16_valid = orig_ussd_resp->uss_info_utf16_valid;
        data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.uss_info_utf16_len   = orig_ussd_resp->uss_info_utf16_len;
        memscpy(data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.uss_info_utf16, 2*QMI_VOICE_USS_DATA_MAX_V02, orig_ussd_resp->uss_info_utf16, (orig_ussd_resp->uss_info_utf16_len)*2);
        
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.ussd_orig_no_wait_ind.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_GET_COLP:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_COLP_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp), response, response_len);
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_colp_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

   case QMI_VOICE_CM_IF_CMD_SUPS_GET_COLR:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_COLR_RESP;
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp), response, response_len);
        if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
        {
          data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_colr_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
          memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
        }
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

   case QMI_VOICE_CM_IF_CMD_SUPS_GET_CNAP:
		   data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_GET_CNAP_RESP;
		   if(response != NULL)
		   {
       memscpy(&data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp,sizeof(data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp), response, response_len);
			 if(handle == cm_if_info.sups_alpha_info.handle && cm_if_info.sups_alpha_info.is_alpha_available == TRUE)
			 {
          data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.alpha_id_valid = cm_if_info.sups_alpha_info.is_alpha_available;
          data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)cm_if_info.sups_alpha_info.alpha_id.alpha_dcs;
          data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.alpha_id.alpha_text_len = cm_if_info.sups_alpha_info.alpha_id.alpha_len;
          memscpy(&(data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.alpha_id.alpha_text),sizeof((data_ptr->cmd.cm_if_data_ptr->data.get_cnap_resp.alpha_id.alpha_text)), &(cm_if_info.sups_alpha_info.alpha_id.alpha_text),sizeof(cm_if_info.sups_alpha_info.alpha_id.alpha_text));
			   memset(&(cm_if_info.sups_alpha_info),0,sizeof(qmi_voice_cm_if_sups_alpha_info));
			 }
		   }
		   else
		   {
			 QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
			 qmi_mmode_free_cmd_data_buf(data_ptr);
			 return;
		   }
		   break;

    case QMI_VOICE_CM_IF_CMD_CALL_ENCRYPTION:
      data_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_CALL_ENCRYPTION_RESP;
      data_ptr->cmd.cm_if_data_ptr->data.call_encryption_resp.resp.error = QMI_ERR_NONE_V01;;
      break;

    /* Cases for Other commands */

    default:
      QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
      qmi_mmode_free_cmd_data_buf(data_ptr);
      return;
  }/* switch */

  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CB, data_ptr);
}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_UNSOL_RESPONSE()

  DESCRIPTION
    Send the command to VOICE service for indication to be sent
    to the control point.

  PARAMETERS
    ind                        : Uniquely identifies a Indication
    response                   : Ptr to response data sent to control point
    response_len               : Length of the response data

  RETURN VALUE
    Pointer to event name string

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_unsol_response
(
  qmi_voice_cm_if_cmd_e_type  ind_type,
  void                        *response,
  int                         response_len,
  uint8                       as_id
)
{
  qmi_mmode_cmd_data_buf_type * data_ptr;
  /*-----------------------------------------------------------------------*/
  
  data_ptr = qmi_mmode_get_cmd_data_buf();
  
  if(NULL == data_ptr)
  {
	  qmi_voice_cmd_fatal();
    return;
  }
  
  data_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(data_ptr->cmd.cm_if_data_ptr)));
  if( NULL == data_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(data_ptr);
    return;
  }
  memset(data_ptr->cmd.cm_if_data_ptr, 0, sizeof(*(data_ptr->cmd.cm_if_data_ptr)));
  
  /* Fill common data */
  data_ptr->cmd.cm_if_data_ptr->header.cmd = ind_type;
  data_ptr->cmd.cm_if_data_ptr->header.as_id = as_id;

  QM_MSG_MED_2("qmi_voice_cm_if_unsol_response:: indication %d ; p_response: %x",
               ind_type, response);

  switch(ind_type)
  {
    case QMI_VOICE_CM_IF_CMD_SUPS_NOTIFICATION_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.sups_notify_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.sups_notify_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_ALL_CALL_STATUS_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.all_call_status_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.all_call_status_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_OTASP_STATUS_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.otasp_status_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.otasp_status_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_PRIVACY_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.privacy_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.privacy_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_DTMF_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.dtmf_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.dtmf_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_INFO_REC_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.info_rec_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.info_rec_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_USSD_IND :
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.ussd_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.ussd_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_USSD_RELEASE_IND:
      //USSD RELEASE Indication being sent 
      break;

    case QMI_VOICE_CM_IF_CMD_UUS_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.uus_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.uus_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_SUPS_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.sups_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.sups_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

case QMI_VOICE_CM_IF_CMD_CALL_MODIFIED_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.call_modified_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.call_modified_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }     
      break;

    case QMI_VOICE_CM_IF_CMD_CALL_MODIFY_ACCEPT_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.call_modify_accept_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.call_modify_accept_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }         
      break;

    case QMI_VOICE_CM_IF_CMD_SPEECH_CODEC_INFO_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.speech_codec_info_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.speech_codec_info_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;
    case QMI_VOICE_CM_IF_CMD_HANDOVER_IND:		
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.handover_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.handover_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;
    case QMI_VOICE_CM_IF_CMD_AOC_LOW_FUNDS_IND:
      //AOC LOW FUNDS Indication being sent
      break;
    case QMI_VOICE_CM_IF_CMD_CONF_INFO_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.conference_info_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.conference_info_ind), response, response_len);
      }
      else
      {        
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;
    case QMI_VOICE_CM_IF_CMD_CONF_JOIN_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.conference_join_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.conference_join_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_CONF_PARTICIPANT_UPDATE_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.conf_participant_info_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.conf_participant_info_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_EXT_BRST_INTL_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.ext_brst_intl_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.ext_brst_intl_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

     case QMI_VOICE_CM_IF_CMD_MT_PAGE_MISS_IND:	  
       if(response != NULL)
       {
         memscpy(&data_ptr->cmd.cm_if_data_ptr->data.mt_page_miss_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.mt_page_miss_ind), response, response_len);
       }
       else
       {
         QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
         qmi_mmode_free_cmd_data_buf(data_ptr);
         return;
       }
       break;
     case QMI_VOICE_CM_IF_CMD_CC_RESULT_INFO_IND:
       if(response != NULL)
       {
         memscpy(&data_ptr->cmd.cm_if_data_ptr->data.cc_result_info_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.cc_result_info_ind), response, response_len);
       }
       else
       {
         QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
         qmi_mmode_free_cmd_data_buf(data_ptr);
         return;
       }
       break;
     case QMI_VOICE_CM_IF_CMD_CONF_PARTICIPANTS_INFO_IND:
       if(response != NULL)
       {
         memscpy(&data_ptr->cmd.cm_if_data_ptr->data.parsed_conf_info,sizeof(data_ptr->cmd.cm_if_data_ptr->data.parsed_conf_info), response, response_len);
       }
       else
       {
         QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
         qmi_mmode_free_cmd_data_buf(data_ptr);
         return;
       }
       break;
    case QMI_VOICE_CM_IF_CMD_TTY_INFO_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.tty_info, sizeof(data_ptr->cmd.cm_if_data_ptr->data.tty_info), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;
    case QMI_VOICE_CM_IF_CMD_AUDIO_RAT_CHANGE_INFO_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.audio_rat_change_info, sizeof(data_ptr->cmd.cm_if_data_ptr->data.audio_rat_change_info), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;
    case QMI_VOICE_CM_IF_CMD_E911_ORIG_FAIL_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.e911_orig_fail_ind,sizeof(data_ptr->cmd.cm_if_data_ptr->data.e911_orig_fail_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_ADDITIONAL_CALL_INFO_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.additional_call_info, sizeof(data_ptr->cmd.cm_if_data_ptr->data.additional_call_info), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;

    case QMI_VOICE_CM_IF_CMD_CONF_PARTICIPANT_STATUS_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.participant_status_info, sizeof(data_ptr->cmd.cm_if_data_ptr->data.participant_status_info), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break;	  

    case QMI_VOICE_CM_IF_CMD_VICE_DIALOG_IND:
      if(response != NULL)
      {
        memscpy(&data_ptr->cmd.cm_if_data_ptr->data.vice_dialog_info_ind, sizeof(data_ptr->cmd.cm_if_data_ptr->data.vice_dialog_info_ind), response, response_len);
      }
      else
      {
        QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
        qmi_mmode_free_cmd_data_buf(data_ptr);
        return;
      }
      break; 

    default:
      /*qmi_voice_cm_if_unsol_response:  Invalid Indication: ind_type*/
      QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
      qmi_mmode_free_cmd_data_buf(data_ptr);
      return;
  } /* switch */
  
  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CB, data_ptr);

}/* qmi_voice_cm_if_unsol_response() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_ORIGINATE_ECALL()

  DESCRIPTION
    Invoke eCall API for call origination

  PARAMETERS
    params_ptr                : Ptr to qmi_voice_cm_if_info_item_s 

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_originate_eCall
(
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
#ifdef FEATURE_ECALL_APP

  voice_dial_call_req_msg_v02 *in_data_ptr;
  ecall_type_of_call ecall_type = ECALL_TEST;
  ecall_activation_type           activation_type=ECALL_MANUAL_INITIATED;
  ecall_call_orig_exten_info_s_type call_orig_exten_info;
  
  ASSERT( params_ptr != NULL );
  in_data_ptr = &(params_ptr->data.dial_call);
  ASSERT( in_data_ptr != NULL );

  memset(&call_orig_exten_info, 0, sizeof(call_orig_exten_info));

  if(in_data_ptr->ecall_variant_valid)
  {
    ecall_type = (ecall_type_of_call)qmi_voice_cm_if_map_qmi_to_eCall_type(in_data_ptr->ecall_variant);
  }

  /* Check if it is manual or auto emergency eCall */
  if( (in_data_ptr->ecall_variant == ECALL_EMERGENCY_V02) && (in_data_ptr->emer_cat_valid))
  {
    if( (in_data_ptr->emer_cat & QMI_VOICE_CM_IF_EMERG_CAT_AUTO_ECALL) != 0)
    {
      activation_type = ECALL_AUTOMATIC_INITIATED;
    }
  }

  if( in_data_ptr->ecall_msd_valid == TRUE )
  {
    QM_MSG_MED_1("Originate eCall with external MSD. Length = %d", in_data_ptr->ecall_msd_len);
    call_orig_exten_info.is_ecall_msd_available = TRUE;
    memscpy(call_orig_exten_info.ecall_msd, sizeof(call_orig_exten_info.ecall_msd), in_data_ptr->ecall_msd, in_data_ptr->ecall_msd_len);
  }
  
  if (!ecall_session_qmi_start_per_subs(ecall_type,
                                        activation_type, 
                                        qmi_voice_cm_if_ecall_orig_exten_info_cb,
                                        (void *) params_ptr->header.handle,
                                        call_orig_exten_info
     )
    )
  {
    QM_MSG_ERROR("Call to ecall_session_qmi_start Failed");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
  }
  else
  {
    QM_MSG_HIGH_3("Invoked eCall orig with ecall_type %d, activation_type %d, handle %d", ecall_type, activation_type, params_ptr->header.handle);
  }
  
#else /* FEATURE_ECALL_APP */

  /*FEATURE_ECALL_APP not defined. Cannot make eCall */
  qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_OP_DEVICE_UNSUPPORTED,TRUE,TRUE);

#endif /* FEATURE_ECALL_APP */
 
} /* qmi_voice_cm_if_originate_eCall */


/*===========================================================================
                    VOICE WRAPPER FUNCTIONS
===========================================================================*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_DIAL_CALL()

  DESCRIPTION
    Invoke CM API to Dial a call.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_dial_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  voice_dial_call_req_msg_v02 *in_data_ptr;
  cm_srv_type_e_type srv_type = CM_SRV_TYPE_AUTOMATIC;
  cm_call_type_e_type call_type = CM_CALL_TYPE_VOICE;
  cm_num_s_type calling_number, called_number;
  cm_orig_alpha_s_type alpha_buf;
  cm_gw_cs_orig_params_s_type gw_cs_orig_params;
  cm_gw_cs_orig_params_s_type *gw_cs_orig_params_ptr = &gw_cs_orig_params;
  cm_cdma_orig_params_s_type cdma_orig_params;
  cm_cdma_orig_params_s_type *cdma_orig_params_ptr = &cdma_orig_params;
  int uus_len = 0,i;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  qmi_voice_cm_util_ss_info_s util_sys_info;
  cm_ip_orig_params_s_type ip_orig_params;
  cm_ip_orig_params_s_type *ip_orig_params_ptr = &ip_orig_params;
  _ref_cnt_info_t *conf_init_ptr;
  _ref_cnt_info_t *file_attrib;
  IxErrnoType status = E_SUCCESS;
  boolean is_dial_call_success = FALSE;
  cm_call_id_type          cm_call_id;
  uint8                sip_uri[CM_MAX_CALLED_INFO_CHARS_IP];
  uint16               ref_str_len=0;
  qmi_error_e_type err = QMI_ERR_NONE;
  uint8 calling_number_len, sip_uri_overflow_len;
  uint16 vs_file_attributes_len, conf_uri_list_len;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );
  in_data_ptr = &(params_ptr->data.dial_call);
  ASSERT( in_data_ptr != NULL );


  /*-----------------------------------------------------------------------*/

  /* Validate input params */
  if ( (err = qmi_voice_cm_if_validate_dial_call_params(in_data_ptr)) != QMI_ERR_NONE )
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,err,FALSE,FALSE);
    return;
  }

  memset( &called_number, 0, sizeof( called_number ) );
  memset( &calling_number, 0, sizeof( calling_number ) );
  memset(&util_sys_info, 0, sizeof( util_sys_info));
  memset(sip_uri, 0, sizeof( sip_uri));
  
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/
  qmi_voice_cm_util_get_ss_info(&util_sys_info,as_id);
  
  /* Add entry to Cmd List and save asubs_id as sub_id*/
  status = qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                          QMI_VOICE_CMD_AWAITING_CALLBACK, QMI_VOICE_CM_IF_EVT_NONE, 
                          (uint32)as_id, NULL, 0, as_id );
  if (  status == E_NO_MEMORY ) 
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else if (  status != E_SUCCESS ) 
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }
  else
  {
    /* Cmd list entry added successfully */
    /* Check if this is an eCall*/
    if((in_data_ptr->call_type_valid) && (in_data_ptr->call_type == CALL_TYPE_ECALL_V02))
    {
      qmi_voice_cm_if_originate_eCall(params_ptr);
      cm_if_info.eCall_info.as_id = as_id;
      return;
    }
  }

  /* Initialize origination number */
  cm_num_init( &calling_number );
  calling_number.number_plan = CM_NPI_ISDN;

  calling_number_len = strlen(in_data_ptr->calling_number);
  
    /*if overflow is available, need to concatenate number and overflow and send */
    if(in_data_ptr->sip_uri_overflow_valid)
    {
      sip_uri_overflow_len = strlen(in_data_ptr->sip_uri_overflow);
      if(strlcat((char*)sip_uri,(char*)in_data_ptr->calling_number, calling_number_len+1)
                                                     > CM_MAX_CALLED_INFO_CHARS_IP)
      {
        QM_MSG_ERROR_1("Wrong calling number or calling number length len=%d", calling_number_len);
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,TRUE,FALSE);
        return;
      }   
      if(strlcat((char*)sip_uri,(char*)in_data_ptr->sip_uri_overflow, calling_number_len+sip_uri_overflow_len+1)
                                                     > CM_MAX_CALLED_INFO_CHARS_IP)
      {
        QM_MSG_ERROR_1("Wrong sip overflow data len = %d", sip_uri_overflow_len);
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,TRUE,FALSE);
        return;
      }
      /* Initialize dialed number */
      cm_num_fill( &called_number, ( uint8 * )sip_uri, 
                 (calling_number_len+sip_uri_overflow_len), CM_DIGIT_MODE_8BIT_ASCII );
      /*called_number.buf[calling_number_len ] = '\0';  since length variable is available*/
    }
    else
    {
      /* Initialize dialed number */
      cm_num_fill( &called_number, ( uint8 * )in_data_ptr->calling_number, 
                   calling_number_len , CM_DIGIT_MODE_8BIT_ASCII );
    }

  called_number.number_plan = CM_NPI_ISDN;

  if ( in_data_ptr->emer_cat_valid)
  {
    called_number.emerg_srv_categ = in_data_ptr->emer_cat;
  }

  if ( in_data_ptr->called_party_subaddress_valid )
  {
    QM_MSG_MED_1("Called party Subaddress present and len=%d", in_data_ptr->called_party_subaddress.subaddress_len);
    called_number.subaddr.extension_bit = in_data_ptr->called_party_subaddress.extension_bit;
    called_number.subaddr.subadd_type = in_data_ptr->called_party_subaddress.subaddress_type;
    called_number.subaddr.odd_even_ind = in_data_ptr->called_party_subaddress.odd_even_ind;
    called_number.subaddr.num_char = in_data_ptr->called_party_subaddress.subaddress_len;
      memscpy(called_number.subaddr.chari,sizeof(called_number.subaddr.chari), in_data_ptr->called_party_subaddress.subaddress, in_data_ptr->called_party_subaddress.subaddress_len);
  }

  /* Initialize call type */
  if ( in_data_ptr->call_type_valid )
  {
    call_type = qmi_voice_cm_util_map_qmi_to_cm_call_type((qmi_voice_cm_if_call_type_e_type)in_data_ptr->call_type);
  }
   QM_MSG_MED_5("TIPTIR Dial Call valid=%d,call_type=%d,pi_val=%d,pi_value=%d digit_mode=%d ",in_data_ptr->call_type_valid,in_data_ptr->call_type,in_data_ptr->pi_valid,
                in_data_ptr->pi, called_number.digit_mode);
  memset( &ip_orig_params, 0, sizeof( ip_orig_params ) );

  if(in_data_ptr->call_type == CALL_TYPE_EMERGENCY_VT_V02)
  {
    ip_orig_params.call_attrib.em_type = CM_CALL_EM_VT;
    QM_MSG_HIGH("em_type = VT");
  }

    //checking if the secure call field is true
  if(in_data_ptr->is_secure_call_valid)
  {
	  ip_orig_params.call_attrib.is_secure_call = in_data_ptr->is_secure_call;
	  QM_MSG_MED_2("Secure call TLV received=%d and sent = %d", in_data_ptr->is_secure_call, ip_orig_params.call_attrib.is_secure_call);
  }

    //Set PI info related to IP Call        
    if(in_data_ptr->pi_valid && in_data_ptr->pi <= IP_PRESENTATION_NUM_RESTRICTED_V02)
    {          
      calling_number.pi = in_data_ptr->pi;
      ip_orig_params.call_attrib.is_ip_pi_valid = TRUE;
    }
    else
    {
      ip_orig_params.call_attrib.is_ip_pi_valid = FALSE;
    }
  
  QM_MSG_MED_2("TIPTIR Dial Call calling_num.pi=%d, valid=%d", calling_number.pi, ip_orig_params.call_attrib.is_ip_pi_valid);

  alpha_buf.buf[0]='\0';
  alpha_buf.len = 0;

  /* Setup GSM/WCDMA origination paramaters */
  memset( &gw_cs_orig_params, 0, sizeof( gw_cs_orig_params ) );


  if ( in_data_ptr->audio_attrib_valid )
  {
    ip_orig_params.call_attrib.audio_attrib = (cm_call_attrib_e_type)in_data_ptr->audio_attrib;
  }

  if ( in_data_ptr->video_attrib_valid )
  {
    ip_orig_params.call_attrib.video_attrib = (cm_call_attrib_e_type)in_data_ptr->video_attrib;
  }

  conf_uri_list_len = strlen(in_data_ptr->conf_uri_list);

  /*Copy the vs_call attributes to the cm structure*/
  if ( in_data_ptr->videoshare_call_attribs_valid )
  {
    vs_file_attributes_len = strlen(in_data_ptr->videoshare_call_attribs.file_attributes);
    if(vs_file_attributes_len > 0)
    {
      /*Allocate memory for ref_cnt_ header, file attrib string, NULL*/
      ref_str_len = sizeof(_ref_cnt_info_t)+vs_file_attributes_len;
      file_attrib = (_ref_cnt_info_t *) QMI_VOICE_CM_IF_MEM_ALLOC(ref_str_len+1);
      if( NULL == file_attrib )
      {
		  qmi_voice_mem_fatal();
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,TRUE,FALSE);
        return;
      }
      memset(file_attrib, 0, (ref_str_len+1));
      /*start copying leaving space for ref_cnt_ header +1 here means shift by sizeof(_ref_cnt_info_t) since file_attrib is pointer to  _ref_cnt_info_t*/
      memscpy(file_attrib+1, sizeof(file_attrib) - 1, in_data_ptr->videoshare_call_attribs.file_attributes,
              vs_file_attributes_len); 
      QM_MSG_MED_2("Dial_call::File_attrib:%s,Length=%d",(char*)(file_attrib+1),vs_file_attributes_len);

      ip_orig_params.call_attrib.ip_gen_param = file_attrib;
    }
    ip_orig_params.call_attrib.vs_ver =  qmi_voice_cm_util_map_qmi_to_cm_vs_version((qmi_voice_cm_if_vs_version_e_type)in_data_ptr->videoshare_call_attribs.vs_variant);

  }  /*Copy the conf_creation_uri data to the cm structure*/
  else if(in_data_ptr->conf_uri_list_valid && (conf_uri_list_len > 0))
  {      
    /*Allocate memory for <ref_cnt_header + conf creation uri + NULL>*/
    ref_str_len = sizeof(_ref_cnt_info_t)+conf_uri_list_len;
    QM_MSG_MED_1("ref_str_len for conf_init_uri= %d", ref_str_len);
    conf_init_ptr = (_ref_cnt_info_t *) QMI_VOICE_CM_IF_MEM_ALLOC(ref_str_len+1);
    if( NULL == conf_init_ptr )
    {
		qmi_voice_mem_error();
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,TRUE,FALSE);
      return;
    }
    memset(conf_init_ptr, 0, (ref_str_len+1));
    /*start copying leaving space for ref_cnt_ header +1 here means shift by sizeof(_ref_cnt_info_t) since conf_init_ptr is pointer to  _ref_cnt_info_t*/
    memscpy(conf_init_ptr+1,conf_uri_list_len,in_data_ptr->conf_uri_list, QMI_VOICE_CONF_URI_LIST_MAX_LEN_V02);
    ip_orig_params.call_attrib.ip_gen_param = conf_init_ptr;
  }

  if(in_data_ptr->display_text_valid && (in_data_ptr->display_text_len > 0))
  {
    /* copy display text to CM structure*/
    ip_orig_params.call_attrib.display_text.displayTextLength = in_data_ptr->display_text_len;
    memscpy(ip_orig_params.call_attrib.display_text.display_text,
            sizeof(ip_orig_params.call_attrib.display_text.display_text),
            in_data_ptr->display_text,
            (in_data_ptr->display_text_len*2));

  
    for (i = 0; i< ip_orig_params.call_attrib.display_text.displayTextLength;i++)
    {
      QM_MSG_LOW_2("Dial_call::Display txt rxed = %c Display txt filled = %c", in_data_ptr->display_text[i], ip_orig_params.call_attrib.display_text.display_text[i]);
    }
    
  }

   if(in_data_ptr->call_pull_valid)
  {
    /* copy call pull*/
    ip_orig_params.call_attrib.is_call_pull= (boolean)in_data_ptr->call_pull;   
  }

  if(in_data_ptr->codec_profile_valid)
  {
    /* copy codec profile */
    ip_orig_params.call_attrib.codec_profile = in_data_ptr->codec_profile;
  }

  cm_util_default_gw_orig_params( gw_cs_orig_params_ptr ); 


  /* Below parameters are not initialized by cm_util_default_gw_orig_params(), need to do explicit initialization to
   enforce retaining good values after above RPC calls */
  gw_cs_orig_params.call_control_completed = FALSE;
  gw_cs_orig_params.mo_user_data.present = FALSE;

  if ( in_data_ptr->clir_type_valid)
  {
    /* Use CLIR setting specified in DIAL cmd */
    if (in_data_ptr->clir_type == CLIR_INVOCATION_V02 )
    { 
      gw_cs_orig_params.cm_clir = 11;
    }
    /* Use CLIR setting specified in DIAL cmd */
    else if ( in_data_ptr->clir_type == CLIR_SUPPRESSION_V02 )
    {
      gw_cs_orig_params.cm_clir = 12;   
    }
  }
  /* Use the default CLIR setting */
  else
  {
  if ( cm_if_info.clir == CLIR_INVOCATION_V02 )
  {
    gw_cs_orig_params.cm_clir = 11;
  }
  else if ( cm_if_info.clir == CLIR_SUPPRESSION_V02 )
  {
    gw_cs_orig_params.cm_clir = 12;   
  }
  else
  {
    gw_cs_orig_params.cm_clir = 0;   
  }
  }

  #ifdef FEATURE_TTY
    if ( qm_nv_get( NV_TTY_I, &nv_buf, (enum qm_subs_e)as_id ) == NV_DONE_S &&
       nv_buf.tty != QM_NV_TTY_MODE_OFF )
  {
    gw_cs_orig_params.bearer_capability_1.ctm = CTM_SUPPORTED;
  }
  else
  {
    gw_cs_orig_params.bearer_capability_1.ctm = CTM_NOT_SUPPORTED;
  }
  #else
  //"TTY undefined setting the default value as OFF
  #endif // FEATURE_TTY

  if(CM_ALS_LINE_02 == cm_if_info.als.curr_line )
  {
    gw_cs_orig_params.bearer_capability_1.information_transfer_capability = cm_if_info.als.itc_aux_val;
  }

  /* Setup CDMA origination parameters */
  memset( &cdma_orig_params, 0, sizeof( cdma_orig_params ) );

  
  cm_util_default_cdma_orig_params( &cdma_orig_params );
  /* set activate_code to CM_PREFERRED for non_otasp since ui_nc_type_allowed_and_callcontrol_cb() won't do
  Number classification function unless call type voice */
  cdma_orig_params.activate_code = (call_type==0x08) ? CM_PREFERRED : cdma_orig_params.activate_code;


  if((in_data_ptr->call_type == (uint32)QMI_VOICE_CM_IF_CALL_TYPE_VOIP) || 
       (in_data_ptr->call_type == (uint32)QMI_VOICE_CM_IF_CALL_TYPE_VT)   ||
       (in_data_ptr->call_type == (uint32)QMI_VOICE_CM_IF_CALL_TYPE_EMERGENCY_VT)   ||
       (in_data_ptr->call_type == (uint32)QMI_VOICE_CM_IF_CALL_TYPE_VIDEOSHARE))
  {
    srv_type = CM_SRV_TYPE_PS_ONLY;
  }

  if(in_data_ptr->service_type_valid==TRUE) /* srv type mentioned by qmi client*/
  {
      srv_type = qmi_voice_cm_if_map_qmi_to_cm_srv_type((qmi_voice_cm_if_srv_type_e_type)in_data_ptr->service_type); 
  }
  /*srv_type is finalised. Here onwards, the parameters and APIs will be depending on the srv_type*/

  if ( (srv_type == CM_SRV_TYPE_GSM_WCDMA) || 
       (srv_type == CM_SRV_TYPE_GSM) || 
       (srv_type == CM_SRV_TYPE_WCDMA)||
       (srv_type == CM_SRV_TYPE_TDS)||
       (srv_type == CM_SRV_TYPE_TDS_GSM_WCDMA)
      ) 
  {
    cdma_orig_params_ptr = NULL;
    ip_orig_params_ptr = NULL;
    /* fill uus info if present */
    if(in_data_ptr->uus_valid)
    {
      gw_cs_orig_params_ptr->mo_user_data.present = TRUE;
      gw_cs_orig_params_ptr->mo_user_data.user_user_type = (uus_type_T)in_data_ptr->uus.uus_type;
      gw_cs_orig_params_ptr->mo_user_data.user_user_protocol_disc = (byte)in_data_ptr->uus.uus_dcs;
      if(in_data_ptr->uus.uus_data_len < QMI_VOICE_CM_IF_MAX_UUS_DATA_LEN)
      {
        uus_len = in_data_ptr->uus.uus_data_len;
      }
      else
      {
        uus_len = QMI_VOICE_CM_IF_MAX_UUS_DATA_LEN;
      }
      gw_cs_orig_params_ptr->mo_user_data.user_user_data_length = uus_len;
        memscpy(gw_cs_orig_params_ptr->mo_user_data.user_user_data,sizeof(gw_cs_orig_params_ptr->mo_user_data.user_user_data), in_data_ptr->uus.uus_data, uus_len);
    }
    /* fill cug info if present */
    if(in_data_ptr->cug_valid)
    {
      gw_cs_orig_params_ptr->forward_cug_info.present = TRUE;
      if(in_data_ptr->cug.cug_index != QMI_VOICE_CM_IF_INVALID_CUG_INDEX)
      {
        gw_cs_orig_params_ptr->forward_cug_info.cm_cug_index.present = TRUE;
        gw_cs_orig_params_ptr->forward_cug_info.cm_cug_index.lsb = (in_data_ptr->cug.cug_index) & 0xFF;
        gw_cs_orig_params_ptr->forward_cug_info.cm_cug_index.msb = (in_data_ptr->cug.cug_index >> 8) & 0xFF;
      }
      gw_cs_orig_params_ptr->forward_cug_info.cm_suppress_pref_cug = in_data_ptr->cug.suppress_pref_cug;
      gw_cs_orig_params_ptr->forward_cug_info.cm_suppress_outgoing_access = in_data_ptr->cug.suppress_oa;
    }
  }
  else if ( srv_type == CM_SRV_TYPE_CDMA_AUTOMATIC ) 
  {
    gw_cs_orig_params_ptr = NULL;
    ip_orig_params_ptr = NULL;
  }
  else if ( srv_type == CM_SRV_TYPE_AUTOMATIC )
  {
    /* fill uus info if present */
    if(in_data_ptr->uus_valid)
    {
      gw_cs_orig_params_ptr->mo_user_data.present = TRUE;
      gw_cs_orig_params_ptr->mo_user_data.user_user_type = (uus_type_T)in_data_ptr->uus.uus_type;
      gw_cs_orig_params_ptr->mo_user_data.user_user_protocol_disc = (byte)in_data_ptr->uus.uus_dcs;
      if(in_data_ptr->uus.uus_data_len < QMI_VOICE_CM_IF_MAX_UUS_DATA_LEN)
      {
        uus_len = in_data_ptr->uus.uus_data_len;
      }
      else
      {
        uus_len = QMI_VOICE_CM_IF_MAX_UUS_DATA_LEN;
      }
      gw_cs_orig_params_ptr->mo_user_data.user_user_data_length = uus_len;
        memscpy(gw_cs_orig_params_ptr->mo_user_data.user_user_data,sizeof(gw_cs_orig_params_ptr->mo_user_data.user_user_data), in_data_ptr->uus.uus_data, uus_len);
    }
    /* fill cug info if present */
    if(in_data_ptr->cug_valid)
    {
      gw_cs_orig_params_ptr->forward_cug_info.present = TRUE;
      if(in_data_ptr->cug.cug_index != QMI_VOICE_CM_IF_INVALID_CUG_INDEX)
      {
        gw_cs_orig_params_ptr->forward_cug_info.cm_cug_index.present = TRUE;
        gw_cs_orig_params_ptr->forward_cug_info.cm_cug_index.lsb = (in_data_ptr->cug.cug_index) & 0xFF;
        gw_cs_orig_params_ptr->forward_cug_info.cm_cug_index.msb = (in_data_ptr->cug.cug_index >> 8) & 0xFF;
      }
      gw_cs_orig_params_ptr->forward_cug_info.cm_suppress_pref_cug = in_data_ptr->cug.suppress_pref_cug;
      gw_cs_orig_params_ptr->forward_cug_info.cm_suppress_outgoing_access = in_data_ptr->cug.suppress_oa;
    }      
  }
  else if ( srv_type == CM_SRV_TYPE_LTE || srv_type == CM_SRV_TYPE_PS_ONLY )
  {
    QM_MSG_HIGH_1("Initiating an IP call with srv_type = %d", srv_type);
    gw_cs_orig_params_ptr = NULL;
    cdma_orig_params_ptr = NULL;
  }


  if(in_data_ptr->call_type_valid && 
      (in_data_ptr->call_type == (uint8)QMI_VOICE_CM_IF_CALL_TYPE_VOICE_FORCED))
  {
    /* Avoid further call type resolution by CM. 
     This also will result in avoiding CM call control */
    //Skipping call control as VOICE is Forced
    gw_cs_orig_params.call_control_completed = TRUE;
    /* Force call type as Voice */
    call_type = CM_CALL_TYPE_VOICE;
  }

  

  if(cm_if_info.otasp_info.is_non_std_otasp_num_available)
  {
    for(i = 0; (i< QMI_VOICE_CM_IF_OTASP_NUM) && (cm_if_info.otasp_info.num[i].num_len > 0); i++)
    {
      if( qmi_voice_cm_util_number_match(cm_if_info.otasp_info.num[i].num_buf, cm_if_info.otasp_info.num[i].num_len,
                                        (byte *) in_data_ptr->calling_number, (byte) calling_number_len) )    
      { 	   
       /* If we found a match, change the call type to the corresponding,		  
       ** type in the table and indicate the OTASP activation code. */
         QM_MSG_MED_1("Non Std OTASP match found %s",cm_if_info.otasp_info.num[i].num_buf);	    
	   call_type = CM_CALL_TYPE_NON_STD_OTASP;
	   cdma_orig_params.activate_code = CM_PREFERRED;
	   break;
      }    
    }
  }

  if ( gw_cs_orig_params_ptr != NULL )
  {
    QM_MSG_LOW_6("gw_cs_orig_params: (bearer_capability_1) present=%d, radio_chnl_req=%d, coding_std=%d, tf_mode=%d, info_tf_cap=%d, ctm=%d",
                 gw_cs_orig_params.bearer_capability_1.present,
                 gw_cs_orig_params.bearer_capability_1.radio_channel_requirement,
                 gw_cs_orig_params.bearer_capability_1.coding_standard,
                 gw_cs_orig_params.bearer_capability_1.transfer_mode,
                 gw_cs_orig_params.bearer_capability_1.information_transfer_capability,
                 gw_cs_orig_params.bearer_capability_1.ctm);

    QM_MSG_LOW_9("gsm_speech_ver: pref0=%d, pref1=%d, pref2=%d, pref3=%d, pref4=%d, pref5=%d, compression = %d, structure=%d, duplex_mode=%d",
                 gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_0,
                 gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_1,
                 gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_2,
                 gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_3,
                 gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_4,
                 gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_5,
                 gw_cs_orig_params.bearer_capability_1.compression,
                 gw_cs_orig_params.bearer_capability_1.structure,
                 gw_cs_orig_params.bearer_capability_1.duplex_mode);

    QM_MSG_MED_7("clir=%d, call_control_completed=%d; (mo_user_data) present=%d, type=%d, data_length=%d, protocol_disc=%d, more_data_indicator=%d",
                 gw_cs_orig_params.cm_clir, gw_cs_orig_params.call_control_completed,
                 gw_cs_orig_params.mo_user_data.present,
                 gw_cs_orig_params.mo_user_data.user_user_type,
                 gw_cs_orig_params.mo_user_data.user_user_data_length,
                 gw_cs_orig_params.mo_user_data.user_user_protocol_disc,
                 gw_cs_orig_params.mo_user_data.more_data_indicator);
   }

  if( (in_data_ptr->conf_uri_list_valid) &&
      (calling_number_len > 0) &&
      (strcmp((char*)in_data_ptr->calling_number, "Conference Call") == 0) )
  {
    QM_MSG_MED("Calling number \"Conference Call\" is being copied to alpha_buf.");
    alpha_buf.len = memscpy(alpha_buf.buf, CM_MAX_ALPHA_LEN_FOR_CALL_ORIG, in_data_ptr->calling_number, MIN(calling_number_len, QMI_VOICE_CM_IF_MAX_CALLING_NUM_LEN));
  }

#ifdef FEATURE_DUAL_SIM
    QM_MSG_MED("Invoke cm_mm_call_cmd_orig_cc_per_subs_exten() ");
    if(ip_orig_params_ptr != NULL && ip_orig_params.call_attrib.ip_gen_param)
    {
      ref_cnt_obj_init(ip_orig_params.call_attrib.ip_gen_param, qmi_voice_cm_if_ip_gen_param_destructor);
    }
    if ( !cm_mm_call_cmd_orig_cc_per_subs_exten( qmi_voice_cm_if_callsvc_exten_command_callback,
                             (void *) params_ptr->header.handle,
                             qmi_voice_cm_if_get_clientid(),
                             call_type,
                             srv_type,
                             &calling_number,
                             &called_number,
                             &alpha_buf,
                             cdma_orig_params_ptr,
                             gw_cs_orig_params_ptr,
                             NULL,
                             ip_orig_params_ptr,
                             CM_CALL_ID_INVALID,
                             CM_ORIG_CLIENT_CATEG_USER,
                             (sys_modem_as_id_e_type)as_id, /* Subs id */
                             &cm_call_id ))
  {
     QM_MSG_ERROR("Call to cm_mm_call_cmd_orig_cc_per_subs failed ");
     qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
  }
  else
  {
    QM_MSG_MED_2("Dial cmd, assigned call id = %d, DSDS, as_id=%d", cm_call_id, as_id);
    if(ip_orig_params_ptr != NULL && ip_orig_params.call_attrib.ip_gen_param)
    {
      ref_cnt_obj_release(ip_orig_params.call_attrib.ip_gen_param); //upon function return, release ref count obj
      //ref to ip_orig_param released
    }
    is_dial_call_success = TRUE;
  }
#else
  if( ip_orig_params_ptr == NULL ) // CS only
  {

    QM_MSG_MED_1("Invoke cm_mm_call_cmd_orig_exten3() srv_type = %d", srv_type);
    if ( !cm_mm_call_cmd_orig_exten3( qmi_voice_cm_if_callsvc_exten_command_callback,
                             (void *) params_ptr->header.handle,
                             qmi_voice_cm_if_get_clientid(),
                             call_type,
                             srv_type,
                             &calling_number,
                             &called_number,
                             &alpha_buf,
                             cdma_orig_params_ptr,
                             gw_cs_orig_params_ptr,
                             NULL,
                             CM_CALL_ID_INVALID,
                             CM_ORIG_CLIENT_CATEG_USER,
                             &cm_call_id ) )
    {
      QM_MSG_ERROR("Call to cm_mm_call_cmd_orig_exten3 failed ");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
    }
    else
    {
      QM_MSG_MED_1("Dial cmd, assigned voice call id = %d", cm_call_id);
      is_dial_call_success = TRUE;
    }
  }
  else
  {
    if(ip_orig_params.call_attrib.ip_gen_param)
    {
      ref_cnt_obj_init(ip_orig_params.call_attrib.ip_gen_param, qmi_voice_cm_if_ip_gen_param_destructor);
    }

    QM_MSG_MED_1("Invoke cm_mm_call_cmd_orig_exten4() for VT/VOIP/Voice srv_type=%d", srv_type);
    if ( !cm_mm_call_cmd_orig_exten4( qmi_voice_cm_if_callsvc_exten_command_callback,
                                      (void *) params_ptr->header.handle,
                                       qmi_voice_cm_if_get_clientid(),
                                       call_type,
                                       srv_type,
                                       &calling_number,
                                       &called_number,
                                       &alpha_buf,
                                       cdma_orig_params_ptr,
                                       gw_cs_orig_params_ptr,
                                       NULL,
                                       ip_orig_params_ptr,
                                       &cm_call_id ) )
    {
      QM_MSG_ERROR("Call to cm_mm_call_cmd_orig_exten4 failed ");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
    }
    else
    {
      QM_MSG_MED_1("Dial cmd, assigned VT/Voip/Voice call id = %d", cm_call_id);
      if(ip_orig_params.call_attrib.ip_gen_param)
      {
        ref_cnt_obj_release(ip_orig_params.call_attrib.ip_gen_param); //upon function return, release ref count obj
      }
      is_dial_call_success = TRUE;
    }    
  }
#endif/*FEATURE_DUAL_SIM*/

  if(is_dial_call_success)
  {
    cm_alpha_s_type           alpha;
    voice_dial_call_resp_msg_v02 dial_call_resp;
    
    memset(&alpha, 0, sizeof(alpha));
    /* Add entry to call list */
    if ( qmi_voice_call_list_new( cm_call_id, call_type, 
                                  SYS_SYS_MODE_NO_SRV, CM_CALL_DIRECTION_MO, QMI_VOICE_CALL_LIST_STATE_CC_IN_PROG,
                                  cm_if_info.als.curr_line, called_number, alpha, 0, FALSE                                  
                                  ,as_id
                                  ,ip_orig_params.call_attrib
                                 ) != E_SUCCESS )
    {
      /* Ignore it.The entry will be added upon call event orig */
       QM_MSG_ERROR("Unable to add call entry");
    }
    else
    {
      if(qm_efs_is_no_wait_rsp_enabled())
      {
        /* Send the resp to dial call here */
        memset(&dial_call_resp, 0, sizeof(dial_call_resp));
        dial_call_resp.media_id_valid = TRUE;
        dial_call_resp.media_id = cm_call_id;
        dial_call_resp.call_id_valid = TRUE;
        (void)qmi_voice_call_list_get_conn_idx_from_call_id(cm_call_id,&dial_call_resp.call_id);
        /* Remove the cmd from the list and add new cmd entry to handle the CM callback. */
        qmi_voice_cm_if_response_success(params_ptr->header.handle,params_ptr->header.cmd,&dial_call_resp,sizeof(dial_call_resp),TRUE);

        /* Add entry to Cmd List with call_id as handle */
        status = qmi_voice_cmd_list_new( params_ptr->header.cmd, cm_call_id, 
                                QMI_VOICE_CMD_AWAITING_CALLBACK, QMI_VOICE_CM_IF_EVT_NONE, 
                                params_ptr->header.handle, NULL, 0, as_id);
        if (  status == E_NO_MEMORY ) 
        {
          QM_MSG_ERROR("Out of cmd list buffer ");
        }
      }
      else
      {
        qmi_voice_cmd_list_update_sub_id(params_ptr->header.handle,cm_call_id);
        /* Send the CC_IN_PROG indication  */
        qmi_voice_call_list_report_all_call_status_changed(as_id);
      }
    }
        
  }
} /* qmi_voice_cm_if_dial_call() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_ANSWER_CALL()

  DESCRIPTION
    Invoke CM API to answer a call.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_answer_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
) 
{
  cm_ans_params_s_type *ans_params_ptr;
  qmi_voice_call_list_public_type *call_info_ptr;
  _ref_cnt_info_t *file_attrib;
  uint16           ref_str_len=0;
  cm_end_params_s_type end_params;
  boolean is_call_accepted = TRUE;
  voice_answer_call_req_msg_v02 *answer_call = &(params_ptr->data.answer_call);
  int file_attributes_len;

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/


  memset( &end_params, 0, sizeof( end_params ) );

  ans_params_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*ans_params_ptr));

  if(NULL == ans_params_ptr)
  {
	  qmi_voice_mem_fatal();
    return;
  }

  call_info_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*call_info_ptr));

  if(NULL == call_info_ptr)
  {
	  qmi_voice_mem_fatal();
    return;
  }  

  memset(ans_params_ptr, 0, sizeof(*ans_params_ptr));
  memset(call_info_ptr, 0, sizeof(*call_info_ptr));

  QM_MSG_MED_3("qmi_voice_cm_if_answer_call() conn id:%d, ans_params_ptr : %x, call_info_ptr : %x", 
  	                  answer_call->call_id,ans_params_ptr,call_info_ptr );

  if ( qmi_voice_call_list_query_by_conn_index( answer_call->call_id, call_info_ptr ) != E_SUCCESS ) 
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    if(NULL != ans_params_ptr)
    {
      QMI_VOICE_CM_IF_MEM_FREE(ans_params_ptr);
    }
    if(NULL != call_info_ptr)
    {
      QMI_VOICE_CM_IF_MEM_FREE(call_info_ptr);
    }

    return;
  }

  /* check if call state is incoming */
  if ( (call_info_ptr->state != QMI_VOICE_CALL_LIST_STATE_INCOMING) && (call_info_ptr->state != QMI_VOICE_CALL_LIST_STATE_WAITING) )
  {
    qmi_voice_cm_if_response_error(  params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INCOMPATIBLE_STATE, FALSE, FALSE );
  }
  else
  {
    /* Add entry to ReqList */
    if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, QMI_VOICE_CMD_AWAITING_CALLBACK,  
                            QMI_VOICE_CM_IF_EVT_NONE, call_info_ptr->call_id, NULL, 0, params_ptr->header.as_id) != E_SUCCESS ) 
    {
      /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INTERNAL, FALSE, FALSE );
    }
    else
    {
      /* Command CM to answer incoming voice call */

      if ( QMI_VOICE_CM_IF_SYS_MODE_IS_1XEVDO(call_info_ptr->call_mode) )
      {
        ans_params_ptr->info_type = CM_CALL_MODE_INFO_CDMA;
        ans_params_ptr->ans_params.cdma_ans.call_type = CM_CALL_TYPE_VOICE;
        {
          char details[80];
          (void)QMI_VOICE_CM_IF_STR_PRINTF( details, sizeof( details ), "Handle %lu, call id %d, info type %d, call type %d", 
                         params_ptr->header.handle, call_info_ptr->call_id, ans_params_ptr->info_type,
                         ans_params_ptr->ans_params.cdma_ans.call_type );
          QM_MSG_MED_1("Answer call: %s",details);
        }
      }
      else if ( QMI_VOICE_CM_IF_SYS_MODE_IS_GWL( call_info_ptr->call_mode ) || 
                QMI_VOICE_CM_IF_SYS_MODE_IS_WLAN( call_info_ptr->call_mode ) 
                #ifdef FEATURE_TDSCDMA
                || QMI_VOICE_CM_IF_SYS_MODE_IS_TDS( call_info_ptr->call_mode )
                #endif /*FEATURE_TDSCDMA*/ 
              )
      {
        if ( (answer_call->reject_call_valid) && (answer_call->reject_call == 1))
        {
          is_call_accepted = FALSE;
        }
        /* Check if the call is IP based */
        if(call_info_ptr->mode_info_type == CM_CALL_MODE_INFO_IP)
        {
          if ( answer_call->audio_attrib_valid )
          {
            ans_params_ptr->ans_params.ip_ans.call_attrib.audio_attrib = (cm_call_attrib_e_type)answer_call->audio_attrib;
          }
      
          if ( answer_call->video_attrib_valid )
          {
            ans_params_ptr->ans_params.ip_ans.call_attrib.video_attrib = (cm_call_attrib_e_type)answer_call->video_attrib;
          }

          if (( answer_call->reject_cause_valid) && (is_call_accepted == FALSE))
          {
             ans_params_ptr->ans_params.ip_ans.call_reject_reason = (cm_call_end_e_type) qmi_voice_cm_util_map_qmi_to_cm_ip_call_reject_cause((qmi_voice_cm_if_call_reject_cause_e_type)answer_call->reject_cause);
          }
          
          if ((answer_call->sip_reject_cause_valid) && (is_call_accepted == FALSE))
          {
            ans_params_ptr->ans_params.ip_ans.sip_reject_code.reject_code = answer_call->sip_reject_cause;
            ans_params_ptr->ans_params.ip_ans.sip_reject_code.is_reject_code_valid = TRUE;
          }

          file_attributes_len = strlen(answer_call->file_attributes);
          if ( answer_call->file_attributes_valid && 
               (file_attributes_len > 0))
          {
            if(file_attributes_len > QMI_VOICE_VS_FILE_ATTRIBUTES_MAX_V02)
            {
              QM_MSG_FATAL_1("Invlaid file attrib len qmi_voice_cm_if_answer_call for file_attrib = %d", file_attributes_len);
              qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_ARG_TOO_LONG, TRUE, FALSE );
              if(NULL != ans_params_ptr)
              {
                QMI_VOICE_CM_IF_MEM_FREE(ans_params_ptr);
              }
              
              if(NULL != call_info_ptr)
              {
                QMI_VOICE_CM_IF_MEM_FREE(call_info_ptr);
              }
              return;             
            }

            ref_str_len = sizeof(_ref_cnt_info_t)+file_attributes_len;

            /*Allocate memory for ref_cnt_ header, file attrib string, NULL*/
            file_attrib = (_ref_cnt_info_t *) QMI_VOICE_CM_IF_MEM_ALLOC(ref_str_len+1);
            if( NULL == file_attrib )
            {
				qmi_voice_mem_fatal();
              qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_NO_MEMORY, TRUE, FALSE );
              if(NULL != ans_params_ptr)
              {
                QMI_VOICE_CM_IF_MEM_FREE(ans_params_ptr);
              }
              
              if(NULL != call_info_ptr)
              {
                QMI_VOICE_CM_IF_MEM_FREE(call_info_ptr);
              }
              return;
            }
            memset(file_attrib, 0, (ref_str_len+1));
            /*start copying leaving space for ref_cnt_ header +1 here means shift by sizeof(_ref_cnt_info_t) since file_attrib is pointer to  _ref_cnt_info_t*/
            memscpy(file_attrib+1, sizeof(file_attrib) - 1, answer_call->file_attributes, file_attributes_len);

            QM_MSG_MED_2("Answer::File_attrib:%s,Length=%d",(char*)(file_attrib+1),file_attributes_len);

            ans_params_ptr->ans_params.ip_ans.call_attrib.ip_gen_param = file_attrib;
          }

          
          if( answer_call->pi_valid && (answer_call->pi <= IP_PRESENTATION_NUM_RESTRICTED_V02) )
          {
             ans_params_ptr->ans_params.ip_ans.pi = (cm_npi_type)answer_call->pi;
          }
          else
          {
            ans_params_ptr->ans_params.ip_ans.pi = call_info_ptr->num.pi;
          }
          
          ans_params_ptr->info_type = call_info_ptr->mode_info_type;
          ans_params_ptr->ans_params.ip_ans.accept = is_call_accepted;
          QM_MSG_MED_4("Mode info IP Answer call: pi_valid=%d, pi_value=%d, Answer=%d, PI Set=%d", 
                       answer_call->pi_valid,(cm_npi_type)answer_call->pi, ans_params_ptr->ans_params.ip_ans.pi, is_call_accepted);


          if ( answer_call->call_type_valid && 
               answer_call->call_type == CALL_TYPE_VT_V02 )
          {
            ans_params_ptr->ans_params.ip_ans.call_type = CM_CALL_TYPE_VT;
          }
          else
          {
          ans_params_ptr->ans_params.ip_ans.call_type = CM_CALL_TYPE_VOICE;
          }

          if(answer_call->codec_profile_valid)
          {
            /* copy codec profile */
            ans_params_ptr->ans_params.ip_ans.call_attrib.codec_profile = answer_call->codec_profile;
          }

          QM_MSG_MED_4("Answer call: Call id %d, infotype %d, ip accept %d, call type %d",
                       call_info_ptr->call_id, ans_params_ptr->info_type,ans_params_ptr->ans_params.ip_ans.accept,
                       ans_params_ptr->ans_params.ip_ans.call_type);
          }
        else if(call_info_ptr->mode_info_type == CM_CALL_MODE_INFO_CDMA)
        {
          //In CDMA case, there is no option to reject using answer API
          //So calling the CM end_call API to reject the call
          if ( (answer_call->reject_call_valid) && (answer_call->reject_call) )
          {
            memset( &end_params, 0, sizeof( end_params ) );
            end_params.info_type = CM_CALL_MODE_INFO_CDMA;
            end_params.call_id = call_info_ptr->call_id;

            if ( !cm_mm_call_cmd_end( qmi_voice_cm_if_callsvc_command_callback, 
                                      (void*)params_ptr->header.handle, 
                                      qmi_voice_cm_if_get_clientid(),
                                      1,
                                      &end_params ) )
            {
              QM_MSG_ERROR("Call to cm_mm_call_cmd_end failed in answer call");
              qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
            }
          }
          else
          {
            ans_params_ptr->info_type = CM_CALL_MODE_INFO_CDMA;
            ans_params_ptr->ans_params.cdma_ans.call_type = CM_CALL_TYPE_VOICE;
        }
        }
        else
        {
          ans_params_ptr->info_type = CM_CALL_MODE_INFO_GW_CS;
          ans_params_ptr->ans_params.gw_cs_ans.accept = is_call_accepted;
          ans_params_ptr->ans_params.gw_cs_ans.call_type = CM_CALL_TYPE_VOICE;
          ans_params_ptr->ans_params.gw_cs_ans.reject_cause  = (uint8) qmi_voice_cm_util_map_qmi_to_cm_call_reject_cause((qmi_voice_cm_if_call_reject_cause_e_type)params_ptr->data.answer_call.reject_cause);
          ans_params_ptr->ans_params.gw_cs_ans.reject_cause_present = !is_call_accepted; //reject_cause is present iff the call is rejected.

          QM_MSG_MED_4("Answer call:  Call id %d, infotype %d, accept %d, reject_cause:%d", call_info_ptr->call_id, ans_params_ptr->info_type, 
          ans_params_ptr->ans_params.gw_cs_ans.accept,ans_params_ptr->ans_params.gw_cs_ans.reject_cause);

        }
      }
      else
      {
        QM_MSG_ERROR_3("Invalid request in the current sys mode %d ans_params_ptr=%x call_info_ptr=%x", 
			          call_info_ptr->call_mode,ans_params_ptr,call_info_ptr );
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, TRUE, TRUE );
        if(NULL != ans_params_ptr)
        {
            QMI_VOICE_CM_IF_MEM_FREE(ans_params_ptr);
        }
      
        if(NULL != call_info_ptr)
        {
          QMI_VOICE_CM_IF_MEM_FREE(call_info_ptr);
        }
        return;
      }

      if(ans_params_ptr->ans_params.ip_ans.call_attrib.ip_gen_param)
      {
        ref_cnt_obj_init(ans_params_ptr->ans_params.ip_ans.call_attrib.ip_gen_param, qmi_voice_cm_if_ip_gen_param_destructor);
        QM_MSG_MED("Answer_call:Reference object init for file_attrib");
      }

      if ( !cm_mm_call_cmd_answer( qmi_voice_cm_if_callsvc_command_callback, 
                                   (void*)params_ptr->header.handle, 
                                   qmi_voice_cm_if_get_clientid(),
                                   call_info_ptr->call_id,
                                   ans_params_ptr ) )
      {
        QM_MSG_ERROR("Call to cm_mm_call_cmd_answer failed ");
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      }
      else
      {
        if(ans_params_ptr->ans_params.ip_ans.call_attrib.ip_gen_param)
        {
          ref_cnt_obj_release(ans_params_ptr->ans_params.ip_ans.call_attrib.ip_gen_param); //upon function return, release ref count obj
          QM_MSG_MED("Answer_call:Reference object release for file_attrib");
        }
      }

    }
  }

  if(NULL != ans_params_ptr)
  {
    QMI_VOICE_CM_IF_MEM_FREE(ans_params_ptr);
  }

  if(NULL != call_info_ptr)
  {
    QMI_VOICE_CM_IF_MEM_FREE(call_info_ptr);
  }
}/* qmi_voice_cm_if_answer_call() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SETUP_ANSWER()

  DESCRIPTION
    Invoke CM API to send setup response

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_setup_answer
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
) 
{
  cm_setup_res_params_s_type setup_res_params;
  qmi_voice_call_list_public_type *call_info;

  boolean is_call_accepted = TRUE;

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  QM_MSG_MED_1("qmi_voice_cm_if_setup_answer() conn id:%d", params_ptr->data.setup_answer.call_id);

  // Allocate memory to the call_info structure
  call_info = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(qmi_voice_call_list_public_type));
  if( NULL == call_info )
  {
	  qmi_voice_mem_fatal();
    return;
  }

  memset( call_info, 0, sizeof( qmi_voice_call_list_public_type ) );
  memset(&setup_res_params, CM_CALL_CMD_PARAM_DEFAULT_VALUE, sizeof(setup_res_params));

  if(!qm_efs_is_auto_setup_response_disabled())
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_OP_DEVICE_UNSUPPORTED, FALSE, FALSE );
    return;
  }

  /*check if call exists*/
  if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.setup_answer.call_id, call_info ) != E_SUCCESS ) 
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

  /* check if call state is setup */
  if ( call_info->state != QMI_VOICE_CALL_LIST_STATE_SETUP )
  {
    qmi_voice_cm_if_response_error(  params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INCOMPATIBLE_STATE, FALSE, FALSE );
    return;
  }

  /* copy call acceptance and reject cause if any*/
  if ((params_ptr->data.setup_answer.reject_setup_valid) && (params_ptr->data.setup_answer.reject_setup == 1))
  {
    is_call_accepted = FALSE;
    QM_MSG_MED("Call Setup is rejected by user");
  }

  if (params_ptr->data.setup_answer.reject_cause_valid)
  {
    setup_res_params.cc_cause.cause_value = qmi_voice_cm_util_map_qmi_to_cm_call_reject_cause((qmi_voice_cm_if_call_reject_cause_e_type)params_ptr->data.setup_answer.reject_cause);
    QM_MSG_MED_1("Sending reject cause as :%d", setup_res_params.cc_cause.cause_value);
  }


  if ( ( call_info->call_type == CM_CALL_TYPE_VOICE ) ||
       ( call_info->call_type == CM_CALL_TYPE_EMERGENCY ) )
  {
    /* Setup response will be sent. Add entry to ReqList */
    if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, QMI_VOICE_CMD_AWAITING_CALLBACK,  
                           QMI_VOICE_CM_IF_EVT_NONE, call_info->call_id, NULL, 0, params_ptr->header.as_id) != E_SUCCESS ) 
    {
      /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INTERNAL, FALSE, FALSE );
    }


    setup_res_params.accept = is_call_accepted;

    /* The default bearer capability to use on incoming voice calls. */
    cm_util_set_default_voice_bearer_cap_per_sub( &setup_res_params.bearer_capability_1,
      call_info->asubs_id);

    /* Based on TTY mode, iindicates whether CTM text teleophony is supported or not */
    if ( qm_nv_get( NV_TTY_I, &nv_buf, (enum qm_subs_e)call_info->asubs_id) == NV_DONE_S &&
         nv_buf.tty != QM_NV_TTY_MODE_OFF )
    { 
      setup_res_params.bearer_capability_1.ctm = CTM_SUPPORTED;
    }
    else
    {
      setup_res_params.bearer_capability_1.ctm = CTM_NOT_SUPPORTED;
    }
    QM_MSG_MED_1("Setting TTY mode in setup indication %d", nv_buf.tty);

    /* Support for ALS */
    if (CM_ALS_LINE_02 == call_info->line)
    {
      setup_res_params.bearer_capability_1.information_transfer_capability = cm_if_info.als.itc_aux_val;
    }

    QM_MSG_MED_6("setup_res_params.bearer_capability_1.present= %d, info_tf_cap= %d, ctm= %d, radio_chnl_req= %d, coding_std = %d, tf_mode = %d", setup_res_params.bearer_capability_1.present, setup_res_params.bearer_capability_1.information_transfer_capability, setup_res_params.bearer_capability_1.ctm,
		setup_res_params.bearer_capability_1.radio_channel_requirement, setup_res_params.bearer_capability_1.coding_standard, setup_res_params.bearer_capability_1.transfer_mode);
    QM_MSG_LOW_6("gsm_speech_ver_pref_0 = %d, pref_1 = %d, pref_2 = %d, pref_3 = %d, pref_4 = %d, pref_5 = %d", setup_res_params.bearer_capability_1.gsm_speech_ver_pref_0, setup_res_params.bearer_capability_1.gsm_speech_ver_pref_1, setup_res_params.bearer_capability_1.gsm_speech_ver_pref_2,
		setup_res_params.bearer_capability_1.gsm_speech_ver_pref_3, setup_res_params.bearer_capability_1.gsm_speech_ver_pref_4, setup_res_params.bearer_capability_1.gsm_speech_ver_pref_5);

    QM_MSG_LOW_4("setup_res_params.bearer_capability_1.compression = %d structure = %d duplex_mode = %d call_id = %d", setup_res_params.bearer_capability_1.compression, setup_res_params.bearer_capability_1.structure, setup_res_params.bearer_capability_1.duplex_mode,call_info->call_id);


    /* Command CM to send a setup message response */
    if(!cm_mm_call_cmd_setup_res( qmi_voice_cm_if_callsvc_command_callback, 
                                     (void*)params_ptr->header.handle, 
                                     qmi_voice_cm_if_get_clientid(),
                                     call_info->call_id, &setup_res_params ))
    {
      qmi_voice_cm_if_response_error(  params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INTERNAL, TRUE, FALSE );
    }
  }

  if(call_info!=NULL)
  {
    QMI_VOICE_CM_IF_MEM_FREE(call_info);
  }
}/* qmi_voice_cm_if_setup_answer() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_GET_CALL_INFO()

  DESCRIPTION
    Get the call information

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_get_call_info
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_call_list_public_type call_info;
  voice_get_call_info_resp_msg_v02 get_call_info_resp;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if(TRUE == qmi_voice_call_list_is_mode_updated())
  {
    QM_MSG_HIGH("Possible RAT change updated in qmi_voice_cm_if_get_call_info");
  }

  /* Get call info from the call list */
  if(qmi_voice_call_list_query_by_conn_index(params_ptr->data.get_call_info.call_id, &call_info) != E_SUCCESS)
  {
    QM_MSG_ERROR_1("Cannot find call object for the call id %d", params_ptr->data.get_call_info.call_id);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ID,FALSE,FALSE);
    return;
  }

  memset(&get_call_info_resp, 0, sizeof(get_call_info_resp));

  /* Fill the response params */
  get_call_info_resp.call_info_valid      = TRUE;
  get_call_info_resp.call_info.call_id    = call_info.conn_index;
  get_call_info_resp.call_info.call_state = (call_state_enum_v02)qmi_voice_cm_util_map_call_state(call_info.state);
  get_call_info_resp.call_info.call_type  = (call_type_enum_v02)qmi_voice_cm_util_map_cm_to_qmi_call_type(call_info.call_type, call_info.mode_info_type);
  if((get_call_info_resp.call_info.call_type == CALL_TYPE_EMERGENCY_IP_V02) && 
      (call_info.em_type == CM_CALL_EM_VT))
  {
    get_call_info_resp.call_info.call_type = CALL_TYPE_EMERGENCY_VT_V02;
    QM_MSG_HIGH("em_type = VT");
  }
  get_call_info_resp.call_info.direction  = (call_info.direction == CM_CALL_DIRECTION_MO)? CALL_DIRECTION_MO_V02 : CALL_DIRECTION_MT_V02;
  get_call_info_resp.call_info.mode       = (call_mode_enum_v02)qmi_voice_cm_util_map_sys_mode_to_call_mode(call_info.call_mode);
  /* Report Mode Unknown when in CC_IN_PROG state */
  if(get_call_info_resp.call_info.call_state == CALL_STATE_CC_IN_PROGRESS_V02)
  {
    get_call_info_resp.call_info.mode = CALL_MODE_UNKNOWN_V02;
  }

  /* VoIP changes FR 1002 */
  if( (call_info.call_mode == SYS_SYS_MODE_LTE) && (call_info.mode_info_type == CM_CALL_MODE_INFO_CDMA) )
    {
      get_call_info_resp.call_info.mode = CALL_MODE_CDMA_V02;
    }
  
  #ifdef FEATURE_TDSCDMA
  if(call_info.call_mode == SYS_SYS_MODE_TDS)
  {
    get_call_info_resp.call_info.mode = CALL_MODE_TDS_V02;
  }
  #endif /*FEATURE_TDSCDMA*/ 

  if( call_info.num.len > 0 )
  {
    get_call_info_resp.remote_party_number_valid        = TRUE;
    get_call_info_resp.remote_party_number.pi           = (pi_num_enum_v02)call_info.num.pi;
    get_call_info_resp.remote_party_number.number_len   = MIN(call_info.num.len,QMI_VOICE_NUMBER_MAX_V02);
    memscpy(get_call_info_resp.remote_party_number.number, QMI_VOICE_NUMBER_MAX_V02, call_info.num.buf, CM_MAX_NUMBER_CHARS);
    
    if(call_info.num.len > CM_MAX_CALLED_INFO_CHARS)
    {
      get_call_info_resp.sip_uri_valid = TRUE;
      memscpy(get_call_info_resp.sip_uri, QMI_VOICE_SIP_URI_MAX_V02, call_info.num.buf, CM_MAX_NUMBER_CHARS);
    }
    
    get_call_info_resp.remote_party_number_ext_valid    = TRUE;
    get_call_info_resp.remote_party_number_ext.num_si   = (voice_si_enum_v02)call_info.num.pi;
    get_call_info_resp.remote_party_number_ext.num_type = (voice_num_type_enum_v02)call_info.num.number_type;
    get_call_info_resp.remote_party_number_ext.num_plan = (voice_num_plan_enum_v02)call_info.num.number_plan;
    memscpy(get_call_info_resp.remote_party_number_ext.num, QMI_VOICE_SIP_URI_MAX_V02, call_info.num.buf, MIN(call_info.num.len, CM_MAX_NUMBER_CHARS));
  }
  if( call_info.is_srv_opt_valid )
  {
    get_call_info_resp.srv_opt_valid = TRUE;
    get_call_info_resp.srv_opt       = (srv_opt_enum_v02)call_info.srv_opt;
  }
  if( call_info.is_privacy_valid )
  {
    get_call_info_resp.voice_privacy_valid = TRUE;
    get_call_info_resp.voice_privacy       = (voice_privacy_enum_v02)call_info.privacy;
  }
  if( call_info.is_otasp_status_valid )
  {
    get_call_info_resp.otasp_status_valid = TRUE;
    get_call_info_resp.otasp_status       = (otasp_status_enum_v02)call_info.otasp_status ;
  }
  if( call_info.is_cnap_info_valid )
  {
    get_call_info_resp.remote_party_name_valid           = TRUE;
    get_call_info_resp.remote_party_name.name_pi         = (pi_name_enum_v02)call_info.cnap_info.name_presentation;
    get_call_info_resp.remote_party_name.coding_scheme   = call_info.cnap_info.coding_scheme;
    get_call_info_resp.remote_party_name.caller_name_len = call_info.cnap_info.name_len;
    memscpy(&get_call_info_resp.remote_party_name.caller_name, QMI_VOICE_CALLER_NAME_MAX_V02, &call_info.cnap_info.name, QMI_VOICE_CM_IF_MAX_ALPHA_TAG_CHARS);
  }
  if( call_info.uus_data.mt_user_data.present )
  {
    get_call_info_resp.uus_valid = TRUE;
    get_call_info_resp.uus.uus_type = (uus_type_enum_v02)call_info.uus_data.mt_user_data.user_user_type;
    get_call_info_resp.uus.uus_dcs = (uus_dcs_enum_v02)call_info.uus_data.mt_user_data.user_user_protocol_disc ;
    get_call_info_resp.uus.uus_data_len = call_info.uus_data.mt_user_data.user_user_data_length;
    memscpy(get_call_info_resp.uus.uus_data, QMI_VOICE_UUS_DATA_MAX_V02, call_info.uus_data.mt_user_data.user_user_data, MAX_USER_USER_DATA_LENGTH);
  }
  if( call_info.is_alerting_type_valid )
  {
    get_call_info_resp.alerting_type_valid = TRUE;
    get_call_info_resp.alerting_type = (alerting_type_enum_v02)call_info.alerting_type ;
  }
  if(call_info.is_alpha_valid)
  {
    //Since alpha is null terminated as received from CM, an alpha_info.len of 1 would indicate a simple null in alpha_info.buf.
    get_call_info_resp.alpha_ident_valid = TRUE;
    qmi_voice_cm_util_copy_alpha_ident_from_cm(&(get_call_info_resp.alpha_ident),&(call_info.alpha_info));
  }
  if( call_info.is_conn_num_valid )
  {
    get_call_info_resp.conn_num_info_valid    = TRUE;
    get_call_info_resp.conn_num_info.pi       = call_info.conn_num_info.pi;
    get_call_info_resp.conn_num_info.si       = call_info.conn_num_info.si;
    get_call_info_resp.conn_num_info.num_type = call_info.conn_num_info.num_type;
    get_call_info_resp.conn_num_info.num_plan = call_info.conn_num_info.num_plan;
    get_call_info_resp.conn_num_info.num_len  = call_info.conn_num_info.len;
    memscpy(&get_call_info_resp.conn_num_info.num, QMI_VOICE_CALLER_ID_MAX_V02, &call_info.conn_num_info.num, CM_MAX_NUMBER_CHARS);
  }
  if( (call_info.is_diagnostics_info_valid == TRUE) && (call_info.state == QMI_VOICE_CALL_LIST_STATE_END) )
  {
    get_call_info_resp.diagnostic_info_valid = TRUE;
    get_call_info_resp.diagnostic_info_len   = call_info.diagnostic_info.diagnostic_length;
    memscpy(get_call_info_resp.diagnostic_info, QMI_VOICE_DIAGNOSTIC_INFO_MAX_V02, call_info.diagnostic_info.diagnostics, MAX_DIAGNOSTICS_LENGTH);
  }
  if( call_info.is_alert_pattern_valid)
  {
    get_call_info_resp.alerting_pattern_valid = TRUE;
    get_call_info_resp.alerting_pattern       = (alerting_pattern_enum_v02)call_info.alert_pattern;
  }

 if(call_info.call_type == CM_CALL_TYPE_VT)
  {
    get_call_info_resp.audio_attrib_valid = TRUE;
    get_call_info_resp.audio_attrib       = (voice_call_attribute_type_mask_v02)call_info.audio_attrib;
    
    get_call_info_resp.video_attrib_valid = TRUE;
    get_call_info_resp.video_attrib       = (voice_call_attribute_type_mask_v02)call_info.video_attrib;
  }  
  
 if((call_info.is_second_alpha_valid) && (call_info.state == QMI_VOICE_CALL_LIST_STATE_DIALING))
  {
    /* Since second alpha is null terminated as received from CM, an second_alpha_info.len of 1 would indicate a simple null in second_alpha_info.buf. */
    get_call_info_resp.second_alpha_ident_valid = TRUE;
    qmi_voice_cm_util_copy_alpha_ident_from_cm(&(get_call_info_resp.second_alpha_ident),&(call_info.second_alpha_info));
    QM_MSG_HIGH_2("Recevied Second ALPHA DCS from CM = %d, Voice = %d", call_info.second_alpha_info.dcs, get_call_info_resp.second_alpha_ident.alpha_dcs);
  }

  if((call_info.call_type == CM_CALL_TYPE_VS) && (call_info.is_vs_call_variant_valid ==TRUE))
  {
    get_call_info_resp.vs_variant_valid = TRUE;
    get_call_info_resp.vs_variant       = (vs_variant_type_enum_v02)call_info.vs_call_variant;
    QM_MSG_MED_2("Call Info: vs_variant_valid=%d, vs_variant=%d", get_call_info_resp.vs_variant_valid, get_call_info_resp.vs_variant);
  }
  get_call_info_resp.is_srvcc_call_valid = call_info.is_srvcc_call_available;
  get_call_info_resp.is_srvcc_call       = call_info.is_srvcc_call;
  QM_MSG_MED_1("GET Call Info: is_srvcc_call=%d", get_call_info_resp.is_srvcc_call);

  if(call_info.is_end_reason_text_available == TRUE)
  {
    get_call_info_resp.end_reason_text_valid = TRUE;
    get_call_info_resp.end_reason_text_len = call_info.end_reason_text.end_reason_text_length;
    memscpy(&get_call_info_resp.end_reason_text, get_call_info_resp.end_reason_text_len,
            &call_info.end_reason_text.end_reason_text_buf, call_info.end_reason_text.end_reason_text_length );
    QM_MSG_MED_1("Get Call Info: End Reason Text Len %d", get_call_info_resp.end_reason_text_len);
  }  

  qmi_voice_cm_if_response_success( params_ptr->header.handle,params_ptr->header.cmd, (void *)&get_call_info_resp, sizeof(get_call_info_resp), FALSE );
} /* qmi_voice_cm_if_get_call_info */

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_validate_end_call_params

===========================================================================*/
/*!
    @brief
    Checks if the input data in END Request is valid

    @return
    retuns QMI_ERR_NONE if data is valid, granular error otherwise.
*/
/*=========================================================================*/
qmi_error_e_type qmi_voice_cm_if_validate_end_call_params
(
  voice_end_call_req_msg_v02 *in_data_ptr
)
{
  qmi_error_e_type err = QMI_ERR_NONE;

  ASSERT( in_data_ptr != NULL );

  if(in_data_ptr->end_cause_valid)
  {
    /* end cause Validation */
    if( in_data_ptr->end_cause < VOICE_REJECT_CAUSE_USER_BUSY_V02 ||
	in_data_ptr->end_cause > VOICE_REJECT_CAUSE_DEAD_BATTERY_V02 )
    {
      QM_MSG_ERROR_1("Unsupported end cause %d for END", in_data_ptr->end_cause);
      err = QMI_ERR_INVALID_ARG;
    }
  }

  return err;
}/* qmi_voice_cm_if_validate_end_call_params */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_END_CALL()

  DESCRIPTION
    Invoke CM API to end a call.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_end_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
) 
{
qmi_voice_call_list_public_type call_info;
cm_end_params_s_type end_params;
char details[80];
uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
sys_sys_mode_e_type     sys_mode = SYS_SYS_MODE_NO_SRV;
  voice_end_call_req_msg_v02* end_call = &(params_ptr->data.end_call);
qmi_error_e_type err = QMI_ERR_NONE;

/*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

/*-----------------------------------------------------------------------*/
  //QMI VOICE qmi_voice_cm_if_end_call
  /* Validate input params */
  if ( (err = qmi_voice_cm_if_validate_end_call_params(end_call)) != QMI_ERR_NONE )
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,err,FALSE,FALSE);
    return;
  }

#ifdef FEATURE_DUAL_SIM
  as_id=params_ptr->header.as_id;
#endif

  /* Lookup Call ID */
  if ( qmi_voice_call_list_query_by_conn_index( end_call->call_id, &call_info ) != E_SUCCESS ) 
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
  }
  /* The call Id is found, add entry to cmd List */
  else if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, QMI_VOICE_CMD_AWAITING_CALLBACK,  
                               QMI_VOICE_CM_IF_EVT_NONE, call_info.call_id, NULL, 0, as_id ) != E_SUCCESS ) 
  {
    /* Out of cmd list buffer */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INTERNAL, FALSE, FALSE );
  }
  else
  {
    /* Command CM to end the call */
    memset( &end_params, 0, sizeof( end_params ) );
    end_params.call_id = call_info.call_id;

    sys_mode = call_info.call_mode;
    QM_MSG_MED_1("In qmi_voice_cm_if_end_call sys_mode=%d", sys_mode);

    if ( QMI_VOICE_CM_IF_SYS_MODE_IS_1XEVDO( sys_mode))
    {
      end_params.info_type = CM_CALL_MODE_INFO_CDMA;
    }
    else if ( QMI_VOICE_CM_IF_SYS_MODE_IS_GWL(sys_mode ) 
              #ifdef FEATURE_TDSCDMA
              || QMI_VOICE_CM_IF_SYS_MODE_IS_TDS(sys_mode )
              #endif /*FEATURE_TDSCDMA*/ 
            )
    {
      if( call_info.mode_info_type == CM_CALL_MODE_INFO_IP )
      {
        end_params.info_type = CM_CALL_MODE_INFO_IP;
        if(end_call->end_cause_valid)
        {
          end_params.end_params.ip_cause.cause = (uint32) qmi_voice_cm_util_map_qmi_to_cm_ip_call_reject_cause(
                                                                 (qmi_voice_cm_if_call_reject_cause_e_type)end_call->end_cause);
          QM_MSG_HIGH_1( "cm_mm_call_cmd_end() - end_cause:%d", end_params.end_params.ip_cause.cause);

        }
      }
      else if( call_info.mode_info_type == CM_CALL_MODE_INFO_CDMA )
      {
        end_params.info_type = CM_CALL_MODE_INFO_CDMA;
      }
      else
      {
        end_params.info_type = CM_CALL_MODE_INFO_GW_CS;
      }
    }
    else
    {
      /* Short fading, use the outgoing/incoming call mode to determine the end params */
      QM_MSG_MED_1("Fading, use call mode %d!", call_info.call_mode);
      end_params.info_type = (call_info.call_mode == SYS_SYS_MODE_CDMA) ? \
                              CM_CALL_MODE_INFO_CDMA : CM_CALL_MODE_INFO_GW_CS;
    }

    (void)QMI_VOICE_CM_IF_STR_PRINTF( details, sizeof( details ), "Handle %lu, call id %d, mode info %d", 
                    params_ptr->header.handle, end_params.call_id, end_params.info_type );
    QM_MSG_MED_1( "cm_mm_call_cmd_end() - %s", details);

    if ( !cm_mm_call_cmd_end( qmi_voice_cm_if_callsvc_command_callback, 
                              (void*)params_ptr->header.handle, 
                              qmi_voice_cm_if_get_clientid(),
                              1,
                              &end_params ) )
    {
      QM_MSG_ERROR("Call to cm_mm_call_cmd_end failed ");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
    }
  }

}/* qmi_voice_cm_if_end_call() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_GET_ALL_CALL_INFO()

  DESCRIPTION
    Get the call information for all the calls

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_get_all_call_info
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cm_if_get_all_call_info_resp_s  *all_call_resp;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  all_call_resp = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(qmi_voice_cm_if_get_all_call_info_resp_s));

  if(NULL == all_call_resp)
  {
	  qmi_voice_mem_error();
    qmi_voice_cm_if_response_error(params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,TRUE);
    return;
  }

#ifdef FEATURE_DUAL_SIM
  as_id=params_ptr->header.as_id;
#endif

  qmi_voice_call_list_fill_all_call_info(&all_call_resp->info, as_id);

  all_call_resp->error = QMI_ERR_NONE;

  /* Send the response */
  qmi_voice_cm_if_response_success( params_ptr->header.handle,params_ptr->header.cmd, 
                                    (void *)all_call_resp, sizeof(qmi_voice_cm_if_get_all_call_info_resp_s), FALSE );

  QMI_VOICE_CM_IF_MEM_FREE(all_call_resp);
  
} /* qmi_voice_cm_if_get_all_call_info() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SEND_FLASH()

  DESCRIPTION
    Send Cdma flash

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_send_flash
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  voice_send_flash_req_msg_v02 *in_data_ptr;
  char *flash_ptr;
  cm_num_s_type dial_number;
  cm_call_sups_params_s_type sups_params;
  qmi_voice_call_list_public_type *call_info;
  qmi_voice_call_list_call_ids_list_type call_ids_list;
  cm_call_id_type                     call_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY; 
  cm_call_sups_type_e_type sups_cmd=CM_CALL_SUPS_TYPE_SIMPLE_FLASH;
  boolean is_emer_number = FALSE;
  cm_num_s_type calling_number;
  cm_cdma_orig_params_s_type cdma_orig_params;
  cm_orig_alpha_s_type alpha_buf;
  uint8 ecc_category=0;
  pbm_session_enum_type session_type=PBM_SESSION_LPB_1X;
  /*-- ---------------------------------------------------------------------*/
  ASSERT(params_ptr);
  in_data_ptr = &params_ptr->data.send_flash;

  ASSERT(in_data_ptr);
  /*-- ---------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  /* If the sys mode is not CDMA, send error response */
  if(!qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_CDMA | 
                                      QMI_VOICE_CM_IF_SYS_MODE_HDR), as_id ))
  {
    QM_MSG_ERROR("Invalid request in the current mode");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, FALSE, FALSE );
    return;
  }

  call_info = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*call_info));
  
  if(NULL == call_info)
  {
	  qmi_voice_mem_fatal();
    return;
  }  

  memset(call_info, 0, sizeof(*call_info));

  if( (in_data_ptr->call_id != QCRIL_QMI_VOICE_UNKNOWN_CONN_ID) &&
       (qmi_voice_call_list_query_voice_calls_by_conn_index(in_data_ptr->call_id, call_info) != E_SUCCESS))
  {
    QM_MSG_ERROR("Not a valid call, Send FLASH not allowed");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );

    if(NULL != call_info)
    {
      QMI_VOICE_CM_IF_MEM_FREE(call_info);
    }
    return;
  }

  /* Check if the call id sent is valid and active */
  memset(&call_ids_list,0,sizeof(qmi_voice_call_list_call_ids_list_type));
  memset( &dial_number, 0, sizeof( cm_num_s_type ) );
  memset( &calling_number, 0, sizeof( calling_number ) );
  memset( &cdma_orig_params, 0, sizeof( cdma_orig_params ) );

  alpha_buf.buf[0]='\0';
  alpha_buf.len = 0;
  

  if( !(in_data_ptr->flash_payload_valid) || (strlen(in_data_ptr->flash_payload) == 0) )
  {
    flash_ptr = NULL;
  }
  else
  {
    flash_ptr = ( char * ) in_data_ptr->flash_payload;
  }

  /* Flash with no info */
  if ( flash_ptr == NULL )
  {
    cm_num_init( &dial_number );
    dial_number.len = 0;
    dial_number.buf[ 0 ] = '\0';
  }
  /* Flash with info */
  else
  {
    /* Initialize dial number */
    cm_num_fill( &dial_number, ( uint8 * ) flash_ptr, strlen(in_data_ptr->flash_payload), CM_DIGIT_MODE_4BIT_DTMF );
  }

  memset( &sups_params, 0, sizeof( sups_params ) );
  memscpy( &sups_params.sups_number,sizeof(sups_params.sups_number), &dial_number, sizeof( cm_num_s_type ) );

  if( (in_data_ptr->flash_type_valid == FALSE) ||
      ((in_data_ptr->flash_type_valid == TRUE) && 
       (in_data_ptr->flash_type == QMI_VOICE_FLASH_TYPE_SIMPLE_FLASH_V02)) )
  {
    /* Check if the call id sent is valid and active */
    if(in_data_ptr->call_id == QCRIL_QMI_VOICE_UNKNOWN_CONN_ID)
    {
      qmi_voice_call_list_query_voice_call_ids_list_by_state(QMI_VOICE_CALL_LIST_STATE_ACTIVE,&call_ids_list, as_id);
      if(call_ids_list.num_of_call_ids == 0)
      {
        QM_MSG_ERROR_1("Not a valid call 1, Send FLASH not allowed call_info = %x",call_info);
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INCOMPATIBLE_STATE, FALSE, FALSE );
        if(NULL != call_info)
        {
          QMI_VOICE_CM_IF_MEM_FREE(call_info);
        }
        return;
      }
      call_id=call_ids_list.call_id[0];
    }
    else if(!(call_info->state & (QMI_VOICE_CALL_LIST_STATE_ACTIVE)))
    {
      QM_MSG_ERROR_1("Not a valid call 2, Send FLASH not allowed call_info = %x",call_info);
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      if(NULL != call_info)
      {
        QMI_VOICE_CM_IF_MEM_FREE(call_info);
      }
      return;
    }
    else
    {
      call_id = call_info->call_id;
    }
  
    QM_MSG_MED_1("Send FLASH :Call ID in Active state  is : %d",call_id);
    sups_cmd = CM_CALL_SUPS_TYPE_SIMPLE_FLASH;
    
  }
  else if((in_data_ptr->flash_type_valid == TRUE) && 
          (in_data_ptr->flash_type == QMI_VOICE_FLASH_TYPE_ACT_ANSWER_HOLD_V02))
  {
       /* Check if the call id sent is valid and active */
    if(in_data_ptr->call_id == QCRIL_QMI_VOICE_UNKNOWN_CONN_ID)
    {
      qmi_voice_call_list_query_voice_call_ids_list_by_state(QMI_VOICE_CALL_LIST_STATE_INCOMING|QMI_VOICE_CALL_LIST_STATE_WAITING,&call_ids_list, as_id);
      if(call_ids_list.num_of_call_ids == 0)
      {
        QM_MSG_ERROR_1("No valid Incoming/waiting call, Send ACT_ANSWER_HOLD not allowed. call_info : %x",call_info);
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INCOMPATIBLE_STATE, FALSE, FALSE );
        if(NULL != call_info)
        {
          QMI_VOICE_CM_IF_MEM_FREE(call_info);
        }
        return;
      }
      call_id=call_ids_list.call_id[0];
    }
    else if(!(call_info->state & (QMI_VOICE_CALL_LIST_STATE_INCOMING|QMI_VOICE_CALL_LIST_STATE_WAITING)) )
    {
      QM_MSG_ERROR_1("No valid Incoming/waiting call 1,Send ACT_ANSWER_HOLD not allowed. call_info : %x",call_info);
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      if(NULL != call_info)
      {
        QMI_VOICE_CM_IF_MEM_FREE(call_info);
      }
      return;
    }
    else
    {
      call_id = call_info->call_id;
    }
    
    QM_MSG_MED_1("Send FLASH ACT_ANSWER_HOLD :Call ID in Incoming/Waiting state  is : %d",call_id);
    sups_cmd = CM_CALL_SUPS_TYPE_ACT_ANSWER_HOLD;
    
  }
  else if((in_data_ptr->flash_type_valid == TRUE) && 
          (in_data_ptr->flash_type == QMI_VOICE_FLASH_TYPE_DEACT_ANSWER_HOLD_V02))
  {
    if(in_data_ptr->call_id == QCRIL_QMI_VOICE_UNKNOWN_CONN_ID)
    {
      /*Here Verifiying for Held+active calls as in 1X there is no way to find out the Held call*/
      qmi_voice_call_list_query_voice_call_ids_list_by_state(QMI_VOICE_CALL_LIST_STATE_ACTIVE|QMI_VOICE_CALL_LIST_STATE_HOLDING,&call_ids_list, as_id);
      if(call_ids_list.num_of_call_ids == 0)
      {
        QM_MSG_ERROR_1("No valid Held call, Send DEACT_ANSWER_HOLD not allowed. call_info = %s",call_info);
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INCOMPATIBLE_STATE, FALSE, FALSE );
        if(NULL != call_info)
        {
          QMI_VOICE_CM_IF_MEM_FREE(call_info);
        }
        return;
      }
      call_id=call_ids_list.call_id[0];
    }
    /*Here Verifiying for Held+active calls as in 1X there is no way to find out the Held call*/
    else if(!(call_info->state & (QMI_VOICE_CALL_LIST_STATE_ACTIVE|QMI_VOICE_CALL_LIST_STATE_HOLDING)) )
    {
      QM_MSG_ERROR_1("Not a valid held call, Send FLASH not allowed. call_info = %x",call_info);
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      if(NULL != call_info)
      {
        QMI_VOICE_CM_IF_MEM_FREE(call_info);
      }
      return;
    }
    else
    {
      call_id = call_info->call_id;
    }
    
    QM_MSG_MED_1("Send FLASH DEACT_ANSWER_HOLD :Call ID in Incoming/Waiting state  is : %d",call_id);
    sups_cmd = CM_CALL_SUPS_TYPE_DEACT_ANSWER_HOLD;
    
  }
  else
  {
    QM_MSG_ERROR_1("Invalid Flash type in Send Flash command. call_info = %d",call_info);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
    if(NULL != call_info)
    {
      QMI_VOICE_CM_IF_MEM_FREE(call_info);
    }
    return;
  }


  if(sups_cmd == CM_CALL_SUPS_TYPE_SIMPLE_FLASH)
  {
    if ( flash_ptr != NULL )
    {
     
       /* Initialize origination number */
      cm_num_init( &calling_number );
      calling_number.number_plan = CM_NPI_ISDN;
      QM_MSG_MED_2("Flash Number Recieved : %s, len =%d",dial_number.buf,strlen(in_data_ptr->flash_payload));
      if(as_id == QMI_VOICE_CM_IF_AS_ID_PRIMARY)
      {
        session_type = PBM_SESSION_LPB_1X;
      }
      else if(as_id == QMI_VOICE_CM_IF_AS_ID_SECONDARY)
      {
        session_type = PBM_SESSION_LPB_1X_SECONDARY;
      }
      #ifdef FEATURE_TRIPLE_SIM
      else if(as_id == QMI_VOICE_CM_IF_AS_ID_TERTIARY)
      {
        /* To be checked in after pbmlib.h checkin for TSTS */
        session_type = PBM_SESSION_LPB_1X_TERTIARY;
      }
      #endif
      else
      {
        QM_MSG_HIGH_2("Invalid asubs_id=%d so session_type to %d", as_id, (int)session_type);
      }
      is_emer_number = pbm_session_emergency_number_cat(session_type,(const byte *)dial_number.buf, strlen(in_data_ptr->flash_payload), &ecc_category);
    }

    if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, QMI_VOICE_CMD_AWAITING_CALLBACK,  
                                 QMI_VOICE_CM_IF_EVT_NONE, call_id, NULL, 0, as_id) != E_SUCCESS ) 
    {
      /* Out of cmd List buffer, send error response */
      QM_MSG_ERROR("Out of CMD List buffer ");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_NO_MEMORY, FALSE, FALSE );
      if(NULL != call_info)
      {
        QMI_VOICE_CM_IF_MEM_FREE(call_info);
      }
      return;
    }   
  }
  else
  {
    if(FALSE == qmi_voice_cm_if_is_jcdma_build())
    {
      if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, QMI_VOICE_CMD_AWAITING_CALLBACK,  
                                   QMI_VOICE_CM_IF_EVT_NONE, call_id, NULL, 0, as_id) != E_SUCCESS ) 
      {
        /* Out of cmd List buffer, send error response */
        QM_MSG_ERROR("Out of CMD List buffer ");
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_NO_MEMORY, FALSE, FALSE );
        if(NULL != call_info)
        {
          QMI_VOICE_CM_IF_MEM_FREE(call_info);
        }
        return;
      }
    }
    else
    {
      if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, QMI_VOICE_CMD_AWAITING_CALLBACK,  
                                   QMI_VOICE_CM_IF_EVT_CALL_L2ACK_CALL_HOLD, call_id, NULL, 0, as_id) != E_SUCCESS ) 
      {
        /* Out of cmd List buffer, send error response */
        QM_MSG_ERROR("Out of CMD List buffer ");
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_NO_MEMORY, FALSE, FALSE );
        if(NULL != call_info)
        {
          //Freeing memory for call_info"
          QMI_VOICE_CM_IF_MEM_FREE(call_info);
        }
        return;
      }
    }
  }
  
  sups_params.call_id = call_id;

  if ( is_emer_number == FALSE )
  {
    #ifdef FEATURE_DUAL_SIM
    QM_MSG_MED_1("Invoke cm_mm_call_cmd_sups_per_subs() call id %d",sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                               (void *) params_ptr->header.handle, 
                               qmi_voice_cm_if_get_clientid(),
                               sups_cmd,
                               &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else
    QM_MSG_MED_1("Invoke cm_mm_call_cmd_sups() call id %d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback, 
                               (void *) params_ptr->header.handle, 
                               qmi_voice_cm_if_get_clientid(),
                               sups_cmd,
                               &sups_params ) )
    #endif
    {
      QM_MSG_ERROR("Call to cm_mm_call_cmd_sups failed ");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
    }
  }
  else
  {
    cm_call_id_type          emerg_call_id;
    cm_util_default_cdma_orig_params( &cdma_orig_params );
    #ifdef FEATURE_DUAL_SIM
    QM_MSG_MED("Invoke cm_mm_call_cmd_orig_cc_per_subs() ");
    if ( !cm_mm_call_cmd_orig_cc_per_subs( qmi_voice_cm_if_callsvc_exten_command_callback,
                             (void *) params_ptr->header.handle,
                             qmi_voice_cm_if_get_clientid(),
                             CM_CALL_TYPE_EMERGENCY,
                             CM_SRV_TYPE_AUTOMATIC,
                             &calling_number,
                             &dial_number,
                             &alpha_buf,
                             &cdma_orig_params,
                             NULL,
                             NULL,
                             CM_CALL_ID_INVALID,
                             CM_ORIG_CLIENT_CATEG_USER,
                             (sys_modem_as_id_e_type)as_id, /* Subs id */
                             &emerg_call_id ))
    {
      QM_MSG_ERROR("Call to cm_mm_call_cmd_orig_cc_per_subs failed in send_flash ");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
    }
    #else
    QM_MSG_MED("Invoke cm_mm_call_cmd_orig_exten3() ");
    if ( !cm_mm_call_cmd_orig_exten3( qmi_voice_cm_if_callsvc_exten_command_callback,
                             (void *) params_ptr->header.handle,
                              qmi_voice_cm_if_get_clientid(),
                              CM_CALL_TYPE_EMERGENCY,
                              CM_SRV_TYPE_AUTOMATIC,
                              &calling_number,
                              &dial_number,
                              &alpha_buf,
                              &cdma_orig_params,
                              NULL,
                              NULL,
                              CM_CALL_ID_INVALID,
                              CM_ORIG_CLIENT_CATEG_USER,
                              &emerg_call_id ) )
    {
      QM_MSG_ERROR("Call to cm_mm_call_cmd_orig_exten3 failed in send_flash ");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
    }
    #endif/*FEATURE_DUAL_SIM*/
    else
    {
      QM_MSG_MED_1("Send Flash cmd, assigned call id = %d", emerg_call_id);
      qmi_voice_cmd_list_update_sub_id(params_ptr->header.handle,emerg_call_id);
    }
  }

if(NULL != call_info)
{
  QMI_VOICE_CM_IF_MEM_FREE(call_info);
}

} /* qmi_voice_cm_if_send_flash() */



/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SET_PREFERRED_PRIVACY()

  DESCRIPTION
    Send Cdma flash

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_set_preferred_privacy
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  voice_set_preferred_privacy_req_msg_v02 *in_data_ptr;
  nv_stat_enum_type nv_status = NV_FAIL_S;
  nv_item_type nv_item;
  qmi_voice_call_list_call_ids_list_type call_id_list;
  cm_privacy_pref_e_type privacy_pref;
  char *privacy_mode_name = NULL;
  uint8  as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/

  ASSERT(params_ptr);
  in_data_ptr = &params_ptr->data.set_pref_privacy;

  ASSERT(in_data_ptr);
  /*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif

  qmi_voice_call_list_query_voice_call_ids_list_by_state( QMI_VOICE_CALL_LIST_STATE_ACTIVE, &call_id_list, as_id );

   /* This request allowed on top of call only in CDMA
      Since we check all the stacks for the RAT, check if CDMA is present or not*/
  if(!qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_CDMA),as_id ) &&
     (call_id_list.num_of_call_ids > 0) )
  {
    QM_MSG_ERROR("Invalid request in the current mode");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, FALSE, FALSE );
    return;
  }

  /* Check if voice privacy received is valid */
  switch ( in_data_ptr->privacy_pref )
  {
    case VOICE_PRIVACY_STANDARD_V02:
    privacy_pref = CM_PRIVACY_PREF_STANDARD;
    privacy_mode_name = "Standard";
    break;

    case VOICE_PRIVACY_ENHANCED_V02:
    privacy_pref = CM_PRIVACY_PREF_ENHANCED;
    privacy_mode_name = "Enhanced";
    break;

  default:
    QM_MSG_ERROR_1("Invalid Voice Privacy Mode %d", in_data_ptr->privacy_pref);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  } /* end switch */

  nv_item.voice_priv = in_data_ptr->privacy_pref;
  nv_status = (nv_stat_enum_type) qmi_mmode_put_nv_item( NV_VOICE_PRIV_I, (nv_item_type *) &nv_item );

  if ( nv_status != NV_DONE_S )
  {
    // notify error 
    QM_MSG_ERROR_1("Write new Voice Privacy Mode (%d) to NV failed.", in_data_ptr->privacy_pref);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL, FALSE, FALSE );
  }
  else
  {
    /* Check if there is active voice call */
    if ( call_id_list.num_of_call_ids == 0 )
    {
      /* no active voice call. Send success */
      qmi_voice_cm_if_response_success( params_ptr->header.handle,params_ptr->header.cmd, NULL, 0, FALSE);
    }
    else
    {   
      /* There is an active voice call.  Command CM to change voice privacy mode */
      /* Add entry to cmd List */
      if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                              QMI_VOICE_CMD_AWAITING_CALLBACK, QMI_VOICE_CM_IF_EVT_NONE, 
                              call_id_list.call_id[ 0 ], NULL, 0, as_id ) != E_SUCCESS ) 
      {
        /* Out of cmd List buffer, send error response */
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INTERNAL, FALSE, FALSE );
        return;
      }

      QM_MSG_MED_2( "cm_mm_call_cmd_privacy_pref() - call id %d,  Privacy mode %s",call_id_list.call_id[ 0 ],privacy_mode_name );
      if ( !cm_mm_call_cmd_privacy_pref( qmi_voice_cm_if_callsvc_command_callback, 
                                   (void *) params_ptr->header.handle,  
                                   qmi_voice_cm_if_get_clientid(),
                                   call_id_list.call_id[ 0 ],
                                   privacy_pref ))
      {
        QM_MSG_ERROR("Call to cm_mm_call_cmd_privacy_pref failed ");
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      }
    }
  }
} /* qmi_voice_cm_if_set_preferred_privacy() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_BURST_DTMF()

  DESCRIPTION
    Send Cdma flash

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_burst_dtmf
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  voice_burst_dtmf_req_msg_v02 *in_data_ptr;
  uint8 on_length, off_length;
  qmi_voice_call_list_public_type call_info;
  qmi_voice_call_list_call_ids_list_type call_ids_list;
  cm_call_id_type                     call_id;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/
  //QMI --> CM :  qmi_voice_cm_if_burst_dtmf

  ASSERT(params_ptr);
  in_data_ptr = &params_ptr->data.burst_dtmf;

  ASSERT(in_data_ptr);
  /*-----------------------------------------------------------------------*/
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif


  /* If the sys mode is not CDMA, send error response */
  if(!qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_CDMA | 
                                      QMI_VOICE_CM_IF_SYS_MODE_HDR), as_id ))
  {
    QM_MSG_ERROR("Invalid request in the current mode");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, FALSE, FALSE );
    return;
  }
  memset(&call_ids_list,0,sizeof(qmi_voice_call_list_call_ids_list_type));
  /* Check if the call id sent is valid and active */
  if(in_data_ptr->burst_dtmf_info.call_id == QCRIL_QMI_VOICE_UNKNOWN_CONN_ID)
  {
    qmi_voice_call_list_query_voice_call_ids_list_by_state(QMI_VOICE_CALL_LIST_STATE_ACTIVE|QMI_VOICE_CALL_LIST_STATE_ALERTING,&call_ids_list,params_ptr->header.as_id);
    if(call_ids_list.num_of_call_ids == 0)
    {
      QM_MSG_ERROR("No valid active or alerting call, BURST DTMF not allowed");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INCOMPATIBLE_STATE, FALSE, FALSE );
      return;
    }
    call_id=call_ids_list.call_id[0];
  }
  else if((qmi_voice_call_list_query_voice_calls_by_conn_index(in_data_ptr->burst_dtmf_info.call_id, &call_info) != E_SUCCESS) ||
      !(call_info.state & (QMI_VOICE_CALL_LIST_STATE_ACTIVE|QMI_VOICE_CALL_LIST_STATE_ALERTING)) )
  {
    QM_MSG_ERROR("Not a valid active or alerting call, BURST DTMF not allowed");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }
  else
  {
    call_id = call_info.call_id;
  }
  QM_MSG_MED_2("%s %d", "Burst DTMF :Call ID in Active/Alerting state  is : ",call_id);

  if(in_data_ptr->dtmf_lengths_valid)
  {
    on_length = in_data_ptr->dtmf_lengths.dtmf_onlength;
    off_length = in_data_ptr->dtmf_lengths.dtmf_offlength;
  }
  else
  {
    /* default values */
    on_length = 3; /* 250 ms recommended pulse width */
    off_length = 1; /* 100 ms recommended minimum interdigit interval */
  }

  /* Add entry to cmd List */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, QMI_VOICE_CMD_AWAITING_CALLBACK,  
                               QMI_VOICE_CM_IF_EVT_NONE, call_id, NULL, 0, as_id) != E_SUCCESS ) 
  {
    /* Out of cmd List buffer, send error response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INTERNAL, FALSE, FALSE );
    return;
  }

  /* Command CM to send burst DTMF */
  QM_MSG_MED_4( "cm_mm_inband_cmd_burst_dtmf(): call id %d, dtmf string %s, on length %d, off length %d", call_id,(char*)in_data_ptr->burst_dtmf_info.digit_buffer, on_length, off_length );

  if ( !cm_mm_inband_cmd_burst_dtmf( qmi_voice_cm_if_inbandsvc_command_callback,
                                     (void *) params_ptr->header.handle, 
                                     qmi_voice_cm_if_get_clientid(),
                                     call_id,
                                     on_length, off_length,
                                     in_data_ptr->burst_dtmf_info.digit_buffer_len,
                                     (uint8 const *)in_data_ptr->burst_dtmf_info.digit_buffer ) )
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
  }
} /* qmi_voice_cm_if_burst_dtmf() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_START_CONT_DTMF()

  DESCRIPTION
    Send START CONT DTMF. The dtmf requests for GW/IP are allowed in Active/Alerting cases. 


  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_start_cont_dtmf
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_call_list_public_type call_info;
  voice_start_cont_dtmf_req_msg_v02 *in_data_ptr;
  qmi_voice_call_list_call_ids_list_type call_ids_list;
  cm_call_id_type                     call_id;
  qmi_voice_cm_if_evt_e_type	      pending_event=QMI_VOICE_CM_IF_EVT_NONE;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  /*-----------------------------------------------------------------------*/
  //QMI --> CM :  qmi_voice_cm_if_start_cont_dtmf

  ASSERT(params_ptr);
  in_data_ptr = &params_ptr->data.start_cont_dtmf;

  ASSERT(in_data_ptr);
/*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif

  /* Check if the call id sent is valid and active */
  memset(&call_ids_list,0,sizeof(qmi_voice_call_list_call_ids_list_type));

  if(in_data_ptr->cont_dtmf_info.call_id == QCRIL_QMI_VOICE_UNKNOWN_CONN_ID)
  {
    qmi_voice_call_list_query_voice_call_ids_list_by_state(QMI_VOICE_CALL_LIST_STATE_ACTIVE|QMI_VOICE_CALL_LIST_STATE_ALERTING,&call_ids_list, params_ptr->header.as_id);
    if(call_ids_list.num_of_call_ids == 0)
    {
      QM_MSG_ERROR("No valid active or alerting call, START CONT DTMF not allowed");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INCOMPATIBLE_STATE, FALSE, FALSE );
      return;
    }
    call_id=call_ids_list.call_id[0];
  }
  else if((qmi_voice_call_list_query_voice_calls_by_conn_index(in_data_ptr->cont_dtmf_info.call_id, &call_info) != E_SUCCESS) ||
      !(call_info.state & (QMI_VOICE_CALL_LIST_STATE_ACTIVE|QMI_VOICE_CALL_LIST_STATE_ALERTING)) )
  {
    QM_MSG_ERROR("Not a valid active or alerting call, START CONT DTMF not allowed");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }
  else
  {
    call_id = call_info.call_id;
  }
  QM_MSG_MED_2("%s %d", "START DTMF :Call ID in Active/Alerting state  is : ",call_id);

  if( qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_1XEVDO), as_id ))
  {
    pending_event = QMI_VOICE_CM_IF_EVT_NONE;
  }
  else if(qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_GWL|
                                          QMI_VOICE_CM_IF_SYS_MODE_WLAN), as_id ))
  {
    pending_event = QMI_VOICE_CM_IF_EVT_INBAND_REV_START_CONT_DTMF_CONF;
  } 

  /* Add entry to cmd List */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, QMI_VOICE_CMD_AWAITING_CALLBACK,  
                               pending_event, call_id, NULL, 0, as_id) != E_SUCCESS ) 
  {
    /* Out of cmd List buffer, send error response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INTERNAL, FALSE, FALSE );
    return;
  }

  QM_MSG_MED_2("cm_mm_inband_cmd_start_cont_dtmf() -  call id %d, digit %d", call_id, in_data_ptr->cont_dtmf_info.digit);
  if ( !cm_mm_inband_cmd_start_cont_dtmf( qmi_voice_cm_if_inbandsvc_command_callback,
                                          (void *) params_ptr->header.handle, 
                                          qmi_voice_cm_if_get_clientid(),
                                          call_id,
                                          in_data_ptr->cont_dtmf_info.digit ) )
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
  }

}/* qmi_voice_cm_if_start_cont_dtmf */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_STOP_CONT_DTMF()

  DESCRIPTION
    Send STOP CONT DTMF. The dtmf requests for GW/IP are allowed in Active/Alerting cases.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_stop_cont_dtmf
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_call_list_public_type call_info;
  voice_stop_cont_dtmf_req_msg_v02 *in_data_ptr;
  qmi_voice_call_list_call_ids_list_type call_ids_list;
  cm_call_id_type                     call_id;
  qmi_voice_cm_if_evt_e_type	      pending_event=QMI_VOICE_CM_IF_EVT_NONE;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  /*-----------------------------------------------------------------------*/
  //qmi_voice_cm_if_stop_cont_dtmf

  ASSERT(params_ptr);
  in_data_ptr = &params_ptr->data.stop_cont_dtmf;

  ASSERT(in_data_ptr);
/*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif

  memset(&call_ids_list,0,sizeof(qmi_voice_call_list_call_ids_list_type));
  /* Check if the call id sent is valid and active */
  if(in_data_ptr->call_id == QCRIL_QMI_VOICE_UNKNOWN_CONN_ID)
  {
    qmi_voice_call_list_query_voice_call_ids_list_by_state(QMI_VOICE_CALL_LIST_STATE_ACTIVE|QMI_VOICE_CALL_LIST_STATE_ALERTING,&call_ids_list, params_ptr->header.as_id);
    if(call_ids_list.num_of_call_ids == 0)
    {
      QM_MSG_ERROR("No valid active or alerting call, STOP CONT DTMF not allowed");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INCOMPATIBLE_STATE, FALSE, FALSE );
      return;
    }
    call_id=call_ids_list.call_id[0];
  }
  else if((qmi_voice_call_list_query_voice_calls_by_conn_index(in_data_ptr->call_id, &call_info) != E_SUCCESS) ||
      !(call_info.state & (QMI_VOICE_CALL_LIST_STATE_ACTIVE|QMI_VOICE_CALL_LIST_STATE_ALERTING)) )
  {
    QM_MSG_ERROR("Not a valid active or alerting call, STOP CONT DTMF not allowed");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }
  else
  {
    call_id = call_info.call_id;
  }
  QM_MSG_MED_2("%s %d", "STOP DTMF :Call ID in Active/Alerting state  is : ",call_id);

  if( qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_CDMA | 
                                      QMI_VOICE_CM_IF_SYS_MODE_HDR), as_id ))
  {
    pending_event = QMI_VOICE_CM_IF_EVT_NONE;
  }
  else if(qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_GWL | 
                                          QMI_VOICE_CM_IF_SYS_MODE_WLAN), as_id ) )
  {
    pending_event = QMI_VOICE_CM_IF_EVT_INBAND_REV_STOP_CONT_DTMF_CONF;
  } 

  /* Add entry to cmd List */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, QMI_VOICE_CMD_AWAITING_CALLBACK,  
                               pending_event, call_id, NULL, 0,  as_id) != E_SUCCESS ) 
  {
    /* Out of cmd List buffer, send error response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INTERNAL, FALSE, FALSE );
    return;
  }

  QM_MSG_MED_1("cm_mm_inband_cmd_stop_cont_dtmf() -  call id %d", call_id);
  if ( !cm_mm_inband_cmd_stop_cont_dtmf( qmi_voice_cm_if_inbandsvc_command_callback,
                                          (void *) params_ptr->header.handle, 
                                          qmi_voice_cm_if_get_clientid(),
                                          call_id,
                                          351 /* 351 ms is the 1xcp recommended minimum interdigit interval */ ) )
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
  }
}/* qmi_voice_cm_if_stop_cont_dtmf */


/*===========================================================================
                    SUPS WRAPPER FUNCTIONS
===========================================================================*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_GET_CLIR()

  DESCRIPTION
    Invoke CM API to Query  Clir service status.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_get_clir
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{

  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type ss_data;
  boolean cm_result;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  //qmi_voice_cm_if_sups_get_clir()

  /* If the sys mode is not GW, send error response */
  memset(&ss_data, 0, sizeof(ss_data));
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  cmd_info_ptr->ss_code = (uint8) qmi_voice_cm_sups_clir;
  cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

  ss_data.interr.ss_code = cmd_info_ptr->ss_code;
  ss_data.interr.ss_ref = cmd_info_ptr->ss_ref;
  ss_data.interr.basic_service.present = FALSE;

  /* fill the sups params required for sups string construction */
  memset(&ss_params, 0, sizeof(ss_params));
  ss_params.mode = QMI_VOICE_CM_SUPS_MODE_QUERY;
  ss_params.code = (qmi_voice_cm_sups_operation_code_e_type) ss_data.interr.ss_code;
  
  /* Invoke Sups String Construction. The string should be sent to modem 
  for any call control */
  if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
  {
    QM_MSG_ERROR("Sups string construction failed ");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }

  QM_MSG_LOW_1( "Sups String constructed is %s", ss_buf);
  memset(&dialed_digits,0,sizeof(dialed_digits));

  dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
  dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
              QMI_VOICE_CMD_AWAITING_CALLBACK,
              QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
              cmd_info_ptr->ss_ref, &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
  {
    /* Out of cmd list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }

#ifdef FEATURE_DUAL_SIM
  QM_MSG_MED_1("cm_sups_cmd_interrogate_cc_exten_per_subs()with ss_ref %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                                &ss_data.interr,
                                                                &dialed_digits,
                                                                CM_ORIG_CLIENT_CATEG_USER,
                                                                FALSE,
                                                               (sys_modem_as_id_e_type)as_id );

#else
  QM_MSG_MED_1("cm_sups_cmd_interrogate_exten()with ss_ref %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                                &ss_data.interr,
                                                                &dialed_digits,
                                                                CM_ORIG_CLIENT_CATEG_USER);
#endif /*FEATURE_DUAL_SIM*/

  if(!cm_result)
  {
    /* send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
  }
} /* qmi_voice_cm_if_sups_get_clir() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_GET_CALL_FORWARDING()

  DESCRIPTION
    Invoke CM API to Query Call forward service status.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_get_call_forwarding
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type ss_data;
  boolean cm_result;
  voice_get_call_forwarding_req_msg_v02 *info = (voice_get_call_forwarding_req_msg_v02 *)(&params_ptr->data.get_call_fwd);
  int reason;
  char *cf_reason_name; /* Name for call forward reason given */
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  uint32 srv_class = 0;
  cm_num_s_type            dialed_digits;
  qmi_voice_cm_util_ss_info_s util_sys_info;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  memset(ss_buf, 0, sizeof(ss_buf) );
  /* If the sys mode is not GW, send error response */
  memset(&util_sys_info, 0, sizeof( util_sys_info));
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/
  
  memset(&ss_data, 0, sizeof(ss_data) );
  memset(&u_info, 0, sizeof(u_info));
  reason = info->reason;

  if(info->service_class_valid || info->service_class_ext_valid)
  {
    if(info->service_class_ext_valid)
    {
      srv_class = info->service_class_ext;
    }
    else
    {
      srv_class = info->service_class;
    }
    if ( !qmi_voice_cm_sups_service_class_is_valid(srv_class) )
    {
      QM_MSG_ERROR_1("received invalid Service class %d", srv_class);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  
  if(!((reason >= (int)QMI_VOICE_CM_SUPS_CCFC_REASON_UNCOND) && (reason < (int)QMI_VOICE_CM_SUPS_CCFC_REASON_MAX)))
  {
    QM_MSG_ERROR_1("received invalid reason %d", reason);
    qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
  }
  else
  {
    cmd_info_ptr->ss_code = qmi_voice_cm_sups_get_cfw_ss_code(reason, &cf_reason_name);
    cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

    ss_data.interr.ss_code = cmd_info_ptr->ss_code;
    ss_data.interr.ss_ref = cmd_info_ptr->ss_ref;
    qmi_voice_cm_sups_set_bsg_info(srv_class, &ss_data.interr.basic_service);

    if (ss_data.interr.basic_service.present)
    {
      if(info->service_class_ext_valid)
      {
        cmd_info_ptr->ss_service_class = info->service_class_ext;
      }
      else
      {
        cmd_info_ptr->ss_service_class = info->service_class;
      }
    }
    /* fill the sups params required for sups string construction */
    memset(&ss_params, 0, sizeof(ss_params));
    ss_params.mode = QMI_VOICE_CM_SUPS_MODE_QUERY;
    ss_params.code = (qmi_voice_cm_sups_operation_code_e_type) cmd_info_ptr->ss_code;
    ss_params.service_class = (qmi_voice_cm_sups_class_e_type)srv_class;
    ss_params.cmd.reg.number = NULL;
    ss_params.cmd.reg.nr_timer = 0;
    /* Invoke Sups String Construction. The string should be sent to modem for any call control*/
    if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
    {
      QM_MSG_ERROR("Sups string construction failed ");
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INTERNAL, FALSE, FALSE );
      return;
    }
    QM_MSG_LOW_1( "Sups String constructed is %s", ss_buf);

    memset(&dialed_digits,0,sizeof(dialed_digits));
    dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
    dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;

    if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                            QMI_VOICE_CMD_AWAITING_CALLBACK,
                            QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
                            cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
    {
     /* Out of cmd List buffer, send error response */
     qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INTERNAL, FALSE, FALSE );
     return;
    }

#ifdef FEATURE_DUAL_SIM
    QM_MSG_MED_2( "cm_sups_cmd_interrogate_cc_exten_per_subs()with ss_ref %d reason %s", cmd_info_ptr->ss_ref,cf_reason_name);
    cm_result = cm_sups_cmd_interrogate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.interr,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER,
                                                                  FALSE,
                                                                 (sys_modem_as_id_e_type)as_id );
    
#else
    QM_MSG_MED_2( "cm_sups_cmd_interrogate_exten()with ss_ref %d reason %s", cmd_info_ptr->ss_ref,cf_reason_name);
    cm_result = cm_sups_cmd_interrogate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.interr,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
#endif /*FEATURE_DUAL_SIM*/
    if(!cm_result)
    {
      /* send QMI_ERR_INTERNAL response */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
    }
  }

}/* qmi_voice_cm_if_sups_get_call_forwarding() */

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_get_clip()

  DESCRIPTION
    Invoke CM API to get the clip information.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_get_clip
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type ss_data;
  boolean cm_result;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* If the sys mode is not GW, send error response */
  memset(&ss_data, 0, sizeof(ss_data));
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  cmd_info_ptr->ss_code = (int) qmi_voice_cm_sups_clip;
  cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

  ss_data.interr.ss_code = cmd_info_ptr->ss_code;
  ss_data.interr.ss_ref = cmd_info_ptr->ss_ref;
  ss_data.interr.basic_service.present = FALSE;

  /* fill the sups params required for sups string construction */
  memset(&ss_params, 0, sizeof(ss_params));
  ss_params.mode = QMI_VOICE_CM_SUPS_MODE_QUERY;
  ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)ss_data.interr.ss_code;
  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
  check in future. The string should be sent to modem for any call control */
  if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
  {
    QM_MSG_HIGH("Sups string construction failed");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }
  else
  {
    QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
    memset(&dialed_digits,0,sizeof(dialed_digits));
    dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
    dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
  }

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                   QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                   QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
                                                   cmd_info_ptr->ss_ref, &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  
#ifdef FEATURE_DUAL_SIM
  QM_MSG_MED_1("cm_sups_cmd_interrogate_cc_exten_per_subs(), Clip ss_ref = %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                                &ss_data.interr,
                                                                &dialed_digits,
                                                                CM_ORIG_CLIENT_CATEG_USER,
                                                                FALSE,
                                                               (sys_modem_as_id_e_type)as_id );

#else
  QM_MSG_MED_1("cm_sups_cmd_interrogate_exten(), Clip ss_ref = %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.interr,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
#endif /*FEATURE_DUAL_SIM*/  
  if(!cm_result)
  {  
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
    return;
  }
  
} /* qmi_voice_cm_if_sups_get_clip */

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_get_colp()

  DESCRIPTION
    Invoke CM API to get the colp information.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_get_colp
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type ss_data;
  boolean cm_result;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  //qmi_voice_cm_if_sups_get_colp()

  /* If the sys mode is not GW, send error response */
  memset(&ss_data, 0, sizeof(ss_data));
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  cmd_info_ptr->ss_code = (int) qmi_voice_cm_sups_colp;
  cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

  ss_data.interr.ss_code = cmd_info_ptr->ss_code;
  ss_data.interr.ss_ref = cmd_info_ptr->ss_ref;
  ss_data.interr.basic_service.present = FALSE;

  /* fill the sups params required for sups string construction */
  memset(&ss_params, 0, sizeof(ss_params));
  ss_params.mode = QMI_VOICE_CM_SUPS_MODE_QUERY;
  ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)ss_data.interr.ss_code;
  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
  check in future. The string should be sent to modem for any call control */
  if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
  {
    QM_MSG_HIGH("Sups string construction failed");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }
  else
  {
    QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
    memset(&dialed_digits,0,sizeof(dialed_digits));
    dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
    dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
  }

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                   QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                   QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
                                                   cmd_info_ptr->ss_ref, &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
  {
    //Could not add entry to the list 
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  
#ifdef FEATURE_DUAL_SIM
  QM_MSG_MED_1("cm_sups_cmd_interrogate_cc_exten_per_subs(), Colp ss_ref = %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                                &ss_data.interr,
                                                                &dialed_digits,
                                                                CM_ORIG_CLIENT_CATEG_USER,
                                                                FALSE,
                                                               (sys_modem_as_id_e_type)as_id );

#else
  QM_MSG_MED_1("cm_sups_cmd_interrogate_exten(), Colp ss_ref = %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.interr,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
#endif /*FEATURE_DUAL_SIM*/  
  if(!cm_result)
  {  
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
    return;
  }
  
} /* qmi_voice_cm_if_sups_get_colp */

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_get_call_waiting()

  DESCRIPTION
    Invoke CM API to get the status of call waiting information for a particular service class
    If no service class is mentioned will return the status of Default service classes that N/W supports.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_get_call_waiting
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type ss_data;
  boolean cm_result;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  voice_get_call_waiting_req_msg_v02 *in_data_ptr;
  uint32 service_class=0;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );
  in_data_ptr = (voice_get_call_waiting_req_msg_v02 *)(&params_ptr->data);
  ASSERT( in_data_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* If the sys mode is not GW, send error response */
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  memset(&ss_data, 0, sizeof(ss_data) );
  if(in_data_ptr ->service_class_valid || in_data_ptr->service_class_ext_valid )
  {
    if(in_data_ptr->service_class_ext_valid)
    {
      service_class = in_data_ptr->service_class_ext;
    }
    else
    {
      service_class = in_data_ptr->service_class;
    }
    QM_MSG_MED_1("Received service class = %d", service_class);
    if ( !qmi_voice_cm_sups_service_class_is_valid(service_class) )
    {
      QM_MSG_ERROR_1("received invalid Service class %d", service_class);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  cmd_info_ptr->ss_code = (uint8)qmi_voice_cm_sups_cw;
  cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();
  cmd_info_ptr->ss_service_class = service_class;

  ss_data.interr.ss_code = cmd_info_ptr->ss_code;
  ss_data.interr.ss_ref = cmd_info_ptr->ss_ref;
  qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.interr.basic_service);

  /* fill the sups params required for sups string construction */
  memset(&ss_params, 0, sizeof(ss_params));
  ss_params.mode = QMI_VOICE_CM_SUPS_MODE_QUERY;
  ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)cmd_info_ptr->ss_code;
  ss_params.service_class = (qmi_voice_cm_sups_class_e_type)service_class;
  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
  check in future. The string should be sent to modem for call control */
  if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
  {
    QM_MSG_HIGH("Sups string construction failed");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }
  else
  {
    QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
    memset(&dialed_digits,0,sizeof(dialed_digits));
    dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
    dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
  }

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                   QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                   QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
                                                   cmd_info_ptr->ss_ref, &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }

#ifdef FEATURE_DUAL_SIM
  QM_MSG_MED_1("cm_sups_cmd_interrogate_cc_exten_per_subs(), Call waiting ss_ref = %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                                &ss_data.interr,
                                                                &dialed_digits,
                                                                CM_ORIG_CLIENT_CATEG_USER,
                                                                FALSE,
                                                               (sys_modem_as_id_e_type)as_id );

#else
  QM_MSG_MED_1("cm_sups_cmd_interrogate_exten(), Call waiting ss_ref = %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.interr,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);

#endif/*FEATURE_DUAL_SIM*/  
  if(!cm_result)
  {  
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
    return;
  }

}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_get_call_barring()

  DESCRIPTION
    Invoke CM API to get the status of call barring information for a particular reason in specified service class
    If no service class is mentioned will return the status of Default service classes that N/W supports.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_get_call_barring
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type ss_data;
  boolean cm_result;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  voice_get_call_barring_req_msg_v02 *in_data_ptr;
  uint32 service_class=0;
  int facility=0;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );
  in_data_ptr = (voice_get_call_barring_req_msg_v02 *)(&params_ptr->data);
  /*-----------------------------------------------------------------------*/
  
  /* If the sys mode is not GW, send error response */
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  memset(&ss_data, 0, sizeof(ss_data) );
  facility = in_data_ptr->reason;
  if(in_data_ptr ->service_class_valid || in_data_ptr->service_class_ext_valid)
  {
    if(in_data_ptr->service_class_ext_valid)
    {
      service_class = in_data_ptr->service_class_ext;
    }
    else
    {
      service_class = in_data_ptr->service_class;
    }
    QM_MSG_MED_2("GET Call Barring info Recieved:  svc_class = %d, (hex = %#x) ", service_class, service_class);

    if ( !qmi_voice_cm_sups_service_class_is_valid(service_class) )
    {
      QM_MSG_ERROR_1("received invalid Service class %d", service_class);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }

  QM_MSG_MED_1("GET Call Barring information Recieved:  reason = %d", facility);

  if(!qmi_voice_cm_sups_query_facility_lock_is_valid(facility, service_class))
  {
    QM_MSG_ERROR("Received invalid parameters in get_call_barring");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
    return;
  }

  cmd_info_ptr->ss_code = (uint8)qmi_voice_cm_sups_get_cb_ss_code(facility);
  cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();
  cmd_info_ptr->ss_service_class = service_class;
  cmd_info_ptr->ss_pwd.present = FALSE;

  QM_MSG_MED_3("Stage1 :  SS_CODE=%d,SS_REF=%d,SrvCls=%d", cmd_info_ptr->ss_code, cmd_info_ptr->ss_ref, cmd_info_ptr->ss_service_class);

  ss_data.interr.ss_code = cmd_info_ptr->ss_code;
  ss_data.interr.ss_ref = cmd_info_ptr->ss_ref;
  qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.interr.basic_service);

  /* fill the sups params required for sups string construction */
  memset(&ss_params, 0, sizeof(ss_params));
  ss_params.mode = QMI_VOICE_CM_SUPS_MODE_QUERY;
  ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)cmd_info_ptr->ss_code;
  ss_params.service_class = (qmi_voice_cm_sups_class_e_type)service_class;
  ss_params.cmd.passwd.old_passwd = NULL;

  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
  check in future. The string should be sent to modem for call control */
  if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
  {
    QM_MSG_HIGH("Sups string construction failed");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }
  else
  {
    QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
    memset(&dialed_digits,0,sizeof(dialed_digits));
    dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
    dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
  }

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                 QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                 QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
                                                 cmd_info_ptr->ss_ref, &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }

#ifdef FEATURE_DUAL_SIM
  QM_MSG_MED_1("cm_sups_cmd_interrogate_cc_exten_per_subs(), Get Call Barring ss_ref = %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                                &ss_data.interr,
                                                                &dialed_digits,
                                                                CM_ORIG_CLIENT_CATEG_USER,
                                                                FALSE,
                                                               (sys_modem_as_id_e_type)as_id );
          
#else
  QM_MSG_MED_1("cm_sups_cmd_interrogate_exten(), Get Call Barring ss_ref = %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.interr,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
#endif /*FEATURE_DUAL_SIM*/
  if(!cm_result)
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
    return;
  }

}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_change_call_barring_pwd()

  DESCRIPTION
    Invoke CM API to get the status of call barring information for a particular reason in specified service class
    If no service class is mentioned will return the status of Default service classes that N/W supports.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_change_call_barring_pwd
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean  cm_result = TRUE;
//  const char **in_data = (const char **)params_ptr->data;
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type ss_data;
  int facility=0;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  char old_pwd[QMI_VOICE_CM_IF_MAX_PWD_LEN+1];
  char new_pwd[QMI_VOICE_CM_IF_MAX_PWD_LEN+1];
  char new_pwd_again[QMI_VOICE_CM_IF_MAX_PWD_LEN+1];
  qmi_voice_cm_sups_params_s_type ss_params;
  voice_set_call_barring_password_req_msg_v02 *in_data_ptr;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
    /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );
  in_data_ptr = &params_ptr->data.set_call_barring;
  /*-----------------------------------------------------------------------*/

  
  /* If the sys mode is not GW, send error response */
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  memset(&ss_data, 0, sizeof(ss_data) );
  memset(old_pwd, 0, sizeof(old_pwd));
  memset(new_pwd, 0, sizeof(new_pwd));
  memset(new_pwd_again, 0, sizeof(new_pwd_again));

  facility = (int)in_data_ptr->call_barring_password_info.reason;
  memscpy(old_pwd, sizeof(old_pwd), in_data_ptr->call_barring_password_info.old_password, QMI_VOICE_CM_IF_MAX_PWD_LEN);
  memscpy(new_pwd, sizeof(new_pwd), in_data_ptr->call_barring_password_info.new_password, QMI_VOICE_CM_IF_MAX_PWD_LEN);
  memscpy(new_pwd_again, sizeof(new_pwd_again), in_data_ptr->call_barring_password_info.new_password_again, QMI_VOICE_CM_IF_MAX_PWD_LEN);
  QM_MSG_MED_4("SET Call Barring info Rxd:  reason = %d old pwd = %s new_pwd  = %s, new_pwd_again = %s", facility, old_pwd, new_pwd, new_pwd_again);  

  if(strncmp(new_pwd,new_pwd_again,QMI_VOICE_CM_IF_MAX_PWD_LEN) != 0)
  {
    QM_MSG_ERROR("Received invalid password parameters in set_call_barring");
  }

  if(!qmi_voice_cm_sups_cmd_change_cb_pwd_is_valid(facility, old_pwd, new_pwd))
  {
    QM_MSG_ERROR("Received invalid parameters in set_call_barring");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
    return;
  }
  else
  {
    cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();;
    cmd_info_ptr->ss_code = (uint8) qmi_voice_cm_sups_get_cb_ss_code(facility);

    memset(&ss_data,0,sizeof(ss_data));

    ss_data.password.ss_code.present = TRUE;
    ss_data.password.ss_code.ss_code = cmd_info_ptr->ss_code;
    ss_data.password.ss_ref = cmd_info_ptr->ss_ref;
    /* filling the password information as accepted by call manager (CM)*/

    ss_data.password.ss_old_pwd.present = TRUE;
    memscpy(ss_data.password.ss_old_pwd.ss_password,
           sizeof(ss_data.password.ss_old_pwd.ss_password),
           old_pwd,
           QMI_VOICE_CM_IF_MAX_PWD_LEN);

    ss_data.password.ss_new_pwd.present = TRUE;
    memscpy(ss_data.password.ss_new_pwd.ss_password,
           sizeof(ss_data.password.ss_new_pwd.ss_password),
           new_pwd,
           QMI_VOICE_CM_IF_MAX_PWD_LEN);

    ss_data.password.ss_new_pwd_again.present = TRUE;
    memscpy(ss_data.password.ss_new_pwd_again.ss_password,
           sizeof(ss_data.password.ss_new_pwd_again.ss_password),
           new_pwd_again,
           QMI_VOICE_CM_IF_MAX_PWD_LEN);

    /* fill the sups params required for sups string construction */
    memset(&ss_params, 0, sizeof(ss_params));
    ss_params.mode = QMI_VOICE_CM_SUPS_MODE_REG_PASSWD;
    ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)cmd_info_ptr->ss_code;
    ss_params.cmd.passwd.old_passwd = old_pwd;
    ss_params.cmd.passwd.new_passwd = new_pwd;
    ss_params.cmd.passwd.new_passwd_again = new_pwd_again;

    if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
    {
      QM_MSG_HIGH("Sups string construction failed");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;
    }
    else
    {
      QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
      memset(&dialed_digits,0,sizeof(dialed_digits));
      dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
      dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
    }

    if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                   QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                   QMI_VOICE_CM_IF_EVT_SUPS_REG_PASSWORD_CONF,
                                                   cmd_info_ptr->ss_ref, &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
    {
      /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
      return;
    }


#ifdef FEATURE_DUAL_SIM
    QM_MSG_MED_1("cm_sups_cmd_reg_password_cc_exten_per_subs(), Set Call Barring ss_ref = %d", cmd_info_ptr->ss_ref);
    cm_result = cm_sups_cmd_reg_password_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.password,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER,
                                                                  FALSE,
                                                                 (sys_modem_as_id_e_type)as_id );

#else
    QM_MSG_MED_1("cm_sups_cmd_reg_password_exten(), Set Call Barring ss_ref = %d", cmd_info_ptr->ss_ref);
    cm_result = cm_sups_cmd_reg_password_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                   (void*)params_ptr->header.handle,
                                                                   qmi_voice_cm_if_get_clientid(),
                                                                    &ss_data.password,
                                                                    &dialed_digits,
                                                                    CM_ORIG_CLIENT_CATEG_USER);
#endif /*FEATURE_DUAL_SIM*/

    if(!cm_result)
    {
      /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
      return;
    }
  }

}


/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_manage_calls()

  DESCRIPTION
    Invoke CM API to get the status of call barring information for a particular reason in specified service class
    If no service class is mentioned will return the status of Default service classes that N/W supports.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_manage_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cm_if_manage_calls_s *in_data_ptr;
  qmi_voice_cmd_list_public_type cmd_info;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;  
  sys_sys_mode_e_type     sys_mode = SYS_SYS_MODE_NO_SRV;
  boolean                 is_local_request = FALSE; /* Request applicable for both GW, CDMA cases for local operation */

    /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );
  in_data_ptr = (qmi_voice_cm_if_manage_calls_s *)(&params_ptr->data);
  /*-----------------------------------------------------------------------*/

  //Inside qmi_voice_cm_if_sups_manage_calls()

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/
  

  switch(in_data_ptr->sups_type)
  {
    case QMI_VOICE_CM_IF_MNG_CALLS_LOCAL_HOLD:
    case QMI_VOICE_CM_IF_MNG_CALLS_LOCAL_UNHOLD:
      is_local_request = TRUE;
    break;
    default:
      break;
  }

  if(qmi_voice_call_list_query_sys_mode_from_call_list(&sys_mode,as_id) == E_SUCCESS)
  {
    QM_MSG_MED_1("Inside qmi_voice_cm_if_sups_manage_calls(), found a call list entry sys mode=%d:", sys_mode);
  }  

  /* case where MNG_CALLS_REQ is in progress . Allow the local requests as they don't disturb with the network operation.*/
  memset(&cmd_info, 0, sizeof(cmd_info));
  if ((!is_local_request) && 
      (qmi_voice_cmd_list_query_by_event_all_states( QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF, &cmd_info, as_id ) == E_SUCCESS))
  {
     QM_MSG_HIGH_2("One instance of MNG_CALLS_REQ Already exists cmd=%d, sups_type=%d", cmd_info.cmd, cmd_info.sub_id);
     qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INCOMPATIBLE_STATE,FALSE,FALSE);
     return;
  }

  switch(in_data_ptr->sups_type)
  {
    case QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_HELD_OR_WAITING:
      qmi_voice_cm_if_sups_release_held_or_waiting(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING :
      qmi_voice_cm_if_sups_release_active_accept_held_or_waiting(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_CALLS_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD :
      qmi_voice_cm_if_sups_hold_active_accept_waiting_or_held(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_CALLS_HOLD_ALL_EXCEPT_SPECIFIED_CALL :
      qmi_voice_cm_if_sups_hold_all_except_specified_call(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_CALLS_MAKE_CONFERENCE_CALL :
      qmi_voice_cm_if_sups_make_conference_call(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_CALLS_EXPLICIT_CALL_TRANSFER :
      qmi_voice_cm_if_sups_explicit_call_transfer(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_CALLS_END_ALL_CALLS :
      qmi_voice_cm_if_sups_end_all_calls(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_SPECIFIED_CALL:
      qmi_voice_cm_if_sups_release_specified_call(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_CALLS_LOCAL_HOLD:
    case QMI_VOICE_CM_IF_MNG_CALLS_LOCAL_UNHOLD:
      qmi_voice_cm_if_sups_local_hold_unhold(params_ptr);
      break;
    default :
      QM_MSG_MED_1("Invalid sups_type in qmi_voice_cm_if_sups_manage_calls():  %d", in_data_ptr->sups_type);
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
      return;
  }
}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_release_held_or_waiting()

  DESCRIPTION
    Hang up waiting or held (like AT+CHLD=0)

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_release_held_or_waiting
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_call_list_call_ids_list_type call_ids_list_held;
  qmi_voice_call_list_call_ids_list_type call_ids_list_waiting;
  qmi_voice_call_list_call_ids_list_type call_ids_list_incoming;  
  cm_call_sups_params_s_type sups_params;
  cm_end_params_s_type end_params;
  qmi_voice_cm_if_evt_e_type pending_event_id;
  IxErrnoType err_no;
  uint32 sub_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  sys_sys_mode_e_type     sys_mode = SYS_SYS_MODE_NO_SRV;
  sys_sys_mode_e_type     waiting_call_mode = SYS_SYS_MODE_NO_SRV;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //Inside qmi_voice_cm_if_sups_release_held_or_waiting();
  memset( &sups_params, 0, sizeof( sups_params ) );
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif

  if(qmi_voice_call_list_query_sys_mode_from_call_list(&sys_mode, as_id) == E_SUCCESS)
  {
    QM_MSG_MED_1("Inside qmi_voice_cm_if_sups_release_held_or_waiting(), found a call list entry sys mode=%d:", sys_mode);
  }
 
 /*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  if (params_ptr->data.manage_calls_info.reject_cause_valid)
  {
    if(qmi_voice_call_list_query_call_mode_by_state(&waiting_call_mode, as_id,QMI_VOICE_CALL_LIST_STATE_WAITING) == E_SUCCESS)
    {
      if((waiting_call_mode  == SYS_SYS_MODE_LTE) || (waiting_call_mode  == SYS_SYS_MODE_WLAN))
      {
        sups_params.ip_params.rej_cause = (cm_call_end_e_type) qmi_voice_cm_util_map_qmi_to_cm_ip_call_reject_cause((qmi_voice_cm_if_call_reject_cause_e_type)params_ptr->data.manage_calls_info.reject_cause);
      }
      else
      {
        sups_params.cause  = (uint8) qmi_voice_cm_util_map_qmi_to_cm_call_reject_cause((qmi_voice_cm_if_call_reject_cause_e_type)params_ptr->data.manage_calls_info.reject_cause);
      }
    }
  }

  if (( params_ptr->data.manage_calls_info.sip_reject_code_valid))
  {
    sups_params.ip_params.sip_reject_code.reject_code = params_ptr->data.manage_calls_info.sip_reject_code;
    sups_params.ip_params.sip_reject_code.is_reject_code_valid = TRUE;
  }

  /* Determine the CM API need to be called */
  if (QMI_VOICE_CM_IF_SYS_MODE_IS_1XEVDO( sys_mode ))
  {
    pending_event_id = QMI_VOICE_CM_IF_EVT_CALL_END;
  }
    else
    {
      pending_event_id = QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF;
    }

  /* Lookup Call ID for Waiting Call */
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_WAITING,
                                                     &call_ids_list_waiting, as_id );

  /* No Waiting Call ID is found */
  if ( call_ids_list_waiting.num_of_call_ids == 0 )
  {
    /* Lookup Call ID for Incoming Call */
    qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_INCOMING,
                                                        &call_ids_list_incoming, as_id );  
    if ( call_ids_list_incoming.num_of_call_ids == 0 )
    {
      /* Lookup Call ID for Hold Call */
      qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_HOLDING,
                                                         &call_ids_list_held, as_id );
      /* No Hold Call ID is found */
      if ( call_ids_list_held.num_of_call_ids == 0 )
      {
        QM_MSG_MED("Rejecting QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_HELD_OR_WAITING command");
        QM_MSG_MED("as there are no waiting and hold calls");
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
        return;
      }
      else
      {
        sups_params.call_id = call_ids_list_held.call_id[0];
      }
    }
    else
    {
      sups_params.call_id = call_ids_list_incoming.call_id[0];
      /* If MT call already answered, just end call without udub */
      if ( call_ids_list_incoming.answered[ 0 ] )
      {
        pending_event_id = QMI_VOICE_CM_IF_EVT_CALL_END;
      }
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_waiting.call_id[0];
    /* If MT call already answered, just end call without udub */
    if ( call_ids_list_waiting.answered[ 0 ] )
    {
      pending_event_id = QMI_VOICE_CM_IF_EVT_CALL_END;
    }
  }

  /* Add entry to ReqList */
  err_no = qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                           QMI_VOICE_CMD_AWAITING_CALLBACK, pending_event_id, 
                                                           sub_id, NULL, 0, as_id) ;
  if ( err_no != E_SUCCESS )
  {
    //Could not add entry to the list
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else if ( pending_event_id == QMI_VOICE_CM_IF_EVT_CALL_END )
  {
    /* Command CM to end the call */
    memset( &end_params, 0, sizeof( end_params ) );
    end_params.call_id = sups_params.call_id;
    end_params.info_type = CM_CALL_MODE_INFO_CDMA;

    QM_MSG_MED_2("cm_mm_call_cmd_end(), release_held_or_waiting callid = %d mode_info=%d", end_params.call_id, end_params.info_type);

    if ( !cm_mm_call_cmd_end( qmi_voice_cm_if_callsvc_command_callback, 
                                                  (void*)params_ptr->header.handle,
                                                  qmi_voice_cm_if_get_clientid(),
                                                  1,
                                                  &end_params ) )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      QM_MSG_HIGH("CM returned error for cm_mm_call_cmd_end() in release_held_or_waiting ");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }  
  else 
  {
    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_1("cm_mm_call_cmd_sups_per_subs(), release_held_or_waiting callid = %d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_HELD_CALL_REL_OR_UDUB,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else    
    QM_MSG_HIGH_1("cm_mm_call_cmd_sups(), release_held_or_waiting callid = %d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback,
                               (void*)params_ptr->header.handle,
                               qmi_voice_cm_if_get_clientid(),
                               CM_CALL_SUPS_TYPE_HELD_CALL_REL_OR_UDUB,
                               &sups_params ) )
    #endif /*FEATURE_DUAL_SIM*/                                                    
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }
}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_release_active_accept_held_or_waiting()

  DESCRIPTION
    Used to disconnect all the active calls so that the held or the waiting
    calls can be retrieved or answered

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_release_active_accept_held_or_waiting
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_call_list_call_ids_list_type call_ids_list_active;
  qmi_voice_call_list_call_ids_list_type call_ids_list_held;
  qmi_voice_call_list_call_ids_list_type call_ids_list_waiting;
  qmi_voice_call_list_call_ids_list_type call_ids_list_incoming;  
  qmi_voice_call_list_call_ids_list_type call_ids_list_all;  
  qmi_voice_call_list_call_ids_list_type call_ids_list_disconnecting;
  qmi_voice_cm_if_evt_e_type  pending_event_id = QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF;
  cm_call_sups_params_s_type sups_params;
  cm_end_params_s_type end_params;
  IxErrnoType err_no = E_SUCCESS;
  uint32 sub_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;  
  qmi_voice_call_list_public_type call_info;
  sys_sys_mode_e_type     sys_mode = SYS_SYS_MODE_NO_SRV;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  //Inside qmi_voice_cm_if_sups_release_active_accept_held_or_waiting()

  memset( &sups_params, 0, sizeof( sups_params ) );
  memset( &call_ids_list_all, 0, sizeof( call_ids_list_all ) );
  memset( &call_ids_list_disconnecting, 0, sizeof( call_ids_list_disconnecting ) );
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/

  if(qmi_voice_call_list_query_sys_mode_from_call_list(&sys_mode, as_id) == E_SUCCESS)
  {
    QM_MSG_MED_1("Inside qmi_voice_cm_if_sups_release_active_accept_held_or_waiting(), found a call list entry sys mode=%d:", sys_mode);
  }  
/*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  /* Lookup Call ID for Waiting Call */
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_WAITING,
                                                     &call_ids_list_waiting, as_id );
  /* Lookup Call ID for Hold Call */
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_HOLDING,
                                                     &call_ids_list_held, as_id );

  if(call_ids_list_waiting.num_of_call_ids != 0)
  {
    cm_if_info.mng_calls_info.waiting_call_id = call_ids_list_waiting.call_id[0];
    cm_if_info.mng_calls_info.waiting_call_id_valid = TRUE;
  }
  else if (call_ids_list_held.num_of_call_ids == 1)
  {
    cm_if_info.mng_calls_info.held_call_id = call_ids_list_held.call_id[0];
    cm_if_info.mng_calls_info.held_call_id_valid = TRUE;
  }
  else
  {
    QM_MSG_MED_2("Number of Waiting calls = %d, Number of Held calls = %d", call_ids_list_waiting.num_of_call_ids, call_ids_list_held.num_of_call_ids);
  }

  /* Lookup Call ID for Active Calls*/
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_ACTIVE,
                                                     &call_ids_list_active, as_id );

  /* No Active Call ID is found */
  if ( call_ids_list_active.num_of_call_ids == 0 )
  {
    /* No Hold Call ID is found */
    if ( call_ids_list_held.num_of_call_ids == 0 )
    {
        /* No Waiting Call ID is found */
      if ( call_ids_list_waiting.num_of_call_ids == 0 )
      {
        /* Lookup Call ID for Incoming Call */
        qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_INCOMING,
                                                           &call_ids_list_incoming, as_id);
          /* No Incoming Call ID is found */
        if ( call_ids_list_incoming.num_of_call_ids == 0 )
        {      
          /* Lookup Call ID for Disconnecting Call */
	  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_DISCONNECTING,
                                                                    &call_ids_list_disconnecting, as_id);
          if(call_ids_list_disconnecting.num_of_call_ids == 0)
	  {  	    
  	    QM_MSG_MED("Rejecting RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING request");
   	    QM_MSG_MED("as there are no active, hold waiting, incoming and disconnecting calls");
            qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
            return;
        }
        else
        {
            sups_params.call_id = call_ids_list_disconnecting.call_id[0];
          }         
        }
        else
        {
          sups_params.call_id = call_ids_list_incoming.call_id[0];
        }
      }
      else
      {
        sups_params.call_id = call_ids_list_waiting.call_id[0];
      }
    }
    else
    {
     sups_params.call_id = call_ids_list_held.call_id[0];
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_active.call_id[0];
  }

  /* when a waiting MT call needs to be upgraded/downgraded, 
        call ID of waiting call, expected call type and audio/video attributes are passed*/
  if(params_ptr->data.manage_calls_info.call_id_valid)
  {
    if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.manage_calls_info.call_id, &call_info ) != E_SUCCESS ) 
    {
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      return;
    }
    sups_params.ip_params.waiting_call_id = call_info.call_id;
    sups_params.ip_params.is_call_modified = TRUE;
    QM_MSG_HIGH("is_call_modified is set ");
  }
  if(params_ptr->data.manage_calls_info.call_type_valid)
  {
     sups_params.ip_params.call_type_mod_to = qmi_voice_cm_util_map_qmi_to_cm_call_type((qmi_voice_cm_if_call_type_e_type)params_ptr->data.manage_calls_info.call_type);
  }
  if(params_ptr->data.manage_calls_info.is_audio_attrib_valid)
  {
    sups_params.ip_params.audio_attrib = (cm_call_attrib_e_type)params_ptr->data.manage_calls_info.audio_attrib;
  }
  if(params_ptr->data.manage_calls_info.is_video_attrib_valid)
  {
    sups_params.ip_params.video_attrib = (cm_call_attrib_e_type)params_ptr->data.manage_calls_info.video_attrib;
  }


  /* Add entry to ReqList */

  if ( QMI_VOICE_CM_IF_SYS_MODE_IS_1XEVDO( sys_mode ) )
  {
    err_no = qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                           QMI_VOICE_CMD_AWAITING_CALLBACK, QMI_VOICE_CM_IF_EVT_CALL_END, 
                                                           sub_id, NULL, 0, as_id) ;
  }
  else
  {
    qmi_voice_call_list_query_voice_call_ids_list_by_state((uint32) (QMI_VOICE_CALL_LIST_STATE_ACTIVE |
                                                                     QMI_VOICE_CALL_LIST_STATE_HOLDING |
                                                                     QMI_VOICE_CALL_LIST_STATE_DIALING |
                                                                     QMI_VOICE_CALL_LIST_STATE_ALERTING |
                                                                     QMI_VOICE_CALL_LIST_STATE_INCOMING |
                                                                     QMI_VOICE_CALL_LIST_STATE_WAITING),
                                                                     &call_ids_list_all, as_id);

    /* for handling the special case in GW where there is only one call which is active call,
        in this case we are supposed to end the call using cm_mm_call_cmd_end() 
        instead of cm_mm_call_cmd_sups()  hence queueing QCRIL_EVT_CM_CALL_END
        instead of QCRIL_EVT_CM_CALL_MNG_CALLS_CONF */
        
    QM_MSG_MED_2( "no of active calls = %lu & no of calls = %lu", call_ids_list_active.num_of_call_ids,
                                                                                         call_ids_list_all.num_of_call_ids);

    if((call_ids_list_all.num_of_call_ids== 1) && (call_ids_list_active.num_of_call_ids ==1))
    {
      err_no = qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                                               QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                               QMI_VOICE_CM_IF_EVT_CALL_END, sub_id, NULL, 0, as_id ) ;
    }
    else
    {
      if(call_ids_list_disconnecting.num_of_call_ids != 0)
      {
        //When the only call is in diconnecting state, instead of relying
        //on conf of MNG_CALL, we return the conf of END_EVENT 
        pending_event_id = QMI_VOICE_CM_IF_EVT_CALL_END;
      }
      err_no = qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                              QMI_VOICE_CMD_AWAITING_CALLBACK,
                                              pending_event_id, sub_id, NULL, 0, as_id ) ;
    }
  }

  if ( err_no != E_SUCCESS )
  {
    //Could not add entry to the list
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {
    if ( QMI_VOICE_CM_IF_SYS_MODE_IS_1XEVDO( sys_mode ) )
    {
      /* Command CM to end the call */
      memset( &end_params, 0, sizeof( end_params ) );
      end_params.call_id = sups_params.call_id;
      end_params.info_type = CM_CALL_MODE_INFO_CDMA;
      QM_MSG_MED_2("cm_mm_call_cmd_end(), 1X:release_active_accept_held_or_waiting callid = %d, mode info= %d", end_params.call_id, end_params.info_type);

      if ( !cm_mm_call_cmd_end( qmi_voice_cm_if_callsvc_command_callback, 
                                                     (void*)params_ptr->header.handle, 
                                                     qmi_voice_cm_if_get_clientid(),
                                                     1,
                                                     &end_params ) )
      {
        /* In case of ARM9 reset, the command callback will never be executed. So, need to
           delete the entry from the ReqList, and call OnRequestComplete() */
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
        return;
      }
    }
    else
    {
      /* Use cm_mm_call_cmd_end() for emergency call */
      if ( ( call_ids_list_all.num_of_call_ids == 1 ) && ( call_ids_list_active.num_of_call_ids ==1 ) ) 
      {
        memset( &end_params, 0, sizeof( end_params ) );
        end_params.call_id = sups_params.call_id;

        if ( qmi_voice_call_list_query_by_call_id( end_params.call_id, &call_info ) != E_SUCCESS ) 
        {
          //QM_MSG_HIGH_1("Invalid call id %d found", end_params.call_id);
          qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, TRUE, TRUE );
          return;
        }
        if( call_info.mode_info_type == CM_CALL_MODE_INFO_IP )
        {
          end_params.info_type = CM_CALL_MODE_INFO_IP;
        }
        else
        {
          end_params.info_type = CM_CALL_MODE_INFO_GW_CS;
        }

        QM_MSG_HIGH_2("cm_mm_call_cmd_end(), GW : release_active_accept_held_or_waiting (emergency/single call) callid = %d, mode info= %d", end_params.call_id, end_params.info_type);

        if ( !cm_mm_call_cmd_end( qmi_voice_cm_if_callsvc_command_callback, 
                                                       (void*)params_ptr->header.handle, 
                                                       qmi_voice_cm_if_get_clientid(),
                                                       1,
                                                       &end_params ) )
        {
          /* In case of ARM9 reset, the command callback will never be executed. So, need to
             delete the entry from the ReqList, and call OnRequestComplete() */
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
        return;
        }
      }
      else
      {

        #ifdef FEATURE_DUAL_SIM
        QM_MSG_HIGH_1("cm_mm_call_cmd_sups_per_subs(): in release_active_accept_held_or_waiting:(multiple calls): CM_CALL_SUPS_TYPE_ACTIVE_CALL_REL CallId =%d", sups_params.call_id);
        if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                            (void *) params_ptr->header.handle, 
                                             qmi_voice_cm_if_get_clientid(),
                                             CM_CALL_SUPS_TYPE_ACTIVE_CALL_REL,
                                             &sups_params,(sys_modem_as_id_e_type)as_id ) )
        #else
        QM_MSG_HIGH_1("cm_mm_call_cmd_sups(): in release_active_accept_held_or_waiting:(multiple calls): CM_CALL_SUPS_TYPE_ACTIVE_CALL_REL CallId =%d", sups_params.call_id);
        if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback,
                                                       (void*)params_ptr->header.handle, 
                                                       qmi_voice_cm_if_get_clientid(),
                                                       CM_CALL_SUPS_TYPE_ACTIVE_CALL_REL,
                                                       &sups_params ) )
        #endif/*FEATURE_DUAL_SIM*/
        {
          /* In case of ARM9 reset, the command callback will never be executed. So, need to
             delete the entry from the ReqList, and call OnRequestComplete() */
          qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
          return;
        }
      }
    }
  }

}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_hold_active_accept_waiting_or_held()

  DESCRIPTION
    Used to put the active calls on hold so that the waiting or the held call
    can be answered or retrieved
    and incase of single call to toggle between active and hold states

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_hold_active_accept_waiting_or_held
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_call_list_call_ids_list_type call_ids_list_active;
  qmi_voice_call_list_call_ids_list_type call_ids_list_held;
  qmi_voice_call_list_call_ids_list_type call_ids_list_waiting;
  qmi_voice_call_list_call_ids_list_type call_ids_list_incoming;
  cm_call_sups_params_s_type sups_params;
  uint32 sub_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY; 
  qmi_voice_call_list_public_type call_info;

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  //Inside qmi_voice_cm_if_sups_hold_active_accept_waiting_or_held():
  memset( &sups_params, 0, sizeof( sups_params ) );
  memset( &call_info, 0, sizeof( call_info ) );

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif

/*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  /* Lookup Call ID for Active Calls*/
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_ACTIVE,
                                                     &call_ids_list_active, as_id );

  /* No Active Call ID is found */
  if ( call_ids_list_active.num_of_call_ids == 0 )
  {
    /* Lookup Call ID for Hold Call */
    qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_HOLDING,
                                                       &call_ids_list_held, as_id );
    /* No Held Call ID is found */
    if ( call_ids_list_held.num_of_call_ids == 0 )
    {
      /* Lookup Call ID for Waiting Call */
      qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_WAITING,
                                                         &call_ids_list_waiting, as_id );
        /* No Waiting Call ID is found */
      if ( call_ids_list_waiting.num_of_call_ids == 0 )
      {
        /* Lookup Call ID for Incoming Call */
        qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_INCOMING,
                                                           &call_ids_list_incoming, as_id );
          /* No Incoming Call ID is found */
        if ( call_ids_list_incoming.num_of_call_ids == 0 )
        {
          QM_MSG_MED("Rejecting qmi_voice_cm_if_sups_hold_active_accept_waiting_or_held request");
          QM_MSG_MED("as there are no active, hold and waiting, incoming calls");
          qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
          return;
        }
        else
        {
          sups_params.call_id = call_ids_list_incoming.call_id[0];
        }
      }
      else
      {
        sups_params.call_id = call_ids_list_waiting.call_id[0];
      }
    }
    else
    {
     sups_params.call_id = call_ids_list_held.call_id[0];
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_active.call_id[0];
  }

  /* when a waiting MT call needs to be upgraded/downgraded, 
        call ID of waiting call, expected call type and audio/video attributes are passed*/
  if(params_ptr->data.manage_calls_info.call_id_valid)
  {
    if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.manage_calls_info.call_id, &call_info ) != E_SUCCESS ) 
    {
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      return;
    }
    sups_params.ip_params.waiting_call_id = call_info.call_id;
    sups_params.ip_params.is_call_modified = TRUE;
    QM_MSG_HIGH("is_call_modified is set ");
  }
  if(params_ptr->data.manage_calls_info.call_type_valid)
  {
     sups_params.ip_params.call_type_mod_to = qmi_voice_cm_util_map_qmi_to_cm_call_type((qmi_voice_cm_if_call_type_e_type)params_ptr->data.manage_calls_info.call_type);
  }
  if(params_ptr->data.manage_calls_info.is_audio_attrib_valid)
  {
    sups_params.ip_params.audio_attrib = (cm_call_attrib_e_type)params_ptr->data.manage_calls_info.audio_attrib;
  }
  if(params_ptr->data.manage_calls_info.is_video_attrib_valid)
  {
    sups_params.ip_params.video_attrib = (cm_call_attrib_e_type)params_ptr->data.manage_calls_info.video_attrib;
  }

    /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                   QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                   QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF, sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_1("cm_mm_call_cmd_sups_per_subs(): hold_active_accept_waiting_or_held, CM_CALL_SUPS_TYPE_HOLD_CALL CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_HOLD_CALL,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else
    QM_MSG_HIGH_1("cm_mm_call_cmd_sups(): hold_active_accept_waiting_or_held, CM_CALL_SUPS_TYPE_HOLD_CALL CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups(qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_HOLD_CALL,
                                                    &sups_params ) )
    #endif/*FEATURE_DUAL_SIM*/
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }

}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_hold_all_except_specified_call()

  DESCRIPTION
    Used to put the active calls on hold so that the waiting or the held call
    can be answered or retrieved
    and incase of single call to toggle between active and hold states

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_hold_all_except_specified_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  IxErrnoType err_no;
  qmi_voice_call_list_public_type info;
  cm_call_sups_params_s_type sups_params;
  uint32 sub_id;
  uint8 conn_idx = 0;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;  

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  //Inside qmi_voice_cm_if_sups_hold_all_except_specified_call():");
  /*sub_id contains sups_type */

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/

  sub_id = params_ptr->data.manage_calls_info.sups_type;

  if(params_ptr->data.manage_calls_info.call_id_valid)
  {
    conn_idx = params_ptr->data.manage_calls_info.call_id;
  }
  else
  {
    QM_MSG_HIGH("Call id should be set for the hold_all_except_specified_call");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }

  memset( &sups_params, 0, sizeof( sups_params ) );

  /* Lookup Call ID among the Voice calls*/
  err_no = qmi_voice_call_list_query_voice_calls_by_conn_index( conn_idx, &info );

  if(err_no != E_SUCCESS)
  {
    QM_MSG_HIGH_1("Fail to find the conn id = %d in the list", conn_idx);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }

  if((info.state == QMI_VOICE_CALL_LIST_STATE_ACTIVE && info.is_multi_party == TRUE ) ||
     (info.state == QMI_VOICE_CALL_LIST_STATE_HOLDING) ||
     (info.state == QMI_VOICE_CALL_LIST_STATE_INCOMING) ||
     (info.state == QMI_VOICE_CALL_LIST_STATE_WAITING) )
  {
    sups_params.call_id = info.call_id;
  }
  else
  {
    QM_MSG_HIGH("Rejecting hold_all_except_specified_call command ");
    QM_MSG_HIGH_2("as the conn with id = %d is in invalid state = %d ", conn_idx, info.state);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }

    /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new(params_ptr->header.cmd, params_ptr->header.handle,
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,
                                                   sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_1("cm_mm_call_cmd_sups_per_subs(): hold_all_except_specified_call, CM_CALL_SUPS_TYPE_SELECT_CALL_X CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_SELECT_CALL_X,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else
    QM_MSG_HIGH_1("cm_mm_call_cmd_sups():hold_all_except_specified_call, CM_CALL_SUPS_TYPE_SELECT_CALL_X CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_SELECT_CALL_X,
                                                    &sups_params ) )
    #endif /*FEATURE_DUAL_SIM*/                                                    
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }

}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_make_conference_call()

  DESCRIPTION
    Used to start a conference call by combining the active and held calls or
    add another user to the existing conference call

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_make_conference_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_call_list_call_ids_list_type call_ids_list_active;
  qmi_voice_call_list_call_ids_list_type call_ids_list_hold;
  cm_call_sups_params_s_type sups_params;
  uint32 sub_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_make_conference_call():");
  memset( &sups_params, 0, sizeof( sups_params ) );
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif

  /*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  /* Lookup Call ID */
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_ACTIVE,
                                                     &call_ids_list_active, as_id );

  /* No Call ID is found */
  if ( call_ids_list_active.num_of_call_ids == 0 )
  {
    /* Lookup Call ID */
    qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_HOLDING,
                                                       &call_ids_list_hold, as_id );

    if ( call_ids_list_hold.num_of_call_ids == 0 )
    {
      QM_MSG_MED("Rejecting RIL_REQUEST_CONFERENCE request as there are no active and held calls");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;
    }
    else
    {
     sups_params.call_id = call_ids_list_hold.call_id[0];
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_active.call_id[0];
  }

    /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,
                                                  sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    //QM_MSG_HIGH("Could not add entry to the list ");
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_1("cm_mm_call_cmd_sups_per_subs() in make_conference_call, CM_CALL_SUPS_TYPE_MULTIPARTY_CALL CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_MULTIPARTY_CALL,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else
    QM_MSG_HIGH_1("cm_mm_call_cmd_sups() in make_conference_call, CM_CALL_SUPS_TYPE_MULTIPARTY_CALL CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_MULTIPARTY_CALL,
                                                    &sups_params ) )
    #endif /*FEATURE_DUAL_SIM*/                                                    
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }
}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_explicit_call_transfer()

  DESCRIPTION
    Used to invoke the ECT supplimentary service, which will disconnect the
    active and held/waiting calls and allow them to connect to each other.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_explicit_call_transfer
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_call_list_call_ids_list_type call_ids_list_active;
  qmi_voice_call_list_call_ids_list_type call_ids_list_alerting;
  cm_call_sups_params_s_type sups_params;
  uint32 sub_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_explicit_call_transfer():");
  memset( &sups_params, 0, sizeof( sups_params ) );

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif

  /*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  /* Lookup Call ID for Active Calls*/
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_ACTIVE,
                                                     &call_ids_list_active, as_id );

  /* No Active Call ID is found */
  if ( call_ids_list_active.num_of_call_ids == 0 )
  {
    /* Lookup Call ID for Alering Call */
    qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_ALERTING,
                                                       &call_ids_list_alerting, as_id );
    /* No Alerting Call ID is found */
    if ( call_ids_list_alerting.num_of_call_ids == 0 )
    {
      QM_MSG_MED("Rejecting explicit_call_transfer command as there are no active and alerting calls");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;
    }
    else
    {
     sups_params.call_id = call_ids_list_alerting.call_id[0];
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_active.call_id[0];
  }

    /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,
                                                  sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    //QM_MSG_HIGH("Could not add entry to the list ");
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_1("cm_mm_call_cmd_sups_per_subs() in explicit_call_transfer, CM_CALL_SUPS_TYPE_EXPLICIT_CALL_TRANSFER CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_EXPLICIT_CALL_TRANSFER,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else
    QM_MSG_HIGH_1("cm_mm_call_cmd_sups() in explicit_call_transfer, CM_CALL_SUPS_TYPE_EXPLICIT_CALL_TRANSFER CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_EXPLICIT_CALL_TRANSFER,
                                                    &sups_params ) )
    #endif /*FEATURE_DUAL_SIM*/                                                    
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }


}


/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_explicit_call_transfer_voip()

  DESCRIPTION
    Used to invoke the ECT supplimentary service, which will disconnect the
    active and held/waiting calls and allow them to connect to each other.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_explicit_call_transfer_voip
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  cm_call_ip_expicit_call_transfer_e_type ect_type;
  cm_call_sups_params_s_type sups_params;
  uint32 sub_id;
  qmi_voice_call_list_public_type call_info;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  memset( &sups_params, 0, sizeof( sups_params ) );

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  QM_MSG_MED_1("Request with asubs_id=%d", as_id);
#endif

  /*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  ect_type = (cm_call_ip_expicit_call_transfer_e_type)params_ptr->data.manage_calls_info.ect_type;

  QM_MSG_HIGH_1("ECT Type received = %d", ect_type);
  
  if (ect_type == CM_EXPLICIT_CALL_TRANSFER_TYPE_CONSULTATIVE)
    {
    sups_params.ip_ect_params.ect_type = ect_type;
      /* Lookup Call ID */
      if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.manage_calls_info.call_id, &call_info ) != E_SUCCESS ) 
      {
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, TRUE, FALSE );
      }
      sups_params.call_id = call_info.call_id;

      if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.manage_calls_info.transfer_target_call_id, &call_info ) != E_SUCCESS ) 
      {
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, TRUE, FALSE );
      }
      sups_params.ip_ect_params.transfer_target_call_id = call_info.call_id;
    }
  
  else if (ect_type == CM_EXPLICIT_CALL_TRANSFER_TYPE_BLIND || ect_type == CM_EXPLICIT_CALL_TRANSFER_TYPE_ASSURED)
    {
    sups_params.ip_ect_params.ect_type = ect_type;
      /* Lookup Call ID */
      if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.manage_calls_info.call_id, &call_info ) != E_SUCCESS ) 
      {
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, TRUE, FALSE );
      }
      sups_params.call_id = call_info.call_id;

    if(params_ptr->data.manage_calls_info.is_sip_uri_valid == FALSE)
      {
        QM_MSG_MED("Missing SIP URI to do an explicit call transfer");
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
        return;
      }
      else
      {
        QM_MSG_MED_2("SIP URI length=%d, num=%s", params_ptr->data.manage_calls_info.sip_uri_len,params_ptr->data.manage_calls_info.sip_uri);
        cm_num_fill( &sups_params.ip_ect_params.transfer_target_call_num, ( uint8 * )params_ptr->data.manage_calls_info.sip_uri, 
                      params_ptr->data.manage_calls_info.sip_uri_len, CM_DIGIT_MODE_8BIT_ASCII );
        sups_params.sups_number.number_plan = CM_NPI_ISDN;
      }
    }
  
  else
    {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
    }

  
    /* Add entry to CMD List */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,
                                                  sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  
  else
  {

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_MED_1("cm_mm_call_cmd_sups_per_subs(), CM_CALL_SUPS_TYPE_EXPLICIT_CALL_TRANSFER_VOIP CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_IP_EXPLICIT_CALL_TRANSFER,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else
    QM_MSG_MED_1("cm_mm_call_cmd_sups(), CM_CALL_SUPS_TYPE_EXPLICIT_CALL_TRANSFER_VOIP CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_IP_EXPLICIT_CALL_TRANSFER,
                                                    &sups_params ) )
    #endif /*FEATURE_DUAL_SIM*/                                                    
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      QM_MSG_HIGH("CM returned error for cm_mm_call_cmd_sups() in explicit_call_transfer_voip");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }


}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_release_specified_call()

  DESCRIPTION
    Used to Release a specified call (Equal to : 1X-SEND)

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_release_specified_call
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  IxErrnoType err_no;
  qmi_voice_call_list_public_type info;
  cm_call_sups_params_s_type sups_params;
  uint32 sub_id;
  uint8 conn_idx = 0;
  qmi_voice_cm_if_evt_e_type  pending_event_id = QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF;
  cm_end_params_s_type end_params;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;  

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  /*sub_id contains sups_type */
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  if(params_ptr->data.manage_calls_info.call_id_valid)
  {
    conn_idx = params_ptr->data.manage_calls_info.call_id;
  }
  else
  {
    QM_MSG_HIGH("qmi_voice_cm_if_sups_release_specified_call :: Call id Not Valid");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }

  memset( &sups_params, 0, sizeof( sups_params ) );

  /* Lookup Call ID amongst the voice calls*/
  err_no = qmi_voice_call_list_query_voice_calls_by_conn_index( conn_idx, &info );

  if(err_no != E_SUCCESS)
  {
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_release_specified_call :: Fail to find the conn id = %d in the list", conn_idx);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }

  QM_MSG_MED_1("sups_release_specified_call: info.state = %d", info.state);

  if((info.state == QMI_VOICE_CALL_LIST_STATE_ACTIVE) ||
     (info.state == QMI_VOICE_CALL_LIST_STATE_HOLDING)
    )
  {
    sups_params.call_id = info.call_id;
    pending_event_id = QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF ;
    sups_params.cause = QMI_VOICE_CC_CAUSE_NORMAL_CALL_CLEARING;
  }
  else if((info.state == QMI_VOICE_CALL_LIST_STATE_DIALING) ||
          (info.state == QMI_VOICE_CALL_LIST_STATE_CC_IN_PROG) ||
          (info.state == QMI_VOICE_CALL_LIST_STATE_WAITING) ||
          (info.state == QMI_VOICE_CALL_LIST_STATE_INCOMING) ||
          (info.state == QMI_VOICE_CALL_LIST_STATE_ALERTING) ||
          (info.state == QMI_VOICE_CALL_LIST_STATE_DISCONNECTING))
  {
    sups_params.call_id = info.call_id;
    pending_event_id = QMI_VOICE_CM_IF_EVT_CALL_END ;
  }
  else
  {
    QM_MSG_HIGH_2("qmi_voice_cm_if_sups_release_specified_call: Rejecting command as the conn_id = %d is in invalid state = %d", conn_idx, info.state);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }

    /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new(params_ptr->header.cmd, params_ptr->header.handle,
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  pending_event_id,
                                                   sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {
    #ifdef FEATURE_DUAL_SIM
    if ( pending_event_id == QMI_VOICE_CM_IF_EVT_CALL_END )
    {
      /* Command CM to end the call */
      memset( &end_params, 0, sizeof( end_params ) );
      end_params.call_id = sups_params.call_id;
      end_params.info_type = CM_CALL_MODE_INFO_GW_CS;
      QM_MSG_HIGH_2("cm_mm_call_cmd_end(),release_specified_call(1X-send) callid = %d mode_info=%d", end_params.call_id, end_params.info_type);
      if ( !cm_mm_call_cmd_end( qmi_voice_cm_if_callsvc_command_callback, 
                                                    (void*)params_ptr->header.handle,
                                                    qmi_voice_cm_if_get_clientid(),
                                                    1,
                                                    &end_params ) )
      {
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
        return;
      }
    }  
    else
    {
      QM_MSG_HIGH_1("cm_mm_call_cmd_sups(),in Release specified call 1X-send, CM_CALL_SUPS_TYPE_ACTIVE_CALL_X_REL CallId =%d", sups_params.call_id);
      if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_ACTIVE_CALL_X_REL,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
      {
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
        return;
      }
    }
    #else
    if ( pending_event_id == QMI_VOICE_CM_IF_EVT_CALL_END )
    {
      /* Command CM to end the call */
      memset( &end_params, 0, sizeof( end_params ) );
      end_params.call_id = sups_params.call_id;
      end_params.info_type = CM_CALL_MODE_INFO_GW_CS;
      QM_MSG_HIGH_2("cm_mm_call_cmd_end(), release_specified_call(1X-send) callid = %d mode_info=%d", end_params.call_id, end_params.info_type);
      if ( !cm_mm_call_cmd_end( qmi_voice_cm_if_callsvc_command_callback, 
                                                    (void*)params_ptr->header.handle,
                                                    qmi_voice_cm_if_get_clientid(),
                                                    1,
                                                    &end_params ) )
      {
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
        return;
      }
    }  
    else
    {
      QM_MSG_HIGH_1("cm_mm_call_cmd_sups(),in Release specified call 1X-send, CM_CALL_SUPS_TYPE_ACTIVE_CALL_X_REL CallId =%d", sups_params.call_id);
      if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_ACTIVE_CALL_X_REL,
                                                    &sups_params ) )
      {
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
        return;
      }
    }
  #endif /*FEATURE_DUAL_SIM*/     
  }

}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_end_all_calls()

  DESCRIPTION
    Used to Release all calls (Equal to : ATH in atcop)

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_end_all_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_call_list_call_ids_list_type call_ids_list_active;
  qmi_voice_call_list_call_ids_list_type call_ids_list_held;
  qmi_voice_call_list_call_ids_list_type call_ids_list_waiting;
  qmi_voice_call_list_call_ids_list_type call_ids_list_incoming;
  qmi_voice_call_list_call_ids_list_type call_ids_list_alerting;
  qmi_voice_call_list_call_ids_list_type call_ids_list_dialing;
  uint32 sub_id;
  uint8 tot_num_calls = 0;
  cm_call_id_type all_call_ids[CM_CALL_ID_MAX];
  cm_end_params_s_type    end_params[CM_CALL_ID_MAX];
  uint8 index;
  qmi_voice_call_list_public_type call_info;
  sys_sys_mode_e_type     sys_mode = SYS_SYS_MODE_NO_SRV;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;  

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  memset(all_call_ids,0,sizeof(all_call_ids));

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif

  if(qmi_voice_call_list_query_sys_mode_from_call_list(&sys_mode, as_id) == E_SUCCESS)
  {
    QM_MSG_MED_1("Inside qmi_voice_cm_if_sups_end_all_calls(), found a call list entry mode=%d:", sys_mode);
  }  

  /*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  /* Lookup Call ID for Waiting Call */
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_WAITING,
                                                                                                &call_ids_list_waiting, as_id );
        /*If Waiting Call ID is found*/
  if ( call_ids_list_waiting.num_of_call_ids != 0 )
  {
    for(index = 0 ; (index < call_ids_list_waiting.num_of_call_ids) && (index < QMI_VOICE_CM_IF_CALL_ID_MAX_PER_SUBS) && (tot_num_calls < CM_CALL_ID_MAX) ; index++)
    {
      all_call_ids[tot_num_calls++] = call_ids_list_waiting.call_id[index];
    }
  }

  /* Lookup Call ID for Active Calls*/
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_ACTIVE,
                                                                                                &call_ids_list_active, as_id );
  /* Active Call ID is found */
  if ( call_ids_list_active.num_of_call_ids != 0 )
  {
    for(index = 0 ; (index < call_ids_list_active.num_of_call_ids) && (index < QMI_VOICE_CM_IF_CALL_ID_MAX_PER_SUBS) && (tot_num_calls < CM_CALL_ID_MAX); index++)
    {
      all_call_ids[tot_num_calls++] = call_ids_list_active.call_id[index];
    }
  }

  /* Lookup Call ID for Hold Call */
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_HOLDING,
                                                                                                &call_ids_list_held, as_id );
    /* Held Call ID is found */
  if ( call_ids_list_held.num_of_call_ids != 0 )
  {
    for(index = 0 ; (index < call_ids_list_held.num_of_call_ids) && (index < QMI_VOICE_CM_IF_CALL_ID_MAX_PER_SUBS) && (tot_num_calls < CM_CALL_ID_MAX) ; index++)
    {
      all_call_ids[tot_num_calls++] = call_ids_list_held.call_id[index];
    }
  }

    /* Lookup Call ID for Incoming Call */
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_INCOMING,
                                                                                                &call_ids_list_incoming, as_id );
          /* Incoming Call ID is found */
  if ( call_ids_list_incoming.num_of_call_ids != 0 )
  {
    for(index = 0 ; (index < call_ids_list_incoming.num_of_call_ids) && (index < QMI_VOICE_CM_IF_CALL_ID_MAX_PER_SUBS) && (tot_num_calls < CM_CALL_ID_MAX) ; index++)
    {
      all_call_ids[tot_num_calls++] = call_ids_list_incoming.call_id[index];
    }
  }

      /* Lookup Call ID for Alerting Calls */
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_ALERTING,
                                                                                                  &call_ids_list_alerting, as_id);
      /* Alerting Call ID found */
  if ( call_ids_list_alerting.num_of_call_ids != 0 )
  {
    for(index = 0 ; (index < call_ids_list_alerting.num_of_call_ids) && (index < QMI_VOICE_CM_IF_CALL_ID_MAX_PER_SUBS) && (tot_num_calls < CM_CALL_ID_MAX) ; index++)
    {
      all_call_ids[tot_num_calls++] = call_ids_list_alerting.call_id[index];
    }
  }
    
    /* Lookup Call ID for Dialing Calls*/
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_DIALING,
                                                                                                &call_ids_list_dialing, as_id);
  /* Dialing Call ID is found */
  if ( call_ids_list_dialing.num_of_call_ids != 0 )
  {
    for(index = 0 ; (index < call_ids_list_dialing.num_of_call_ids) && (index < QMI_VOICE_CM_IF_CALL_ID_MAX_PER_SUBS) && (tot_num_calls < CM_CALL_ID_MAX) ; index++)
    {
      all_call_ids[tot_num_calls++] = call_ids_list_dialing.call_id[index];
    }
  }
    
  if (tot_num_calls == 0)
  {
    QM_MSG_ERROR("In qmi_voice_cm_if_sups_end_all_calls no valid calls are present");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INCOMPATIBLE_STATE,FALSE,FALSE);
    return;
  }

    /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                   QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                   QMI_VOICE_CM_IF_EVT_NONE, sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {
    memset( end_params, 0, sizeof( end_params ) );

    for(index =0; (index < tot_num_calls) && (index < CM_CALL_ID_MAX) ; index++)
    {
      if ( QMI_VOICE_CM_IF_SYS_MODE_IS_1XEVDO( sys_mode ))
      {
        end_params[index].info_type = CM_CALL_MODE_INFO_CDMA;
      }
      else
      {
        if ( qmi_voice_call_list_query_by_call_id( all_call_ids[index], &call_info ) != E_SUCCESS ) 
        {
          QM_MSG_HIGH_1("Invalid call id %d in the list", all_call_ids[index]);
          qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, TRUE, TRUE );
          return;
        }
        /* check if the call is VOIP here */
        if( call_info.mode_info_type == CM_CALL_MODE_INFO_IP )
        {
          end_params[index].info_type = CM_CALL_MODE_INFO_IP;
        }
        else
        {
          end_params[index].info_type = CM_CALL_MODE_INFO_GW_CS;
        }
      }

      end_params[index].call_id = all_call_ids[index];
      QM_MSG_MED_1("End All calls, call id = %d", end_params[index].call_id);
    }
    
    QM_MSG_MED_1("qmi_voice_cm_if_sups_end_all_calls :: cm_mm_call_cmd_end() for %d calls", tot_num_calls);

    if ( !cm_mm_call_cmd_end( qmi_voice_cm_if_callsvc_command_callback, 
                              (void*)params_ptr->header.handle, 
                              qmi_voice_cm_if_get_clientid(),
                              tot_num_calls,
                              end_params ) )
    {
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
    }
  }

}


/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_local_hold_unhold()

  DESCRIPTION
    Used to move all the calls of a subscription to either hold or unhold state 

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_local_hold_unhold
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
#ifdef FEATURE_DUAL_ACTIVE

  uint32 sub_id;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;  
  cm_call_hold_state_e_type  call_hold_state;

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_local_hold_unhold():");

  as_id = params_ptr->header.as_id;

  sub_id = params_ptr->data.manage_calls_info.sups_type;

  if(sub_id == (uint32)QMI_VOICE_CM_IF_MNG_CALLS_LOCAL_HOLD)
  {
    call_hold_state = CM_CALL_HOLD_STATE_LOCAL_HOLD;
  }
  else
  {
    call_hold_state = CM_CALL_HOLD_STATE_ACTIVE;
  }

  /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new(params_ptr->header.cmd, params_ptr->header.handle,
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_NONE,
                                                   sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    //QM_MSG_HIGH("Could not add entry to the list ");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }

  QM_MSG_HIGH_2("qmi_voice_cm_if_sups_local_hold_unhold :: cm_mm_call_cmd_local_hold invoked with hold state %d for as_id %d", call_hold_state, as_id);

  /* Invoke CM API for local hold*/
  if(!cm_mm_call_cmd_local_hold( qmi_voice_cm_if_callsvc_command_callback, 
                             (void*)params_ptr->header.handle, 
                             qmi_voice_cm_if_get_clientid(),
                             as_id,
                             call_hold_state
                            ) )
  {
    QM_MSG_HIGH("cm_mm_call_cmd_local_hold() failed ");
    /*Send error response upon callback invocation from CM. This ensures proper error being captured */
  }

#else /* FEATURE_DUAL_ACTIVE */
  qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NOT_SUPPORTED,FALSE,FALSE);
#endif /* FEATURE_DUAL_ACTIVE */

}


/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_modify_ip_calls()

  DESCRIPTION
    Used to initiate a Call upgrade/downgrade from VOIP<->VT

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_modify_ip_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  cm_call_sups_params_s_type sups_params;
  uint8 connex_index=0;
  qmi_voice_call_list_public_type call_info;
  cm_ip_call_attrib_info_s_type  call_attrib;
  cm_call_type_e_type call_type=CM_CALL_TYPE_VOICE;
  uint8 sub_id=0, as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_modify_ip_calls():");
  memset( &sups_params, 0, sizeof( sups_params ) );
  memset( &call_info , 0 , sizeof(call_info));
  memset( &call_attrib , 0 , sizeof(call_attrib));

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif

  sub_id = params_ptr->data.manage_calls_info.sups_type;
  
  /* Lookup Call ID */
  QM_MSG_HIGH_3("qmi_voice_cm_if_sups_modify_ip_calls :: call_id_valid : %d, call_type_valid : %d, call_type :%x",
                 params_ptr->data.manage_calls_info.call_id_valid,
                 params_ptr->data.manage_calls_info.call_type_valid,
                 params_ptr->data.manage_calls_info.call_type );
  
  if(params_ptr->data.manage_calls_info.call_id_valid)
  {
    connex_index = params_ptr->data.manage_calls_info.call_id;
  }
  else
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

  if( params_ptr->data.manage_calls_info.call_type_valid)
  { 
    if (params_ptr->data.manage_calls_info.call_type == QMI_VOICE_CM_IF_CALL_TYPE_VT)
    {
      call_type = CM_CALL_TYPE_VT;
    }
    else if((params_ptr->data.manage_calls_info.call_type == QMI_VOICE_CM_IF_CALL_TYPE_VOIP) ||
		    (params_ptr->data.manage_calls_info.call_type == QMI_VOICE_CM_IF_CALL_TYPE_VOICE))
    {
      call_type = CM_CALL_TYPE_VOICE;
    }	
    else
    {
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      return;    
    }
  }  
  else
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

 
  if ( qmi_voice_call_list_query_by_conn_index( connex_index, &call_info ) != E_SUCCESS ) 
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

  if ( params_ptr->data.manage_calls_info.is_audio_attrib_valid )
  {
    call_attrib.audio_attrib = (cm_call_attrib_e_type)params_ptr->data.manage_calls_info.audio_attrib;
  }
     
  if ( params_ptr->data.manage_calls_info.is_video_attrib_valid )
  {
    call_attrib.video_attrib = (cm_call_attrib_e_type)params_ptr->data.manage_calls_info.video_attrib;
  }


     /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_CALL_MODIFY_COMPLETE_CONF,
                                                  sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_modify_ip_calls :: cm_mm_call_cmd_modify_req_ext(), CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_modify_req_ext( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    call_info.call_id,
                                                    call_type,
                                                    &call_attrib) )
                                         
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }
}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_release_specified_call_from_conference()

  DESCRIPTION
    Release a specified call (using sip number) from the conference call.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_release_specified_call_from_conference
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_call_list_call_ids_list_type call_ids_list_active;
  qmi_voice_call_list_call_ids_list_type call_ids_list_hold;
  cm_call_sups_params_s_type sups_params;
  uint32 sub_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_release_specified_call_from_conference():");
  memset( &sups_params, 0, sizeof( sups_params ) );

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif

  /*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  if(params_ptr->data.manage_calls_info.is_sip_uri_valid == FALSE)
  {
    QM_MSG_MED("qmi_voice_cm_if_sups_release_specified_call_from_conference :: Missing SIP URI to remove a IP call from Conference");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;    
  }
  else
  {
    QM_MSG_MED_2("qmi_voice_cm_if_sups_release_specified_call_from_conference :: SIP URI length=%d, num=%s", params_ptr->data.manage_calls_info.sip_uri_len,params_ptr->data.manage_calls_info.sip_uri);
    cm_num_fill( &sups_params.sups_number, ( uint8 * )params_ptr->data.manage_calls_info.sip_uri, 
                  params_ptr->data.manage_calls_info.sip_uri_len, CM_DIGIT_MODE_8BIT_ASCII );
    sups_params.sups_number.number_plan = CM_NPI_ISDN;
  }
    
  /* Lookup Call ID */
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_ACTIVE,
                                                     &call_ids_list_active, as_id );

  /* No Call ID is found */
  if ( call_ids_list_active.num_of_call_ids == 0 )
  {
    /* Lookup Call ID */
    qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_HOLDING,
                                                       &call_ids_list_hold, as_id );

    if ( call_ids_list_hold.num_of_call_ids == 0 )
    {
      QM_MSG_MED("qmi_voice_cm_if_sups_release_specified_call_from_conference : rejecting cmd as there are neither active nor held calls");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;
    }
    else
    {
     sups_params.call_id = call_ids_list_hold.call_id[0];
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_active.call_id[0];
  }

    /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,
                                                  sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_MED_1("qmi_voice_cm_if_sups_release_specified_call_from_conference :: cm_mm_call_cmd_sups_per_subs(), CM_CALL_SUPS_TYPE_RELEASE_CALL_X_FROM_CONFERENCE CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_RELEASE_CALL_X_FROM_CONFERENCE,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else
    QM_MSG_MED_1("qmi_voice_cm_if_sups_release_specified_call_from_conference :: cm_mm_call_cmd_sups(), CM_CALL_SUPS_TYPE_RELEASE_CALL_X_FROM_CONFERENCE CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_RELEASE_CALL_X_FROM_CONFERENCE,
                                                    &sups_params ) )
    #endif /*FEATURE_DUAL_SIM*/                                                    
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }
}/*qmi_voice_cm_if_sups_release_specified_call_from_conference*/


/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_add_participant()

  DESCRIPTION
    Add a participant to a normal call or a conference call (using sip number).

  PARAMETERS
    params_ptr  : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_add_participant
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  cm_call_sups_params_s_type sups_params;
  uint32 sub_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  qmi_voice_call_list_public_type call_info;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_add_participant():");
  memset( &sups_params, 0, sizeof( sups_params ) );

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif

  /*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  if((params_ptr->data.manage_calls_info.call_id_valid == FALSE) || 
     (params_ptr->data.manage_calls_info.is_sip_uri_valid == FALSE) )
  {
    //Call ID and URI of participant to be added are required
    QM_MSG_MED("Missing Call ID to which participant needs to be added or SIP URI of participant");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_MISSING_ARG,FALSE,FALSE);
    return;
  }
  else if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.manage_calls_info.call_id, &call_info ) != E_SUCCESS ) 
  {
    //call with the given call ID was not found
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }
  else if((call_info.state != QMI_VOICE_CALL_LIST_STATE_ACTIVE) && (call_info.state != QMI_VOICE_CALL_LIST_STATE_HOLDING))
  {
    //Add participant request can be sent only for a call in conversation
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_OPERATION, FALSE, FALSE );
    return;
  }
  else
  { 
    //Fill sups params to be sent to CM
    sups_params.call_id = call_info.call_id;
    QM_MSG_MED_3("qmi_voice_cm_if_sups_add_participant :: Call ID %D SIP URI length=%d, num=%s", sups_params.call_id, params_ptr->data.manage_calls_info.sip_uri_len,params_ptr->data.manage_calls_info.sip_uri);
    cm_num_fill( &sups_params.sups_number, ( uint8 * )params_ptr->data.manage_calls_info.sip_uri, 
                  params_ptr->data.manage_calls_info.sip_uri_len, CM_DIGIT_MODE_8BIT_ASCII );
    sups_params.sups_number.number_plan = CM_NPI_ISDN; // ?? 
  }

  /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,
                                                  sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_add_participant :: cm_mm_call_cmd_sups_per_subs(), CM_CALL_SUPS_TYPE_ADD_PARTICIPANT CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_ADD_PARTICIPANT,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )

    #else
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_add_participant :: cm_mm_call_cmd_sups(), CM_CALL_SUPS_TYPE_ADD_PARTICIPANT CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_ADD_PARTICIPANT,
                                                    &sups_params ) )
    #endif /*FEATURE_DUAL_SIM*/                                                    
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }
}/*qmi_voice_cm_if_sups_add_participant*/


/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_call_deflection()

  DESCRIPTION
    Deflect an incoming call to a spedicified UE (using sip number) 

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_call_deflection
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{

  qmi_voice_call_list_call_ids_list_type call_ids_list_incoming;
  cm_call_sups_params_s_type sups_params;
  qmi_voice_call_list_public_type call_info;
  uint32 sub_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_call_deflection()");
  memset( &sups_params, 0, sizeof( sups_params ) );
  memset( &call_info, 0, sizeof( call_info ) );

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/

  /*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;
 

  if((params_ptr->data.manage_calls_info.call_id_valid == FALSE) || 
     (params_ptr->data.manage_calls_info.is_sip_uri_valid == FALSE) )
  {
    QM_MSG_MED("qmi_voice_cm_if_sups_call_deflection :: Missing Either SIP URI or Call ID to deflect an incoming call");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;    
  }
  else
  {
    QM_MSG_MED_2("SIP URI length=%d, num=%s", params_ptr->data.manage_calls_info.sip_uri_len,params_ptr->data.manage_calls_info.sip_uri);
    cm_num_fill( &sups_params.sups_number, ( uint8 * )params_ptr->data.manage_calls_info.sip_uri, 
                  params_ptr->data.manage_calls_info.sip_uri_len, CM_DIGIT_MODE_8BIT_ASCII );
    sups_params.sups_number.number_plan = CM_NPI_ISDN;

    if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.manage_calls_info.call_id, &call_info ) != E_SUCCESS ) 
    {
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      return;
    }
    sups_params.call_id = call_info.call_id;
  }
    
  /* Lookup Call state , Additional Checks*/
  qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_INCOMING|QMI_VOICE_CALL_LIST_STATE_WAITING,
                                                          &call_ids_list_incoming,
                                                          as_id );

  /* No Call ID is found */
  if ( call_ids_list_incoming.num_of_call_ids != 0 && 
       (call_ids_list_incoming.call_id[0] == params_ptr->data.manage_calls_info.call_id))
  {
    QM_MSG_MED("Call ID verified. Call state is incoming");
  }

    /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,
                                                  sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_call_deflection :: cm_mm_call_cmd_sups_per_subs(), CM_CALL_SUPS_TYPE_CALL_DEFLECTION CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_CALL_DEFLECTION,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_call_deflection :: cm_mm_call_cmd_sups(), CM_CALL_SUPS_TYPE_CALL_DEFLECTION CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_CALL_DEFLECTION,
                                                    &sups_params ) )
    #endif /*FEATURE_DUAL_SIM*/                                                    
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }
}/*qmi_voice_cm_if_sups_call_deflection*/


/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_modify_accept_ip_calls()

  DESCRIPTION
    Used accepted the Call upgrade from VOIP->VT/VS

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_modify_accept_ip_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  cm_call_sups_params_s_type sups_params;
  uint8 connex_index=0;
  qmi_voice_call_list_public_type call_info;
  cm_call_type_e_type call_type=CM_CALL_TYPE_VOICE;
  cm_ip_call_attrib_info_s_type  call_attrib;
  uint8 sub_id=0, as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_modify_accept_ip_calls():");
  memset( &sups_params, 0, sizeof( sups_params ) );
  memset( &call_info , 0 , sizeof(call_info));
  memset( &call_attrib , 0 , sizeof(call_attrib));

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif

  sub_id = params_ptr->data.manage_calls_info.sups_type;
  
  /* Lookup Call ID */
  if(params_ptr->data.manage_calls_info.call_id_valid)
  {
    connex_index = params_ptr->data.manage_calls_info.call_id;
  }
  else
  {
    QM_MSG_MED("No Call id mentioned for Modify Accept call():");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

  if( params_ptr->data.manage_calls_info.call_type_valid)
  { 
    if (params_ptr->data.manage_calls_info.call_type == QMI_VOICE_CM_IF_CALL_TYPE_VT)
    {
      call_type = CM_CALL_TYPE_VT;
    }
    else if((params_ptr->data.manage_calls_info.call_type == QMI_VOICE_CM_IF_CALL_TYPE_VOIP) ||
           (params_ptr->data.manage_calls_info.call_type == QMI_VOICE_CM_IF_CALL_TYPE_VOICE))
    {
      call_type = CM_CALL_TYPE_VOICE;
    }
    else
    {
      QM_MSG_MED_1("Invalid Call type %d mentioned for Modify Accept call():", params_ptr->data.manage_calls_info.call_type);
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      return;    
    }
  }  
  else
  {
    QM_MSG_MED("No Call type mentioned for Modify Accept call():");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

  if ( params_ptr->data.manage_calls_info.is_audio_attrib_valid )
  {
    call_attrib.audio_attrib = (cm_call_attrib_e_type)params_ptr->data.manage_calls_info.audio_attrib;
  }
     
  if ( params_ptr->data.manage_calls_info.is_video_attrib_valid )
  {
    call_attrib.video_attrib = (cm_call_attrib_e_type)params_ptr->data.manage_calls_info.video_attrib;
  }

  if ( qmi_voice_call_list_query_by_conn_index( connex_index, &call_info ) != E_SUCCESS ) 
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

     /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_CALL_MODIFY_COMPLETE_CONF,
                                                  sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_modify_accept_ip_calls :: cm_mm_call_cmd_modify_res_ext() - Accept, CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_modify_res_ext( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    call_info.call_id,
                                                    TRUE,
                                                    NULL,
                                                    call_type,
                                                    &call_attrib) )
                                         
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }
}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_modify_reject_ip_calls()

  DESCRIPTION
    Used Rejected the Call upgrade from remote party (VOIP->VT/VS)

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_modify_reject_ip_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  cm_call_sups_params_s_type sups_params;
  uint8 connex_index=0;
  qmi_voice_call_list_public_type call_info;
  cm_call_type_e_type call_type=CM_CALL_TYPE_VOICE;
  cm_ip_call_attrib_info_s_type  call_attrib;
  uint8 sub_id=0, as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_modify_reject_ip_calls():");
  memset( &sups_params, 0, sizeof( sups_params ) );
  memset( &call_info , 0 , sizeof(call_info));
  memset( &call_attrib , 0 , sizeof(call_attrib));
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif

  sub_id = params_ptr->data.manage_calls_info.sups_type;
  
  /* Lookup Call ID */
  QM_MSG_HIGH_3("qmi_voice_cm_if_sups_modify_reject_ip_calls :: call_id_valid : %d, call_type_valid : %d, call_type :%x",
                 params_ptr->data.manage_calls_info.call_id_valid,
                 params_ptr->data.manage_calls_info.call_type_valid,
                 params_ptr->data.manage_calls_info.call_type );

  if(params_ptr->data.manage_calls_info.call_id_valid)
  {
    connex_index = params_ptr->data.manage_calls_info.call_id;
  }
  else
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

  if( params_ptr->data.manage_calls_info.call_type_valid)
  { 
    if (params_ptr->data.manage_calls_info.call_type == QMI_VOICE_CM_IF_CALL_TYPE_VT)
    {
      call_type = CM_CALL_TYPE_VT;
    }
    else if((params_ptr->data.manage_calls_info.call_type == QMI_VOICE_CM_IF_CALL_TYPE_VOIP) ||
           (params_ptr->data.manage_calls_info.call_type == QMI_VOICE_CM_IF_CALL_TYPE_VOICE))
    {
      call_type = CM_CALL_TYPE_VOICE;
    }
    else
    {
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      return;    
    }
  }  
  else
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

  if ( params_ptr->data.manage_calls_info.is_audio_attrib_valid )
  {
    call_attrib.audio_attrib = (cm_call_attrib_e_type)params_ptr->data.manage_calls_info.audio_attrib;
  }
     
  if ( params_ptr->data.manage_calls_info.is_video_attrib_valid )
  {
    call_attrib.video_attrib = (cm_call_attrib_e_type)params_ptr->data.manage_calls_info.video_attrib;
  }

  if ( qmi_voice_call_list_query_by_conn_index( connex_index, &call_info ) != E_SUCCESS ) 
  {
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

     /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, 
                                                  QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                  QMI_VOICE_CM_IF_EVT_CALL_MODIFY_COMPLETE_CONF,
                                                  sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_modify_reject_ip_calls :: cm_mm_call_cmd_modify_res_ext() - Reject, CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_modify_res_ext( qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    call_info.call_id,
                                                    FALSE,
                                                    NULL,
                                                    call_type,
                                                    &call_attrib) )
                                         
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }
}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_hold_ip_calls()

  DESCRIPTION
    Used to put a call on hold with specific call_id

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_hold_ip_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  cm_call_sups_params_s_type sups_params;
  uint32 sub_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY; 
  qmi_voice_call_list_public_type call_info;

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_hold_ip_calls():");

  memset( &sups_params, 0, sizeof( sups_params ) );
  memset( &call_info, 0, sizeof( call_info ) );

  /* call_id TLV is mandantory for HOLD sups_type */
  if ( params_ptr->data.manage_calls_info.call_id_valid != TRUE )
  {
    QM_MSG_ERROR_2("No valid call_id for hold_ip_calls(), call_id_valid = %d, call_id = %d",
                    params_ptr->data.manage_calls_info.call_id_valid,
                    params_ptr->data.manage_calls_info.call_id);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

  /* Look up CM call_id by conn_idx */
  if(params_ptr->data.manage_calls_info.call_id_valid)
  {
    if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.manage_calls_info.call_id, &call_info ) != E_SUCCESS ) 
    {
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      return;
    }
    sups_params.call_id = call_info.call_id;
  }

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif

  /*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                   QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                   QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF, sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_hold_ip_calls :: cm_mm_call_cmd_sups_per_subs(), CM_CALL_SUPS_TYPE_HOLD_CALL CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_HOLD_PER_CALL,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_hold_ip_calls :: cm_mm_call_cmd_sups(), CM_CALL_SUPS_TYPE_HOLD_CALL CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups(qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_HOLD_PER_CALL,
                                                    &sups_params ) )
    #endif/*FEATURE_DUAL_SIM*/
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }

}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_resume_ip_calls()

  DESCRIPTION
    Used to resume a call with specific call_id

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_resume_ip_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  cm_call_sups_params_s_type sups_params;
  uint32 sub_id;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY; 
  qmi_voice_call_list_public_type call_info;

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_resume_ip_calls():");

  memset( &sups_params, 0, sizeof( sups_params ) );
  memset( &call_info, 0, sizeof( call_info ) );

  /* call_id TLV is mandantory for RESUME sups_type */
  if ( params_ptr->data.manage_calls_info.call_id_valid != TRUE )
  {
    QM_MSG_ERROR_2("No valid call_id for resume_ip_calls(), call_id_valid = %d, call_id = %d",
                    params_ptr->data.manage_calls_info.call_id_valid,
                    params_ptr->data.manage_calls_info.call_id);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
    return;
  }

  /* Look up CM call_id by conn_idx */
  if(params_ptr->data.manage_calls_info.call_id_valid)
  {
    if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.manage_calls_info.call_id, &call_info ) != E_SUCCESS ) 
    {
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      return;
    }
    sups_params.call_id = call_info.call_id;
  }

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif

  /*sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

    /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                   QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                   QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF, sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_resume_ip_calls :: cm_mm_call_cmd_sups_per_subs(), CM_CALL_SUPS_TYPE_RESUME_CALL CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_RESUME_PER_CALL,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
    #else
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_resume_ip_calls :: cm_mm_call_cmd_sups(), CM_CALL_SUPS_TYPE_RESUME_CALL CallId =%d", sups_params.call_id);
    if ( !cm_mm_call_cmd_sups(qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_RESUME_PER_CALL,
                                                    &sups_params ) )
    #endif/*FEATURE_DUAL_SIM*/
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }

}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_switch_speech_codec()

  DESCRIPTION
    Used to switch speech codec for an IP call with specific call_id

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_switch_speech_codec
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  cm_call_sups_params_s_type       sups_params;
  uint32                           sub_id;
  uint8                            as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY; 
  qmi_voice_call_list_public_type  call_info;

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_switch_speech_codec():");

  memset( &sups_params, 0, sizeof( sups_params ) );
  memset( &call_info,   0, sizeof( call_info ) );

  /* call_id TLV is mandantory for SWITCH_SPEECH_CODEC sups_type */
  if ( params_ptr->data.manage_calls_info.call_id_valid != TRUE )
  {
    QM_MSG_ERROR_2("No valid call_id for switch_speech_codec(), call_id_valid = %d, call_id = %d",
                    params_ptr->data.manage_calls_info.call_id_valid,
                    params_ptr->data.manage_calls_info.call_id);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_MISSING_ARG, FALSE, FALSE );
    return;
  }

  /* speech_codec TLV is mandantory for SWITCH_SPEECH_CODEC sups_type */
  if ( params_ptr->data.manage_calls_info.is_speech_codec_valid != TRUE )
  {
    QM_MSG_ERROR_2("No valid speech_codec for switch_speech_codec(), is_speech_codec_valid = %d, speech_codec = %d",
                    params_ptr->data.manage_calls_info.is_speech_codec_valid,
                    params_ptr->data.manage_calls_info.speech_codec);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_MISSING_ARG, FALSE, FALSE );
    return;
  }
  else
  {
    /* Fill the speech_codec info into sup_params */
    sups_params.ip_params.switch_to_codec = params_ptr->data.manage_calls_info.speech_codec;
  }

  /* Look up CM call_id by conn_idx */
  if(params_ptr->data.manage_calls_info.call_id_valid)
  {
    if ( qmi_voice_call_list_query_by_conn_index( params_ptr->data.manage_calls_info.call_id, &call_info ) != E_SUCCESS ) 
    {
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INVALID_ID, FALSE, FALSE );
      return;
    }
    sups_params.call_id = call_info.call_id;
  }

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif

  /* sub_id contains sups_type */
  sub_id = params_ptr->data.manage_calls_info.sups_type;

  /* Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                               QMI_VOICE_CMD_AWAITING_CALLBACK,
                               QMI_VOICE_CM_IF_EVT_CALL_SWITCH_CODEC_CNF, sub_id, NULL, 0, as_id ) != E_SUCCESS )
  {
    /* Out of ReqList buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  else
  {

  #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_2("qmi_voice_cm_if_sups_switch_speech_codec :: cm_mm_call_cmd_sups_per_subs(), CM_CALL_SUPS_TYPE_SWITCH_SPEECH_CODEC switch_to_codec %d, CallId =%d",
                  sups_params.ip_params.switch_to_codec,
                  sups_params.call_id);
    if ( !cm_mm_call_cmd_sups_per_subs( qmi_voice_cm_if_callsvc_command_callback, 
                                        (void *) params_ptr->header.handle, 
                                         qmi_voice_cm_if_get_clientid(),
                                         CM_CALL_SUPS_TYPE_SWITCH_SPEECH_CODEC,
                                         &sups_params,(sys_modem_as_id_e_type)as_id ) )
  #else
    QM_MSG_HIGH_2("qmi_voice_cm_if_sups_switch_speech_codec :: cm_mm_call_cmd_sups(), CM_CALL_SUPS_TYPE_SWITCH_SPEECH_CODEC switch_to_codec %d, CallId =%d",
                  sups_params.ip_params.switch_to_codec,
                  sups_params.call_id);
    if ( !cm_mm_call_cmd_sups(qmi_voice_cm_if_callsvc_command_callback,
                                                    (void*)params_ptr->header.handle, 
                                                    qmi_voice_cm_if_get_clientid(),
                                                    CM_CALL_SUPS_TYPE_SWITCH_SPEECH_CODEC,
                                                    &sups_params ) )
  #endif/*FEATURE_DUAL_SIM*/
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,TRUE);
      return;
    }
  }

} /* qmi_voice_cm_if_sups_switch_speech_codec() */

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_set_sups_service()

  DESCRIPTION


  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_set_sups_service
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cm_if_set_sups_service_s *in_data_ptr;
  
  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );
  in_data_ptr = (qmi_voice_cm_if_set_sups_service_s *)(&params_ptr->data);
  /*-----------------------------------------------------------------------*/

  QM_MSG_MED_1("sups_type in qmi_voice_cm_if_sups_set_sups_service():  %d", in_data_ptr->sups_service_info.reason);

  /* If the sys mode is not GW, send error response */
  /* If the sys mode is not GW, send error response */
  #ifdef FEATURE_DUAL_SIM
   qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  switch(in_data_ptr->sups_service_info.reason)
  {
    case QMI_VOICE_CM_IF_SET_SUPS_FWD_UNCONDITIONAL:
    case QMI_VOICE_CM_IF_SET_SUPS_FWD_MOBILEBUSY:
    case QMI_VOICE_CM_IF_SET_SUPS_FWD_NOREPLY:
    case QMI_VOICE_CM_IF_SET_SUPS_FWD_UNREACHABLE:
    case QMI_VOICE_CM_IF_SET_SUPS_FWD_ALLFORWARDING:
    case QMI_VOICE_CM_IF_SET_SUPS_FWD_ALLCONDITIONAL:
      qmi_voice_cm_if_sups_set_sups_service_call_forward(params_ptr);
      break;
    case QMI_VOICE_CM_IF_SET_SUPS_BARR_ALLOUTGOING:
    case QMI_VOICE_CM_IF_SET_SUPS_BARR_OUTGOINGINT:
    case QMI_VOICE_CM_IF_SET_SUPS_BARR_OUTGOINGINTEXTOHOME:
    case QMI_VOICE_CM_IF_SET_SUPS_BARR_ALLINCOMING:
    case QMI_VOICE_CM_IF_SET_SUPS_BARR_INCOMINGROAMING:
    case QMI_VOICE_CM_IF_SET_SUPS_BARR_ALLBARRING:
    case QMI_VOICE_CM_IF_SET_SUPS_BARR_ALLOUTGOINGBARRING:
    case QMI_VOICE_CM_IF_SET_SUPS_BARR_ALLINCOMINGBARRING:
    case QMI_VOICE_CM_IF_SET_SUPS_BARR_INCOMINGNUMBER:
    case QMI_VOICE_CM_IF_SET_SUPS_BARR_INCOMINGANONYMOUS:
      qmi_voice_cm_if_sups_set_sups_service_call_barring(params_ptr);
      break;
    case QMI_VOICE_CM_IF_SET_SUPS_CALLWAITING :
      qmi_voice_cm_if_sups_set_sups_service_call_waiting(params_ptr);
      break;
    case QMI_VOICE_CM_IF_SET_SUPS_CLIP :
      qmi_voice_cm_if_sups_set_sups_service_clip(params_ptr);
      break;
    case QMI_VOICE_CM_IF_SET_SUPS_COLP :
      qmi_voice_cm_if_sups_set_sups_service_colp(params_ptr);
      break;
    case QMI_VOICE_CM_IF_SET_SUPS_COLR :
      qmi_voice_cm_if_sups_set_sups_service_colr(params_ptr);
      break;
    default :
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      break;
  }
}


/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_set_sups_service_call_forward()

  DESCRIPTION
    Sets the Call Forwarding supplimentary services as per the received input

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_set_sups_service_call_forward
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{

  boolean cm_result = TRUE;
  qmi_voice_cm_if_set_sups_service_s *in_data_ptr = (qmi_voice_cm_if_set_sups_service_s *)(&params_ptr->data);
  unsigned int bcd_num_len = 0;
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type ss_data;
  cm_num_s_type number;
  byte  bcd_number[CM_CALLED_PARTY_BCD_NO_LENGTH];
  char *cf_reason_name; /* Name for call forward reason given */
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  uint32 service_class=0;
  int toa=129;
  char *digit;
  char forward_num[QMI_VOICE_CM_IF_MAX_CALLING_NUM_LEN];
  cm_num_s_type            dialed_digits;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;


  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_set_sups_service_call_forward():");

  memset(&ss_data, 0, sizeof(ss_data));
  memset(&number, 0, sizeof(number));
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/

  QM_MSG_MED_2("set_sups_service_call_forward service = %d, reason = %d", in_data_ptr->sups_service_info.service, in_data_ptr->sups_service_info.reason);

  if(in_data_ptr->service_class_valid || in_data_ptr->service_class_ext_valid)
  {
    if(in_data_ptr->service_class_ext_valid)
    {
      service_class = in_data_ptr->service_class_ext;
    }
	else
	{
      service_class = in_data_ptr->service_class;
	}
    if ( !qmi_voice_cm_sups_service_class_is_valid(service_class) )
    {
      QM_MSG_ERROR_1("received invalid Service class %d", service_class);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }

  memset(bcd_number, 0, sizeof(bcd_number));
 
  if(!qmi_voice_cm_sups_cmd_set_call_fwd_is_valid(params_ptr,in_data_ptr))
  {
    QM_MSG_MED("received invalid parameters in set_sups_service_call_forward");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
    return;
  }
  else
  {
    if((in_data_ptr->fwd_number_valid == TRUE) && (in_data_ptr->fwd_number_len!= 0))
    {
      cm_num_fill(&number, (byte *)in_data_ptr->fwd_number,
                  (byte)in_data_ptr->fwd_number_len,
                  CM_DIGIT_MODE_8BIT_ASCII);
  
      if(number.len > 0)
      {
      
        memset(forward_num,0,QMI_VOICE_CM_IF_MAX_CALLING_NUM_LEN);
        memscpy(forward_num,sizeof(forward_num), in_data_ptr->fwd_number,in_data_ptr->fwd_number_len);
        digit = forward_num;
        /* cm_num_fill does nothing to verify number */
        if ('+' == *digit)
        {
          toa = 145;
          digit++;
        }
        QM_MSG_MED_2( "toa = %d, number is = %s",toa ,forward_num);

        /* Number type documented in GSM 04.08 section 10.5.4.7  */
        /* If user speficied the number type, it has precedence. */
        /* The BCD encoding routine will set final type value.   */
        if(in_data_ptr->num_type_plan_valid)
        {
         number.number_type = in_data_ptr->num_type_plan.num_type;
         number.number_plan = in_data_ptr->num_type_plan.num_plan;
        }
        else
        {
         number.number_type = (toa & CM_TON_MASK) >> 4;
         number.number_plan = (toa & 0x0F);
        }
        cm_util_number_to_bcd( &number, bcd_number );
  
        /* qcril_cm_util_phone_number_to_bcd saves the length in bcd_number[0] */
        bcd_num_len = bcd_number[0];
        memscpy(&bcd_number[0], sizeof(bcd_number), &bcd_number[1], bcd_num_len);
        bcd_number[bcd_num_len] = '\0';
  
      }
    }

    cmd_info_ptr->ss_code = qmi_voice_cm_sups_get_cfw_ss_code(in_data_ptr->sups_service_info.reason, &cf_reason_name);
    cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

    /* fill the sups params required for sups string construction */
    memset(&ss_params, 0, sizeof(ss_params));
    ss_params.mode = (qmi_voice_cm_sups_mode_e_type)qmi_voice_cm_sups_map_service_to_cm_mode(in_data_ptr->sups_service_info.service);
    ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)cmd_info_ptr->ss_code;
    if(in_data_ptr->service_class_valid)
    {
      ss_params.service_class = (qmi_voice_cm_sups_class_e_type)service_class;
    }
    if(in_data_ptr->fwd_number_valid)
    {
      ss_params.cmd.reg.number = forward_num;
    }
    if(in_data_ptr->no_reply_timer_valid)
    {
      ss_params.cmd.reg.nr_timer = in_data_ptr->no_reply_timer;
    }
    /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
    check in future. The string should be sent to modem for any call control */
    if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
    {
      QM_MSG_HIGH("Sups string construction failed");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;
    }
    else
    {
      QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
      memset(&dialed_digits,0,sizeof(dialed_digits));
      dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
      dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
    }

    switch (qmi_voice_cm_sups_map_service_to_cm_mode(in_data_ptr->sups_service_info.service))
    {
     case QMI_VOICE_CM_SUPS_MODE_DISABLE:
       ss_data.deact.ss_code = cmd_info_ptr->ss_code;
       ss_data.deact.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.deact.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
       {
         //QM_MSG_HIGH("Could not add entry to the list ");
         /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
         return;
       }
       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_4( "CFW :deactivate_cc_exten_per_subs() CFW reason :%s, ss_ref =%d, code_type :%d, bs_code=%d ", 
                      cf_reason_name,ss_data.deact.ss_ref, ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code);
       
       cm_result = cm_sups_cmd_deactivate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.deact,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );

       #else
       QM_MSG_MED_4( "CFW :deactivate_exten() CFW reason :%s, ss_ref =%d, code_type :%d, bs_code=%d", 
                      cf_reason_name,  ss_data.deact.ss_ref, ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code);
       
       cm_result = cm_sups_cmd_deactivate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.deact,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         QM_MSG_HIGH("CM returned error for cm_sups_cmd_deactivate_exten() in qmi_voice_cm_if_sups_set_sups_service_call_forward");
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
         return; 
       }
       break;

     case QMI_VOICE_CM_SUPS_MODE_ENABLE:
       ss_data.act.ss_code = cmd_info_ptr->ss_code;
       ss_data.act.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.act.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
         //QM_MSG_HIGH("Could not add entry to the list ");
         /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
          return;
        }

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_4( "CFW :activate_cc_exten_per_subs() CFW reason : %s, ss_ref =%d, code_type :%d, bs_code=%d", 
                      cf_reason_name, ss_data.act.ss_ref,ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code);
       
       cm_result = cm_sups_cmd_activate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.act,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );

       #else
       QM_MSG_MED_4("CFW :activate_exten() CFW reason : %s, ss_ref =%d, code_type :%d, bs_code=%d", 
                    cf_reason_name, ss_data.act.ss_ref,  ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code);
       
       cm_result = cm_sups_cmd_activate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.act,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/      
       if(!cm_result)
       {
         QM_MSG_HIGH("CM returned error for cm_sups_cmd_activate_exten() in qmi_voice_cm_if_sups_set_sups_service_call_forward");
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
         return;
       }
       break;

     case QMI_VOICE_CM_SUPS_MODE_REG:
       ss_data.reg.ss_code = cmd_info_ptr->ss_code;
       ss_data.reg.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.reg.basic_service);
       if ( in_data_ptr->fwd_start_time_valid == TRUE && in_data_ptr->fwd_end_time_valid == TRUE )
       {
         QM_MSG_MED("Both fwd_start_time and fwd_end_time are valid for SUPS_MODE_REG");
         ss_data.reg.sups_time_info.time_present = TRUE;
         if( E_SUCCESS != qmi_voice_cm_sups_set_time_info(in_data_ptr->fwd_start_time, &ss_data.reg.sups_time_info.call_fwd_start_time) )
         {
           QM_MSG_ERROR("Sups set fwd_start_time info failed");
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
           return;
         }
         if( E_SUCCESS != qmi_voice_cm_sups_set_time_info(in_data_ptr->fwd_end_time, &ss_data.reg.sups_time_info.call_fwd_end_time) )
         {
           QM_MSG_ERROR("Sups set fwd_end_time info failed");
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
           return;
         }
       }

       /* filling call fwd address structure */
       if (0 < bcd_num_len)
       {
         ss_data.reg.fwd_to_num.present = TRUE;
         ss_data.reg.fwd_to_num.length = (byte) bcd_num_len;
         memscpy(ss_data.reg.fwd_to_num.data,sizeof(ss_data.reg.fwd_to_num.data), bcd_number, bcd_num_len);
       }
       else
       {
         ss_data.reg.fwd_to_num.present = FALSE;
       }

       if ( ((in_data_ptr->sups_service_info.reason ==  (int)QMI_VOICE_CM_SUPS_CCFC_REASON_NOREPLY ) || 
             ( in_data_ptr->sups_service_info.reason == (int)QMI_VOICE_CM_SUPS_CCFC_REASON_ALLCALL ) ||
             ( in_data_ptr->sups_service_info.reason == (int)QMI_VOICE_CM_SUPS_CCFC_REASON_ALLCOND ) )&&
            (in_data_ptr->no_reply_timer_valid == TRUE) && (in_data_ptr->no_reply_timer != 0))
       {
         ss_data.reg.nr_timer.present = TRUE;
         ss_data.reg.nr_timer.timer_value = (byte) in_data_ptr->no_reply_timer;
       }
       else
       {
         ss_data.reg.nr_timer.present = FALSE;
       }

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
         /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
         return;
        }

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_4("CFW :register_cc_exten_per_subs() CFW reason : %s, ss_ref =%d, code_type :%d, bs_code=%d", 
                    cf_reason_name, ss_data.reg.ss_ref, ss_data.reg.basic_service.code_type, ss_data.reg.basic_service.bs_code);
       
       cm_result = cm_sups_cmd_register_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.reg,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );

       #else
       QM_MSG_MED_4("CFW :register_exten() CFW reason : %s, ss_ref =%d, code_type :%d, bs_code=%d ",cf_reason_name, ss_data.reg.ss_ref, ss_data.reg.basic_service.code_type, ss_data.reg.basic_service.bs_code);
       
       cm_result = cm_sups_cmd_register_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                 &ss_data.reg,
                                                                 &dialed_digits,
                                                                 CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         QM_MSG_HIGH("CM returned error for cm_sups_cmd_register_exten() in qmi_voice_cm_if_sups_set_sups_service_call_forward");
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
         return;
       }
       break;

     case QMI_VOICE_CM_SUPS_MODE_ERASURE:
       ss_data.erase.ss_code = cmd_info_ptr->ss_code;
       ss_data.erase.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.erase.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF,
                                                         cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
         /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
         return;
       }
  

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_4( "CFW : erase_cc_exten_per_subs() CFW reason : %s, ss_ref =%d, code_type :  %d, bs_code=%d ", 
                      cf_reason_name, ss_data.erase.ss_ref, ss_data.erase.basic_service.code_type, ss_data.erase.basic_service.bs_code);
       
       cm_result = cm_sups_cmd_erase_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.erase,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );
        
       #else
       QM_MSG_MED_4("CFW :erase_exten() CFW reason : %s, ss_ref =%d, code_type :  %d, bs_code=%d ", 
                     cf_reason_name, ss_data.erase.ss_ref,ss_data.erase.basic_service.code_type, ss_data.erase.basic_service.bs_code);
       
       cm_result = cm_sups_cmd_erase_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                 &ss_data.erase,
                                                                 &dialed_digits,
                                                                 CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         QM_MSG_HIGH("CM returned error for cm_sups_cmd_erase_exten() in qmi_voice_cm_if_sups_set_sups_service_call_forward");
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
         return;
       }
       break;

     default:
       QM_MSG_HIGH_1("Unrecognized CFW mode value:  %d", qmi_voice_cm_sups_map_service_to_cm_mode(in_data_ptr->sups_service_info.service));
       qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
       break;
    }
  }


}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_set_sups_service_call_barring()

  DESCRIPTION
    Sets the Call Forwarding supplimentary services as per the received input

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_set_sups_service_call_barring
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean  cm_result = TRUE;
  qmi_voice_cm_if_set_sups_service_s *in_data_ptr = (qmi_voice_cm_if_set_sups_service_s *)(&params_ptr->data);
  int facility=0, status=0;
  uint32 service_class=0;
  char *password = NULL;
  qmi_voice_cmd_list_u_type  u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type  ss_data;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  cm_num_s_type            dialed_digits;
  cm_call_barring_list_s_type *barr_list_ptr = NULL;
  uint16 barr_list_len = 0;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY; 

 
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_set_sups_service_call_barring():");
  memset(&ss_data, 0, sizeof(ss_data));
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/  
  facility = in_data_ptr->sups_service_info.reason;

  QM_MSG_MED_2( "set_sups_service_call_barring Facility %d, status =%s ",
                     facility, ((in_data_ptr->sups_service_info.service == 2)? "unlock": "lock"));
  if(in_data_ptr->service_class_valid || in_data_ptr->service_class_ext_valid)
  {
    if(in_data_ptr->service_class_ext_valid)
    {
      service_class = in_data_ptr->service_class_ext;
    }
	else
	{
   	  service_class = in_data_ptr->service_class;
	}
    QM_MSG_MED_1("set_sups_service_call_barring service_class =%d", service_class);
    if ( !qmi_voice_cm_sups_service_class_is_valid(service_class) )
    {
      QM_MSG_ERROR_1("received invalid Service class %d", service_class);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->password_valid)
  {
    password = (char *)in_data_ptr->password;
    if((password == NULL) || (strlen(password) > QMI_VOICE_CM_IF_MAX_PWD_LEN))
    {
      QM_MSG_ERROR("Received invalid password parameters in set_sups_service_call_barring");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
      return;
    }
    else
    {
      QM_MSG_MED_1( "set_sups_service_call_barring passwd =%s",password);
    }
  }

  if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_DEACTIVATE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_DISABLE;
  }
  else if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_ACTIVATE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_ENABLE;
  }
  else if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_REGISTER)
  {
    status = QMI_VOICE_CM_SUPS_MODE_REG;
  }
  else if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_ERASE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_ERASURE;
  }
  else
  {
    QM_MSG_ERROR_1("Unrecognized service recieved in set_sups_call_barring %d", in_data_ptr->sups_service_info.service);
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INCOMPATIBLE_STATE,FALSE,FALSE);
    return;
  }

  if(in_data_ptr->password_valid)
  {
    cmd_info_ptr->ss_pwd.present = TRUE;
    memscpy(cmd_info_ptr->ss_pwd.password,sizeof(cmd_info_ptr->ss_pwd.password), password,QMI_VOICE_CM_IF_MAX_PWD_LEN);
  }  
  else
  {
    cmd_info_ptr->ss_pwd.present = FALSE;
  }
  if(!qmi_voice_cm_sups_set_facility_lock_is_valid( facility, status, service_class))
  {
    QM_MSG_HIGH("received invalid paramets in set_sups_service_call_barring");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
    return;
  }
  else
  {
    cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();
    cmd_info_ptr->ss_code = (uint8)qmi_voice_cm_sups_get_cb_ss_code(facility);

    /* fill the sups params required for sups string construction */
    memset(&ss_params, 0, sizeof(ss_params));
    ss_params.mode = (qmi_voice_cm_sups_mode_e_type)status;
    ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)cmd_info_ptr->ss_code;
    if(in_data_ptr->service_class_valid || in_data_ptr->service_class_ext_valid )
    {
      ss_params.service_class = (qmi_voice_cm_sups_class_e_type)service_class;
    }
    if(in_data_ptr ->password_valid)
    {
    ss_params.cmd.passwd.old_passwd = password;
    }
    else
    {
      ss_params.cmd.passwd.old_passwd = NULL;
    }
    /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
    check in future. The string should be sent to modem for call control */
    if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
    {
      QM_MSG_HIGH("Sups string construction failed");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;
    }
    else
    {
      QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
      memset(&dialed_digits,0,sizeof(dialed_digits));
      dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
      dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
    }

    if((in_data_ptr->barr_num_list_valid) && (in_data_ptr->barr_num_list_len > 0))
    {      
      /*Allocate memory for <cm_call_barring_list_s_type>*/
      barr_list_len = in_data_ptr->barr_num_list_len;
      QM_MSG_MED_1("barr_list_len for barr_num_list= %d", barr_list_len);
      barr_list_ptr = (cm_call_barring_list_s_type *) QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(cm_call_barring_list_s_type));
      if( NULL == barr_list_ptr )
      {
		  qmi_voice_mem_error();
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,TRUE,FALSE);
        return;
      }
      memset(barr_list_ptr, 0, sizeof(cm_call_barring_list_s_type));
      barr_list_ptr->call_barring_list_length = barr_list_len;
      
      barr_list_ptr->call_barring_num = (cm_called_party_bcd_no_s_type *) QMI_VOICE_CM_IF_MEM_ALLOC((barr_list_ptr->call_barring_list_length)*sizeof(cm_called_party_bcd_no_s_type));
      if( NULL == barr_list_ptr->call_barring_num )
      {
		  qmi_voice_mem_error();
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,TRUE,FALSE);
        return;
      }
      memset(barr_list_ptr->call_barring_num, 0, barr_list_len*sizeof(cm_called_party_bcd_no_s_type));
      qmi_voice_cm_util_copy_barr_num_list_from_qmi_to_cm(in_data_ptr->barr_num_list, barr_list_ptr->call_barring_num, barr_list_ptr->call_barring_list_length);
    }
    else
    {
      QM_MSG_MED_2("No numbers received in barr_num_list.barr_num_list_valid=%d, barr_num_list_len=%d", in_data_ptr->barr_num_list_valid, in_data_ptr->barr_num_list_len);
      if(facility == QMI_VOICE_CM_SUPS_BARR_INCOMINGNUMBER)
      {
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_MISSING_ARG,TRUE,FALSE);
        return;
      }
    }

    switch (status)
    {
      case QMI_VOICE_CM_SUPS_MODE_DISABLE:
        ss_data.deact.ss_code = cmd_info_ptr->ss_code;
        ss_data.deact.ss_ref = cmd_info_ptr->ss_ref;
        ss_data.deact.call_barring_num_list = barr_list_ptr;
        qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.deact.basic_service);

        if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
         {
           /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
         }

        if(ss_data.deact.call_barring_num_list)
        {
          ref_cnt_obj_init(ss_data.deact.call_barring_num_list, qmi_voice_cm_if_barr_list_ptr_destructor);
          QM_MSG_MED("ref to barr_list_ptr added");
        }

        #ifdef FEATURE_DUAL_SIM
        QM_MSG_MED_4("deactivate_cc_exten_per_subs(), call_barring ss_ref = %d facility=%d code_type = %d bs_code=%d", 
                     ss_data.deact.ss_ref, facility,ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code);
        
        cm_result = cm_sups_cmd_deactivate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                     (void*)params_ptr->header.handle,
                                                                     qmi_voice_cm_if_get_clientid(),
                                                                      &ss_data.deact,
                                                                      &dialed_digits,
                                                                      CM_ORIG_CLIENT_CATEG_USER,
                                                                      FALSE,
                                                                     (sys_modem_as_id_e_type)as_id );
        
        #else
        QM_MSG_MED_4("deactivate_exten(), call_barring ss_ref = %d facility=%d, code_type = %d bs_code=%d", 
                      ss_data.deact.ss_ref, facility, ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code);
        
        cm_result = cm_sups_cmd_deactivate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.deact,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
        #endif /*FEATURE_DUAL_SIM*/

        if(ss_data.deact.call_barring_num_list)
        {
          ref_cnt_obj_release(ss_data.deact.call_barring_num_list); //upon function return, release ref count obj
          QM_MSG_MED("ref to barr_list_ptr released");
        }

        if(!cm_result)
        {
          QM_MSG_HIGH("CM returned error for cm_sups_cmd_deactivate_exten() in set_sups_service_call_barring ");
          /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
          qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
          return;
        }
        break;

       case QMI_VOICE_CM_SUPS_MODE_ENABLE:
         
         ss_data.act.ss_code = cmd_info_ptr->ss_code;
         ss_data.act.ss_ref = cmd_info_ptr->ss_ref;
         ss_data.act.call_barring_num_list = barr_list_ptr;
         qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.act.basic_service);

         if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
         {
           /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
         }

        if(ss_data.act.call_barring_num_list)
        {
          ref_cnt_obj_init(ss_data.act.call_barring_num_list, qmi_voice_cm_if_barr_list_ptr_destructor);
          QM_MSG_MED("ref to barr_list_ptr added");
        }

         #ifdef FEATURE_DUAL_SIM
         QM_MSG_MED_4("activate_cc_exten_per_subs(),call_barring ss_ref = %d facility=%d, code_type = %d bs_code=%d", 
                      ss_data.act.ss_ref, facility, ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code);
         
         cm_result = cm_sups_cmd_activate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                      (void*)params_ptr->header.handle,
                                                                      qmi_voice_cm_if_get_clientid(),
                                                                       &ss_data.act,
                                                                       &dialed_digits,
                                                                       CM_ORIG_CLIENT_CATEG_USER,
                                                                       FALSE,
                                                                      (sys_modem_as_id_e_type)as_id );
         
         #else
         QM_MSG_MED_4("cm_sups_cmd_activate_exten(),call_barring ss_ref = %d facility=%d, code_type = %d bs_code=%d", 
                      ss_data.act.ss_ref, facility, ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code);
         
         cm_result = cm_sups_cmd_activate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.act,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
         #endif /*FEATURE_DUAL_SIM*/

        if(ss_data.act.call_barring_num_list)
        {
          ref_cnt_obj_release(ss_data.act.call_barring_num_list); //upon function return, release ref count obj
          QM_MSG_MED("ref to barr_list_ptr released");
        }

         if(!cm_result)
         {
           QM_MSG_HIGH("CM returned error for cm_sups_cmd_activate_exten() in set_sups_service_call_barring ");
           /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
           return;
         }
         break;

       case QMI_VOICE_CM_SUPS_MODE_REG:
         
         ss_data.reg.ss_code = cmd_info_ptr->ss_code;
         ss_data.reg.ss_ref = cmd_info_ptr->ss_ref;
         ss_data.reg.call_barring_num_list = barr_list_ptr;
         qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.reg.basic_service);

         if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
         {
           /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
         }

        if(ss_data.reg.call_barring_num_list)
        {
          ref_cnt_obj_init(ss_data.reg.call_barring_num_list, qmi_voice_cm_if_barr_list_ptr_destructor);
          QM_MSG_MED("ref to barr_list_ptr added");
        }

         #ifdef FEATURE_DUAL_SIM
         QM_MSG_MED_4("register_cc_exten_per_subs(),call_barring ss_ref = %d facility=%d, code_type = %d bs_code=%d", 
                       ss_data.reg.ss_ref, facility, ss_data.reg.basic_service.code_type, ss_data.reg.basic_service.bs_code);
         
         cm_result = cm_sups_cmd_register_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                      (void*)params_ptr->header.handle,
                                                                      qmi_voice_cm_if_get_clientid(),
                                                                       &ss_data.reg,
                                                                       &dialed_digits,
                                                                       CM_ORIG_CLIENT_CATEG_USER,
                                                                       FALSE,
                                                                      (sys_modem_as_id_e_type)as_id );
         
         #else
         QM_MSG_MED_4("register_exten(), call_barring ss_ref = %d facility=%d, code_type = %d bs_code=%d", 
                      ss_data.reg.ss_ref, facility, ss_data.reg.basic_service.code_type, ss_data.reg.basic_service.bs_code);
         
         cm_result = cm_sups_cmd_register_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.reg,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
         #endif /*FEATURE_DUAL_SIM*/

        if(ss_data.reg.call_barring_num_list)
        {
          ref_cnt_obj_release(ss_data.reg.call_barring_num_list); //upon function return, release ref count obj
          QM_MSG_MED("ref to barr_list_ptr released");
        }

         if(!cm_result)
         {
           QM_MSG_HIGH("CM returned error for cm_sups_cmd_register_exten() in set_sups_service_call_barring ");
           /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
           return;
         }
         break;

       case QMI_VOICE_CM_SUPS_MODE_ERASURE:
         
         ss_data.erase.ss_code = cmd_info_ptr->ss_code;
         ss_data.erase.ss_ref = cmd_info_ptr->ss_ref;
         ss_data.erase.call_barring_num_list = barr_list_ptr;
         qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.erase.basic_service);

         if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
         {
           /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
         }

        if(ss_data.erase.call_barring_num_list)
        {
          ref_cnt_obj_init(ss_data.erase.call_barring_num_list, qmi_voice_cm_if_barr_list_ptr_destructor);
          QM_MSG_MED("ref to barr_list_ptr added");
        }

         #ifdef FEATURE_DUAL_SIM
         QM_MSG_MED_4("erase_cc_exten_per_subs(), call_barring ss_ref = %d facility=%d, code_type = %d bs_code=%d", 
                      ss_data.erase.ss_ref, facility, ss_data.erase.basic_service.code_type, ss_data.erase.basic_service.bs_code);
         
         cm_result = cm_sups_cmd_erase_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                      (void*)params_ptr->header.handle,
                                                                      qmi_voice_cm_if_get_clientid(),
                                                                       &ss_data.erase,
                                                                       &dialed_digits,
                                                                       CM_ORIG_CLIENT_CATEG_USER,
                                                                       FALSE,
                                                                      (sys_modem_as_id_e_type)as_id );
         
         #else
         QM_MSG_MED_4("erase_exten(),call_barring ss_ref = %d facility=%d, code_type = %d bs_code=%d", 
                       ss_data.erase.ss_ref, facility, ss_data.erase.basic_service.code_type, ss_data.erase.basic_service.bs_code);
         
         cm_result = cm_sups_cmd_erase_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.erase,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
         #endif /*FEATURE_DUAL_SIM*/

        if(ss_data.erase.call_barring_num_list)
        {
          ref_cnt_obj_release(ss_data.erase.call_barring_num_list); //upon function return, release ref count obj
          QM_MSG_MED("ref to barr_list_ptr released");
        }

         if(!cm_result)
         {
           QM_MSG_HIGH("CM returned error for cm_sups_cmd_erase_exten() in set_sups_service_call_barring ");
           /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
           return;
         }
         break;

       default:
         QM_MSG_HIGH_1("Unrecognized status value:  %d", status);
         /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
         return;
    }
  }
}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_set_sups_service_call_waiting()

  DESCRIPTION
    Sets the Call Waiting supplimentary services as per the received input

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_set_sups_service_call_waiting
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean cm_result = TRUE;
  qmi_voice_cm_if_set_sups_service_s *in_data_ptr = (qmi_voice_cm_if_set_sups_service_s *)(&params_ptr->data);
  int  status =-1 ;
  uint32 service_class=0;
  qmi_voice_cmd_list_u_type  u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type  ss_data;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY; 

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_set_sups_service_call_waiting():");
  memset(&ss_data, 0, sizeof(ss_data));
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/  
  QM_MSG_MED_1( "qmi_voice_cm_if_sups_set_sups_service_call_waiting status =%s ",
                     ((in_data_ptr->sups_service_info.service == 2)? "unlock": "lock"));
  if(in_data_ptr->service_class_valid || in_data_ptr->service_class_ext_valid)
  {
    if(in_data_ptr->service_class_ext_valid)
    {
      service_class = in_data_ptr->service_class_ext;
    }
	else
	{
	  service_class = in_data_ptr->service_class;
	}
    QM_MSG_MED_1("set_sups_service_call_waiting service_class =%d", service_class);
    if ( !qmi_voice_cm_sups_service_class_is_valid(service_class) )
    {
      QM_MSG_ERROR_1("received invalid Service class %d", service_class);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_DEACTIVATE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_DISABLE;
  }
  if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_ACTIVATE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_ENABLE;
  }
  if(!qmi_voice_cm_sups_cmd_set_call_wait_is_valid(status, service_class))
  {
    QM_MSG_HIGH("received invalid parameters in set_sups_service_call_waiting");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
    return;
  }
  else
  {
    cmd_info_ptr->ss_code = (uint8)qmi_voice_cm_sups_cw;
    cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

    /* fill the sups params required for sups string construction */
    memset(&ss_params, 0, sizeof(ss_params));
    ss_params.mode = (qmi_voice_cm_sups_mode_e_type)status;
    ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)cmd_info_ptr->ss_code;
    ss_params.service_class = (qmi_voice_cm_sups_class_e_type)service_class;

    /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
    check in future. The string should be sent to modem for any call control */
    if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
    {
      QM_MSG_HIGH("Sups string construction failed");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;  
    }
    else
    {
      QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
      memset(&dialed_digits,0,sizeof(dialed_digits));
      dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
      dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
    }

    switch (status)
    {
     case QMI_VOICE_CM_SUPS_MODE_DISABLE:
       ss_data.deact.ss_code = (uint8)qmi_voice_cm_sups_cw;
       ss_data.deact.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.deact.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
           //QM_MSG_HIGH("Could not add entry to the list ");
           /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
       }

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_HIGH_3("cm_sups_cmd_deactivate_cc_exten_per_subs(), qmi_voice_cm_if_sups_set_sups_service_call_waiting ss_ref = %d code_type = %d bs_code=%d", 
                                       ss_data.deact.ss_ref, 
                                       ss_data.deact.basic_service.code_type, 
                                       ss_data.deact.basic_service.bs_code);
       cm_result = cm_sups_cmd_deactivate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.deact,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );
       
       #else
       QM_MSG_HIGH_3("cm_sups_cmd_deactivate_exten(), qmi_voice_cm_if_sups_set_sups_service_call_waiting ss_ref = %d, code_type = %d bs_code=%d",
                                       ss_data.deact.ss_ref,
                                       ss_data.deact.basic_service.code_type,
                                       ss_data.deact.basic_service.bs_code);
       cm_result = cm_sups_cmd_deactivate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.deact,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
          return; 
       }
       break;

     case QMI_VOICE_CM_SUPS_MODE_ENABLE:
       ss_data.act.ss_code = (uint8)qmi_voice_cm_sups_cw;
       ss_data.act.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.act.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
           //QM_MSG_HIGH("Could not add entry to the list ");
           /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
       }

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_3("cm_sups_cmd_activate_cc_exten_per_subs(), qmi_voice_cm_if_sups_set_sups_service_call_waiting ss_ref = %d, code_type = %d bs_code=%d",
                                  ss_data.act.ss_ref,
                                  ss_data.act.basic_service.code_type,
                                  ss_data.act.basic_service.bs_code);
       cm_result = cm_sups_cmd_activate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.act,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );
       
       #else
       QM_MSG_MED_3("cm_sups_cmd_activate_exten(), qmi_voice_cm_if_sups_set_sups_service_call_waiting ss_ref = %d code_type = %d bs_code=%d",
                                   ss_data.act.ss_ref, 
                                   ss_data.act.basic_service.code_type, 
                                   ss_data.act.basic_service.bs_code);
       cm_result = cm_sups_cmd_activate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.act,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
         return; 
       }
       break;

     default:
         QM_MSG_HIGH_1("Unrecognized status value:  %d", status);
         /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
         return;
    }
  }
}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_set_sups_service_clip()

  DESCRIPTION
    Sets the CLIP supplimentary services as per the received input

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_set_sups_service_clip
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean cm_result = TRUE;
  qmi_voice_cm_if_set_sups_service_s *in_data_ptr = (qmi_voice_cm_if_set_sups_service_s *)(&params_ptr->data);
  int  status = QMI_VOICE_CM_SUPS_MODE_NONE ;
  uint32 service_class=0;
  qmi_voice_cmd_list_u_type  u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type  ss_data;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY; 

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_set_sups_service_clip():");
  memset(&ss_data, 0, sizeof(ss_data));
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/  
  QM_MSG_MED_1( "qmi_voice_cm_if_sups_set_sups_service_clip request =%s ",
                     ((in_data_ptr->sups_service_info.service == 2)? "deactivate": "activate"));

  if(in_data_ptr->service_class_valid || in_data_ptr->service_class_ext_valid)
  {
    if(in_data_ptr->service_class_ext_valid)
    {
      service_class = in_data_ptr->service_class_ext;
    }
    else
    {
      service_class = in_data_ptr->service_class;
    }
    QM_MSG_MED_1("qmi_voice_cm_if_sups_set_sups_service_clip service_class =%d", service_class);
    if ( !qmi_voice_cm_sups_service_class_is_valid(service_class) )
    {
      QM_MSG_ERROR_1("received invalid Service class %d", service_class);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_DEACTIVATE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_DISABLE;
  }
  if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_ACTIVATE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_ENABLE;
  }
  if(!qmi_voice_cm_sups_cmd_set_clip_is_valid(status, service_class))
  {
    QM_MSG_HIGH("received invalid parameters in set_sups_service_clip");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
    return;
  }
  else
  {
    cmd_info_ptr->ss_code = (uint8)qmi_voice_cm_sups_clip;
    cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

    /* fill the sups params required for sups string construction */
    memset(&ss_params, 0, sizeof(ss_params));
    ss_params.mode = (qmi_voice_cm_sups_mode_e_type)status;
    ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)cmd_info_ptr->ss_code;
    ss_params.service_class = (qmi_voice_cm_sups_class_e_type)service_class;

    /* Invoke Sups String Construction. This has to be invoked even if qmi-voice doesn't do FDN
    check in future. The string should be sent to modem for any call control */
    if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
    {
      QM_MSG_HIGH("Sups string construction failed");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;  
    }
    else
    {
      QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
      memset(&dialed_digits,0,sizeof(dialed_digits));
      dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
      dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
    }

    switch (status)
    {
     case QMI_VOICE_CM_SUPS_MODE_DISABLE:
       ss_data.deact.ss_code = (uint8)qmi_voice_cm_sups_clip;
       ss_data.deact.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.deact.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
           /* Out of command list buffer, send failure response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
       }

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_3("cm_sups_cmd_deactivate_cc_exten_per_subs(), qmi_voice_cm_if_sups_set_sups_service_clip ss_ref = %d,  code_type = %d bs_code=%d", ss_data.deact.ss_ref, ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code);
       cm_result = cm_sups_cmd_deactivate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.deact,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );
       
       #else
       QM_MSG_MED_3("cm_sups_cmd_deactivate_exten(), qmi_voice_cm_if_sups_set_sups_service_clip ss_ref = %d code_type = %d bs_code=%d", ss_data.deact.ss_ref, ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code);
       cm_result = cm_sups_cmd_deactivate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.deact,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         /*Out of command list buffer, send failure response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
          return; 
       }
       break;

     case QMI_VOICE_CM_SUPS_MODE_ENABLE:
       ss_data.act.ss_code = (uint8)qmi_voice_cm_sups_clip;
       ss_data.act.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.act.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
           /* Out of command list buffer, send failure response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
       }

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_3("cm_sups_cmd_activate_cc_exten_per_subs(), qmi_voice_cm_if_sups_set_sups_service_clip ss_ref = %d code_type = %d bs_code=%d", ss_data.act.ss_ref, ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code);
       cm_result = cm_sups_cmd_activate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.act,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );
       
       #else
       QM_MSG_MED_3("cm_sups_cmd_activate_exten(), qmi_voice_cm_if_sups_set_sups_service_clip ss_ref = %d code_type = %d bs_code=%d", ss_data.act.ss_ref, ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code);
       cm_result = cm_sups_cmd_activate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.act,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         /* Out of command list buffer, send failure response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
         return; 
       }
       break;

     default:
         QM_MSG_HIGH_1("Unrecognized status value:  %d", status);
         /* Out of command list buffer, send failure response*/
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
         return;
    }
  }
}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_set_sups_service_colp()

  DESCRIPTION
    Sets the COLP supplimentary services as per the received input

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_set_sups_service_colp
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean cm_result = TRUE;
  qmi_voice_cm_if_set_sups_service_s *in_data_ptr = (qmi_voice_cm_if_set_sups_service_s *)(&params_ptr->data);
  int  status = QMI_VOICE_CM_SUPS_MODE_NONE ;
  uint32 service_class=0;
  qmi_voice_cmd_list_u_type  u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type  ss_data;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY; 

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_set_sups_service_colp():");
  memset(&ss_data, 0, sizeof(ss_data));
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/  
  QM_MSG_MED_1( "qmi_voice_cm_if_sups_set_sups_service_colp request =%s ",
                     ((in_data_ptr->sups_service_info.service == 2)? "deactivate": "activate"));

  if(in_data_ptr->service_class_valid || in_data_ptr->service_class_ext_valid)
  {
    if(in_data_ptr->service_class_ext_valid)
    {
      service_class = in_data_ptr->service_class_ext;
    }
    else
    {
      service_class = in_data_ptr->service_class;
    }
    QM_MSG_MED_1("qmi_voice_cm_if_sups_set_sups_service_colp service_class =%d", service_class);
    if ( !qmi_voice_cm_sups_service_class_is_valid(service_class) )
    {
      QM_MSG_ERROR_1("received invalid Service class %d", service_class);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_DEACTIVATE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_DISABLE;
  }
  if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_ACTIVATE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_ENABLE;
  }
  if(!qmi_voice_cm_sups_cmd_set_colp_is_valid(status, service_class))
  {
    QM_MSG_HIGH("received invalid parameters in set_sups_service_colp");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
    return;
  }
  else
  {
    cmd_info_ptr->ss_code = (uint8)qmi_voice_cm_sups_colp;
    cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

    /* fill the sups params required for sups string construction */
    memset(&ss_params, 0, sizeof(ss_params));
    ss_params.mode = (qmi_voice_cm_sups_mode_e_type)status;
    ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)cmd_info_ptr->ss_code;
    ss_params.service_class = (qmi_voice_cm_sups_class_e_type)service_class;

    /* Invoke Sups String Construction. This has to be invoked even if qmi-voice doesn't do FDN
    check in future. The string should be sent to modem for any call control */
    if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
    {
      QM_MSG_HIGH("Sups string construction failed");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;  
    }
    else
    {
      QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
      memset(&dialed_digits,0,sizeof(dialed_digits));
      dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
      dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
    }

    switch (status)
    {
     case QMI_VOICE_CM_SUPS_MODE_DISABLE:
       ss_data.deact.ss_code = (uint8)qmi_voice_cm_sups_colp;
       ss_data.deact.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.deact.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
           /* Out of command list buffer, send failure response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
       }

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_3("cm_sups_cmd_deactivate_cc_exten_per_subs(), qmi_voice_cm_if_sups_set_sups_service_colp ss_ref = %d  code_type = %d bs_code=%d", ss_data.deact.ss_ref, ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code);
       cm_result = cm_sups_cmd_deactivate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.deact,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );
       
       #else
       QM_MSG_MED_3("cm_sups_cmd_deactivate_cc_exten_per_subs(), qmi_voice_cm_if_sups_set_sups_service_colp ss_ref = %d code_type = %d bs_code=%d", ss_data.deact.ss_ref, ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code);
       cm_result = cm_sups_cmd_deactivate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.deact,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         QM_MSG_HIGH("CM returned error for cm_sups_cmd_deactivate_exten() in set_sups_service_colp ");
         /* Out of command list buffer, send failure response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
          return; 
       }
       break;

     case QMI_VOICE_CM_SUPS_MODE_ENABLE:
       ss_data.act.ss_code = (uint8)qmi_voice_cm_sups_colp;
       ss_data.act.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.act.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
           /* Out of command list buffer, send failure response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
       }

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_3("cm_sups_cmd_activate_cc_exten_per_subs(), qmi_voice_cm_if_sups_set_sups_service_colp ss_ref = %d code_type = %d bs_code=%d", ss_data.act.ss_ref, ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code);
       cm_result = cm_sups_cmd_activate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.act,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );
       
       #else
       QM_MSG_MED_2("cm_sups_cmd_activate_exten(), qmi_voice_cm_if_sups_set_sups_service_colp ss_ref = %d, code_type = %d bs_code=%d", ss_data.act.ss_ref, ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code);
       cm_result = cm_sups_cmd_activate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.act,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         /* Out of command list buffer, send failure response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
         return; 
       }
       break;

     default:
         QM_MSG_HIGH_1("Unrecognized status value:  %d", status);
         /* Out of command list buffer, send failure response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
         return;
    }
  }
}


/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_set_sups_service_colr()

  DESCRIPTION
    Sets the COLR/TIR supplimentary services as per the received input (Applicable only for IMS)

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_set_sups_service_colr
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean cm_result = TRUE;
  qmi_voice_cm_if_set_sups_service_s *in_data_ptr = (qmi_voice_cm_if_set_sups_service_s *)(&params_ptr->data);
  int  status = QMI_VOICE_CM_SUPS_MODE_NONE ;
  uint32 service_class=0;
  qmi_voice_cmd_list_u_type  u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type  ss_data;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY,colr_pi=0; 

  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  memset(&ss_data, 0, sizeof(ss_data));
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/  
  QM_MSG_MED_1( "qmi_voice_cm_if_sups_set_sups_service_colr request =%s ",
                     ((in_data_ptr->sups_service_info.service == 2)? "deactivate": "activate"));

  if(in_data_ptr->service_class_valid || in_data_ptr->service_class_ext_valid)
  {
    if(in_data_ptr->service_class_ext_valid)
    {
      service_class = in_data_ptr->service_class_ext;
    }
    else
    {
      service_class = in_data_ptr->service_class;
    }
    QM_MSG_MED_1("qmi_voice_cm_if_sups_set_sups_service_colr service_class =%d", service_class);
    if ( !qmi_voice_cm_sups_service_class_is_valid(service_class) )
    {
      QM_MSG_ERROR_1("received invalid Service class in colr %d", service_class);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_DEACTIVATE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_DISABLE;
  }
  if(in_data_ptr->sups_service_info.service == QMI_VOICE_CM_SUPS_SERVICE_ACTIVATE)
  {
    status = QMI_VOICE_CM_SUPS_MODE_ENABLE;
  }

  if(!qmi_voice_cm_sups_cmd_set_colp_is_valid(status, service_class))
  {
    QM_MSG_HIGH("received invalid parameters in set_sups_service_colr");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
    return;
  }
  else
  {
    cmd_info_ptr->ss_code = (uint8)qmi_voice_cm_sups_colr;
    cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

    /* fill the sups params required for sups string construction */
    memset(&ss_params, 0, sizeof(ss_params));
    ss_params.mode = (qmi_voice_cm_sups_mode_e_type)status;
    ss_params.code = (qmi_voice_cm_sups_operation_code_e_type)cmd_info_ptr->ss_code;
    ss_params.service_class = (qmi_voice_cm_sups_class_e_type)service_class;

    /* Invoke Sups String Construction. This has to be invoked even if qmi-voice doesn't do FDN
    check in future. The string should be sent to modem for any call control */
    if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
    {
      QM_MSG_HIGH("Sups string construction failed");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;  
    }
    else
    {
      QM_MSG_MED_1( "Sups String constructed is %s", ss_buf);
      memset(&dialed_digits,0,sizeof(dialed_digits));
      dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
      dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
    }

    if(in_data_ptr->colr_pi_valid)
    {
      QM_MSG_MED_1("Received colr_pi %d", in_data_ptr->colr_pi);
      colr_pi= in_data_ptr->colr_pi;
      dialed_digits.pi = colr_pi;
    }

    switch (status)
    {
     case QMI_VOICE_CM_SUPS_MODE_DISABLE:
       ss_data.deact.ss_code = (uint8)qmi_voice_cm_sups_colr;
       ss_data.deact.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.deact.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
           /* Out of command list buffer, send failure response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
       }

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_3("cm_sups_cmd_deactivate_cc_exten_per_subs(), qmi_voice_cm_if_sups_set_sups_service_colr ss_ref = %d code_type = %d bs_code=%d", ss_data.deact.ss_ref, ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code);
       cm_result = cm_sups_cmd_deactivate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.deact,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );
       
       #else
       QM_MSG_MED_3("cm_sups_cmd_deactivate_exten(), qmi_voice_cm_if_sups_set_sups_service_colr ss_ref = %d code_type = %d bs_code=%d", ss_data.deact.ss_ref, ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code);
       cm_result = cm_sups_cmd_deactivate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.deact,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         /* Out of command list buffer, send failure response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
          return; 
       }
       break;

     case QMI_VOICE_CM_SUPS_MODE_ENABLE:
       ss_data.act.ss_code = (uint8)qmi_voice_cm_sups_colr;
       ss_data.act.ss_ref = cmd_info_ptr->ss_ref;
       qmi_voice_cm_sups_set_bsg_info(service_class, &ss_data.act.basic_service);

       if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                        QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                        QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF,
                                                        cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
       {
           /* Out of command list buffer, send failure response */
           qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
           return;
       }

       #ifdef FEATURE_DUAL_SIM
       QM_MSG_MED_1("cm_sups_cmd_activate_cc_exten_per_subs(), set_sups_service_colr ss_ref = %d ", ss_data.act.ss_ref);
       QM_MSG_MED_2("cm_sups_cmd_activate_cc_exten_per_subs(), set_sups_service_colr code_type = %d bs_code=%d", ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code);
       cm_result = cm_sups_cmd_activate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                    (void*)params_ptr->header.handle,
                                                                    qmi_voice_cm_if_get_clientid(),
                                                                     &ss_data.act,
                                                                     &dialed_digits,
                                                                     CM_ORIG_CLIENT_CATEG_USER,
                                                                     FALSE,
                                                                    (sys_modem_as_id_e_type)as_id );
       
       #else
       QM_MSG_MED_1("cm_sups_cmd_activate_exten(), set_sups_service_colr ss_ref = %d ", ss_data.act.ss_ref);
       QM_MSG_MED_2("cm_sups_cmd_activate_exten(), set_sups_service_colr code_type = %d bs_code=%d", ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code);
       cm_result = cm_sups_cmd_activate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                 (void*)params_ptr->header.handle,
                                                                 qmi_voice_cm_if_get_clientid(),
                                                                  &ss_data.act,
                                                                  &dialed_digits,
                                                                  CM_ORIG_CLIENT_CATEG_USER);
       #endif /*FEATURE_DUAL_SIM*/
       if(!cm_result)
       {
         QM_MSG_HIGH("CM returned error for cm_sups_cmd_activate_exten() in set_sups_service_colr ");
         /* Out of command list buffer, send failure response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
         return; 
       }
       break;

     default:
         QM_MSG_HIGH_1("Unrecognized status value:  %d", status);
         /* Out of command list buffer, send failure response */
         qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
         return;
    }
  }
}/*qmi_voice_cm_if_sups_set_sups_service_colr*/

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_answer_ussd()

  DESCRIPTION
    Send the user's response to the network initiated ussd request.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_answer_ussd
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cmd_list_public_type cmd_info;
  cm_uss_res_params_s_type uss_res_parms;
  char ussd_str[QMI_VOICE_CM_IF_MAX_USS_DATA_LEN];
  char ussd_gsm7_ext_str[QMI_VOICE_CM_IF_MAX_USS_DATA_LEN];
  byte temp_buf[QMI_VOICE_CM_IF_MAX_USS_DATA_LEN];
  uint8 gsm7_ext_str_len=0;  
  uint8 ussd_str_len = 0;
  voice_answer_ussd_req_msg_v02 *ans_ussd_info;
  boolean cm_result;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY; 
  uint8 conv_result = 0;
  size_t num_conv_chars = 0;
  uint8 num_bytes = 0;
  int i;
  boolean send_gsm7 = FALSE;
              
/*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );
/*-----------------------------------------------------------------------*/

  memset(ussd_str, 0, sizeof(ussd_str) );
  memset(ussd_gsm7_ext_str, 0, sizeof(ussd_gsm7_ext_str) );
  memset(temp_buf, 0, sizeof(temp_buf) );
  
  /* If the sys mode is not GW, send error response */
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
 qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/

  ans_ussd_info = &params_ptr->data.answer_ussd;

  memset(&uss_res_parms,0,sizeof(uss_res_parms));
  memset(&cmd_info,0,sizeof(cmd_info));

  /* case where user is responding for MT USSD request */
  if (qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_SUPS_USS_IND, &cmd_info, as_id ) == E_SUCCESS)
  {
    if((ans_ussd_info->uss_info.uss_data_len == 0) || (ans_ussd_info->uss_info.uss_data_len > QMI_VOICE_USS_DATA_MAX_V02))
    {
      QM_MSG_ERROR_1("Invalid User data length(%d) for ussd response", ans_ussd_info->uss_info.uss_data_len);
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_MALFORMED_MSG,FALSE,FALSE);
      return;
    }
    else if((ans_ussd_info->uss_info.uss_dcs < USS_DCS_ASCII_V02) || (ans_ussd_info->uss_info.uss_dcs > USS_DCS_UCS2_V02) )
    {
      QM_MSG_ERROR_1("Invalid data coding scheme(%d) for ussd response", ans_ussd_info->uss_info.uss_dcs);
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_MALFORMED_MSG,FALSE,FALSE);
      return;
    }
    else
    {
      /* Fill the response params to be sent to CM */
      uss_res_parms.uss_res_data.data_type =  (cm_ss_conf_e_type)CM_USS_RES_SS_DATA;
      uss_res_parms.uss_res_data.data.uss_data.present = TRUE;
      uss_res_parms.invoke_id = (uint8)cmd_info.sub_id;
      QM_MSG_MED_2("Invoke ID Retrieved from Reqlist ss_ref=%d, subid=%d", cmd_info.sub.sups.ss_ref, cmd_info.sub_id);

      if( ans_ussd_info->uss_info.uss_dcs == USS_DCS_ASCII_V02)
      {
        ussd_str_len = cm_util_ascii_to_gsm_alphabet((byte *)ussd_str, (const byte *)ans_ussd_info->uss_info.uss_data, ans_ussd_info->uss_info.uss_data_len);
        if(ussd_str_len > MAX_USS_CHAR)
        {
          ussd_str_len = MAX_USS_CHAR;
        }
        QM_MSG_MED_2( "Response ussd string in 7BIT  format = %s length = %d",ussd_str, ussd_str_len );
        /* Because of restriction in CM, need to check if the data has to be cutdown */
        memscpy(uss_res_parms.uss_res_data.data.uss_data.ussData,sizeof(uss_res_parms.uss_res_data.data.uss_data.ussData), ussd_str, (byte)ussd_str_len);
        uss_res_parms.uss_res_data.data.uss_data.size = (byte)ussd_str_len;
        uss_res_parms.uss_res_data.data.uss_data.uss_data_coding_scheme = 0x0F;
      }
      else if(ans_ussd_info->uss_info.uss_dcs == USS_DCS_8BIT_V02)
      {
        /* Because of restriction in CM, need to check if the data has to be cutdown */
        ussd_str_len = (ans_ussd_info->uss_info.uss_data_len > MAX_USS_CHAR) ? MAX_USS_CHAR : ans_ussd_info->uss_info.uss_data_len;
        memscpy(uss_res_parms.uss_res_data.data.uss_data.ussData, sizeof(uss_res_parms.uss_res_data.data.uss_data.ussData), ans_ussd_info->uss_info.uss_data , (byte)ussd_str_len);
        uss_res_parms.uss_res_data.data.uss_data.size = (byte)ussd_str_len;
        uss_res_parms.uss_res_data.data.uss_data.uss_data_coding_scheme = CM_USSD_DCS_8_BIT;
      }
      else
      {
        /* DCS is UCS2 */
        /* Because of restriction in CM, need to check if the data has to be cutdown */
        ussd_str_len = (ans_ussd_info->uss_info.uss_data_len > MAX_USS_CHAR) ? MAX_USS_CHAR : ans_ussd_info->uss_info.uss_data_len;
        
        QM_MSG_MED_1( "UCS2 to GSM7 Converstion ucs2_len = %d",ussd_str_len);
        
        conv_result = cm_util_utf16_to_gsm7((uint16 *)ans_ussd_info->uss_info.uss_data,
                                            (ussd_str_len/2),
                                            (uint8 *)ussd_str,
                                            QMI_VOICE_CM_IF_MAX_USS_DATA_LEN,
                                            (size_t*)&num_conv_chars);

        QM_MSG_MED_1( "UCS2 to GSM7 Converstion result = %d",conv_result);
        QM_MSG_MED_1( "UCS2 to GSM7 Converstion num_conv_chars = %d",num_conv_chars);

        /* Check the boundary */
        if ( (2*num_conv_chars > sizeof(ans_ussd_info->uss_info.uss_data)) || (num_conv_chars > sizeof(ussd_str)) )
        {
          QM_MSG_ERROR_3( "num_conv_chars %d is out of the bound of array ans_ussd_info->uss_info.uss_data %d or ussd_str %d",
                           num_conv_chars,
                           sizeof(ans_ussd_info->uss_info.uss_data),
                           sizeof(ussd_str) );
          return;
        }

        if(conv_result & CHR_CVRT_INACCURATE)
        {
          if(qmi_voice_util_check_if_gsm7_ext_set((uint16 *) ans_ussd_info->uss_info.uss_data,
                                                  (uint8)sizeof(ans_ussd_info->uss_info.uss_data),
                                                  (uint8 *)ussd_str,
                                                  (uint8)sizeof(ussd_str),
                                                  (uint8)num_conv_chars,
                                                  (uint8 *)ussd_gsm7_ext_str,&gsm7_ext_str_len))
          {
            send_gsm7 = TRUE;
          }
        }
        else if(conv_result & CHR_CVRT_SUCCESS)
        {
          send_gsm7 = TRUE;
        }
        
        if(send_gsm7)
        {
          /* Check the boundary */
          if ( (gsm7_ext_str_len >= sizeof(ussd_gsm7_ext_str)) || (gsm7_ext_str_len <= 0) )
          {
            QM_MSG_ERROR_2( "gsm7_ext_str_len %d is out of bound of ussd_gsm7_ext_str %d",
                             gsm7_ext_str_len,
                             sizeof(ussd_gsm7_ext_str) );
            return;
          }
          /* pack the string to 7-bit format  */
          num_bytes = cm_util_ussd_pack( temp_buf,
                         (const byte *)ussd_gsm7_ext_str,
                         gsm7_ext_str_len);
          memscpy(uss_res_parms.uss_res_data.data.uss_data.ussData,
                  sizeof(uss_res_parms.uss_res_data.data.uss_data.ussData), 
                  temp_buf , 
                  (byte)num_bytes);
          uss_res_parms.uss_res_data.data.uss_data.size = (num_bytes > MAX_USS_CHAR) ? MAX_USS_CHAR : num_bytes;
          uss_res_parms.uss_res_data.data.uss_data.uss_data_coding_scheme = 0x0F;
          QM_MSG_MED_2( "Convertnig UCS2 to GSM 7-bit:EXT-len=%d,PackLen=%d",gsm7_ext_str_len,uss_res_parms.uss_res_data.data.uss_data.size);            
  
          for(i=0;i<num_bytes;i++)
          {
            QM_MSG_MED_2("7-bit BYTE %d is %x\n",i,temp_buf[i]);
          }
        }
        else
        {
          QM_MSG_MED_1( "Sending UCS2 data len = %d",ussd_str_len);
        memscpy(uss_res_parms.uss_res_data.data.uss_data.ussData,sizeof(uss_res_parms.uss_res_data.data.uss_data.ussData), ans_ussd_info->uss_info.uss_data , (byte)ussd_str_len);
        uss_res_parms.uss_res_data.data.uss_data.size = (byte)ussd_str_len;
        uss_res_parms.uss_res_data.data.uss_data.uss_data_coding_scheme = CM_USSD_DCS_UCS2;
        }
    }
    }

    if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                     QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                     QMI_VOICE_CM_IF_EVT_NONE,
                                                     uss_res_parms.invoke_id, NULL, 0, as_id ) != E_SUCCESS )
    {
        /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
        return;
    }


    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_answer_ussd :: cm_sups_cmd_uss_res_per_subs() with invoke_id %d", uss_res_parms.invoke_id);
    cm_result = cm_sups_cmd_uss_res_per_subs(qmi_voice_cm_if_sups_command_callback,
                                    (void*)params_ptr->header.handle,
                                    qmi_voice_cm_if_get_clientid(),
                                    &uss_res_parms,(sys_modem_as_id_e_type)as_id);
    #else
    QM_MSG_HIGH_1("qmi_voice_cm_if_sups_answer_ussd :: cm_sups_cmd_uss_res() with invoke_id %d", uss_res_parms.invoke_id);
    cm_result = cm_sups_cmd_uss_res(qmi_voice_cm_if_sups_command_callback,
                                    (void*)params_ptr->header.handle,
                                    qmi_voice_cm_if_get_clientid(),
                                    &uss_res_parms);    
    #endif /*FEATURE_DUAL_SIM*/
    if(!cm_result)
    {
      /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
    }
    else
    {
      QM_MSG_HIGH("CM returned Success for cm_sups_cmd_uss_res() in Answer USSD freeing Existing INDICATION");
      qmi_voice_cmd_list_free( cmd_info.hdl );
    }
  }
  else
  {
    QM_MSG_ERROR("Network is not waiting for any ussd response from user");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INCOMPATIBLE_STATE,FALSE,FALSE);
  }

} /* qmi_voice_cm_if_sups_answer_ussd */

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_orig_ussd()

  DESCRIPTION
    Invoke CM API to originate the sups ussd request

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_orig_ussd
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  voice_orig_ussd_req_msg_v02 *in_data_ptr = &params_ptr->data.ussd_orig_info;
  qmi_voice_cmd_list_public_type info_ptr;
  cm_uss_params_s_type uss_cmd_parms;
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  boolean cm_result;
  byte  ussd_dcs=CM_USSD_DCS_UNSPECIFIED;
  cm_num_s_type            dialed_digits;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;  
  /*-----------------------------------------------------------------------*/
  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  memset(&uss_cmd_parms, 0, sizeof(uss_cmd_parms));
  memset(&info_ptr, 0, sizeof(info_ptr));

  /* If the sys mode is not GW, send error response */
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
   qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  if((in_data_ptr->uss_info.uss_data_len == 0) || ((in_data_ptr->uss_info.uss_data_len >= QMI_VOICE_USS_DATA_MAX_V02)) || 
      (in_data_ptr->uss_info.uss_dcs < USS_DCS_ASCII_V02  ) || (in_data_ptr->uss_info.uss_dcs > USS_DCS_UCS2_V02 ))
  {
    QM_MSG_HIGH("Received ORIG_USSD with Invalid Data");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
    return;
  }
  else
  {
    QM_MSG_MED_2("ORIG_USSD string format = %d, length = %d", in_data_ptr->uss_info.uss_dcs, in_data_ptr->uss_info.uss_data_len);
    if(in_data_ptr->uss_info.uss_dcs == USS_DCS_ASCII_V02)
    {
      ussd_dcs = CM_USSD_DCS_UNSPECIFIED;
    }
    else if(in_data_ptr->uss_info.uss_dcs == USS_DCS_8BIT_V02)
    {
      ussd_dcs = CM_USSD_DCS_8_BIT;
    }
    else /*UCS2 Format*/
    {
      ussd_dcs = CM_USSD_DCS_UCS2;
    }

    if(in_data_ptr->uss_info.uss_data_len > QMI_VOICE_USS_DATA_MAX_V02)
    {
      QM_MSG_MED("converted USSD charecters exceed maximum length");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
      return;
    }

    cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();;

    /* case where USSD request is in progress */
    if (qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_SUPS_USS_IND, &info_ptr, as_id ) == E_SUCCESS)
    {
       QM_MSG_HIGH("One instance of USSD Already exists");
       qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INCOMPATIBLE_STATE,FALSE,FALSE);
       return;
    }
    else /* case where MO USSD request is initiated */
    {
      uss_cmd_parms.ss_ref = cmd_info_ptr->ss_ref;
      uss_cmd_parms.uss_data.present = TRUE;
      if(in_data_ptr->uss_info.uss_data_len < MAX_USS_CHAR)
      {
        uss_cmd_parms.uss_data.size =  in_data_ptr->uss_info.uss_data_len;
      }
      else
      {
        uss_cmd_parms.uss_data.size = MAX_USS_CHAR;
      }
      memscpy(uss_cmd_parms.uss_data.ussData,sizeof(uss_cmd_parms.uss_data.ussData), in_data_ptr->uss_info.uss_data, uss_cmd_parms.uss_data.size);
      uss_cmd_parms.uss_data.uss_data_coding_scheme = ussd_dcs;

      memset(&dialed_digits,0,sizeof(dialed_digits));
      if(in_data_ptr->uss_info.uss_data_len <= CM_MAX_NUMBER_CHARS)
      {
        memscpy(dialed_digits.buf,sizeof(dialed_digits.buf),in_data_ptr->uss_info.uss_data,in_data_ptr->uss_info.uss_data_len);
        dialed_digits.len = in_data_ptr->uss_info.uss_data_len;
      }
      dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;

      if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
                                                     QMI_VOICE_CMD_AWAITING_CALLBACK,
                                                     QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF,
                                                     cmd_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
      {
        /* Out of cmd_list buffer, send QMI_ERR_NO_MEMORY response */
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
        return;
      }


      #ifdef FEATURE_DUAL_SIM
      QM_MSG_HIGH_1("qmi_voice_cm_if_sups_orig_ussd :: cm_sups_cmd_process_uss_exten_per_subs() with ss_ref %d", uss_cmd_parms.ss_ref);
      cm_result = cm_sups_cmd_process_uss_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                                                   (void*)params_ptr->header.handle,
                                                                                   qmi_voice_cm_if_get_clientid(),
                                                                                   &uss_cmd_parms,
                                                                                   &dialed_digits,
                                                                                   CM_ORIG_CLIENT_CATEG_USER,
                                                                                   FALSE,(sys_modem_as_id_e_type)as_id);      
      #else
      QM_MSG_HIGH_1("qmi_voice_cm_if_sups_orig_ussd :: cm_sups_cmd_process_uss_exten() with ss_ref %d", uss_cmd_parms.ss_ref);
      cm_result = cm_sups_cmd_process_uss_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                                                   (void*)params_ptr->header.handle,
                                                                                   qmi_voice_cm_if_get_clientid(),
                                                                                   &uss_cmd_parms,
                                                                                   &dialed_digits,
                                                                                   CM_ORIG_CLIENT_CATEG_USER);
      #endif /*FEATURE_DUAL_SIM*/      
      if(!cm_result)
      {
        QM_MSG_HIGH("CM returned error for cm_sups_cmd_process_uss_exten() ");
        /* Out of cmdList buffer, send QMI_ERR_INTERNAL response */
        qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
      }
    }
  }

}/*qmi_voice_cm_if_sups_orig_ussd*/

/*===========================================================================

  FUNCTION:  qmi_voice_cm_if_sups_cancel_ussd

===========================================================================*/
/*!
    @brief
    Handles CANCEL_USSD.
    Used for cancelling/releasing the ongoing USSD session

    @return
    None.
*/
/*=========================================================================*/
void qmi_voice_cm_if_sups_cancel_ussd
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cmd_list_public_type info_ptr;
  cm_release_ss_params_s_type  release_cmd_parms;
  boolean cm_result = TRUE;
  char *ss_name;
  voice_cancel_ussd_resp_msg_v02      cancel_ussd_resp;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;  
  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  /* If the sys mode is not GW, send error response */
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
   qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  memset(&release_cmd_parms, 0, sizeof(cm_release_ss_params_s_type));
  memset(&cancel_ussd_resp, 0, sizeof(cancel_ussd_resp));
  
  if(qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF,&info_ptr, as_id ) == E_SUCCESS)
  {
    QM_MSG_HIGH_2("Recieved Cancel USSD Req with ss_ref=%d and cmd=%d", info_ptr.sub_id, info_ptr.cmd);
    release_cmd_parms.ss_oper = qmi_voice_cm_sups_processUnstructuredSS_Request;
    release_cmd_parms.ss_ref = info_ptr.sub_id;
    ss_name = "ProcessUnstructuredReq";
  }
  else if(qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_SUPS_USS_IND, &info_ptr, as_id ) == E_SUCCESS)
  {
    release_cmd_parms.ss_oper = qmi_voice_cm_sups_unstructuredSS_Request;
    ss_name = "UnstructuredReq";
  }
  else
  {
    QM_MSG_MED("CANCEL_USSD received when none of them are present");
    ss_name = "InvalidReq";
  }

  if((int)info_ptr.pending_event_id > 0)
  {
    QM_MSG_MED_1( "qmi_voice_cm_if_sups_cancel_ussd :: cm_sups_cmd_release() %s", ss_name );
  
    release_cmd_parms.ss_ref = info_ptr.sub.sups.ss_ref;
    #ifdef FEATURE_DUAL_SIM
    cm_result = cm_sups_cmd_release_cc_per_subs(NULL,
                                    NULL,
                                    qmi_voice_cm_if_get_clientid(),
                                    &release_cmd_parms,NULL,FALSE,(sys_modem_as_id_e_type)as_id);
    #else
    cm_result = cm_sups_cmd_release(NULL,
                                    NULL,
                                    qmi_voice_cm_if_get_clientid(),
                                    &release_cmd_parms);    
    #endif /*FEATURE_DUAL_SIM*/
    if(cm_result)
    {
      if ( release_cmd_parms.ss_oper == qmi_voice_cm_sups_processUnstructuredSS_Request )
      {
        /* send success to match with the android design for blocking the multiple rejected pop ups */
        qmi_voice_cm_if_response_error( info_ptr.hdl, info_ptr.cmd, QMI_ERR_ABORTED, 
                                                                  TRUE, FALSE );
      } 
      else if( release_cmd_parms.ss_oper == qmi_voice_cm_sups_unstructuredSS_Request )
      {
        qmi_voice_cmd_list_free( info_ptr.hdl );
      }
      qmi_voice_cm_if_response_success(params_ptr->header.handle, params_ptr->header.cmd, (void *)&cancel_ussd_resp, sizeof(cancel_ussd_resp), TRUE );
    }
    else
    {
      QM_MSG_HIGH("CM returned error for cm_sups_cmd_release() ");
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    }
  }
  else
  {
    QM_MSG_HIGH("Sending failure as response for CANCEL_USSD request");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
  }

} /* qmi_voice_cm_if_sups_cancel_ussd() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SET_MODEM_CONFIG()

  DESCRIPTION
    Set modem configuration items

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_set_modem_config
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  voice_set_config_req_msg_v02 *in_data_ptr;
  nv_stat_enum_type nv_status = NV_FAIL_S;
  nv_item_type nv_item;
  uint8 auto_answer=FALSE;
  voice_set_config_resp_msg_v02 set_config_resp;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/

  ASSERT(params_ptr);
  in_data_ptr = &params_ptr->data.set_config;
#ifdef FEATURE_DUAL_SIM
    as_id = params_ptr->header.as_id;
 qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/



  ASSERT(in_data_ptr);
  /*-----------------------------------------------------------------------*/

  if(in_data_ptr->auto_answer_valid)
  {
    auto_answer = in_data_ptr->auto_answer;
    if ( auto_answer > (uint8)QMI_VOICE_CM_IF_AUTO_ANSWER_ENABLE )
    {
      QM_MSG_ERROR_1("received invalid auto_answer type %d", auto_answer);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->air_timer_valid)
  {
    if(in_data_ptr->air_timer.nam_id > QMI_VOICE_CM_IF_MAX_NAM_ID)
    {
      QM_MSG_ERROR_2("received invalid Nam id :%d for air_timer :%ld",in_data_ptr->air_timer.nam_id,in_data_ptr->air_timer.air_timer);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->roam_timer_valid)
  {
    if(in_data_ptr->roam_timer.nam_id > QMI_VOICE_CM_IF_MAX_NAM_ID)
    {
      QM_MSG_ERROR_2("received invalid Nam id :%d for roam_timer :%ld",in_data_ptr->roam_timer.nam_id,in_data_ptr->roam_timer.roam_timer);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->tty_mode_valid)
  {
    if((in_data_ptr->tty_mode >= (uint8)QM_NV_TTY_MODE_MAX) || (in_data_ptr->tty_mode <= QM_NV_TTY_MODE_MIN))
    {
      QM_MSG_ERROR_1("received invalid ttyp_mode %d", in_data_ptr->tty_mode);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->preferred_voice_so_valid)
  {
    if(in_data_ptr->preferred_voice_so.nam_id > QMI_VOICE_CM_IF_MAX_NAM_ID)
    {
      QM_MSG_ERROR_1("received invalid Nam id :%ld in set pref_voice_so",in_data_ptr->preferred_voice_so.nam_id);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
    if(in_data_ptr->preferred_voice_so.evrc_capability > QMI_VOICE_CM_IF_EVRC_CAPABILITY_ENABLE)
    {
      QM_MSG_ERROR_1("received invalid evrc_capability :%d in set pref_voice_so", in_data_ptr->preferred_voice_so.evrc_capability);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
    if(qmi_voice_cm_if_pref_voice_service_option_is_valid((uint16)(in_data_ptr->preferred_voice_so.home_page_voice_so)) != TRUE)
    {
      QM_MSG_ERROR_1("received invalid home_page_voice_so :%d in set pref_voice_so", in_data_ptr->preferred_voice_so.home_page_voice_so);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
    if(qmi_voice_cm_if_pref_voice_service_option_is_valid((uint16)(in_data_ptr->preferred_voice_so.home_orig_voice_so)) != TRUE)
    {
      QM_MSG_ERROR_1("received invalid home_orig_voice_so :%d in set pref_voice_so", in_data_ptr->preferred_voice_so.home_orig_voice_so);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
    if(qmi_voice_cm_if_pref_voice_service_option_is_valid((uint16)(in_data_ptr->preferred_voice_so.roam_orig_voice_so)) != TRUE)
    {
      QM_MSG_ERROR_1("received invalid roam_orig_voice_so :%d in set pref_voice_so", in_data_ptr->preferred_voice_so.roam_orig_voice_so);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->voice_domain_valid)
  {
    if(in_data_ptr->voice_domain > VOICE_DOMAIN_PREF_PS_PREF_V02)
    {
      QM_MSG_ERROR_1("received invalid voice domain pref %d", in_data_ptr->voice_domain);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->ui_tty_setting_valid)
  {
    if(in_data_ptr->ui_tty_setting > TTY_MODE_OFF_V02)
    {
      QM_MSG_ERROR_1("received invalid UI TTY setting %d", in_data_ptr->ui_tty_setting);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }

  memset(&set_config_resp,0,sizeof(set_config_resp));
  
  if(in_data_ptr->auto_answer_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_item.auto_answer.enable = auto_answer;
    set_config_resp.auto_answer_outcome_valid = TRUE;
    nv_status = (nv_stat_enum_type) qmi_mmode_put_nv_item( NV_AUTO_ANSWER_I, (nv_item_type *) &nv_item );
    if ( nv_status != NV_DONE_S )
    {
      set_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      set_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      set_config_resp.auto_answer_outcome = QMI_VOICE_CM_IF_SET_MODEM_FAILURE;
      QM_MSG_ERROR_1("Write auto_answer mode (%d) to NV failed.", auto_answer);
    }
    else
    {
      set_config_resp.auto_answer_outcome = QMI_VOICE_CM_IF_SET_MODEM_SUCCESS;
    }
  }

  if(in_data_ptr->air_timer_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_item.air_cnt.nam = in_data_ptr->air_timer.nam_id;
    nv_item.air_cnt.cnt = in_data_ptr->air_timer.air_timer;
    set_config_resp.air_timer_outcome_valid = TRUE;
    nv_status = (nv_stat_enum_type) qmi_mmode_put_nv_item( NV_AIR_CNT_I, (nv_item_type *) &nv_item );
    if ( nv_status != NV_DONE_S )
    {
      set_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      set_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      set_config_resp.air_timer_outcome = QMI_VOICE_CM_IF_SET_MODEM_FAILURE;
      QM_MSG_ERROR_1("Write air time for nam:  (%d) to NV failed.", in_data_ptr->air_timer.nam_id);
    }
    else
    {
      set_config_resp.air_timer_outcome = QMI_VOICE_CM_IF_SET_MODEM_SUCCESS;
    }
  }

  if(in_data_ptr->roam_timer_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_item.roam_cnt.nam = in_data_ptr->roam_timer.nam_id;
    nv_item.roam_cnt.cnt = in_data_ptr->roam_timer.roam_timer;
    set_config_resp.roam_timer_outcome_valid = TRUE;
    nv_status = (nv_stat_enum_type) qmi_mmode_put_nv_item( NV_ROAM_CNT_I, (nv_item_type *) &nv_item );
    if ( nv_status != NV_DONE_S )
    {
      set_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      set_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      set_config_resp.roam_timer_outcome= QMI_VOICE_CM_IF_SET_MODEM_FAILURE;
      QM_MSG_ERROR_1("Write Roam time for nam:  (%d) to NV failed.", in_data_ptr->roam_timer.nam_id);
      
    }
    else
    {
      set_config_resp.roam_timer_outcome= QMI_VOICE_CM_IF_SET_MODEM_SUCCESS;
    }
  }

  if(in_data_ptr->tty_mode_valid)
  {
    memset(&nv_buf,0,sizeof(nv_buf));
    nv_buf.tty = in_data_ptr->tty_mode;
    set_config_resp.tty_mode_outcome_valid = TRUE;
    nv_status = qm_nv_put( NV_TTY_I, &nv_buf, (enum qm_subs_e)as_id );
    if ( nv_status != NV_DONE_S )
    {
      set_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      set_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      set_config_resp.tty_mode_outcome = QMI_VOICE_CM_IF_SET_MODEM_FAILURE;
      QM_MSG_ERROR_1("Write TTY Mode:  (%d) to NV failed.", in_data_ptr->tty_mode);
    }
    else
    {
      set_config_resp.tty_mode_outcome = QMI_VOICE_CM_IF_SET_MODEM_SUCCESS;
      QM_MSG_HIGH_1("Tried Writing TTY Mode: (%d)to NV", in_data_ptr->tty_mode);
    }
  }

  if(in_data_ptr->preferred_voice_so_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_item.pref_voice_so.nam = in_data_ptr->preferred_voice_so.nam_id;
    nv_item.pref_voice_so.evrc_capability_enabled = in_data_ptr->preferred_voice_so.evrc_capability;
    nv_item.pref_voice_so.home_page_voice_so = (uint16)in_data_ptr->preferred_voice_so.home_page_voice_so;
    nv_item.pref_voice_so.home_orig_voice_so = (uint16)in_data_ptr->preferred_voice_so.home_orig_voice_so;
    nv_item.pref_voice_so.roam_orig_voice_so = (uint16)in_data_ptr->preferred_voice_so.roam_orig_voice_so;
    set_config_resp.pref_voice_so_outcome_valid = TRUE;
    nv_status = (nv_stat_enum_type) qmi_mmode_put_nv_item( NV_PREF_VOICE_SO_I , (nv_item_type *) &nv_item );
    if ( nv_status != NV_DONE_S )
    {
      set_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      set_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      set_config_resp.pref_voice_so_outcome = QMI_VOICE_CM_IF_SET_MODEM_FAILURE;
      QM_MSG_ERROR_1("Write pref_voice_so for nam:  (%d) to NV failed.", in_data_ptr->preferred_voice_so.nam_id);
    }
    else
    {
      set_config_resp.pref_voice_so_outcome = QMI_VOICE_CM_IF_SET_MODEM_SUCCESS;
    }
  }

  if(in_data_ptr->voice_domain_valid)
  {
    if (qmi_voice_cm_util_efs_write_per_subs( QMI_VOICE_DOMAIN_PREF_F_NAME,
                                              (byte*)&(in_data_ptr->voice_domain),
                                              sizeof(sys_voice_domain_pref_e_type),
                                              (qmi_voice_cm_if_as_id_e_type)as_id ))
    {
      set_config_resp.voice_domain_pref_outcome = QMI_VOICE_CM_IF_SET_MODEM_SUCCESS;
    }
    else
    {
      set_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      set_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      set_config_resp.voice_domain_pref_outcome = QMI_VOICE_CM_IF_SET_MODEM_FAILURE;
      QM_MSG_ERROR_1("Write voice domain preference %d to EFS NV failed.", in_data_ptr->voice_domain);
    }
    set_config_resp.voice_domain_pref_outcome_valid = TRUE;
  }

  if(in_data_ptr->ui_tty_setting_valid)
  {
    if ( qm_efs_put_ui_tty_setting((uint8)in_data_ptr->ui_tty_setting) )
    {
      QM_MSG_HIGH_1("Successfully update UI TTY setting (%d)", in_data_ptr->ui_tty_setting);
      set_config_resp.ui_tty_setting_outcome = QMI_VOICE_CM_IF_SET_MODEM_SUCCESS;
    }
    else
    {
      set_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      set_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      set_config_resp.ui_tty_setting_outcome = QMI_VOICE_CM_IF_SET_MODEM_FAILURE;
      QM_MSG_ERROR_1("Failed to update UI TTY setting (%d)", in_data_ptr->ui_tty_setting);
    }
    set_config_resp.ui_tty_setting_outcome_valid = TRUE;
  }

  if(in_data_ptr->secure_call_functionality_available_valid)
  {
  	 qmi_voice_cm_if_secure_call_functionality_info(params_ptr);
  }

  if(in_data_ptr->ecall_msd_valid)
  {
#ifdef FEATURE_ECALL_APP
    {
      ecall_session_update_msd_setting_s_type msd_setting;
      memset(&msd_setting, 0, sizeof(msd_setting));
      if (in_data_ptr->ecall_msd_len != 0)
      {
        msd_setting.is_external_msd = TRUE;
      }
      memscpy(msd_setting.ecall_msd, sizeof(msd_setting.ecall_msd), in_data_ptr->ecall_msd, in_data_ptr->ecall_msd_len);

      if ( ecall_session_update_msd_setting(msd_setting) )
      {
        QM_MSG_HIGH_1("Successfully update eCall MSD setting with is_external_msd = %d", msd_setting.is_external_msd);
        set_config_resp.ecall_msd_outcome= QMI_VOICE_CM_IF_SET_MODEM_SUCCESS;
      }
      else
      {
        set_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
        set_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
        set_config_resp.ecall_msd_outcome= QMI_VOICE_CM_IF_SET_MODEM_FAILURE;
        QM_MSG_ERROR_1("Failed to update eCall MSD setting with is_external_msd = %d", msd_setting.is_external_msd);
      }
      set_config_resp.ecall_msd_outcome_valid = TRUE;
    }
#else /* FEATURE_ECALL_APP */
    QM_MSG_HIGH("FEATURE_ECALL_APP not defined. Cannot update eCall MSD setting");
#endif /* FEATURE_ECALL_APP */
  }

  if( (set_config_resp.resp.error == QMI_ERR_INTERNAL_V01) &&
      ( (set_config_resp.auto_answer_outcome == QMI_VOICE_CM_IF_SET_MODEM_SUCCESS) ||
        (set_config_resp.air_timer_outcome == QMI_VOICE_CM_IF_SET_MODEM_SUCCESS) ||
        (set_config_resp.roam_timer_outcome == QMI_VOICE_CM_IF_SET_MODEM_SUCCESS) ||
        (set_config_resp.tty_mode_outcome == QMI_VOICE_CM_IF_SET_MODEM_SUCCESS) ||
        (set_config_resp.pref_voice_so_outcome == QMI_VOICE_CM_IF_SET_MODEM_SUCCESS) || 
        (set_config_resp.voice_domain_pref_outcome == QMI_VOICE_CM_IF_SET_MODEM_SUCCESS) || 
        (set_config_resp.ui_tty_setting_outcome == QMI_VOICE_CM_IF_SET_MODEM_SUCCESS) ) )
  {
    set_config_resp.resp.result = QMI_RESULT_SUCCESS_V01;
  }


  qmi_voice_cm_if_response_success(params_ptr->header.handle, params_ptr->header.cmd, (void *)&set_config_resp, sizeof(set_config_resp), FALSE);

} /* qmi_voice_cm_if_set_modem_config() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_GET_MODEM_CONFIG()

  DESCRIPTION
    Get modem configuration items

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_get_modem_config
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  voice_get_config_req_msg_v02 *in_data_ptr;
  nv_stat_enum_type nv_status = NV_FAIL_S;
  nv_item_type nv_item;
  uint8 auto_answer=FALSE;
  uint8 nam_id=0;
  voice_get_config_resp_msg_v02 get_config_resp;
  mmode_qmi_voice_tty_mode_e_type  ui_tty_setting_buf = MMODE_QMI_VOICE_TTY_MODE_OFF;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  /*-----------------------------------------------------------------------*/

  ASSERT(params_ptr);
  in_data_ptr = &params_ptr->data.get_config;
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
  qmi_voice_asid(params_ptr);
#endif /*FEATURE_DUAL_SIM*/


  ASSERT(in_data_ptr);
  /*-----------------------------------------------------------------------*/

  if(in_data_ptr->auto_answer_valid)
  {
    if ( in_data_ptr->auto_answer != QMI_VOICE_CM_IF_GET_MODEM_CONFIG_ITEM )
    {
      QM_MSG_ERROR_1("received invalid auto_answer type %d", auto_answer);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->air_timer_valid)
  {
    if( in_data_ptr->air_timer != QMI_VOICE_CM_IF_GET_MODEM_CONFIG_ITEM )
    {
      QM_MSG_ERROR_1("received invalid air_timer :%d", in_data_ptr->air_timer);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->roam_timer_valid)
  {
    if( in_data_ptr->roam_timer != QMI_VOICE_CM_IF_GET_MODEM_CONFIG_ITEM )
    {
      QM_MSG_ERROR_1("received invalid  roam_timer :%d", in_data_ptr->roam_timer);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->tty_mode_valid)
  {
    if(in_data_ptr->tty_mode != QMI_VOICE_CM_IF_GET_MODEM_CONFIG_ITEM)
    {
      QM_MSG_ERROR_1("received invalid tty_mode %d", in_data_ptr->tty_mode);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->pref_voice_so_valid)
  {
    if( in_data_ptr->pref_voice_so != QMI_VOICE_CM_IF_GET_MODEM_CONFIG_ITEM )
    {
      QM_MSG_ERROR_1("received invalid pref_voice_so %d", in_data_ptr->pref_voice_so);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->amr_status_valid)
  {
    if(in_data_ptr->amr_status != QMI_VOICE_CM_IF_GET_MODEM_CONFIG_ITEM)
    {
      QM_MSG_ERROR_1("received invalid amr_status %d", in_data_ptr->amr_status);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->voice_privacy_valid)
  {
    if(in_data_ptr->voice_privacy != QMI_VOICE_CM_IF_GET_MODEM_CONFIG_ITEM)
    {
      QM_MSG_ERROR_1("received invalid voice_privacy %d", in_data_ptr->voice_privacy);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->nam_id_valid)
  {
    if(in_data_ptr->nam_id > QMI_VOICE_CM_IF_MAX_NAM_ID)
    {
      QM_MSG_ERROR_1("received invalid nam_id %d", in_data_ptr->nam_id);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
    nam_id = in_data_ptr->nam_id;
  }
  if(in_data_ptr->voice_domain_pref_valid)
  {
    if(in_data_ptr->voice_domain_pref != QMI_VOICE_CM_IF_GET_MODEM_CONFIG_ITEM)
    {
      QM_MSG_ERROR_1("received invalid voice_domain_preference %d", in_data_ptr->voice_domain_pref);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }
  if(in_data_ptr->ui_tty_setting_valid)
  {
    if(in_data_ptr->ui_tty_setting != QMI_VOICE_CM_IF_GET_MODEM_CONFIG_ITEM)
    {
      QM_MSG_ERROR_1("received invalid ui_tty_setting %d", in_data_ptr->ui_tty_setting);
      qmi_voice_cm_if_response_error( params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ARG, FALSE, FALSE );
      return;
    }
  }

  /*Read NV Items from Here*/
  memset(&get_config_resp,0,sizeof(get_config_resp));

  if(in_data_ptr->auto_answer_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_status = (nv_stat_enum_type) qmi_mmode_get_nv_item( NV_AUTO_ANSWER_I, &nv_item );
    if ( nv_status != NV_DONE_S )
    {
      get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("Read auto_answer mode (%d) to NV failed.", auto_answer);
    }
    else
    {
     if(nv_item.auto_answer.enable <= QMI_VOICE_CM_IF_AUTO_ANSWER_ENABLE)
     {
        get_config_resp.auto_answer_status_valid = TRUE;
        get_config_resp.auto_answer_status = nv_item.auto_answer.enable;
     }
     else
     {
        get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
        get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("Read Auto answer Invalid Value:  (%d) .", nv_item.auto_answer.enable);
     }
    }
  }

  if(in_data_ptr->air_timer_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_item.air_cnt.nam = nam_id;
    nv_status = (nv_stat_enum_type) qmi_mmode_get_nv_item( NV_AIR_CNT_I, (nv_item_type *) &nv_item );
    if ( nv_status != NV_DONE_S )
    {
      get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("Read air time NV failed with nv_status :  (%d) .", nv_status);
    }
    else
    {
      if(nv_item.air_cnt.nam <= QMI_VOICE_CM_IF_MAX_NAM_ID)
      {
        get_config_resp.air_timer_count_valid = TRUE;
        get_config_resp.air_timer_count.nam_id = nv_item.air_cnt.nam;
        get_config_resp.air_timer_count.air_timer = nv_item.air_cnt.cnt;
      }
      else
      {
        get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
        get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("Read Air timer Invalid Values for nam_id:  (%d) .", nv_item.air_cnt.nam);
      }
    }
  }

  if(in_data_ptr->roam_timer_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_item.roam_cnt.nam = nam_id;
    nv_status = (nv_stat_enum_type) qmi_mmode_get_nv_item( NV_ROAM_CNT_I, (nv_item_type *) &nv_item );
    if ( nv_status != NV_DONE_S )
    {
      get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("Read Roam timer NV failed with nv_status :  (%d) .", nv_status);
    }
    else
    {
      if(nv_item.roam_cnt.nam <= QMI_VOICE_CM_IF_MAX_NAM_ID)
      {
        get_config_resp.roam_timer_count_valid = TRUE;
        get_config_resp.roam_timer_count.nam_id = nv_item.roam_cnt.nam;
        get_config_resp.roam_timer_count.roam_timer = nv_item.roam_cnt.cnt;
      }
      else
      {
        get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
        get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("Read Roam timer Invalid Values for nam_id:  (%d) .", nv_item.roam_cnt.nam);
      }
    }
  }

  if(in_data_ptr->tty_mode_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_status = qm_nv_get( NV_TTY_I, &nv_buf, (enum qm_subs_e)as_id );
    if ( nv_status != NV_DONE_S )
    {
      get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("Read TTY_MODE NV failed with nv_status :  (%d) .", nv_status);
    }
    else
    {
      get_config_resp.current_tty_mode_valid = TRUE;
      get_config_resp.current_tty_mode = nv_buf.tty;
    }
  }

  if(in_data_ptr->pref_voice_so_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_item.pref_voice_so.nam = nam_id;
    nv_status = (nv_stat_enum_type) qmi_mmode_get_nv_item( NV_PREF_VOICE_SO_I , (nv_item_type *) &nv_item );
    if ( nv_status != NV_DONE_S )
    {
      get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("Read PREF VOICE SO NV failed with nv_status :  (%d) .", nv_status);
    }
    else
    {
      if((qmi_voice_cm_if_pref_voice_service_option_is_valid(nv_item.pref_voice_so.home_page_voice_so) == TRUE) &&
          (qmi_voice_cm_if_pref_voice_service_option_is_valid(nv_item.pref_voice_so.home_orig_voice_so) == TRUE) &&
          (qmi_voice_cm_if_pref_voice_service_option_is_valid(nv_item.pref_voice_so.roam_orig_voice_so) == TRUE) &&
          (nv_item.pref_voice_so.nam <= QMI_VOICE_CM_IF_MAX_NAM_ID) &&
          (nv_item.pref_voice_so.evrc_capability_enabled <= QMI_VOICE_CM_IF_EVRC_CAPABILITY_ENABLE)
          )
      {
        get_config_resp.current_preferred_voice_so_valid = TRUE;
        get_config_resp.current_preferred_voice_so.nam_id =  nv_item.pref_voice_so.nam;
        get_config_resp.current_preferred_voice_so.evrc_capability =  nv_item.pref_voice_so.evrc_capability_enabled;
        get_config_resp.current_preferred_voice_so.home_page_voice_so =  (voice_so_enum_v02)nv_item.pref_voice_so.home_page_voice_so;
        get_config_resp.current_preferred_voice_so.home_orig_voice_so =  (voice_so_enum_v02)nv_item.pref_voice_so.home_orig_voice_so;
        get_config_resp.current_preferred_voice_so.roam_orig_voice_so =  (voice_so_enum_v02)nv_item.pref_voice_so.roam_orig_voice_so;
      }
      else
      {
        get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
        get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("Read PREF VOICE SO Invalid Values for nam_id:  (%d) .", nv_item.pref_voice_so.nam);
      }
    }
  }

  if(in_data_ptr->amr_status_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_status = (nv_stat_enum_type) qmi_mmode_get_nv_item_ext( NV_GSM_AMR_CALL_CONFIG_I  , (nv_item_type *) &nv_item, (uint16)as_id );
    if ( nv_status != NV_DONE_S )
    {
      QM_MSG_ERROR_1("Read GSM_AMR NV failed with nv_status :  (%d) .", nv_status);
    }
    else
    {
      if(nv_item.gsm_amr_call_config <= QMI_VOICE_CM_IF_GSM_AMR_STATUS_ENABLE)
      {
        get_config_resp.current_arm_config_valid = TRUE;
        get_config_resp.current_arm_config.gsm_amr_status = nv_item.gsm_amr_call_config;
      }
      else
      {
        QM_MSG_ERROR_1("Read Invalid Value for gsm_amr_status :  (%d) .", nv_item.gsm_amr_call_config);
      }
    }

    memset(&nv_item,0,sizeof(nv_item));
    nv_status = (nv_stat_enum_type) qmi_mmode_get_nv_item_ext( NV_UMTS_AMR_CODEC_PREFERENCE_CONFIG_I,
      (nv_item_type *) &nv_item, (uint16)as_id);

    if ( nv_status != NV_DONE_S )
    {
      get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("Read UMTS_AMR_CODEC NV failed with nv_status :  (%d) .", nv_status);
    }
    else
    {
      /*
        NV Octet: xxxxABCD 
        A  Controls WCDMA AMR WB 
        B  Controls GSM HR AMR 
        C  Controls GSM AMR WB 
        D  Controls GSM AMR NB 
        0 for the A, B, C, and D bits  Corresponding AMR codec is not supported 
        1 for the A, B, C, and D bits  Corresponding AMR codec is supported
        So, Considering only least 4-bits
      */
      get_config_resp.current_arm_config_valid = TRUE;
      get_config_resp.current_arm_config.wcdma_amr_status = nv_item.umts_amr_codec_preference_config & 0x0F;
    }

  }

  if(in_data_ptr->voice_privacy_valid)
  {
    memset(&nv_item,0,sizeof(nv_item));
    nv_status = (nv_stat_enum_type) qmi_mmode_get_nv_item( NV_VOICE_PRIV_I, (nv_item_type *) &nv_item );
    if ( nv_status != NV_DONE_S )
    {
      get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("Read VOICE PRIVACY NV failed with nv_status :  (%d) .", nv_status);
    }
    else
    {
      if( nv_item.voice_priv <= VOICE_PRIVACY_ENHANCED_V02)
      {
        get_config_resp.current_voice_privacy_pref_valid = TRUE;
        get_config_resp.current_voice_privacy_pref = (voice_privacy_enum_v02)nv_item.voice_priv;
      }
      else
      {
        get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
        get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("Read Invalid Value for voice_privacy :  (%d) .", nv_item.voice_priv);
      }
    }
  }

  if(in_data_ptr->voice_domain_pref_valid)
  {
    byte domain_pref = (byte)get_config_resp.voice_domain;

    if(qmi_voice_cm_util_efs_read_per_subs(QMI_VOICE_DOMAIN_PREF_F_NAME,
                                           &domain_pref,
                                           sizeof(sys_voice_domain_pref_e_type),
                                           (qmi_voice_cm_if_as_id_e_type)as_id))
    {
      if(get_config_resp.voice_domain <= VOICE_DOMAIN_PREF_PS_PREF_V02)
      {
        QM_MSG_HIGH_1("Domain Pref EFS NV read sucessful, domain pref=%d!", get_config_resp.voice_domain);
        get_config_resp.voice_domain_valid = TRUE;
      }
      else
      {
        get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
        get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("Read Invalid Value for voice_domain_pref :  (%d)", get_config_resp.voice_domain);
      }
    }
    else
    {
      get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR("Read Failed for Voice domain preference ");
    }
  }


  if(in_data_ptr->ui_tty_setting_valid)
  {
    if ( qm_efs_get_ui_tty_setting((uint8*)&ui_tty_setting_buf,
                                  sizeof(uint8)) ) /* ui_tty_setting is uint8 per IDL */
    {
      QM_MSG_HIGH_1("Successfully get UI TTY setting %d", ui_tty_setting_buf);
      get_config_resp.current_ui_tty_setting_valid = TRUE;
      get_config_resp.current_ui_tty_setting = (tty_mode_enum_v02)ui_tty_setting_buf;
    }
    else
    {
      get_config_resp.resp.result = QMI_RESULT_FAILURE_V01;
      get_config_resp.resp.error = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR("Failed to get UI TTY setting");
    }
  }

  if( (get_config_resp.resp.error == QMI_ERR_INTERNAL_V01) &&
       ( (get_config_resp.auto_answer_status_valid == TRUE) ||
         (get_config_resp.air_timer_count_valid == TRUE) ||
         (get_config_resp.roam_timer_count_valid == TRUE) ||
         (get_config_resp.current_tty_mode_valid == TRUE) ||
         (get_config_resp.current_preferred_voice_so_valid == TRUE) ||
         (get_config_resp.current_arm_config_valid == TRUE) ||
         (get_config_resp.current_voice_privacy_pref_valid == TRUE) ||
         (get_config_resp.voice_domain_valid == TRUE) ||
         (get_config_resp.current_ui_tty_setting_valid == TRUE) ) )
  {
    get_config_resp.resp.result = QMI_RESULT_SUCCESS_V01;
  }

  qmi_voice_cm_if_response_success(params_ptr->header.handle, params_ptr->header.cmd, (void *)&get_config_resp, sizeof(get_config_resp), FALSE );

} /* qmi_voice_cm_if_get_modem_config() */

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_orig_ussd_no_wait()

  DESCRIPTION
    Invoke CM API to originate the sups ussd request

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_orig_ussd_no_wait
(
  qmi_voice_cm_if_info_item_s *const  params_ptr
)
{
  voice_orig_ussd_no_wait_req_msg_v02   *in_data_ptr = &params_ptr->data.ussd_orig_no_wait_info;
  cm_uss_params_s_type                uss_cmd_parms;
  qmi_voice_cmd_list_u_type           u_info;
  qmi_voice_cm_if_cmd_info_sups_type *cmd_info_ptr = &u_info.sups;
  boolean                             cm_result;
  cm_num_s_type                       dialed_digits;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/
  ASSERT(params_ptr != NULL);

  memset(&uss_cmd_parms, 0, sizeof(uss_cmd_parms));
  
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif
  
  switch (in_data_ptr->uss_info.uss_dcs)
  {
  case QMI_VOICE_CM_IF_USSD_DCS_ASCII:
    uss_cmd_parms.uss_data.uss_data_coding_scheme = CM_USSD_DCS_UNSPECIFIED;
    break;
  case QMI_VOICE_CM_IF_USSD_DCS_USER_DEF_8_BIT:
    uss_cmd_parms.uss_data.uss_data_coding_scheme = CM_USSD_DCS_8_BIT;
    break;
  default:
    uss_cmd_parms.uss_data.uss_data_coding_scheme = CM_USSD_DCS_UCS2;
    break;
  }

  cmd_info_ptr->ss_ref                = qmi_voice_cm_sups_get_ss_ref();

  uss_cmd_parms.ss_ref                = cmd_info_ptr->ss_ref;
  uss_cmd_parms.uss_data.present      = TRUE;
  uss_cmd_parms.uss_data.size         = in_data_ptr->uss_info.uss_data_len;
  memscpy(uss_cmd_parms.uss_data.ussData,
         sizeof(uss_cmd_parms.uss_data.ussData),
         in_data_ptr->uss_info.uss_data,
         uss_cmd_parms.uss_data.size);
  memset(&dialed_digits,
         0,
         sizeof(dialed_digits));

  if (in_data_ptr->uss_info.uss_data_len <= CM_MAX_NUMBER_CHARS)
  {
    memscpy(dialed_digits.buf, 
           sizeof(dialed_digits.buf),
           in_data_ptr->uss_info.uss_data,
           in_data_ptr->uss_info.uss_data_len);
    dialed_digits.len = in_data_ptr->uss_info.uss_data_len;
  }
  dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;

  if (qmi_voice_cmd_list_new(params_ptr->header.cmd, params_ptr->header.handle,
                             QMI_VOICE_CMD_AWAITING_CALLBACK,
                             QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF,
                             cmd_info_ptr->ss_ref,
                             &u_info,
                             sizeof(u_info), as_id) != E_SUCCESS)
  {
    //QM_MSG_HIGH("Could not add entry to the list ");
    /* Out of cmd_list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error(params_ptr->header.handle,
                                   params_ptr->header.cmd,
                                   QMI_ERR_NO_MEMORY,
                                   FALSE,
                                   FALSE);
    return;
  }

  #ifdef FEATURE_DUAL_SIM
  QM_MSG_HIGH_1("qmi_voice_cm_if_sups_orig_ussd_no_wait :: cm_sups_cmd_process_uss_exten_per_subs() with ss_ref %d", uss_cmd_parms.ss_ref);
  cm_result = cm_sups_cmd_process_uss_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
						    (void*)params_ptr->header.handle,
						    qmi_voice_cm_if_get_clientid(),
						    &uss_cmd_parms,
						    &dialed_digits,
						    CM_ORIG_CLIENT_CATEG_USER,
						    FALSE,(sys_modem_as_id_e_type)as_id);		
  #else
  QM_MSG_HIGH_1("qmi_voice_cm_if_sups_orig_ussd_no_wait :: cm_sups_cmd_process_uss_exten() with ss_ref %d", uss_cmd_parms.ss_ref);
  cm_result = cm_sups_cmd_process_uss_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                            (void*)params_ptr->header.handle,
                                            qmi_voice_cm_if_get_clientid(),
                                            &uss_cmd_parms,
                                            &dialed_digits,
                                            CM_ORIG_CLIENT_CATEG_USER);
  #endif /*FEATURE_DUAL_SIM*/    
  if(!cm_result)
  {
    /* Out of cmdList buffer, send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error(params_ptr->header.handle,
                                   params_ptr->header.cmd,
                                   QMI_ERR_INTERNAL,
                                   TRUE,
                                   FALSE);
  }
}/*qmi_voice_cm_if_sups_orig_ussd_no_wait*/


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_ALS_SET_LINE_SWITCHING()

  DESCRIPTION
    Set whether or not line switching is allowed

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_als_set_line_switching
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean cm_result;
  cm_als_line_switching_e_type switch_option;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  QM_MSG_MED_1("qmi_voice_cm_if_als_set_line_switching():  allowed = %d ", params_ptr->data.set_line_switch.switch_option);

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif
  
  /* If the sys mode is not GW, send error response */
  if(!(qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_GWL), as_id )))
  {
    QM_MSG_ERROR("Invalid request in the current mode");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, FALSE, FALSE );
    return;
  }

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
              QMI_VOICE_CMD_AWAITING_CALLBACK,
              QMI_VOICE_CM_IF_EVT_NONE,
              params_ptr->header.handle, NULL, 0, as_id ) != E_SUCCESS )
  {

    /* Out of cmd list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }

  switch_option = (params_ptr->data.set_line_switch.switch_option == VOICE_LINE_SWITCHING_ALLOWED_V02)?
                  CM_ALS_LINE_SWITCHING_ALLOWED : CM_ALS_LINE_SWITCHING_NOT_ALLOWED;

  QM_MSG_HIGH_1("cm_ph_cmd_line_switching()with switch option %d", switch_option);

  cm_result = cm_ph_cmd_line_switching(qmi_voice_cm_if_ph_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                               switch_option);

  if(!cm_result)
  {
    /* send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
  }
} /* qmi_voice_cm_if_als_set_line_switching() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_ALS_GET_LINE_SWITCHING_STATUS()

  DESCRIPTION
    get info whether or not line switching is allowed

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_als_get_line_switching_status
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean cm_result;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  //QM_MSG_MED("qmi_voice_cm_if_als_get_line_switching_status()");

#ifdef FEATURE_DUAL_SIM
	as_id = params_ptr->header.as_id;
#endif /*FEATURE_DUAL_SIM*/


  /* If the sys mode is not GW, send error response */
  if(!(qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_GWL), as_id )))
  {
    QM_MSG_ERROR("Invalid request in the current mode");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, FALSE, FALSE );
    return;
  }

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
              QMI_VOICE_CMD_AWAITING_CALLBACK,
              QMI_VOICE_CM_IF_EVT_PH_INFO,
              params_ptr->header.handle, NULL, 0, as_id ) != E_SUCCESS )
  {

    /* Out of cmd list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }

  QM_MSG_HIGH("qmi_voice_cm_if_als_get_line_switching_status :: cm_ph_cmd_line_switching()");

#ifdef FEATURE_DUAL_SIM
  cm_result = cm_ph_cmd_get_ph_info_per_subs(qmi_voice_cm_if_ph_command_callback,
                                             (void*)params_ptr->header.handle,
                                             qmi_voice_cm_if_get_clientid(),
					     as_id);
#else
  cm_result = cm_ph_cmd_get_ph_info(qmi_voice_cm_if_ph_command_callback,
                                    (void*)params_ptr->header.handle,
                                    qmi_voice_cm_if_get_clientid());
#endif

  if(!cm_result)
  {
    /* send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
  }
} /* qmi_voice_cm_if_als_get_line_switching_status() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_ALS_SELECT_LINE()

  DESCRIPTION
    Select the line of interest

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_als_select_line
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean cm_result;
  cm_als_line_e_type line;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  QM_MSG_MED_1("qmi_voice_cm_if_als_select_line():  selected line %d", params_ptr->data.select_line.line_value);
#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif
  
  /* If the sys mode is not GW, send error response */
  if(!(qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_GWL), params_ptr->header.as_id )))
  {
    QM_MSG_ERROR("Invalid request in the current mode");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, FALSE, FALSE );
    return;
  }

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
              QMI_VOICE_CMD_AWAITING_CALLBACK,
              QMI_VOICE_CM_IF_EVT_NONE,
              params_ptr->header.handle, NULL, 0, as_id ) != E_SUCCESS )
  {

    /* Out of cmd list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }

  line = (params_ptr->data.select_line.line_value == ALS_LINE1_V02)? CM_ALS_LINE_01: \
                                              CM_ALS_LINE_02;

  /* Remember the line selected */
  cm_if_info.als.prev_line = cm_if_info.als.curr_line;
  cm_if_info.als.curr_line = line;

  QM_MSG_HIGH_1("qmi_voice_cm_if_als_select_line :: cm_ph_cmd_selected_line with line %d", line);

  cm_result = cm_ph_cmd_selected_line(qmi_voice_cm_if_ph_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                               line);

  if(!cm_result)
  {
    /* send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
  }
} /* qmi_voice_cm_if_als_select_line() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_ALS_GET_SELECTED_LINE()

  DESCRIPTION
    Get the Selected the line of interest

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_als_get_selected_line
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean cm_result;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif /*FEATURE_DUAL_SIM*/

  /* If the sys mode is not GW, send error response */
  if(!(qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_GWL), params_ptr->header.as_id )))
  {
    QM_MSG_ERROR("Invalid request in the current mode");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, FALSE, FALSE );
    return;
  }

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
              QMI_VOICE_CMD_AWAITING_CALLBACK,
              QMI_VOICE_CM_IF_EVT_PH_INFO,
              params_ptr->header.handle, NULL, 0, as_id ) != E_SUCCESS )
  {

    /* Out of cmd list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }

  QM_MSG_HIGH("qmi_voice_cm_if_als_get_selected_line :: cm_ph_cmd_get_ph_info");
 
#ifdef FEATURE_DUAL_SIM
  cm_result = cm_ph_cmd_get_ph_info_per_subs(qmi_voice_cm_if_ph_command_callback,
					     (void*)params_ptr->header.handle,
					     qmi_voice_cm_if_get_clientid(),
					     as_id);
#else
  cm_result = cm_ph_cmd_get_ph_info(qmi_voice_cm_if_ph_command_callback,
                                    (void*)params_ptr->header.handle,
                                    qmi_voice_cm_if_get_clientid());
#endif

  if(!cm_result)
  {
    /* send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
  }
} /* qmi_voice_cm_if_als_get_selected_line() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_AOC_RESET_ACM()

  DESCRIPTION
    Reset ACM value to 0

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_aoc_reset_acm
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean cm_result = FALSE;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  
  ASSERT(params_ptr != NULL);
  
  /*-----------------------------------------------------------------------*/
  
  //QM_MSG_MED("In qmi_voice_cm_if_aoc_reset_acm()");
  
  #ifdef FEATURE_DUAL_SIM
    as_id = params_ptr->header.as_id;
  #endif
  
  if(!(qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_GWL | 
                                       QMI_VOICE_CM_IF_SYS_MODE_TDS), as_id )))    
    {
      QM_MSG_ERROR("Invalid request in the current mode");
      qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, FALSE, FALSE);
      return;
    }
  
  if(qmi_voice_cmd_list_new(params_ptr->header.cmd, params_ptr->header.handle,
                            QMI_VOICE_CMD_AWAITING_CALLBACK,
                            QMI_VOICE_CM_IF_EVT_PH_RESET_ACM_COMPLETED,
                            params_ptr->header.handle, NULL, 0, as_id) != E_SUCCESS)
  {
    /* Out of cmd list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_NO_MEMORY, FALSE, FALSE);
    return;
  }
  
  #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_2("qmi_voice_cm_if_aoc_reset_acm :: cm_ph_cmd_aoc_reset_acm_per_subs(): client_id = %d, as_id = %d", qmi_voice_cm_if_get_clientid(), as_id);
    cm_result = cm_ph_cmd_aoc_reset_acm_per_subs(qmi_voice_cm_if_ph_command_callback,
                                                 (void*)params_ptr->header.handle,
                                                 qmi_voice_cm_if_get_clientid(),
                                                 as_id);

  #else
    QM_MSG_HIGH_1("qmi_voice_cm_if_aoc_reset_acm :: cm_ph_cmd_aoc_reset_acm(): client_id = %d", qmi_voice_cm_if_get_clientid());
    cm_result = cm_ph_cmd_aoc_reset_acm(qmi_voice_cm_if_ph_command_callback,
                                        (void*)params_ptr->header.handle,
                                        qmi_voice_cm_if_get_clientid());

  #endif
  
  if(!cm_result)
  {
    /* Send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INTERNAL, TRUE, FALSE);
  }
} /* qmi_voice_cm_if_aoc_reset_acm() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_AOC_SET_ACMMAX()

  DESCRIPTION
    Set ACMmax value

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_aoc_set_acmmax
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  uint32 new_max;
  qmi_voice_cm_util_ss_info_s util_sys_info;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  
  ASSERT(params_ptr != NULL);
  
  /*-----------------------------------------------------------------------*/
  
  //QM_MSG_MED("In qmi_voice_cm_if_aoc_set_acmmax()");
  
  #ifdef FEATURE_DUAL_SIM
    as_id = params_ptr->header.as_id;
  #endif
  
  memset(&util_sys_info, 0, sizeof(util_sys_info));
  qmi_voice_cm_util_get_ss_info(&util_sys_info, as_id);
  
  #ifdef FEATURE_TDSCDMA
    /* If the sys mode is not GW or TDS, send error response */
    if(!QMI_VOICE_CM_IF_SYS_MODE_IS_GWL(util_sys_info.sys_mode) && !QMI_VOICE_CM_IF_SYS_MODE_IS_TDS(util_sys_info.sys_mode))
  #else
    /* If the sys mode is not GW, send error response */
    if(!QMI_VOICE_CM_IF_SYS_MODE_IS_GWL(util_sys_info.sys_mode))
  #endif
    {
      QM_MSG_ERROR("Invalid request in the current mode");
      qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, FALSE, FALSE);
      return;
    }
  
  if(qmi_voice_cmd_list_new(params_ptr->header.cmd, params_ptr->header.handle,
                            QMI_VOICE_CMD_AWAITING_CALLBACK,
                            QMI_VOICE_CM_IF_EVT_PH_SET_ACMMAX_COMPLETED,
                            params_ptr->header.handle, NULL, 0, as_id) != E_SUCCESS)
  {
    /* Out of cmd list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_NO_MEMORY, FALSE, FALSE);
    return;
  }
  
  new_max = params_ptr->data.set_acmmax.acmmax;
  
  #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_3("qmi_voice_cm_if_aoc_set_acmmax :: cm_ph_cmd_aoc_set_acmmax_per_subs(): client_id = %d, as_id = %d, new_max = %d", qmi_voice_cm_if_get_clientid(), as_id, new_max);
    if(!cm_ph_cmd_aoc_set_acmmax_per_subs(qmi_voice_cm_if_ph_command_callback,
                                         (void*)params_ptr->header.handle,
                                         qmi_voice_cm_if_get_clientid(),
                                         as_id,
                                         new_max))
    {
      /* Send QMI_ERR_INTERNAL response */
      qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INTERNAL, TRUE, FALSE);
      return;
    }
  #else
    QM_MSG_HIGH_2("qmi_voice_cm_if_aoc_set_acmmax :: cm_ph_cmd_aoc_set_acmmax(): client_id = %d, new_max = %d", qmi_voice_cm_if_get_clientid(), new_max);
    if(!cm_ph_cmd_aoc_set_acmmax(qmi_voice_cm_if_ph_command_callback,
                                         (void*)params_ptr->header.handle,
                                         qmi_voice_cm_if_get_clientid(),
                                         new_max))
    {
      /* Send QMI_ERR_INTERNAL response */
      qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INTERNAL, TRUE, FALSE);
      return;
    }
  #endif
  
  if(new_max > QMI_VOICE_CM_IF_AOC_MAX_NEW_MAX)
  {
    QM_MSG_ERROR_2("Error: new_max(%d) exceeds QMI_VOICE_CM_IF_AOC_MAX_NEW_MAX(%d)", new_max, QMI_VOICE_CM_IF_AOC_MAX_NEW_MAX);
    /* Send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INTERNAL, TRUE, FALSE);
    return;
  }
} /* qmi_voice_cm_if_aoc_set_acmmax() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO()

  DESCRIPTION
    Get values of ACM, ACMmax and/or CCM

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_aoc_get_call_meter_info
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  uint32 info_mask;
  voice_aoc_get_call_meter_info_resp_msg_v02 get_call_meter_info_resp;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  
  ASSERT(params_ptr != NULL);
  
  /*-----------------------------------------------------------------------*/
  
  #ifdef FEATURE_DUAL_SIM
    as_id = params_ptr->header.as_id;
  #endif
  
  if(!(qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_GWL | 
                                       QMI_VOICE_CM_IF_SYS_MODE_TDS), as_id )))    
    {
      QM_MSG_ERROR("Invalid request in the current mode");
      qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_OP_NETWORK_UNSUPPORTED, FALSE, FALSE);
      return;
    }
  
  info_mask = params_ptr->data.get_call_meter_info.info_mask;
  
  memset(&get_call_meter_info_resp,0,sizeof(voice_aoc_get_call_meter_info_resp_msg_v02));
  
  #ifdef FEATURE_DUAL_SIM
    if((info_mask & QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_CCM) == QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_CCM)
    {
      get_call_meter_info_resp.ccm = cm_ph_cmd_aoc_get_ccm_per_subs(as_id);
      get_call_meter_info_resp.ccm_valid = TRUE;
      QM_MSG_MED_2("cm_ph_cmd_aoc_get_ccm_per_subs(): as_id = %d, Rxd CCM = %d from CM", as_id, get_call_meter_info_resp.ccm);
    }
    if((info_mask & QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_ACM) == QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_ACM)
    {
      get_call_meter_info_resp.acm = cm_ph_cmd_aoc_get_acm_per_subs(as_id);
      get_call_meter_info_resp.acm_valid = TRUE;
      QM_MSG_MED_2("cm_ph_cmd_aoc_get_acm_per_subs(): as_id = %d, Rxd ACM = %d from CM", as_id, get_call_meter_info_resp.acm);
    }
    if((info_mask & QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_ACMMAX) == QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_ACMMAX)
    {
      get_call_meter_info_resp.acmmax = cm_ph_cmd_aoc_get_acmmax_per_subs(as_id);
      get_call_meter_info_resp.acmmax_valid = TRUE;
      QM_MSG_MED_2("cm_ph_cmd_aoc_get_acmmax_per_subs(): as_id = %d, Rxd ACMmax = %d from CM", as_id,  get_call_meter_info_resp.acmmax);
    }
  #else
    if((info_mask & QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_CCM) == QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_CCM)
    {
      get_call_meter_info_resp.ccm = cm_ph_cmd_aoc_get_ccm();
      get_call_meter_info_resp.ccm_valid = TRUE;
      QM_MSG_MED_1("cm_ph_cmd_aoc_get_ccm(): Rxd CCM = %d from CM", get_call_meter_info_resp.ccm);
    }
    if((info_mask & QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_ACM) == QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_ACM)
    {
      get_call_meter_info_resp.acm = cm_ph_cmd_aoc_get_acm();
      get_call_meter_info_resp.acm_valid = TRUE;
      QM_MSG_MED_1("cm_ph_cmd_aoc_get_acm(): Rxd ACM = %d from CM", get_call_meter_info_resp.acm);
    }
    if((info_mask & QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_ACMMAX) == QMI_VOICE_CM_IF_AOC_GET_CALL_METER_INFO_ACMMAX)
    {
      get_call_meter_info_resp.acmmax = cm_ph_cmd_aoc_get_acmmax();
      get_call_meter_info_resp.acmmax_valid = TRUE;
      QM_MSG_MED_1("cm_ph_cmd_aoc_get_acmmax(): Rxd ACMmax = %d from CM", get_call_meter_info_resp.acmmax);
    }
  #endif
  
  if(info_mask > QMI_VOICE_CM_IF_AOC_MAX_INFO_MASK)
  {
    QM_MSG_ERROR_2("Error: info_mask(%d) exceeds QMI_VOICE_CM_IF_AOC_MAX_INFO_MASK(%d)", info_mask, QMI_VOICE_CM_IF_AOC_MAX_INFO_MASK);
    /* Send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INTERNAL, TRUE, FALSE);
    return;
  }
  
  qmi_voice_cm_if_response_success(params_ptr->header.handle,
                                   params_ptr->header.cmd,
                                   (void *)&get_call_meter_info_resp,
                                   sizeof(voice_aoc_get_call_meter_info_resp_msg_v02),
                                   FALSE);
} /* qmi_voice_cm_if_aoc_get_call_meter_info() */


/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_get_cnap()

  DESCRIPTION
    Invoke CM API to get the cnap information.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_get_cnap
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type ss_data;
  boolean cm_result;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  
/* If the sys mode is not GW, send error response */
  memset(&ss_data, 0, sizeof(ss_data));
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
   qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  cmd_info_ptr->ss_code = (int) qmi_voice_cm_sups_cnap;
  cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

  ss_data.interr.ss_code = cmd_info_ptr->ss_code;
  ss_data.interr.ss_ref = cmd_info_ptr->ss_ref;
  ss_data.interr.basic_service.present = FALSE;

  /* fill the sups params required for sups string construction */
  memset(&ss_params, 0, sizeof(ss_params));
  ss_params.mode = QMI_VOICE_CM_SUPS_MODE_QUERY;
  ss_params.code = (qmi_voice_cm_sups_operation_code_e_type) ss_data.interr.ss_code;
  
  /* Invoke Sups String Construction. The string should be sent to modem 
  for any call control */
  if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
  {
    QM_MSG_ERROR("Sups string construction failed ");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }

  QM_MSG_LOW_1( "Sups String constructed is %s", ss_buf);
  memset(&dialed_digits,0,sizeof(dialed_digits));
  dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
  dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
              QMI_VOICE_CMD_AWAITING_CALLBACK,
              QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
              cmd_info_ptr->ss_ref, &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
  {
    /* Out of cmd list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }
  

#ifdef FEATURE_DUAL_SIM
  QM_MSG_MED_1("qmi_voice_cm_if_sups_get_cnap :: cm_sups_cmd_interrogate_cc_exten_per_subs(), Cnap ss_ref = %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                                &ss_data.interr,
                                                                &dialed_digits,
                                                                CM_ORIG_CLIENT_CATEG_USER,
                                                                FALSE,
                                                               (sys_modem_as_id_e_type)as_id );

#else
  QM_MSG_MED_1("qmi_voice_cm_if_sups_get_cnap :: cm_sups_cmd_interrogate_exten()with cnap ss_ref %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                                &ss_data.interr,
                                                                &dialed_digits,
                                                                CM_ORIG_CLIENT_CATEG_USER);
#endif /*FEATURE_DUAL_SIM*/  
  if(!cm_result)
  {
    /* send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
  }
} /* qmi_voice_cm_if_sups_get_cnap */


/*===========================================================================
  FUNCTION qmi_voice_cm_if_srvcc_call_config_req()

  DESCRIPTION
    Invoke CM API to pass the call data for SRVCC

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_srvcc_call_config_req
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cm_if_set_srvcc_call_context_s *in_data_ptr;
  qmi_voice_cm_if_set_srvcc_call_context_resp_s set_srvcc_resp;  

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );
  in_data_ptr = (qmi_voice_cm_if_set_srvcc_call_context_s *)(&params_ptr->data);
  ASSERT( in_data_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  memset( &set_srvcc_resp, 0, sizeof( set_srvcc_resp ) );

  if(cm_if_info.ho_state == VOICE_HANDOVER_START_V02)
  {
    if(qmi_voice_msgr_send_srvcc_config_req(in_data_ptr, (qmi_voice_cm_if_as_id_e_type)(params_ptr->header.as_id)) == E_SUCCESS)
    {
      set_srvcc_resp.error = QMI_ERR_NONE;
      qmi_voice_cm_if_response_success(params_ptr->header.handle, params_ptr->header.cmd, (void *)&set_srvcc_resp,
                                                                  sizeof(set_srvcc_resp), FALSE );
    }
    else
    {
      qmi_voice_cm_if_response_error(params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    }
  }
  else 
  {
    qmi_voice_cm_if_response_error(params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INCOMPATIBLE_STATE,FALSE,FALSE);
  }

} /* qmi_voice_cm_if_srvcc_call_config_req */

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_get_colr()

  DESCRIPTION
    Invoke CM API to get the colr information.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_get_colr
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type *cmd_info_ptr = &u_info.sups;
  qmi_voice_cm_sups_cmd_parm_u_type ss_data;
  boolean cm_result;
  char ss_buf[QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH];
  qmi_voice_cm_sups_params_s_type ss_params;
  cm_num_s_type            dialed_digits;
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  
/* If the sys mode is not GW, send error response */
  memset(&ss_data, 0, sizeof(ss_data));
  #ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
   qmi_voice_asid(params_ptr);
  #endif /*FEATURE_DUAL_SIM*/

  cmd_info_ptr->ss_code = (int) qmi_voice_cm_sups_colr;
  cmd_info_ptr->ss_ref = qmi_voice_cm_sups_get_ss_ref();

  ss_data.interr.ss_code = cmd_info_ptr->ss_code;
  ss_data.interr.ss_ref = cmd_info_ptr->ss_ref;
  ss_data.interr.basic_service.present = FALSE;

  /* fill the sups params required for sups string construction */
  memset(&ss_params, 0, sizeof(ss_params));
  ss_params.mode = QMI_VOICE_CM_SUPS_MODE_QUERY;
  ss_params.code = (qmi_voice_cm_sups_operation_code_e_type) ss_data.interr.ss_code;
  
  /* Invoke Sups String Construction. The string should be sent to modem 
  for any call control */
  if( E_SUCCESS != qmi_voice_cm_sups_build_sups_string(&ss_params, ss_buf, QMI_VOICE_CM_SUPS_MAX_SUPS_LENGTH) )
  {
    QM_MSG_ERROR("Sups string construction failed ");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,FALSE,FALSE);
    return;
  }

  QM_MSG_LOW_1( "Sups String constructed is %s", ss_buf);
  memset(&dialed_digits,0,sizeof(dialed_digits));
  dialed_digits.len = memscpy(dialed_digits.buf, sizeof(dialed_digits.buf),ss_buf, strlen(ss_buf));
  dialed_digits.digit_mode = CM_DIGIT_MODE_8BIT_ASCII;

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
              QMI_VOICE_CMD_AWAITING_CALLBACK,
              QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
              cmd_info_ptr->ss_ref, &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
  {
    /* Out of cmd list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }


#ifdef FEATURE_DUAL_SIM
  QM_MSG_MED_1("cm_sups_cmd_interrogate_cc_exten_per_subs(), Colr ss_ref = %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_cc_exten_per_subs(qmi_voice_cm_if_sups_exten_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                                &ss_data.interr,
                                                                &dialed_digits,
                                                                CM_ORIG_CLIENT_CATEG_USER,
                                                                FALSE,
                                                               (sys_modem_as_id_e_type)as_id );

#else
  QM_MSG_MED_1("cm_sups_cmd_interrogate_exten()with ss_ref %d", cmd_info_ptr->ss_ref);
  cm_result = cm_sups_cmd_interrogate_exten(qmi_voice_cm_if_sups_exten_command_callback,
                                                               (void*)params_ptr->header.handle,
                                                               qmi_voice_cm_if_get_clientid(),
                                                                &ss_data.interr,
                                                                &dialed_digits,
                                                                CM_ORIG_CLIENT_CATEG_USER);
#endif /*FEATURE_DUAL_SIM*/  
  if(!cm_result)
  {
    QM_MSG_ERROR("CM returned error for cm_sups_cmd_interrogate_extern() ");

    /* send QMI_ERR_INTERNAL response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
  }
} /* qmi_voice_cm_if_sups_get_colr */

/*===========================================================================
  FUNCTION qmi_voice_cm_if_sups_manage_ip_calls()

  DESCRIPTION
    Manage the call dependant sups for VoIP Calls.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_manage_ip_calls
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  qmi_voice_cm_if_manage_calls_s *in_data_ptr;
  sys_sys_mode_e_type     sys_mode = SYS_SYS_MODE_NO_SRV;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  qmi_voice_cmd_list_public_type cmd_info;

    /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );
  in_data_ptr = (qmi_voice_cm_if_manage_calls_s *)(&params_ptr->data);
  /*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
 qmi_voice_asid(params_ptr);
#endif

  if(qmi_voice_call_list_query_sys_mode_from_call_list(&sys_mode, as_id) == E_SUCCESS)
  {
    QM_MSG_MED_1("Inside qmi_voice_cm_if_sups_manage_ip_calls(), found a call list entry mode=%d:", sys_mode);
  }  


  /* If the sys mode is not GW, send error response */

  /* case where MNG_CALLS_REQ is in progress . Allow only local requests which don't disturb with the network operation.*/
  memset(&cmd_info, 0, sizeof(cmd_info));
  if (qmi_voice_cmd_list_query_by_event_all_states( QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF, &cmd_info, as_id ) == E_SUCCESS)
  {
     QM_MSG_HIGH_2("One instance of MNG_CALLS_REQ Already exists cmd=%d, sups_type=%d", cmd_info.cmd, cmd_info.sub_id);
     qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INCOMPATIBLE_STATE,FALSE,FALSE);
     return;
  }

  QM_MSG_HIGH_1("qmi_voice_cm_if_sups_manage_ip_calls :: sups_type for VoIP calls  %d", in_data_ptr->sups_type);

  switch(in_data_ptr->sups_type)
  {
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_RELEASE_HELD_OR_WAITING:
      qmi_voice_cm_if_sups_release_held_or_waiting(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING :
      qmi_voice_cm_if_sups_release_active_accept_held_or_waiting(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD :
      qmi_voice_cm_if_sups_hold_active_accept_waiting_or_held(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_MAKE_CONFERENCE_CALL :
      qmi_voice_cm_if_sups_make_conference_call(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_END_ALL_CALLS :
      qmi_voice_cm_if_sups_end_all_calls(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_MODIFY_CALL :
      qmi_voice_cm_if_sups_modify_ip_calls(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_MODIFY_ACCEPT :
      qmi_voice_cm_if_sups_modify_accept_ip_calls(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_MODIFY_REJECT :
      qmi_voice_cm_if_sups_modify_reject_ip_calls(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_RELEASE_SPECIFIED_CALL_FROM_CONFERENCE :
      qmi_voice_cm_if_sups_release_specified_call_from_conference(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_ADD_PARTICIPANT :
      qmi_voice_cm_if_sups_add_participant(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_CALL_DEFLECTION :
      qmi_voice_cm_if_sups_call_deflection(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_PER_CALL:
      qmi_voice_cm_if_sups_hold_ip_calls(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_RESUME_PER_CALL:
      qmi_voice_cm_if_sups_resume_ip_calls(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_SWITCH_SPEECH_CODEC:
      qmi_voice_cm_if_sups_switch_speech_codec(params_ptr);
      break;
    case QMI_VOICE_CM_IF_MNG_IP_CALLS_EXPLICIT_CALL_TRANSFER_VOIP:
      qmi_voice_cm_if_sups_explicit_call_transfer_voip(params_ptr);
      break;
    default :
      qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INVALID_ARG,FALSE,FALSE);
      return;
  }
} /* qmi_voice_cm_if_sups_manage_ip_calls */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_LOOKUP_EVENT_NAME()

  DESCRIPTION
    Look up the event name in the CM Call/Sups events list.

  PARAMETERS
    event_id        : event of type qmi_voice_cm_if_evt_e_type

  RETURN VALUE
    Pointer to event name string

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
const char *qmi_voice_cm_if_lookup_event_name
(
  int event_id
)
{
  switch(event_id)
  {
    case QMI_VOICE_CM_IF_EVT_CALL_ORIG:
      return "CM_CALL_EVENT_ORIG";

    case QMI_VOICE_CM_IF_EVT_CALL_ANSWER:
      return "CM_CALL_EVENT_ANSWER";

    case QMI_VOICE_CM_IF_EVT_CALL_END_REQ:
      return "CM_CALL_EVENT_END_REQ";

    case QMI_VOICE_CM_IF_EVT_CALL_END:
      return "CM_CALL_EVENT_END";

    case QMI_VOICE_CM_IF_EVT_CALL_INCOM:
      return "CM_CALL_EVENT_INCOM";

    case QMI_VOICE_CM_IF_EVT_CALL_CONNECT:
      return "CM_CALL_EVENT_CONNECT";

    case QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF:
      return "CM_CALL_EVENT_MNG_CALLS_CONF";

    case QMI_VOICE_CM_IF_EVT_CALL_BARRED:
      return "CM_CALL_EVENT_CALL_BARRED";

    case QMI_VOICE_CM_IF_EVT_CALL_ON_HOLD:
      return "CM_CALL_EVENT_CALL_ON_HOLD";

    case QMI_VOICE_CM_IF_EVT_CALL_IS_WAITING:
      return "CM_CALL_EVENT_CALL_IS_WAITING";

    case QMI_VOICE_CM_IF_EVT_CALL_RETRIEVED:
      return "CM_CALL_EVENT_CALL_RETRIEVED";

    case QMI_VOICE_CM_IF_EVT_CALL_ORIG_FWD_STATUS:
      return "CM_CALL_EVENT_ORIG_FWD_STATUS";

    case QMI_VOICE_CM_IF_EVT_CALL_FORWARDED:
      return "CM_CALL_EVENT_CALL_FORWARDED";

    case QMI_VOICE_CM_IF_EVT_CALL_BEING_FORWARDED:
      return "CM_CALL_EVENT_CALL_BEING_FORWARDED";

    case QMI_VOICE_CM_IF_EVT_CALL_INCOM_FWD_CALL:
      return "CM_CALL_EVENT_INCOM_FWD_CALL";

    case QMI_VOICE_CM_IF_EVT_CALL_RESTRICTED:
      return "CM_CALL_EVENT_CALL_RESTRICTED";

    case QMI_VOICE_CM_IF_EVT_CALL_CUG_INFO_RECEIVED:
      return "CM_CALL_EVENT_CUG_INFO_RECEIVED";

    case QMI_VOICE_CM_IF_EVT_CALL_SETUP_IND:
      return "CM_CALL_EVENT_SETUP_IND";

    case QMI_VOICE_CM_IF_EVT_CALL_PROGRESS_INFO_IND:
      return "CM_CALL_EVENT_PROGRESS_INFO_IND";

    case QMI_VOICE_CM_IF_EVT_CALL_DEFLECTION:
      return "CM_CALL_EVENT_CALL_DEFLECTION";

    case QMI_VOICE_CM_IF_EVT_CALL_TRANSFERRED_CALL:
      return "CM_CALL_EVENT_TRANSFERRED_CALL";

    case QMI_VOICE_CM_IF_EVT_CALL_SUPS:
      return "CM_CALL_EVENT_SUPS";

    case QMI_VOICE_CM_IF_EVT_CALL_CNAP_INFO_RECEIVED:
      return "CM_CALL_EVENT_CNAP_INFO_RECEIVED";

    case QMI_VOICE_CM_IF_EVT_CALL_PRIVACY:
      return "CM_CALL_EVENT_PRIVACY";

    case QMI_VOICE_CM_IF_EVT_CALL_PRIVACY_PREF:
      return "CM_CALL_EVENT_PRIVACY_PREF";

    case QMI_VOICE_CM_IF_EVT_CALL_CALLER_ID:
      return "CM_CALL_EVENT_CALLER_ID";

    case QMI_VOICE_CM_IF_EVT_ABRV_ALERT:
      return "CM_CALL_EVENT_ABRV_ALERT";

    case QMI_VOICE_CM_IF_EVT_CALL_SIGNAL:
      return "CM_CALL_EVENT_SIGNAL";

    case QMI_VOICE_CM_IF_EVT_CALL_DISPLAY:
      return "CM_CALL_EVENT_DISPLAY";

    case QMI_VOICE_CM_IF_EVT_CALL_CALLED_PARTY:
      return "CM_CALL_EVENT_CALLED_PARTY";

    case QMI_VOICE_CM_IF_EVT_CALL_CONNECTED_NUM:
      return "CM_CALL_EVENT_CONNECTED_NUM";

    case QMI_VOICE_CM_IF_EVT_CALL_EXT_DISP:
      return "CM_CALL_EVENT_EXT_DISP";

    case QMI_VOICE_CM_IF_EVT_CALL_NSS_CLIR_REC:
      return "CM_CALL_EVENT_NSS_CLIR_REC";

    case QMI_VOICE_CM_IF_EVT_CALL_NSS_REL_REC:
      return "CM_CALL_EVENT_NSS_REL_REC";

    case QMI_VOICE_CM_IF_EVT_CALL_NSS_AUD_CTRL:
      return "CM_CALL_EVENT_NSS_AUD_CTRL";

    case QMI_VOICE_CM_IF_EVT_CALL_L2ACK_CALL_HOLD:
      return "CM_CALL_EVENT_L2ACK_CALL_HOLD";      

    case QMI_VOICE_CM_IF_EVT_CALL_REDIRECTING_NUMBER:
      return "CM_CALL_EVENT_REDIRECTING_NUMBER";

    case QMI_VOICE_CM_IF_EVT_CALL_LINE_CTRL:
      return "CM_CALL_EVENT_LINE_CTRL";

    case QMI_VOICE_CM_IF_EVT_CALL_ON_HOLD_BY_REMOTE:
      return "CM_CALL_EVENT_CALL_ON_HOLD_BY_REMOTE";

    case QMI_VOICE_CM_IF_EVT_CALL_RETRIEVE_BY_REMOTE:
      return "CM_CALL_EVENT_CALL_RETRIEVE_BY_REMOTE";      

    case QMI_VOICE_CM_IF_EVT_CALL_MODIFY_IND:
      return "CM_CALL_EVENT_MODIFY_IND";  

    case QMI_VOICE_CM_IF_EVT_CALL_MODIFY_COMPLETE_CONF:
      return "CM_CALL_EVENT_MODIFY_COMPLETE_CONF";        

    case QMI_VOICE_CM_IF_EVT_CALL_INFO:
      return "CM_CALL_EVENT_INFO";

    case QMI_VOICE_CM_IF_EVT_CALL_OTASP_STATUS:
      return "CM_CALL_EVENT_OTASP_STATUS";

    case QMI_VOICE_CM_IF_EVT_CALL_ORIG_MOD_TO_SUPS:
      return "CM_CALL_EVENT_ORIG_MOD_TO_SUPS";

    case QMI_VOICE_CM_IF_EVT_CALL_PROGRESS_EARLY_MEDIA:
      return "CM_CALL_EVENT_PROGRESS_EARLY_MEDIA";

    case QMI_VOICE_CM_IF_EVT_CALL_SPEECH_CODEC_INFO:
      return "CM_CALL_EVENT_SPEECH_CODEC_INFO"; 

    case QMI_VOICE_CM_IF_EVT_INBAND_REV_BURST_DTMF:
      return "CM_INBAND_EVENT_REV_BURST_DTMF";

    case QMI_VOICE_CM_IF_EVT_INBAND_REV_START_CONT_DTMF:
      return "CM_INBAND_EVENT_REV_START_CONT_DTMF";

    case QMI_VOICE_CM_IF_EVT_INBAND_REV_STOP_CONT_DTMF:
      return "CM_INBAND_EVENT_REV_STOP_CONT_DTMF";

    case QMI_VOICE_CM_IF_EVT_INBAND_FWD_BURST_DTMF:
      return "CM_INBAND_EVENT_FWD_BURST_DTMF";

    case QMI_VOICE_CM_IF_EVT_INBAND_FWD_START_CONT_DTMF:
      return "CM_INBAND_EVENT_FWD_START_CONT_DTMF";

    case QMI_VOICE_CM_IF_EVT_INBAND_FWD_STOP_CONT_DTMF:
      return "CM_INBAND_EVENT_FWD_STOP_CONT_DTMF";

    case QMI_VOICE_CM_IF_EVT_INBAND_REV_START_CONT_DTMF_CONF:
      return "CM_INBAND_EVENT_REV_START_CONT_DTMF_CONF";

    case QMI_VOICE_CM_IF_EVT_INBAND_REV_STOP_CONT_DTMF_CONF:
      return "CM_INBAND_EVENT_REV_STOP_CONT_DTMF_CONF";

   case QMI_VOICE_CM_IF_EVT_INBAND_IP_START_DTMF_IND:
   	return "QMI_VOICE_CM_IF_EVT_INBAND_IP_START_DTMF_IND";

   case QMI_VOICE_CM_IF_EVT_INBAND_IP_STOP_DTMF_IND:
   	return "QMI_VOICE_CM_IF_EVT_INBAND_IP_STOP_DTMF_IND";

    case QMI_VOICE_CM_IF_EVT_SUPS_REGISTER:
      return "CM_SUPS_EVENT_REGISTER";

    case QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF:
      return "CM_SUPS_EVENT_REGISTER_CONF";

    case QMI_VOICE_CM_IF_EVT_SUPS_ERASE:
      return "CM_SUPS_EVENT_ERASE";
      
    case QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF:
      return "CM_SUPS_EVENT_ERASE_CONF";

    case QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE:
      return "CM_SUPS_EVENT_ACTIVATE";
      
    case QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF:
      return "CM_SUPS_EVENT_ACTIVATE_CONF";

    case QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE:
      return "CM_SUPS_EVENT_DEACTIVATE";

    case QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF:
      return "CM_SUPS_EVENT_DEACTIVATE_CONF";

    case QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE:
      return "CM_SUPS_EVENT_INTERROGATE";
      
    case QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF:
      return "CM_SUPS_EVENT_INTERROGATE_CONF";

    case QMI_VOICE_CM_IF_EVT_SUPS_REG_PASSWORD:
      return "CM_SUPS_EVENT_REG_PASSWORD";
      
    case QMI_VOICE_CM_IF_EVT_SUPS_REG_PASSWORD_CONF:
      return "CM_SUPS_EVENT_REG_PASSWORD_CONF";

    case QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS:
      return "CM_SUPS_EVENT_PROCESS_USS";
      
    case QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF:
      return "CM_SUPS_EVENT_PROCESS_USS_CONF";

    case QMI_VOICE_CM_IF_EVT_SUPS_USS_NOTIFY_IND:
      return "CM_SUPS_EVENT_USS_NOTIFY_IND";

    case QMI_VOICE_CM_IF_EVT_SUPS_USS_IND:
      return "CM_SUPS_EVENT_USS_IND";

    case QMI_VOICE_CM_IF_EVT_SUPS_RELEASE_USS_IND:
      return "CM_SUPS_EVENT_RELEASE_USS_IND";

    case QMI_VOICE_CM_IF_EVT_SUPS_CC_RESULT_INFO:
      return "CM_SUPS_EVENT_CC_RESULT_INFO";

    case QMI_VOICE_CM_IF_EVT_SUPS_GET_PASSWORD_IND:
      return "CM_SUPS_EVENT_GET_PASSWORD_IND";

    case QMI_VOICE_CM_IF_EVT_NONE:
      return "QMI_VOICE_CM_IF_EVT_NONE";

    case QMI_VOICE_CM_IF_EVT_SUPS_SS_MOD_TO_ORIG:
      return "CM_SUPS_EVENT_SS_MOD_TO_ORIG";

    case QMI_VOICE_CM_IF_EVT_PH_SUBSCRIPTION_AVAILABLE:
      return "CM_PH_EVENT_SUBSCRIPTION_AVAILABLE";

    case QMI_VOICE_CM_IF_EVT_PH_SELECTED_LINE:
      return "CM_PH_EVENT_SELECTED_LINE";

    case QMI_VOICE_CM_IF_EVT_PH_INFO:
      return "CM_PH_EVENT_INFO";

    case QMI_VOICE_CM_IF_EVT_OPRT_MODE:
      return "CM_PH_EVENT_OPRT_MOD";

    case QMI_VOICE_CM_IF_EVT_PH_RESET_ACM_COMPLETED:
      return "CM_PH_EVENT_RESET_ACM_COMPLETED"; 

    case QMI_VOICE_CM_IF_EVT_PH_SET_ACMMAX_COMPLETED:
      return "CM_PH_EVENT_SET_ACMMAX_COMPLETED";

    case QMI_VOICE_CM_IF_EVT_PH_FUNDS_LOW:
      return "CM_PH_EVENT_FUNDS_LOW";

    case QMI_VOICE_CM_IF_EVT_EMERGENCY_FLASHED:
      return "CM_CALL_EVENT_EMERGENCY_FLASHED";

    case QMI_VOICE_CM_IF_EVT_SS_SRV_CHANGED:
      return "CM_SS_EVENT_SRV_CHANGED";

    case QMI_VOICE_CM_IF_EVT_SS_INFO:
      return "CM_SS_EVENT_INFO";
	  
    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_START:
      return "CM_CALL_EVENT_HO_START";

    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_FAIL:
      return "CM_CALL_EVENT_HO_FAIL";

    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_COMPLETE:
      return "CM_CALL_EVENT_HO_COMPLETE";

    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_CANCEL:
      return "CM_CALL_EVENT_HO_CANCEL";

    case QMI_VOICE_CM_IF_EVT_CALL_BRST_INTL_IND:
      return "CM_CALL_EVENT_EXT_BRST_INTL";

    case QMI_VOICE_CM_IF_EVT_CONF_AND_USER_INFO_IND:
      return "CM_CALL_EVENT_CONFERENCE_INFO";

    case QMI_VOICE_CM_IF_EVT_CONFERENCE_JOIN_IND:
      return "CM_CALL_EVENT_JOIN_CONFERENCE";

    case QMI_VOICE_CM_IF_EVT_MT_CALL_PAGE_FAIL:
      return "CM_CALL_EVENT_MT_CALL_PAGE_FAIL";

    case QMI_VOICE_CM_IF_EVT_MPTY_CALL_IND:
      return "CM_CALL_EVENT_MPTY_CALL_IND";

    case QMI_VOICE_CM_IF_EVT_CALL_RAT_CHANGE:
      return "CM_CALL_EVENT_RAT_CHANGE";

    case QMI_VOICE_CM_IF_EVT_CC_RESULT_INFO:
      return "CM_CALL_EVENT_CC_RESULT_INFO";

    case QMI_VOICE_CM_IF_EVT_E911_ORIG_FAIL:
      return "CM_CALL_EVENT_E911_ORIG_FAIL";

    case QMI_VOICE_CM_IF_EVT_CALL_SWITCH_CODEC_CNF:
      return "CM_CALL_EVENT_SWITCH_CODEC_CNF";

    case QMI_VOICE_CM_IF_EVT_CALL_VOIP_CALL_END_CNF:
      return "CM_CALL_EVENT_VOIP_CALL_END_CNF";

    default:
      QM_MSG_HIGH_1("Unrecognized Event recieved:  (%d)", event_id);
      return "<UNKNOWN EVENT>?";
  }
} /* qmi_voice_cm_if_lookup_event_name */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_LOOKUP_CMD_NAME()

  DESCRIPTION
    Look up the command name 

  PARAMETERS
    cmd        : command of type qmi_voice_cm_if_cmd_e_type

  RETURN VALUE
    Pointer to cmd name string

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
const char *qmi_voice_cm_if_lookup_cmd_name
( 
  int cmd
)
{
  switch(cmd)
  {
    case QMI_VOICE_CM_IF_CMD_INDICATION_REGISTER:
      return "CM IF INDICATION REGISTER";
    case QMI_VOICE_CM_IF_CMD_DIAL_CALL:
      return "CM IF DIAL CALL";
    case QMI_VOICE_CM_IF_CMD_END_CALL:
      return "CM IF END CALL";
    case QMI_VOICE_CM_IF_CMD_ANSWER_CALL:
      return "ANSWER CALL";
    case QMI_VOICE_CM_IF_CMD_SETUP_ANSWER:
      return "SETUP ANSWER";
    case QMI_VOICE_CM_IF_CMD_GET_CALL_INFO:
      return "CM IF GET CALL INFO";
    case QMI_VOICE_CM_IF_CMD_SEND_FLASH:
      return "CM IF SEND FLASH";
    case QMI_VOICE_CM_IF_CMD_BURST_DTMF:
      return "CM IF BURST DTMF";
    case QMI_VOICE_CM_IF_CMD_START_CONT_DTMF:
      return "CM IF START CONT DTMF";
    case QMI_VOICE_CM_IF_CMD_STOP_CONT_DTMF:
      return "CM IF STOP CONT DTMF";
    case QMI_VOICE_CM_IF_CMD_SET_PREFERRED_PRIVACY:
      return "CM IF SET PREFERRED PRIVACY";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIR:
      return "CM IF GET CLIR";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_FORWARDING:
      return "CM IF GET CALL FORWARDING";
    case QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_CALLS:
      return "CM IF MANAGE CALLS";
    case QMI_VOICE_CM_IF_CMD_GET_ALL_CALL_INFO:
      return "CM IF GET ALL CALL INFO";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIP:
      return "CM IF GET CLIP";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_WAITING:
      return "CM IF GET CALL WAITING";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_BARRING:
      return "CM IF GET CALL BARRING";
    case QMI_VOICE_CM_IF_CMD_SUPS_SET_CALL_BARRING:
      return "CM IF SET CALL BARRING PASSWORD";
    case QMI_VOICE_CM_IF_CMD_SUPS_SET_SUPS_SERVICE:
      return "CM IF SET SUPS SERVICE";
    case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD:
      return "CM IF ORIG USSD";
    case QMI_VOICE_CM_IF_CMD_SUPS_ANSWER_USSD:
      return "CM IF ANSWER USSD";
    case QMI_VOICE_CM_IF_CMD_SUPS_CANCEL_USSD:
      return "CM IF CANCEL USSD";
    case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_NO_WAIT:
      return "CM IF ORIG USSD NO WAIT";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_COLP:
      return "CM IF GET COLP";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_COLR:
      return "CM IF GET COLR";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CNAP:
      return "CM IF GET CNAP";	  
    case QMI_VOICE_CM_IF_CMD_SRVCC_CALL_CONFIG:
      return "CM IF SRVCC CALL CONFIG";
    case QMI_VOICE_CM_IF_CMD_SRVCC_CALL_CONFIG_RESP:
      return "CM IF SRVCC CALL CONFIG RESP";
    case QMI_VOICE_CM_IF_CMD_ALS_SET_LINE_SWITCHING:
      return "CM IF ALS SET LINE SWITCHING";
    case QMI_VOICE_CM_IF_CMD_ALS_SELECT_LINE:
      return "CM IF ALS SELECT LINE";
    case QMI_VOICE_CM_IF_CMD_AOC_RESET_ACM:
      return "CM IF AOC RESET ACM";
    case QMI_VOICE_CM_IF_CMD_AOC_SET_ACMMAX:
      return "CM IF AOC SET ACMMAX";
    case QMI_VOICE_CM_IF_CMD_AOC_GET_CALL_METER_INFO:
      return "CM IF AOC GET CALL METER INFO";
    case QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS:
      return "CM IF MANAGE IP CALLS";
    case QMI_VOICE_CM_IF_CMD_INDICATION_REGISTER_RESP:
      return "CM IF INDICATION REGISTER RESP";
    case QMI_VOICE_CM_IF_CMD_DIAL_CALL_RESP:
      return "CM IF DIAL CALL RESP";
    case QMI_VOICE_CM_IF_CMD_END_CALL_RESP:
      return "CM IF END CALL RESP";
    case QMI_VOICE_CM_IF_CMD_ANSWER_CALL_RESP:
      return "CM IF ANSWER CALL RESP";
    case QMI_VOICE_CM_IF_CMD_SETUP_ANSWER_RESP:
      return "CM IF SETUP ANSWER RESP";
    case QMI_VOICE_CM_IF_CMD_GET_CALL_INFO_RESP:
      return "CM IF GET CALL INFO RESP";
    case QMI_VOICE_CM_IF_CMD_SEND_FLASH_RESP:
      return "CM IF SEND FLASH RESP";
    case QMI_VOICE_CM_IF_CMD_BURST_DTMF_RESP:
      return "CM IF BURST DTMF RESP";
    case QMI_VOICE_CM_IF_CMD_START_CONT_DTMF_RESP:
      return "CM IF START CONT DTMF RESP";
    case QMI_VOICE_CM_IF_CMD_STOP_CONT_DTMF_RESP:
      return "CM IF STOP CONT DTMF RESP";
    case QMI_VOICE_CM_IF_CMD_SET_PREFERRED_PRIVACY_RESP:
      return "CM IF SET PREFERRED PRIVACY RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIR_RESP:
      return "CM IF GET CLIR RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_FORWARDING_RESP:
      return "CM IF GET CALL FORWARDING RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIP_RESP:
      return "CM IF GET CLIP RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_WAITING_RESP:
      return "CM IF GET CALL WAITING RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_BARRING_RESP:
      return "CM IF GET CALL BARRING RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_SET_CALL_BARRING_RESP:
      return "CM IF SET CALL BARRING PASSWORD RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_SET_SUPS_SERVICE_RESP:
      return "CM IF SET SUPS SERVICE RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_CALLS_RESP:
      return "CM IF MANAGE CALLS RESP";
    case QMI_VOICE_CM_IF_CMD_GET_ALL_CALL_INFO_RESP:
      return "CM IF GET ALL CALL INFO RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_RESP:
      return "CM IF ORIG USSD RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_ANSWER_USSD_RESP:
      return "CM IF ANSWER USSD RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_CANCEL_USSD_RESP:
      return "CM IF CANCEL USSD RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_COLP_RESP:
      return "CM IF SUPS GET COLP RESP";
   case QMI_VOICE_CM_IF_CMD_SUPS_GET_COLR_RESP:
      return "CM IF ALS SUPS GET COLR RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CNAP_RESP:
      return "CM IF ALS SUPS GET CNAP RESP";
    case QMI_VOICE_CM_IF_CMD_ALS_SET_LINE_SWITCHING_RESP:
      return "CM IF ALS SET LINE SWITCHING RESP";
    case QMI_VOICE_CM_IF_CMD_ALS_SELECT_LINE_RESP:
      return "CM IF ALS SELECT LINE RESP";
    case QMI_VOICE_CM_IF_CMD_AOC_RESET_ACM_RESP:
      return "CM IF AOC RESET ACM RESP";
    case QMI_VOICE_CM_IF_CMD_AOC_SET_ACMMAX_RESP:
      return "CM IF AOC SET ACMMAX RESP";
    case QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS_RESP:
      return "CM IF MANAGE IP CALLS RESP";
    case QMI_VOICE_CM_IF_CMD_INFO_REC_IND:
      return "CM IF INFO REC IND";
    case QMI_VOICE_CM_IF_CMD_OTASP_STATUS_IND:
      return "CM IF OTASP STATUS IND";
    case QMI_VOICE_CM_IF_CMD_PRIVACY_IND:
      return "CM IF PRIVACY IND";
    case QMI_VOICE_CM_IF_CMD_DTMF_IND:
      return "CM IF DTMF IND";
    case QMI_VOICE_CM_IF_CMD_SUPS_NOTIFICATION_IND:
      return "CM IF SUPS NOTIFICATION IND";
    case QMI_VOICE_CM_IF_CMD_ALL_CALL_STATUS_IND:
      return "CM IF ALL CALL STATUS IND";
    case QMI_VOICE_CM_IF_CMD_SUPS_USSD_IND:
      return "CM IF USSD IND";
    case QMI_VOICE_CM_IF_CMD_SUPS_USSD_RELEASE_IND:
      return "CM IF USSD RELEASE IND";
    case QMI_VOICE_CM_IF_CMD_UUS_IND:
      return "CM IF UUS IND";
    case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_NO_WAIT_IND:
      return "CM IF ORIG USSD NO WAIT IND";
    case QMI_VOICE_CM_IF_CMD_CALL_CMD_CB:
      return "CM IF CALL CMD CB";
    case QMI_VOICE_CM_IF_CMD_CALL_CMD_EXTEN_CB:
      return "CM IF CALL CMD EXTEN CB";
    case QMI_VOICE_CM_IF_CMD_SUPS_CMD_CB:
      return "CM IF SUPS CMD CB";
    case QMI_VOICE_CM_IF_CMD_SUPS_CMD_EXTEN_CB:
      return "CM IF SUPS CMD EXTEN CB";
    case QMI_VOICE_CM_IF_CMD_INBAND_CMD_CB:
      return "CM IF INBAND CMD CB";
    case QMI_VOICE_CM_IF_CMD_PH_CMD_CB:
      return "CM IF PH CMD CB";
    case QMI_VOICE_CM_IF_CMD_CALL_EVT_CB:
      return "CM IF CALL EVT CB";
    case QMI_VOICE_CM_IF_CMD_SUPS_EVT_CB:
      return "CM IF SUPS EVT CB";
    case QMI_VOICE_CM_IF_CMD_INBAND_EVT_CB:
      return "CM IF INBAND EVT CB";
    case QMI_VOICE_CM_IF_CMD_CALL_MOD_TO_SUPS:
      return "CM IF CALL MOD TO SUPS";
    case QMI_VOICE_CM_IF_CMD_SUPS_MOD_TO_SUPS:
      return "CM IF SUPS MOD TO SUPS";
    case QMI_VOICE_CM_IF_CMD_PH_EVT_CB:
      return "CM IF PH EVT CB";
    case QMI_VOICE_CM_IF_CMD_ALS_GET_LINE_SWITCHING_STATUS:
      return "CM IF GET LINE SWITCHING STATUS";	  
    case QMI_VOICE_CM_IF_CMD_ALS_GET_SELECTED_LINE:
      return "CM IF GET SELECTED LINE";		
    case QMI_VOICE_CM_IF_CMD_ALS_GET_LINE_SWITCHING_STATUS_RESP:
      return "CM IF GET LINE SWITCHING STATUS RESP";	  
    case QMI_VOICE_CM_IF_CMD_ALS_GET_SELECTED_LINE_RESP:
      return "CM IF GET SELECTED LINE RESP";	
    case QMI_VOICE_CM_IF_CMD_SS_EVT_CB:
      return "CM IF SS EVT CB";
    case QMI_VOICE_CM_IF_CMD_CALL_ENCRYPTION:
      return "CM IF CALL ENCRYPTION REQ";
    case QMI_VOICE_CM_IF_CMD_CALL_ENCRYPTION_RESP:
      return "CM IF CALL ENCRYPTION RESP";
    default:
      QM_MSG_HIGH_1("Unrecognized cmd received: (%d)", cmd);
      return "<UNKNOWN VOICE COMMAND>?";
  }

} /* qmi_voice_cm_if_lookup_cmd_name() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_PROCESS_CMD()

  DESCRIPTION
    Process the commands posted to CM Interface layer

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_process_cmd
(
  qmi_mmode_cmd_enum_type        cmd,
  void                   * user_data_ptr
)
{
  #ifndef FEATURE_NO_QMI_VOICE
  qmi_mmode_cmd_data_buf_type *  data_ptr;
  data_ptr = (qmi_mmode_cmd_data_buf_type *) user_data_ptr;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  ASSERT (data_ptr);
  ASSERT (data_ptr->cmd.cm_if_data_ptr);
  ASSERT (data_ptr->cmd.cm_if_data_ptr->header.cmd < QMI_VOICE_CM_IF_CMD_MAX);

  switch (data_ptr->cmd.cm_if_data_ptr->header.cmd)
  {
    case QMI_VOICE_CM_IF_CMD_DIAL_CALL:
      qmi_voice_cm_if_dial_call( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_GET_CALL_INFO:
      qmi_voice_cm_if_get_call_info( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_END_CALL:
      qmi_voice_cm_if_end_call( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_ANSWER_CALL:
      qmi_voice_cm_if_answer_call( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SETUP_ANSWER:
      qmi_voice_cm_if_setup_answer( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_GET_ALL_CALL_INFO:
      qmi_voice_cm_if_get_all_call_info( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SEND_FLASH:
      qmi_voice_cm_if_send_flash( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SET_PREFERRED_PRIVACY:
      qmi_voice_cm_if_set_preferred_privacy( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_BURST_DTMF:
      qmi_voice_cm_if_burst_dtmf( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_START_CONT_DTMF:
      qmi_voice_cm_if_start_cont_dtmf( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_STOP_CONT_DTMF:
      qmi_voice_cm_if_stop_cont_dtmf( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIR:
      qmi_voice_cm_if_sups_get_clir( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_FORWARDING:
      qmi_voice_cm_if_sups_get_call_forwarding( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIP:
      qmi_voice_cm_if_sups_get_clip( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_WAITING:
      qmi_voice_cm_if_sups_get_call_waiting( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_BARRING:
      qmi_voice_cm_if_sups_get_call_barring( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_SET_CALL_BARRING:
      qmi_voice_cm_if_sups_change_call_barring_pwd( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_CALLS:
      qmi_voice_cm_if_sups_manage_calls( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_SET_SUPS_SERVICE:
      qmi_voice_cm_if_sups_set_sups_service( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD:
      qmi_voice_cm_if_sups_orig_ussd( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_CANCEL_USSD:
      qmi_voice_cm_if_sups_cancel_ussd( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_ANSWER_USSD:
      qmi_voice_cm_if_sups_answer_ussd( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SET_MODEM_CONFIG:
      qmi_voice_cm_if_set_modem_config( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_GET_MODEM_CONFIG:
      qmi_voice_cm_if_get_modem_config( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_NO_WAIT:
      qmi_voice_cm_if_sups_orig_ussd_no_wait( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_COLP:
      qmi_voice_cm_if_sups_get_colp( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_COLR:
      qmi_voice_cm_if_sups_get_colr( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CNAP:
      qmi_voice_cm_if_sups_get_cnap( data_ptr->cmd.cm_if_data_ptr );
      break;	  
    case QMI_VOICE_CM_IF_CMD_SRVCC_CALL_CONFIG:
      qmi_voice_cm_if_srvcc_call_config_req( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_ALS_SET_LINE_SWITCHING:
      qmi_voice_cm_if_als_set_line_switching( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_ALS_SELECT_LINE:
      qmi_voice_cm_if_als_select_line( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_AOC_RESET_ACM:
      qmi_voice_cm_if_aoc_reset_acm( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_AOC_SET_ACMMAX:
      qmi_voice_cm_if_aoc_set_acmmax( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_AOC_GET_CALL_METER_INFO:
      qmi_voice_cm_if_aoc_get_call_meter_info( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_AOC_LOW_FUNDS_IND:
      qmi_voice_cm_if_send_aoc_low_funds_ind( (data_ptr->cmd.cm_if_data_ptr)->header.as_id );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS:
      qmi_voice_cm_if_sups_manage_ip_calls( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_CALL_CMD_CB:
      qmi_voice_cm_if_call_cmd_cb_handler( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_CALL_CMD_EXTEN_CB:
      qmi_voice_cm_if_call_cmd_exten_cb_handler( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_CMD_CB:
      qmi_voice_cm_if_sups_cmd_cb_handler( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_CMD_EXTEN_CB:
      qmi_voice_cm_if_sups_cmd_exten_cb_handler( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_INBAND_CMD_CB:
      qmi_voice_cm_if_inband_cmd_cb_handler( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_PH_CMD_CB:
      qmi_voice_cm_if_ph_cmd_cb_handler( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_CALL_EVT_CB:
      qmi_voice_cm_if_call_evt_cb_handler( (qmi_voice_cm_if_evt_e_type)data_ptr->cmd.cm_if_data_ptr->data.call_evt_cb.event, 
                                         &data_ptr->cmd.cm_if_data_ptr->data.call_evt_cb.call_info);
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_EVT_CB:
      qmi_voice_cm_if_sups_evt_cb_handler( (qmi_voice_cm_if_evt_e_type)data_ptr->cmd.cm_if_data_ptr->data.sups_evt_cb.event, 
                                         &data_ptr->cmd.cm_if_data_ptr->data.sups_evt_cb.sups_info);
      break;
    case QMI_VOICE_CM_IF_CMD_INBAND_EVT_CB:
      qmi_voice_cm_if_inband_evt_cb_handler( (qmi_voice_cm_if_evt_e_type)data_ptr->cmd.cm_if_data_ptr->data.inband_evt_cb.event, 
                                         &data_ptr->cmd.cm_if_data_ptr->data.inband_evt_cb.inband_info);
      break;
    case QMI_VOICE_CM_IF_CMD_PH_EVT_CB:
      qmi_voice_cm_if_ph_evt_cb_handler( (qmi_voice_cm_if_evt_e_type)data_ptr->cmd.cm_if_data_ptr->data.ph_evt_cb.event, 
                                         &data_ptr->cmd.cm_if_data_ptr->data.ph_evt_cb.ph_info);
      break;
    case QMI_VOICE_CM_IF_CMD_ALS_GET_LINE_SWITCHING_STATUS:
      qmi_voice_cm_if_als_get_line_switching_status( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_ALS_GET_SELECTED_LINE:
      qmi_voice_cm_if_als_get_selected_line( data_ptr->cmd.cm_if_data_ptr );
      break;
    case QMI_VOICE_CM_IF_CMD_SS_EVT_CB:
      qmi_voice_cm_if_ss_evt_cb_handler( (qmi_voice_cm_if_evt_e_type)data_ptr->cmd.cm_if_data_ptr ->data.ss_evt_cb.event, 
                                         &data_ptr->cmd.cm_if_data_ptr ->data.ss_evt_cb.ss_info);
      break;
    case QMI_VOICE_CM_IF_CMD_ECALL_ORIG_INFO_CMD_CB:
      qmi_voice_cm_if_ecall_orig_info_cb_handler(data_ptr->cmd.cm_if_data_ptr);
      break;
    case QMI_VOICE_CM_IF_CMD_CALL_CMD_ERR_CB:
      qmi_voice_cm_if_call_cmd_err_cb_handler(data_ptr->cmd.cm_if_data_ptr);
      break;
    case QMI_VOICE_CM_IF_CMD_CALL_ENCRYPTION:
      qmi_voice_cm_if_call_encryption_req(data_ptr->cmd.cm_if_data_ptr);
      break;
    case QMI_VOICE_CM_IF_CMD_CALL_ENCRYPTION_CMD_CB:
      qmi_voicei_call_encryption_resp(data_ptr->cmd.cm_if_data_ptr);
      break;
    default:
      QM_MSG_MED_1("Ignoring cmd %d", data_ptr->cmd.cm_if_data_ptr->header.cmd);
      break;
  }
  QMI_VOICE_CM_IF_MEM_FREE(data_ptr->cmd.cm_if_data_ptr);
  #else
  (void) cmd;
  (void) user_data_ptr;
  #endif /* !FEATURE_NO_QMI_VOICE */
  return;
}


/*===========================================================================

                             INTERNAL FUNCTIONS

===========================================================================*/

/*===========================================================================
                    CALL EVENTS PROCESSING
===========================================================================*/

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_call_event_user_data_ind

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_USER_DATA_IND

    @return
    None.
*/
/*=========================================================================*/
static void qmi_voice_cm_if_call_event_user_data_ind
(
  cm_mm_call_info_s_type *call_info_ptr
)
{

  cm_call_event_user_data_s_type  call_event_user_data;
  qmi_voice_cm_if_uus_data_s_type *uus_ptr = &cm_if_info.uus_data;
  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr );

  /*-----------------------------------------------------------------------*/
//  QM_MSG_MED_2("qmi_voice_cm_if_call_event_user_data_ind UUS Data ind :  call_id %d, uus present = %d", call_info_ptr->call_id, call_info_ptr->mode_info.info.gw_cs_call.end_user_data.mt_user_data.present);

  if(call_info_ptr->mode_info.info.gw_cs_call.end_user_data.mt_user_data.present)
  {
    memset(&call_event_user_data,0,sizeof(call_event_user_data));
    memset(uus_ptr,0,sizeof(*uus_ptr));

    memscpy(&call_event_user_data,sizeof(call_event_user_data),&call_info_ptr->mode_info.info.gw_cs_call.end_user_data,sizeof(cm_call_event_user_data_s_type));

    if(call_event_user_data.mt_user_data.present == FALSE)
    {
      QM_MSG_HIGH("UUS MT Data ind :  UUS Data not present");
      return ;
    }
    uus_ptr->call_id = call_info_ptr->call_id;
    memscpy((void*)&uus_ptr->user_data,sizeof(uus_ptr->user_data),(void*)&call_event_user_data,sizeof(call_event_user_data));
    QM_MSG_HIGH_6( " call_id %d, MT uus present = %d, UUS Len = %d, UUS Type = %d, UUS Data = %s, Dcs = %d ",
                    uus_ptr->call_id, uus_ptr->user_data.mt_user_data.present, uus_ptr->user_data.mt_user_data.user_user_data_length,
                    uus_ptr->user_data.mt_user_data.user_user_type,
                    uus_ptr->user_data.mt_user_data.user_user_data,
                    uus_ptr->user_data.mt_user_data.user_user_protocol_disc);
    QM_MSG_HIGH_6("cause_val=%d,Coding_standard=%d,Diagnostic Len=%d, location=%d,cause_present=%d,Rec_present=%d ", uus_ptr->user_data.cm_cc_cause.cause_value, uus_ptr->user_data.cm_cc_cause.coding_standard, 
		uus_ptr->user_data.cm_cc_cause.diagnostic_length, uus_ptr->user_data.cm_cc_cause.location, uus_ptr->user_data.cm_cc_cause.present, uus_ptr->user_data.cm_cc_cause.recommendation_present);
    if(uus_ptr->user_data.cm_cc_cause.recommendation_present)
    {
      QM_MSG_LOW_1("UUS Data Recommendation = %d ", uus_ptr->user_data.cm_cc_cause.recommendation);
    }
  }
} /* qmi_voice_cm_if_call_event_user_data_ind() */


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_call_event_orig

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_ORIG.

    @return
    None.
*/
/*=========================================================================*/
static void qmi_voice_cm_if_call_event_orig
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  cm_num_s_type     calling_num;
  voice_dial_call_resp_msg_v02 dial_call_resp;
  qmi_voice_cmd_list_public_type cmd_info;  
  uint8   conn_idx = QMI_VOICE_CM_UTIL_CONN_ID_INVALID;
  uint8   as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  qmi_voice_cm_util_ss_info_s util_sys_info;
  sys_sys_mode_e_type      sys_mode = SYS_SYS_MODE_NO_SRV;
  
  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr );

  /*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)call_info_ptr->asubs_id;
#endif

  memset(&dial_call_resp,0,sizeof(dial_call_resp));

  memset(&util_sys_info, 0, sizeof( util_sys_info));
  qmi_voice_cm_util_get_ss_info(&util_sys_info,as_id);
  sys_mode = util_sys_info.sys_mode; 

  QM_MSG_MED_1("In qmi_voice_cm_if_call_event_orig ::  sysmode =%d", call_info_ptr->sys_mode);

  if ( (call_info_ptr->call_type != CM_CALL_TYPE_PS_DATA) && ( call_info_ptr->call_type != CM_CALL_TYPE_CS_DATA) )
  {
    if(qmi_voice_cmd_list_query_by_event_and_sub_id_all_subs(QMI_VOICE_CM_IF_EVT_CALL_ORIG,call_info_ptr->call_id,&cmd_info) == E_SUCCESS)
    {
      QM_MSG_HIGH_1("qmi_voice_cm_if_call_event_orig:  Call control result from CM = %d", call_info_ptr->result_from_cc.call_control_result);
      switch(call_info_ptr->result_from_cc.call_control_result)
      {
        case CM_CC_RESULT_ALLOWED_NO_MODIFICATIONS:
          /* By default, calling number is the user dialed number */
          calling_num = call_info_ptr->num;
          break;
        case CM_CC_RESULT_ALLOWED_BUT_MODIFIED:
        case CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_VOICE:
          /* Calling number is the modified number */
          calling_num = call_info_ptr->result_from_cc.num;
          dial_call_resp.cc_result_type_valid = TRUE;
          dial_call_resp.cc_result_type = VOICE_CC_RESULT_TYPE_VOICE_V02;
          break;
        default:
          QM_MSG_HIGH_1("Invalid call control result %d from CM", call_info_ptr->result_from_cc.call_control_result);
          dial_call_resp.resp.result = QMI_RESULT_FAILURE_V01;
          dial_call_resp.resp.error = QMI_ERR_INTERNAL_V01;
          break;
      }
      if(cmd_info.as_id != as_id)
      {
        dial_call_resp.resp.result = QMI_RESULT_FAILURE_V01;
        dial_call_resp.resp.error = QMI_ERR_OP_PARTIAL_FAILURE_V01;
        QM_MSG_HIGH_2("Call shifted to a different sub: as_id %d -> %d", as_id, cmd_info.as_id);
      }
      if(call_info_ptr->result_from_cc.alpha.len > 0)
      {
        dial_call_resp.alpha_ident_valid = TRUE;
        qmi_voice_cm_util_copy_alpha_ident_from_cm(&(dial_call_resp.alpha_ident),&(call_info_ptr->result_from_cc.alpha));
  QM_MSG_HIGH_2("Recevied ALPHA DCS from CM = %d, Voice = %d", call_info_ptr->result_from_cc.alpha.dcs, dial_call_resp.alpha_ident.alpha_dcs);
      }
      if(qmi_voice_call_list_get_conn_idx_from_call_id( call_info_ptr->call_id, &conn_idx ) != E_SUCCESS)
      {
        QM_MSG_ERROR_1("Conn index not found for call id = %d ", call_info_ptr->call_id);
      }
      dial_call_resp.media_id_valid = TRUE;
      dial_call_resp.media_id = call_info_ptr->call_id;
      dial_call_resp.call_id_valid = TRUE;
      dial_call_resp.call_id = conn_idx;
      qmi_voice_cm_if_response_success(cmd_info.hdl,cmd_info.cmd,&dial_call_resp,sizeof(dial_call_resp),TRUE);

      /* Reset the eCall info */
      if(call_info_ptr->call_id == cm_if_info.eCall_info.eCall_id)
      {
        cm_if_info.eCall_info.eCall_id = CM_CALL_ID_INVALID;
        cm_if_info.eCall_info.eCall_client_id = CM_CLIENT_ID_ANONYMOUS;
        cm_if_info.eCall_info.as_id = QMI_VOICE_CM_IF_AS_ID_INVALID;
      }
    }
    else
    {
      if( (call_info_ptr->result_from_cc.call_control_result == CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_VOICE) ||
          (call_info_ptr->result_from_cc.call_control_result == CM_CC_RESULT_ALLOWED_BUT_MODIFIED) )
      {
          calling_num = call_info_ptr->result_from_cc.num;  
      }
      else
      {
      calling_num = call_info_ptr->num;
    }

    }

#ifdef FEATURE_DUAL_SIM
   as_id = (uint8)call_info_ptr->asubs_id;
#endif

    /* to handle a case when sys mode is CDMA and mode info is IP*/
    if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP)
    {
      sys_mode = SYS_SYS_MODE_LTE;
    }

	if( (call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP))
    {
      qmi_voice_call_list_update_secure_call_info(call_info_ptr->call_id,
                                                    call_info_ptr->mode_info.info.ip_call.call_attrib_info.is_secure_call);
    }
    /* Add a record to Call list */
    if ( qmi_voice_call_list_new( call_info_ptr->call_id, call_info_ptr->call_type, sys_mode,
                         call_info_ptr->direction, QMI_VOICE_CALL_LIST_STATE_DIALING,
                         call_info_ptr->line, calling_num, call_info_ptr->result_from_cc.alpha, call_info_ptr->mode_info.info_type, 
                         FALSE, as_id, call_info_ptr->mode_info.info.ip_call.call_attrib_info) == E_SUCCESS )
    {
      if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA)
      {
        if ( qmi_voice_call_list_update_cdma_srv_opt( call_info_ptr->call_id, 
                                                     call_info_ptr->mode_info.info.cdma_call.srv_opt ) != E_SUCCESS )
        {
          QM_MSG_ERROR_1("Failed to update the srv opt for call :  call_id %d", call_info_ptr->call_id);
        }
      }
      
      /* Check if client_categ is card or not and update the second alpha to call list */
      if ( call_info_ptr->client_categ == CM_ORIG_CLIENT_CATEG_CARD )
      {
        if ( E_SUCCESS != qmi_voice_call_list_update_second_alpha_info(
                                    call_info_ptr->call_id,
                                    call_info_ptr->client_categ,
                                    call_info_ptr->alpha) )
        {
          QM_MSG_ERROR_1("Failed to update the second alpha for call: call_id %d", call_info_ptr->call_id);
        }
      }
      
        /* Check if this is conference call and set the multiparty bit*/
      if( call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP )
      {  
        if( (call_info_ptr->alpha.len > 0) &&
            (strcmp((char*)call_info_ptr->alpha.buf, "Conference Call") == 0) )
        {
          if (qmi_voice_call_list_set_mpty_status(call_info_ptr->call_id, TRUE) != E_SUCCESS)
          {
            QM_MSG_ERROR_1("Failed to update the multiparty status for call_id %d", call_info_ptr->call_id);
          }
        }

         QM_MSG_HIGH_2("emergency_type :  call id %d, em_type %d", call_info_ptr->call_id, call_info_ptr->mode_info.info.ip_call.call_attrib_info.em_type);

        if( qmi_voice_call_list_update_call_attributes_type(call_info_ptr->call_id,
                                                            call_info_ptr->mode_info.info.ip_call.call_attrib_info,
                                                            call_info_ptr->call_type) == E_SUCCESS )
        {
          QM_MSG_MED_1("Possible update the Call type/attributes call_id %d", call_info_ptr->call_id);
        }
      }
      
      /* Send unsolicited call state change if needed after updating the mpty bit*/
      if ( QMI_VOICE_CALL_LIST_REPORT_CALL_STATE_CHANGED( call_info_ptr->call_type ) )
      {
        qmi_voice_call_list_report_all_call_status_changed(as_id);
      }
    }
    else
    {
      QM_MSG_ERROR_1("Fail to add Call List entry for orig :  call_id %d", call_info_ptr->call_id);
    }
  }
}/* qmi_voice_cm_if_call_event_orig() */


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_call_event_setup_ind

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_SETUP_IND.

    @return
    None.
*/
/*=========================================================================*/
static void qmi_voice_cm_if_call_event_setup_ind
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  cm_setup_res_params_s_type setup_res_params;
  cm_num_s_type incoming_num;
  uint8  as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  boolean  is_setup_auto_response_disabled = FALSE;
 
  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr );

  /*-----------------------------------------------------------------------*/
 
  memset( &incoming_num, 0, sizeof( cm_num_s_type ) );

  QM_MSG_HIGH_2("Received setup ind, call_id %d, call type %d", call_info_ptr->call_id, call_info_ptr->call_type);

  is_setup_auto_response_disabled = qm_efs_is_auto_setup_response_disabled();

  if ( ( call_info_ptr->call_type == CM_CALL_TYPE_VOICE ) ||
       ( call_info_ptr->call_type == CM_CALL_TYPE_EMERGENCY ) )
  {
    if(!is_setup_auto_response_disabled)
    {
      memset( &setup_res_params, CM_CALL_CMD_PARAM_DEFAULT_VALUE, sizeof( setup_res_params ) );

      setup_res_params.accept = TRUE;
 
      /* The default bearer capability to use on incoming voice calls. */
      cm_util_set_default_voice_bearer_cap_per_sub( &setup_res_params.bearer_capability_1,
        call_info_ptr->asubs_id);

      /* Based on TTY mode, iindicates whether CTM text teleophony is supported or not */
      if ( qm_nv_get( NV_TTY_I, &nv_buf, (enum qm_subs_e)call_info_ptr->asubs_id) == NV_DONE_S &&
           nv_buf.tty != QM_NV_TTY_MODE_OFF )
      { 
        setup_res_params.bearer_capability_1.ctm = CTM_SUPPORTED;
      }
      else
      {
        setup_res_params.bearer_capability_1.ctm = CTM_NOT_SUPPORTED;
      }
      QM_MSG_MED_1("Setting TTY mode in setup indication %d", nv_buf.tty);

      /* Support for ALS */
      if (CM_ALS_LINE_02 == call_info_ptr->line)
      {
        setup_res_params.bearer_capability_1.information_transfer_capability = cm_if_info.als.itc_aux_val;
      }

      QM_MSG_MED_6("setup_res_params.bearer_capability_1.present = %d info_trans_cap = %d ctm = %d, radio_chnl_req = %d coding_std = %d tf_mode = %d", setup_res_params.bearer_capability_1.present, setup_res_params.bearer_capability_1.information_transfer_capability, setup_res_params.bearer_capability_1.ctm,
	  setup_res_params.bearer_capability_1.radio_channel_requirement, setup_res_params.bearer_capability_1.coding_standard, setup_res_params.bearer_capability_1.transfer_mode);
      QM_MSG_LOW_6("gsm_speech_ver_pref_0 = %d, pref_1 = %d, pref_2 = %d, pref_3 = %d, pref_4 = %d, pref_5 = %d", setup_res_params.bearer_capability_1.gsm_speech_ver_pref_0, setup_res_params.bearer_capability_1.gsm_speech_ver_pref_1, setup_res_params.bearer_capability_1.gsm_speech_ver_pref_2,
	  	 setup_res_params.bearer_capability_1.gsm_speech_ver_pref_3, setup_res_params.bearer_capability_1.gsm_speech_ver_pref_4, setup_res_params.bearer_capability_1.gsm_speech_ver_pref_5);
      QM_MSG_LOW_3("setup_res_params.bearer_capability_1.compression = %d structure= %d, duplex_mode = %d", setup_res_params.bearer_capability_1.compression, setup_res_params.bearer_capability_1.structure, setup_res_params.bearer_capability_1.duplex_mode);

      /* Command CM to send a setup message response */
      QM_MSG_LOW_1("cm_mm_call_cmd_setup_res() with call_id = %d", call_info_ptr->call_id);
      (void) cm_mm_call_cmd_setup_res( qmi_voice_cm_if_callsvc_command_callback, 
                                       (void *)QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL, 
                                       qmi_voice_cm_if_get_clientid(),
                                       call_info_ptr->call_id, &setup_res_params );
    }
      
    memscpy(&incoming_num,sizeof(incoming_num), &call_info_ptr->num, sizeof(incoming_num));
  
      /*  Set the Presentation indicator based on cause of no CLI 
          if presentation is Restricted According to the spec TS22.081, there is a possibility to receive
          line identify info (CLIR override) even if CM_PRESENTATION_RESTRICTED.
      */
    QM_MSG_MED_4("Override check::  num.pi= %d, num.len=%d, cli.present=%d, cli.cause_value=%d", call_info_ptr->num.pi, call_info_ptr->num.len, call_info_ptr->mode_info.info.gw_cs_call.cause_of_no_cli.present, call_info_ptr->mode_info.info.gw_cs_call.cause_of_no_cli.cause_value);

    if ((call_info_ptr->num.pi == CM_PRESENTATION_RESTRICTED) &&
        (call_info_ptr->num.len == 0))
    {
      if(call_info_ptr->mode_info.info.gw_cs_call.cause_of_no_cli.present)
      {        
        switch(call_info_ptr->mode_info.info.gw_cs_call.cause_of_no_cli.cause_value)
        {
          case QMI_VOICE_CM_IF_NO_CLI_CAUSE_PAYPHONE:
             incoming_num.pi = QMI_VOICE_CM_IF_PRESENTATION_PAYPHONE;
             break;
  
          case QMI_VOICE_CM_IF_NO_CLI_CAUSE_REJECT_BY_USER:
             incoming_num.pi = QMI_VOICE_CM_IF_PRESENTATION_RESTRICTED;
             break;
   
          case QMI_VOICE_CM_IF_NO_CLI_CAUSE_UNAVAILABLE:
          case QMI_VOICE_CM_IF_NO_CLI_CAUSE_INTERACTION_WITH_OTHER_SERVICE:
          default:
             incoming_num.pi = QMI_VOICE_CM_IF_PRESENTATION_NUM_UNAVAILABLE;           
         }
      }
      else
      {
         incoming_num.pi = QMI_VOICE_CM_IF_PRESENTATION_RESTRICTED;
      }
    }
    else if(call_info_ptr->num.pi == CM_NUMBER_NOT_AVAILABLE)
    {
      incoming_num.pi = QMI_VOICE_CM_IF_PRESENTATION_NUM_UNAVAILABLE;
    }
    else if(call_info_ptr->num.pi == 0x03)
    {
      incoming_num.pi = QMI_VOICE_CM_IF_PRESENTATION_NUM_UNAVAILABLE;
    }
    else
    {
      incoming_num.pi = QMI_VOICE_CM_IF_PRESENTATION_ALLOWED;
    }

    QM_MSG_MED_1("Override check::  PI sent to client %d", incoming_num.pi);

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)call_info_ptr->asubs_id;
#endif

    /* Add a record to CList */
  if ( qmi_voice_call_list_new( call_info_ptr->call_id, call_info_ptr->call_type,
                                  call_info_ptr->sys_mode, 
                                  call_info_ptr->direction, 
                                  QMI_VOICE_CALL_LIST_STATE_SETUP,
                                  call_info_ptr->line, incoming_num, 
                                  call_info_ptr->alpha, call_info_ptr->mode_info.info_type, 
                                  FALSE, as_id, call_info_ptr->mode_info.info.ip_call.call_attrib_info) != E_SUCCESS )
  {
    QM_MSG_ERROR_1("Fail to add call list entry for setup :  call_id %d", call_info_ptr->call_id);
  }

    QM_MSG_HIGH_1("Called party Number len=%d", call_info_ptr->mode_info.info.gw_cs_call.called_party_bcd_number.length);
    if(qmi_voice_call_list_update_called_party_num_info(call_info_ptr->call_id,&(call_info_ptr->mode_info.info.gw_cs_call.called_party_bcd_number)) != E_SUCCESS)
    {
      QM_MSG_HIGH_2( "%s %d", "Unable to update Called party number info for call_id=",call_info_ptr->call_id);
    }

    QM_MSG_HIGH_1("Redirecting Party Number len=%d", call_info_ptr->mode_info.info.gw_cs_call.redirect_party_number.len);
    if(qmi_voice_call_list_update_redirecting_party_num_info(call_info_ptr->call_id,&(call_info_ptr->mode_info.info.gw_cs_call.redirect_party_number)) != E_SUCCESS)
    {
      QM_MSG_HIGH_2( "%s %d", "Unable to update Redirecting party number info for call_id=",call_info_ptr->call_id);
    }
    /*GW only*/
    QM_MSG_HIGH_1("Alerting Pattern Avail=%d", call_info_ptr->mode_info.info.gw_cs_call.cm_alerting_pattern.present);
    QM_MSG_HIGH_1("Alerting Pattern Value=%d", call_info_ptr->mode_info.info.gw_cs_call.cm_alerting_pattern.alerting_pattern_value);
    if( call_info_ptr->mode_info.info.gw_cs_call.cm_alerting_pattern.present == TRUE )
    {
      if(qmi_voice_call_list_update_alerting_pattern(call_info_ptr->call_id,call_info_ptr->mode_info.info.gw_cs_call.cm_alerting_pattern.alerting_pattern_value) != E_SUCCESS)
      {
        QM_MSG_HIGH_2("Unable to update Alerting Pattern=%d info for call_id=%d", call_info_ptr->mode_info.info.gw_cs_call.cm_alerting_pattern.alerting_pattern_value, call_info_ptr->call_id);
      }
    }
    qmi_voice_call_list_report_all_call_status_changed(as_id);
  }

} /* qmi_voice_cm_if_call_event_setup_ind */



/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_call_event_incom

===========================================================================*/
/*!
    @brief
    handle CM_CALL_EVENT_INCOM.

    @return
    None.
*/
/*=========================================================================*/
void qmi_voice_cm_if_call_event_incom
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  cm_num_s_type incoming_num;
  cm_num_s_type child_num;
  qmi_voice_call_list_public_type call_info;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  cm_display_text_s_type  display_text;
  boolean is_additional_info_flag_set=FALSE;
 
  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QM_MSG_MED_1("Inside qmi_voice_cm_if_call_event_incom(): mode_info : %d",call_info_ptr->mode_info.info_type);
  memset( &child_num, 0, sizeof( cm_num_s_type ) );
  memset( &display_text, 0, sizeof( cm_display_text_s_type ) );


  if ( ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA ) &&
       ( ( call_info_ptr->call_type == CM_CALL_TYPE_TEST ) ||
         ( call_info_ptr->call_type == CM_CALL_TYPE_OTAPA ) ||
         ( call_info_ptr->call_type == CM_CALL_TYPE_CS_DATA ) ) )
  {
    memset( &incoming_num, 0, sizeof( cm_num_s_type ) );
  }
  else
  {
    memscpy( &incoming_num,sizeof(incoming_num), &call_info_ptr->num, sizeof( cm_num_s_type ) );
    child_num = call_info_ptr->child_num;
    if( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP )
    {
    display_text = call_info_ptr->mode_info.info.ip_call.call_attrib_info.display_text;
    QM_MSG_HIGH_1("Inside display_text len=%d", call_info_ptr->mode_info.info.ip_call.call_attrib_info.display_text.displayTextLength);
    QM_MSG_HIGH_1("Inside display_text len=%d", display_text.displayTextLength);
  }
  }

  #ifdef FEATURE_DUAL_SIM
    as_id = (uint8)call_info_ptr->asubs_id;
    QM_MSG_HIGH_1("Incoming event asubs_id = %d", (uint8)call_info_ptr->asubs_id);
  #endif

  if ( ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA ) &&
       ( qmi_voice_call_list_query(call_info_ptr->call_id, &call_info) == E_SUCCESS )  )
  {

    /* Check if the number received in the event is not the same as the one maintained in the call list 
	     Instead of checking just the num_buf, check the whole num data to make sure pi,si etc hasn't changed */
    if ( !memcmp(&incoming_num, &call_info.num, sizeof(cm_num_s_type)) )
    {
        /* Number info received is same. Reset the num info in call list when replaced */
        memset( &incoming_num, 0, sizeof( cm_num_s_type ) );        
    }
	
    /* This call id already exists in the call list.  Getting an incoming event
       with the same call id means the bs is replacing the existing
       call with the incoming call. */
    if (qmi_voice_call_list_replace(call_info_ptr->call_id, call_info.conn_index,
                               call_info_ptr->call_type, 
                               call_info_ptr->sys_mode,
                               call_info_ptr->direction, call_info_ptr->call_state,
                               call_info_ptr->line, incoming_num, call_info_ptr->mode_info.info_type, FALSE
                              ) != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Fail to replace CList entry for existing call :  call_id %d", call_info_ptr->call_id);
    }
  }
  else
  {
    if(call_info_ptr->call_type != CM_CALL_TYPE_CS_DATA)
    {

      /* For GW calls, the clist entry might be created when receiving CM_CALL_EVENT_SETUP_IND. */
      if ( qmi_voice_call_list_query( call_info_ptr->call_id, &call_info ) != E_SUCCESS )
      {

        #ifdef FEATURE_DUAL_SIM
        as_id = (uint8)call_info_ptr->asubs_id;
        #endif
      /* Add a record to CList */
      if ( qmi_voice_call_list_new( call_info_ptr->call_id, call_info_ptr->call_type, call_info_ptr->sys_mode,
                                 call_info_ptr->direction, QMI_VOICE_CALL_LIST_STATE_INCOMING,
                                 call_info_ptr->line, incoming_num, call_info_ptr->alpha, 
                                 call_info_ptr->mode_info.info_type, FALSE, as_id,
                                 call_info_ptr->mode_info.info.ip_call.call_attrib_info
                               ) != E_SUCCESS )
      {
        QM_MSG_ERROR_1("Fail to add Call list entry for incom :  call_id %d", call_info_ptr->call_id);
      }
      else
      {
         /* Update service option info for CDMA call, (it is not sent with call orig event)*/
         if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA)
         {
            if ( qmi_voice_call_list_update_cdma_srv_opt( call_info_ptr->call_id, 
                                                         call_info_ptr->mode_info.info.cdma_call.srv_opt ) != E_SUCCESS )
            {
              QM_MSG_ERROR_1("Failed to update the srv opt for call :  call_id %d", call_info_ptr->call_id);
            }
               /* Send unsolicited call state change if needed */
         }
      }
    }
      else
      {
        if (qmi_voice_call_list_replace(call_info_ptr->call_id, call_info.conn_index,
                                   call_info_ptr->call_type, 
                                   call_info_ptr->sys_mode,
                                   call_info_ptr->direction, call_info_ptr->call_state,
                                   call_info_ptr->line, incoming_num, call_info_ptr->mode_info.info_type, FALSE
                               ) != E_SUCCESS )
      {
          QM_MSG_ERROR_1("Fail to replace CList entry for existing call :  call_id %d", call_info_ptr->call_id);
        }
      }
      }
    else if (qmi_voice_call_list_incoming(call_info_ptr->call_id) != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Fail to update call list entry state for incom:  call_id %d", call_info_ptr->call_id);
    }
  }

  /* Add cnap info */
  qmi_voice_cm_util_process_cnap_info( call_info_ptr, FALSE );

  qmi_voice_call_list_update_child_number(call_info_ptr->call_id,child_num);

  if( (call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP))
  {
    qmi_voice_call_list_update_secure_call_info(call_info_ptr->call_id,
                                                    call_info_ptr->mode_info.info.ip_call.call_attrib_info.is_secure_call);
  }

  
  //Check if any redirecting party number has been received
  if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP )
  {
    qmi_voice_call_list_update_display_text(call_info_ptr->call_id,display_text);
    
    QM_MSG_HIGH_1("(IP) Redirecting Number len=%d", call_info_ptr->redirecting_number.num.len);
    if(qmi_voice_call_list_update_redirecting_party_num_info(call_info_ptr->call_id,&(call_info_ptr->redirecting_number.num)) != E_SUCCESS)
    {
      QM_MSG_HIGH_1( "Unable to update Redirecting party number info for call_id=%d", call_info_ptr->call_id);
    }
  }

  if( (call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP) && (call_info_ptr->mode_info.info.ip_call.caller_info != NULL) )
  {
    qmi_voice_call_list_update_additional_call_info(call_info_ptr->call_id,
                                                    call_info_ptr->mode_info.info.ip_call.caller_info,
                                                    &is_additional_info_flag_set);
  }
  
  if( qmi_voice_call_list_update_call_capabilities(call_info_ptr->call_id,
                                                       call_info_ptr->mode_info.info.ip_call.ipcall_local_call_cap_attrib_info,
                                                       call_info_ptr->mode_info.info.ip_call.ipcall_peer_call_cap_attrib_info) == E_SUCCESS )
  {
    QM_MSG_MED_1("Updating call capabilities in incom for call_id %d", call_info_ptr->call_id);
  }
  
  /* Add uus info */
  if( (cm_if_info.uus_data.user_data.mt_user_data.present) &&
      (call_info_ptr->call_id == cm_if_info.uus_data.call_id) )
  {
    cm_call_event_user_data_s_type uus_info;
    memset( &uus_info, 0, sizeof( cm_call_event_user_data_s_type ) );
    memscpy(&uus_info,sizeof(uus_info),&cm_if_info.uus_data.user_data, sizeof(cm_call_event_user_data_s_type) );
    (void)qmi_voice_call_list_set_uus_data(cm_if_info.uus_data.call_id, &uus_info );
    /* User data copied to the call list. Reset the uus data storage so as to avoid conflict 
    with further incoming events with same call id */
    cm_if_info.uus_data.user_data.mt_user_data.present = FALSE;
    cm_if_info.uus_data.call_id = 0xFF;
  }

  qmi_voice_call_list_report_all_call_status_changed(as_id);

  if(is_additional_info_flag_set && (call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP))
  {
    //QM_MSG_MED("Additional Call Info Indication");
    qmi_voice_cm_if_send_additional_call_info_ind(call_info_ptr);

    /* Release the reference once the indications are sent */
    if(call_info_ptr->mode_info.info.ip_call.caller_info != NULL)
    {
      QM_MSG_MED("Additional Call info REFERENCE REMOVED");
      ref_cnt_obj_release( (void *) call_info_ptr->mode_info.info.ip_call.caller_info);
    }
    else
    {
      QM_MSG_MED("Reference not added to Additional Call info");
    }
  }

} /* qmi_voice_cm_if_call_event_incom */


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_call_event_progress_info_ind

===========================================================================*/
/*!
    @brief
    handle CM_CALL_EVENT_PROGRESS_INFO_IND.

    @return
    None.
*/
/*=========================================================================*/
void qmi_voice_cm_if_call_event_progress_info_ind
(
  cm_mm_call_info_s_type *call_info_ptr,
  boolean isModeChanged
)
{
  uint8 call_progress = QMI_VOICE_CM_IF_ALERTING_NONE;
  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Play local Ringback tone if needed */
  QM_MSG_HIGH_2("Progress info indication for info_type %d with GW call_progress=%d", call_info_ptr->mode_info.info_type, call_info_ptr->mode_info.info.gw_cs_call.call_progress);

  if( (call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP))
  {
    qmi_voice_call_list_update_secure_call_info(call_info_ptr->call_id,
                                                call_info_ptr->mode_info.info.ip_call.call_attrib_info.is_secure_call);
  }
  if( qmi_voice_call_list_update_call_capabilities(call_info_ptr->call_id,
                                                   call_info_ptr->mode_info.info.ip_call.ipcall_local_call_cap_attrib_info,
                                                   call_info_ptr->mode_info.info.ip_call.ipcall_peer_call_cap_attrib_info) == E_SUCCESS )
  {
    QM_MSG_MED_1("Updating peer call capabilities in PROGRESS_INFO for call_id %d", call_info_ptr->call_id);
  }

  #ifdef FEATURE_DUAL_SIM
  if(qmi_voice_call_list_update_as_id(call_info_ptr->call_id, call_info_ptr->asubs_id) != E_SUCCESS)
  {
    QM_MSG_ERROR_2("Failed to update the Active Subscription ID of CList entry for call_id %d,asubs_id %d", call_info_ptr->call_id, call_info_ptr->asubs_id);
  }
  #endif /*FEATURE_DUAL_SIM*/

  if ( ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS ) &&
       ( call_info_ptr->mode_info.info.gw_cs_call.call_progress == QMI_VOICE_CM_IF_CALL_PROG_REMOTE_ALERT) &&
       (qmi_voice_call_list_is_remote_alerting(call_info_ptr->call_id) == FALSE) )
  {
     /*As there will be only one MO call at any point of time not keeping any additional checks */
     if(qmi_voice_call_list_update_alerting_type(call_info_ptr->call_id, QMI_VOICE_CM_IF_REMOTE_ALERTING) != E_SUCCESS)
     {
       QM_MSG_ERROR_1("Failed to update the Ringback information of CList entry for call_id %d", call_info_ptr->call_id);
     }
     call_progress = QMI_VOICE_CM_IF_REMOTE_ALERTING;
  }

  /* stop local Ringback tone if USER_RESUMED */
  if ( ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS ) &&
       ( call_info_ptr->mode_info.info.gw_cs_call.call_progress == QMI_VOICE_CM_IF_CALL_PROG_USER_RESUMED)&&
       (qmi_voice_call_list_is_remote_alerting(call_info_ptr->call_id) == TRUE) )
  {
     /*As there will be only one MO call at any point of time not keeping any additional checks */
     if(qmi_voice_call_list_update_alerting_type(call_info_ptr->call_id, QMI_VOICE_CM_IF_LOCAL_ALERTING) != E_SUCCESS)
     {
       QM_MSG_ERROR_1("Failed to update the Ringback information of CList entry for call_id %d", call_info_ptr->call_id);
     }
     call_progress = QMI_VOICE_CM_IF_LOCAL_ALERTING;
  }

  /* Handle VOLTE local ringback */
  if( (call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP) && 
      (call_info_ptr->mode_info.info.ip_call.call_prog_info == CM_CALL_PROG_INFO_REMOTE_ALERT) &&
      ( !qmi_voice_call_list_is_remote_alerting(call_info_ptr->call_id)) )
  {
    QM_MSG_HIGH_1("VoIP call_progress=%d", call_info_ptr->mode_info.info.ip_call.call_prog_info);
    if(qmi_voice_call_list_update_alerting_type(call_info_ptr->call_id, QMI_VOICE_CM_IF_REMOTE_ALERTING) != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Failed to update the Ringback information of CList entry for call_id %d", call_info_ptr->call_id);
    }
    call_progress = QMI_VOICE_CM_IF_REMOTE_ALERTING;
  }

  /* Handle VOLTE Update Call Type and Mode type change if any */
  if( call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP )
  {
    QM_MSG_HIGH_1("Updating mode info for VoIP call_id=%d", call_info_ptr->call_id);
    if(qmi_voice_call_list_update_mode_info_type(call_info_ptr->call_id, call_info_ptr->mode_info.info_type ) != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Failed to update the Mode info of CList entry for call_id %d", call_info_ptr->call_id);
    }
  }

  /* Update service option info for CDMA call, (it is not sent with call orig event)*/
  if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA)
  {
     if ( qmi_voice_call_list_update_cdma_srv_opt( call_info_ptr->call_id, 
                                                   call_info_ptr->mode_info.info.cdma_call.srv_opt ) != E_SUCCESS )
     {
         QM_MSG_ERROR_1("Failed to update the srv opt for call :  call_id %d", call_info_ptr->call_id);
     }
  }
  
  /* Update the state of the record in Call List if needed */
  if ( qmi_voice_call_list_alert( call_info_ptr->call_id, call_progress ) != E_SUCCESS )
  {
    if(isModeChanged)
    {
      qmi_voice_call_list_report_all_call_status_changed(call_info_ptr->asubs_id);
    }
    QM_MSG_MED_1("No update done on Call List entry for alert :  call_id %d", call_info_ptr->call_id);
  }
} /* qmi_voice_cm_if_call_event_progress_info_ind() */

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_call_emergency_flashed

===========================================================================*/
/*!
    @brief
    handle CM_CALL_EVENT_EMERGENCY_FLASHED.
    A voice call was converted into an emergency call. 

    @return
    None.
*/


void qmi_voice_cm_if_call_emergency_flashed
(
  cm_mm_call_info_s_type *call_info_ptr
)
{  
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QM_MSG_MED_1("In qmi_voice_cm_if_call_emergency_flashed:  Converting voice call (id:  %d) into emergency call", call_info_ptr->call_id);

  
  if ( (qmi_voice_call_list_update_call_type(call_info_ptr->call_id,call_info_ptr->call_type ) != E_SUCCESS ) ||
       (qmi_voice_call_list_update_num_info(call_info_ptr->call_id, &call_info_ptr->num) != E_SUCCESS ) )
  {
    QM_MSG_ERROR_1("Fail to update the call_type or num_info of cm call_id %d", call_info_ptr->call_id);
  }
  else
  {
#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)call_info_ptr->asubs_id;
#endif
    qmi_voice_call_list_report_all_call_status_changed(as_id);
  }
  
}

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_call_event_end

===========================================================================*/
/*!
    @brief
    handle CM_CALL_EVENT_END.

    @return
    None.
*/
/*=========================================================================*/
void qmi_voice_cm_if_call_event_end
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  qmi_voice_cmd_list_public_type cmd_info;
  qmi_voice_call_list_call_ids_list_type call_ids_list;
  qmi_voice_call_list_public_type *info;
  uint8 num_active_calls = 0, num_held_wait_calls = 0;
  voice_start_cont_dtmf_resp_msg_v02 start_cont_dtmf_resp;
  voice_stop_cont_dtmf_resp_msg_v02 stop_cont_dtmf_resp;
  voice_end_call_resp_msg_v02 end_call_resp;
  uint8 conn_idx = 0, as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  info = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*info));
  
  if(NULL == info)
  {
	  qmi_voice_mem_fatal();
    return;
  }  

  memset(&start_cont_dtmf_resp, 0, sizeof(start_cont_dtmf_resp));
  memset(&stop_cont_dtmf_resp, 0, sizeof(stop_cont_dtmf_resp));
  memset(&end_call_resp, 0 , sizeof(end_call_resp));
  memset(info, 0 , sizeof(qmi_voice_call_list_public_type));

  #ifdef FEATURE_DUAL_SIM
  if(qmi_voice_call_list_update_as_id(call_info_ptr->call_id, call_info_ptr->asubs_id) != E_SUCCESS)
  {
    QM_MSG_ERROR_2("Failed to update the Active Subscription ID of CList entry for call_id %d,asubs_id %d", call_info_ptr->call_id, call_info_ptr->asubs_id);
  }
  as_id = (uint8)call_info_ptr->asubs_id;
  #endif

  //Handling/prints for special scenarios
  if(call_info_ptr->end_status == CM_CALL_END_SRVCC_IMS_END)
  {//Ignoring the call event end when this particular end reason is received because the call instance associated with this CALL_END would have been cleared in HO_COMPLETE itself.
    QM_MSG_MED("CM_CALL_END_SRVCC_IMS_END received; no indication will be sent to clients.");
    return;
  }
  else if(call_info_ptr->end_status == CM_CALL_END_EMERGENCY_FLASHED)
  {//Check if a call is ended due to an emergency flash (on CDMA only).
    QM_MSG_MED_1("End call reason EMERGENCY FLASHED for call ID %d", call_info_ptr->call_id);
  }

  /* Extract the call end reason */
  qmi_voice_cm_if_extract_call_end_reason(call_info_ptr);

  QM_MSG_MED_1("End call call_type %d", call_info_ptr->call_type);

  QM_MSG_MED_1("Otapa Commit = %d", call_info_ptr->mode_info.info.cdma_call.is_otasp_commit);
  if ( (call_info_ptr->call_type == CM_CALL_TYPE_OTAPA) && 
       (call_info_ptr->mode_info.info.cdma_call.is_otasp_commit == TRUE) )
  {
    if ( qmi_voice_call_list_update_otasp_status( call_info_ptr->call_id, 
                                                  QMI_VOICE_CALL_LIST_OTASP_STATUS_OTAPA_COMMITTED ) != E_SUCCESS )
    {
       QM_MSG_ERROR_1("Failed to update the Otasp status for call :  call_id %d", call_info_ptr->call_id);
    }
    
  }

  /* stop local Ringback tone if needed */
  if((call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS) &&
     (call_info_ptr->mode_info.info.gw_cs_call.call_progress == QMI_VOICE_CM_IF_CALL_PROG_REMOTE_ALERT) &&
     (qmi_voice_call_list_is_remote_alerting(call_info_ptr->call_id) == TRUE))
  {
    if(qmi_voice_call_list_update_alerting_type(call_info_ptr->call_id, QMI_VOICE_CM_IF_LOCAL_ALERTING) != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Failed to update the alerting type Call List entry for call_id %d", call_info_ptr->call_id);
    }
  }

  /* Handle VOLTE local ringback */
  if( (call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP) && 
      (qmi_voice_call_list_is_remote_alerting(call_info_ptr->call_id)) )
  {
    if(qmi_voice_call_list_update_alerting_type(call_info_ptr->call_id, QMI_VOICE_CM_IF_LOCAL_ALERTING) != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Failed to update the Ringback information of CList entry for call_id %d", call_info_ptr->call_id);
    }
  }
  /* See if there is any RIL request pending for the event */

  /* Handle End Reason Text */
  if ( (call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP) &&
       (call_info_ptr->mode_info.info.ip_call.ims_end_reason != NULL) &&
       (call_info_ptr->mode_info.info.ip_call.ims_end_reason->end_reason_len != 0) )
  {
    if ( qmi_voice_call_list_update_end_reason_text(call_info_ptr->call_id, call_info_ptr->mode_info.info.ip_call.ims_end_reason) != E_SUCCESS )
    {
      QM_MSG_ERROR_1("Failed to update the end reason text of CList entry for call_id %d", call_info_ptr->call_id);
    }
  }

  while ( qmi_voice_cmd_list_query_by_event_all_states( QMI_VOICE_CM_IF_EVT_CALL_END, &cmd_info, as_id ) == E_SUCCESS )
  {
    if ( (cmd_info.cmd == QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_CALLS) &&
          ((cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_HELD_OR_WAITING)||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING) ||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_SPECIFIED_CALL) ||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_MAKE_CONFERENCE_CALL) ||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_HOLD_ALL_EXCEPT_SPECIFIED_CALL) ||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD)))

    {
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, NULL, 0, TRUE );
      QM_MSG_MED_1( "Completing MANAGE_CALLS request %s upon CM_CALL_EVENT_END ", 
                       qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) ); 
    }
    else if ( (cmd_info.cmd == QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS) &&
          ((cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_RELEASE_HELD_OR_WAITING)||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING) ||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD)))
    {
      QM_MSG_MED_1( "Completing %s upon CM_CALL_EVENT_END ", qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) ); 
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, NULL, 0, TRUE );
    }
    else
    {
      QM_MSG_MED_1("QMI Call Event End Recieved for subid id %d", cmd_info.sub_id);
      break;
    }
  }

  /* For any request that pending for CM_EVENT_CALL_MNG_CALLS_CONF, it is time now to response back since Modem may not send pending events 
     for those requests after END (if this is the last call in call list)*/
  while ( qmi_voice_cmd_list_query_by_event_all_states( QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF, &cmd_info, as_id ) == E_SUCCESS )
  {
    if ( (cmd_info.cmd == QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_CALLS) &&
          ((cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_HELD_OR_WAITING)||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_SPECIFIED_CALL) ||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_MAKE_CONFERENCE_CALL)   || 
           ((cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD) && !(qmi_voice_call_list_count_num_of_voice_calls(as_id) > 1)) ||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_HOLD_ALL_EXCEPT_SPECIFIED_CALL) || 
           ( (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_EXPLICIT_CALL_TRANSFER) && !(qmi_voice_call_list_count_num_of_voice_calls(as_id) > 1))))

    {
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, NULL, 0, TRUE );
      QM_MSG_MED_1( "Completing request %s upon CM_CALL_EVENT_END ", 
                       qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) ); 
    }  
    else if ( (cmd_info.cmd == QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS) &&
              !(qmi_voice_call_list_count_num_of_voice_calls(as_id) > 1) &&
          ((cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_RELEASE_HELD_OR_WAITING)||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD)||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_PER_CALL)||
           (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_RESUME_PER_CALL)))
    {
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, NULL, 0, TRUE );
      QM_MSG_MED_1( "Completing request %s upon CM_CALL_EVENT_END ", 
                       qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) ); 
    }
    else
    {
      QM_MSG_MED_1("QMI MNG_CALLS_CONF Recieved for subid id %d", cmd_info.sub_id);
      break;
    }
  }

  /* For any request that is pending CM_EVENT_CALL_MODIFY_COMPLETE_CONF, response sent since Modem may not send pending events 
     for those requests after END  (when there is only one call pending)*/
  while(qmi_voice_cmd_list_query_by_event_all_states(QMI_VOICE_CM_IF_EVT_CALL_MODIFY_COMPLETE_CONF, &cmd_info, as_id) == E_SUCCESS)
  {
    if( (cmd_info.cmd == QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS) &&
       !(qmi_voice_call_list_count_num_of_voice_calls(as_id) > 1) &&
        ( (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_MODIFY_CALL)||
          (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_MODIFY_ACCEPT)||
          (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_MODIFY_REJECT))
      )
    {
      qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_INTERNAL, TRUE , TRUE );
      QM_MSG_MED_1("Completing request %s upon CM_CALL_EVENT_END sending a dummy manage_ip_call_resp with QMI_ERR_INTERNAL", qmi_voice_cm_if_lookup_cmd_name(cmd_info.cmd)); 
    }
    else
    {
      QM_MSG_MED_1("QMI MNG_CALLS_CONF Recieved for subid id %d", cmd_info.sub_id);
      break;
    }
  }

  if( qmi_voice_call_list_get_conn_idx_from_call_id( call_info_ptr->call_id, &conn_idx ) == E_SUCCESS )
  {
    QM_MSG_MED_1("Found the conn index = %d in the list", conn_idx);
  }

  while ( qmi_voice_cmd_list_query_by_event_and_sub_id_all_states( QMI_VOICE_CM_IF_EVT_INBAND_REV_START_CONT_DTMF_CONF,
  	                                                               call_info_ptr->call_id, &cmd_info, as_id ) == E_SUCCESS )
  {
    start_cont_dtmf_resp.call_id_valid = TRUE;
      start_cont_dtmf_resp.call_id = conn_idx;
    qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&start_cont_dtmf_resp, sizeof(start_cont_dtmf_resp), TRUE );
    QM_MSG_MED_1( "Completing request %s upon CM_CALL_EVENT_END \n", qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) );
  }

  while ( qmi_voice_cmd_list_query_by_event_and_sub_id_all_states( QMI_VOICE_CM_IF_EVT_INBAND_REV_STOP_CONT_DTMF_CONF,
  	                                                               call_info_ptr->call_id, &cmd_info, as_id ) == E_SUCCESS )
  {
    stop_cont_dtmf_resp.call_id_valid = TRUE;
      stop_cont_dtmf_resp.call_id = conn_idx;
    qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&stop_cont_dtmf_resp, sizeof(stop_cont_dtmf_resp), TRUE );
    QM_MSG_MED_1( "Completing request %s upon CM_CALL_EVENT_END \n", qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) );
  }

  /* Check if the call object is present already */
  if( qmi_voice_call_list_query(call_info_ptr->call_id, info) == E_SUCCESS )
  { 
    if((info->state  == QMI_VOICE_CALL_LIST_STATE_CC_IN_PROG) ||
       (info->state  == QMI_VOICE_CALL_LIST_STATE_DISCONNECTING))
    {
      while ( qmi_voice_cmd_list_query_by_event_all_states( QMI_VOICE_CM_IF_EVT_CALL_ORIG, &cmd_info, as_id ) == E_SUCCESS )
      {      
        if(call_info_ptr->end_status == CM_CALL_END_CC_REJECT)
        {
          QM_MSG_MED_1( "Completing request %s upon CM_CALL_EVENT_END (end_reason = CM_CALL_END_CC_REJECT) ", 
          qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) );   
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_CARD_CALL_CONTROL_FAILED, TRUE , TRUE );      
          break;
        }
        else if(call_info_ptr->end_status == CM_CALL_END_NO_GW_SRV || 
                call_info_ptr->end_status == CM_CALL_END_NO_CDMA_SRV || 
                call_info_ptr->end_status == CM_CALL_END_NO_SRV )
        {
          QM_MSG_MED_1( "Completing request %s upon CM_CALL_EVENT_END (end_reason = No service) ", 
          qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) );   
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_NO_NETWORK_FOUND, TRUE , TRUE );
          break;
        }
        else
        {
          QM_MSG_MED_1( "ORIG %s upon CM_CALL_EVENT_END, not sending dial call response ", 
          qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) ); 
          break;
        }
      }
    }
  }

  while ( qmi_voice_cmd_list_query_by_cmd_all_states(QMI_VOICE_CM_IF_CMD_END_CALL, &cmd_info, as_id ) == E_SUCCESS )
  {
    //End call request pending response found for which END EVENT is received
    if(call_info_ptr->call_id == (uint8) cmd_info.sub_id)
    {
      QM_MSG_MED_1( "Completing request %s upon CM_CALL_EVENT_END ",qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) );

      conn_idx = 0;
      if(qmi_voice_call_list_get_conn_idx_from_call_id( (cm_call_id_type) cmd_info.sub_id, &conn_idx ) == E_SUCCESS)
      {
        QM_MSG_MED_1("Found the conn index = %d in the list", conn_idx);
      }
      end_call_resp.call_id_valid = TRUE;
      end_call_resp.call_id = conn_idx;

      /* Send cmd SUCCESS response */
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd,(void *) &end_call_resp, sizeof(end_call_resp), TRUE );
    }
    else
    {
      QM_MSG_MED_1( "Not found %s upon CM_CALL_EVENT_END ",qmi_voice_cm_if_lookup_cmd_name( cmd_info.cmd ) );
      break;
    }
  }

  /* Remove the record from the CList */
  if ( qmi_voice_call_list_free( call_info_ptr->call_id, TRUE ) != E_SUCCESS )
  {
    QM_MSG_ERROR_1("Failed to delete the Call list entry :  call_id %d", call_info_ptr->call_id);
  }

  /* Respond to RELEASE ACTIVE ACCEPT HELD OR WAITING when all the end events are 
   received and no call is on hold/waiting. If there is a waiting/held call the response will
   be sent in MNG_CALLS_CONF event handling */
  if( (qmi_voice_cmd_list_query_by_event_all_states( QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF, &cmd_info, as_id ) == E_SUCCESS) && 
       (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING) )
  {
    /* Get active calls */
    qmi_voice_call_list_query_voice_call_ids_list_by_state( QMI_VOICE_CALL_LIST_STATE_ACTIVE, &call_ids_list, as_id );
    num_active_calls = call_ids_list.num_of_call_ids;
    /* Get held or waiting calls */
    qmi_voice_call_list_query_voice_call_ids_list_by_state( QMI_VOICE_CALL_LIST_STATE_HOLDING|QMI_VOICE_CALL_LIST_STATE_WAITING, &call_ids_list, as_id );
    num_held_wait_calls = call_ids_list.num_of_call_ids;
    QM_MSG_MED_2("Found Release active accept held or waiting - active calls=%d, held/wait calls = %d ", num_active_calls, num_held_wait_calls);
    /* send the response if there are no active calls and
           a) Waiting call ends unexpectedly OR
           b) No waiting call present & only one held call present which is also ended unexpectedly. When there are multiple calls in held state response shouldn't be sent upon one held call end.
           c) No waiting call present and no held call present (i.e no held/waiting calls).
       */
    
    if((num_active_calls == 0) && ( (cm_if_info.mng_calls_info.waiting_call_id_valid &&(call_info_ptr->call_id == cm_if_info.mng_calls_info.waiting_call_id)) ||
        (cm_if_info.mng_calls_info.held_call_id_valid &&(call_info_ptr->call_id == cm_if_info.mng_calls_info.held_call_id)) || 
        (!cm_if_info.mng_calls_info.waiting_call_id_valid &&(num_held_wait_calls == 0)) ) 
       )
    {
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, NULL, 0, TRUE );
    }
  }
  
  if(NULL != info)
  {
    QMI_VOICE_CM_IF_MEM_FREE(info);
  }
  
}/* qmi_voice_cm_if_call_event_end() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_FILL_AND_SEND_SUPS_NOTIFICATION_IND()

  DESCRIPTION
    Fill and send sups notification based on the call event 

  PARAMETERS
    event          : Call event received
    call_info_ptr  : Call event payload 

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_fill_and_send_sups_notification_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_call_info_s_type *call_info_ptr
)
{
  cm_call_ss_info_s_type    *ss_info;
  cm_forward_cug_info_s_type  *forward_cug_info;
  cm_ect_indicator_s_type  *ect_info;
  voice_sups_notification_ind_msg_v02 notify_data;
  boolean success = FALSE;
  int count;
  uint8 conn_idx = 0, as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  qmi_voice_cm_sups_reason_code_e_type  reason  = QMI_VOICE_CM_SUPS_REASON_NONE;
  qmi_voice_cmd_list_public_type cmd_info;

  /*-----------------------------------------------------------------------*/
  ASSERT( call_info_ptr );
  /*-----------------------------------------------------------------------*/
  /*Initialize notification indication structure */
  memset(&notify_data,0,sizeof(notify_data));
  
  #ifdef FEATURE_DUAL_SIM
  if(qmi_voice_call_list_update_as_id(call_info_ptr->call_id, call_info_ptr->asubs_id) != E_SUCCESS)
  {
    QM_MSG_MED_2("Failed to update the Active Subscription ID of CList entry for call_id %d,asubs_id %d", call_info_ptr->call_id, call_info_ptr->asubs_id);
  }
  as_id = (uint8) call_info_ptr->asubs_id;
  #endif
  ss_info = &call_info_ptr->mode_info.info.gw_cs_call.ss_info;

  /* Fill the common data */
  if(qmi_voice_call_list_get_conn_idx_from_call_id( call_info_ptr->call_id, &conn_idx ) == E_SUCCESS)
  {
    //Found the conn index 
  }
  notify_data.notification_info.call_id = conn_idx;

  /* Fill the event specific data */
  switch(event)
  {
    case QMI_VOICE_CM_IF_EVT_CALL_ORIG_FWD_STATUS:
      if(ss_info->ss_code.present == TRUE)
      {
        switch(ss_info->ss_code.ss_code)
        {
          case qmi_voice_cm_sups_cfu:
            {
              if((ss_info->ss_status.present == TRUE) &&
                 (ss_info->ss_status.cm_ss_active == TRUE))
              {
                notify_data.notification_info.notification_type = NOTIFICATION_TYPE_UNCOND_CALL_FORWARD_ACTIVE_V02;
                success = TRUE;
              }
            }
            break;
      
          case qmi_voice_cm_sups_cfb:
          case qmi_voice_cm_sups_cfnry:
          case qmi_voice_cm_sups_cfnrc:
          case qmi_voice_cm_sups_allCondForwardingSS:
            {
              if((ss_info->ss_status.present == TRUE) &&
                 (ss_info->ss_status.cm_ss_active == TRUE))
              {
                notify_data.notification_info.notification_type = NOTIFICATION_TYPE_COND_CALL_FORWARD_ACTIVE_V02;
                success = TRUE;
              }
            }
            break;
      
          default:
            break;
        }
      }
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_BEING_FORWARDED:
      notify_data.notification_info.notification_type = NOTIFICATION_TYPE_OUTGOING_CALL_IS_FORWARDED_V02;
      success = TRUE;

      /* send the ip_forward_hist_info for call being forwarded if available */
      if( (call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP) &&
          (call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info != NULL) &&
          (call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info->hist_info_text != NULL) &&
          (call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info->hist_info_len  != 0) )
      {
        notify_data.ip_forward_hist_info_valid = TRUE;
        notify_data.ip_forward_hist_info_len = call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info->hist_info_len;
        memscpy( notify_data.ip_forward_hist_info,
                 sizeof(notify_data.ip_forward_hist_info),
                 call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info->hist_info_text,
                 2*call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info->hist_info_len );
        QM_MSG_MED_1("Fill and send sups notification ind: IP Forward Hist Info %d characters",
                      notify_data.ip_forward_hist_info_len );
      }
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_IS_WAITING:
      notify_data.notification_info.notification_type = NOTIFICATION_TYPE_OUTGOING_CALL_IS_WAITING_V02;
      success = TRUE;
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_BARRED:
      if(ss_info->ss_code.present == TRUE)
      {
        switch(ss_info->ss_code.ss_code)
        {
          case qmi_voice_cm_sups_barringOfOutgoingCalls:
          case qmi_voice_cm_sups_baoc:
          case qmi_voice_cm_sups_boic:
          case qmi_voice_cm_sups_boicExHC:
            {
              notify_data.notification_info.notification_type = NOTIFICATION_TYPE_OUTGOING_CALLS_BARRED_V02;
              success = TRUE;
            }
            break;

          case qmi_voice_cm_sups_barringOfIncomingCalls:
          case qmi_voice_cm_sups_baic:
          case qmi_voice_cm_sups_bicRoam:
            {
              notify_data.notification_info.notification_type = NOTIFICATION_TYPE_INCOMING_CALLS_BARRED_V02;
              success = TRUE;
            }
            break;

          default:
            break;
        }
      }
      else if (call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP)
      {
        notify_data.notification_info.notification_type = NOTIFICATION_TYPE_OUTGOING_CALLS_BARRED_V02;
        success = TRUE;
      }

      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_RESTRICTED:
      notify_data.notification_info.notification_type = NOTIFICATION_TYPE_CLIR_SUPPRSESION_REJECTED_V02;
      success = TRUE;
      break;
    
    case QMI_VOICE_CM_IF_EVT_CALL_INCOM_FWD_CALL:
      notify_data.notification_info.notification_type = NOTIFICATION_TYPE_INCOMING_FORWARDED_CALL_V02;
      success = TRUE;
      /* send the reason for call forwarding if available */
      if(ss_info->ss_code.present == TRUE)
      {
        if((reason=qmi_voice_cm_sups_get_reason_from_ss_code(ss_info->ss_code.ss_code)) != QMI_VOICE_CM_SUPS_REASON_NONE)
        {
          if((reason >= QMI_VOICE_CM_SUPS_FWD_UNCONDITIONAL) && (reason <= QMI_VOICE_CM_SUPS_FWD_ALLCONDITIONAL))
          {
            notify_data.ss_code_valid = TRUE;
            notify_data.ss_code = (voice_sups_notify_reason_enum_v02)reason;
            QM_MSG_MED_1("Reason for call forwarding is %d", reason);
          }
          else
          {
            QM_MSG_MED_1("Received unsupported SS Code=%d for INCOM FWD CALL", ss_info->ss_code.ss_code);
          }
        }
      }
      break;
      
    case QMI_VOICE_CM_IF_EVT_MPTY_CALL_IND:
      notify_data.notification_info.notification_type = NOTIFICATION_TYPE_CALL_IS_IN_MPTY_V02;
      success = TRUE;
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_CUG_INFO_RECEIVED:
      forward_cug_info = &call_info_ptr->mode_info.info.gw_cs_call.forward_cug_info;
      if((forward_cug_info->present == TRUE) && (forward_cug_info->cm_cug_index.present))
      {
        notify_data.index_valid = TRUE;
        notify_data.index = (forward_cug_info->cm_cug_index.lsb)|
                               (forward_cug_info->cm_cug_index.msb << 8);

        if(call_info_ptr->call_id < 7)
        {
          notify_data.notification_info.notification_type = NOTIFICATION_TYPE_OUTGOING_CUG_CALL_V02;
          success = TRUE;
        }
        else if((call_info_ptr->call_id > 7) && (call_info_ptr->call_id < 15))
        {
          notify_data.notification_info.notification_type = NOTIFICATION_TYPE_INCOMING_CUG_CALL_V02;
          success = TRUE;
        }
        else
        {
          QM_MSG_ERROR_1("received unexpected call id %d for QMI_VOICE_CM_IF_EVT_CALL_CUG_INFO_RECEIVED", call_info_ptr->call_id);
        }
      }
      else
      {
        QM_MSG_ERROR("received null value for either cug_info or cug_index");
      }
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_ON_HOLD:
      if( call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP )
      {
        /* Update the call list entry to HOLD when CALL_ON_HOLD event is received as 
                  1. A transient state in the process of make_conf_call request or 
                  2. When this event is not from a HOLD request triggered by Apps (toggling happens on MANGE_CALL_CONF) */
        if( (qmi_voice_cmd_list_query_by_event_and_sub_id_all_states( QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,QMI_VOICE_CM_IF_MNG_IP_CALLS_MAKE_CONFERENCE_CALL, &cmd_info, as_id ) == E_SUCCESS) ||
            ( !(qmi_voice_cmd_list_query_by_event_and_sub_id_all_states( QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD, &cmd_info, as_id ) == E_SUCCESS) &&
              !(qmi_voice_cmd_list_query_by_event_and_sub_id_all_states( QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_PER_CALL, &cmd_info, as_id) == E_SUCCESS)) )
        {
          qmi_voice_call_list_update_call_state(call_info_ptr->call_id,QMI_VOICE_CALL_LIST_STATE_HOLDING);
          qmi_voice_call_list_report_all_call_status_changed(as_id);
        }
        return;
      }
      notify_data.notification_info.notification_type = NOTIFICATION_TYPE_CALL_IS_ON_HOLD_V02;
      success = TRUE;
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_RETRIEVED:
      if( call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP )
      {
        if( (qmi_voice_cmd_list_query_by_event_and_sub_id_all_states(
                               QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF,QMI_VOICE_CM_IF_MNG_IP_CALLS_MAKE_CONFERENCE_CALL, &cmd_info, as_id ) == E_SUCCESS) ||
            (qmi_voice_cmd_list_query_by_event_and_sub_id_all_states(
                               QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF, QMI_VOICE_CM_IF_MNG_IP_CALLS_RESUME_PER_CALL, &cmd_info, as_id ) == E_SUCCESS) ||
			(qmi_voice_cmd_list_query_by_event_and_sub_id_all_states(
                               QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF, QMI_VOICE_CM_IF_MNG_IP_CALLS_EXPLICIT_CALL_TRANSFER_VOIP, &cmd_info, as_id ) == E_SUCCESS))
        {
          qmi_voice_call_list_update_call_state(call_info_ptr->call_id, QMI_VOICE_CALL_LIST_STATE_ACTIVE);
          qmi_voice_call_list_report_all_call_status_changed(as_id);
        }
        return;
      }
      notify_data.notification_info.notification_type = NOTIFICATION_TYPE_CALL_IS_RETRIEVED_V02;
      success = TRUE;
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_ON_HOLD_BY_REMOTE:
      if( call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP )
      {
        notify_data.notification_info.notification_type = NOTIFICATION_TYPE_CALL_IS_ON_HOLD_V02;
        notify_data.media_direction_hold_valid = TRUE;
        notify_data.media_direction_hold = call_info_ptr->mode_info.info.ip_call.held_call_audio_attrib;
        success = TRUE;
        QM_MSG_MED_2("Media Dir Rxed is %d, Media Direction hold is %d", 
                     call_info_ptr->mode_info.info.ip_call.held_call_audio_attrib, notify_data.media_direction_hold );
      }
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_RETRIEVE_BY_REMOTE:
      if( call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP )
      {
        notify_data.notification_info.notification_type = NOTIFICATION_TYPE_CALL_IS_RETRIEVED_V02;
        success = TRUE;
      }
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_FORWARDED:
      notify_data.notification_info.notification_type = NOTIFICATION_TYPE_INCOMING_CALL_IS_FORWARDED_V02;
      success = TRUE;
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_TRANSFERRED_CALL:
      ect_info = &call_info_ptr->mode_info.info.gw_cs_call.ect_info;
      notify_data.notification_info.notification_type = NOTIFICATION_TYPE_INCOMING_CALL_IS_ECT_V02;
      if(ect_info->callState == (ect_call_state_T) qmi_voice_cm_sups_notification_alerting_ECT)
      {
        notify_data.ect_number_valid = TRUE;
        notify_data.ect_number.ect_call_state =  ECT_CALL_STATE_ALERTING_V02;
        success = TRUE;
      }
      else if(ect_info->callState == (ect_call_state_T) qmi_voice_cm_sups_notification_alerting_active_ECT)
      {  
        byte buffer[CM_CALLED_PARTY_BCD_NO_LENGTH+1];
        size_t ect_ascii_len=0;

        notify_data.ect_number_valid = TRUE;
        notify_data.ect_number.ect_call_state = ECT_CALL_STATE_ACTIVE_V02;

        switch(ect_info->routeDestNumber.type)
        {
          case presentationAllowedAddress:
            notify_data.ect_number.pi = PRESENTATION_NUM_ALLOWED_V02;
            break;
          case presentationRestrictedECT:
            notify_data.ect_number.pi = PRESENTATION_NUM_RESTRICTED_V02;
            break;
          case numberNotAvailable:
            notify_data.ect_number.pi = PRESENTATION_NUM_NUM_UNAVAILABLE_V02;
            break;
          case presentationRestricteddAdress:
            notify_data.ect_number.pi = 0x04; //QMI_VOICE_CM_SUPS_ECT_PRESENTATION_RESTRICTED_ADDRESS;
            break;
          default:
            notify_data.ect_number.pi = 0xFF; //QMI_VOICE_CM_SUPS_ECT_PRESENTATION_INVALID;
            break;
        }

        /* ECT number present only in active state */
        if(ect_info->routeDestNumber.present)
        {
          if(ect_info->routeDestNumber.number[0].present)
          {
            for(count = 0; (count<ect_info->routeDestNumber.number[0].length) && (count < CM_CALLED_PARTY_BCD_NO_LENGTH); count++)
            {
              buffer[count+1] = ect_info->routeDestNumber.number[0].data[count];
            }
            buffer[0] = ect_info->routeDestNumber.number[0].length;
            ect_ascii_len = cm_util_bcd_num_to_ascii_num(buffer, (byte*)notify_data.ect_number.number, sizeof(notify_data.ect_number.number));
            notify_data.ect_number.number_len = (uint8)MIN(ect_ascii_len, (sizeof(notify_data.ect_number.number)-1));
            notify_data.ect_number.number[notify_data.ect_number.number_len] = '\0';
            QM_MSG_LOW_1( "ECT notification has number = %s", notify_data.ect_number.number);
          }
        }
        success = TRUE;
      }
      else
      {
        QM_MSG_ERROR("received invalid call state value for QMI_VOICE_CM_IF_EVT_CALL_TRANSFERRED_CALL");
      }
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_DEFLECTION:
      /* for MO calls callid ranges from 0-6 and for MT calls it ranges from 8-14 */
      if(call_info_ptr->call_id < 7)
      {
        notify_data.notification_info.notification_type = NOTIFICATION_TYPE_OUTGOING_CALL_IS_DEFLECTED_V02;
        success = TRUE;
      }
      else if((call_info_ptr->call_id > 7) && (call_info_ptr->call_id < 15))
      {
        notify_data.notification_info.notification_type = NOTIFICATION_TYPE_INCOMING_DEFLECTED_CALL_V02;
        success = TRUE;
      }
      else
      {
        QM_MSG_ERROR_1("received unexpected call id %d for QCRIL_EVT_CM_CALL_DEFLECTION", call_info_ptr->call_id);
      }
      break;
      
    default:
      break;
  }/* switch */

  if(success)
  {
    QM_MSG_MED_2("Event %d  sups notification type %d ", event, notify_data.notification_info.notification_type);
    /* Send sups notification indication */
    #ifdef FEATURE_DUAL_SIM
    as_id = (uint8)call_info_ptr->asubs_id;
    #endif
    qmi_voice_cm_if_unsol_response( QMI_VOICE_CM_IF_CMD_SUPS_NOTIFICATION_IND, (void *) &notify_data, sizeof( notify_data ), as_id );
  }
} /* qmi_voice_cm_if_fill_and_send_sups_notification_ind() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SEND_HANDOVER_IND()

  DESCRIPTION
    Send handover indication based on the call event 

  PARAMETERS
    event          : Call event received
    call_info_ptr  : Call info from CM
    as_id          : Subscription id

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_send_handover_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_call_info_s_type *call_info_ptr,
  uint8 as_id  
)
{ 
  voice_handover_ind_msg_v02  ind_data;
  voice_handover_type_enum_v02 qmi_ho_type = (voice_handover_type_enum_v02)SYS_VOICE_HO_NONE;
  boolean success = TRUE;

  /*Initialize notification indication structure */
  memset(&ind_data,0,sizeof(ind_data));
  
  QM_MSG_MED_1("Inside qmi_voice_cm_if_send_handover_ind(): voice_ho_type=%d", call_info_ptr->voice_ho_type);
  
  /* Fill the event specific data */
  switch(event)
  {
    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_START:
    ind_data.ho_state = VOICE_HANDOVER_START_V02;
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_FAIL:		
      ind_data.ho_state = VOICE_HANDOVER_FAIL_V02;
	  break;
	  
    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_COMPLETE:		
      ind_data.ho_state = VOICE_HANDOVER_COMPLETE_V02;
      break;      

    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_CANCEL:		
      ind_data.ho_state = VOICE_HANDOVER_CANCEL_V02;
      break;
	
    default:
      success = FALSE;
      break;
  }/* switch */

  if(success)
  {
    cm_if_info.ho_state = ind_data.ho_state;

    if( qmi_voice_cm_util_map_cm_to_qmi_ho_type(call_info_ptr->voice_ho_type, &qmi_ho_type) )
    {
      ind_data.ho_type_valid = TRUE;
      ind_data.ho_type = qmi_ho_type;
    }
    else
    {
      QM_MSG_MED_1("Un-handled HO_TYPE Received from CM %d", call_info_ptr->voice_ho_type);
    }

    QM_MSG_MED_3("Event %d  handover notification ho_state= %d, ho_type=%d ", event, ind_data.ho_state , ind_data.ho_type);
    /* Send handover notification indication */
    qmi_voice_cm_if_unsol_response( QMI_VOICE_CM_IF_CMD_HANDOVER_IND, (void *) &ind_data, sizeof( ind_data ), as_id );
  }
} /* qmi_voice_cm_if_send_handover_ind() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SEND_AOC_LOW_FUNDS_IND()

  DESCRIPTION
    Send AOC Low Funds indication

  PARAMETERS
    as_id          : Subscription id

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_send_aoc_low_funds_ind
(
  uint8 as_id
)
{
  QM_MSG_MED_1("Inside qmi_voice_cm_if_send_aoc_low_funds_ind(): as_id = %d", as_id);

  /* Send AOC low funds indication */
  qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_AOC_LOW_FUNDS_IND, (void *)NULL, 0, as_id);
} /* qmi_voice_cm_if_send_aoc_low_funds_ind() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SEND_EXT_BRST_INTERNALTIONAL_IND()

  DESCRIPTION
    Send extended burst international indication based on the call event 

  PARAMETERS
    call_info_ptr  : Call event payload 

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_send_ext_burst_international_ind
(
    cm_mm_call_info_s_type *call_info_ptr, 
    uint8     as_id
)
{ 
  voice_ext_brst_intl_ind_msg_v02 ind_data;

  /*Initialize notification indication structure */
  memset(&ind_data,0,sizeof(ind_data));
  
  //Inside qmi_voice_cm_if_send_ext_burst_international_ind

  /* Fill the event specific data */
  ind_data.ext_burst_data.mcc        = call_info_ptr->mode_info.info.cdma_call.ext_brst_intl_msg.mcc;
  ind_data.ext_burst_data.db_subtype = call_info_ptr->mode_info.info.cdma_call.ext_brst_intl_msg.db_subtype;
  ind_data.ext_burst_data.chg_ind    = call_info_ptr->mode_info.info.cdma_call.ext_brst_intl_msg.chg_ind;
  ind_data.ext_burst_data.sub_unit   = call_info_ptr->mode_info.info.cdma_call.ext_brst_intl_msg.sub_unit;
  ind_data.ext_burst_data.unit       = call_info_ptr->mode_info.info.cdma_call.ext_brst_intl_msg.unit;
  
  QM_MSG_MED_5("burst intl: mcc=%d, db_subtype=%d, chg_ind=%d, sub_unit=%d, unit=%d", ind_data.ext_burst_data.mcc, ind_data.ext_burst_data.db_subtype, 
  	ind_data.ext_burst_data.chg_ind, ind_data.ext_burst_data.sub_unit, ind_data.ext_burst_data.unit);

  /* Send ext burst internatiol indication */
  qmi_voice_cm_if_unsol_response( QMI_VOICE_CM_IF_CMD_EXT_BRST_INTL_IND, (void *) &ind_data, sizeof( ind_data ), as_id );
} /* qmi_voice_cm_if_send_ext_burst_international_ind() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SEND_MT_PAGE_MISS_IND()

  DESCRIPTION
	Send MT PAGE MISS indication to client.

  PARAMETERS
	event		   : Call event received
        as_id              : subscription info (received from CM or default)

  RETURN VALUE
	None

  DEPENDENCIES
	None

  SIDE EFFECTS
	None
===========================================================================*/
static void qmi_voice_cm_if_send_mt_page_miss_ind
(
  cm_mm_call_info_s_type *call_info_ptr,
  uint8     as_id
)
{ 
  voice_mt_page_miss_ind_msg_v02 ind_data;

  /*-----------------------------------------------------------------------*/
  
	ASSERT( call_info_ptr );
  
  /*-----------------------------------------------------------------------*/


  /*Initialize notification indication structure */
  memset(&ind_data,0,sizeof(ind_data));

  /* Extract the end reason for the mt page fail */
  qmi_voice_cm_if_extract_call_end_reason(call_info_ptr);
  ind_data.page_miss_reason = (call_end_reason_enum_v02)cm_if_info.call_fail_cause;

  QM_MSG_MED_1("MT PAGE MIS END reason = %d ", ind_data.page_miss_reason);
  /* Send MT PAGE MISS indication */
  qmi_voice_cm_if_unsol_response( QMI_VOICE_CM_IF_CMD_MT_PAGE_MISS_IND, (void *) &ind_data, sizeof( ind_data ), as_id);

} /* qmi_voice_cm_if_send_mt_page_miss_ind() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SEND_CC_RESULT_INFO_IND()

  DESCRIPTION
        Send Call control result info indication to client.

  PARAMETERS
        cc_result               : Call control result (MODIFIED/NOT MODIFIED etc)
        cm_alpha              : Call control alpha coming from CM
        as_id                    : Subscription information
  RETURN VALUE
        None

  DEPENDENCIES
        None

  SIDE EFFECTS
        None
===========================================================================*/
static void qmi_voice_cm_if_send_cc_result_info_ind
(
  cm_cc_result_e_type            cc_result,
  cm_alpha_s_type                cm_alpha,
  uint8                          as_id
)
{ 
  voice_call_control_result_info_ind_msg_v02 ind_data;
  qmi_voice_cm_if_cc_alpha_id_s         alpha;

  /*Initialize notification indication structure */
  memset(&ind_data,0,sizeof(ind_data));
  memset(&alpha,0,sizeof(alpha));

  /* cc_result value */
  ind_data.cc_result = (voice_cc_result_enum_v02)cc_result;

  if(cm_alpha.len > 0)
  {
    /* Alpha NULL case */
    if((cm_alpha.len == 1) && (cm_alpha.buf[0] == '\0'))
    {
      ind_data.alpha_presence = VOICE_CC_ALPHA_NULL_V02;
    }
    else
    {
      ind_data.alpha_presence = VOICE_CC_ALPHA_PRESENT_V02;

      qmi_voice_cm_util_copy_cc_alpha_info_from_cm((qmi_voice_cm_if_cc_alpha_id_s*)(&alpha),&(cm_alpha));

      if(alpha.alpha_len > 0)
      {
        /* Alpha present, gsm 8bit case*/
        if(alpha.alpha_dcs == QMI_VOICE_CM_IF_ALPHA_DCS_GSM_DEFAULT)
        {
          ind_data.alpha_text_gsm8_valid    = TRUE;
          ind_data.alpha_text_gsm8_len      = alpha.alpha_len;

          memscpy(&(ind_data.alpha_text_gsm8), sizeof(ind_data.alpha_text_gsm8),&(alpha.alpha_text),alpha.alpha_len);
        } /*Alpha preset, ucs2 case */
        else if(alpha.alpha_dcs == QMI_VOICE_CM_IF_ALPHA_DCS_UCS2) 
        {
          ind_data.alpha_text_utf16_valid = TRUE;
          ind_data.alpha_text_utf16_len   =  qm_util_decode_ucs2_80_81_82_encoding(alpha.alpha_text,
                                                                            alpha.alpha_len,
                                                                            ind_data.alpha_text_utf16,
                                                                            QMI_VOICE_CC_ALPHA_TEXT_MAX_V02);
        }
      }
      else
      {
        QM_MSG_ERROR_1("Unexpected alpha from CM len=%d ", cm_alpha.len);
      }
    }
  }//else VOICE_CC_ALPHA_NOT_PRESENT_V02
  QM_MSG_MED_5("CC Result info ind cc result = %d, alpha_gsm8_len=%d,alpha_utf16_len=%d, dcs = %d, presence=%d", cc_result, ind_data.alpha_text_gsm8_len, ind_data.alpha_text_utf16_len, alpha.alpha_dcs, ind_data.alpha_presence);


  /* Send CC Result info indication */
  qmi_voice_cm_if_unsol_response(   QMI_VOICE_CM_IF_CMD_CC_RESULT_INFO_IND, (void *) &ind_data, sizeof( ind_data ), as_id);

} /* qmi_voice_cm_if_send_cc_result_info_ind() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALL_MOD_TO_SUPS()

  DESCRIPTION
    Handle the case when sim call control modifies the voice call to 
    supplementary service or USSD.

  PARAMETERS
    call_info_ptr          : pointer to cm_mm_call_info_s_type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_call_mod_to_sups
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  voice_dial_call_resp_msg_v02 dial_call_resp;
  qmi_voice_cmd_list_public_type cmd_info; 
  qmi_voice_cm_if_evt_e_type evt;
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  uint8 conn_idx = QMI_VOICE_CM_UTIL_CONN_ID_INVALID;
  cm_voice_to_ss_param_s_type *call_to_sups;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  boolean send_end_ind = FALSE;

  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr );

  /*-----------------------------------------------------------------------*/

  QM_MSG_MED_1("QMI VOICE Recieved CM_CALL_EVENT_ORIG_MOD_TO_SS with call_id = %d ", call_info_ptr->call_id);

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)call_info_ptr->asubs_id;
#endif

  call_to_sups = (cm_voice_to_ss_param_s_type *)&call_info_ptr->result_from_cc.voice_to_ss;

  if(qmi_voice_cmd_list_query_by_event_and_sub_id(QMI_VOICE_CM_IF_EVT_CALL_ORIG,call_info_ptr->call_id,&cmd_info, as_id) == E_SUCCESS)
  {
    memset(&dial_call_resp, 0, sizeof(dial_call_resp));

    switch(call_info_ptr->result_from_cc.call_control_result)
    {
      case CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_SS:
        dial_call_resp.cc_result_type_valid = TRUE;
        dial_call_resp.cc_result_type = VOICE_CC_RESULT_TYPE_SUPS_V02;
        dial_call_resp.cc_sups_result_valid = TRUE;
        dial_call_resp.cc_sups_result.reason = (voice_cc_sups_result_reason_enum_v02)qmi_voice_cm_sups_get_reason_from_ss_code(call_to_sups->ss_code);
      case CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_USSD:
        QM_MSG_HIGH_3("Call modified to sups:  ss_code:%d, ss_oper:%d, ss_ref:%d", call_to_sups->ss_code, call_to_sups->ss_oper, call_to_sups->ss_ref);
        dial_call_resp.cc_result_type_valid = TRUE;
        dial_call_resp.cc_result_type = VOICE_CC_RESULT_TYPE_SUPS_V02;
        dial_call_resp.cc_sups_result_valid = TRUE;
        dial_call_resp.cc_sups_result.service_type = (voice_cc_sups_result_service_type_enum_v02)qmi_voice_cm_sups_get_service_type_from_operation(call_to_sups->ss_oper);
        if(call_info_ptr->result_from_cc.call_control_result != CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_SS)
        {
          dial_call_resp.cc_result_type = VOICE_CC_RESULT_TYPE_USSD_V02;
        }
        break;
      default:
        QM_MSG_HIGH_1("Invalid call control result %d from CM", call_info_ptr->result_from_cc.call_control_result);
        dial_call_resp.resp.result = QMI_RESULT_FAILURE_V01;
        dial_call_resp.resp.error = QMI_ERR_INTERNAL_V01;
        break;
    }
    if(call_info_ptr->result_from_cc.alpha.len > 0)
    {
      dial_call_resp.alpha_ident_valid = TRUE;
      qmi_voice_cm_util_copy_alpha_ident_from_cm(&(dial_call_resp.alpha_ident),&(call_info_ptr->result_from_cc.alpha));
      QM_MSG_HIGH_2("Recevied ALPHA DCS from CM = %d, Voice= %d", call_info_ptr->result_from_cc.alpha.dcs, dial_call_resp.alpha_ident.alpha_dcs);
    }
    if(qmi_voice_call_list_get_conn_idx_from_call_id( call_info_ptr->call_id, &conn_idx ) != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Conn index not found for call id = %d ", call_info_ptr->call_id);
    }
    dial_call_resp.media_id_valid = TRUE;
    dial_call_resp.media_id = call_info_ptr->call_id;
    dial_call_resp.call_id_valid = TRUE;
    dial_call_resp.call_id = conn_idx;
    
    /* Send response to the dial request */
    qmi_voice_cm_if_response_success(cmd_info.hdl,cmd_info.cmd,&dial_call_resp,sizeof(dial_call_resp),TRUE);

    /* Reset the eCall info */
    if(call_info_ptr->call_id == cm_if_info.eCall_info.eCall_id)
    {
      cm_if_info.eCall_info.eCall_id = CM_CALL_ID_INVALID;
      cm_if_info.eCall_info.eCall_client_id = CM_CLIENT_ID_ANONYMOUS;
      cm_if_info.eCall_info.as_id = QMI_VOICE_CM_IF_AS_ID_INVALID;
    }

    if(dial_call_resp.resp.error != QMI_ERR_INTERNAL_V01)
    {
      evt = qmi_voice_cm_sups_get_event_from_service_type((qmi_voice_cm_sups_service_type_e_type)dial_call_resp.cc_sups_result.service_type);
      cmd_info_ptr->ss_code = call_to_sups->ss_code;
      cmd_info_ptr->ss_ref  = call_to_sups->ss_ref; /* ss_ref generated by CM */
      cmd_info_ptr->cc_mod_conn_idx = conn_idx;
      if ( qmi_voice_cmd_list_new( QMI_VOICE_CM_IF_CMD_CALL_MOD_TO_SUPS, QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL,
                                                       QMI_VOICE_CMD_AWAITING_MORE_AMSS_EVENTS,
                                                       evt,
                                                       call_to_sups->ss_ref, &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
      {
        //Could not add entry to the list
      }
    }
  }

  if ( qm_efs_is_no_wait_rsp_enabled() )
  {
    send_end_ind = TRUE;
    cm_if_info.call_fail_cause = QMI_FAILURE_CAUSE_CALL_REJECTED;
  }
  
  /* Remove the call data from the list as call is modified to sups */
  if ( qmi_voice_call_list_free( call_info_ptr->call_id, send_end_ind ) != E_SUCCESS )
  {
    QM_MSG_ERROR_1("Failed to delete the Call list entry :  call_id %d", call_info_ptr->call_id);
  }

}/* qmi_voice_cm_if_call_mod_to_sups */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALL_L2ACK_CALL_HOLD()

  DESCRIPTION
    Handle the case when L2Ack is recieved from network for SEND_FLASH.

  PARAMETERS
    call_info_ptr          : pointer to cm_mm_call_info_s_type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

void qmi_voice_cm_if_call_l2ack_call_hold
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  qmi_voice_cmd_list_public_type cmd_info;
  voice_send_flash_resp_msg_v02 send_flash_resp;
  uint8 conn_idx = 0;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/
 
   ASSERT( call_info_ptr );
 
 /*-----------------------------------------------------------------------*/
 
  memset(&send_flash_resp, 0, sizeof(send_flash_resp));

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)call_info_ptr->asubs_id;
#endif
 
  if ( qmi_voice_cmd_list_query_by_event(QMI_VOICE_CM_IF_EVT_CALL_L2ACK_CALL_HOLD,&cmd_info, as_id) == E_SUCCESS )
  { 
    if(qmi_voice_call_list_get_conn_idx_from_call_id( (cm_call_id_type) call_info_ptr->call_id, &conn_idx ) == E_SUCCESS)
    {
      send_flash_resp.call_id_valid = TRUE;
      send_flash_resp.call_id = conn_idx;
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&send_flash_resp, sizeof(send_flash_resp), TRUE );
    }
    else
    {
      QM_MSG_ERROR_1("Not Found the conn index for the call id= %d in the list", call_info_ptr->call_id);
      qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_INCOMPATIBLE_STATE, TRUE, FALSE );
    }
  }
  else
  {
    QM_MSG_HIGH("None of entry is waiting for QMI_VOICE_CM_IF_EVT_CALL_L2ACK_CALL_HOLD");
    return;   
  }
  
}/*qmi_voice_cm_if_call_l2ack_call_hold*/
/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALLSVC_EVENT_MANAGE_CALLS_CONF()

  DESCRIPTION
    Manage call conf sent by CM is handled here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_callsvc_event_manage_calls_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_call_info_s_type *call_info_ptr
)
{
  qmi_voice_cmd_list_public_type cmd_info;
  voice_manage_calls_resp_msg_v02 manage_calls_resp;
  voice_manage_ip_calls_resp_msg_v02 mng_ip_calls_resp;
  qmi_voice_call_list_call_ids_list_type call_ids_list;
  qmi_voice_call_list_call_ids_list_type active_call_ids_list, held_call_ids_list;
  uint8 i=0, as_id=(uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  boolean is_call_state_changed = FALSE;
  boolean send_mng_ip_calls_resp = TRUE;
  boolean send_conf_part_update_ind = FALSE;
  boolean is_cause_found=FALSE;
  cm_call_id_type  cm_call_id = 0;

  /*-----------------------------------------------------------------------*/
  ASSERT( call_info_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_callsvc_event_manage_calls_conf():");

  memset(&manage_calls_resp, 0, sizeof(manage_calls_resp));

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)call_info_ptr->asubs_id;
#endif

  if ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS )
  {
    /* See if there is any RIL request pending for the event */
    QM_MSG_MED_1("Recieved Manage call conf with call_ss_success = %d ", call_info_ptr->mode_info.info.gw_cs_call.call_ss_success);
    if ( qmi_voice_cmd_list_query_by_event( event, &cmd_info, as_id ) == E_SUCCESS ) 
    {
      /* Success in supplementary command */
      if ( call_info_ptr->mode_info.info.gw_cs_call.call_ss_success )
      {
        if( QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING == cmd_info.sub_id )
        {
          /* If there are active calls it means that the release is not complete. And if there are no active calls
          and if the active_calls_list from NAS is 0, it means that the MNG CALLS CONF is for the last released call.
          So we need to wait for the event which indicates held call as active. */
          qmi_voice_call_list_query_voice_call_ids_list_by_state( QMI_VOICE_CALL_LIST_STATE_ACTIVE, &call_ids_list, as_id );
          if( (call_ids_list.num_of_call_ids > 0) || 
               (call_info_ptr->mode_info.info.gw_cs_call.active_calls_list.size == 0) )
          {
            QM_MSG_MED("Ignore MNG CALLS CONF - Release not complete or Held call is not active yet");
            return;
          }
        }
        if ( qmi_voice_call_list_manage( &call_info_ptr->mode_info.info.gw_cs_call.active_calls_list, as_id) != E_SUCCESS )
        {
          QM_MSG_ERROR("Fail to update the state of Call list entries for manage");
        }
        qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&manage_calls_resp, sizeof(manage_calls_resp), TRUE );
      }
      /* Failure in supplementary command */
      else
      {
         manage_calls_resp.resp.result = QMI_RESULT_FAILURE_V01;
         manage_calls_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
         manage_calls_resp.failure_cause_valid = TRUE;
         manage_calls_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(call_info_ptr->mode_info.info.gw_cs_call.ss_error,call_info_ptr->mode_info.info.gw_cs_call.cc_cause);
         qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&manage_calls_resp, sizeof(manage_calls_resp), TRUE );
         return;
      }
    }
    else
    {
      /*When there is no command in the command list, i.e., if the request was originated by non-QMI clients 
                                                                 (or) 
        When originated through Dial Req ex: Dial 1 once CONNECTED then Dial 2, First call will be kept on Hold by N/W */
              
      if ( call_info_ptr->mode_info.info.gw_cs_call.call_ss_success )
      {
        if ( qmi_voice_call_list_manage( &call_info_ptr->mode_info.info.gw_cs_call.active_calls_list,as_id ) != E_SUCCESS )
        {
          QM_MSG_ERROR("Fail to update Call list entries for manage calls when no command exists");
          return;
        }
      }
      /* Failure in supplementary command */
      else
      {
         QM_MSG_ERROR("Manage calls conf recieved when someone originated with a command");
         return;
      }     
    }
  }
  else if( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP )
  {
    QM_MSG_MED_1("Recieved Manage call conf with call_ss_success = %d ", call_info_ptr->mode_info.info.ip_call.call_ss_success);
    if ( qmi_voice_cmd_list_query_by_event( event, &cmd_info, as_id ) == E_SUCCESS ) 
    {
      memset(&mng_ip_calls_resp, 0, sizeof(mng_ip_calls_resp));
      
      if ( call_info_ptr->mode_info.info.ip_call.call_ss_success )
      {
        switch(cmd_info.sub_id)
        {
          case QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD:
            /* Put the active calls on hold and retrieve any held calls */
            qmi_voice_call_list_query_voice_call_ids_list_by_state( QMI_VOICE_CALL_LIST_STATE_ACTIVE, &active_call_ids_list, as_id );
            qmi_voice_call_list_query_voice_call_ids_list_by_state( QMI_VOICE_CALL_LIST_STATE_HOLDING|QMI_VOICE_CALL_LIST_STATE_WAITING, 
                                                                    &held_call_ids_list, as_id );
            QM_MSG_MED_2("Num of active calls %d, num of held/waiting calls %d", active_call_ids_list.num_of_call_ids, held_call_ids_list.num_of_call_ids);
            for(i=0; i < active_call_ids_list.num_of_call_ids; i++)
            {
              qmi_voice_call_list_update_call_state(active_call_ids_list.call_id[i],QMI_VOICE_CALL_LIST_STATE_HOLDING);
              is_call_state_changed = TRUE;
            }
            for(i=0; i < held_call_ids_list.num_of_call_ids; i++)
            {
              qmi_voice_call_list_update_call_state(held_call_ids_list.call_id[i],QMI_VOICE_CALL_LIST_STATE_ACTIVE);
              is_call_state_changed = TRUE;
            }
            break;
            
          case QMI_VOICE_CM_IF_MNG_IP_CALLS_MAKE_CONFERENCE_CALL:
            //QMI_VOICE_CM_IF_MNG_IP_CALLS_MAKE_CONFERENCE_CALL case

            /* Get the CM call_id for the conference call first */
            if(qmi_voice_call_list_get_conf_call_id(&cm_call_id) == E_SUCCESS)
            {
              /* Get the QMI Conn Idx from CM call_id */
              if(qmi_voice_call_list_get_conn_idx_from_call_id( cm_call_id, &mng_ip_calls_resp.call_id ) == E_SUCCESS)
            {
              mng_ip_calls_resp.call_id_valid = TRUE;
              send_mng_ip_calls_resp = TRUE;
              /* Only one call in VoIP case will be active during conference */
              if(qmi_voice_call_list_query_by_call_id_and_call_state(mng_ip_calls_resp.call_id, QMI_VOICE_CALL_LIST_STATE_ACTIVE) != E_SUCCESS )					
              {
                 QM_MSG_MED("Conf call is not active, sending all_call_status_ind");
	         qmi_voice_call_list_report_all_call_status_changed(as_id);
	      }
            }
            else
            {
                QM_MSG_ERROR_1("Conn index not found for call id = %d ", cm_call_id);
              }
            }
            else
            {
              /* Could be the case of the existing active cals being held initially before getting
              joined into a conf call. Wait for the next MNG_CALLS_CONF to make sure the conf call
              is established. */
              send_mng_ip_calls_resp = FALSE;
              QM_MSG_MED("There is no conference call in the call list");
            }

            //Number of participants Added or Removed 
            mng_ip_calls_resp.num_participants = call_info_ptr->mode_info.info.ip_call.number_of_participants_add_removed;
            
            QM_MSG_MED_1("Num participants_added_deleted = %d", mng_ip_calls_resp.num_participants);
            if(mng_ip_calls_resp.num_participants > 0) 
            {
              mng_ip_calls_resp.num_participants_valid = TRUE;
              send_conf_part_update_ind = TRUE;
            }

            break;

          case QMI_VOICE_CM_IF_MNG_IP_CALLS_ADD_PARTICIPANT:
            /* Only one call in VoIP case will be active during conference */
            if(qmi_voice_call_list_get_conn_idx_from_call_id(call_info_ptr->call_id,&mng_ip_calls_resp.call_id) == E_SUCCESS)
            {
              mng_ip_calls_resp.call_id_valid = TRUE;
            }
            else
            {
              /* if this manage call request to add participant is successful, there should be an active conference call*/
              /* shoud not hit this point*/
              send_mng_ip_calls_resp = FALSE;
              QM_MSG_ERROR("Not found call ID given by CM");
            }

            /*set MPTY but if not already set and report to clients */
            if (qmi_voice_call_list_is_mpty_call(call_info_ptr->call_id) == FALSE)
            {
              QM_MSG_MED_1("Setting MPTY Bit for call_id %d", call_info_ptr->call_id);
              if (qmi_voice_call_list_set_mpty_status(call_info_ptr->call_id, TRUE) != E_SUCCESS)
              {
                QM_MSG_ERROR_1("Failed to update the multiparty status for call_id %d", call_info_ptr->call_id);
              }
              else
              {
                is_call_state_changed = TRUE;
              }
            }

            //Number of participants Added or Removed 
            //QMI_VOICE_CM_IF_MNG_IP_CALLS_ADD_PARTICIPANT case
            mng_ip_calls_resp.num_participants = call_info_ptr->mode_info.info.ip_call.number_of_participants_add_removed;
            
            QM_MSG_MED_1("Num participants_added_deleted = %d", mng_ip_calls_resp.num_participants);
            if(mng_ip_calls_resp.num_participants > 0) 
            {
              mng_ip_calls_resp.num_participants_valid = TRUE;
              send_conf_part_update_ind = TRUE;
            }
            break;

          case QMI_VOICE_CM_IF_MNG_IP_CALLS_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING:
            qmi_voice_call_list_query_voice_call_ids_list_by_state( QMI_VOICE_CALL_LIST_STATE_HOLDING|QMI_VOICE_CALL_LIST_STATE_WAITING, 
                                                                    &held_call_ids_list, as_id );
            for(i=0; i < held_call_ids_list.num_of_call_ids; i++)
            {
              qmi_voice_call_list_update_call_state(held_call_ids_list.call_id[i],QMI_VOICE_CALL_LIST_STATE_ACTIVE);
              is_call_state_changed = TRUE;
            }
            break;
            
          case QMI_VOICE_CM_IF_MNG_IP_CALLS_RELEASE_SPECIFIED_CALL_FROM_CONFERENCE:
            send_mng_ip_calls_resp = TRUE;
            is_call_state_changed = TRUE;

            //QMI_VOICE_CM_IF_MNG_IP_CALLS_RELEASE_SPECIFIED_CALL_FROM_CONFERENCE case
            //Number of participants Added or Removed 
            mng_ip_calls_resp.num_participants = call_info_ptr->mode_info.info.ip_call.number_of_participants_add_removed;
            QM_MSG_MED_1("Num participants_added_deleted = %d", mng_ip_calls_resp.num_participants);
            if(mng_ip_calls_resp.num_participants > 0) 
            {
              mng_ip_calls_resp.num_participants_valid = TRUE;
              send_conf_part_update_ind = TRUE;
            }

            break;
            
          case QMI_VOICE_CM_IF_MNG_IP_CALLS_CALL_DEFLECTION:
            send_mng_ip_calls_resp = TRUE;
            //QMI_VOICE_CM_IF_MNG_IP_CALLS_CALL_DEFLECTION case confirmation received
            break;

          case QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_PER_CALL:
            /* Only one call will be in active state in VoIP case */
            qmi_voice_call_list_query_voice_call_ids_list_by_state( QMI_VOICE_CALL_LIST_STATE_ACTIVE, &active_call_ids_list, as_id );
            QM_MSG_MED_1("Put call_id %d to hold state", active_call_ids_list.call_id[0]);
            qmi_voice_call_list_update_call_state(active_call_ids_list.call_id[0],QMI_VOICE_CALL_LIST_STATE_HOLDING);
            is_call_state_changed = TRUE;
            break;

          case QMI_VOICE_CM_IF_MNG_IP_CALLS_RESUME_PER_CALL:
            /* Call state is updated when receiving CM_CALL_EVENT_CALL_RETRIEVED */
            //QMI_VOICE_CM_IF_MNG_IP_CALLS_RESUME_PER_CALL case confirmation received
            break;
      
          case QMI_VOICE_CM_IF_MNG_IP_CALLS_EXPLICIT_CALL_TRANSFER_VOIP:
            send_mng_ip_calls_resp = TRUE;
            //QMI_VOICE_CM_IF_MNG_IP_CALLS_EXPLICIT_CALL_TRANSFER_VOIP case confirmation received
            break;
      
          default:
            QM_MSG_MED_1("Unhandled sups type (%d) for manage ip calls", cmd_info.sub_id);
            break;
        }
        if(send_mng_ip_calls_resp)
        {
          qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&mng_ip_calls_resp, sizeof(mng_ip_calls_resp), TRUE );

          if(send_conf_part_update_ind == TRUE)
          {
            qmi_voice_cm_if_send_conference_participant_update_ind(call_info_ptr);
            QM_MSG_MED("Done sending participant update ind SENT");
          }
        }
        /* Report the call information in case of any change in state */
        if(is_call_state_changed)
        {
          qmi_voice_call_list_report_all_call_status_changed(as_id);
        }
      }
      else
      {
        switch(cmd_info.sub_id)
        {
          case QMI_VOICE_CM_IF_MNG_IP_CALLS_ADD_PARTICIPANT:
          case QMI_VOICE_CM_IF_MNG_IP_CALLS_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING:
          case QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD:
          case QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_PER_CALL:
          case QMI_VOICE_CM_IF_MNG_IP_CALLS_RESUME_PER_CALL:
            mng_ip_calls_resp.resp.result = QMI_RESULT_FAILURE_V01;
            mng_ip_calls_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
            mng_ip_calls_resp.failure_cause_valid = TRUE;
            mng_ip_calls_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_util_map_cm_to_qmi_ip_sups_failure_cause(call_info_ptr->mode_info.info.ip_call.modify_error_code,&is_cause_found);

            qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&mng_ip_calls_resp, sizeof(mng_ip_calls_resp), TRUE );
            break;
          default:
            /* Report unknown error for VoIP sups failure */
            qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_UNKNOWN, TRUE, TRUE);
            break;
        }
      }
    }
  }
}


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALLSVC_EVENT_MODIFY_COMPLETE_CONF()
 

  DESCRIPTION
    Modify complete conf sent by CM is handled here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_callsvc_event_modify_complete_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_call_info_s_type *call_info_ptr
)
{
  qmi_voice_cmd_list_public_type cmd_info;
  voice_manage_ip_calls_resp_msg_v02 mng_ip_calls_resp;
  boolean is_call_attrib_changed = FALSE;
  qmi_voice_cm_if_failure_cause_e_type  failure_cause = QMI_FAILURE_CAUSE_UNKNOWN;
  qmi_voice_cm_if_call_modified_cause_e_type  ip_call_modified_cause = QMI_VOICE_CM_IF_CALL_MODIFIED_CAUSE_NONE;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  boolean is_cause_found = FALSE;

  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)call_info_ptr->asubs_id;
#endif

 memset(&cmd_info,0,sizeof(cmd_info));
  
  QM_MSG_MED_3("In qmi_voice_cm_if_callsvc_event_modify_complete_conf(): call_ss_success=%d, call_modif_err_status=%d, info_type=%d.", call_info_ptr->mode_info.info.ip_call.call_ss_success, call_info_ptr->mode_info.info.ip_call.call_modif_err_status, call_info_ptr->mode_info.info_type);

  if ( qmi_voice_cmd_list_query_by_event( event, &cmd_info, as_id ) == E_SUCCESS ) 
  {
    memset(&mng_ip_calls_resp, 0, sizeof(mng_ip_calls_resp));

    /* No error in operation, update call attributes, send modified ind if any change*/
    if ( !call_info_ptr->mode_info.info.ip_call.call_modif_err_status )
    {
    QM_MSG_MED_6("Call id %d, Modified call type =%d, a_attrib = %d, v_attrib = %d, Attrib status= %d, Modified Cause = %d", call_info_ptr->call_id, call_info_ptr->call_type,
                   (uint8)call_info_ptr->mode_info.info.ip_call.call_attrib_info.audio_attrib,
                   (uint8)call_info_ptr->mode_info.info.ip_call.call_attrib_info.video_attrib,
                   (uint8)call_info_ptr->mode_info.info.ip_call.call_attrib_info.attrib_status,
                   call_info_ptr->mode_info.info.ip_call.modify_cause_code);
      switch(cmd_info.sub_id)
      {
        case QMI_VOICE_CM_IF_MNG_IP_CALLS_MODIFY_CALL:
        case QMI_VOICE_CM_IF_MNG_IP_CALLS_MODIFY_ACCEPT:
        case QMI_VOICE_CM_IF_MNG_IP_CALLS_MODIFY_REJECT:
        {
          if( qmi_voice_call_list_update_call_attributes_type(call_info_ptr->call_id,
                                                              call_info_ptr->mode_info.info.ip_call.call_attrib_info,
                                                              call_info_ptr->call_type) == E_SUCCESS )
          {
            QM_MSG_MED_1("Modified Call type/attributes for call_id %d", call_info_ptr->call_id);
            is_call_attrib_changed = TRUE;
          }
          break;
        }
        default:
          QM_MSG_MED_1("Unhandled sups type (%d) for manage ip calls", cmd_info.sub_id);
          break;
      }

      if ( cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_MODIFY_CALL )
      {
        ip_call_modified_cause = qmi_voice_cm_util_map_cm_to_qmi_ip_call_modified_cause(call_info_ptr->mode_info.info.ip_call.modify_cause_code, &is_cause_found);
        if(is_cause_found)
        {
          mng_ip_calls_resp.call_modified_cause_valid = TRUE;
          mng_ip_calls_resp.call_modified_cause = (voice_call_modified_cause_enum_v02)ip_call_modified_cause;
        }
      }

      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&mng_ip_calls_resp, sizeof(mng_ip_calls_resp), TRUE );

      if(is_call_attrib_changed)
      {
        /* Report the call information in case of any change in state */
        qmi_voice_cm_if_call_modified_ind(call_info_ptr);
        return;
      }
    }
    else
    {
      QM_MSG_MED_1("End Status received:  %d", call_info_ptr->end_status);
      failure_cause = qmi_voice_cm_util_map_cm_to_qmi_ip_sups_failure_cause(call_info_ptr->mode_info.info.ip_call.modify_error_code,&is_cause_found);
      if(is_cause_found)
      {
        mng_ip_calls_resp.resp.result = QMI_RESULT_FAILURE_V01;
        mng_ip_calls_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
        mng_ip_calls_resp.failure_cause_valid = TRUE;
        mng_ip_calls_resp.failure_cause = (qmi_sups_errors_enum_v02)failure_cause;
        qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&mng_ip_calls_resp, sizeof(mng_ip_calls_resp), TRUE );
      }
      else
      {
        /* Report unknown error for VoIP sups failure */
        qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_INTERNAL, TRUE, TRUE);
      }
    }
  }
  else if(!call_info_ptr->mode_info.info.ip_call.call_modif_err_status)
  { 
    /* Modified indication to be sent even if this was not triggered by a client*/
    if( qmi_voice_call_list_update_call_attributes_type(call_info_ptr->call_id,
                                                        call_info_ptr->mode_info.info.ip_call.call_attrib_info,
                                                        call_info_ptr->call_type) == E_SUCCESS )
    {
       QM_MSG_MED_1("Modified Call type/attributes for call_id %d", call_info_ptr->call_id);
       /* Report the call information in case of any change in state */
       qmi_voice_cm_if_call_modified_ind(call_info_ptr);
       return;
    }
  }
  else
  {
    qmi_voice_cm_if_call_modified_ind(call_info_ptr);
    return;
  }
}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALL_SWITCH_CODEC_CNF()
 

  DESCRIPTION
    Switch codec cnf sent by CM is handled here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_call_switch_codec_cnf
(
  qmi_voice_cm_if_evt_e_type  event,
  cm_mm_call_info_s_type     *call_info_ptr
)
{
  qmi_voice_cmd_list_public_type          cmd_info;
  voice_manage_ip_calls_resp_msg_v02      mng_ip_calls_resp;
  uint8                                   as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)call_info_ptr->asubs_id;
#endif

  memset(&cmd_info,0,sizeof(cmd_info));
  
  QM_MSG_MED_2("In qmi_voice_cm_if_call_switch_codec_cnf(): call_id %d, switch_codec_status %d", call_info_ptr->call_id, call_info_ptr->mode_info.info.ip_call.switch_codec_status);

  if ( qmi_voice_cmd_list_query_by_event( event, &cmd_info, as_id ) == E_SUCCESS ) 
  {
    memset(&mng_ip_calls_resp, 0, sizeof(mng_ip_calls_resp));

    /* No error in switch codec, send successful response */
    if ( TRUE == call_info_ptr->mode_info.info.ip_call.switch_codec_status )
    {
      mng_ip_calls_resp.resp.error = (qmi_error_type_v01)QMI_ERR_NONE;
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&mng_ip_calls_resp, sizeof(mng_ip_calls_resp), TRUE );
    }
    else
    {
      /* Report internal error for codec switch failure */
      qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_INTERNAL, TRUE, TRUE);
    }
  }
  else
  {
    QM_MSG_HIGH_1( "No cmd_list pending for QMI_VOICE_CM_IF_EVT_CALL_SWITCH_CODEC_CNF (event %d)",
                    event );
    return;
  }
} /* qmi_voice_cm_if_call_switch_codec_cnf() */

/*===========================================================================
  FUNCTION qmi_voice_cm_if_call_modified_ind()
 

  DESCRIPTION
    Indicates  call attributes got modified.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

void qmi_voice_cm_if_call_modified_ind
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  voice_modified_ind_msg_v02 modified_ind;
  uint8 conn_index=0;
  qmi_voice_call_list_public_type call_data;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  qmi_voice_cm_if_failure_cause_e_type  failure_cause = QMI_FAILURE_CAUSE_UNKNOWN;
  qmi_voice_cm_if_call_modified_cause_e_type ip_call_modified_cause = QMI_VOICE_CM_IF_CALL_MODIFIED_CAUSE_NONE;
  boolean is_cause_found = FALSE;

#ifdef FEATURE_DUAL_SIM
  as_id = call_info_ptr->asubs_id;
#endif

  memset(&call_data, 0, sizeof(qmi_voice_call_list_public_type));
  memset(&modified_ind,0,sizeof(modified_ind));
 
  QM_MSG_MED_6("Modified entry for call id= %d, type = %d, v_attrib = %d, a_attrib = %d, attrib_status = %d, Modify_cause = %d", call_info_ptr->call_id, call_info_ptr->call_type,
                call_info_ptr->mode_info.info.ip_call.call_attrib_info.video_attrib,
                call_info_ptr->mode_info.info.ip_call.call_attrib_info.audio_attrib,
                call_info_ptr->mode_info.info.ip_call.call_attrib_info.attrib_status, call_info_ptr->mode_info.info.ip_call.modify_cause_code);

  if(qmi_voice_call_list_get_conn_idx_from_call_id(call_info_ptr->call_id, &conn_index) == E_SUCCESS)
  {
    if( qmi_voice_call_list_query_by_call_id(call_info_ptr->call_id, &call_data) == E_SUCCESS)
    {
      QM_MSG_MED_3("Original entry for conn idx = %d, type = %d, mode_info = %d :", call_data.conn_index, call_data.call_type, call_data.mode_info_type);
    }
    modified_ind.call_id = conn_index;
    if(!(call_info_ptr->mode_info.info.ip_call.call_modif_err_status))
    {
      modified_ind.call_type_valid = TRUE;
      modified_ind.call_type = (call_type_enum_v02)qmi_voice_cm_util_map_cm_to_qmi_call_type(call_info_ptr->call_type, call_data.mode_info_type);
      if((modified_ind.call_type == CALL_TYPE_EMERGENCY_IP_V02) && 
          (call_data.em_type == CM_CALL_EM_VT))
      {
        modified_ind.call_type = CALL_TYPE_EMERGENCY_VT_V02;
        QM_MSG_HIGH("em_type = VT");
      }
      modified_ind.audio_attrib_valid = TRUE;
      modified_ind.audio_attrib = (voice_call_attribute_type_mask_v02)call_info_ptr->mode_info.info.ip_call.call_attrib_info.audio_attrib ;
      
      modified_ind.video_attrib_valid = TRUE;
      modified_ind.video_attrib = (voice_call_attribute_type_mask_v02)call_info_ptr->mode_info.info.ip_call.call_attrib_info.video_attrib ;

      modified_ind.call_attrib_status_valid = TRUE;
      modified_ind.call_attrib_status = (voice_call_attrib_status_enum_v02)call_info_ptr->mode_info.info.ip_call.call_attrib_info.attrib_status;
      
      modified_ind.media_id_valid = TRUE;
      modified_ind.media_id = call_info_ptr->call_id;
      if ( qmi_voice_call_list_update_call_attributes_type(call_info_ptr->call_id,call_info_ptr->mode_info.info.ip_call.call_attrib_info,call_info_ptr->call_type ) != E_SUCCESS )
      {
         QM_MSG_ERROR_1("Fail to update the call_type/attrib %d", call_info_ptr->call_type);
      }

      ip_call_modified_cause = qmi_voice_cm_util_map_cm_to_qmi_ip_call_modified_cause(call_info_ptr->mode_info.info.ip_call.modify_cause_code,&is_cause_found);
      if ( is_cause_found )
      {
        modified_ind.call_modified_cause_valid = TRUE;
        modified_ind.call_modified_cause = (voice_call_modified_cause_enum_v02)ip_call_modified_cause;
      }
    }
    else
    {
      failure_cause = qmi_voice_cm_util_map_cm_to_qmi_ip_sups_failure_cause(call_info_ptr->mode_info.info.ip_call.modify_error_code,&is_cause_found);
      if(is_cause_found)
      {
        modified_ind.failure_cause_valid = TRUE;
        modified_ind.failure_cause = (qmi_sups_errors_enum_v02)failure_cause;
      }
    }
    qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_CALL_MODIFIED_IND,(void *)&modified_ind,sizeof(modified_ind),as_id);  
  }
}

/*===========================================================================
  FUNCTION qmi_voice_cm_if_call_modify_accept_ind()
 

  DESCRIPTION
    Indicates call attributes got modified/Upgraded from remote party.
    Needs Accept/Reject from Control points.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

void qmi_voice_cm_if_call_modify_accept_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_call_info_s_type *call_info_ptr
)
{
  voice_modify_accept_ind_msg_v02 modify_accept_ind;
  uint8 conn_index=0;
  qmi_voice_call_list_public_type call_data;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
#ifdef FEATURE_DUAL_SIM
    as_id = call_info_ptr->asubs_id;
#endif

  memset(&call_data, 0, sizeof(qmi_voice_call_list_public_type));
  memset(&modify_accept_ind,0,sizeof(modify_accept_ind));
 
  QM_MSG_MED_2("v_attrib = %d a_attrib from CM = %d:", call_info_ptr->mode_info.info.ip_call.call_attrib_info.video_attrib, call_info_ptr->mode_info.info.ip_call.call_attrib_info.audio_attrib);

  if(qmi_voice_call_list_get_conn_idx_from_call_id(call_info_ptr->call_id, &conn_index) == E_SUCCESS)
  {
    if( qmi_voice_call_list_query_by_call_id(call_info_ptr->call_id, &call_data) == E_SUCCESS)
    {
      QM_MSG_MED_3("Found entry for conn idx = %d, type = %d, mode_info = %d :", call_data.conn_index, call_data.call_type, call_data.mode_info_type);
    }
    modify_accept_ind.call_id = conn_index;
    modify_accept_ind.call_type_valid = TRUE;
    modify_accept_ind.call_type = (uint8)qmi_voice_cm_util_map_cm_to_qmi_call_type(call_info_ptr->call_type, call_data.mode_info_type);
    if((modify_accept_ind.call_type == CALL_TYPE_EMERGENCY_IP_V02) && 
        (call_data.em_type == CM_CALL_EM_VT))
    {
      modify_accept_ind.call_type = CALL_TYPE_EMERGENCY_VT_V02;
      QM_MSG_HIGH("em_type = VT");
    }
    modify_accept_ind.audio_attrib_valid = TRUE;
    modify_accept_ind.audio_attrib = call_info_ptr->mode_info.info.ip_call.call_attrib_info.audio_attrib ;
    modify_accept_ind.video_attrib_valid = TRUE;    
    modify_accept_ind.video_attrib = call_info_ptr->mode_info.info.ip_call.call_attrib_info.video_attrib ;
    qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_CALL_MODIFY_ACCEPT_IND,(void *)&modify_accept_ind,sizeof(modify_accept_ind), as_id);
  }

}

/*===========================================================================
                    SUPS EVENTS PROCESSING
===========================================================================*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_EVENT_INTERROGATE_CONF()

  DESCRIPTION
    Sups interrogate conf sent by CM is handled here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_event_interrogate_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
)
{
  qmi_voice_cmd_list_public_type list_info;
  qmi_voice_cm_if_cmd_info_sups_type *ss_list_info;
  boolean success = FALSE;
  int count = 0, count_sc = 0;
  basic_service_T *bsg_list_ptr;
  cli_restriction_info_T *cli_restriction_info;
  uint32 bs_class=0;
  uint8 i, status = 0, as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  cm_ip_sups_call_fwd_time_s_type dest_time_info;

  /*-----------------------------------------------------------------------*/

  ASSERT( sups_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)sups_info_ptr->asubs_id;
#endif
  

  if( qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
                                              sups_info_ptr->ss_ref,
                                              &list_info, as_id) != E_SUCCESS )
  {
    QM_MSG_ERROR("None of entry is waiting for QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF ");
    return;
  }


  ss_list_info = &list_info.sub.sups;


  QM_MSG_MED_4("sups_event_interrogate_conf():Sups info success = %d, conf type = %d, retry duration = %d, stored ss code = %d",
                sups_info_ptr->ss_success, sups_info_ptr->conf_type, sups_info_ptr->retry_duration, ss_list_info->ss_code);

  if(ss_list_info->ss_ref != sups_info_ptr->ss_ref)
  {
    QM_MSG_ERROR("QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF with incorrect ss_ref is received");
    return;
  }
  else if(sups_info_ptr->ss_success)
  {
    switch(ss_list_info->ss_code)
    {
      case qmi_voice_cm_sups_baoc:
      case qmi_voice_cm_sups_boic:
      case qmi_voice_cm_sups_boicExHC:
      case qmi_voice_cm_sups_baic:
      case qmi_voice_cm_sups_bicRoam:
      case qmi_voice_cm_sups_allCallRestrictionSS:
      case qmi_voice_cm_sups_barringOfOutgoingCalls:       
      case qmi_voice_cm_sups_barringOfIncomingCalls:  
      case qmi_voice_cm_sups_bil:
      case qmi_voice_cm_sups_bin:        
        {
          qmi_voice_cm_if_get_call_barring_resp_s get_call_barring_resp;
          memset(&get_call_barring_resp,0,sizeof(get_call_barring_resp));
          get_call_barring_resp.error = QMI_ERR_NONE;
          get_call_barring_resp.is_alpha_available = FALSE;
          memset(&get_call_barring_resp.alpha_id,0,sizeof(get_call_barring_resp.alpha_id));
          QM_MSG_MED_1("Get call barring confirmation type = %d is received", sups_info_ptr->conf_type);
          switch(sups_info_ptr->conf_type)
          {
            /* Success cases */
            case BSG_LIST_INFO:

              while(sups_info_ptr->bsg_list.list_length > count)
              {
               bsg_list_ptr = &sups_info_ptr->bsg_list.list[count];

               if(bsg_list_ptr->present)
               {
                 bs_class += qmi_voice_cm_sups_get_service_class(bsg_list_ptr->code_type,
                                                           bsg_list_ptr->bs_code);
               }
               count++;
              }

              get_call_barring_resp.service_class = (uint8) (bs_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
              get_call_barring_resp.service_class_ext = bs_class;

              success = TRUE;
              break;

            case SS_STATUS_INFO:
              /*status info received with ss_active set to TRUE is considered as success */
              if(sups_info_ptr->ss_status.present && sups_info_ptr->ss_status.cm_ss_active)
              {
                bs_class = (uint32)list_info.sub.sups.ss_service_class;
                if(bs_class == 0)
                {
                  bs_class = (uint32)QMI_VOICE_CM_SUPS_CLASS_ALL;
                }
				
                get_call_barring_resp.service_class = (uint8) (bs_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
                get_call_barring_resp.service_class_ext = bs_class;
              }
              else
              {
                get_call_barring_resp.service_class = QMI_VOICE_SERVICE_CLASS_NONE;
                get_call_barring_resp.service_class_ext = QMI_VOICE_SERVICE_CLASS_NONE;
              }
              success = TRUE;
              break;

            case CALL_BARRING_NUM_LIST_INFO:
              /*status info received with ss_active set to TRUE is considered as success */
              if(sups_info_ptr->ss_status.present && sups_info_ptr->ss_status.cm_ss_active)
              {
                bs_class = (uint32)list_info.sub.sups.ss_service_class;
                if(bs_class == 0)
                {
                  bs_class = (uint32)QMI_VOICE_CM_SUPS_CLASS_ALL;
                }
                get_call_barring_resp.service_class = (uint8) (bs_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
                get_call_barring_resp.service_class_ext = bs_class;
              }
              else
              {
                get_call_barring_resp.service_class = QMI_VOICE_SERVICE_CLASS_NONE;
                get_call_barring_resp.service_class_ext = QMI_VOICE_SERVICE_CLASS_NONE;
              }
              success = TRUE;
              if(sups_info_ptr->call_barring_num_info_list)
              {
                QM_MSG_MED_2("call_barring_num_info_list->present=%d, list_length=%d", sups_info_ptr->call_barring_num_info_list->present, sups_info_ptr->call_barring_num_info_list->list_length);
                if(sups_info_ptr->call_barring_num_info_list->present)
                {
                  get_call_barring_resp.sc_barr_num_list_valid = TRUE;
                  get_call_barring_resp.sc_barr_num_list_len = sups_info_ptr->call_barring_num_info_list->list_length;
                  /*Looping over list of service classes.*/
                  for(i = 0; (i < sups_info_ptr->call_barring_num_info_list->list_length) && (i < BASIC_SERV_GROUP_LIST_SIZE); i++)
                  {
                    QM_MSG_MED_2("call_barring_num_info_list->list[%d].call_barring_num_list_length = %d", i, sups_info_ptr->call_barring_num_info_list->list[i].call_barring_num_list_length);
                    if(sups_info_ptr->call_barring_num_info_list->list[i].call_barring_num_list_length > 0)
                    {
                      /*List of numbers for each service class.*/
                      get_call_barring_resp.sc_barr_num_list_info[i].barr_num_list_len = sups_info_ptr->call_barring_num_info_list->list[i].call_barring_num_list_length;
                      QM_MSG_MED_2("sups_info_ptr->call_barring_num_info_list->list[%d].basic_service.present=%d", i, sups_info_ptr->call_barring_num_info_list->list[i].basic_service.present);
                      if(sups_info_ptr->call_barring_num_info_list->list[i].basic_service.present)
                      {
                        get_call_barring_resp.sc_barr_num_list_info[i].barr_sc_ext = qmi_voice_cm_sups_get_service_class(sups_info_ptr->call_barring_num_info_list->list[i].basic_service.code_type,
                                                                                                                            sups_info_ptr->call_barring_num_info_list->list[i].basic_service.bs_code);
                        QM_MSG_MED_2("get_call_barring_resp.sc_barr_num_list_info[%d].barr_sc_ext = %d", i, get_call_barring_resp.sc_barr_num_list_info[i].barr_sc_ext);
                      }
                      get_call_barring_resp.sc_barr_num_list_info[i].barr_num_list_info = QMI_VOICE_CM_IF_MEM_ALLOC((sups_info_ptr->call_barring_num_info_list->list[i].call_barring_num_list_length) *\
                                                                                                                    sizeof(qmi_voice_cm_if_icb_sc_s));
                      memset(get_call_barring_resp.sc_barr_num_list_info[i].barr_num_list_info, 0, (sups_info_ptr->call_barring_num_info_list->list[i].call_barring_num_list_length) * sizeof(qmi_voice_cm_if_icb_sc_s));
                      if(!(get_call_barring_resp.sc_barr_num_list_info[i].barr_num_list_info))
                      {
						  qmi_voice_mem_error();
                        while(i>0)
                        {
                          QMI_VOICE_CM_IF_MEM_FREE(get_call_barring_resp.sc_barr_num_list_info[--i].barr_num_list_info); //Decrement index before freeing allocated memory.
                        }
                        get_call_barring_resp.error = QMI_ERR_NO_MEMORY;
                        success = FALSE;
                        break;
                      }
                      if(!qmi_voice_cm_util_copy_barr_num_list_info_from_cm_to_qmi(sups_info_ptr->call_barring_num_info_list->list[i].call_barring_num_info,
                                                                    get_call_barring_resp.sc_barr_num_list_info[i].barr_num_list_info,
                                                                    sups_info_ptr->call_barring_num_info_list->list[i].call_barring_num_list_length))
                      {
                        QM_MSG_HIGH_1("Unable to copy call_barring_num_info to barr_num_list_info for index %d", i);
                      }
                    }
                  }
                }
              }
              else
              {
                QM_MSG_HIGH("NULL received for call_barring_num_info_list");
              }
              break;

            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
              //Recieved Get call barring with Error confirmation type sups_info_ptr->conf_type is received
              get_call_barring_resp.error = QMI_ERR_SUPS_FAILURE_CAUSE;
              get_call_barring_resp.sups_failure_cause = qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              success = TRUE;
              break;

            default:
              //Invalid Get call barring confirmation type sups_info_ptr->conf_type is received
              get_call_barring_resp.error = QMI_ERR_INTERNAL;
              success = FALSE;
              break;
          }
          if(success)
          {
            qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&get_call_barring_resp, 
                                                                          sizeof(get_call_barring_resp), TRUE );
          }
          else
          {
            qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, get_call_barring_resp.error, TRUE, FALSE );
            return;
          }
        }
        break;

      case qmi_voice_cm_sups_cw:
      {
          voice_get_call_waiting_resp_msg_v02 get_call_waiting_resp;
          memset(&get_call_waiting_resp,0,sizeof(get_call_waiting_resp));
          get_call_waiting_resp.resp.error = QMI_ERR_NONE_V01;
          get_call_waiting_resp.alpha_id_valid = FALSE;
          memset(&get_call_waiting_resp.alpha_id,0,sizeof(get_call_waiting_resp.alpha_id));
          switch(sups_info_ptr->conf_type)
          {
            /* Success cases */
            case BSG_LIST_INFO:

              while(sups_info_ptr->bsg_list.list_length > count)
              {
               bsg_list_ptr = &sups_info_ptr->bsg_list.list[count];

               if(bsg_list_ptr->present)
               {
                 bs_class += qmi_voice_cm_sups_get_service_class(bsg_list_ptr->code_type,
                                                           bsg_list_ptr->bs_code);
               }
               count++;
              }

              get_call_waiting_resp.service_class_valid = TRUE;
              get_call_waiting_resp.service_class = (uint8) (bs_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
              get_call_waiting_resp.service_class_ext_valid = TRUE;
              get_call_waiting_resp.service_class_ext = (voice_service_class_enum_v02)bs_class;

              success = TRUE;
              break;

            case SS_STATUS_INFO:
              /*status info received with ss_active set to TRUE is considered as success */
              if(sups_info_ptr->ss_status.present && sups_info_ptr->ss_status.cm_ss_active)
              {
                bs_class = (uint32)list_info.sub.sups.ss_service_class;
                if(bs_class == 0)
                {
                  bs_class = (uint32)QMI_VOICE_CM_SUPS_CLASS_ALL;
                }
                get_call_waiting_resp.service_class_valid = TRUE;
                get_call_waiting_resp.service_class = (uint8) (bs_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
                get_call_waiting_resp.service_class_ext_valid = TRUE;
                get_call_waiting_resp.service_class_ext = (voice_service_class_enum_v02)bs_class;
              }
              else
              {
                get_call_waiting_resp.service_class_valid = TRUE;
                get_call_waiting_resp.service_class = QMI_VOICE_SERVICE_CLASS_NONE;
                get_call_waiting_resp.service_class_ext_valid = TRUE;
                get_call_waiting_resp.service_class_ext = QMI_VOICE_SERVICE_CLASS_NONE;
              }
              success = TRUE;
              break;

            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
              QM_MSG_ERROR_1("Recieved Get call waiting with Error confirmation type = %d is received", sups_info_ptr->conf_type);
              get_call_waiting_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              get_call_waiting_resp.resp.result = QMI_RESULT_FAILURE_V01;
              get_call_waiting_resp.failure_cause_valid = TRUE;
              get_call_waiting_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                get_call_waiting_resp.retry_duration_valid = TRUE;
                get_call_waiting_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;
            default:
              QM_MSG_ERROR_1("Invalid Get call waiting confirmation type = %d is received", sups_info_ptr->conf_type);
              get_call_waiting_resp.failure_cause_valid = TRUE;
              get_call_waiting_resp.failure_cause = QMI_FAILURE_CAUSE_INTERNAL_ERROR_V02;
              success = FALSE;
              break;
          }
          if(success)
          {
            qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&get_call_waiting_resp, 
                                                                          sizeof(get_call_waiting_resp), TRUE );
          }
          else
          {
            qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, get_call_waiting_resp.resp.error, TRUE, FALSE );
            return;
          }
        }
      break;
      case qmi_voice_cm_sups_clip:
        {
          voice_get_clip_resp_msg_v02 get_clip_resp;
          memset(&get_clip_resp,0,sizeof(get_clip_resp));
          switch(sups_info_ptr->conf_type)
          {
            case SS_STATUS_INFO:
              if(sups_info_ptr->ss_status.present)
              {
                get_clip_resp.clip_response_valid = TRUE;
                if(sups_info_ptr->ss_status.cm_ss_active == TRUE)
                {
                  get_clip_resp.clip_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                }
                if(sups_info_ptr->ss_status.cm_ss_provisioned == TRUE)
                {
                  get_clip_resp.clip_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
                }
              }
              success = TRUE;
              QM_MSG_MED_3("CLIP: clip_response_valid=%d, active_status=%d, provision_status=%d", get_clip_resp.clip_response_valid, get_clip_resp.clip_response.active_status, get_clip_resp.clip_response.provision_status);
              break;
              
           case CLI_RESTRICTION_INFO:
	      QM_MSG_MED_4("CLIP:cli_restrict present = %d,cm_ss_present =%d, Status active = %d, provisioned =%d", sups_info_ptr->cli_restriction.present, sups_info_ptr->cli_restriction.cm_ss_status.present,
			   	sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active, sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned);


              if(sups_info_ptr->cli_restriction.present)
              {
                get_clip_resp.clip_response_valid = TRUE;
                if(sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE)
                {
                  get_clip_resp.clip_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                }
                if(sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE)
                {
                  get_clip_resp.clip_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
                }
              }
              success = TRUE;
              QM_MSG_MED_3("CLIP: clip_response_valid=%d, active_status=%d, provision_status=%d", get_clip_resp.clip_response_valid, get_clip_resp.clip_response.active_status, get_clip_resp.clip_response.provision_status);
              break;

            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
             QM_MSG_ERROR_1("Recieved Get CLIP with Error confirmation type  = %d is received", sups_info_ptr->conf_type);
             if ( sups_info_ptr->retry_duration > 0 )
             {
                get_clip_resp.retry_duration_valid = TRUE;
               get_clip_resp.retry_duration = sups_info_ptr->retry_duration;
             }
              get_clip_resp.resp.result = QMI_RESULT_FAILURE_V01;
              get_clip_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              get_clip_resp.failure_cause_valid = TRUE;
              get_clip_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
             success = TRUE;
             break;

            default:
             QM_MSG_ERROR_1("Invalid confirmation type for CLIP = %d is received", sups_info_ptr->conf_type);
             get_clip_resp.resp.result = QMI_RESULT_FAILURE_V01;
             get_clip_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
          }

          if(success)
          {
            qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&get_clip_resp, 
                                                                          sizeof(get_clip_resp), TRUE );
          }
          else
          {
            qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, QMI_ERR_INTERNAL, TRUE, FALSE );
            return;
          }
        }
        break;

      case qmi_voice_cm_sups_clir:
        {
          voice_get_clir_resp_msg_v02 get_clir_resp;
          memset(&get_clir_resp,0,sizeof(get_clir_resp));
          switch(sups_info_ptr->conf_type)
          {
            case SS_STATUS_INFO:
              if(sups_info_ptr->ss_status.present)
              {
                get_clir_resp.clir_response_valid = TRUE;
                if(sups_info_ptr->ss_status.cm_ss_active == TRUE)
                {
                  get_clir_resp.clir_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                }
                if(sups_info_ptr->ss_status.cm_ss_provisioned == TRUE)
                {
                  get_clir_resp.clir_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
                }                
                }
              success = TRUE;
              break;

            case FWD_FEATURE_LIST_INFO:
              if (!sups_info_ptr->fwd_feature_list.present)
              {
                QM_MSG_ERROR("Fowarding feature list info missing");
                break;
              }

              count = 0;
              //Loop through the feature forwarding list 
              while (sups_info_ptr->fwd_feature_list.forwarding_feature_list_length > count)
              {
                const forwarding_feature_T * fflist_ptr = &sups_info_ptr->fwd_feature_list.forwarding_feature[count];
                //Check if ss status is present and set response accordingly
                if(fflist_ptr->ss_status.present)
                {
                  get_clir_resp.clir_response_valid = TRUE;
                  QM_MSG_MED_2("ss_status is present and status is active=%d,provisioned=%d", fflist_ptr->ss_status.cm_ss_active, fflist_ptr->ss_status.cm_ss_provisioned);
                  if(fflist_ptr->ss_status.cm_ss_active == TRUE)
                  {
                    get_clir_resp.clir_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                  }
                  if(fflist_ptr->ss_status.cm_ss_provisioned == TRUE)
                  {
                    get_clir_resp.clir_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
                  }                  
                  break;
                }
                count++;
              }
              success = TRUE;
              break;

            case CLI_RESTRICTION_INFO:
             cli_restriction_info = &sups_info_ptr->cli_restriction;

             if(cli_restriction_info->present == TRUE)
             {
               if(cli_restriction_info->cm_cli_restriction_option.present == TRUE)
               {
                 QM_MSG_MED_1("GET_CLIR CONF with option = %d", cli_restriction_info->cm_cli_restriction_option.option);
                 get_clir_resp.clir_response_valid = TRUE;
                 switch(cli_restriction_info->cm_cli_restriction_option.option)
                 {
                   case CLI_DEFAULT_OPTION:
                     /* This maps to Permanent CLIR provisioning */
                     get_clir_resp.clir_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
                     get_clir_resp.clir_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                     break;

                   case CLI_RESTRICT_OPTION:
                     /* This maps to default CLIR ON and can be overidden */
                     get_clir_resp.clir_response.provision_status = PROVISION_STATUS_PRESENTATION_RESTRICTED_V02;
                     get_clir_resp.clir_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                     break;

                   case CLI_OVERRIDE_OPTION:
                     /* This maps to CLIR default - requires explicit CLIR status to be used
                        during call setup */
                     get_clir_resp.clir_response.provision_status = PROVISION_STATUS_PRESENTATION_ALLOWED_V02;
                     get_clir_resp.clir_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                     break;

                   case CLI_UNKNOWN_OPTION:
                     break;

                   default:
                     /* Ideally filtered by CM and should not be received */
                     /* Map it to non provisioned status */
                     break;
                 }
               }
             }

             success = TRUE;
             break;

            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
              get_clir_resp.resp.result = QMI_RESULT_FAILURE_V01;
              get_clir_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              get_clir_resp.failure_cause_valid = TRUE;
              get_clir_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              QM_MSG_ERROR_2("Get CLIR CONF with Error conf= %d,cause=%d", sups_info_ptr->conf_type, get_clir_resp.failure_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                get_clir_resp.retry_duration_valid = TRUE;
                get_clir_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

            default:
              QM_MSG_ERROR_1("Invalid confirmation type for CLIR = %d is received", sups_info_ptr->conf_type);
              get_clir_resp.resp.result = QMI_RESULT_FAILURE_V01;
              get_clir_resp.resp.error = QMI_ERR_INTERNAL_V01;
              success = FALSE;
              break;
          }

          if(success)
          {
            qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&get_clir_resp, sizeof(get_clir_resp), TRUE );
          }
          else
          {
            qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, get_clir_resp.resp.error, TRUE, FALSE );
          }
        }
        break;
      case qmi_voice_cm_sups_colp:
        {
          voice_get_colp_resp_msg_v02 get_colp_resp;
          memset(&get_colp_resp,0,sizeof(get_colp_resp));
          switch(sups_info_ptr->conf_type)
          {
            case SS_STATUS_INFO:
              if(sups_info_ptr->ss_status.present)
              {
                get_colp_resp.colp_response_valid = TRUE;
                if(sups_info_ptr->ss_status.cm_ss_active == TRUE )
                {
                  get_colp_resp.colp_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                }
                if(sups_info_ptr->ss_status.cm_ss_provisioned == TRUE)
                {
                  get_colp_resp.colp_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
              }
              }
              success = TRUE;
              QM_MSG_MED_2("COLP : active_status=%d, provision_status=%d", get_colp_resp.colp_response.active_status, get_colp_resp.colp_response.provision_status);
            break;
            
            case CLI_RESTRICTION_INFO:
				QM_MSG_MED_4("COLP:cli_restrict present = %d,cm_ss_present =%d, Status active = %d, provisioned =%d", sups_info_ptr->cli_restriction.present, sups_info_ptr->cli_restriction.cm_ss_status.present,
					sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active, sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned);
              if(sups_info_ptr->cli_restriction.present)
              {
                get_colp_resp.colp_response_valid = TRUE;
                if(sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE )
                {
                  get_colp_resp.colp_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                }
                if(sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE)
                {
                  get_colp_resp.colp_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
              }
              }
              success = TRUE;
              QM_MSG_MED_2("COLP :  active_status = %d,provision_status =%d", get_colp_resp.colp_response.active_status, get_colp_resp.colp_response.provision_status);
            break;
            
            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
              QM_MSG_ERROR_1("Recieved Get COLP with Error confirmation type  = %d is received", sups_info_ptr->conf_type);
              get_colp_resp.resp.result = QMI_RESULT_FAILURE_V01;
              get_colp_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              get_colp_resp.failure_cause_valid = TRUE;
              get_colp_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                get_colp_resp.retry_duration_valid = TRUE;
                get_colp_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
            break;
            default:
              QM_MSG_ERROR_1("Invalid confirmation type for COLP = %d is received", sups_info_ptr->conf_type);
              get_colp_resp.resp.result = QMI_RESULT_FAILURE_V01;
              get_colp_resp.resp.error = QMI_ERR_INTERNAL_V01;
              success = FALSE;
              break;
          }
          if(success)
          {
            qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&get_colp_resp, sizeof(get_colp_resp), TRUE );
          }
          else
          {
            qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, QMI_ERR_INTERNAL, TRUE, FALSE );
            return;
          }
        }
        break;

      case qmi_voice_cm_sups_allForwardingSS:
      case qmi_voice_cm_sups_allCondForwardingSS:
      case qmi_voice_cm_sups_cfb:
      case qmi_voice_cm_sups_cfnry:
      case qmi_voice_cm_sups_cfnrc:
      case qmi_voice_cm_sups_cfu:
        {
          voice_get_call_forwarding_resp_msg_v02 *get_call_fwd_resp;
          get_call_fwd_resp = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*get_call_fwd_resp));
          if(NULL == get_call_fwd_resp)
          {
			  qmi_voice_mem_fatal();
            return;
          }
          memset((void*)get_call_fwd_resp, 0, sizeof(*get_call_fwd_resp));

          switch(sups_info_ptr->conf_type)
          {
            case SS_STATUS_INFO:
               if(sups_info_ptr->ss_status.present && sups_info_ptr->ss_status.cm_ss_active)
               {
                get_call_fwd_resp->get_call_forwarding_info[0].service_status = SERVICE_STATUS_ACTIVE_V02;
                get_call_fwd_resp->get_call_forwarding_exten_info[0].service_status = SERVICE_STATUS_ACTIVE_V02;
                get_call_fwd_resp->get_call_forwarding_exten2_info[0].service_status = SERVICE_STATUS_ACTIVE_V02;
               }

              get_call_fwd_resp->provision_status_valid = TRUE;
              get_call_fwd_resp->provision_status = (provision_status_enum_v02)sups_info_ptr->ss_status.cm_ss_provisioned;

              get_call_fwd_resp->get_call_forwarding_info[0].service_class = QMI_VOICE_CM_SUPS_CLASS_ALL;
              get_call_fwd_resp->get_call_forwarding_exten_info[0].service_class = QMI_VOICE_CM_SUPS_CLASS_ALL;
              get_call_fwd_resp->get_call_forwarding_exten2_info[0].service_class_ext = (voice_service_class_enum_v02)QMI_VOICE_CM_SUPS_CLASS_ALL;
               /* if call forwarding is interrogated for specific service class,
                  include only that service class in response */                  			 
               if(ss_list_info->ss_service_class != 0)
               {
                get_call_fwd_resp->get_call_forwarding_info[0].service_class = (uint8) (ss_list_info->ss_service_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
                get_call_fwd_resp->get_call_forwarding_exten_info[0].service_class = (uint8) (ss_list_info->ss_service_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
                get_call_fwd_resp->get_call_forwarding_exten2_info[0].service_class_ext = ss_list_info->ss_service_class;
               }
               else
               {
                get_call_fwd_resp->get_call_forwarding_info[0].service_class = QMI_VOICE_CM_SUPS_CLASS_ALL;
                get_call_fwd_resp->get_call_forwarding_exten_info[0].service_class = QMI_VOICE_CM_SUPS_CLASS_ALL;         
                get_call_fwd_resp->get_call_forwarding_exten2_info[0].service_class_ext = (voice_service_class_enum_v02)QMI_VOICE_CM_SUPS_CLASS_ALL;
               }     

               if ( sups_info_ptr->sups_time_info.time_present == TRUE )
               {
                memset(&dest_time_info, 0, sizeof(dest_time_info));
                if( E_SUCCESS == qmi_voice_cm_sups_set_time_info(sups_info_ptr->sups_time_info.call_fwd_start_time, &dest_time_info) )
                 {
                  get_call_fwd_resp->call_fwd_start_time_valid     = TRUE;
                  get_call_fwd_resp->call_fwd_start_time.year      = dest_time_info.year;
                  get_call_fwd_resp->call_fwd_start_time.month     = dest_time_info.month;
                  get_call_fwd_resp->call_fwd_start_time.day       = dest_time_info.day;
                  get_call_fwd_resp->call_fwd_start_time.hour      = dest_time_info.hour;
                  get_call_fwd_resp->call_fwd_start_time.minute    = dest_time_info.minute;
                  get_call_fwd_resp->call_fwd_start_time.second    = dest_time_info.second;
                  get_call_fwd_resp->call_fwd_start_time.time_zone = dest_time_info.time_zone;
                 }
                 else
                 {
                   QM_MSG_HIGH("No valid call fwd start time info");
                 }

                memset(&dest_time_info, 0, sizeof(dest_time_info));
                if( E_SUCCESS == qmi_voice_cm_sups_set_time_info(sups_info_ptr->sups_time_info.call_fwd_end_time, &dest_time_info) )
                 {
                  get_call_fwd_resp->call_fwd_end_time_valid       = TRUE;
                  get_call_fwd_resp->call_fwd_end_time.year        = dest_time_info.year;
                  get_call_fwd_resp->call_fwd_end_time.month       = dest_time_info.month;
                  get_call_fwd_resp->call_fwd_end_time.day         = dest_time_info.day;
                  get_call_fwd_resp->call_fwd_end_time.hour        = dest_time_info.hour;
                  get_call_fwd_resp->call_fwd_end_time.minute      = dest_time_info.minute;
                  get_call_fwd_resp->call_fwd_end_time.second      = dest_time_info.second;
                  get_call_fwd_resp->call_fwd_end_time.time_zone   = dest_time_info.time_zone;
                 }
                 else
                 {
                   QM_MSG_HIGH("No valid call fwd end time info");
                 }
               }
              get_call_fwd_resp->get_call_forwarding_info_valid = TRUE;
              get_call_fwd_resp->get_call_forwarding_exten_info_valid = TRUE;
              get_call_fwd_resp->get_call_forwarding_exten2_info_valid = TRUE;

              get_call_fwd_resp->get_call_forwarding_info_len = 1;
              get_call_fwd_resp->get_call_forwarding_exten_info_len = 1;
              get_call_fwd_resp->get_call_forwarding_exten2_info_len = 1;
               success = TRUE;
              break;

            case FWD_FEATURE_LIST_INFO:

              if (!sups_info_ptr->fwd_feature_list.present)
              {
                QM_MSG_ERROR("Fowarding feature list info missing ");
                break;
              }

              /* Report for each forwarding registration */
              count = 0;
              count_sc = 0;
              if(sups_info_ptr->fwd_feature_list.forwarding_feature[0].ss_status.present) 
              { 
                get_call_fwd_resp->provision_status_valid = TRUE;
                get_call_fwd_resp->provision_status = \
                sups_info_ptr->fwd_feature_list.forwarding_feature[0].ss_status.cm_ss_provisioned; 
              } 
              else 
              { 
                QM_MSG_ERROR("Fowarding feature list provision_status is missing "); 
              }
              while (sups_info_ptr->fwd_feature_list.forwarding_feature_list_length > count)
              {
                const forwarding_feature_T * fflist_ptr =
                  &sups_info_ptr->fwd_feature_list.forwarding_feature[count];

                uint8 j = 0;
                uint32 service_class = 0;
                int no_reply_timer = 0;
                boolean fwd_num_present = FALSE;
                /* Size temp buffer for address, subaddress, and various other characters */
              #define MAX_CCFC_ADDRESS_SIZE (2 * CM_CALLED_PARTY_BCD_NO_LENGTH * \
                                                   (2*MAXNO_FORWARD_TO_NUMBER))
                byte address[MAX_CCFC_ADDRESS_SIZE];
                byte buffer[MAX_CCFC_ADDRESS_SIZE];
                byte * a_ptr = &address[1];
                uint8 a_length = 0;
                cm_num_s_type conv_cfw_num;
                byte * s_ptr = buffer;
                
                status = 0;
                memset((void*)buffer, 0, sizeof(buffer));
                memset((void*)address, 0, sizeof(address));
                memset(&conv_cfw_num,0,sizeof(cm_num_s_type));

                status = ((fflist_ptr->ss_status.present &&
                           fflist_ptr->ss_status.cm_ss_active)? QMI_VOICE_CM_SUPS_STATUS_ACTIVE : QMI_VOICE_CM_SUPS_STATUS_IN_ACTIVE);

                QM_MSG_HIGH_2("Stored Service class = %d, Basic service present =%d", ss_list_info->ss_service_class, fflist_ptr->basic_service.present);

                if(!fflist_ptr->basic_service.present && (ss_list_info->ss_service_class == 0))
                {
                  service_class = QMI_VOICE_CM_SUPS_CLASS_ALL;
                }
                else if(!fflist_ptr->basic_service.present && (ss_list_info->ss_service_class != 0))
                {
                  service_class = ss_list_info->ss_service_class;
                }
                else
                {
                  service_class = qmi_voice_cm_sups_get_service_class(fflist_ptr->basic_service.code_type,
                                                               fflist_ptr->basic_service.bs_code);
                }

                /* Decode  number */
                /* though it has been written to handle multiple call forward to number
                   as of now we are not aware of such scenario where multiple call forward
                   to number is sent by network */

                while ( j < (2*MAXNO_FORWARD_TO_NUMBER) )
                {
                   /* Check for availability */
                   if (fflist_ptr->forwarded_to_number[j].present)
                   {
                     uint8 k;
                      fwd_num_present = TRUE;
                     /* Append number segment to existing buffer */
                      for (k=0; k < fflist_ptr->forwarded_to_number[j].length; k++)
                      {
                         *a_ptr++ = fflist_ptr->forwarded_to_number[j].data[k];
                      }
                      a_length += fflist_ptr->forwarded_to_number[j].length;

                      qmi_voice_cm_util_get_num_info_from_bcd_num(&conv_cfw_num,(cm_called_party_bcd_no_s_type *)&fflist_ptr->forwarded_to_number[j]) ;
                      
                   }
                   j++;
                }
                address[0] = a_length;

                /* Convert from BCD to ASCII string */
                if (a_ptr != &address[1])
                {
                  (void)cm_util_bcd_num_to_ascii_num(address, s_ptr, sizeof(buffer));

                   /* removing the first charecter which indicates type*/
                   s_ptr = s_ptr + 1;
                }


                /* Decode timer */
                if (fflist_ptr->no_reply_condition_timer.present)
                {
                  no_reply_timer = fflist_ptr->no_reply_condition_timer.timer_value;
                }

                get_call_fwd_resp->get_call_forwarding_info[count_sc].service_status = status;
                get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].service_status = status;
                get_call_fwd_resp->get_call_forwarding_exten2_info[count].service_status = status;
				
                get_call_fwd_resp->get_call_forwarding_info[count_sc].no_reply_timer = no_reply_timer;
                get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].no_reply_timer = no_reply_timer;
                get_call_fwd_resp->get_call_forwarding_exten2_info[count].no_reply_timer = no_reply_timer;  

                get_call_fwd_resp->get_call_forwarding_info[count_sc].service_class = (uint8) (service_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
                get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].service_class = (uint8) (service_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
                get_call_fwd_resp->get_call_forwarding_exten2_info[count].service_class_ext = service_class;

                if(fwd_num_present)
                {
                  get_call_fwd_resp->get_call_forwarding_info[count_sc].number_len = strlen((char*)s_ptr)+1;
                  get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].cfw_num_info.num_len = strlen((char*)s_ptr)+1;
                  get_call_fwd_resp->get_call_forwarding_exten2_info[count].cfw_num_info.num_len = strlen((char*)s_ptr)+1;

                  if(get_call_fwd_resp->get_call_forwarding_info[count].number_len < QMI_VOICE_CM_IF_MAX_CALLING_NUM_LEN )
                  {
                    memscpy(get_call_fwd_resp->get_call_forwarding_info[count_sc].number, 
                            sizeof(get_call_fwd_resp->get_call_forwarding_info[count_sc].number),
                            buffer, get_call_fwd_resp->get_call_forwarding_info[count_sc].number_len);
                    memscpy(get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].cfw_num_info.num, 
                            sizeof(get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].cfw_num_info.num),
                            buffer, get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].cfw_num_info.num_len);
                    memscpy(get_call_fwd_resp->get_call_forwarding_exten2_info[count].cfw_num_info.num, 
                            sizeof(get_call_fwd_resp->get_call_forwarding_exten2_info[count].cfw_num_info.num),
                            buffer, get_call_fwd_resp->get_call_forwarding_exten2_info[count].cfw_num_info.num_len);
                  }
                  get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].cfw_num_info.num_plan = conv_cfw_num.number_plan;
                  get_call_fwd_resp->get_call_forwarding_exten2_info[count].cfw_num_info.num_plan = conv_cfw_num.number_plan;

                  get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].cfw_num_info.num_type = conv_cfw_num.number_type;
                  get_call_fwd_resp->get_call_forwarding_exten2_info[count].cfw_num_info.num_type = conv_cfw_num.number_type;

                  get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].cfw_num_info.pi = conv_cfw_num.pi;
                  get_call_fwd_resp->get_call_forwarding_exten2_info[count].cfw_num_info.pi = conv_cfw_num.pi;

                  get_call_fwd_resp->get_call_forwarding_exten_info[count_sc].cfw_num_info.si = conv_cfw_num.si;
                  get_call_fwd_resp->get_call_forwarding_exten2_info[count].cfw_num_info.si = conv_cfw_num.si;

                }
                count++;
                if((service_class < QMI_VOICE_CM_SUPS_CLASS_ALL) || 
                  ((service_class == QMI_VOICE_CM_SUPS_CLASS_ALL) && (count_sc == 0) ))
                {
                  count_sc++;
                }
              } /* for each fwding registration */

              if ( sups_info_ptr->sups_time_info.time_present == TRUE )
              {
                memset(&dest_time_info, 0, sizeof(dest_time_info));
                if ( E_SUCCESS == qmi_voice_cm_sups_set_time_info(sups_info_ptr->sups_time_info.call_fwd_start_time ,&dest_time_info) )
                {
                  get_call_fwd_resp->call_fwd_start_time_valid     = TRUE;
                  get_call_fwd_resp->call_fwd_start_time.year      = dest_time_info.year;
                  get_call_fwd_resp->call_fwd_start_time.month     = dest_time_info.month;
                  get_call_fwd_resp->call_fwd_start_time.day       = dest_time_info.day;
                  get_call_fwd_resp->call_fwd_start_time.hour      = dest_time_info.hour;
                  get_call_fwd_resp->call_fwd_start_time.minute    = dest_time_info.minute;
                  get_call_fwd_resp->call_fwd_start_time.second    = dest_time_info.second;
                  get_call_fwd_resp->call_fwd_start_time.time_zone = dest_time_info.time_zone;
                }
                else
                {
                  QM_MSG_HIGH("No valid call fwd start time info");
                }

                memset(&dest_time_info, 0, sizeof(dest_time_info));
                if ( E_SUCCESS == qmi_voice_cm_sups_set_time_info(sups_info_ptr->sups_time_info.call_fwd_end_time ,&dest_time_info) )
                {
                  get_call_fwd_resp->call_fwd_end_time_valid = TRUE;
                  get_call_fwd_resp->call_fwd_end_time.year        = dest_time_info.year;
                  get_call_fwd_resp->call_fwd_end_time.month       = dest_time_info.month;
                  get_call_fwd_resp->call_fwd_end_time.day         = dest_time_info.day;
                  get_call_fwd_resp->call_fwd_end_time.hour        = dest_time_info.hour;
                  get_call_fwd_resp->call_fwd_end_time.minute      = dest_time_info.minute;
                  get_call_fwd_resp->call_fwd_end_time.second      = dest_time_info.second;
                  get_call_fwd_resp->call_fwd_end_time.time_zone   = dest_time_info.time_zone;
                }
                else
                {
                  QM_MSG_HIGH("No valid call fwd end time info");
                }
              }

              get_call_fwd_resp->get_call_forwarding_info_valid = TRUE;
              get_call_fwd_resp->get_call_forwarding_exten_info_valid = TRUE;
              get_call_fwd_resp->get_call_forwarding_exten2_info_valid = TRUE;
              
              get_call_fwd_resp->get_call_forwarding_info_len = count_sc;
              get_call_fwd_resp->get_call_forwarding_exten_info_len = count_sc;
              get_call_fwd_resp->get_call_forwarding_exten2_info_len = count;
              QM_MSG_MED_1("Number of instances = %d", count);
              success = TRUE;
              break;

            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
              QM_MSG_ERROR_1("Recieved Get CALL FORWARDING with Error confirmation type  = %d", sups_info_ptr->conf_type);
              get_call_fwd_resp->resp.result = QMI_RESULT_FAILURE_V01;
              get_call_fwd_resp->resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              get_call_fwd_resp->failure_cause_valid = TRUE;
              get_call_fwd_resp->failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                get_call_fwd_resp->retry_duration_valid = TRUE;
                get_call_fwd_resp->retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

            default:
              QM_MSG_MED_1("Entered the default case for call forwarding conf type = %d", sups_info_ptr->conf_type);
              get_call_fwd_resp->resp.result = QMI_RESULT_FAILURE_V01;
              get_call_fwd_resp->resp.error = QMI_ERR_INTERNAL_V01;
              success = FALSE;
              break;
          }
          if(success)
          {
            qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)get_call_fwd_resp, sizeof(*get_call_fwd_resp), TRUE );
          }
          else
          {
            qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, get_call_fwd_resp->resp.error, TRUE, FALSE );
          }

          if(NULL != get_call_fwd_resp)
          {
            QM_MSG_MED("Freeing memory for get_call_fwd_resp");
            QMI_VOICE_CM_IF_MEM_FREE(get_call_fwd_resp);
          }
  
        }
        break;

	case qmi_voice_cm_sups_colr:
        {
          voice_get_colr_resp_msg_v02 get_colr_resp;
          memset(&get_colr_resp,0,sizeof(get_colr_resp));
          switch(sups_info_ptr->conf_type)
          {
            case SS_STATUS_INFO:
              if(sups_info_ptr->ss_status.present)
              {
                get_colr_resp.colr_response_valid = TRUE;
                if(sups_info_ptr->ss_status.cm_ss_active == TRUE)
                {
                  get_colr_resp.colr_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                }
                if(sups_info_ptr->ss_status.cm_ss_provisioned == TRUE)
                {
                  get_colr_resp.colr_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
                }
              }
              QM_MSG_MED_1("Get COLR: pi = %d", sups_info_ptr->pi);
              if(sups_info_ptr->pi == 0x0 || sups_info_ptr->pi == 0x1)
              {
                get_colr_resp.colr_pi_valid = TRUE;
                get_colr_resp.colr_pi = (pi_colr_enum_v02)sups_info_ptr->pi;
              }
              success = TRUE;
              QM_MSG_MED_2("COLR :  active_status = %d,provision_status =%d", get_colr_resp.colr_response.active_status, get_colr_resp.colr_response.provision_status);
              break;
      
            case CLI_RESTRICTION_INFO:
              QM_MSG_MED_4("COLR:cli_restrict present = %d,cm_ss_present = %d, Status active = %d, provisioned = %d",
                           sups_info_ptr->cli_restriction.present,
                           sups_info_ptr->cli_restriction.cm_ss_status.present,
                           sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active,
                           sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned);
              if(sups_info_ptr->cli_restriction.present)
              {
                get_colr_resp.colr_response_valid = TRUE;
                if(sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE)
                {
                  get_colr_resp.colr_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                }
                if(sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE)
                {
                  get_colr_resp.colr_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
                }
              }

              QM_MSG_MED_1("Get COLR: pi = %d", sups_info_ptr->pi);
              if(sups_info_ptr->pi == 0x0 || sups_info_ptr->pi == 0x1)
              {
                get_colr_resp.colr_pi_valid = TRUE;
                get_colr_resp.colr_pi = (pi_colr_enum_v02)sups_info_ptr->pi;
              }
              success = TRUE;
              QM_MSG_MED_2("COLR :  active_status = %d,provision_status =%d", get_colr_resp.colr_response.active_status, get_colr_resp.colr_response.provision_status);
              break;
              
            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
             QM_MSG_ERROR_1("Recieved Get COLR with Error confirmation type  = %d is received", sups_info_ptr->conf_type);
              get_colr_resp.resp.result = QMI_RESULT_FAILURE_V01;
              get_colr_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              get_colr_resp.failure_cause_valid = TRUE;
              get_colr_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
             if ( sups_info_ptr->retry_duration > 0 )
             {
                get_colr_resp.retry_duration_valid = TRUE;
               get_colr_resp.retry_duration = sups_info_ptr->retry_duration;
             }
             success = TRUE;
             break;
      
            default:
             QM_MSG_ERROR_1("Invalid confirmation type for COLR = %d is received", sups_info_ptr->conf_type);
              get_colr_resp.resp.result = QMI_RESULT_FAILURE_V01;
              get_colr_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
          }
          if(success)
          {
            qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&get_colr_resp, sizeof(get_colr_resp), TRUE );
          }
          else
          {
            qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, QMI_ERR_INTERNAL, TRUE, FALSE );
            return;
          }
        }
        break;
    case qmi_voice_cm_sups_cnap:
    {
          voice_get_cnap_resp_msg_v02 get_cnap_resp;
      memset(&get_cnap_resp,0,sizeof(get_cnap_resp));
      switch(sups_info_ptr->conf_type)
      {
	    case SS_STATUS_INFO:
	      if(sups_info_ptr->ss_status.present)
	      {
                get_cnap_resp.cnap_response_valid = TRUE;
                if(sups_info_ptr->ss_status.cm_ss_active == TRUE)
		    {
                  get_cnap_resp.cnap_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
		    }
                if(sups_info_ptr->ss_status.cm_ss_provisioned == TRUE)
		    {
                  get_cnap_resp.cnap_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
	      }
	      }
	      success = TRUE;
              QM_MSG_MED_2("CNAP: active_status=%d, provision_status=%d", get_cnap_resp.cnap_response.active_status, get_cnap_resp.cnap_response.provision_status);
	      break;	  
            case CLI_RESTRICTION_INFO:
              QM_MSG_MED_4("CNAP:cli_restrict present = %d, cm_ss_present = %d, Status active = %d, provisioned = %d",
                           sups_info_ptr->cli_restriction.present,
                           sups_info_ptr->cli_restriction.cm_ss_status.present,
                           sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active,
                           sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned);
              if(sups_info_ptr->cli_restriction.present)
              {
                get_cnap_resp.cnap_response_valid = TRUE;
                if(sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE)
                {
                  get_cnap_resp.cnap_response.active_status = ACTIVE_STATUS_ACTIVE_V02;
                }
                if(sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE)
                {
                  get_cnap_resp.cnap_response.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
                }
              }
              success = TRUE;
              QM_MSG_MED_2("CNAP: active_status=%d, provision_status=%d", get_cnap_resp.cnap_response.active_status, get_cnap_resp.cnap_response.provision_status);
              break;                    
	      case CC_CAUSE_INFO:
	      case SS_ERROR_INFO:
	       QM_MSG_ERROR_1("Recieved Get CNAP with Error confirmation type  = %d is received", sups_info_ptr->conf_type);
              get_cnap_resp.resp.result = QMI_RESULT_FAILURE_V01;
              get_cnap_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              get_cnap_resp.failure_cause_valid = TRUE;
              get_cnap_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
               if ( sups_info_ptr->retry_duration > 0 )
               {
                get_cnap_resp.retry_duration_valid = TRUE;
                 get_cnap_resp.retry_duration = sups_info_ptr->retry_duration;
               }
	       success = TRUE;
	       break;
	      default:
	       QM_MSG_ERROR_1("Invalid confirmation type for CNAP = %d is received", sups_info_ptr->conf_type);
              get_cnap_resp.resp.result = QMI_RESULT_FAILURE_V01;
              get_cnap_resp.resp.error = QMI_ERR_INTERNAL_V01;
	       success = FALSE;
	       break;
	}
	if(success)
	{
            qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&get_cnap_resp, sizeof(get_cnap_resp), TRUE );
	}
	else
	{
            qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, QMI_ERR_INTERNAL, TRUE, FALSE );
	      return;
	}
      }
      break;
      default:
        break;
    }
  }
  else
  {
    QM_MSG_ERROR("Rejected from protocol layer");
    qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, QMI_ERR_INTERNAL, TRUE, FALSE );
  }
} /* qmi_voice_cm_if_sups_event_interrogate_conf() */



/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_EVENT_REG_PASSWORD_CONF()

  DESCRIPTION
    Sups Password conf sent by CM is handled here.
    In response to QMI_VOICE_SET_CALL_BARRING_PASSWORD
  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_event_reg_password_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
)
{
  qmi_voice_cmd_list_public_type list_info;
  voice_set_call_barring_password_resp_msg_v02 set_call_barring_resp;
  boolean success=FALSE;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  /*-----------------------------------------------------------------------*/

  ASSERT( sups_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)sups_info_ptr->asubs_id;
#endif

  QM_MSG_MED_2( "%s ss_ref= %d", "qmi_voice_cm_if_sups_event_reg_password_conf ",sups_info_ptr->ss_ref);
  memset(&set_call_barring_resp,0,sizeof(set_call_barring_resp));
  QM_MSG_MED_1("Sups info retry duration = %d", sups_info_ptr->retry_duration);
  if( qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)QMI_VOICE_CM_IF_EVT_SUPS_REG_PASSWORD_CONF,
                                              sups_info_ptr->ss_ref,
                                              &list_info, as_id) != E_SUCCESS )
  {
    QM_MSG_ERROR("None of entry is waiting for QMI_VOICE_CM_IF_EVT_SUPS_REG_PASSWORD_CONF ");
    return;
  }
  else if(sups_info_ptr->ss_success)
  {
    QM_MSG_MED_1("Sups info success = %d", sups_info_ptr->ss_success);
    switch(list_info.sub.sups.ss_code)
    {
      case qmi_voice_cm_sups_baoc:
      case qmi_voice_cm_sups_boic:
      case qmi_voice_cm_sups_boicExHC:
      case qmi_voice_cm_sups_baic:
      case qmi_voice_cm_sups_bicRoam:
      case qmi_voice_cm_sups_allCallRestrictionSS:
      case qmi_voice_cm_sups_barringOfOutgoingCalls:
      case qmi_voice_cm_sups_barringOfIncomingCalls:  
	  	QM_MSG_MED_1("SupS confirmation:  %d ", sups_info_ptr->conf_type);
         switch(sups_info_ptr->conf_type)
         {
           /* Success cases */
           case NEW_PWD_INFO:
             //If conf_type=11:NEW_PWD_INFO SupS confirmation successful
             success = TRUE;
             break;

           case CC_CAUSE_INFO:    /* Lower layer failure in protocol stack */
             //If conf_type=16:CC_CAUSE_INFO => Rejected from protocol layer
            set_call_barring_resp.resp.result = QMI_RESULT_FAILURE_V01;
            set_call_barring_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
            set_call_barring_resp.failure_cause_valid = TRUE;
            set_call_barring_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
             if ( sups_info_ptr->retry_duration > 0 )
             {
              set_call_barring_resp.retry_duration_valid = TRUE;
               set_call_barring_resp.retry_duration = sups_info_ptr->retry_duration;
             }
             success = TRUE;
             break;

           case SS_ERROR_INFO:    /* Network rejected request */
             //If conf_type= 15 =>Network rejected SupS request");
            set_call_barring_resp.resp.result = QMI_RESULT_FAILURE_V01;
            set_call_barring_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
            set_call_barring_resp.failure_cause_valid = TRUE;
            set_call_barring_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
             if ( sups_info_ptr->retry_duration > 0 )
             {
              set_call_barring_resp.retry_duration_valid = TRUE;
               set_call_barring_resp.retry_duration = sups_info_ptr->retry_duration;
             }
             success = TRUE;
             break;

           default:
            set_call_barring_resp.resp.result = QMI_RESULT_FAILURE_V01;
            set_call_barring_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
         }
         break;
      default:
         QM_MSG_ERROR("received invalid ss code");
        set_call_barring_resp.resp.result = QMI_RESULT_FAILURE_V01;
        set_call_barring_resp.resp.error = QMI_ERR_INTERNAL_V01;
         break;
    }
  }
  else
  {
    QM_MSG_ERROR("Pwd Reg Conf - Rejected from protocol layer");
    set_call_barring_resp.resp.result = QMI_RESULT_FAILURE_V01;
    set_call_barring_resp.resp.error = QMI_ERR_INTERNAL_V01;
    success = FALSE;
  }

  if(success)
  {
    qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&set_call_barring_resp, sizeof(set_call_barring_resp), TRUE );
  }
  else
  {
    qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, set_call_barring_resp.resp.error, TRUE, FALSE );
    return;
  }

}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_EVENT_ACTIVATE_CONF()

  DESCRIPTION
    Sups interrogate conf sent by CM is handled here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_event_activate_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
)
{
  qmi_voice_cmd_list_public_type list_info;
  qmi_voice_cm_if_cmd_info_sups_type *ss_list_info;
  voice_set_sups_service_resp_msg_v02 set_sups_resp;
  boolean success;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/
  ASSERT( sups_info_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_event_activate_conf():");

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)sups_info_ptr->asubs_id;
#endif
  
  memset(&set_sups_resp,0,sizeof(set_sups_resp));
  if( qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF, sups_info_ptr->ss_ref, &list_info, as_id) != E_SUCCESS )
  {
    QM_MSG_ERROR("None of entry is waiting for QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF ");
    return;
  }

  ss_list_info = &list_info.sub.sups;

  QM_MSG_MED_4("sups_event_activate_conf():Sups info success = %d conf type = %d ss_code = %d retry duration = %d", sups_info_ptr->ss_success, sups_info_ptr->conf_type, ss_list_info->ss_code, sups_info_ptr->retry_duration);

  if(ss_list_info->ss_ref != sups_info_ptr->ss_ref)
  {
    QM_MSG_HIGH("QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF with incorrect ss_ref is receiveds");
    return;
  }
  else if(sups_info_ptr->ss_success)
  {
    switch(ss_list_info->ss_code)
    {
      case qmi_voice_cm_sups_cw:
      case qmi_voice_cm_sups_clip:
      case qmi_voice_cm_sups_colp:
      case qmi_voice_cm_sups_colr:
      case qmi_voice_cm_sups_cfu:
      case qmi_voice_cm_sups_cfb:
      case qmi_voice_cm_sups_cfnry:
      case qmi_voice_cm_sups_cfnrc:
      case qmi_voice_cm_sups_allForwardingSS:
      case qmi_voice_cm_sups_allCondForwardingSS:
	  	QM_MSG_MED_1("SupS confirmation  %d ", sups_info_ptr->conf_type);
         switch(sups_info_ptr->conf_type)
         {
           /* Success cases */
           case FWD_INFO:
           case SS_DATA_INFO:
           case NO_INFO:  /* special case with no parameter info */
             //If conf_type=1,13,4,20 =>SupS confirmation successful
             success = TRUE;
             break;

           case CC_CAUSE_INFO:    /* Lower layer failure in protocol stack */
              //If conf_type=16 =>Recieved Activation conf with Rejection from protocol layer 
            set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
            set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
            set_sups_resp.failure_cause_valid = TRUE;
            set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
              set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

           case SS_ERROR_INFO:    /* Network rejected request */
              //If conf_type=15 =>Recieved Activation conf with Network rejected SupS request 
            set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
            set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
            set_sups_resp.failure_cause_valid = TRUE;
            set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
              set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

           default:
             QM_MSG_MED("Network rejected SupS request");
            set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
            set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
         }
         break;

      case qmi_voice_cm_sups_baoc:
      case qmi_voice_cm_sups_boic:
      case qmi_voice_cm_sups_boicExHC:
      case qmi_voice_cm_sups_baic:
      case qmi_voice_cm_sups_bicRoam:
      case qmi_voice_cm_sups_bil:
      case qmi_voice_cm_sups_bin:
         QM_MSG_MED_1("SupS confirmation type:  %d ", sups_info_ptr->conf_type);
         switch(sups_info_ptr->conf_type)
         {
           /* Success cases */
           case CALL_BARRING_NUM_LIST_INFO:
           case SS_DATA_INFO:
           case CALL_BARRING_INFO:
           case NO_INFO:  /* special case with no parameter info */
             //If conf_type=21,13,4,20 =>SupS confirmation successful
             success = TRUE;
             break;

           case CC_CAUSE_INFO:    /* Lower layer failure in protocol stack */
              //If conf_type=16 =>Recieved Activation conf with Rejection from protocol layer 
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
             break;

           case SS_ERROR_INFO:    /* Network rejected request */
              //If conf_type=15 =>Recieved Activation conf with Network rejected SupS request 
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

           default:
             QM_MSG_MED("Network rejected SupS request ");
             set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
             set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
         }
         break;
      default:
         QM_MSG_MED_2( "%s : %d", "Invalid ss_code in activate conf ",ss_list_info->ss_code);
         set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
         set_sups_resp.resp.error = QMI_ERR_INCOMPATIBLE_STATE_V01;
         success = FALSE;
      break;
    }
    
    if(sups_info_ptr->sups_ss_error_text != NULL )
    {
      qmi_voice_cm_util_copy_sups_failure_string(&set_sups_resp, sups_info_ptr->sups_ss_error_text);
    }
  }
  else
  {
    QM_MSG_MED("Rejected from protocol layer");
    set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
    set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
    success = FALSE;
  }

  QM_MSG_MED_1("sending response for QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF as success = %d", success);

  if(success)
  {
    qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&set_sups_resp, sizeof(set_sups_resp), TRUE );
  }
  else
  {
    qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, set_sups_resp.resp.error, TRUE, FALSE );
    return;
  }

}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_EVENT_DEACTIVATE_CONF()

  DESCRIPTION
    Sups Deactivation conf sent by CM is handled here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_event_deactivate_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
)
{
  qmi_voice_cmd_list_public_type list_info;
  qmi_voice_cm_if_cmd_info_sups_type *ss_list_info;
  voice_set_sups_service_resp_msg_v02 set_sups_resp;
  boolean success;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  /*-----------------------------------------------------------------------*/
  ASSERT( sups_info_ptr != NULL );
  /*-----------------------------------------------------------------------*/
  memset(&set_sups_resp,0,sizeof(set_sups_resp));
  
  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_event_deactivate_conf():");

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)sups_info_ptr->asubs_id;
#endif
  
  if( qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF, sups_info_ptr->ss_ref, &list_info, as_id) != E_SUCCESS )
  {
    QM_MSG_ERROR("None of entry is waiting for QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF ");
    return;
  }

  ss_list_info = &list_info.sub.sups;

  QM_MSG_MED_1("sups_event_deactivate_conf():Sups info retry duration = %d", sups_info_ptr->retry_duration);

  if(ss_list_info->ss_ref != sups_info_ptr->ss_ref)
  {
    QM_MSG_HIGH("QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF with incorrect ss_ref is receiveds");
    return;
  }
  else if(sups_info_ptr->ss_success)
  {
    switch(ss_list_info->ss_code)
    {

      case qmi_voice_cm_sups_cw:
      case qmi_voice_cm_sups_clip:
      case qmi_voice_cm_sups_colp:
      case qmi_voice_cm_sups_colr:
      case qmi_voice_cm_sups_cfu:
      case qmi_voice_cm_sups_cfb:
      case qmi_voice_cm_sups_cfnry:
      case qmi_voice_cm_sups_cfnrc:
      case qmi_voice_cm_sups_allForwardingSS:
      case qmi_voice_cm_sups_allCondForwardingSS:
         switch(sups_info_ptr->conf_type)
         {
           /* Success cases */
           case FWD_INFO:
           case SS_DATA_INFO:
           case NO_INFO:  /* special case with no parameter info */
             //If conf_type=1,13,4,20 =>SupS confirmation successful
             success = TRUE;
             break;

           case CC_CAUSE_INFO:    /* Lower layer failure in protocol stack */
              //If conf_type=16 =>Recieved Deactivation conf with Rejection from protocol layer 
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
             break;

           case SS_ERROR_INFO:    /* Network rejected request */
              //If conf_type=15 =>Recieved Deactivation conf with Network rejected SupS request 
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

           default:
             QM_MSG_MED("Network rejected SupS request ");
             set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
             set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
         }
         break;

      case qmi_voice_cm_sups_baoc:
      case qmi_voice_cm_sups_boic:
      case qmi_voice_cm_sups_boicExHC:
      case qmi_voice_cm_sups_baic:
      case qmi_voice_cm_sups_bicRoam:
      case qmi_voice_cm_sups_allCallRestrictionSS:
      case qmi_voice_cm_sups_barringOfOutgoingCalls:       
      case qmi_voice_cm_sups_barringOfIncomingCalls:       
      case qmi_voice_cm_sups_bil:
      case qmi_voice_cm_sups_bin:
         QM_MSG_MED_1("SupS confirmation type:  %d ", sups_info_ptr->conf_type);
         switch(sups_info_ptr->conf_type)
         {
           /* Success cases */

           case CALL_BARRING_NUM_LIST_INFO:
           case CALL_BARRING_INFO:
           case SS_DATA_INFO:
           case NO_INFO:             /* special case with no parameter info */
             //If conf_type=21,13,4,20 =>SupS confirmation successful
             success = TRUE;
             break;

           case CC_CAUSE_INFO:    /* Lower layer failure in protocol stack */
              //If conf_type=16 =>Recieved Deactivation conf with Rejection from protocol layer
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
             break;

           case SS_ERROR_INFO:    /* Network rejected request */
              //If conf_type=15 =>Recieved Deactivation conf with Network rejected SupS request 
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

           default:
             QM_MSG_MED("Network rejected SupS request ");
             set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
             set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
         }
         break;
      default:
         QM_MSG_MED_2( "%s : %d", "Invalid ss_code in Deactivate conf ",ss_list_info->ss_code);
         set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
         set_sups_resp.resp.error = QMI_ERR_INCOMPATIBLE_STATE_V01;
         success = FALSE;
         break;
    }

    if(sups_info_ptr->sups_ss_error_text != NULL )
    {
      qmi_voice_cm_util_copy_sups_failure_string(&set_sups_resp, sups_info_ptr->sups_ss_error_text);
    }

  }
  else
  {
    QM_MSG_MED("Rejected from protocol layer");
    set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
    set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
    success = FALSE;
  }

  if(success)
  {
    qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&set_sups_resp, sizeof(set_sups_resp), TRUE );
  }
  else
  {
    qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, set_sups_resp.resp.error, TRUE, FALSE );
    return;
  }


}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_EVENT_ERASE_CONF()

  DESCRIPTION
    Sups Erasure conf sent by CM is handled here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_event_erase_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
)
{
  qmi_voice_cmd_list_public_type list_info;
  qmi_voice_cm_if_cmd_info_sups_type *ss_list_info;
  voice_set_sups_service_resp_msg_v02 set_sups_resp;
  boolean success;
  forwarding_feature_T   *ss_status_ptr;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( sups_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  memset(&set_sups_resp,0,sizeof(set_sups_resp));

  //QM_MSG_MED("Inside qmi_voice_cm_if_sups_event_erase_conf():");
#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)sups_info_ptr->asubs_id;
#endif
  
  if( qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF, sups_info_ptr->ss_ref, &list_info, as_id) != E_SUCCESS )
  {
    QM_MSG_HIGH("None of entry is waiting for QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF");
    return;
  }

  ss_list_info = &list_info.sub.sups;

  QM_MSG_MED_4("sups_event_erase_conf()::Sups info success = %d conf type = %d ss_code = %d retry duration = %d", sups_info_ptr->ss_success, sups_info_ptr->conf_type, ss_list_info->ss_code, sups_info_ptr->retry_duration);

  
  if(ss_list_info->ss_ref != sups_info_ptr->ss_ref)
  {
    QM_MSG_HIGH("QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF with incorrect ss_ref is received");
    return;
  }
  else if(sups_info_ptr->ss_success)
  {
    switch(ss_list_info->ss_code)
    {

      case qmi_voice_cm_sups_cfu:
      case qmi_voice_cm_sups_cfb:
      case qmi_voice_cm_sups_cfnry:
      case qmi_voice_cm_sups_cfnrc:
      case qmi_voice_cm_sups_allForwardingSS:
      case qmi_voice_cm_sups_allCondForwardingSS:
	  QM_MSG_MED_1("SupS confirmation  %d ", sups_info_ptr->conf_type);
         switch(sups_info_ptr->conf_type)
         {
           /* Success cases */
           case FWD_INFO:    
              QM_MSG_MED_4("ss_status.present==%d, fwd_feature_list::ss_status.present=%d, forwarding_info::ss_status.present=%d, feature_list_len=%d",
              sups_info_ptr->ss_status.present,
              sups_info_ptr->fwd_feature_list.forwarding_feature[0].ss_status.present,
              sups_info_ptr->forwarding_info.forwarding_feature_list.forwarding_feature[0].ss_status.present,
			  	sups_info_ptr->forwarding_info.forwarding_feature_list.forwarding_feature_list_length);
           
              ss_status_ptr =  &sups_info_ptr->forwarding_info.forwarding_feature_list.forwarding_feature[0];

              if(ss_status_ptr->ss_status.present)
              {
                set_sups_resp.service_status_valid = TRUE;
                if(ss_status_ptr->ss_status.cm_ss_active == TRUE)
                {
                  set_sups_resp.service_status.active_status = ACTIVE_STATUS_ACTIVE_V02;
                }
                if(ss_status_ptr->ss_status.cm_ss_provisioned == TRUE)
                {
                  set_sups_resp.service_status.provision_status = PROVISION_STATUS_PROVISIONED_PERMANENT_V02;
                }
              }
              QM_MSG_MED_3("Valid = %d, Active = %d, Provision = %d ", set_sups_resp.service_status_valid, set_sups_resp.service_status.active_status, set_sups_resp.service_status.provision_status);
              success = TRUE;
              break;
           case NO_INFO:  /* special case with no parameter info */
             //SupS confirmation successful:
             success = TRUE;
             break;

           case CC_CAUSE_INFO:   /* Network rejected request */
              //If conf_type = 16 =>Recieved Erase conf with Rejection from protocol layer 
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
             break;

           case SS_ERROR_INFO:    /* Network rejected request */
              //If conf_type = 15 =>Recieved Erase conf with Network rejected SupS request 
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

           default:
             QM_MSG_MED("Network rejected SupS request ");
             set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
             set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
         }
         break;
      case qmi_voice_cm_sups_bil:
	  	QM_MSG_MED_1("SupS confirmation  %d ", sups_info_ptr->conf_type);
         switch(sups_info_ptr->conf_type)
         {
           /* Success cases */
           case CALL_BARRING_NUM_LIST_INFO:
           case NO_INFO:             /* special case with no parameter info */
             //If conf_type = 21,20 =>SupS confirmation successful
             success = TRUE;
             break;

           case CC_CAUSE_INFO:    /* Lower layer failure in protocol stack */
              //If conf_type = 16 =>Recieved erase conf with Rejection from protocol layer 
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
             break;

           case SS_ERROR_INFO:    /* Network rejected request */
              //If conf_type = 15 =>Recieved erase conf with Network rejected SupS request 
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

           default:
             QM_MSG_MED("Network rejected SupS request ");
             set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
             set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
         }
         break;

      default:
         QM_MSG_MED("Invalid ss_code in erase conf ");
         set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
         set_sups_resp.resp.error = QMI_ERR_INCOMPATIBLE_STATE_V01;
         success = FALSE;
         break;
    }

    if(sups_info_ptr->sups_ss_error_text != NULL )
    {
      qmi_voice_cm_util_copy_sups_failure_string(&set_sups_resp, sups_info_ptr->sups_ss_error_text);
    }

  }
  else
  {
    QM_MSG_HIGH("Rejected from protocol layer");
    set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
    set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
    success = FALSE;
  }

  if(success)
  {
    qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&set_sups_resp, sizeof(set_sups_resp), TRUE );
  }
  else
  {
    qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, set_sups_resp.resp.error, TRUE, FALSE );
    return;
  }
}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_EVENT_REGISTER_CONF()

  DESCRIPTION
    Sups Register conf sent by CM is handled here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_event_register_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
)
{
  qmi_voice_cmd_list_public_type list_info;
  qmi_voice_cm_if_cmd_info_sups_type *ss_list_info;
  voice_set_sups_service_resp_msg_v02 set_sups_resp;
  boolean success;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( sups_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  memset(&set_sups_resp,0,sizeof(set_sups_resp));

  //Inside qmi_voice_cm_if_sups_event_register_conf()
#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)sups_info_ptr->asubs_id;
#endif

  if( qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF, sups_info_ptr->ss_ref, &list_info, as_id) != E_SUCCESS )
  {
    QM_MSG_HIGH("None of entry is waiting for QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF");
    return;
  }

  ss_list_info = &list_info.sub.sups;

  QM_MSG_MED_4("sups_event_register_conf():Sups info success = %d conf type = %d ss_code = %d retry duration = %d", 
  	            sups_info_ptr->ss_success, sups_info_ptr->conf_type, ss_list_info->ss_code, sups_info_ptr->retry_duration);
  
  if(ss_list_info->ss_ref != sups_info_ptr->ss_ref)
  {
    QM_MSG_HIGH("QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF with incorrect ss_ref is received");
    return;
  }
  else if(sups_info_ptr->ss_success)
  {
    switch(ss_list_info->ss_code)
    {
      case qmi_voice_cm_sups_cfu:
      case qmi_voice_cm_sups_cfb:
      case qmi_voice_cm_sups_cfnry:
      case qmi_voice_cm_sups_cfnrc:
      case qmi_voice_cm_sups_allForwardingSS:
      case qmi_voice_cm_sups_allCondForwardingSS:
	  	QM_MSG_MED_1("SupS confirmation  %d ", sups_info_ptr->conf_type);
         switch(sups_info_ptr->conf_type)
         {
           /* Success cases */
           case FWD_INFO:
	   case NO_INFO: /* special case with no parameter info */
             //If conf_type= 1,20 =>SupS confirmation successful
             success = TRUE;
             break;

           case CC_CAUSE_INFO:   /* Network rejected request */
              //If conf_type= 16 =>Recieved Register conf with Rejection from protocol layer
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
             break;

           case SS_ERROR_INFO:    /* Network rejected request */
              //If conf_type= 15 =>Recieved Register conf with Network rejected SupS request
              if((sups_info_ptr->ss_error.present == TRUE) &&
                 (sups_info_ptr->ss_error.error_code_tag == QMI_SS_ERROR_MN_SS_ERROR_TAG) && 
                 (sups_info_ptr->ss_error.error_code == QMI_CM_IF_SS_ERROR_MN_NO_REPLY_CONDITION_TIMER_VALUE_INVALID))
              {
                QM_MSG_MED("Special handling for No reply timer out of bounds.");
                set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
                set_sups_resp.resp.error = QMI_ERR_INVALID_ARG_V01;
              }
              else
              {
                set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
                set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
                set_sups_resp.failure_cause_valid = TRUE;
                set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              }
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

           default:
             QM_MSG_MED("Network rejected SupS request ");
             set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
             set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
         }
         break;
     case qmi_voice_cm_sups_bil:
	 	QM_MSG_MED_1("SupS confirmation %d ", sups_info_ptr->conf_type);
         switch(sups_info_ptr->conf_type)
         {
           /* Success cases */
           case CALL_BARRING_NUM_LIST_INFO:
           case NO_INFO:             /* special case with no parameter info */
             //If conf_type= 21,20 => SupS confirmation successful
             success = TRUE;
             break;

           case CC_CAUSE_INFO:    /* Lower layer failure in protocol stack */
              //If conf_type= 16=>Recieved register conf with Rejection from protocol layer 
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
             break;

           case SS_ERROR_INFO:    /* Network rejected request */
              //If conf_type= 15 =>Recieved register conf with Network rejected SupS request
              set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
              set_sups_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
              set_sups_resp.failure_cause_valid = TRUE;
              set_sups_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              if ( sups_info_ptr->retry_duration > 0 )
              {
                set_sups_resp.retry_duration_valid = TRUE;
                set_sups_resp.retry_duration = sups_info_ptr->retry_duration;
              }
              success = TRUE;
              break;

           default:
             QM_MSG_MED("Network rejected SupS request ");
             set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
             set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
             success = FALSE;
             break;
         }
         break;
      
       default:
         QM_MSG_MED("Invalid ss_code in Register conf ");
         set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
         set_sups_resp.resp.error = QMI_ERR_INCOMPATIBLE_STATE_V01;
         success = FALSE;
         break;
    }

    if(sups_info_ptr->sups_ss_error_text != NULL )
    {
      qmi_voice_cm_util_copy_sups_failure_string(&set_sups_resp, sups_info_ptr->sups_ss_error_text);
    }
  }
  else
  {
    QM_MSG_ERROR("Rejected from protocol layer");
    set_sups_resp.resp.result = QMI_RESULT_FAILURE_V01;
    set_sups_resp.resp.error = QMI_ERR_INTERNAL_V01;
    success = FALSE;
  }

  if(success)
  {
    qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&set_sups_resp, sizeof(set_sups_resp), TRUE );
  }
  else
  {
    qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, set_sups_resp.resp.error , TRUE, FALSE );
    return;
  }
}

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_sups_event_process_uss_conf

===========================================================================*/
/*!
    @brief
    Processes the response received for ORIG USSD request
    (i.e QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF) from network/protocol stack

    @return
    USSD DATA on success.
    
    None.
*/
/*=========================================================================*/
void qmi_voice_cm_if_sups_event_process_uss_conf
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
)
{
  qmi_voice_cmd_list_public_type list_info, info_data;
  cm_sups_info_s_type *cm_info = sups_info_ptr;
  qmi_voice_cm_if_cmd_info_sups_type *ss_list_info;
  voice_orig_ussd_resp_msg_v02 ussd_orig_resp;
  boolean success = FALSE;
  char ussd_str[MAX_MT_USSD_CHAR];
  cm_ussd_dcs_e_type dcs=CM_USSD_DCS_UNSPECIFIED;
  boolean is_qmi_orig_ussd = TRUE;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/
  ASSERT( sups_info_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  memset(ussd_str, '\0', sizeof(ussd_str) );
  memset(&ussd_orig_resp,0,sizeof(ussd_orig_resp));

#ifdef FEATURE_DUAL_SIM
	as_id = (uint8)sups_info_ptr->asubs_id;
#endif


  if( qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF, sups_info_ptr->ss_ref, &list_info,as_id) != E_SUCCESS )
  {
    QM_MSG_HIGH("None of entry is waiting for QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF");
    return;
  }
  else if(list_info.cmd == QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_FROM_EXTERNAL_SOURCE)
  {
    is_qmi_orig_ussd = FALSE;
    QM_MSG_HIGH_2( "Found Ussd originated by external source = %ld, ss_ref=%d ",list_info.hdl,list_info.sub_id);
  }

  if( ( ( cm_info->conf_type == SS_ERROR_INFO ) &&
         ( cm_info->ss_error.error_code_tag  == QMI_VOICE_CM_IF_SUPS_INVOKE_PROBLEM ) &&
         ( cm_info->ss_error.error_code == QMI_VOICE_CM_IF_SUPS_UNRECOGNISED_OPERATION ) ) ||
       ( ( cm_info->conf_type == CC_CAUSE_INFO ) &&
         ( cm_info->cc_cause.cause_value == QMI_VOICE_CM_IF_SUPS_FACILITY_REJECTED ) )
    )
  {
    QM_MSG_HIGH("Ignoring the event as PHASE2 USSD is rejected and retried as PHASE1");
    ussd_orig_resp.resp.result = QMI_RESULT_FAILURE_V01;
    ussd_orig_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
    ussd_orig_resp.failure_cause_valid = TRUE;
    ussd_orig_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
    if(is_qmi_orig_ussd)
    {
      qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&ussd_orig_resp, 
                                                                  sizeof(ussd_orig_resp), TRUE );
    }
    else
    {
      qmi_voice_cmd_list_free( list_info.hdl );
    }
    return;
  }

  ss_list_info = &list_info.sub.sups;

  QM_MSG_MED_2("Sups info success = %d confirmation type = %d", cm_info->ss_success, cm_info->conf_type);
  
  if(ss_list_info->ss_ref != cm_info->ss_ref)
  {
    QM_MSG_HIGH("QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF with incorrect ss_ref is received");
    return;
  }
  else if(cm_info->ss_success)
  {
    QM_MSG_MED_1("SupS USSD confirmation  %d ", sups_info_ptr->conf_type);
    switch(cm_info->conf_type)
    {
      /* Success cases */
      case USS_DATA_INFO:
      case NO_INFO:  /* special case with no parameter info */
        if(cm_info->uss_data.present == TRUE)
        {
          uss_data_T  *cm_data = &cm_info->uss_data;
          voice_uss_info_type_v02  *resp_data = &ussd_orig_resp.uss_info;

          //If conf_type= 9,20 =>SupS USSD confirmation successful
          ussd_orig_resp.uss_info_valid = TRUE;
          dcs = qmi_voice_cm_util_get_ussd_dcs( cm_data->uss_data_coding_scheme );
          resp_data->uss_data_len = MIN(sizeof(resp_data->uss_data), cm_data->size);
          if(dcs == CM_USSD_DCS_8_BIT)
           {
              memscpy(resp_data->uss_data, sizeof(resp_data->uss_data), cm_data->ussData, resp_data->uss_data_len);
              resp_data->uss_dcs = USS_DCS_8BIT_V02;
           }
          else if(dcs == CM_USSD_DCS_UCS2)
           {
             /* Special handling for UCS2 preceded by two GSM 7-bit alphabet. Ignore the first two bytes which represent language indicator. */
             if(0x11 == cm_data->uss_data_coding_scheme)
             {
               memscpy(resp_data->uss_data, sizeof(resp_data->uss_data),
                       &cm_data->ussData[2], (resp_data->uss_data_len-2));
               resp_data->uss_data_len = resp_data->uss_data_len - 2;
             }
             else
             {
               memscpy(resp_data->uss_data, sizeof(resp_data->uss_data),
                       cm_data->ussData, resp_data->uss_data_len);
             }
              resp_data->uss_dcs = USS_DCS_UCS2_V02;
           }
          else if(dcs == CM_USSD_DCS_7_BIT)
           {
              if( cm_info->uss_data_type == CM_USS_PHASE1_TYPE )
               {
                 QM_MSG_MED("Received PHASE1 USSD ");
                 memscpy( resp_data->uss_data,sizeof(resp_data->uss_data), cm_data->ussData, resp_data->uss_data_len  );
                 resp_data->uss_dcs = USS_DCS_ASCII_V02;
               }
               else
               {
                 size_t response_len_asci=0;
                 size_t response_len_ucs2=0;

                //Since cm_util_gsm7_to_iso8859 returns NULL terminated string, buffer needs to be one char bigger
                uint8 uss_temp_buffer[QMI_VOICE_CM_IF_MAX_USS_DATA_LEN+1];
                memset( uss_temp_buffer, '\0', sizeof( uss_temp_buffer ) );

                 /* Try to convert to ISO 8859-1.  If the data can't be represented
                 ** in that character set, use UTF-16 instead.
                 */
                 resp_data->uss_dcs = USS_DCS_ASCII_V02;
                
                 (void) cm_util_gsm7_to_iso8859(
                             cm_data->ussData, cm_data->size, TRUE,
                            uss_temp_buffer, sizeof(uss_temp_buffer),
                             &response_len_asci);


                if(response_len_asci > QMI_VOICE_CM_IF_MAX_USS_DATA_LEN)
                {
                  resp_data->uss_data_len = QMI_VOICE_USS_DATA_MAX_V02;
                }
                else
                {
                 resp_data->uss_data_len = (uint8) response_len_asci;
                }
                memscpy(resp_data->uss_data,sizeof(resp_data->uss_data), uss_temp_buffer, resp_data->uss_data_len);
                

                QM_MSG_MED_1("Converting the data to asci length =%d", resp_data->uss_data_len);

                 //if (result & CHR_CVRT_INACCURATE) // Conversion accurate or not, we need to send both TLVs             

                 QM_MSG_MED_2( "%s, length =%d", "Converting the data to UCS2",resp_data->uss_data_len );
                 (void) cm_util_gsm7_to_utf16(
                             cm_data->ussData, cm_data->size, TRUE,
                             ussd_orig_resp.uss_info_utf16, sizeof(ussd_orig_resp.uss_info_utf16)/2,
                             &response_len_ucs2);
                 ussd_orig_resp.uss_info_utf16_len = (uint8) response_len_ucs2;
                 ussd_orig_resp.uss_info_utf16_valid = TRUE;
               }
           }
          else
           {
              QM_MSG_ERROR_1("Received unhandled DCS = %d ", dcs);
           }
        }
        success = TRUE;
        break;

      case CC_CAUSE_INFO:   /* Network rejected request */
        //If conf_type=16 =>Recieved ussd conf with Rejection from protocol layer 
        ussd_orig_resp.resp.result = QMI_RESULT_FAILURE_V01;
        ussd_orig_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
        ussd_orig_resp.failure_cause_valid = TRUE;
        ussd_orig_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
        success = TRUE;
        break;

      case SS_ERROR_INFO:   /* Lower layer failure in protocol stack */
        //If conf_type= 15 =>Recieved ussd conf with Network rejected SupS request
        ussd_orig_resp.resp.result = QMI_RESULT_FAILURE_V01;
        ussd_orig_resp.resp.error = QMI_ERR_SUPS_FAILURE_CAUSE_V01;
        ussd_orig_resp.failure_cause_valid = TRUE;
        ussd_orig_resp.failure_cause = (qmi_sups_errors_enum_v02)qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
        success = TRUE;
        break;

      default:
        QM_MSG_MED("Network rejected SupS request ");
        ussd_orig_resp.resp.result = QMI_RESULT_FAILURE_V01;
        ussd_orig_resp.resp.error = QMI_ERR_INTERNAL_V01;
        success = FALSE;
        break;
    }
  }
  else
  {
    QM_MSG_MED("Rejected from protocol layer");
    ussd_orig_resp.resp.result = QMI_RESULT_FAILURE_V01;
    ussd_orig_resp.resp.error = QMI_ERR_INTERNAL_V01;
    success = FALSE;
  }

  if((cm_info->conf_type == CC_CAUSE_INFO) || (cm_info->conf_type == SS_ERROR_INFO))
  {
    if(qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_SUPS_USS_IND, &info_data, as_id ) == E_SUCCESS)
    {
      /* remove the entry of the indication from the list*/
      qmi_voice_cmd_list_free( info_data.hdl );
    }
  }
  
  if (is_qmi_orig_ussd)
  {
    if(success)
    {
      qmi_voice_cm_if_response_success( list_info.hdl, list_info.cmd, (void *)&ussd_orig_resp, sizeof(ussd_orig_resp), TRUE );
    }
    else
    {
      qmi_voice_cm_if_response_error( list_info.hdl, list_info.cmd, ussd_orig_resp.resp.error , TRUE, FALSE );
      return;
    }
  }
  else
  {
    qmi_voice_cmd_list_free( list_info.hdl );
  }
} /* qmi_voice_cm_if_sups_event_process_uss_conf */

/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_get_password_ind

===========================================================================*/
/*!
    @brief
    Handle QMI_VOICE_CM_IF_EVT_SUPS_GET_PASSWORD_IND.

    @return
    None.
*/
/*=========================================================================*/
void qmi_voice_cm_if_sups_event_get_password_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
)
{
  boolean cm_result = FALSE;
  cm_get_pwd_res_params_s_type       get_pwd_res;
  qmi_voice_cmd_list_public_type info_ptr;
  char *cm_guidance;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( sups_info_ptr != NULL );
  /*-----------------------------------------------------------------------*/
#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)sups_info_ptr->asubs_id;
#endif
  memset( &get_pwd_res, 0, sizeof( cm_get_pwd_res_params_s_type ));

  /* Preserve network invoke ID */
  get_pwd_res.invoke_id = sups_info_ptr->invoke_id;

  /* case where RIL is responding for MT USSD request */
  if (qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF, &info_ptr, as_id ) == E_SUCCESS)
  {
    if(info_ptr.sub.sups.ss_pwd.present)
    {
      get_pwd_res.ss_pwd.present = TRUE;
    }
  }
  else if (qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF, &info_ptr, as_id ) == E_SUCCESS)
  {
    if(info_ptr.sub.sups.ss_pwd.present)
    {
      get_pwd_res.ss_pwd.present = TRUE;
    }  
  }
  else if (qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF, &info_ptr, as_id ) == E_SUCCESS)
  {
    if(info_ptr.sub.sups.ss_pwd.present)
    {
      get_pwd_res.ss_pwd.present = TRUE;
    }  
  }
  else if (qmi_voice_cmd_list_query_by_event(QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF, &info_ptr, as_id ) == E_SUCCESS)
  {
    if(info_ptr.sub.sups.ss_pwd.present)
    {
      get_pwd_res.ss_pwd.present = TRUE;
    }  
  }
  else
  {
    QM_MSG_ERROR("ignoring the received event as there are no pending requests ");
  }

  if(get_pwd_res.ss_pwd.present)
  {
    switch (sups_info_ptr->guidance_info)
    {
      case enterPW:                   /* enter password */
        memscpy( get_pwd_res.ss_pwd.ss_password,
                sizeof(get_pwd_res.ss_pwd.ss_password),
                info_ptr.sub.sups.ss_pwd.password,
                MAX_PWD_CHAR );
        cm_guidance = "enterPW";
        break;
  
      case enterNewPW:                /* enter new password */
        cm_guidance = "enterNewPW";
        break;

      case enterNewPW_Again:          /* confirm new password */
        memscpy( get_pwd_res.ss_pwd.ss_password,
                sizeof(get_pwd_res.ss_pwd.ss_password),
                info_ptr.sub.sups.ss_pwd.password,
                MAX_PWD_CHAR );
        cm_guidance = (sups_info_ptr->guidance_info == enterNewPW)? "enterNewPW" : "enterNewPW_Again";

        break;
  
      default:
        QM_MSG_ERROR_1("Unknown password indication:  %d ", sups_info_ptr->guidance_info);
        cm_guidance = "Invalid_guidance";
        break;
    }
   
    QM_MSG_MED_3( "pwd %s, present %d, cm_guidance %s", get_pwd_res.ss_pwd.ss_password, get_pwd_res.ss_pwd.present, cm_guidance);


#ifdef FEATURE_DUAL_SIM
    QM_MSG_MED_1("cm_sups_cmd_get_password_res_per_subs() invoked with as_id %d", sups_info_ptr->asubs_id);
    /* Send the command to the CM command queue */
    cm_result = cm_sups_cmd_get_password_res_per_subs( NULL,
                                                       NULL,
                                                       qmi_voice_cm_if_get_clientid(),
                                                       &get_pwd_res,
                                                       sups_info_ptr->asubs_id);
#else
    QM_MSG_MED("cm_sups_cmd_get_password_res()");
    /* Send the command to the CM command queue */
    cm_result = cm_sups_cmd_get_password_res( NULL,
                                              NULL,
                                              qmi_voice_cm_if_get_clientid(),
                                              &get_pwd_res);
#endif /* FEATURE_DUAL_SIM */
    if (!cm_result)
    {
      QM_MSG_ERROR("Problem invoking CM API ");
      return ;
    }
  }
  else
  {
    QM_MSG_ERROR("Ignoring as there is no stored password ");
  }

} /* qcril_cm_supsvc_event_get_password_ind */



/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_sups_event_send_ussd_ind

===========================================================================*/
/*!
    @brief
    Handle QMI_VOICE_CM_IF_EVT_SUPS_USS_IND/.
           QMI_VOICE_CM_IF_EVT_SUPS_USS_NOTIFY_IND

    @return
    None.
*/
/*=========================================================================*/
void qmi_voice_cm_if_sups_event_send_ussd_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *cm_info
)
{
  char ussd_str[QMI_VOICE_CM_IF_MAX_USS_DATA_LEN];
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type *req_info_ptr = &u_info.sups;
  voice_ussd_ind_msg_v02 ind;
  voice_uss_info_type_v02 *uss_info = &ind.uss_info;
  cm_uss_notify_res_params_s_type    uss_notify_parms;
  boolean cm_result;
  cm_ussd_dcs_e_type uss_dcs = CM_USSD_DCS_UNSPECIFIED;
  uint8  as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( cm_info != NULL );

  /*-----------------------------------------------------------------------*/
  memset(&u_info, 0 , sizeof(u_info));
  req_info_ptr->ss_ref = cm_info->invoke_id;
#ifdef FEATURE_DUAL_SIM
  as_id = cm_info->asubs_id;
#endif

  QM_MSG_MED_2("qmi_voice_cm_if_sups_event_send_ussd_ind Invoke id from CM:  %d , ss_ref=%d", cm_info->invoke_id, req_info_ptr->ss_ref);

  if(cm_info->uss_data.present == TRUE)
  {
    uss_data_T  *cm_data = &cm_info->uss_data;
    
    memset( ussd_str, '\0', sizeof( ussd_str ) );
    memset( &ind, 0, sizeof( ind ) );
    uss_dcs = qmi_voice_cm_util_get_ussd_dcs( cm_data->uss_data_coding_scheme );
    
    uss_info->uss_data_len = MIN(sizeof(uss_info->uss_data), cm_data->size);

    if(uss_dcs == CM_USSD_DCS_8_BIT)
    {
      uss_info->uss_dcs = USS_DCS_8BIT_V02;
      memscpy(uss_info->uss_data,sizeof(uss_info->uss_data), cm_data->ussData, uss_info->uss_data_len);
      ind.uss_info_valid = TRUE;
    }
    else if(uss_dcs == CM_USSD_DCS_UCS2)
    {
      /* Special handling for UCS2 preceded by two GSM 7-bit alphabet. Ignore the first two bytes which represent language indicator. */
      if(0x11 == cm_data->uss_data_coding_scheme)
      {
        memscpy(uss_info->uss_data, sizeof(uss_info->uss_data), &cm_data->ussData[2], (uss_info->uss_data_len-2));
        uss_info->uss_data_len = uss_info->uss_data_len - 2;
      }
      else
      {
        memscpy(uss_info->uss_data, sizeof(uss_info->uss_data), cm_data->ussData, uss_info->uss_data_len);
      }
      uss_info->uss_dcs = USS_DCS_UCS2_V02;
      ind.uss_info_valid = TRUE;
    }
    else if(uss_dcs == CM_USSD_DCS_7_BIT)
    {
	  size_t response_len_asci=0;
      size_t response_len_ucs2=0;

      //Since cm_util_gsm7_to_iso8859 returns NULL terminated string, buffer needs to be one char bigger
      uint8 uss_temp_buffer[QMI_VOICE_CM_IF_MAX_USS_DATA_LEN+1];
      memset( uss_temp_buffer, '\0', sizeof( uss_temp_buffer ) );

      uss_info->uss_dcs = USS_DCS_ASCII_V02;
      (void) cm_util_gsm7_to_iso8859(
                  cm_data->ussData, cm_data->size, TRUE,
                  uss_temp_buffer, sizeof(uss_temp_buffer),
                  &response_len_asci);
      if(response_len_asci > QMI_VOICE_USS_DATA_MAX_V02)
      {
        uss_info->uss_data_len = QMI_VOICE_USS_DATA_MAX_V02;
      }
      else
      {
      uss_info->uss_data_len = (uint8) response_len_asci;
      }
      memscpy(uss_info->uss_data,sizeof(uss_info->uss_data), uss_temp_buffer,uss_info->uss_data_len);
      if(uss_info->uss_data_len > 0 )
      {
        ind.uss_info_valid = TRUE; 
      }

      //if (result & CHR_CVRT_INACCURATE) // Need to send both TLVs
      
      QM_MSG_MED_2( "%s length = %d", "Converting the data to UCS2 qmi_voice_cm_if_sups_event_send_ussd_ind ",uss_info->uss_data_len );
      (void) cm_util_gsm7_to_utf16(
                   cm_data->ussData, cm_data->size, TRUE,
                   ind.uss_info_utf16, sizeof(ind.uss_info_utf16)/2,
                   &response_len_ucs2);

      ind.uss_info_utf16_len = (uint8) response_len_ucs2;
      ind.uss_info_utf16_valid = TRUE;
    }
    else
    {
      QM_MSG_ERROR_1("Received unhandled DCS in send ussd ind = %d ", uss_dcs);
    }

    if(event == QMI_VOICE_CM_IF_EVT_SUPS_USS_IND)
    {
      QM_MSG_MED_2("Invoke ID Added in Reqlist ss_ref:  %d, subid=%d", u_info.sups.ss_ref, req_info_ptr->ss_ref);
      if ( qmi_voice_cmd_list_new( QMI_VOICE_CM_IF_CMD_SUPS_USSD_IND, (uint32)(cm_info->invoke_id),
                              QMI_VOICE_CMD_AWAITING_MORE_AMSS_EVENTS,
                              QMI_VOICE_CM_IF_EVT_SUPS_USS_IND,
                              (uint32)req_info_ptr->ss_ref, &u_info, sizeof(u_info), as_id ) != E_SUCCESS )
      {
        //Could not add entry to the list for SUPS_USS_IND 
      }

      ind.notification_type = FURTHER_USER_ACTION_REQUIRED_V02;
      /* sending the data received from the network for the USSD request */
      qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_SUPS_USSD_IND, &ind,sizeof(ind), as_id);
    }
    else if(event == QMI_VOICE_CM_IF_EVT_SUPS_USS_NOTIFY_IND)
    {
      ind.notification_type = FURTHER_USER_ACTION_NOT_REQUIRED_V02;
      /* sending the data received from the network for the USSD request */
      qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_SUPS_USSD_IND, &ind,sizeof(ind), as_id);

      /* Send notify response to network */
      uss_notify_parms.invoke_id = cm_info->invoke_id;
      uss_notify_parms.ss_error.present = FALSE;
      #ifdef FEATURE_DUAL_SIM
      QM_MSG_MED_1("cm_sups_cmd_uss_notify_res_per_subs() with invoke_id (%d)", uss_notify_parms.invoke_id);
      cm_result = cm_sups_cmd_uss_notify_res_per_subs(NULL,
                                             (void*)QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL,
                                             qmi_voice_cm_if_get_clientid(),
                                             &uss_notify_parms,cm_info->asubs_id);      
      #else
      QM_MSG_MED_1("cm_sups_cmd_uss_notify_res() with invoke_id (%d)", uss_notify_parms.invoke_id);
      cm_result = cm_sups_cmd_uss_notify_res(NULL,
                                             (void*)QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL,
                                             qmi_voice_cm_if_get_clientid(),
                                             &uss_notify_parms);
      #endif /*FEATURE_DUAL_SIM*/
      if(!cm_result)
      {
        QM_MSG_ERROR("received error from CM while sending USS notify_res() ");
      }
    }
  }
  else
  {
    QM_MSG_ERROR_1("Received USS indication %d with no USSD string", event);
  }
} /* qmi_voice_cm_if_sups_event_send_ussd_ind */


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_sups_event_send_ussd_release_ind

===========================================================================*/
/*!
    @brief
    Handle QMI_VOICE_CM_IF_EVT_SUPS_RELEASE_USS_IND.

    @return
    None.
*/
/*=========================================================================*/
void qmi_voice_cm_if_sups_event_send_ussd_release_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *cm_info
)
{
  qmi_voice_cmd_list_public_type info_ptr;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  /*-----------------------------------------------------------------------*/
  ASSERT( cm_info != NULL );
  /*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)cm_info->asubs_id;
#endif

  if(qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF, &info_ptr, as_id ) == E_SUCCESS)
  {
    QM_MSG_ERROR("cleaning the uss_cnf after receiving release_uss_ind");
    /* send QMI_ERR_NETWORK_ABORTED response */
    if( info_ptr.cmd != QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_FROM_EXTERNAL_SOURCE )
    {
      qmi_voice_cm_if_response_error( info_ptr.hdl, info_ptr.cmd, QMI_ERR_NETWORK_ABORTED, TRUE , FALSE);
    }
    else
    {
      QM_MSG_HIGH_1("Free ussd command orig by external source = %ld",info_ptr.hdl);
      qmi_voice_cmd_list_free( info_ptr.hdl );
    }
  }

  if(qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_SUPS_USS_IND, &info_ptr, as_id ) == E_SUCCESS)
  {
    /* remove the entry of the indication from the list*/
    qmi_voice_cmd_list_free( info_ptr.hdl );
  }
  qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_SUPS_USSD_RELEASE_IND, NULL, 0, as_id);
}

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_fill_sups_ntwk_resp

===========================================================================*/
/*!
    @brief
    Fills the sups network response into the sups indication

    @return
    None.
*/
/*=========================================================================*/
static void qmi_voice_cm_if_fill_sups_ntwk_resp
(
  qmi_voice_cm_if_evt_e_type event,
  qmi_voice_cm_if_sups_ind_s *ind,
  cm_sups_info_s_type *sups_info_ptr
)
{
  int count = 0;
  basic_service_T *bsg_list_ptr;
  cli_restriction_info_T *cli_restriction_info;
  uint32 bs_class=0;
  qmi_voice_cm_sups_clir_status_e_type  clir_interrogate_status = QMI_VOICE_CM_SUPS_CLIR_SRV_NOT_PROVISIONED;
  uint8 status = 0;
  qmi_voice_cm_if_cmd_info_sups_type *ss_list_info;
  qmi_voice_cmd_list_public_type list_info;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  ASSERT(ind != NULL);

  memset(&list_info,0,sizeof(list_info));

#ifdef FEATURE_DUAL_SIM
	as_id = (uint8)sups_info_ptr->asubs_id;
#endif

  if( qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
                                              sups_info_ptr->ss_ref,
                                              &list_info, as_id) != E_SUCCESS )
  {
    QM_MSG_ERROR("None of entry is waiting for QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF ");
  }
  ss_list_info = &list_info.sub.sups;

  if(sups_info_ptr->ss_success)
  {
    QM_MSG_MED_1("Received call barring resp with conf type %d", sups_info_ptr->conf_type);
    switch(sups_info_ptr->ss_code)
    {
      case qmi_voice_cm_sups_baoc:
      case qmi_voice_cm_sups_boic:
      case qmi_voice_cm_sups_boicExHC:
      case qmi_voice_cm_sups_baic:
      case qmi_voice_cm_sups_bicRoam:
      case qmi_voice_cm_sups_allCallRestrictionSS:
      case qmi_voice_cm_sups_barringOfOutgoingCalls:
      case qmi_voice_cm_sups_barringOfIncomingCalls:
      {
        switch(sups_info_ptr->conf_type)
        {
          /* Success cases */
          case BSG_LIST_INFO:

            while(sups_info_ptr->bsg_list.list_length > count)
            {
             bsg_list_ptr = &sups_info_ptr->bsg_list.list[count];

             if(bsg_list_ptr->present)
             {
               bs_class += qmi_voice_cm_sups_get_service_class(bsg_list_ptr->code_type,
                                                         bsg_list_ptr->bs_code);
             }
             count++;
            }
            break;

          case SS_STATUS_INFO:
            /*status info received with ss_active set to TRUE is considered as success */
            if(sups_info_ptr->ss_status.present && sups_info_ptr->ss_status.cm_ss_active)
            {
              if(sups_info_ptr->basic_service.present)
              {
                bs_class =(uint8) qmi_voice_cm_sups_get_service_class( sups_info_ptr->basic_service.code_type,(int)sups_info_ptr->basic_service.bs_code);
                if(QMI_VOICE_CM_SUPS_CLASS_ALL != (bs_class | QMI_VOICE_CM_SUPS_CLASS_ALL))
                {
                  bs_class = (uint32)QMI_VOICE_CM_SUPS_CLASS_ALL;
                }
              }
            }
            break;

          case CC_CAUSE_INFO:
          case SS_ERROR_INFO:
            QM_MSG_ERROR_1("Recieved call barring resp with Error confirmation type = %d is received", sups_info_ptr->conf_type);
            ind->is_failure_cause_valid = TRUE;
            ind->sups_failure_cause = qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
            break;

          case CALL_BARRING_INFO:
          case NO_INFO:
            //Received call barring resp with conf type
            break;

          default:
            //Invalid call barring confirmation type 
            break;
        }
      }
      break;

      case qmi_voice_cm_sups_cw:
      {
	  	QM_MSG_MED_1("call waiting confirmation type = %d is received", sups_info_ptr->conf_type);
        switch(sups_info_ptr->conf_type)
        {
          /* Success cases */
          case BSG_LIST_INFO:
            while(sups_info_ptr->bsg_list.list_length > count)
            {
             bsg_list_ptr = &sups_info_ptr->bsg_list.list[count];

             if(bsg_list_ptr->present)
             {
               bs_class += qmi_voice_cm_sups_get_service_class(bsg_list_ptr->code_type,
                                                         bsg_list_ptr->bs_code);
             }
             count++;
            }
            break;

          case SS_STATUS_INFO:
            /*status info received with ss_active set to TRUE is considered as success */
            if(sups_info_ptr->ss_status.present && sups_info_ptr->ss_status.cm_ss_active)
            {
              if(sups_info_ptr->basic_service.present)
              {
                bs_class =(uint8) qmi_voice_cm_sups_get_service_class( sups_info_ptr->basic_service.code_type,(int)sups_info_ptr->basic_service.bs_code);
                if(qmi_voice_cm_sups_cw_allowed_classes != (bs_class | qmi_voice_cm_sups_cw_allowed_classes))
                {
                  bs_class = (uint32)QMI_VOICE_CM_SUPS_CLASS_ALL;
                }
              }
            }
            break;

            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
              //recieved call waiting resp with Error confirmation type 
              ind->is_failure_cause_valid = TRUE;
              ind->sups_failure_cause = qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              break;
            default:
              //Invalid call waiting confirmation type
              break;
          }
      }
      break;

      case qmi_voice_cm_sups_clip:
      {
	  	QM_MSG_MED_1("confirmation type for CLIP = %d is received", sups_info_ptr->conf_type);
        switch(sups_info_ptr->conf_type)
        {
          case SS_STATUS_INFO:
            ind->is_clip_status_valid = TRUE;
            if(sups_info_ptr->ss_status.present)
            {
              if((sups_info_ptr->ss_status.cm_ss_active == TRUE ) && (sups_info_ptr->ss_status.cm_ss_provisioned == TRUE))
              {
                ind->cli_status.active_status = 1;
                ind->cli_status.provision_status= 1;
              }
              else if((sups_info_ptr->ss_status.cm_ss_active == TRUE)&& (sups_info_ptr->ss_status.cm_ss_provisioned == FALSE))
              {
                ind->cli_status.active_status = 1;
                ind->cli_status.provision_status= 0;
              }
              else if((sups_info_ptr->ss_status.cm_ss_active == FALSE)&& (sups_info_ptr->ss_status.cm_ss_provisioned == TRUE))
              {
                ind->cli_status.active_status = 0;
                ind->cli_status.provision_status= 1;
              }
              else
              {
                ind->cli_status.active_status = 0;
                ind->cli_status.provision_status= 0;
              }
            }
            else
            {
              ind->cli_status.active_status = 0;
              ind->cli_status.provision_status= 0;
            }
            break;
            case CLI_RESTRICTION_INFO:
              ind->is_clip_status_valid = TRUE;
              if(sups_info_ptr->cli_restriction.present)
              {
                if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE ) && (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE))
                {
                  ind->cli_status.active_status = 1;
                  ind->cli_status.provision_status= 1;
                }
                else if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE)&& (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == FALSE))
                {
                  ind->cli_status.active_status = 1;
                  ind->cli_status.provision_status= 0;
                }
                else if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == FALSE)&& (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE))
                {
                  ind->cli_status.active_status = 0;
                  ind->cli_status.provision_status= 1;
                }
                else
                {
                  ind->cli_status.active_status = 0;
                  ind->cli_status.provision_status= 0;
                }
              }
              else
              {
                ind->cli_status.active_status = 0;
                ind->cli_status.provision_status= 0;
              }
            break;            

          case CC_CAUSE_INFO:
          case SS_ERROR_INFO:
           //Recieved CLIP resp with Error confirmation type 
           ind->is_failure_cause_valid = TRUE;
           ind->sups_failure_cause = qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
           break;

          default:
           //Invalid confirmation type for CLIP 
           break;
        }
      }
      break;

      case qmi_voice_cm_sups_clir:
      {
        ind->is_clir_status_valid = TRUE;
        ind->cli_status.active_status = cm_if_info.clir;
        switch(sups_info_ptr->conf_type)
        {
        QM_MSG_MED_1("confirmation type for CLIR = %d is received", sups_info_ptr->conf_type);
          case SS_STATUS_INFO:
            if(sups_info_ptr->ss_status.present)
            {
              if( (sups_info_ptr->ss_status.cm_ss_active == TRUE) && (sups_info_ptr->ss_status.cm_ss_provisioned == TRUE) )
              {
                clir_interrogate_status = (qmi_voice_cm_sups_clir_status_e_type)
                                          QMI_VOICE_CM_SUPS_CLIR_SRV_PROVISIONED_PERMANENT;
                ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_ACTIVE;
              }
              else if( (sups_info_ptr->ss_status.cm_ss_active == TRUE) && (sups_info_ptr->ss_status.cm_ss_provisioned == FALSE) )
              {
                clir_interrogate_status = (qmi_voice_cm_sups_clir_status_e_type)
                                          QMI_VOICE_CM_SUPS_CLIR_SRV_NOT_PROVISIONED;
                ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_ACTIVE;
              }
              else if((sups_info_ptr->ss_status.cm_ss_active == FALSE)&& (sups_info_ptr->ss_status.cm_ss_provisioned == TRUE))
              {
                clir_interrogate_status = (qmi_voice_cm_sups_clir_status_e_type)
                                          QMI_VOICE_CM_SUPS_CLIR_SRV_PROVISIONED_PERMANENT;
                ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_INACTIVE;                  
              }                
              else
              {
                clir_interrogate_status = (qmi_voice_cm_sups_clir_status_e_type)
                                          QMI_VOICE_CM_SUPS_CLIR_SRV_NOT_PROVISIONED;
                ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_INACTIVE;
              }

              }
            else
            {
              /*clir_interrogate_status = (int)QMI_VOICE_CM_SUPS_CLIR_SRV_NO_NETWORK; */
              QM_MSG_ERROR_1("GET_CLIR CONF with ss_status = %d", sups_info_ptr->ss_status.present);
              clir_interrogate_status = (qmi_voice_cm_sups_clir_status_e_type)
                                         QMI_VOICE_CM_SUPS_CLIR_SRV_NOT_PROVISIONED;
              ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_INACTIVE;                
            }
            ind->cli_status.provision_status = clir_interrogate_status;
            break;

            case FWD_FEATURE_LIST_INFO:
              if (!sups_info_ptr->fwd_feature_list.present)
              {
                QM_MSG_ERROR("Fowarding feature list info missing");
                break;
              }

              count = 0;

              //Initialise the response
              clir_interrogate_status = (qmi_voice_cm_sups_clir_status_e_type) QMI_VOICE_CM_SUPS_CLIR_SRV_NOT_PROVISIONED;
              ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_INACTIVE;   

              //Loop through the feature forwarding list 
              while (sups_info_ptr->fwd_feature_list.forwarding_feature_list_length > count)
              {
                const forwarding_feature_T * fflist_ptr =
                  &sups_info_ptr->fwd_feature_list.forwarding_feature[count];

                //Check if ss status is present and set response accordingly
                if(fflist_ptr->ss_status.present)
                {
                  QM_MSG_MED_2("ss_status is present and status is active=%d,provisioned=%d", fflist_ptr->ss_status.cm_ss_active, fflist_ptr->ss_status.cm_ss_provisioned);
                  if(fflist_ptr->ss_status.cm_ss_active == TRUE)
                  {
                    ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_ACTIVE;
                  }
                  if(fflist_ptr->ss_status.cm_ss_provisioned == TRUE)
                  {
                    clir_interrogate_status = (qmi_voice_cm_sups_clir_status_e_type)
                                              QMI_VOICE_CM_SUPS_CLIR_SRV_PROVISIONED_PERMANENT;
                  }                  
                  break;
                }

                count++;
              }              
              ind->cli_status.provision_status = clir_interrogate_status;
              break;

          case CLI_RESTRICTION_INFO:
           cli_restriction_info = &sups_info_ptr->cli_restriction;
           clir_interrogate_status = QMI_VOICE_CM_SUPS_CLIR_SRV_NOT_PROVISIONED;

           if(cli_restriction_info->present == TRUE)
           {
             if(cli_restriction_info->cm_cli_restriction_option.present == TRUE)
             {
               QM_MSG_MED_1("GET_CLIR CONF with option = %d", cli_restriction_info->cm_cli_restriction_option.option);
               switch(cli_restriction_info->cm_cli_restriction_option.option)
               {
                 case CLI_DEFAULT_OPTION:
                   /* This maps to Permanent CLIR provisioning */
                   clir_interrogate_status = QMI_VOICE_CM_SUPS_CLIR_SRV_PROVISIONED_PERMANENT;
                   ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_ACTIVE;
                   break;

                 case CLI_RESTRICT_OPTION:
                   /* This maps to default CLIR ON and can be overidden */
                   clir_interrogate_status = QMI_VOICE_CM_SUPS_CLIR_SRV_PRESENTATION_RESTRICTED;
                   ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_ACTIVE;
                   break;

                 case CLI_OVERRIDE_OPTION:
                   /* This maps to CLIR default - requires explicit CLIR status to be used
                      during call setup */
                   clir_interrogate_status = QMI_VOICE_CM_SUPS_CLIR_SRV_PRESENTATION_ALLOWED;
                   ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_ACTIVE;
                   break;

                 case CLI_UNKNOWN_OPTION:
                   /*clir_interrogate_status = QMI_VOICE_CM_SUPS_CLIR_SRV_NO_NETWORK;*/
                   ind->cli_status.active_status = QMI_VOICE_CM_SUPS_CLIR_INACTIVE;
                   break;

                 default:
                   /* Ideally filtered by CM and should not be received */
                   /* Map it to non provisioned status */
                   break;
               }
             }
           }
           ind->cli_status.provision_status = clir_interrogate_status;
           break;

          case CC_CAUSE_INFO:
          case SS_ERROR_INFO:
            ind->is_failure_cause_valid = TRUE;
            ind->sups_failure_cause = qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
            QM_MSG_ERROR_2("CLIR CONF with Error conf= %d,cause=%d", sups_info_ptr->conf_type, ind->sups_failure_cause);
            break;

          default:
            //Invalid confirmation type for CLIR 
            break;
        }
      }
      break;
      case qmi_voice_cm_sups_colp:
        {
			QM_MSG_MED_1("confirmation type for COLP = %d is received", sups_info_ptr->conf_type);
          switch(sups_info_ptr->conf_type)
          {
            case SS_STATUS_INFO:
              ind->is_colp_status_valid = TRUE;
              if(sups_info_ptr->ss_status.present)
              {
                if((sups_info_ptr->ss_status.cm_ss_active == TRUE ) && (sups_info_ptr->ss_status.cm_ss_provisioned == TRUE))
                {
                  ind->cli_status.active_status = 1;
                  ind->cli_status.provision_status= 1;
                }
                else if((sups_info_ptr->ss_status.cm_ss_active == TRUE)&& (sups_info_ptr->ss_status.cm_ss_provisioned == FALSE))
                {
                  ind->cli_status.active_status = 1;
                  ind->cli_status.provision_status= 0;
                }
                else if((sups_info_ptr->ss_status.cm_ss_active == FALSE)&& (sups_info_ptr->ss_status.cm_ss_provisioned == TRUE))
                {
                  ind->cli_status.active_status = 0;
                  ind->cli_status.provision_status= 1;
                }
                else
                {
                  ind->cli_status.active_status = 0;
                  ind->cli_status.provision_status= 0;
                }
              }
              else
              {
                ind->cli_status.active_status = 0;
                ind->cli_status.provision_status= 0;
              }
            break;
            
            case CLI_RESTRICTION_INFO:
              ind->is_colp_status_valid = TRUE;
              if(sups_info_ptr->cli_restriction.present)
              {
                if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE ) && (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE))
                {
                  ind->cli_status.active_status = 1;
                  ind->cli_status.provision_status= 1;
                }
                else if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE)&& (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == FALSE))
                {
                  ind->cli_status.active_status = 1;
                  ind->cli_status.provision_status= 0;
                }
                else if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == FALSE)&& (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE))
                {
                  ind->cli_status.active_status = 0;
                  ind->cli_status.provision_status= 1;
                }
                else
                {
                  ind->cli_status.active_status = 0;
                  ind->cli_status.provision_status= 0;
                }
              }
              else
              {
                ind->cli_status.active_status = 0;
                ind->cli_status.provision_status= 0;
              }
            break;
            
            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
              //Recieved COLP resp with Error confirmation type
              ind->is_failure_cause_valid = TRUE;
              ind->sups_failure_cause = qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              break;
            default:
              //Invalid confirmation type for COLP 
              break;
            }
          }
        break;

	case qmi_voice_cm_sups_colr:
        {
		QM_MSG_MED_1("Recieved COLR resp with confirmation type  = %d is received", sups_info_ptr->conf_type);
          switch(sups_info_ptr->conf_type)
          {
            case SS_STATUS_INFO:
              ind->is_colr_status_valid = TRUE;
              if(sups_info_ptr->ss_status.present)
              {
                if((sups_info_ptr->ss_status.cm_ss_active == TRUE ) && (sups_info_ptr->ss_status.cm_ss_provisioned == TRUE))
                {
                  ind->cli_status.active_status = 1;
                  ind->cli_status.provision_status= 1;
                }
                else if((sups_info_ptr->ss_status.cm_ss_active == TRUE)&& (sups_info_ptr->ss_status.cm_ss_provisioned == FALSE))
                {
                  ind->cli_status.active_status = 1;
                  ind->cli_status.provision_status= 0;
                }
                else if((sups_info_ptr->ss_status.cm_ss_active == FALSE)&& (sups_info_ptr->ss_status.cm_ss_provisioned == TRUE))
                {
                  ind->cli_status.active_status = 0;
                  ind->cli_status.provision_status= 1;
                }
                else
                {
                  ind->cli_status.active_status = 0;
                  ind->cli_status.provision_status= 0;
                }
              }
              else
              {
                ind->cli_status.active_status = 0;
                ind->cli_status.provision_status= 0;
              }
            break;

            case CLI_RESTRICTION_INFO:
              ind->is_colr_status_valid = TRUE;
              if(sups_info_ptr->cli_restriction.present)
              {
                if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE ) && (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE))
                {
                  ind->cli_status.active_status = 1;
                  ind->cli_status.provision_status= 1;
                }
                else if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE)&& (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == FALSE))
                {
                  ind->cli_status.active_status = 1;
                  ind->cli_status.provision_status= 0;
                }
                else if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == FALSE)&& (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE))
                {
                  ind->cli_status.active_status = 0;
                  ind->cli_status.provision_status= 1;
                }
                else
                {
                  ind->cli_status.active_status = 0;
                  ind->cli_status.provision_status= 0;
                }
              }
              else
              {
                ind->cli_status.active_status = 0;
                ind->cli_status.provision_status= 0;
              }
            break;
            
            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
              //"Recieved COLR resp with Error confirmation type  
              ind->is_failure_cause_valid = TRUE;
              ind->sups_failure_cause = qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              break;
            default:
              //Invalid confirmation type for COLR 
              break;
            }
          }
        break;
	case qmi_voice_cm_sups_cnap:
	{
	  QM_MSG_MED_1("confirmation type for CNAP = %d is received", sups_info_ptr->conf_type);
	  switch(sups_info_ptr->conf_type)
	  {
		case SS_STATUS_INFO:
		  ind->is_cnap_status_valid = TRUE;
		  if(sups_info_ptr->ss_status.present)
		  {
			if((sups_info_ptr->ss_status.cm_ss_active == TRUE ) && (sups_info_ptr->ss_status.cm_ss_provisioned == TRUE))
			{
			  ind->cli_status.active_status = 1;
			  ind->cli_status.provision_status= 1;
			}
			else if((sups_info_ptr->ss_status.cm_ss_active == TRUE)&& (sups_info_ptr->ss_status.cm_ss_provisioned == FALSE))
			{
			  ind->cli_status.active_status = 1;
			  ind->cli_status.provision_status= 0;
			}
			else if((sups_info_ptr->ss_status.cm_ss_active == FALSE)&& (sups_info_ptr->ss_status.cm_ss_provisioned == TRUE))
			{
			  ind->cli_status.active_status = 0;
			  ind->cli_status.provision_status= 1;
			}
			else
			{
			  ind->cli_status.active_status = 0;
			  ind->cli_status.provision_status= 0;
			}
		  }
		  else
		  {
			ind->cli_status.active_status = 0;
			ind->cli_status.provision_status= 0;
		  }
		break;
  
	        case CLI_RESTRICTION_INFO:
		  ind->is_cnap_status_valid = TRUE;
		  if(sups_info_ptr->cli_restriction.present)
		  {
		        if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE ) && (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE))
		        {
			  ind->cli_status.active_status = 1;
			  ind->cli_status.provision_status= 1;
		        }
		        else if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == TRUE)&& (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == FALSE))
		        {
			  ind->cli_status.active_status = 1;
			  ind->cli_status.provision_status= 0;
		        }
		        else if((sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_active == FALSE)&& (sups_info_ptr->cli_restriction.cm_ss_status.cm_ss_provisioned == TRUE))
		        {
			  ind->cli_status.active_status = 0;
			  ind->cli_status.provision_status= 1;
		        }
		        else
		        {
			  ind->cli_status.active_status = 0;
			  ind->cli_status.provision_status= 0;
		        }
		  }
		  else
		  {
		        ind->cli_status.active_status = 0;
		        ind->cli_status.provision_status= 0;
		  }
	        break;
  
		case CC_CAUSE_INFO:
		case SS_ERROR_INFO:
		  //Recieved CNAP resp with Error confirmation type  = %d is received", sups_info_ptr->conf_type);
		  ind->is_failure_cause_valid = TRUE;
		  ind->sups_failure_cause = qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
		  break;
		default:
		  //QM_MSG_ERROR_1("Invalid confirmation type for CNAP = %d is received", sups_info_ptr->conf_type);
		  break;
		}
	  }
	break;
      case qmi_voice_cm_sups_allForwardingSS:
      case qmi_voice_cm_sups_allCondForwardingSS:
      case qmi_voice_cm_sups_cfb:
      case qmi_voice_cm_sups_cfnry:
      case qmi_voice_cm_sups_cfnrc:
      case qmi_voice_cm_sups_cfu:
        {
          ind->is_call_fwd_info_from_ntwk_valid = TRUE;
          ind->cf_data.num_cfw_instances = 0;
		  QM_MSG_MED_1("Rxd call forwarding conf type = %d", sups_info_ptr->conf_type);
          switch(sups_info_ptr->conf_type)
          {
            case SS_STATUS_INFO:
              if(sups_info_ptr->ss_status.present && sups_info_ptr->ss_status.cm_ss_active)
              {
                ind->cf_data.sc_instances[0].service_status = QMI_VOICE_CM_SUPS_STATUS_ACTIVE;
               
              }
              else
              {
                ind->cf_data.sc_instances[0].service_status = QMI_VOICE_CM_SUPS_STATUS_IN_ACTIVE;
              }
              ind->cf_data.sc_instances[0].service_class = QMI_VOICE_CM_SUPS_CLASS_ALL;
              ind->cf_data.num_cfw_instances = 1;
              break;

            case FWD_FEATURE_LIST_INFO:
              if (!sups_info_ptr->fwd_feature_list.present)
              {
                QM_MSG_ERROR("Fowarding feature list info missing ");
                break;
              }

              /* Report for each forwarding registration */
              while (sups_info_ptr->fwd_feature_list.forwarding_feature_list_length > count)
              {
                const forwarding_feature_T * fflist_ptr =
                  &sups_info_ptr->fwd_feature_list.forwarding_feature[count];

                uint8 j = 0;
                uint32 service_class = 0;
                int no_reply_timer = 0;
                boolean fwd_num_present = FALSE;
                /* Size temp buffer for address, subaddress, and various other characters */
            #define MAX_CCFC_ADDRESS_SIZE (2 * CM_CALLED_PARTY_BCD_NO_LENGTH * \
                                                   (2*MAXNO_FORWARD_TO_NUMBER))
                byte address[MAX_CCFC_ADDRESS_SIZE];
                byte buffer[MAX_CCFC_ADDRESS_SIZE];
                byte * a_ptr = &address[1];
                uint8 a_length = 0;
                byte * s_ptr = buffer;
                
                status = 0;
                memset((void*)buffer, 0, sizeof(buffer));
                memset((void*)address, 0, sizeof(address));

                status = ((fflist_ptr->ss_status.present &&
                           fflist_ptr->ss_status.cm_ss_active)? QMI_VOICE_CM_SUPS_STATUS_ACTIVE : QMI_VOICE_CM_SUPS_STATUS_IN_ACTIVE);


                QM_MSG_HIGH_2("Stored Service class = %d, Basic service present =%d", ss_list_info->ss_service_class, fflist_ptr->basic_service.present);

                if(!fflist_ptr->basic_service.present && (ss_list_info->ss_service_class == 0))
                {
                  service_class = QMI_VOICE_CM_SUPS_CLASS_ALL;
                }
                else if(!fflist_ptr->basic_service.present && (ss_list_info->ss_service_class != 0))
                {
                  service_class = ss_list_info->ss_service_class;
                }
                else
                {
                  service_class = qmi_voice_cm_sups_get_service_class(fflist_ptr->basic_service.code_type,
                                                               fflist_ptr->basic_service.bs_code);
                }

                /* Decode  number */
                /* though it has been written to handle multiple call forward to number
                   as of now we are not aware of such scenario where multiple call forward
                   to number is sent by network */

                while ( j < (2*MAXNO_FORWARD_TO_NUMBER) )
                {
                   /* Check for availability */
                   if (fflist_ptr->forwarded_to_number[j].present)
                   {
                     uint8 k;
                      fwd_num_present = TRUE;
                     /* Append number segment to existing buffer */
                      for (k=0; k < fflist_ptr->forwarded_to_number[j].length; k++)
                      {
                         *a_ptr++ = fflist_ptr->forwarded_to_number[j].data[k];
                      }
                      a_length += fflist_ptr->forwarded_to_number[j].length;
                   }
                   j++;
                }
                address[0] = a_length;

                /* Convert from BCD to ASCII string */
                if (a_ptr != &address[1])
                {
                   (void)cm_util_bcd_num_to_ascii_num(address, s_ptr, sizeof(buffer));

                   /* removing the first charecter which indicates type*/
                   s_ptr = s_ptr + 1;
                }


                /* Decode timer */
                if (fflist_ptr->no_reply_condition_timer.present)
                {
                  no_reply_timer = fflist_ptr->no_reply_condition_timer.timer_value;
                }

                ind->cf_data.sc_instances[count].service_status = status;
                ind->cf_data.sc_instances[count].no_reply_timer = no_reply_timer;
				  ind->cf_data.sc_instances[count].service_class = (uint8) service_class;
                if(fwd_num_present)
                {
                  ind->cf_data.sc_instances[count].num_len = strlen((char*)s_ptr)+1;
                  if(ind->cf_data.sc_instances[count].num_len < QMI_VOICE_CM_IF_MAX_CALLING_NUM_LEN )
                  {
                    memscpy(ind->cf_data.sc_instances[count].num_buf,sizeof(ind->cf_data.sc_instances[count].num_buf), buffer, ind->cf_data.sc_instances[count].num_len);
                  }
                }
                count++;
              } /* for each fwding registration */
              QM_MSG_MED_1("Number of instances = %d", count);
              ind->cf_data.num_cfw_instances = count;
              break;

            case CC_CAUSE_INFO:
            case SS_ERROR_INFO:
              //Recieved CALL FORWARDING resp with Error confirmation type  = %d", sups_info_ptr->conf_type);
              ind->is_failure_cause_valid = TRUE;
              ind->sups_failure_cause = qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              break;

            case FWD_INFO:
            case SS_DATA_INFO:
            case NO_INFO:
              //Received Call forwarding resp with conf type %d", sups_info_ptr->conf_type);
              ind->cf_data.num_cfw_instances = 0;
              break;
            
            default:
              //Entered the default case for call forwarding conf type = %d", sups_info_ptr->conf_type);
              break;
          }
        }
        break;
      default:
        if(event == QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF)
        {
          QM_MSG_MED_1(" USS Conf, conf_type=%d", sups_info_ptr->conf_type);
          switch(sups_info_ptr->conf_type)
          {
            case CC_CAUSE_INFO:   /* Network rejected request */
            case SS_ERROR_INFO:
              //Recieved USS Conf from netwk with Error confirmation type sups_info_ptr->conf_type);
              ind->is_failure_cause_valid = TRUE;
              ind->sups_failure_cause = qmi_voice_cm_if_map_sups_event_error_to_qmi(sups_info_ptr->ss_error,sups_info_ptr->cc_cause);
              break;
            default:
              //Entered the default case for USS Conf, conf_type=%d", sups_info_ptr->conf_type);
              break;
          }
        }
        break;
    }
  }

  if(bs_class != 0)
  {
    ind->is_service_class_available = TRUE;
    ind->is_service_class_ext_available = TRUE;
	
    ind->service_class = (uint8) (bs_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
    ind->service_class_ext= bs_class;
  }

}/* qmi_voice_cm_if_fill_sups_ntwk_resp */


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_sups_event_sups_ind

===========================================================================*/
/*!
    @brief
    Indicates origination of supplementary services at modem/.
           QMI_VOICE_CM_IF_CMD_SUPS_IND

    @return
    None.
*/
/*=========================================================================*/
void qmi_voice_cm_if_sups_event_sups_ind
(
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *cm_info,
  qmi_voice_cm_if_cc_result_e_type cc_result
)
{
  qmi_voice_cm_if_sups_ind_s *ind;
  qmi_voice_cm_if_ussd_info_s *uss_info;
  qmi_voice_cm_sups_reason_code_e_type reason=QMI_VOICE_CM_SUPS_REASON_MAX;
  qmi_voice_cm_sups_service_type_e_type service_type=QMI_VOICE_CM_SUPS_SERVICE_TYPE_INVALID;
  qmi_voice_cmd_list_public_type list_info;
  qmi_voice_cm_if_evt_e_type ntwk_rsp_evt;
  cm_ussd_dcs_e_type dcs=CM_USSD_DCS_UNSPECIFIED;
  uint32 service_class;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  uint8 i;

  /*-----------------------------------------------------------------------*/

  ASSERT( cm_info != NULL );

  /*-----------------------------------------------------------------------*/
  ind = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(qmi_voice_cm_if_sups_ind_s));
  if( NULL == ind )
  {
	  qmi_voice_mem_fatal();
    return;
  }
  memset( ind, 0, sizeof( qmi_voice_cm_if_sups_ind_s ) );
  uss_info = (qmi_voice_cm_if_ussd_info_s *)&ind->uss_info;

#ifdef FEATURE_DUAL_SIM
	as_id = (uint8)cm_info->asubs_id;
#endif


  service_type = qmi_voice_cm_sups_get_service_type_from_event(event);

  if( service_type != QMI_VOICE_CM_SUPS_SERVICE_TYPE_INVALID)
  {
    ind->service_type = (uint8)service_type;
  }

  if( cc_result != QMI_VOICE_CM_IF_CC_RESULT_NO_MODIFICATIONS )
  {
    ind->is_modified_by_call_control = TRUE;
  }

  ind->is_ntwk_resp = qmi_voice_cm_sups_is_network_resp_event(event);

  /* Optional data starts here */
  if((reason=qmi_voice_cm_sups_get_reason_from_ss_code(cm_info->ss_code)) != QMI_VOICE_CM_SUPS_REASON_NONE)
  {
    ind->is_reason_available = TRUE;
    ind->reason = (uint8) reason;
  }

  if (!ind->is_ntwk_resp)
  {
    if(cm_info->basic_service.present)
    {
      ind->is_service_class_available = TRUE;
      ind->is_service_class_ext_available = TRUE;
      service_class = qmi_voice_cm_sups_get_service_class( cm_info->basic_service.code_type,(int)cm_info->basic_service.bs_code);

      ind->service_class =(uint8) (service_class & QMI_VOICE_CM_SUPS_CLASS_ALL);
      ind->service_class_ext= service_class;
    }

    if((cm_info->forwarded_to_number.present == TRUE) && (cm_info->forwarded_to_number.length > 0))
    {
      ind->is_cfw_number_available = TRUE;
      ind->num_len = cm_info->forwarded_to_number.length;
      memscpy(ind->num_buf,sizeof(ind->num_buf),cm_info->forwarded_to_number.data,cm_info->forwarded_to_number.length);
    }

    if(cm_info->nr_timer.present)
    {
      ind->is_cfw_nrtimer_available = TRUE;
      ind->no_reply_timer = cm_info->nr_timer.timer_value;
    }
  }
  else
  {
    qmi_voice_cm_if_fill_sups_ntwk_resp(event, ind, cm_info);
  }

  if((cm_info->uss_data.present == TRUE) && !(ind->is_failure_cause_valid))
  {
    uss_data_T  *cm_data = &cm_info->uss_data;

    dcs = qmi_voice_cm_util_get_ussd_dcs( cm_data->uss_data_coding_scheme );
    uss_info->uss_len = MIN(sizeof(uss_info->uss_data), cm_data->size);
    if(dcs == CM_USSD_DCS_8_BIT)
    {
      uss_info->uss_dcs = QMI_VOICE_CM_IF_USSD_DCS_USER_DEF_8_BIT;
      memscpy(uss_info->uss_data, sizeof(uss_info->uss_data), cm_data->ussData, uss_info->uss_len);
    }
    else if(dcs == CM_USSD_DCS_UCS2)
    {
      /* Special handling for UCS2 preceded by two GSM 7-bit alphabet. Ignore the first two bytes which represent language indicator. */
      if(0x11 == cm_data->uss_data_coding_scheme)
      {
        memscpy(uss_info->uss_data, sizeof(uss_info->uss_data), &cm_data->ussData[2], (uss_info->uss_len-2));
        uss_info->uss_len = uss_info->uss_len - 2;
      }
      else
      {
        memscpy(uss_info->uss_data, sizeof(uss_info->uss_data), cm_data->ussData, uss_info->uss_len);
      }
      uss_info->uss_dcs = QMI_VOICE_CM_IF_USSD_DCS_UCS2;
    }
    else if(dcs == CM_USSD_DCS_7_BIT)
    {
      if( cm_info->uss_data_type == CM_USS_PHASE1_TYPE )
      {
        QM_MSG_MED("Received PHASE1 USSD ");
        memscpy( uss_info->uss_data,sizeof(uss_info->uss_data), cm_data->ussData, uss_info->uss_len  );
        uss_info->uss_dcs = QMI_VOICE_CM_IF_USSD_DCS_ASCII;
      }
      else
      {
        size_t response_len_asci=0;
        size_t response_len_ucs2=0;

        //Since cm_util_gsm7_to_iso8859 returns NULL terminated string, buffer needs to be one char bigger
        uint8 uss_temp_buffer[QMI_VOICE_CM_IF_MAX_USS_DATA_LEN+1];
        memset( uss_temp_buffer, '\0', sizeof( uss_temp_buffer ) );

        uss_info->uss_dcs = QMI_VOICE_CM_IF_USSD_DCS_ASCII;
        (void) cm_util_gsm7_to_iso8859(
                    cm_data->ussData, cm_data->size, TRUE,
                    uss_temp_buffer, sizeof(uss_temp_buffer),
                    &response_len_asci);

        if(response_len_asci > QMI_VOICE_CM_IF_MAX_USS_DATA_LEN)
        {
          uss_info->uss_len = QMI_VOICE_CM_IF_MAX_USS_DATA_LEN;
        }
        else
        {
          uss_info->uss_len = (uint8)response_len_asci;
        }
        memscpy(uss_info->uss_data,sizeof(uss_info->uss_data), uss_temp_buffer, uss_info->uss_len);

        //if (result & CHR_CVRT_INACCURATE) // Need to send both TLVs
      
        QM_MSG_MED_2( "%s length = %d", "UCS2 conversion",uss_info->uss_len);
        (void) cm_util_gsm7_to_utf16(
                    cm_data->ussData, cm_data->size, TRUE,
                    ind->ussd_info_utf16.ussd_data_utf16, sizeof(ind->ussd_info_utf16)/2,
                    &response_len_ucs2);
        ind->is_ussd_info_utf16_available = TRUE;
        ind->ussd_info_utf16.ussd_data_utf16_len = response_len_ucs2;
      }
    }
    else
    {
      QM_MSG_ERROR_1("Received unhandled DCS in sups ind = %d ", dcs);
    }
    ind->is_uss_available = TRUE;
  }

  if(QMI_VOICE_CM_IF_CC_RESULT_VOICE_MODIFIED_TO_SUPS == cc_result)
  {
    if(!ind->is_ntwk_resp)
    {
      /* Get the network resp event */
      ntwk_rsp_evt = qmi_voice_cm_sups_get_network_resp_event(event);
    }
    else
    {
      ntwk_rsp_evt = event;
    }
    
    if( qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)ntwk_rsp_evt,
                                            cm_info->ss_ref,
                                            &list_info, as_id) != E_SUCCESS )
    {
      QM_MSG_ERROR("Unable to find the cmd in the list");
    }

    if(QMI_VOICE_CM_IF_CMD_CALL_MOD_TO_SUPS == list_info.cmd)
    {
      ind->is_call_id_available = TRUE;
      ind->call_id = list_info.sub.sups.cc_mod_conn_idx;

      /* Remove the entry from cmd list if it is the event resulting from ntwk response */
      if ( ind->is_ntwk_resp && (qmi_voice_cmd_list_free( list_info.hdl ) != E_SUCCESS) )
      {
        //Failed to delete cmd list entry 
      }
    }
  }

  if(cm_info->cc_result_alpha.len > 0)
  {
    ind->is_alpha_available = TRUE;
    qmi_voice_cm_util_copy_alpha_info_from_cm(&(ind->alpha_info),&(cm_info->cc_result_alpha));
    QM_MSG_HIGH_2("Recevied ALPHA DCS from CM = %d, Voice = %d", cm_info->cc_result_alpha.dcs, ind->alpha_info.alpha_dcs);
  }

  if(cm_info->ss_password.present == TRUE)
  {
    memscpy(ind->pwd,sizeof(ind->pwd),cm_info->ss_password.ss_password,QMI_VOICE_CM_IF_MAX_PWD_LEN);
    ind->is_cb_pwd_available = TRUE;
  }

  if(cm_info->ss_new_password.present == TRUE)
  {
    memscpy(ind->new_pwd,sizeof(ind->new_pwd),cm_info->ss_new_password.ss_password,QMI_VOICE_CM_IF_MAX_PWD_LEN);
    ind->is_new_pwd_available = TRUE;
  }

  if(cm_info->ss_new_password_again.present == TRUE)
  {
    memscpy(ind->new_pwd_again,sizeof(ind->new_pwd_again),cm_info->ss_new_password_again.ss_password,QMI_VOICE_CM_IF_MAX_PWD_LEN);
    ind->is_new_pwd_available = TRUE;
  }

  if( 
      (cm_info->call_barring_num_list) && 
      (cm_info->ss_code == qmi_voice_cm_sups_bil) && 
      ( 
        (event == QMI_VOICE_CM_IF_EVT_SUPS_REGISTER) || 
        (event == QMI_VOICE_CM_IF_EVT_SUPS_ERASE) || 
        (event == QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE) || 
        (event == QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE)
      )
    )
  {
    if(cm_info->call_barring_num_list->call_barring_num)
    {
      ind->barr_num_list_len = cm_info->call_barring_num_list->call_barring_list_length;
      for(i=0; i<ind->barr_num_list_len && i<QMI_VOICE_CM_IF_MAX_BARR_LIST_LEN; i++)
      {
        ind->barr_num_list[i].barr_num_len = cm_info->call_barring_num_list->call_barring_num[i].length;
        memscpy(ind->barr_num_list[i].barr_num,
                QMI_VOICE_CM_IF_MAX_CALLING_NUM_LEN,
                cm_info->call_barring_num_list->call_barring_num[i].data,
                cm_info->call_barring_num_list->call_barring_num[i].length);
      }
      ind->barr_num_list_valid = TRUE;
    }
    else
    {
      QM_MSG_MED("Received NULL for cm_info->call_barring_num_list->call_barring_num");
    }
  }
  else
  {
    QM_MSG_MED("Received NULL for cm_info->call_barring_num_list");
  }

  qmi_voice_cm_if_unsol_response( QMI_VOICE_CM_IF_CMD_SUPS_IND, (void *) ind, sizeof( qmi_voice_cm_if_sups_ind_s ), as_id );

  QMI_VOICE_CM_IF_MEM_FREE(ind);
} /* qmi_voice_cm_if_sups_event_sups_ind */

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_call_speech_codec_info_ind

===========================================================================*/
/*!
    @brief
    Indicates the speech codec information to clients.

    @return
    None.
*/
/*=========================================================================*/

static void qmi_voice_cm_if_call_speech_codec_info_ind
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  voice_speech_codec_info_ind_msg_v02 codec_info;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  uint8 conn_idx=0;

#ifdef FEATURE_DUAL_SIM
  as_id = call_info_ptr->asubs_id;
#endif
  memset(&codec_info,0,sizeof(codec_info));

  if( qmi_voice_call_list_get_conn_idx_from_call_id( call_info_ptr->call_id, &conn_idx ) != E_SUCCESS )
  {
    QM_MSG_MED_1("speech_codec_info_ind :: No call exist with call_id = %d in the list", call_info_ptr->call_id);
  }
  else
  {
    codec_info.call_id_valid = TRUE;
    codec_info.call_id              = conn_idx;
  }

  codec_info.network_mode_valid = TRUE;
  codec_info.network_mode = (voice_network_mode_enum_v02)call_info_ptr->speech_codec_info.network_mode;
  codec_info.speech_codec_valid = TRUE;
  codec_info.speech_codec = (voice_speech_codec_enum_v02)call_info_ptr->speech_codec_info.speech_codec_type;
  codec_info.speech_enc_samp_freq_valid = TRUE;
  codec_info.speech_enc_samp_freq  = (uint32)call_info_ptr->speech_codec_info.speech_enc_samp_freq;
  qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_SPEECH_CODEC_INFO_IND,(void *) &codec_info, sizeof(codec_info), as_id);

}/* qmi_voice_cm_if_call_speech_codec_info_ind */

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_send_conf_info_ind

===========================================================================*/
/*!
    @brief
    This indication will send the conference information to the control points.
    This info is received from CM with CM_CALL_EVENT_REFRESH_CONF_CALL_PARTICIPANTS event.

    @return
    None.
*/
/*=========================================================================*/

static void qmi_voice_cm_if_send_conf_info_ind
(
  cm_mm_call_info_s_type *call_info_ptr
)
{

  voice_conference_info_ind_msg_v02 *conf_info;  

  cm_conference_info_s_type *cm_conf_info;
  uint8 conn_idx=0,num_indications=0,ind=0;
  uint32 xml_length=0;
  uint8 *xml_ptr=NULL;
  uint8 *ptr_begin;
  uint32 copy_length=0;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

#ifdef FEATURE_DUAL_SIM
  as_id = call_info_ptr->asubs_id;
#endif

  cm_conf_info = (cm_conference_info_s_type *) call_info_ptr->mode_info.info.ip_call.conference_info;

  if(cm_conf_info == NULL)
  {
    QM_MSG_MED("cm_conf_info is NULL");
    return;
  }  

  conf_info = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*conf_info));
  if( NULL == conf_info )
  {
	  qmi_voice_mem_fatal();
    return;
  }
  
  // check if a call exists for the incoming call event
  if( qmi_voice_call_list_get_conn_idx_from_call_id( call_info_ptr->call_id, &conn_idx ) != E_SUCCESS )
  {
    QM_MSG_MED_1("No call exist with call_id = %d in the list", call_info_ptr->call_id);
    QMI_VOICE_CM_IF_MEM_FREE(conf_info);
    return;
  }

  xml_ptr = cm_conf_info->conference_xml;
  xml_length = (uint32) strlen( (char*) cm_conf_info->conference_xml);
  num_indications = (int)(xml_length/QMI_VOICE_CONF_XML_MAX_LEN) + 1;
  
  QM_MSG_MED_2("num_indications=%d, conn_idx=%d", num_indications, conn_idx);
  for(ind=0;ind<num_indications;ind++)
  {
    QM_MSG_MED_1("Sending Indication Number=%d", ind+1);
    memset( conf_info, 0, sizeof(*conf_info) );
    conf_info->sequence = ind;
    if(conf_info->sequence == 0) conf_info->total_size_valid = TRUE;
    conf_info->total_size = xml_length;
    conf_info->call_id_valid = TRUE;
    conf_info->call_id = conn_idx;
    
    ptr_begin = xml_ptr+(ind*QMI_VOICE_CONF_XML_MAX_LEN);
    if(ind == num_indications-1)
    {
      copy_length = xml_length - (ind*QMI_VOICE_CONF_XML_MAX_LEN);
    }
    else
    {
      copy_length = QMI_VOICE_CONF_XML_MAX_LEN;
    }
    QM_MSG_MED_1("copy: copy_len=%d", copy_length);
    conf_info->conference_xml_len = copy_length;
    memscpy(conf_info->conference_xml,sizeof(conf_info->conference_xml),ptr_begin,copy_length);

    //Send indication for every 2k of XMl string
    qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_CONF_INFO_IND,(void *)conf_info, sizeof(*conf_info), as_id);
  }
 
    QMI_VOICE_CM_IF_MEM_FREE(conf_info);
}/* qmi_voice_cm_if_send_conf_info_ind */


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_send_additional_call_info_ind

===========================================================================*/
/*!
    @brief
    This indication will send the conference information to the control points.
    This info is received from CM with CM_CALL_EVENT_REFRESH_CONF_CALL_PARTICIPANTS event.

    @return
    None.
*/
/*=========================================================================*/

static void qmi_voice_cm_if_send_additional_call_info_ind
(
  cm_mm_call_info_s_type *call_info_ptr
)
{

  voice_additional_call_info_ind_msg_v02 *call_info;

  cm_ip_caller_info_s_type *cm_call_info;
  uint8 conn_idx=0,num_indications=0,ind=0;
  uint32 info_length=0;
  uint8 *info_ptr=NULL;
  uint8 *ptr_begin;
  uint32 copy_length=0;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

#ifdef FEATURE_DUAL_SIM
  as_id = call_info_ptr->asubs_id;
#endif

  cm_call_info = (cm_ip_caller_info_s_type *) call_info_ptr->mode_info.info.ip_call.caller_info;

  if(cm_call_info == NULL)
  {
    QM_MSG_MED("ip_call.caller_info is NULL");
    return;
  }  

  // Allocate memory to the conf_info structure
  call_info = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*call_info));
  if( NULL == call_info )
  {
	  qmi_voice_mem_fatal();
    return;
  }
  
  // check if a call exists for the incoming call event
  if( qmi_voice_call_list_get_conn_idx_from_call_id( call_info_ptr->call_id, &conn_idx ) != E_SUCCESS )
  {
    QM_MSG_MED_1( "No call exist with call_id = %d in the list", call_info_ptr->call_id);
    QMI_VOICE_CM_IF_MEM_FREE(call_info);
    return;
  }

  //START using conference_info;
  info_ptr = cm_call_info->info_text;
  info_length = (uint32) cm_call_info->info_len;
  num_indications = (int)(info_length/QMI_VOICE_CONF_ADNL_CALL_INFO_MAX_LEN) + 1;
  
  QM_MSG_MED_2( "num_indications=%d,conn_idx=%d",num_indications,conn_idx);
  for(ind=0;ind<num_indications;ind++)
  {
    QM_MSG_MED_1( "Sending Indication Number=%d",ind+1);
    memset( call_info, 0, sizeof(*call_info) );
    call_info->extension_header_info_valid = TRUE;
    call_info->extension_header_info.sequence = ind;
    call_info->extension_header_info.total_size = info_length;
    call_info->call_id = conn_idx;
    
    ptr_begin = info_ptr+(ind*QMI_VOICE_CONF_ADNL_CALL_INFO_MAX_LEN);
    if(ind == num_indications-1)
    {
      copy_length = info_length - (ind*QMI_VOICE_CONF_ADNL_CALL_INFO_MAX_LEN);
    }
    else
    {
      copy_length = QMI_VOICE_CONF_ADNL_CALL_INFO_MAX_LEN;
    }
    QM_MSG_MED_1( "copy: copy_len=%d",copy_length);
    call_info->extension_header_info.additional_call_info_len = copy_length;
    memscpy(call_info->extension_header_info.additional_call_info, QMI_VOICE_ADDITIONAL_INFO_MAX_LEN_V02, ptr_begin, copy_length);

    //Send indication for every 2k of call info string
    qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_ADDITIONAL_CALL_INFO_IND,(void *) call_info, sizeof(*call_info), as_id);
  }
 
  if(call_info!=NULL)
  {
    QMI_VOICE_CM_IF_MEM_FREE(call_info);
  }
}/* qmi_voice_cm_if_send_additional_call_info_ind */


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_send_conf_join_ind

===========================================================================*/
/*!
    @brief
    This indication will send the info of a newly joined participant to all the user on conference call
    This info is received from CM with  CM_CALL_EVENT_JOIN_CONFERENCE event.

    @return
    None.
*/
/*=========================================================================*/
static void qmi_voice_cm_if_send_conf_join_ind
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  voice_conference_join_ind_msg_v02 *join_ind;

  const cm_usr_uri_s_type *cm_participant_info;
  uint8 conn_idx=0;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

#ifdef FEATURE_DUAL_SIM
  as_id = call_info_ptr->asubs_id;
#endif
  
  if(call_info_ptr->mode_info.info.ip_call.participant_uri == NULL)
  {
    //Participant_uri field is NULL
    return;
  }
  else if(call_info_ptr->mode_info.info.ip_call.participant_uri->uris == NULL)
  {
    //Participant_uri->uris field is NULL
    return;
  }
  QM_MSG_MED_2("p_participant_uri: % d, p_participant_uri->uris: %d",call_info_ptr->mode_info.info.ip_call.participant_uri,
                                                                     call_info_ptr->mode_info.info.ip_call.participant_uri->uris);
  cm_participant_info = call_info_ptr->mode_info.info.ip_call.participant_uri->uris[0];

  if(cm_participant_info == NULL)
  {
    QM_MSG_MED("Participant URI is NULL");
    return;
  }

  join_ind = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*join_ind));
  if( NULL == join_ind )
  {
	  qmi_voice_mem_fatal();
    return;
  }
  memset( join_ind, 0, sizeof(*join_ind) );

  // check if a call exists for the incoming call event
  if( qmi_voice_call_list_get_conn_idx_from_call_id( call_info_ptr->call_id, &conn_idx ) != E_SUCCESS )
  {
    QM_MSG_MED_1("No call exist with call_id = %d in the list", call_info_ptr->call_id);
      QMI_VOICE_CM_IF_MEM_FREE(join_ind);
    return;
  }
  else
  {
    join_ind->call_id = conn_idx;
  }

  join_ind->participant_uri.uri_name_len = qmi_wstrlen(cm_participant_info->uri_name);
  memscpy(join_ind->participant_uri.uri_name, sizeof(join_ind->participant_uri.uri_name), cm_participant_info->uri_name, 2*(join_ind->participant_uri.uri_name_len));
  //QM_MSG_MED_1("URI Name len=%d", join_ind->participant_uri.uri_name_len);

  join_ind->participant_uri.uri_description_len = qmi_wstrlen(cm_participant_info->uri_description);
  memscpy(join_ind->participant_uri.uri_description, sizeof(join_ind->participant_uri.uri_description), cm_participant_info->uri_description, 2*(join_ind->participant_uri.uri_description_len));
  //QM_MSG_MED_1("URI Desc len=%d", join_ind->participant_uri.uri_description_len);

  QM_MSG_MED_2("URI Name len=%d, Desc len=%d", join_ind->participant_uri.uri_name_len, join_ind->participant_uri.uri_description_len);

  if (qmi_voice_call_list_set_mpty_status(call_info_ptr->call_id, TRUE) != E_SUCCESS)
  {
    QM_MSG_ERROR_1("Failed to update the multiparty status for call_id %d", call_info_ptr->call_id);
  }
  else
  {
    QM_MSG_MED("MPTY bit updated. An all_call_status_ind will be sent.");
    qmi_voice_call_list_report_all_call_status_changed(as_id);
  }

  qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_CONF_JOIN_IND, (void *)join_ind, sizeof(*join_ind), as_id);

    QMI_VOICE_CM_IF_MEM_FREE(join_ind);
}/* qmi_voice_cm_if_send_conf_join_ind */



/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_send_conference_participant_update_ind

===========================================================================*/
/*!
    @brief

    @return
    None.
*/
/*=========================================================================*/

static void qmi_voice_cm_if_send_conference_participant_update_ind
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  voice_conference_participant_update_ind_msg_v02 *participant_ind;

  uint8 idx=0,num_participants=0;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

#ifdef FEATURE_DUAL_SIM
  as_id = call_info_ptr->asubs_id;
#endif

  num_participants = call_info_ptr->mode_info.info.ip_call.number_of_participants_add_removed;
  QM_MSG_MED_1("Num participants=%d", call_info_ptr->mode_info.info.ip_call.number_of_participants_add_removed);

  if(call_info_ptr->mode_info.info.ip_call.participant_uri == NULL)
  {
    //participant_uri field is NULL
    return;
  }
  else if(call_info_ptr->mode_info.info.ip_call.participant_uri->uris == NULL)
  {
    //participant_uri->uris field is NULL
    return;
  }
  QM_MSG_MED_2("p_participant_uri: % d, p_participant_uri->uris: %d",call_info_ptr->mode_info.info.ip_call.participant_uri, 
                call_info_ptr->mode_info.info.ip_call.participant_uri->uris);


  participant_ind = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*participant_ind));
  if( NULL == participant_ind )
  {
	  qmi_voice_mem_fatal();
    return;
  }
 
  for(idx=0;idx<num_participants;idx++)
  {
    const cm_usr_uri_s_type *cm_participant_info = call_info_ptr->mode_info.info.ip_call.participant_uri->uris[idx];
    memset( participant_ind, 0, sizeof(*participant_ind) );

    if(cm_participant_info != NULL)
    {
      participant_ind->participant_uri.uri_name_len = qmi_wstrlen(cm_participant_info->uri_name);
      memscpy(participant_ind->participant_uri.uri_name, sizeof(participant_ind->participant_uri.uri_name), cm_participant_info->uri_name, 2*(participant_ind->participant_uri.uri_name_len));
      QM_MSG_MED_1("participant_uri URI Name: Len=%d", participant_ind->participant_uri.uri_name_len);

      participant_ind->participant_uri.uri_description_len = qmi_wstrlen(cm_participant_info->uri_description);
      memscpy(participant_ind->participant_uri.uri_description, sizeof(participant_ind->participant_uri.uri_description), cm_participant_info->uri_description, 2*(participant_ind->participant_uri.uri_description_len));
      QM_MSG_MED_1("participant_uri URI Desc: Len=%d ", participant_ind->participant_uri.uri_description_len);
    }
    //else
    //{
     // QM_MSG_ERROR("Incorrect participant Number could not read participant info");
    //}

      //Sending one participant update ind for each participant
    qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_CONF_PARTICIPANT_UPDATE_IND,(void *) participant_ind, sizeof(*participant_ind), as_id);
  }

    QMI_VOICE_CM_IF_MEM_FREE(participant_ind);
}/* qmi_voice_cm_if_send_conference_participant_update_ind */

/*===========================================================================
  FUNCTION qmi_voice_cm_if_report_rat_change()

  DESCRIPTION
    Send ALL_CALL_STATUS indication when rat change happens for a particular call.

  PARAMETERS
    event          : Call event received

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_report_rat_change
(
    cm_mm_call_info_s_type *call_info_ptr
)
{
  /*-----------------------------------------------------------------------*/
  ASSERT( call_info_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  QM_MSG_MED_1("call mode change for a voice call (id:  %d)", call_info_ptr->call_id);
  QM_MSG_MED_2("qmi_voice_cm_if_report_rat_change: sys_mode=%d, mode_info_type=%d)", call_info_ptr->sys_mode, call_info_ptr->mode_info.info_type); 

  //Update the call mode and mode info type and send all call status indication
  if ( (qmi_voice_call_list_update_call_mode( call_info_ptr->call_id,call_info_ptr->sys_mode) == E_SUCCESS ) &&
       (qmi_voice_call_list_update_mode_info_type(call_info_ptr->call_id, call_info_ptr->mode_info.info_type ) == E_SUCCESS ) )
  {
    QM_MSG_MED_1("update in the call_mode and mode_info_type for call id:%d", call_info_ptr->call_id);
    qmi_voice_call_list_report_all_call_status_changed(call_info_ptr->asubs_id);
  }
 // else
  //{
    //QM_MSG_ERROR_1("Fail to update the call_mode or mode_info_type %d", call_info_ptr->call_id);
 // }
}/*qmi_voice_cm_if_report_rat_change*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SECURE_CALL_MODE()

  DESCRIPTION
    Invoke CM API to inform a secure call.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_call_encryption_req
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
) 
{
  uint8 as_id=QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  qmi_voice_call_list_public_type call_info;


  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/

#ifdef FEATURE_DUAL_SIM
  as_id=params_ptr->header.as_id;
#endif
  /* Setup response will be sent. Add entry to ReqList */
  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle, QMI_VOICE_CMD_AWAITING_CALLBACK,  
                         QMI_VOICE_CM_IF_EVT_NONE, 0, NULL, 0, params_ptr->header.as_id) != E_SUCCESS ) 
  {
    /* Out of ReqList buffer, send RIL_E_GENERIC_FAILURE response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd, QMI_ERR_INTERNAL, FALSE, FALSE );
    return;
  }

  qmi_voice_call_list_update_secure_call_info(params_ptr->data.call_encryption_req.call_id,
                                                 params_ptr->data.call_encryption_req.secure_context_established);

  /* Lookup Call ID */
	if (qmi_voice_call_list_query_by_conn_index(params_ptr->data.call_encryption_req.call_id, &call_info) != E_SUCCESS)
  {
		qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INVALID_ID, TRUE, FALSE);
		return;
  }

	if (!cm_mm_call_cmd_inform_secure_context_info(qmi_voice_cm_if_call_encryption_callback,
		(void*)params_ptr->header.handle,
                            qmi_voice_cm_if_get_clientid(),
                            call_info.call_id,
                            params_ptr->data.call_encryption_req.secure_context_established))
  {
    QM_MSG_ERROR("Call to cm_mm_call_cmd_inform_secure_context_info failed ");
		qmi_voice_cm_if_response_error(params_ptr->header.handle, params_ptr->header.cmd, QMI_ERR_INTERNAL, TRUE, TRUE);
  }
}/* qmi_voice_cm_if_call_encryption_req() */
  
  /*===========================================================================
	FUNCTION QMI_VOICE_CM_IF_CALL_ENCRYPTION_CALLBACK()
  
	DESCRIPTION
	  Call command callback to be invoked by CM
  
	PARAMETERS
	  None
  
	RETURN VALUE
	  None
  
	DEPENDENCIES
	  None
  
	SIDE EFFECTS
	  None
  ===========================================================================*/
  void qmi_voice_cm_if_call_encryption_callback
  (
	void				  *data_block_ptr,
	cm_call_cmd_e_type	   call_cmd,
	cm_call_cmd_err_e_type call_cmd_err
  )
  {
	qmi_mmode_cmd_data_buf_type *cmd_ptr;
	
	QM_MSG_MED_1("Inside qmi_voice_cm_if_call_encryption_callback():%d", call_cmd_err);
  
	
	cmd_ptr = qmi_mmode_get_cmd_data_buf();
  
	if(NULL == cmd_ptr)
	{
		QM_MSG_FATAL("Out of cmd bufs in callsvc cmd callback");
	  return;
	}
	cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
	if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
	{
	  QM_MSG_FATAL("Can't allocate memory in callsvc cmd cb");
	  qmi_mmode_free_cmd_data_buf(cmd_ptr);
	  return;
	}
	
	cmd_ptr->cmd.cm_if_data_ptr->header.cmd    = QMI_VOICE_CM_IF_CMD_CALL_ENCRYPTION_CMD_CB;
	cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)data_block_ptr;
  
	if(call_cmd_err == CM_CALL_CMD_ERR_NOERR)
	{
		cmd_ptr->cmd.cm_if_data_ptr->data.call_encryption_resp.resp.result = QMI_RESULT_SUCCESS_V01;
		cmd_ptr->cmd.cm_if_data_ptr->data.call_encryption_resp.resp.error	= QMI_ERR_NONE_V01;
	}
	else
	{
	   cmd_ptr->cmd.cm_if_data_ptr->data.call_encryption_resp.resp.result = QMI_RESULT_FAILURE_V01;
	   cmd_ptr->cmd.cm_if_data_ptr->data.call_encryption_resp.resp.error  = QMI_ERR_INTERNAL_V01;
	}
  
	qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);
  
  } /* qmi_voice_cm_if_secure_call_mode_call_back() */

  /*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SET_SECURE_CALL_FUNCTIONALITY()

  DESCRIPTION
    Set whether secure call functionality is configured or not.

  PARAMETERS
    params_ptr        : the qmi_voice_cm_if_info_item_s pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_secure_call_functionality_info
( 
  qmi_voice_cm_if_info_item_s *const params_ptr
)
{
  boolean cm_result;
  cm_als_line_switching_e_type switch_option;
  uint8 as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  /*-----------------------------------------------------------------------*/

  ASSERT( params_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  QM_MSG_MED_1("qmi_voice_cm_if_secure_call_functionality_info():  available: %d", params_ptr->data.set_config.secure_call_functionality_available);

#ifdef FEATURE_DUAL_SIM
  as_id = params_ptr->header.as_id;
#endif

  if ( qmi_voice_cmd_list_new( params_ptr->header.cmd, params_ptr->header.handle,
              QMI_VOICE_CMD_AWAITING_CALLBACK,
              QMI_VOICE_CM_IF_EVT_NONE,
              params_ptr->header.handle, NULL, 0, as_id ) != E_SUCCESS )
  {

    /* Out of cmd list buffer, send QMI_ERR_NO_MEMORY response */
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_NO_MEMORY,FALSE,FALSE);
    return;
  }

  cm_result = cm_ph_cmd_inform_secure_call_capability(qmi_voice_cm_if_ph_command_callback,
                                                      (void*)params_ptr->header.handle,
                                                      qmi_voice_cm_if_get_clientid(),
                                                      params_ptr->data.set_config.secure_call_functionality_available,
                                                      (sys_modem_as_id_e_type)as_id);

  if(!cm_result)
  {
    /* send QMI_ERR_INTERNAL response */
	QM_MSG_MED("cm_ph_cmd_inform_secure_call_capability() could not be called");
    qmi_voice_cm_if_response_error( params_ptr->header.handle,params_ptr->header.cmd,QMI_ERR_INTERNAL,TRUE,FALSE);
  }
} /* qmi_voice_cm_if_secure_call_functionality_info() */

/*===========================================================================
                    CALL COMMAND,EVENT CALLBACKS
===========================================================================*/


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALL_CMD_CB_HANDLER()

  DESCRIPTION
    Handle Call command callback here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_call_cmd_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
)
{
  qmi_error_e_type err_val = QMI_ERR_NONE;
  boolean cmd_exec_success = TRUE;
  qmi_voice_cmd_list_public_type cmd_info;
  void *response = NULL;
  size_t response_len=0;
  qmi_voice_cm_if_call_cmd_cb_s  *call_cmd_cb = (qmi_voice_cm_if_call_cmd_cb_s*)(&params_ptr->data);
  voice_answer_call_resp_msg_v02 answer_call_resp;
  voice_setup_answer_resp_msg_v02 setup_answer_resp;
  voice_end_call_resp_msg_v02 end_call_resp;
  voice_send_flash_resp_msg_v02 send_flash_resp;
  uint8 conn_idx = 0;

  ASSERT(params_ptr != NULL);
  
  memset(&answer_call_resp, 0, sizeof(answer_call_resp));
  memset(&setup_answer_resp, 0, sizeof(setup_answer_resp));
  memset(&end_call_resp, 0, sizeof(end_call_resp));
  memset(&send_flash_resp, 0, sizeof(send_flash_resp));
  
  if(call_cmd_cb->cmd_err != CM_CALL_CMD_ERR_NOERR )
  {
    QM_MSG_MED_2("Call command callback error %d received for cmd %d from CM", call_cmd_cb->cmd_err, call_cmd_cb->cmd);
    cmd_exec_success = FALSE;
    err_val = qmi_voice_cm_if_map_call_error_to_qmi(call_cmd_cb->cmd_err);
  }

  /* Entry found in the cmd list */
  if ( qmi_voice_cmd_list_query( params_ptr->header.handle, &cmd_info ) == E_SUCCESS )
  {
    /* Fail to execute the command */
    if ( !cmd_exec_success )
    {
      
      /* Send cmd FAILURE response */
      qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, err_val, TRUE , TRUE );
      return;
    }
    /* Not pending for AMSS events */
    else if ( cmd_info.pending_event_id == QMI_VOICE_CM_IF_EVT_NONE )
    {
      switch(call_cmd_cb->cmd)
      {
        case CM_CALL_CMD_ANSWER:
          if(qmi_voice_call_list_get_conn_idx_from_call_id( (cm_call_id_type) cmd_info.sub_id, &conn_idx ) == E_SUCCESS)
          {
            //QM_MSG_MED_1("Found the conn index = %d in the list", conn_idx);
          }
          answer_call_resp.call_id_valid = TRUE;
          answer_call_resp.call_id = conn_idx;
          response = &answer_call_resp;
          response_len = sizeof(answer_call_resp);
          break;

        case CM_CALL_CMD_SETUP_RES:
          memset(&setup_answer_resp,0,sizeof(setup_answer_resp));

          if(qmi_voice_call_list_get_conn_idx_from_call_id( (cm_call_id_type) cmd_info.sub_id, &conn_idx ) == E_SUCCESS)
          {
            //QM_MSG_MED_1("Found the conn index = %d in the list", conn_idx);
          }
          setup_answer_resp.call_id_valid = TRUE;
          setup_answer_resp.call_id = conn_idx;
          response = &setup_answer_resp;
          response_len = sizeof(setup_answer_resp);
          break;

        case CM_CALL_CMD_END:
          if( ((cmd_info.cmd == QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_CALLS) && (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_CALLS_END_ALL_CALLS )) ||
              ((cmd_info.cmd == QMI_VOICE_CM_IF_CMD_SUPS_MANAGE_IP_CALLS) && (cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_END_ALL_CALLS )) )
          {
            QM_MSG_MED_1("Call Command End success for sups_type :  %d in end_all_calls", cmd_info.sub_id);
            qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, response, response_len, TRUE );
            return;
          }
          else
          {
            if(qmi_voice_call_list_get_conn_idx_from_call_id( (cm_call_id_type) cmd_info.sub_id, &conn_idx ) == E_SUCCESS)
            {
              //QM_MSG_MED_1("Found the conn index = %d in the list", conn_idx);
            }
            end_call_resp.call_id_valid = TRUE;
            end_call_resp.call_id = conn_idx;
            response = &end_call_resp;
            response_len = sizeof(end_call_resp);
          }
          break;

        case CM_CALL_CMD_SUPS:
          if(qmi_voice_call_list_get_conn_idx_from_call_id( (cm_call_id_type) cmd_info.sub_id, &conn_idx ) == E_SUCCESS)
          {
            //QM_MSG_MED_1("Found the conn index = %d in the list", conn_idx);
          }
          send_flash_resp.call_id_valid = TRUE;
          send_flash_resp.call_id = conn_idx;
          response = &send_flash_resp;
          response_len = sizeof(send_flash_resp);
          break;

        case CM_CALL_CMD_PRIVACY_PREF:
          /* No response data for SET PRIVACY PREF */
          response = NULL;
          response_len = 0;
          break;

        case CM_CALL_CMD_LOCAL_HOLD:
          /* No response data */
          break;

        case CM_CALL_CMD_MO_MODIFY_REQ:
          break;

        default:
          QM_MSG_ERROR("Unsupported CM command");
          return;
      }
      /* Send cmd SUCCESS response */
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, response, response_len, TRUE );
    }
    /* Force state transition to WaitingMoreAMSSEvents */
    else
    {
      qmi_voice_cm_if_force_state_transition_to_wait_amss_event( cmd_info.hdl, cmd_info.cmd, cmd_info.pending_event_id );
    }
  }
  /* Entry not found in the cmd List */
  else if ( params_ptr->header.handle != QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL )
  {
    QM_MSG_ERROR_1("Cmd list entry not found :  handle %d", params_ptr->header.handle);
  }
} /* qmi_voice_cm_if_call_cmd_cb_handler() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALLSVC_COMMAND_CALLBACK()

  DESCRIPTION
    Call command callback to be invoked by CM

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_callsvc_command_callback
(
  void                  *data_block_ptr,
  cm_call_cmd_e_type     call_cmd,
  cm_call_cmd_err_e_type call_cmd_err
)
{
  qmi_mmode_cmd_data_buf_type *cmd_ptr;
  

  
  cmd_ptr = qmi_mmode_get_cmd_data_buf();

  if(NULL == cmd_ptr)
  {
	  qmi_voice_cmd_fatal();
    return;
  }
  cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
  if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(cmd_ptr);
    return;
  }
  
  cmd_ptr->cmd.cm_if_data_ptr->header.cmd    = QMI_VOICE_CM_IF_CMD_CALL_CMD_CB;
  cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)data_block_ptr;

  /* Call CM command callback event handler */
  cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_cb.cmd     = call_cmd;
  cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_cb.cmd_err = call_cmd_err;
  
  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);

} /* qmi_voice_cm_if_callsvc_command_callback() */



/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALL_CMD_CB_HANDLER()

  DESCRIPTION
    Handle Call command callback here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_call_cmd_exten_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
)
{
  qmi_error_e_type err_val = QMI_ERR_NONE;
  boolean cmd_exec_success = TRUE;
  qmi_voice_cmd_list_public_type cmd_info;
  void *response = NULL;
  size_t response_len;
  qmi_voice_cm_if_call_cmd_exten_cb_s  *call_cmd_exten_cb = (qmi_voice_cm_if_call_cmd_exten_cb_s*)(&params_ptr->data);
  voice_dial_call_resp_msg_v02  dial_call_resp;
  uint16 fail_cause = QMI_FAILURE_CAUSE_NORMAL_UNSPECIFIED;


  ASSERT(params_ptr != NULL);

  memset(&dial_call_resp, 0, sizeof(dial_call_resp));

  if(call_cmd_exten_cb->cmd_err != CM_CALL_CMD_ERR_NOERR )
  {
    cmd_exec_success = FALSE;
    if( call_cmd_exten_cb->cmd_err != CM_CALL_CMD_ERR_CALL_CONTROL_REJECTED )
    {
      err_val = qmi_voice_cm_if_map_call_error_to_qmi(call_cmd_exten_cb->cmd_err);
      if(call_cmd_exten_cb->cmd_err == CM_CALL_CMD_ERR_REJECT_DURING_INCOMING_CALL)
      {
        dial_call_resp.end_reason_valid = TRUE;
        fail_cause = QMI_FAILURE_CAUSE_INCOM_CALL;
      }
      else if(call_cmd_exten_cb->cmd_err == CM_CALL_CMD_ERR_SSAC_REJECT)
      {
        dial_call_resp.end_reason_valid = TRUE;
        fail_cause = QMI_VOICE_CM_IF_END_SSAC_REJECT;
      }
      else if(call_cmd_exten_cb->cmd_err == CM_CALL_CMD_ERR_IN_USE_S)
      {
        dial_call_resp.end_reason_valid = TRUE;
        fail_cause = QMI_FAILURE_CAUSE_INCOMPATIBLE;
      }
      else if(call_cmd_exten_cb->cmd_err == CM_CALL_CMD_ERR_DRVCC_IN_PROG)
      {
        dial_call_resp.end_reason_valid = TRUE;
        fail_cause = QMI_FAILURE_CAUSE_DRVCC_IN_PROG;
      }

    }
    else
    {
      switch(call_cmd_exten_cb->call_cmd_err_cause)
      {
        case CM_CALL_CMD_ERR_CAUSE_FDN_FAIL:
          err_val = QMI_ERR_FDN_RESTRICT;
          break;
        case CM_CALL_CMD_ERR_CAUSE_NO_SUBSC:
          err_val = QMI_ERR_NO_SUBSCRIPTION;
          break;
        case CM_CALL_CMD_ERR_CAUSE_CARD_CC_FAIL:
          err_val = QMI_ERR_CARD_CALL_CONTROL_FAILED;
          break;
        default:
          err_val = QMI_ERR_INTERNAL;
          break;
      }
      fail_cause = QMI_FAILURE_CAUSE_CALL_REJECTED;
    }
    dial_call_resp.end_reason = (call_end_reason_enum_v02)fail_cause;
  }

  /* fill the call control alpha if present */
  if(call_cmd_exten_cb->alpha.len > 0)
  {
    dial_call_resp.alpha_ident_valid = TRUE;
    qmi_voice_cm_util_copy_alpha_ident_from_cm(&(dial_call_resp.alpha_ident),&(call_cmd_exten_cb->alpha));
    QM_MSG_HIGH_2("Recevied ALPHA DCS from CM = %d, Voice = %d", call_cmd_exten_cb->alpha.dcs, dial_call_resp.alpha_ident.alpha_dcs);
  }

  if( (qm_efs_is_no_wait_rsp_enabled()) && 
      (qmi_voice_cmd_list_query_by_event_and_sub_id_all_states(QMI_VOICE_CM_IF_EVT_NONE, params_ptr->header.handle, &cmd_info,QMI_VOICE_CM_IF_AS_ID_MAX) == E_SUCCESS))
  {
    if(!cmd_exec_success)
    {
      /* Send all call status ind with state=END */
      cm_if_info.call_fail_cause = fail_cause;
      qmi_voice_call_list_free( (cm_call_id_type) cmd_info.hdl, TRUE);
    }

    /* Remove the entry from cmd list here */
    qmi_voice_cmd_list_free( cmd_info.hdl );
  }
  /* Entry found in the cmd list */
  else if ( qmi_voice_cmd_list_query( params_ptr->header.handle, &cmd_info ) == E_SUCCESS )
  {
    /* Fail to execute the command */
    if ( !cmd_exec_success )
    {
      /* Free the call instance only in case of CALL_CMD_ORIG. No more CALL STATUS IND will be sent for this call. 
         Client should clear any call data when DIAL_CALL_RESP returns Failure */
      if ( call_cmd_exten_cb->cmd == CM_CALL_CMD_ORIG )
      {
        qmi_voice_call_list_free( (cm_call_id_type) cmd_info.sub_id, FALSE);
      }

      if( (dial_call_resp.alpha_ident_valid || dial_call_resp.end_reason_valid) && 
          (cmd_info.cmd != QMI_VOICE_CM_IF_CMD_SEND_FLASH))
      {
        dial_call_resp.resp.error = (qmi_error_type_v01)err_val;
        if(err_val) dial_call_resp.resp.result = QMI_RESULT_FAILURE_V01;
        response = &dial_call_resp;
        response_len = sizeof(dial_call_resp);
        qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, response, response_len, TRUE );
      }
      else
      {
        /* Send cmd FAILURE response */
        qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, err_val, TRUE , TRUE );
      }
      return;
    }
    else if ( call_cmd_exten_cb->cmd == CM_CALL_CMD_ORIG)
    {
      if(cmd_info.cmd == QMI_VOICE_CM_IF_CMD_SEND_FLASH)
      {
	    qmi_voice_call_list_call_ids_list_type active_call_ids_list;
        voice_send_flash_resp_msg_v02 send_flash_resp;
        memset(&send_flash_resp, 0, sizeof(send_flash_resp));
        
        qmi_voice_call_list_query_voice_call_ids_list_by_state( (uint32) QMI_VOICE_CALL_LIST_STATE_ACTIVE, &active_call_ids_list, params_ptr->header.as_id);
        if(active_call_ids_list.num_of_call_ids > 0)
        {
          send_flash_resp.call_id_valid = TRUE;
          send_flash_resp.call_id = active_call_ids_list.call_id[0];
          QM_MSG_MED_1("Call id populated in send_flsh_resp = %d.", send_flash_resp.call_id);
        }
        else
        {
          QM_MSG_MED("No ACTIVE call found; call id not populated in send_flsh_resp.");
        }
        qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, &send_flash_resp, sizeof(send_flash_resp), TRUE );
      }
      else
      {
        qmi_voice_cmd_list_update_pending_event_id(cmd_info.hdl,QMI_VOICE_CM_IF_EVT_CALL_ORIG);
        qmi_voice_cmd_list_update_state(cmd_info.hdl,QMI_VOICE_CMD_AWAITING_MORE_AMSS_EVENTS);
      }
    }
  }
  /* Entry not found in the cmd List */
  else if ( params_ptr->header.handle != QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL )
  {
    QM_MSG_ERROR_1("Cmd list entry not found :  handle %d", params_ptr->header.handle);
  }
} /* qmi_voice_cm_if_call_cmd_exten_cb_handler() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALLSVC_EXTEN_COMMAND_CALLBACK()

  DESCRIPTION
    Call command callback to be invoked by CM

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

static void qmi_voice_cm_if_callsvc_exten_command_callback
(
  void                         *data_block_ptr,
  cm_call_cmd_e_type            call_cmd,
  cm_call_cmd_err_e_type        call_cmd_err,
  cm_call_cmd_err_cause_e_type  call_cmd_err_cause,
  cm_alpha_s_type               alpha
)
{
  qmi_mmode_cmd_data_buf_type *cmd_ptr;
  

  
cmd_ptr = qmi_mmode_get_cmd_data_buf();

  if(NULL == cmd_ptr)
  {
	  qmi_voice_cmd_fatal();
    return;
  }
  cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
  if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(cmd_ptr);
    return;
  }

  cmd_ptr->cmd.cm_if_data_ptr->header.cmd    = QMI_VOICE_CM_IF_CMD_CALL_CMD_EXTEN_CB;
  cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)data_block_ptr;

  /* Call CM command callback event handler */
  cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_exten_cb.cmd     = call_cmd;
  cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_exten_cb.cmd_err = call_cmd_err;
  cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_exten_cb.call_cmd_err_cause = call_cmd_err_cause;
  if(alpha.len > 0)
  {
    memscpy(&cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_exten_cb.alpha,sizeof(cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_exten_cb.alpha), &alpha, sizeof(alpha));
  }
  else
  {
    cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_exten_cb.alpha.len = 0;
  }

  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);

}


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_HANDLE_VOIP_CONNECT()

  DESCRIPTION
    Handles Voip connect event

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_handle_voip_connect
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  qmi_voice_call_list_call_ids_list_type active_call_ids_list;
  qmi_voice_call_list_public_type call_data;
  qmi_voice_cmd_list_public_type cmd_info;
  voice_manage_ip_calls_resp_msg_v02 mng_ip_calls_resp;
  uint8 i=0;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  

  ASSERT( call_info_ptr != NULL );
  
#ifdef FEATURE_DUAL_SIM
  as_id = (uint8) call_info_ptr->asubs_id;
#endif

  if( (call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP))
  {
    qmi_voice_call_list_update_secure_call_info(call_info_ptr->call_id,
                                                    call_info_ptr->mode_info.info.ip_call.call_attrib_info.is_secure_call);
  }

  /* End any local ringback by sending local alerting */
  if(qmi_voice_call_list_is_remote_alerting(call_info_ptr->call_id))
  {
    if(qmi_voice_call_list_update_alerting_type(call_info_ptr->call_id, QMI_VOICE_CM_IF_LOCAL_ALERTING) != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Failed to update the Ringback information of CList entry for call_id %d", call_info_ptr->call_id);
    }
  }
  
  /* Check if this is conference call and set the multiparty bit*/
  if( (call_info_ptr->alpha.len > 0) &&
      (strcmp((char*)call_info_ptr->alpha.buf, "Conference Call") == 0) )
  {
    if (qmi_voice_call_list_set_mpty_status(call_info_ptr->call_id, TRUE) != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Failed to update the multiparty status for call_id %d", call_info_ptr->call_id);
    }
  }
  
  /* Check if the waiting or incoming call is switched with an active call and send response here. CM may not send
  CALL_EVENT_MNG_CALLS_CONF here for VoIP cases. */
  if(qmi_voice_call_list_query_by_call_id(call_info_ptr->call_id,&call_data) == E_SUCCESS)
  {
    if ( ( (call_data.state == QMI_VOICE_CALL_LIST_STATE_WAITING) ||
	       (call_data.state == QMI_VOICE_CALL_LIST_STATE_INCOMING) ) && 
         (qmi_voice_cmd_list_query_by_event(QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF , &cmd_info, as_id ) == E_SUCCESS) ) 
    {
      if( cmd_info.sub_id == QMI_VOICE_CM_IF_MNG_IP_CALLS_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD )
      {
        /* Move the active calls to Hold state. Waiting call will be moved to CONVERSATION later */
        qmi_voice_call_list_query_voice_call_ids_list_by_state( QMI_VOICE_CALL_LIST_STATE_ACTIVE, &active_call_ids_list, as_id );
        QM_MSG_MED_1("Num of active calls %d", active_call_ids_list.num_of_call_ids);
        for(i=0; i < active_call_ids_list.num_of_call_ids; i++)
        {
          qmi_voice_call_list_update_call_state(active_call_ids_list.call_id[i],QMI_VOICE_CALL_LIST_STATE_HOLDING);
        }
      }
      memset(&mng_ip_calls_resp, 0, sizeof(mng_ip_calls_resp));
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&mng_ip_calls_resp, sizeof(mng_ip_calls_resp), TRUE );
    }
  }
}/* qmi_voice_cm_if_handle_voip_connect */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALL_EVT_CB_HANDLER()

  DESCRIPTION
    Handles CM Call events

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_call_evt_cb_handler
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_call_info_s_type *call_info_ptr
)
{
  boolean is_last_info_rec;
  qmi_voice_call_list_call_ids_list_type call_ids_list;
  qmi_voice_cmd_list_public_type cmd_info;
  voice_manage_calls_resp_msg_v02 manage_calls_resp;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  
  ASSERT( call_info_ptr != NULL );
  QM_MSG_HIGH_2( "CALL EVENT RECEIVED from CM : id = %d, name = %s",event,qmi_voice_cm_if_lookup_event_name(event));
#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)call_info_ptr->asubs_id;
  if(qmi_voice_call_list_update_as_id(call_info_ptr->call_id, call_info_ptr->asubs_id) != E_SUCCESS)
  {
    QM_MSG_ERROR_2("Failed to update the Active Subscription ID of CList entry for call_id %d,asubs_id %d", call_info_ptr->call_id, call_info_ptr->asubs_id);
  }
#endif /*FEATURE_DUAL_SIM*/

  switch(event)
  {
    case QMI_VOICE_CM_IF_EVT_CALL_ORIG:
      qmi_voice_cm_if_call_event_orig(call_info_ptr);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_SETUP_IND:
      qmi_voice_cm_if_call_event_setup_ind(call_info_ptr);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_USER_DATA_IND:
      qmi_voice_cm_if_call_event_user_data_ind(call_info_ptr);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_INCOM:
      qmi_voice_cm_if_call_event_incom(call_info_ptr);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_ANSWER:
      /* Update the answer indication of the record in Call List */
      if ( qmi_voice_call_list_answer( call_info_ptr->call_id ) != E_SUCCESS )
      {
        QM_MSG_ERROR_1("Failed to update the answer indication of Call List entry :  call_id %d", call_info_ptr->call_id);
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_PROGRESS_INFO_IND:
    {
      qmi_voice_call_list_public_type call_data;
      boolean isModeChanged = FALSE;
    
      if( qmi_voice_call_list_query_by_call_id( call_info_ptr->call_id, &call_data ) == E_SUCCESS )
      {
        if (call_info_ptr->sys_mode != call_data.call_mode)
        {
          isModeChanged = TRUE;
        }
      }

      /* Update the call mode  of the record in Call list */
      if ( qmi_voice_call_list_update_call_mode( call_info_ptr->call_id, call_info_ptr->sys_mode ) ==  E_FAILURE )
      {
        QM_MSG_ERROR_1("Failed to update call mode of Call list entry: call_id %d", call_info_ptr->call_id);
      }

      if (qmi_voice_call_list_update_mode_info_type(call_info_ptr->call_id, call_info_ptr->mode_info.info_type) != E_SUCCESS )
      {
        QM_MSG_ERROR_1("Failed to update mode info type of Call list entry for connect : call_id %d", call_info_ptr->call_id);
      }
      QM_MSG_HIGH_2("emergency_type :  call id %d, em_type %d", call_info_ptr->call_id, call_info_ptr->mode_info.info.ip_call.call_attrib_info.em_type);
        //Possible update of the Call type in PROGRESS_INFO for call_id
      qmi_voice_call_list_update_call_attributes_type(call_info_ptr->call_id,
                                                          call_info_ptr->mode_info.info.ip_call.call_attrib_info,
                                                          call_info_ptr->call_type);
      qmi_voice_cm_if_call_event_progress_info_ind(call_info_ptr, isModeChanged);
     }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_PROGRESS_EARLY_MEDIA:

      /* Update the call mode  of the record in Call list */
      if ( qmi_voice_call_list_update_call_mode(call_info_ptr->call_id, call_info_ptr->sys_mode) == E_FAILURE )
      {
        QM_MSG_ERROR_1("Failed to update call mode of Call list entry: call_id %d", call_info_ptr->call_id);
      }
      if (qmi_voice_call_list_update_mode_info_type(call_info_ptr->call_id, call_info_ptr->mode_info.info_type) != E_SUCCESS )
      {
        QM_MSG_ERROR_1("Failed to update mode info type of Call list entry for connect : call_id %d", call_info_ptr->call_id);
      }

      if(call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP)
      {
        if((qmi_voice_call_list_query_by_call_id_and_call_state(call_info_ptr->call_id, QMI_VOICE_CALL_LIST_STATE_DIALING) == E_SUCCESS ))
      {
      /* Update the state of the record in Call List if needed */
      if ( qmi_voice_call_list_alert( call_info_ptr->call_id, QMI_VOICE_CM_IF_ALERTING_NONE ) != E_SUCCESS )
      {
        QM_MSG_MED_1("No update done on Call List entry for alert :  call_id %d", call_info_ptr->call_id);
      }
        }
        else if(qmi_voice_call_list_is_remote_alerting(call_info_ptr->call_id) )
        {
          QM_MSG_HIGH("VoIP call:  Indicate client to Stop the ringback");
          if(qmi_voice_call_list_update_alerting_type(call_info_ptr->call_id, QMI_VOICE_CM_IF_LOCAL_ALERTING) != E_SUCCESS)
          {
            QM_MSG_ERROR_1("Failed to update the Ringback information of CList entry for call_id %d", call_info_ptr->call_id);
          }
          else
          {
            qmi_voice_call_list_report_all_call_status_changed(as_id);
          }
        }
      }   
      
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_CONNECT:
      /* Update the call type  of the record in call list */
      if ( qmi_voice_call_list_update_call_type( call_info_ptr->call_id, call_info_ptr->call_type) == E_FAILURE )
      {
        QM_MSG_ERROR_1("Failed to update call type of call list entry: call_id %d", call_info_ptr->call_id);
      }
      if( call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP )
      {
      if ( qmi_voice_call_list_update_num_pi( call_info_ptr->call_id, call_info_ptr->num.pi) == E_FAILURE )
      {
        QM_MSG_ERROR_1("Failed to update num pi of call list entry: call_id %d", call_info_ptr->call_id);
      }
      }
      /* Update the call mode  of the record in Call list */
      if ( qmi_voice_call_list_update_call_mode( call_info_ptr->call_id, call_info_ptr->sys_mode ) == E_FAILURE )
      {
        QM_MSG_ERROR_1("Failed to update call mode of Call list entry: call_id %d", call_info_ptr->call_id);
      }
      if (qmi_voice_call_list_update_mode_info_type( call_info_ptr->call_id, call_info_ptr->mode_info.info_type ) != E_SUCCESS )
      {
        QM_MSG_ERROR_1("Failed to update mode info type of Call list entry for connect : call_id %d", call_info_ptr->call_id);
      }
      if( call_info_ptr->mode_info.info_type ==  CM_CALL_MODE_INFO_IP )
      {
        qmi_voice_cm_if_handle_voip_connect( call_info_ptr);

        if( qmi_voice_call_list_update_call_attributes_type(call_info_ptr->call_id,
                                                            call_info_ptr->mode_info.info.ip_call.call_attrib_info,
                                                            call_info_ptr->call_type) == E_SUCCESS )
        {
          QM_MSG_MED_1("Possible update of the Call type/attributes in CONNECT for call_id %d", call_info_ptr->call_id);
        }
        
        if( qmi_voice_call_list_update_call_capabilities(call_info_ptr->call_id,
                                                         call_info_ptr->mode_info.info.ip_call.ipcall_local_call_cap_attrib_info,
                                                         call_info_ptr->mode_info.info.ip_call.ipcall_peer_call_cap_attrib_info) == E_SUCCESS )
        {
          QM_MSG_MED_1("Updating call capabilities in CONNECT for call_id %d", call_info_ptr->call_id);
        }
        
      }

      QM_MSG_MED_2("call_info_type = %d,srv_opt=%d", call_info_ptr->mode_info.info_type, call_info_ptr->mode_info.info.cdma_call.srv_opt);
      if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA)
      {
         if ( qmi_voice_call_list_update_cdma_srv_opt( call_info_ptr->call_id, 
					               call_info_ptr->mode_info.info.cdma_call.srv_opt ) != E_SUCCESS )
         {
            QM_MSG_ERROR_1("Failed to update the srv opt for call :  call_id %d", call_info_ptr->call_id);
         }
      }

      /* Update the state of the record in Call list */
      if ( qmi_voice_call_list_connect( call_info_ptr->call_id ) != E_SUCCESS )
      {
        QM_MSG_ERROR_1("Failed to update state of Call list entry for connect :  call_id %d", call_info_ptr->call_id);
      }
      else
      {
        memset(&cmd_info,0,sizeof(cmd_info));
        memset(&manage_calls_resp, 0, sizeof(manage_calls_resp));
        if ( qmi_voice_cmd_list_query_by_event( QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF, &cmd_info, as_id ) == E_SUCCESS ) 
        {
          if( QMI_VOICE_CM_IF_MNG_CALLS_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING == cmd_info.sub_id )
          {
              /* Assumption is For this request Connect will be sent only when there is a waiting call and for held calls CM won't send connect
                 Send the response to RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING just after waiting call gets connected.
              */
            qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&manage_calls_resp, sizeof(manage_calls_resp), TRUE );
          }
        }      
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_END_REQ:

      /* Update the call mode  of the record in Call list */
      if ( qmi_voice_call_list_update_call_mode( call_info_ptr->call_id, call_info_ptr->sys_mode ) == E_FAILURE )
      {
        QM_MSG_ERROR_1("Failed to update call mode of Call list entry: call_id %d", call_info_ptr->call_id);
      }

      
      QM_MSG_MED_1("inband tone (%d) info from cm", call_info_ptr->mode_info.info.gw_cs_call.inband_tone_present);
      if(call_info_ptr->mode_info.info.gw_cs_call.inband_tone_present)
      {
        /* if inband tone is present, UE is not expected to play any tone, so sending local alerting*/
        if(qmi_voice_call_list_update_alerting_type(call_info_ptr->call_id, QMI_VOICE_CM_IF_LOCAL_ALERTING) != E_SUCCESS)
        {
          QM_MSG_ERROR_1("Failed to update the Ringback information of CList entry for call_id %d", call_info_ptr->call_id);
        }
      }        

       /* Extract the call end reason */
       qmi_voice_cm_if_extract_call_end_reason(call_info_ptr);

      /* Update the state of the record in Call list */
      if ( qmi_voice_call_list_disconnecting( call_info_ptr->call_id ) != E_SUCCESS )
      {
        QM_MSG_ERROR_1("Failed to update state of Call list entry for disconnecting :  call_id %d", call_info_ptr->call_id);
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_END:

      /* Update the call mode  of the record in Call list */
      if ( qmi_voice_call_list_update_call_mode( call_info_ptr->call_id, call_info_ptr->sys_mode ) == E_FAILURE )
      {
        QM_MSG_ERROR_1("Failed to update call mode of Call list entry: call_id %d", call_info_ptr->call_id);
      }

      qmi_voice_cm_if_call_event_end(call_info_ptr);

      if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP)
      {
        if(call_info_ptr->mode_info.info.ip_call.ims_end_reason != NULL)
        {
          QM_MSG_MED("ims_end_reason REFERENCE REMOVED");
          ref_cnt_obj_release( (void *) call_info_ptr->mode_info.info.ip_call.ims_end_reason);
        }
        else
        {
          QM_MSG_MED("Reference not removed for ims_end_reason");
        }
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_CNAP_INFO_RECEIVED:
      if(call_info_ptr->mode_info.info_type != CM_CALL_MODE_INFO_IP)
      {
        qmi_voice_cm_util_process_cnap_info(call_info_ptr, TRUE);
      }
      else
      {
        /*Copying is done, release the reference */
        if(call_info_ptr->mode_info.info.ip_call.call_attrib_info.caller_name != NULL)
          {
            qmi_voice_call_list_update_ip_caller_name(call_info_ptr);
            ref_cnt_obj_release( (void *) call_info_ptr->mode_info.info.ip_call.call_attrib_info.caller_name);
            QM_MSG_MED("Ref RELEASED for caller_name; caller_name_text is present\n");
        }
        else
        {
          QM_MSG_MED("Reference not ADDED, not released");
        }
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_PRIVACY:
      if ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA ) 
      {
        if ( qmi_voice_call_list_update_voice_privacy_mode( call_info_ptr->call_id, 
                                                       call_info_ptr->mode_info.info.cdma_call.is_privacy ) != E_SUCCESS )
        {
          QM_MSG_ERROR_1("Failed to update the privacy mode for call :  call_id %d", call_info_ptr->call_id);
        }
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_OTASP_STATUS:
      if((call_info_ptr->mode_info.info.cdma_call.otasp_status < CM_OTASP_STATUS_SPL_UNLOCKED) ||
        (call_info_ptr->mode_info.info.cdma_call.otasp_status > CM_OTASP_STATUS_OTAPA_ABORTED))
      {
        QM_MSG_ERROR("Received unexpected otasp status ");
      }
      else
      {
        if ( qmi_voice_call_list_update_otasp_status( call_info_ptr->call_id, 
                                                        (qmi_voice_call_list_otasp_status_e_type)call_info_ptr->mode_info.info.cdma_call.otasp_status ) != E_SUCCESS )
        {
          QM_MSG_ERROR_1("Failed to update the Otasp status for call :  call_id %d", call_info_ptr->call_id);
        }
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_ORIG_FWD_STATUS:
    case QMI_VOICE_CM_IF_EVT_CALL_BEING_FORWARDED:
    case QMI_VOICE_CM_IF_EVT_CALL_IS_WAITING:
    case QMI_VOICE_CM_IF_EVT_CALL_BARRED:
    case QMI_VOICE_CM_IF_EVT_CALL_RESTRICTED:
    case QMI_VOICE_CM_IF_EVT_CALL_INCOM_FWD_CALL:
    case QMI_VOICE_CM_IF_EVT_CALL_CUG_INFO_RECEIVED:
    case QMI_VOICE_CM_IF_EVT_CALL_ON_HOLD:
    case QMI_VOICE_CM_IF_EVT_CALL_RETRIEVED:
    case QMI_VOICE_CM_IF_EVT_CALL_FORWARDED:
    case QMI_VOICE_CM_IF_EVT_CALL_TRANSFERRED_CALL:
    case QMI_VOICE_CM_IF_EVT_CALL_DEFLECTION:
    case QMI_VOICE_CM_IF_EVT_CALL_ON_HOLD_BY_REMOTE:
    case QMI_VOICE_CM_IF_EVT_CALL_RETRIEVE_BY_REMOTE:
    case QMI_VOICE_CM_IF_EVT_MPTY_CALL_IND:
      qmi_voice_cm_if_fill_and_send_sups_notification_ind(event, call_info_ptr);

      if( (call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP) && 
          (event == QMI_VOICE_CM_IF_EVT_CALL_BEING_FORWARDED) )
      {
        if ( call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info != NULL )
        {
          QM_MSG_MED("ip_forward_hist_info REFERENCE REMOVED");
          ref_cnt_obj_release( (void *) call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info);
        }
        else
        {
          QM_MSG_MED("Reference not removed for ip_forward_hist_info");
        }
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_DISPLAY:
    case QMI_VOICE_CM_IF_EVT_CALL_CALLER_ID:
    case QMI_VOICE_CM_IF_EVT_CALL_SIGNAL:
    case QMI_VOICE_CM_IF_EVT_CALL_EXT_DISP:
    case QMI_VOICE_CM_IF_EVT_CALL_CONNECTED_NUM:
    case QMI_VOICE_CM_IF_EVT_CALL_CALLED_PARTY:
    case QMI_VOICE_CM_IF_EVT_CALL_NSS_CLIR_REC:
    case QMI_VOICE_CM_IF_EVT_CALL_NSS_REL_REC:
    case QMI_VOICE_CM_IF_EVT_CALL_NSS_AUD_CTRL:
    case QMI_VOICE_CM_IF_EVT_CALL_LINE_CTRL:
    case QMI_VOICE_CM_IF_EVT_CALL_REDIRECTING_NUMBER:
      if( (event == QMI_VOICE_CM_IF_EVT_CALL_SIGNAL) && !QMI_VOICE_CALL_LIST_CALL_TYPE_IS_VOICE( call_info_ptr->call_type ) )
      {
        QM_MSG_HIGH_1("Ignoring Signal evt for call type = %d", (int)call_info_ptr->call_type);
        if(call_info_ptr->call_type != CM_CALL_TYPE_NONE)
        {
        return;
      }
      }
      is_last_info_rec = qmi_voice_cm_if_process_info_rec(event, call_info_ptr);
      memset((void*)&call_ids_list, 0, sizeof(call_ids_list));
      qmi_voice_call_list_query_voice_call_ids_list_by_state(QMI_VOICE_CALL_LIST_STATE_ACTIVE,&call_ids_list, as_id);
      if(call_ids_list.num_of_call_ids != 0)
      {
        // set call waiting flag
         if ( (event == QMI_VOICE_CM_IF_EVT_CALL_CALLER_ID) ||
              (event == QMI_VOICE_CM_IF_EVT_CALL_NSS_CLIR_REC) )
         {
           QM_MSG_HIGH_1("set callwaiting indicator :  num_call_ids %d", call_ids_list.num_of_call_ids);
           info_record_buf.call_waiting_valid = TRUE;
           info_record_buf.call_waiting = CALL_WAITING_NEW_CALL_V02;
         }
      }
      if(is_last_info_rec)
      {
         voice_info_rec_ind_msg_v02 rec_ind;
         memset((void*)&rec_ind, 0, sizeof(rec_ind));
         qmi_voice_cm_if_gen_info_rec_ind(&rec_ind);
         qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_INFO_REC_IND,
                                        (void*)&rec_ind, sizeof(rec_ind), as_id);

         /* Clear the info record indication data */
         memset((void *)&(info_record_buf), 0, sizeof(info_record_buf));
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF:
      QM_MSG_MED("Manage Calls conf case, could be a conference case ADD REF");      
      qmi_voice_cm_if_callsvc_event_manage_calls_conf(event, call_info_ptr);

      //Manage Calls conf case, could be a conf case    
      if((call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP) &&
         (call_info_ptr->mode_info.info.ip_call.participant_uri != NULL) && 
         ((call_info_ptr->mode_info.info.ip_call.sups_type == CM_CALL_SUPS_TYPE_MULTIPARTY_CALL) || 
          (call_info_ptr->mode_info.info.ip_call.sups_type == CM_CALL_SUPS_TYPE_RELEASE_CALL_X_FROM_CONFERENCE))
        )
        {
          QM_MSG_MED_1("Reference REMOVED to participant_URI, num_participants=%d", call_info_ptr->mode_info.info.ip_call.number_of_participants_add_removed);
          ref_cnt_obj_release((void*)call_info_ptr->mode_info.info.ip_call.participant_uri);
        }
        //else:QM_MSG_MED("Reference not added to participant_URI, participant_uri NULL or num_participant<=0");
        break;

    case QMI_VOICE_CM_IF_EVT_CALL_SWITCH_CODEC_CNF:
      qmi_voice_cm_if_call_switch_codec_cnf(event, call_info_ptr);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_ORIG_MOD_TO_SUPS:
      qmi_voice_cm_if_call_mod_to_sups(call_info_ptr);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_L2ACK_CALL_HOLD:
      qmi_voice_cm_if_call_l2ack_call_hold(call_info_ptr);
      break;  

    case QMI_VOICE_CM_IF_EVT_CALL_MODIFY_IND:
      qmi_voice_cm_if_call_modify_accept_ind(event,call_info_ptr);
      break;  

    case QMI_VOICE_CM_IF_EVT_CALL_MODIFY_COMPLETE_CONF:
      qmi_voice_cm_if_callsvc_event_modify_complete_conf(event, call_info_ptr);
      break;        

    case QMI_VOICE_CM_IF_EVT_CALL_SPEECH_CODEC_INFO:
      qmi_voice_cm_if_call_speech_codec_info_ind(call_info_ptr);
      break; 

    case QMI_VOICE_CM_IF_EVT_EMERGENCY_FLASHED:
      qmi_voice_cm_if_call_emergency_flashed(call_info_ptr);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_START:
    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_FAIL:
    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_COMPLETE:
    case QMI_VOICE_CM_IF_EVT_CALL_HANDOVER_CANCEL:		
        qmi_voice_cm_if_send_handover_ind(event, call_info_ptr,as_id);	 	
      break;

    case QMI_VOICE_CM_IF_EVT_CONF_AND_USER_INFO_IND:
      //QM_MSG_MED("Conf Info and User info ind");
      qmi_voice_cm_if_send_conf_info_ind(call_info_ptr);

      if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP)
      {
        if(call_info_ptr->mode_info.info.ip_call.conference_info != NULL)
        {
          QM_MSG_MED("Conf Info and User info REFERENCE REMOVED");
          ref_cnt_obj_release( (void *) call_info_ptr->mode_info.info.ip_call.conference_info);
        }
        //else:QM_MSG_MED("Reference not added to USER_CONF_INFO");
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CONFERENCE_JOIN_IND:
      //QM_MSG_MED("Join Indication");
      qmi_voice_cm_if_send_conf_join_ind(call_info_ptr);      
      QM_MSG_MED_1("JOIN_IND Num participants=%d", call_info_ptr->mode_info.info.ip_call.number_of_participants_add_removed);
      if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP)
      {
        if(call_info_ptr->mode_info.info.ip_call.participant_uri != NULL)
        {
          QM_MSG_MED("Conf Join Ind info REFERENCE REMOVED");
          ref_cnt_obj_release((void *) call_info_ptr->mode_info.info.ip_call.participant_uri);
        }
        //else:QM_MSG_MED("Reference not added to participant_URI");
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_BRST_INTL_IND:
      qmi_voice_cm_if_send_ext_burst_international_ind(call_info_ptr, as_id);
      break;

    case QMI_VOICE_CM_IF_EVT_MT_CALL_PAGE_FAIL:
      qmi_voice_cm_if_send_mt_page_miss_ind(call_info_ptr, as_id);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_RAT_CHANGE:
      qmi_voice_cm_if_report_rat_change(call_info_ptr);
      break;

    case QMI_VOICE_CM_IF_EVT_CC_RESULT_INFO:
      qmi_voice_cm_if_send_cc_result_info_ind(call_info_ptr->result_from_cc.call_control_result, 
                                              call_info_ptr->result_from_cc.alpha, 
                                              as_id);
      break;

    case QMI_VOICE_CM_IF_EVT_E911_ORIG_FAIL:
      qmi_voice_ims_ext_e911_orig_fail_ind(call_info_ptr, as_id);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_VOIP_CALL_END_CNF:
       /* Update the orig_fail_reason  of the record in Call list */
      QM_MSG_HIGH_2( "updating orig fail reason of call list entry: call_id=%d, end_status=%d", call_info_ptr->call_id, call_info_ptr->end_status);
      if ( qmi_voice_call_list_update_orig_fail_reason( call_info_ptr->call_id, call_info_ptr->end_status ) !=  E_FAILURE )
      {
        /*all Call Status Indication is sent if Update is successful*/
        qmi_voice_call_list_report_all_call_status_changed(as_id);
      }
      break;

    case QMI_VOICE_CM_IF_EVT_ABRV_ALERT:
    {
      IxErrnoType status = E_FAILURE;
      QM_MSG_HIGH_3( "Rxd ABRV_ALERT call list entry: call_id=%d, info_type=%d direction=%d", 
          call_info_ptr->call_id, call_info_ptr->mode_info.info_type, call_info_ptr->direction);

      if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP &&
         call_info_ptr->direction == CM_CALL_DIRECTION_MO &&
         (call_info_ptr->call_type == CM_CALL_TYPE_VOICE ||
          call_info_ptr->call_type == CM_CALL_TYPE_EMERGENCY ||
          call_info_ptr->call_type == CM_CALL_TYPE_VT ||
          call_info_ptr->call_type == CM_CALL_TYPE_VS
         ))
      {
          status = qmi_voice_call_list_update_called_party_ring_alert_info(call_info_ptr->call_id,
                   call_info_ptr->mode_info.info.ip_call.call_attrib_info.is_180_ringing_rxd_in_mo_prog_ind);

      }
      else if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS &&
              call_info_ptr->direction == CM_CALL_DIRECTION_MO &&
              (call_info_ptr->call_type == CM_CALL_TYPE_VOICE ||
               call_info_ptr->call_type == CM_CALL_TYPE_EMERGENCY )
             )
      {
          status = qmi_voice_call_list_update_called_party_ring_alert_info(call_info_ptr->call_id, TRUE);
          /* If CALL_EVT_ABRV_ALERT is received for GW CS Calls, then it ensures called party is alerted
             and ringing */
      }

      if ( status ==  E_SUCCESS )
      {
        QM_MSG_HIGH_2( "Updated called party alert status of call list entry: call_id=%d, call_type=%d", call_info_ptr->call_id, call_info_ptr->call_type);
        qmi_voice_call_list_report_all_call_status_changed(as_id);

        /* Resetting the QMI call context variable, so it is not sent in subsequent ALL_CALL_STATUS_IND
                   This is required only to be sent only when CM has explicitely sent the EVENT*/
        qmi_voice_call_list_update_called_party_ring_alert_info(call_info_ptr->call_id, FALSE);	

      }
      else
      {
        QM_MSG_ERROR_2( "Failed to update called party alert status of call list entry: call_id=%d, call_type=%d", call_info_ptr->call_id, call_info_ptr->call_type);
      }
    }
      break;

    default:
      QM_MSG_ERROR_1("Unsupported CM event %d", event);
      break;
  }
  
}/* qmi_voice_cm_if_call_evt_cb_handler() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_CALLSVC_EVT_CALLBACK()

  DESCRIPTION
    Call event callback to be invoked by CM

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_call_evt_cb (cm_call_event_e_type call_event, const cm_mm_call_info_s_type *call_info_ptr)
{
  qmi_voice_cm_if_evt_e_type event_id;
  qmi_mmode_cmd_data_buf_type *cmd_ptr;
  uint8 num_participants=0;

  if(call_info_ptr == NULL)
  {
    QM_MSG_FATAL("Call info ptr is NULL");
    return;
  }

  if (qmi_voice_has_valid_client())
  {
    /* Figure out Event ID */
    event_id = (qmi_voice_cm_if_evt_e_type)(QMI_VOICE_CM_IF_EVT_CALL_BASE + call_event);

    if(!QMI_VOICE_CALL_LIST_HANDLE_CALL_TYPES(call_info_ptr->call_type) && 
       !(((qmi_voice_cm_if_evt_e_type)event_id == QMI_VOICE_CM_IF_EVT_MT_CALL_PAGE_FAIL) && (call_info_ptr->call_type == CM_CALL_TYPE_UNKNOWN)))
    {
      QM_MSG_HIGH_2( "Ignoring Call type = %d, for CM event = %s",call_info_ptr->call_type,qmi_voice_cm_if_lookup_event_name(call_event));
      return;
    }    

    cmd_ptr = qmi_mmode_get_cmd_data_buf();
    if(NULL == cmd_ptr)
    {
		qmi_voice_cmd_fatal();
      return;
    }
    cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
    if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
    {
		qmi_voice_mem_fatal();
      qmi_mmode_free_cmd_data_buf(cmd_ptr);
      return;
    }
    cmd_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_CALL_EVT_CB;
    cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)0x00;
    cmd_ptr->cmd.cm_if_data_ptr->data.call_evt_cb.event = (int)event_id;
    memscpy( &cmd_ptr->cmd.cm_if_data_ptr->data.call_evt_cb.call_info,sizeof(cmd_ptr->cmd.cm_if_data_ptr->data.call_evt_cb.call_info), call_info_ptr, sizeof(cm_mm_call_info_s_type));

    if(call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP)
    {
      QM_MSG_MED_1("Event ID = %d", event_id);
      switch((qmi_voice_cm_if_evt_e_type)event_id)
      {
        case QMI_VOICE_CM_IF_EVT_CONFERENCE_JOIN_IND:
           if(call_info_ptr->mode_info.info.ip_call.participant_uri != NULL)
           {
             QM_MSG_MED_1("Join Indication, p_participant_uri %d", call_info_ptr->mode_info.info.ip_call.participant_uri);
             ref_cnt_obj_add_ref((void *) call_info_ptr->mode_info.info.ip_call.participant_uri);
           }

           break;
 
       case QMI_VOICE_CM_IF_EVT_CONF_AND_USER_INFO_IND:
           if(call_info_ptr->mode_info.info.ip_call.conference_info != NULL)
           {
             QM_MSG_MED_1("Conf Info and User info ind p_conference_info % d", call_info_ptr->mode_info.info.ip_call.conference_info);
             ref_cnt_obj_add_ref( (void *) call_info_ptr->mode_info.info.ip_call.conference_info);
           }
 
           break;

       case QMI_VOICE_CM_IF_EVT_CALL_MNG_CALLS_CONF:
           //Manage Calls conf case, could be a conf case
           num_participants = call_info_ptr->mode_info.info.ip_call.number_of_participants_add_removed;
           QM_MSG_MED_1("Manage Calls conf case,could be a conf case, num_participants = %d", num_participants); 
           if((call_info_ptr->mode_info.info.ip_call.participant_uri != NULL) && 
              ((call_info_ptr->mode_info.info.ip_call.sups_type == CM_CALL_SUPS_TYPE_MULTIPARTY_CALL) || 
               (call_info_ptr->mode_info.info.ip_call.sups_type == CM_CALL_SUPS_TYPE_RELEASE_CALL_X_FROM_CONFERENCE))
             )
           {
             QM_MSG_MED_1("Reference ADDED to participant_URI, num_participants=%d", call_info_ptr->mode_info.info.ip_call.number_of_participants_add_removed);
             ref_cnt_obj_add_ref( (void *) call_info_ptr->mode_info.info.ip_call.participant_uri);
           }
           //else:QM_MSG_MED("Reference not added to participant_URI, participant_uri NULL or num_participant<=0");
           
           break;

       case QMI_VOICE_CM_IF_EVT_CALL_INCOM:
           if((call_info_ptr->mode_info.info.ip_call.caller_info != NULL))
           {
             ref_cnt_obj_add_ref( (void *) call_info_ptr->mode_info.info.ip_call.caller_info);
			 QM_MSG_MED_2("Inc call:Reference ADDED for caller_info; info_text %d, length=%d",
			 	          call_info_ptr->mode_info.info.ip_call.caller_info->info_text,
			 	          call_info_ptr->mode_info.info.ip_call.caller_info->info_len);
           }

           break;

       case QMI_VOICE_CM_IF_EVT_CALL_END:
           if(call_info_ptr->mode_info.info.ip_call.ims_end_reason != NULL)
           {
             ref_cnt_obj_add_ref( (void *) call_info_ptr->mode_info.info.ip_call.ims_end_reason);
               QM_MSG_MED_2("Reference ADDED for ims_end_reason; p_end_reason_text %d, length=%d\n",
			   	             call_info_ptr->mode_info.info.ip_call.ims_end_reason->end_reason_text,
                             call_info_ptr->mode_info.info.ip_call.ims_end_reason->end_reason_len);
             }

           break;

          case QMI_VOICE_CM_IF_EVT_CALL_CNAP_INFO_RECEIVED:
           if((call_info_ptr->mode_info.info_type  ==  CM_CALL_MODE_INFO_IP )&&
              (call_info_ptr->mode_info.info.ip_call.call_attrib_info.caller_name != NULL))
            {
                ref_cnt_obj_add_ref( (void *) call_info_ptr->mode_info.info.ip_call.call_attrib_info.caller_name);
                QM_MSG_MED_1("cnap info Rxd: Ref ADDED for caller_name; caller_name_text is present, length=%d\n",
                              call_info_ptr->mode_info.info.ip_call.call_attrib_info.caller_name->caller_name_len);
              }
           break;

       case QMI_VOICE_CM_IF_EVT_CALL_BEING_FORWARDED:
           if((call_info_ptr->mode_info.info_type  ==  CM_CALL_MODE_INFO_IP )&&
              (call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info != NULL))
            {
              ref_cnt_obj_add_ref( (void *) call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info);
			  QM_MSG_MED_2("Call being fwded:Ref ADDED for ip_forward_hist_info; p_hist_info_text %d, hist_info_len: %d characters",
                              call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info->hist_info_text,
                              call_info_ptr->mode_info.info.ip_call.call_attrib_info.forward_info->hist_info_len);
              }
           break;

       default:
           QM_MSG_MED("Not a conference package event");
           break;
      }
    }
    qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);
  }
}/* qmi_voice_cm_if_call_evt_cb() */



/*===========================================================================
                    SUPS COMMAND, EVENT CALLBACKS
===========================================================================*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_CMD_CB_HANDLER()

  DESCRIPTION
    Handle Sups command callback here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_sups_cmd_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
)
{
  qmi_error_e_type err_val = QMI_ERR_NONE;
  boolean cmd_exec_success = TRUE;
  qmi_voice_cmd_list_public_type cmd_info;
  void *response = NULL;
  size_t response_len = 0;
  qmi_voice_cm_if_sups_cmd_cb_s  *sups_cmd_cb = (qmi_voice_cm_if_sups_cmd_cb_s*)(&params_ptr->data);

  ASSERT(params_ptr != NULL);
  
  //QM_MSG_MED("QMI VOICE :  Inside qmi_voice_cm_if_sups_cmd_cb_handler");

  if(sups_cmd_cb->cmd_err != CM_SUPS_CMD_ERR_NOERR )
  {
    QM_MSG_MED_2("Sups command callback error %d received for cmd %d from CM", sups_cmd_cb->cmd_err, sups_cmd_cb->cmd);
    cmd_exec_success = FALSE;
    err_val = qmi_voice_cm_if_map_sups_error_to_qmi(sups_cmd_cb->cmd_err);
  }

  /* Entry found in the cmd list */
  if ( qmi_voice_cmd_list_query( params_ptr->header.handle, &cmd_info ) == E_SUCCESS )
  {
    /* Fail to execute the command */
    if ( !cmd_exec_success )
    {
      /* Send cmd FAILURE response */
      qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, err_val, TRUE , TRUE );
      return;
    }
    /* Not pending for AMSS events */
    else if ( cmd_info.pending_event_id == QMI_VOICE_CM_IF_EVT_NONE )
    {
      switch(sups_cmd_cb->cmd)
      {
        case CM_SUPS_CMD_REGISTER:
        case CM_SUPS_CMD_ERASE:
        case CM_SUPS_CMD_ACTIVATE:
        case CM_SUPS_CMD_DEACTIVATE:
        case CM_SUPS_CMD_INTERROGATE:
        case CM_SUPS_CMD_REG_PASSWORD:
        case CM_SUPS_CMD_USS_RES:
        case CM_SUPS_CMD_PROCESS_USS:
          break;
        default:
          QM_MSG_ERROR("Unsupported CM command");
          return;
      }
      /* Send cmd SUCCESS response */
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, response, response_len, TRUE );
    }
    /* Force state transition to WaitingMoreAMSSEvents */
    else
    {
      qmi_voice_cm_if_force_state_transition_to_wait_amss_event( cmd_info.hdl, cmd_info.cmd, cmd_info.pending_event_id );
    }
  }
  /* Entry not found in the cmd List */
  else if ( params_ptr->header.handle != QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL )
  {
    QM_MSG_ERROR_1("Cmd list entry not found :  handle %d", params_ptr->header.handle);
  }
} /* qmi_voice_cm_if_sups_cmd_cb_handler() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_CMD_EXTEN_CB_HANDLER()

  DESCRIPTION
    Handle Sups Extended command callback here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_sups_cmd_exten_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
)
{
  qmi_error_e_type err_val = QMI_ERR_NONE;
  boolean cmd_exec_success = TRUE;
  qmi_voice_cmd_list_public_type cmd_info;
  void *response = NULL;
  size_t response_len = 0;
  qmi_voice_cm_if_sups_exten_cmd_cb_s  *sups_cmd_cb = (qmi_voice_cm_if_sups_exten_cmd_cb_s*)(&params_ptr->data);

  ASSERT(params_ptr != NULL);
  
  //QM_MSG_MED("QMI VOICE :  Inside qmi_voice_cm_if_sups_cmd_exten_cb_handler");

  if(sups_cmd_cb->cmd_err != CM_SUPS_CMD_ERR_NOERR )
  {
    QM_MSG_MED_2("Sups command callback error %d received for cmd %d from CM", sups_cmd_cb->cmd_err, sups_cmd_cb->cmd);
    cmd_exec_success = FALSE;
    err_val = qmi_voice_cm_if_map_sups_error_to_qmi(sups_cmd_cb->cmd_err);

      if(sups_cmd_cb->cmd_err == CM_SUPS_CMD_ERR_CALL_CONTROL_REJECTED)
      {
        switch(sups_cmd_cb->err_cause)
        {
          case CM_SUPS_CMD_ERR_CAUSE_FDN_FAIL:
        err_val = QMI_ERR_FDN_RESTRICT;
            break;
          case CM_SUPS_CMD_ERR_CAUSE_NO_SUBSC:
            err_val = QMI_ERR_NO_SUBSCRIPTION;
            break;
          case CM_SUPS_CMD_ERR_CAUSE_CARD_CC_FAIL:
            err_val = QMI_ERR_CARD_CALL_CONTROL_FAILED;
            break;
          default:
            err_val = QMI_ERR_INTERNAL;
            break;
        }
      }
  }

  /* fill the call control alpha if present save to global data element until event is recieved*/
  if(sups_cmd_cb->alpha.len > 0)
  {
    cm_if_info.sups_alpha_info.is_alpha_available = TRUE;
    cm_if_info.sups_alpha_info.handle = params_ptr->header.handle;

    qmi_voice_cm_util_copy_alpha_info_from_cm(&(cm_if_info.sups_alpha_info.alpha_id),&(sups_cmd_cb->alpha));
    QM_MSG_HIGH_2("Recevied ALPHA DCS from CM = %d, Voice = %d", sups_cmd_cb->alpha.dcs, cm_if_info.sups_alpha_info.alpha_id.alpha_dcs);
  }

  /* Entry found in the cmd list */
  if ( qmi_voice_cmd_list_query( params_ptr->header.handle, &cmd_info ) == E_SUCCESS )
  {
    /* Fail to execute the command */
    if ( !cmd_exec_success )
    {
      /* Send cmd FAILURE response */
      qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, err_val, TRUE , TRUE );
      return;
    }
    /* Not pending for AMSS events */
    else if ( cmd_info.pending_event_id == QMI_VOICE_CM_IF_EVT_NONE )
    {
      switch(sups_cmd_cb->cmd)
      {
        case CM_SUPS_CMD_REGISTER:
        case CM_SUPS_CMD_ERASE:
        case CM_SUPS_CMD_ACTIVATE:
        case CM_SUPS_CMD_DEACTIVATE:
        case CM_SUPS_CMD_INTERROGATE:
        case CM_SUPS_CMD_REG_PASSWORD:
        case CM_SUPS_CMD_USS_RES:
        case CM_SUPS_CMD_PROCESS_USS:
          break;
        default:
          QM_MSG_ERROR("Unsupported CM command");
          return;
      }
      /* Send cmd SUCCESS response */
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, response, response_len, TRUE );
    }
    /* Force state transition to WaitingMoreAMSSEvents */
    else
    {
      qmi_voice_cm_if_force_state_transition_to_wait_amss_event( cmd_info.hdl, cmd_info.cmd, cmd_info.pending_event_id );
    }
  }
  /* Entry not found in the cmd List */
  else if ( params_ptr->header.handle != QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL )
  {
    QM_MSG_ERROR_1("Cmd list entry not found :  handle %d", params_ptr->header.handle);
  }
} /* qmi_voice_cm_if_sups_cmd_cb_handler() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_COMMAND_CALLBACK()

  DESCRIPTION
    Sups command callback to be invoked by CM

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_command_callback
(
  void                   *data_block_ptr,
  cm_sups_cmd_e_type      sups_cmd,
  cm_sups_cmd_err_e_type  sups_cmd_err
)
{
  qmi_mmode_cmd_data_buf_type *cmd_ptr;
  
  
  
  cmd_ptr = qmi_mmode_get_cmd_data_buf();
  if(NULL == cmd_ptr)
  {
	  qmi_voice_cmd_fatal();
    return;
  }
  cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
  if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(cmd_ptr);
    return;
  }

  cmd_ptr->cmd.cm_if_data_ptr->header.cmd    = QMI_VOICE_CM_IF_CMD_SUPS_CMD_CB;
  cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)data_block_ptr;

  /* Call CM command callback event handler */
  cmd_ptr->cmd.cm_if_data_ptr->data.sups_cmd_cb.cmd     = sups_cmd;
  cmd_ptr->cmd.cm_if_data_ptr->data.sups_cmd_cb.cmd_err = sups_cmd_err;
  
  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);

} /* qmi_voice_cm_if_sups_command_callback() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_EXTEN_COMMAND_CALLBACK()

  DESCRIPTION
    Sups extended command callback to be invoked by CM for FDN checks.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_exten_command_callback
(
  void                   *data_block_ptr,
  cm_sups_cmd_e_type      sups_cmd,
  cm_sups_cmd_err_e_type  sups_cmd_err,
  cm_sups_cmd_err_cause_e_type err_cause,
  cm_alpha_s_type              alpha
)
{
  qmi_mmode_cmd_data_buf_type *cmd_ptr;
  

  
  cmd_ptr = qmi_mmode_get_cmd_data_buf();
  if(NULL == cmd_ptr)
  {
	  qmi_voice_cmd_fatal();
    return;
  }
  cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
  if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(cmd_ptr);
    return;
  }

  cmd_ptr->cmd.cm_if_data_ptr->header.cmd    = QMI_VOICE_CM_IF_CMD_SUPS_CMD_EXTEN_CB;
  cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)data_block_ptr;

  /* Call CM command callback event handler */
  cmd_ptr->cmd.cm_if_data_ptr->data.sups_exten_cmd_cb.cmd     = sups_cmd;
  cmd_ptr->cmd.cm_if_data_ptr->data.sups_exten_cmd_cb.cmd_err = sups_cmd_err;
  cmd_ptr->cmd.cm_if_data_ptr->data.sups_exten_cmd_cb.err_cause     = err_cause;
  memscpy((void *)&(cmd_ptr->cmd.cm_if_data_ptr->data.sups_exten_cmd_cb.alpha) ,sizeof(cmd_ptr->cmd.cm_if_data_ptr->data.sups_exten_cmd_cb.alpha ), (const void *)&alpha ,sizeof(cm_alpha_s_type));
  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);

} /* qmi_voice_cm_if_sups_extern_command_callback() */


/*===========================================================================
                    ECALL COMMAND CALLBACK
===========================================================================*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_ECALL_ORIG_INFO_CMD_CB_HANDLER()

  DESCRIPTION
    Handle Ecall Call orig info callback here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_ecall_orig_info_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
)
{
  qmi_voice_cmd_list_public_type cmd_info;
    
  ASSERT(params_ptr != NULL);
    
  if ( qmi_voice_cmd_list_query( params_ptr->header.handle, &cmd_info ) == E_SUCCESS )
  {
    if(params_ptr->data.ecall_orig_info_cb.session_status != ECALL_PASS )
    {
      //QM_MSG_MED("ECall orig failure returned in callback");
      qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_INCOMPATIBLE_STATE, TRUE , TRUE );

       /* Reset the relevant eCall info */
      cm_if_info.eCall_info.as_id = QMI_VOICE_CM_IF_AS_ID_INVALID;
    }
    else
    {
      cm_alpha_s_type           alpha;
      cm_num_s_type called_number;
      cm_ip_call_attrib_info_s_type call_attrib;

      /* save the call_id, client_id, as_id for use upon CM Call cmd error callback */
      cm_if_info.eCall_info.eCall_id = params_ptr->data.ecall_orig_info_cb.call_id;
      cm_if_info.eCall_info.eCall_client_id = params_ptr->data.ecall_orig_info_cb.eCall_client_id;
      if ( params_ptr->data.ecall_orig_info_cb.is_as_id_available == TRUE )
      {
        cm_if_info.eCall_info.as_id = params_ptr->data.ecall_orig_info_cb.as_id;
      }

      memset(&alpha, 0, sizeof(alpha));
      memset(&called_number, 0, sizeof(called_number));
      memset(&call_attrib, 0, sizeof(call_attrib));

      /* Add entry to call list */
      if ( qmi_voice_call_list_new( cm_if_info.eCall_info.eCall_id, CM_CALL_TYPE_VOICE, 
                                    SYS_SYS_MODE_NO_SRV, CM_CALL_DIRECTION_MO, QMI_VOICE_CALL_LIST_STATE_CC_IN_PROG,
                                    cm_if_info.als.curr_line, called_number, alpha, 0, TRUE
                                    ,cm_if_info.eCall_info.as_id
                                    ,call_attrib
                                   ) != E_SUCCESS )
      {
        /* Ignore it.The entry will be added upon call event orig */
         //QM_MSG_ERROR("Unable to add call entry");
      }

      /* Update the cmd list entry */
      qmi_voice_cmd_list_update_pending_event_and_state(cmd_info.hdl, QMI_VOICE_CM_IF_EVT_CALL_ORIG, QMI_VOICE_CMD_AWAITING_MORE_AMSS_EVENTS );
      qmi_voice_cmd_list_update_sub_id(cmd_info.hdl,cm_if_info.eCall_info.eCall_id);
      QM_MSG_MED_2("ECall orig callback success: call_id %d, client_id %d", cm_if_info.eCall_info.eCall_id, cm_if_info.eCall_info.eCall_client_id);
    }
  }
  else
  {
    QM_MSG_ERROR_1("Invalid handle(%d) returned by eCall", params_ptr->header.handle);
  }

}/* qmi_voice_cm_if_ecall_call_orig_info_cmd_cb_handler */

#ifdef FEATURE_ECALL_APP
/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_ECALL_ORIG_EXTEN_INFO_CB()

  DESCRIPTION
    Command callback to be invoked by eCall once call origination is sent to CM or upon failure

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_ecall_orig_exten_info_cb 
(
  void                             *data_block_ptr,
  ecall_session_status_type         session_status,
  cm_call_id_type                   call_id,
  cm_client_id_type                 client_id,
  ecall_call_orig_exten_info_s_type exten_info
)
{
  qmi_mmode_cmd_data_buf_type *cmd_ptr;
  
  
  
  cmd_ptr = qmi_mmode_get_cmd_data_buf();
  if(NULL == cmd_ptr)
  {
	  qmi_voice_cmd_fatal();
    return;
  }
  cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
  if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(cmd_ptr);
    return;
  }

  cmd_ptr->cmd.cm_if_data_ptr->header.cmd    = QMI_VOICE_CM_IF_CMD_ECALL_ORIG_INFO_CMD_CB;
  cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)data_block_ptr;

  /* Call CM command callback event handler */
  cmd_ptr->cmd.cm_if_data_ptr->data.ecall_orig_info_cb.session_status  = session_status;
  cmd_ptr->cmd.cm_if_data_ptr->data.ecall_orig_info_cb.call_id  = call_id;
  cmd_ptr->cmd.cm_if_data_ptr->data.ecall_orig_info_cb.eCall_client_id = client_id;
  cmd_ptr->cmd.cm_if_data_ptr->data.ecall_orig_info_cb.is_as_id_available = exten_info.is_as_id_available;
  cmd_ptr->cmd.cm_if_data_ptr->data.ecall_orig_info_cb.as_id = exten_info.as_id;
  
  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);

}/* qmi_voice_cm_if_ecall_orig_exten_info_cb */
#endif /* FEATURE_ECALL_APP */

  /*===========================================================================
    FUNCTION QMI_VOICE_CM_IF_CALL_CMD_ERR_CB_HANDLER()
  
    DESCRIPTION
      Handle CM call error callback here.
  
    PARAMETERS
      None
  
    RETURN VALUE
      None
  
    DEPENDENCIES
      None
  
    SIDE EFFECTS
      None
  ===========================================================================*/
  static void qmi_voice_cm_if_call_cmd_err_cb_handler
  (
    qmi_voice_cm_if_info_item_s *params_ptr
  )
  {
    qmi_error_e_type err_val = QMI_ERR_INTERNAL;
    qmi_voice_cmd_list_public_type cmd_info;
    qmi_voice_cm_if_call_cmd_err_cb_s *err_cb;
  
    ASSERT(params_ptr != NULL);
  
    err_cb = &params_ptr->data.call_cmd_err_cb;
  
    /* Check if this is err callback for ecall origination */
    if( (cm_if_info.eCall_info.eCall_id == err_cb->call_id ) &&
        (cm_if_info.eCall_info.eCall_client_id == err_cb->client_id) ) 
    {
      if ( qmi_voice_cmd_list_query_by_event_and_sub_id( QMI_VOICE_CM_IF_EVT_CALL_ORIG,
                                                         err_cb->call_id,
                                                         &cmd_info, 
                                                         cm_if_info.eCall_info.as_id ) == E_SUCCESS )
      {
          QM_MSG_MED("ECall orig failure returned in CM err callback");
          err_val = qmi_voice_cm_if_map_call_error_to_qmi(err_cb->cmd_err);
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, err_val, TRUE , TRUE );

           /* Free the call instance */
           qmi_voice_call_list_free( (cm_call_id_type) err_cb->call_id, FALSE);
  
           /* Reset the eCall info */
          cm_if_info.eCall_info.eCall_id = CM_CALL_ID_INVALID;
          cm_if_info.eCall_info.eCall_client_id = CM_CLIENT_ID_ANONYMOUS;
          cm_if_info.eCall_info.as_id = QMI_VOICE_CM_IF_AS_ID_INVALID;
      }
      else
      {
        QM_MSG_MED_1("Cmd list entry not found for sub_id %d", err_cb->call_id);
      }
    }
    else
    {
      QM_MSG_HIGH_2("Unknown call_id %d, client_id %d from CM", err_cb->call_id, err_cb->client_id);
    }
  }


  /*===========================================================================
    FUNCTION QMI_VOICE_CM_IF_CALL_CMD_ERR_CB()
  
    DESCRIPTION
      Call command Error callback to be invoked by CM
  
    PARAMETERS
      None
  
    RETURN VALUE
      None
  
    DEPENDENCIES
      None
  
    SIDE EFFECTS
      None
  ===========================================================================*/
void qmi_voice_cm_if_call_cmd_err_cb
(
  cm_call_id_type              call_id,
  cm_client_id_type            client_id,
  cm_call_cmd_e_type           cmd,
  cm_call_cmd_err_e_type       cmd_err
)
{
    qmi_mmode_cmd_data_buf_type *cmd_ptr;

  if( cmd == CM_CALL_CMD_ORIG ) 
  {
    cmd_ptr = qmi_mmode_get_cmd_data_buf();
    if(NULL == cmd_ptr)
    {
		qmi_voice_cmd_fatal();
      return;
    }
    cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
    if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
    {
		qmi_voice_mem_fatal();
      qmi_mmode_free_cmd_data_buf(cmd_ptr);
      return;
    }
    
    cmd_ptr->cmd.cm_if_data_ptr->header.cmd    = QMI_VOICE_CM_IF_CMD_CALL_CMD_ERR_CB;
    
    /* Call CM command callback event handler */
    cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_err_cb.call_id  = call_id;
    cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_err_cb.client_id = client_id;
    cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_err_cb.cmd  = cmd;
    cmd_ptr->cmd.cm_if_data_ptr->data.call_cmd_err_cb.cmd_err = cmd_err;
    
    qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);

  }

}



/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SEND_CC_RESP_TO_OLD_SUPS_REQUEST()

  DESCRIPTION
    Send the response to the old sups request which was modified by 
    call control.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_send_cc_resp_to_old_sups_request
(
  cm_sups_info_s_type *sups_info_ptr
)
{
  qmi_voice_cmd_list_public_type list_info;
  cm_cc_result_e_type cm_cc_result;
  qmi_voice_cm_if_info_item_s *sups_rsp;
  qmi_voice_cm_if_sups_cc_result_s sups_cc_result;
  uint8 conn_idx = 0, as_id = QMI_VOICE_CM_IF_AS_ID_PRIMARY;
  qmi_voice_cm_if_alpha_id_s alpha;
  boolean is_alpha_available = FALSE;
  size_t rsp_len = 0;
  cm_num_s_type number;
  qmi_voice_cm_if_cc_mod_e_type cc_mod_type = QMI_VOICE_CM_IF_CC_MOD_TO_SS;
  qmi_voice_cm_util_ss_info_s util_sys_info;
  cm_ip_call_attrib_info_s_type  call_attrib_info;


  ASSERT(sups_info_ptr != NULL);

  memset(&list_info,0,sizeof(list_info));
  memset(&call_attrib_info, 0 , sizeof(call_attrib_info));

  /* Check for the sups request with the ss_ref */
  if(
      (qmi_voice_cmd_list_query_by_sub_id(sups_info_ptr->ss_ref, &list_info)!= E_SUCCESS) &&
      (sups_info_ptr->mod_ss_params.call_control_result != CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_VOICE)
    )
  {
    QM_MSG_HIGH_1("Sups request not found in cmd list for sub id %d", sups_info_ptr->ss_ref);
    return;
  }

  sups_rsp = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*sups_rsp));
  
  if(NULL == sups_rsp)
  {
	  qmi_voice_mem_error();
    return;
  }

  memset(sups_rsp,0,sizeof(*sups_rsp));
  memset(&alpha,0,sizeof(alpha));
  memset(&sups_cc_result,0,sizeof(sups_cc_result));
  memset(&number,0,sizeof(number));
  cm_cc_result = sups_info_ptr->mod_ss_params.call_control_result;

  if(CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_VOICE == cm_cc_result)
  {
    memset(&util_sys_info, 0, sizeof(util_sys_info));
    #ifdef FEATURE_DUAL_SIM
    as_id = (uint8)sups_info_ptr->asubs_id;
    #endif
    qmi_voice_cm_util_get_ss_info(&util_sys_info,as_id);

    sups_cc_result.is_mod_to_voice = TRUE;
    cc_mod_type = QMI_VOICE_CM_IF_CC_MOD_TO_VOICE;
    QM_MSG_HIGH_1("Modified Call id returned by CM = %d", sups_info_ptr->mod_ss_params.call_id);
    /* Add entry to call list */
    if ( qmi_voice_call_list_new( sups_info_ptr->mod_ss_params.call_id, CM_CALL_TYPE_VOICE, 
                                  util_sys_info.sys_mode, CM_CALL_DIRECTION_MO, QMI_VOICE_CALL_LIST_STATE_CC_IN_PROG,
                                  cm_if_info.als.curr_line, number,sups_info_ptr->cc_result_alpha, 
                                  CM_CALL_MODE_INFO_GW_CS, FALSE, as_id, call_attrib_info) != E_SUCCESS )
    {
      /* Ignore it.The entry will be added upon call event orig */
      //QM_MSG_ERROR("Unable to add call entry to the call list");
    }
    /* Get the Conn ID for the corresponding call id */
    else if(qmi_voice_call_list_get_conn_idx_from_call_id( sups_info_ptr->mod_ss_params.call_id, &conn_idx ) != E_SUCCESS)
    {
      //QM_MSG_ERROR_1("Conn index not found for call id = %d ", sups_info_ptr->mod_ss_params.call_id);
    }
    else
    {
      sups_cc_result.call_id = conn_idx;
    }
  }
  else if((CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_SS == cm_cc_result) ||
          (CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_USSD == cm_cc_result) ||
          (CM_CC_RESULT_ALLOWED_BUT_MODIFIED == cm_cc_result))
  {
    sups_cc_result.is_mod_to_sups = TRUE; 
    QM_MSG_MED_2("Modified to Sups:  ss_code %d and ss_operation %d", sups_info_ptr->ss_code, sups_info_ptr->ss_operation);
    sups_cc_result.reason = qmi_voice_cm_sups_get_reason_from_ss_code(sups_info_ptr->ss_code);
    sups_cc_result.service =  qmi_voice_cm_sups_get_service_type_from_operation(sups_info_ptr->ss_operation);
    if (cm_cc_result == CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_USSD)
    {
      cc_mod_type = QMI_VOICE_CM_IF_CC_MOD_TO_USSD;
    }
  }
  else
  {
    QM_MSG_ERROR_1("Invalid call control result from CM %d", cm_cc_result);
    if(NULL != sups_rsp)
    {
      //QM_MSG_MED("Freeing memory for sups_rsp");
      QMI_VOICE_CM_IF_MEM_FREE(sups_rsp);
    }
    return;
  }

  /* Check if alpha present */
  if(sups_info_ptr->cc_result_alpha.len > 0)
  {
    is_alpha_available = TRUE;

    qmi_voice_cm_util_copy_alpha_info_from_cm(&(alpha),&(sups_info_ptr->cc_result_alpha));
    QM_MSG_HIGH_2("Recevied ALPHA DCS from CM = %d, Voice = %d", sups_info_ptr->cc_result_alpha.dcs, alpha.alpha_dcs);
  }

  /* Find the sups command and send response */
  switch(list_info.cmd)
  {
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIR:
      sups_rsp->data.get_clir_resp.resp.error = QMI_ERR_NONE_V01;
      if(sups_cc_result.is_mod_to_voice)
      {
        sups_rsp->data.get_clir_resp.cc_result_type = VOICE_CC_RESULT_TYPE_VOICE_V02;
        sups_rsp->data.get_clir_resp.call_id_valid = TRUE;
        sups_rsp->data.get_clir_resp.call_id = sups_cc_result.call_id;
      }
      else
      {
        sups_rsp->data.get_clir_resp.cc_sups_result_valid = TRUE;
        sups_rsp->data.get_clir_resp.cc_sups_result.service_type = (voice_cc_sups_result_service_type_enum_v02)sups_cc_result.service;
        sups_rsp->data.get_clir_resp.cc_sups_result.reason = (voice_cc_sups_result_reason_enum_v02)sups_cc_result.reason;
      }
      sups_rsp->data.get_clir_resp.cc_result_type_valid = TRUE;
      sups_rsp->data.get_clir_resp.cc_result_type = (voice_cc_result_type_enum_v02)cc_mod_type;
      if(is_alpha_available)
      {
        sups_rsp->data.get_clir_resp.alpha_id_valid = TRUE;
        sups_rsp->data.get_clir_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)alpha.alpha_dcs;
        sups_rsp->data.get_clir_resp.alpha_id.alpha_text_len = alpha.alpha_len;
        memscpy(sups_rsp->data.get_clir_resp.alpha_id.alpha_text, QMI_VOICE_ALPHA_TEXT_MAX_V02, alpha.alpha_text, QMI_VOICE_CM_IF_MAX_ALPHA_TAG_CHARS);
      }
      rsp_len = sizeof(sups_rsp->data.get_clir_resp);
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CLIP:
      sups_rsp->data.get_clip_resp.resp.error = QMI_ERR_NONE_V01;
      if(sups_cc_result.is_mod_to_voice)
      {
        sups_rsp->data.get_clip_resp.cc_result_type = VOICE_CC_RESULT_TYPE_VOICE_V02;
        sups_rsp->data.get_clip_resp.call_id_valid = TRUE;
        sups_rsp->data.get_clip_resp.call_id = sups_cc_result.call_id;
      }
      else
      {
        sups_rsp->data.get_clip_resp.cc_sups_result_valid = TRUE;
        sups_rsp->data.get_clip_resp.cc_sups_result.service_type = (voice_cc_sups_result_service_type_enum_v02)sups_cc_result.service;
        sups_rsp->data.get_clip_resp.cc_sups_result.reason = (voice_cc_sups_result_reason_enum_v02)sups_cc_result.reason;
      }
      sups_rsp->data.get_clip_resp.cc_result_type_valid = TRUE;
      sups_rsp->data.get_clip_resp.cc_result_type = (voice_cc_result_type_enum_v02)cc_mod_type;
      if(is_alpha_available)
      {
        sups_rsp->data.get_clip_resp.alpha_id_valid = TRUE;
        sups_rsp->data.get_clip_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)alpha.alpha_dcs;
        sups_rsp->data.get_clip_resp.alpha_id.alpha_text_len = alpha.alpha_len;
        memscpy(sups_rsp->data.get_clip_resp.alpha_id.alpha_text, QMI_VOICE_ALPHA_TEXT_MAX_V02, alpha.alpha_text, QMI_VOICE_CM_IF_MAX_ALPHA_TAG_CHARS);
      }
      rsp_len = sizeof(sups_rsp->data.get_clip_resp);
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_WAITING:
      sups_rsp->data.get_call_waiting_resp.resp.error = QMI_ERR_NONE_V01;
      if(sups_cc_result.is_mod_to_voice)
      {
        sups_rsp->data.get_call_waiting_resp.cc_result_type = VOICE_CC_RESULT_TYPE_VOICE_V02;
        sups_rsp->data.get_call_waiting_resp.call_id_valid = TRUE;
        sups_rsp->data.get_call_waiting_resp.call_id = sups_cc_result.call_id;
      }
      else
      {
        sups_rsp->data.get_call_waiting_resp.cc_sups_result_valid = TRUE;
        sups_rsp->data.get_call_waiting_resp.cc_sups_result.service_type = (voice_cc_sups_result_service_type_enum_v02)sups_cc_result.service;
        sups_rsp->data.get_call_waiting_resp.cc_sups_result.reason = (voice_cc_sups_result_reason_enum_v02)sups_cc_result.reason;
      }
      sups_rsp->data.get_call_waiting_resp.cc_result_type_valid = TRUE;
      sups_rsp->data.get_call_waiting_resp.cc_result_type = (voice_cc_result_type_enum_v02)cc_mod_type;
      if(is_alpha_available)
      {
        sups_rsp->data.get_call_waiting_resp.alpha_id_valid = TRUE;
        sups_rsp->data.get_call_waiting_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)alpha.alpha_dcs;
        sups_rsp->data.get_call_waiting_resp.alpha_id.alpha_text_len = alpha.alpha_len;
        memscpy(sups_rsp->data.get_call_waiting_resp.alpha_id.alpha_text, QMI_VOICE_ALPHA_TEXT_MAX_V02, alpha.alpha_text, QMI_VOICE_CM_IF_MAX_ALPHA_TAG_CHARS);
      }
      rsp_len = sizeof(sups_rsp->data.get_call_waiting_resp);
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_GET_CALL_BARRING:
      sups_rsp->data.get_call_barring_resp.error = QMI_ERR_NONE;
      sups_rsp->data.get_call_barring_resp.cc_result = sups_cc_result;
      sups_rsp->data.get_call_barring_resp.is_cc_modified = TRUE;
      sups_rsp->data.get_call_barring_resp.cc_mod_type = (uint8)cc_mod_type;
      if(is_alpha_available)
      {
        sups_rsp->data.get_call_barring_resp.is_alpha_available = TRUE;
        sups_rsp->data.get_call_barring_resp.alpha_id = alpha;
      }
      rsp_len = sizeof(sups_rsp->data.get_call_barring_resp);
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_SET_CALL_BARRING:
      sups_rsp->data.set_call_barring_resp.resp.error = QMI_ERR_NONE_V01;
      if(sups_cc_result.is_mod_to_voice)
      {
        sups_rsp->data.set_call_barring_resp.cc_result_type = VOICE_CC_RESULT_TYPE_VOICE_V02;
        sups_rsp->data.set_call_barring_resp.call_id_valid = TRUE;
        sups_rsp->data.set_call_barring_resp.call_id = sups_cc_result.call_id;
      }
      else
      {
        sups_rsp->data.set_call_barring_resp.cc_sups_result_valid = TRUE;
        sups_rsp->data.set_call_barring_resp.cc_sups_result.service_type = (voice_cc_sups_result_service_type_enum_v02)sups_cc_result.service;
        sups_rsp->data.set_call_barring_resp.cc_sups_result.reason = (voice_cc_sups_result_reason_enum_v02)sups_cc_result.reason;
      }
      sups_rsp->data.set_call_barring_resp.cc_result_type_valid = TRUE;
      sups_rsp->data.set_call_barring_resp.cc_result_type = (voice_cc_result_type_enum_v02)cc_mod_type;
      if(is_alpha_available)
      {
        sups_rsp->data.set_call_barring_resp.alpha_id_valid = TRUE;
        sups_rsp->data.set_call_barring_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)alpha.alpha_dcs;
        sups_rsp->data.set_call_barring_resp.alpha_id.alpha_text_len = alpha.alpha_len;
        memscpy(sups_rsp->data.set_call_barring_resp.alpha_id.alpha_text, QMI_VOICE_ALPHA_TEXT_MAX_V02, alpha.alpha_text, QMI_VOICE_CM_IF_MAX_ALPHA_TAG_CHARS);
      }
      rsp_len = sizeof(sups_rsp->data.set_call_barring_resp);
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_SET_SUPS_SERVICE:
      sups_rsp->data.set_sups_resp.resp.error = QMI_ERR_NONE_V01;
      if(sups_cc_result.is_mod_to_voice)
      {
        sups_rsp->data.set_sups_resp.cc_result_type = VOICE_CC_RESULT_TYPE_VOICE_V02;
        sups_rsp->data.set_sups_resp.call_id_valid = TRUE;
        sups_rsp->data.set_sups_resp.call_id = sups_cc_result.call_id;
      }
      else
      {
        sups_rsp->data.set_sups_resp.cc_sups_result_valid = TRUE;
        sups_rsp->data.set_sups_resp.cc_sups_result.service_type = (voice_cc_sups_result_service_type_enum_v02)sups_cc_result.service;
        sups_rsp->data.set_sups_resp.cc_sups_result.reason = (voice_cc_sups_result_reason_enum_v02)sups_cc_result.reason;
      }
      sups_rsp->data.set_sups_resp.cc_result_type_valid = TRUE;
      sups_rsp->data.set_sups_resp.cc_result_type = (voice_cc_result_type_enum_v02)cc_mod_type;
      if(is_alpha_available)
      {
        sups_rsp->data.set_call_barring_resp.alpha_id_valid = TRUE;
        sups_rsp->data.set_call_barring_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)alpha.alpha_dcs;
        sups_rsp->data.set_call_barring_resp.alpha_id.alpha_text_len = alpha.alpha_len;
        memscpy(sups_rsp->data.set_call_barring_resp.alpha_id.alpha_text, QMI_VOICE_ALPHA_TEXT_MAX_V02, alpha.alpha_text, QMI_VOICE_CM_IF_MAX_ALPHA_TAG_CHARS);
      }
      rsp_len = sizeof(sups_rsp->data.set_sups_resp);
      break;
    case QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD:
      sups_rsp->data.ussd_orig_resp.resp.error = QMI_ERR_NONE_V01;
      sups_rsp->data.ussd_orig_resp.cc_sups_result_valid = TRUE;
      sups_rsp->data.ussd_orig_resp.cc_sups_result.service_type = (voice_cc_sups_result_service_type_enum_v02)sups_cc_result.service;
      sups_rsp->data.ussd_orig_resp.cc_sups_result.reason = (voice_cc_sups_result_reason_enum_v02)sups_cc_result.reason;
      sups_rsp->data.ussd_orig_resp.cc_result_type_valid = TRUE;
      sups_rsp->data.ussd_orig_resp.cc_result_type = (CM_CC_RESULT_ALLOWED_BUT_MODIFIED == cm_cc_result)? 
                                                     VOICE_CC_RESULT_TYPE_USSD_V02 : (voice_cc_result_type_enum_v02)cc_mod_type;
      if(is_alpha_available)
      {
        sups_rsp->data.ussd_orig_resp.alpha_id_valid = TRUE;
        sups_rsp->data.ussd_orig_resp.alpha_id.alpha_dcs = (alpha_dcs_enum_v02)alpha.alpha_dcs;
        sups_rsp->data.ussd_orig_resp.alpha_id.alpha_text_len = alpha.alpha_len;
        memscpy(sups_rsp->data.ussd_orig_resp.alpha_id.alpha_text, QMI_VOICE_ALPHA_TEXT_MAX_V02, alpha.alpha_text, QMI_VOICE_CM_IF_MAX_ALPHA_TAG_CHARS);
      }
      rsp_len = sizeof(sups_rsp->data.ussd_orig_resp);
      break;
  
    default:
      QM_MSG_HIGH_1("Invalid sups cmd %d", list_info.cmd);
      if(NULL != sups_rsp)
      {
        //QM_MSG_MED("Freeing memory for sups_rsp");
        QMI_VOICE_CM_IF_MEM_FREE(sups_rsp);
      }
      return;
  }
  qmi_voice_cm_if_response_success(list_info.hdl,list_info.cmd,&sups_rsp->data,rsp_len,TRUE);

  if(NULL != sups_rsp)
  {
    //Freeing memory for sups_rsp
    QMI_VOICE_CM_IF_MEM_FREE(sups_rsp);
  }

} /* qmi_voice_cm_if_send_cc_resp_to_old_sups_request */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_PROCESS_CALL_CONTROL_DATA()

  DESCRIPTION
    Process the call control data in CM Sups events

  PARAMETERS
    None

  RETURN VALUE
    qmi_voice_cm_if_cc_result_e_type

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_sups_process_call_control_data
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr,
  qmi_voice_cm_if_cc_result_e_type *cc_result
)
{
  qmi_voice_cmd_list_public_type list_info;
  IxErrnoType  err_no;
  qmi_voice_cm_if_evt_e_type ntwk_rsp_evt;
  cm_cc_result_e_type cm_cc_result;
  qmi_voice_cmd_list_u_type u_info;
  qmi_voice_cm_if_cmd_info_sups_type  *cmd_info_ptr = &u_info.sups;
  uint8  as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  ASSERT(sups_info_ptr != NULL);
  ASSERT(cc_result != NULL);

  cm_cc_result = sups_info_ptr->mod_ss_params.call_control_result;
#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)sups_info_ptr->asubs_id;
#endif

  QM_MSG_HIGH_3("qmi_voice_cm_if_sups_process_call_control_data: ss ref =%d, cc result = %d, event = %d", 
                 sups_info_ptr->ss_ref, cm_cc_result, event);
  err_no = qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)event,
                                          sups_info_ptr->ss_ref,
                                          &list_info, as_id);

  /* Set the default to no modifications */
  *cc_result = QMI_VOICE_CM_IF_CC_RESULT_NO_MODIFICATIONS;

  switch(event)
  {
    case QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE:
    case QMI_VOICE_CM_IF_EVT_SUPS_REGISTER:
    case QMI_VOICE_CM_IF_EVT_SUPS_ERASE:
    case QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE:
    case QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE:
    case QMI_VOICE_CM_IF_EVT_SUPS_REG_PASSWORD:
    case QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS:
      if(E_SUCCESS == err_no)
      {
        if(QMI_VOICE_CM_IF_CMD_CALL_MOD_TO_SUPS == list_info.cmd)
        {
          /* Get the network resp event */
          ntwk_rsp_evt = qmi_voice_cm_sups_get_network_resp_event(event);
          *cc_result = QMI_VOICE_CM_IF_CC_RESULT_VOICE_MODIFIED_TO_SUPS;
          qmi_voice_cmd_list_update_pending_event_id(list_info.hdl,ntwk_rsp_evt);
        }
      }
      else if((CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_SS == cm_cc_result) ||
              (CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_USSD == cm_cc_result) ||
              (CM_CC_RESULT_ALLOWED_BUT_MODIFIED == cm_cc_result) )
      {
        *cc_result = QMI_VOICE_CM_IF_CC_RESULT_SUPS_MODIFIED_TO_SUPS;
        cmd_info_ptr->ss_code = sups_info_ptr->ss_code;
        cmd_info_ptr->ss_ref  = sups_info_ptr->ss_ref; /* ss_ref of prev sups cmd */
        ntwk_rsp_evt = qmi_voice_cm_sups_get_network_resp_event(event);
        if ( qmi_voice_cmd_list_new( QMI_VOICE_CM_IF_CMD_SUPS_MOD_TO_SUPS, QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL,
                                                       QMI_VOICE_CMD_AWAITING_MORE_AMSS_EVENTS,
                                                       ntwk_rsp_evt, sups_info_ptr->ss_ref,
                                                       &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
        {
          //QM_MSG_HIGH("Could not add entry to the list ");
        }
        qmi_voice_cm_if_send_cc_resp_to_old_sups_request(sups_info_ptr);
      }
      else
      {
        /* No call control modifications */
        QM_MSG_HIGH("No call control modifications");
      }
      break;

    case QMI_VOICE_CM_IF_EVT_SUPS_SS_MOD_TO_ORIG:
      qmi_voice_cm_if_send_cc_resp_to_old_sups_request(sups_info_ptr);
      *cc_result = QMI_VOICE_CM_IF_CC_RESULT_SUPS_MODIFIED_TO_VOICE;
      break;

    case QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF:
    case QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF:
    case QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF:
    case QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF:
    case QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF:
    case QMI_VOICE_CM_IF_EVT_SUPS_REG_PASSWORD_CONF:
    case QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF:
      if(E_SUCCESS == err_no)
      {
        if(QMI_VOICE_CM_IF_CMD_CALL_MOD_TO_SUPS == list_info.cmd)
        {
          *cc_result = QMI_VOICE_CM_IF_CC_RESULT_VOICE_MODIFIED_TO_SUPS;
        }
        else if(QMI_VOICE_CM_IF_CMD_SUPS_MOD_TO_SUPS == list_info.cmd)
        {
          *cc_result = QMI_VOICE_CM_IF_CC_RESULT_SUPS_MODIFIED_TO_SUPS;
          /* Remove the entry from cmd list */
          qmi_voice_cmd_list_free( list_info.hdl );
        }
        else
        {
          /* No call control modifications */
        }
      }
      break;

    default:
      //Invalid event to process call control data
      break;
  }

} /* qmi_voice_cm_if_sups_process_call_control_data */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_EVT_CB_HANDLER()

  DESCRIPTION
    Handles CM Sups events

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_sups_evt_cb_handler
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_sups_info_s_type *sups_info_ptr
)
{
  boolean send_sups_ind = TRUE;
  qmi_voice_cm_if_cc_result_e_type cc_result;
  qmi_voice_cmd_list_public_type list_info;
  qmi_voice_cmd_list_public_type cmd_info;
  qmi_voice_cmd_list_u_type u_info;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  ASSERT(sups_info_ptr != NULL);
  QM_MSG_MED_1("Sups event received from CM is %s",qmi_voice_cm_if_lookup_event_name(event));
#ifdef FEATURE_DUAL_SIM
  if ( (sups_info_ptr->asubs_id < SYS_MODEM_AS_ID_1) || (sups_info_ptr->asubs_id > SYS_MODEM_AS_ID_3) )
  {
    QM_MSG_FATAL_1("Invalid asubs_id %d in qmi_voice_cm_if_sups_evt_cb_handler()", sups_info_ptr->asubs_id);
    return;
  }
  as_id = (uint8)sups_info_ptr->asubs_id;
#endif

  qmi_voice_cm_if_sups_process_call_control_data(event,sups_info_ptr,&cc_result);

  /* Do not send sups indication for network responses to requests originated by qmi client that 
     are not modified by call control */
  if( qmi_voice_cmd_list_query_by_event_and_sub_id((uint32)event,
                                          sups_info_ptr->ss_ref,
                                          &list_info, as_id) == E_SUCCESS )
  {
    if( (list_info.cmd != QMI_VOICE_CM_IF_CMD_CALL_MOD_TO_SUPS) &&
       (list_info.cmd != QMI_VOICE_CM_IF_CMD_SUPS_MOD_TO_SUPS) && 
       (list_info.cmd != QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_FROM_EXTERNAL_SOURCE) &&
       qmi_voice_cm_sups_is_network_resp_event(event))
    {
      send_sups_ind = FALSE;
    }
  }

  if(QMI_VOICE_CM_IF_CC_RESULT_NO_MODIFICATIONS == cc_result)
  {
    switch(event)
    {
      case QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF:
        qmi_voice_cm_if_sups_event_interrogate_conf(event, sups_info_ptr);
        break;
    
      /* Other sups events to be handled here */
      case QMI_VOICE_CM_IF_EVT_SUPS_REG_PASSWORD_CONF:
        qmi_voice_cm_if_sups_event_reg_password_conf(event, sups_info_ptr);
        break;
    
      case QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF:
        qmi_voice_cm_if_sups_event_activate_conf(event, sups_info_ptr);
        break;
    
      case QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF:
        qmi_voice_cm_if_sups_event_deactivate_conf(event, sups_info_ptr);
        break;
    
      case QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF:
        qmi_voice_cm_if_sups_event_erase_conf(event, sups_info_ptr);
        break;
    
      case QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF:
        qmi_voice_cm_if_sups_event_register_conf(event, sups_info_ptr);
        break;
    
      case QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF:
        qmi_voice_cm_if_sups_event_process_uss_conf(event, sups_info_ptr);
        break;
    
      case QMI_VOICE_CM_IF_EVT_SUPS_GET_PASSWORD_IND:
        qmi_voice_cm_if_sups_event_get_password_ind(event, sups_info_ptr);
        send_sups_ind = FALSE;
        break;
    
      case QMI_VOICE_CM_IF_EVT_SUPS_USS_IND:
      case QMI_VOICE_CM_IF_EVT_SUPS_USS_NOTIFY_IND:
        qmi_voice_cm_if_sups_event_send_ussd_ind(event, sups_info_ptr);
        send_sups_ind = FALSE;
        break;
    
      case QMI_VOICE_CM_IF_EVT_SUPS_RELEASE_USS_IND:
        qmi_voice_cm_if_sups_event_send_ussd_release_ind(event, sups_info_ptr);
        send_sups_ind = FALSE;
        break;
    
      case QMI_VOICE_CM_IF_EVT_SUPS_CC_RESULT_INFO:
        qmi_voice_cm_if_send_cc_result_info_ind(sups_info_ptr->mod_ss_params.call_control_result,
                                                sups_info_ptr->cc_result_alpha,
                                                as_id);
        send_sups_ind = FALSE;
        break;

      case QMI_VOICE_CM_IF_EVT_SUPS_REGISTER:
      case QMI_VOICE_CM_IF_EVT_SUPS_ERASE:
      case QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE:
      case QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE:
      case QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE:
      case QMI_VOICE_CM_IF_EVT_SUPS_REG_PASSWORD:
      case QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS:
      case QMI_VOICE_CM_IF_EVT_SUPS_SS_MOD_TO_ORIG:
        /* Sups indication will be sent */
        if(event == QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS)
        {
          memset(&cmd_info, 0, sizeof(cmd_info));
          memset(&u_info,0,sizeof(u_info));
          u_info.sups.ss_code = sups_info_ptr->ss_code;
          u_info.sups.ss_ref = sups_info_ptr->ss_ref;
          if (qmi_voice_cmd_list_query_by_event_all_states( QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF, &cmd_info, as_id ) != E_SUCCESS)
          {
            QM_MSG_HIGH("USSD triggered from someother external source, Adding one with internal command");
            if ( qmi_voice_cmd_list_new( QMI_VOICE_CM_IF_CMD_SUPS_ORIG_USSD_FROM_EXTERNAL_SOURCE, QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL,
                                         QMI_VOICE_CMD_AWAITING_MORE_AMSS_EVENTS,
                                         QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF, sups_info_ptr->ss_ref,
                                         &u_info, sizeof( u_info ), as_id ) != E_SUCCESS )
            {
              QM_MSG_HIGH("Could not add ORIG_USSD_FROM_EXTERNAL_SOURCE to the list ");
            }
          }
          else
          {
            QM_MSG_HIGH_3( "%s, cmd=%d ss_ref=%d", "One instance of ORIG_USSD exists Could be originated by user/modified",cmd_info.cmd,cmd_info.sub_id);
          }
        }
        break;
    
      default:
        QM_MSG_ERROR_1("Unsupported CM event %d", event);
        send_sups_ind = FALSE;
        break;
    }
  }

  if(send_sups_ind && (cc_result != QMI_VOICE_CM_IF_CC_RESULT_SUPS_MODIFIED_TO_VOICE))
  {
    qmi_voice_cm_if_sups_event_sups_ind(event, sups_info_ptr, cc_result);
  }
    
  if(sups_info_ptr->ss_code == qmi_voice_cm_sups_bil)
  {
    /*Release reference here*/
    switch(event)
    {
      case QMI_VOICE_CM_IF_EVT_SUPS_REGISTER:
      case QMI_VOICE_CM_IF_EVT_SUPS_ERASE:
      case QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE:
      case QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE:
        if(sups_info_ptr->call_barring_num_list != NULL )
        {
          ref_cnt_obj_release( (void *) sups_info_ptr->call_barring_num_list);
          QM_MSG_MED("Reference to call_barring_num_list released");
        }
        //else:Reference to call_barring_num_list not added, not removed
        break;
      case QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF:
        if((sups_info_ptr->call_barring_num_info_list != NULL) && (sups_info_ptr->conf_type == CALL_BARRING_NUM_LIST_INFO))
        {
          ref_cnt_obj_release( (void *) sups_info_ptr->call_barring_num_info_list);
          QM_MSG_MED("Reference to call_barring_num_info_list released");
        }
        //else: Reference to call_barring_num_info_list not added, not removed
        
        break;
      default:
        QM_MSG_MED("Not any of REG/ACT/DEACT/ERASE/INT_CONF");
        break;
    }
  }

  /*Release reference here*/
  switch(event)
  {
    case QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF:
    case QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF:
    case QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF:
    case QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF:
         if(sups_info_ptr->sups_ss_error_text != NULL )
         {
           QM_MSG_MED("Reference released");
           ref_cnt_obj_release( (void *) sups_info_ptr->sups_ss_error_text);
         }
         //else:Reference not added, not removed");
         break;
    default:
       QM_MSG_MED("Not a SET_SUPS related event");
       break;
  }
}/* qmi_voice_cm_if_sups_evt_cb_handler() */



/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SUPS_EVT_CALLBACK()

  DESCRIPTION
    Sups event callback to be invoked by CM

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_sups_evt_cb 
(
  cm_sups_event_e_type sups_event, 
  const cm_sups_info_s_type *sups_info_ptr
)
{
  qmi_voice_cm_if_evt_e_type event_id;
  qmi_mmode_cmd_data_buf_type *cmd_ptr = NULL;

  if (qmi_voice_has_valid_client())
  {
    /* Figure out Event ID */
    event_id = (qmi_voice_cm_if_evt_e_type)(QMI_VOICE_CM_IF_EVT_SUPS_BASE + sups_event);

    cmd_ptr = qmi_mmode_get_cmd_data_buf();
    if(NULL == cmd_ptr)
    {
		qmi_voice_cmd_fatal();
      return;
    }
    cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
    if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
    {
		qmi_voice_mem_fatal();
      qmi_mmode_free_cmd_data_buf(cmd_ptr);
      return;
    }
    cmd_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SUPS_EVT_CB;
    cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)0x00;
    cmd_ptr->cmd.cm_if_data_ptr->data.sups_evt_cb.event = (int)event_id;
    memscpy( &cmd_ptr->cmd.cm_if_data_ptr->data.sups_evt_cb.sups_info,sizeof(cmd_ptr->cmd.cm_if_data_ptr->data.sups_evt_cb.sups_info), sups_info_ptr, sizeof(cm_sups_info_s_type));

    QM_MSG_MED_1("In qmi_voice_cm_if_sups_evt_cb():Event ID = %d", event_id);
    
    if(sups_info_ptr->ss_code == qmi_voice_cm_sups_bil)
    {
      switch((qmi_voice_cm_if_evt_e_type)event_id)
      {
        case QMI_VOICE_CM_IF_EVT_SUPS_REGISTER:
        case QMI_VOICE_CM_IF_EVT_SUPS_ERASE:
        case QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE:
        case QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE:
          //Received ICB REG/ERASE/ACT/DEACT
          if(sups_info_ptr->call_barring_num_list!= NULL)
          {
            ref_cnt_obj_add_ref((void *) sups_info_ptr->call_barring_num_list);
            QM_MSG_MED("ICB REG/ERASE/ACT/DEACT:Reference added to call_barring_num_list");
          }
          //else: ICB REG/ERASE/ACT/DEACT:Reference not added to call_barring_num_list");
          break;
        case QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF:        
         //Received ICB INT_CONF
         if((sups_info_ptr->call_barring_num_info_list != NULL) && (sups_info_ptr->conf_type == CALL_BARRING_NUM_LIST_INFO))
         {
           ref_cnt_obj_add_ref((void *) sups_info_ptr->call_barring_num_info_list);
           QM_MSG_MED("ICB INT_CONF:Reference added to call_barring_num_info_list");
         }
         //Else: ICB INT_CONF:Reference not added to call_barring_num_info_list
         break;
       default:
         //Not a add ref related event
         break;
      }
    }


    QM_MSG_MED_1("Event ID = %d", event_id);
    switch((qmi_voice_cm_if_evt_e_type)event_id)
    {
      case QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF:
      case QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF:
      case QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF:
      case QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF:
         QM_MSG_MED("REG_CONF/ACT_CONF/DEACT_CONF/ERASE_CONF ");
           if(sups_info_ptr->sups_ss_error_text!= NULL)
           {
             ref_cnt_obj_add_ref((void *) sups_info_ptr->sups_ss_error_text);
           }
           else
           {
             QM_MSG_MED("Reference not added");
           }
           break;
       default:
           //Not a SET_SUPS related event
           break;
      }    

    qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);
  }
}/* qmi_voice_cm_if_sups_evt_cb() */


/*===========================================================================
                    INBAND COMMAND, EVENT CALLBACKS
===========================================================================*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_INBAND_CMD_CB_HANDLER()

  DESCRIPTION
    Handle Inband command callback here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_inband_cmd_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
)
{
  qmi_error_e_type err_val = QMI_ERR_NONE;
  boolean cmd_exec_success = TRUE;
  qmi_voice_cmd_list_public_type cmd_info;
  void *response = NULL;
  size_t response_len;
  qmi_voice_cm_if_inband_cmd_cb_s  *inband_cmd_cb = (qmi_voice_cm_if_inband_cmd_cb_s*)(&params_ptr->data);
  voice_burst_dtmf_resp_msg_v02 burst_dtmf_resp;
  voice_start_cont_dtmf_resp_msg_v02 start_cont_dtmf_resp;
  voice_stop_cont_dtmf_resp_msg_v02 stop_cont_dtmf_resp;
  uint8 conn_idx = 0;

  memset(&burst_dtmf_resp, 0, sizeof(burst_dtmf_resp));
  memset(&start_cont_dtmf_resp, 0, sizeof(start_cont_dtmf_resp));
  memset(&stop_cont_dtmf_resp, 0, sizeof(stop_cont_dtmf_resp));

  ASSERT(params_ptr != NULL);
  
  //Inside qmi_voice_cm_if_inband_cmd_cb_handler()

  if(inband_cmd_cb->cmd_err != CM_INBAND_CMD_ERR_NOERR )
  {
    QM_MSG_MED_2("Inband command callback error %d received for cmd %d from CM", inband_cmd_cb->cmd_err, inband_cmd_cb->cmd);
    cmd_exec_success = FALSE;
    err_val = qmi_voice_cm_if_map_inband_error_to_qmi(inband_cmd_cb->cmd_err);
  }

  /* Entry found in the cmd list */
  if ( qmi_voice_cmd_list_query( params_ptr->header.handle, &cmd_info ) == E_SUCCESS )
  {
    /* Fail to execute the command */
    if ( !cmd_exec_success )
    {
      /* Send cmd FAILURE response */
      qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, err_val, TRUE , TRUE );
    }
    /* Not pending for AMSS events */
    else if ( cmd_info.pending_event_id == QMI_VOICE_CM_IF_EVT_NONE )
    {
      if( qmi_voice_call_list_get_conn_idx_from_call_id( (cm_call_id_type) cmd_info.sub_id, &conn_idx ) == E_SUCCESS )
      {
        //QM_MSG_MED_1("Found the conn index = %d in the list", conn_idx);
      }
      switch(inband_cmd_cb->cmd)
      {
        case CM_INBAND_CMD_BURST_DTMF:
          burst_dtmf_resp.call_id_valid = TRUE;
          burst_dtmf_resp.call_id = conn_idx;
          response = &burst_dtmf_resp;
          response_len = sizeof(burst_dtmf_resp);
          break;

        case CM_INBAND_CMD_START_CONT_DTMF:
          start_cont_dtmf_resp.call_id_valid = TRUE;
          start_cont_dtmf_resp.call_id = conn_idx;
          response = &start_cont_dtmf_resp;
          response_len = sizeof(start_cont_dtmf_resp);
          break;

        case CM_INBAND_CMD_STOP_CONT_DTMF:
          stop_cont_dtmf_resp.call_id_valid = TRUE;
          stop_cont_dtmf_resp.call_id = conn_idx;
          response = &stop_cont_dtmf_resp;
          response_len = sizeof(stop_cont_dtmf_resp);
          break;

        default:
          //Unsupported CM command
          return;
      }
      /* Send cmd SUCCESS response */
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, response, response_len, TRUE );
    }
    /* Force state transition to WaitingMoreAMSSEvents */
    else
    {
      qmi_voice_cm_if_force_state_transition_to_wait_amss_event( cmd_info.hdl, cmd_info.cmd, cmd_info.pending_event_id );
    }
  }
  /* Entry not found in the cmd List */
  else if ( params_ptr->header.handle != QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL )
  {
    QM_MSG_ERROR_1("Cmd list entry not found :  handle %d", params_ptr->header.handle);
  }
} /* qmi_voice_cm_if_inband_cmd_cb_handler() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_INBAND_COMMAND_CALLBACK()

  DESCRIPTION
    Inband command callback to be invoked by CM

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_inbandsvc_command_callback
(
  void                     *data_block_ptr,
  cm_inband_cmd_e_type      inband_cmd,
  cm_inband_cmd_err_e_type  inband_cmd_err
)
{
  qmi_mmode_cmd_data_buf_type *cmd_ptr;
  
  
  
  cmd_ptr = qmi_mmode_get_cmd_data_buf();
  if(NULL == cmd_ptr)
  {
    qmi_voice_cmd_fatal();
    return;
  }
  cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
  if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(cmd_ptr);
    return;
  }

  cmd_ptr->cmd.cm_if_data_ptr->header.cmd    = QMI_VOICE_CM_IF_CMD_INBAND_CMD_CB;
  cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)data_block_ptr;

  /* Call CM command callback event handler */
  cmd_ptr->cmd.cm_if_data_ptr->data.inband_cmd_cb.cmd     = inband_cmd;
  cmd_ptr->cmd.cm_if_data_ptr->data.inband_cmd_cb.cmd_err = inband_cmd_err;
  
  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);

} /* qmi_voice_cm_if_inbandsvc_command_callback() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_INBAND_EVT_CB_HANDLER()

  DESCRIPTION
    Handles CM inband events

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_inband_evt_cb_handler
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_inband_info_s_type *inband_info_ptr
)
{
  voice_dtmf_ind_msg_v02 dtmf_ind;
  #ifdef FEATURE_DUAL_SIM
  qmi_voice_call_list_buf_type *buf_ptr;
  #endif /*FEATURE_DUAL_SIM*/
  uint8 conn_idx = 0;
  qmi_voice_cm_util_ss_info_s      util_sys_info;
  qmi_voice_cmd_list_public_type cmd_info;
  void *response = NULL;
  size_t response_len = 0;
  voice_start_cont_dtmf_resp_msg_v02 start_cont_dtmf_resp;
  voice_stop_cont_dtmf_resp_msg_v02 stop_cont_dtmf_resp;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  ASSERT(inband_info_ptr != NULL);

  memset(&dtmf_ind, 0, sizeof(dtmf_ind));
  memset(&cmd_info,0,sizeof(cmd_info));
  memset(&util_sys_info, 0, sizeof( util_sys_info));
  memset(&start_cont_dtmf_resp, 0, sizeof( start_cont_dtmf_resp));
  memset(&stop_cont_dtmf_resp, 0, sizeof( stop_cont_dtmf_resp));

  QM_MSG_MED_1("Inside qmi_voice_cm_if_inband_evt_cb_handler():%d", event);

  #ifdef FEATURE_DUAL_SIM
  buf_ptr = qmi_voice_call_list_get_callid_info( inband_info_ptr->call_id);
  if ((buf_ptr != NULL ) && (buf_ptr->pub.is_as_id_valid))
  {
    as_id = buf_ptr->pub.asubs_id;
  }
  #endif /*FEATURE_DUAL_SIM*/  
  
  qmi_voice_cm_util_get_ss_info(&util_sys_info, as_id);
  
  switch(event)
  {
    case QMI_VOICE_CM_IF_EVT_INBAND_FWD_BURST_DTMF:
      dtmf_ind.on_length        = (dtmf_onlength_enum_v02)inband_info_ptr->on_length;
      dtmf_ind.on_length_valid  = TRUE;
      dtmf_ind.off_length       = (dtmf_offlength_enum_v02)inband_info_ptr->off_length;
      dtmf_ind.off_length_valid = TRUE;
      if( qmi_voice_call_list_get_conn_idx_from_call_id( inband_info_ptr->call_id, &conn_idx ) == E_SUCCESS )
      {
        //Found the conn index = %d in the list", conn_idx
      }
      dtmf_ind.dtmf_info.call_id   = conn_idx;
      dtmf_ind.dtmf_info.dtmf_event  = (dtmf_event_enum_v02)(event - QMI_VOICE_CM_IF_EVT_INBAND_BASE);
      dtmf_ind.dtmf_info.digit_buffer_len = inband_info_ptr->cnt;
      memscpy(dtmf_ind.dtmf_info.digit_buffer,sizeof(dtmf_ind.dtmf_info.digit_buffer), inband_info_ptr->digits, inband_info_ptr->cnt);
      break;

    case QMI_VOICE_CM_IF_EVT_INBAND_REV_START_CONT_DTMF:
    case QMI_VOICE_CM_IF_EVT_INBAND_REV_STOP_CONT_DTMF:
      QM_MSG_MED_1("In qmi_voice_cm_if_inband_evt_cb_handler sys_mode=%d", util_sys_info.sys_mode);
     if(!(qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_CDMA | 
                                          QMI_VOICE_CM_IF_SYS_MODE_HDR ), as_id )))
      {
        return;
      } 
    case QMI_VOICE_CM_IF_EVT_INBAND_FWD_START_CONT_DTMF:
    case QMI_VOICE_CM_IF_EVT_INBAND_FWD_STOP_CONT_DTMF:
    case QMI_VOICE_CM_IF_EVT_INBAND_REV_BURST_DTMF:
      if( qmi_voice_call_list_get_conn_idx_from_call_id( inband_info_ptr->call_id, &conn_idx ) == E_SUCCESS )
      {
        //Found the conn index = %d in the list", conn_idx
      }
      dtmf_ind.dtmf_info.call_id   = conn_idx;
      dtmf_ind.dtmf_info.dtmf_event  = (dtmf_event_enum_v02)(event - QMI_VOICE_CM_IF_EVT_INBAND_BASE);
      dtmf_ind.dtmf_info.digit_buffer_len = inband_info_ptr->cnt;
      memscpy(dtmf_ind.dtmf_info.digit_buffer,sizeof(dtmf_ind.dtmf_info.digit_buffer), inband_info_ptr->digits, inband_info_ptr->cnt);
      break;
   case QMI_VOICE_CM_IF_EVT_INBAND_REV_START_CONT_DTMF_CONF:
   case QMI_VOICE_CM_IF_EVT_INBAND_REV_STOP_CONT_DTMF_CONF:
      if(qmi_voice_cm_util_is_sys_mode( (QMI_VOICE_CM_IF_SYS_MODE_CDMA | 
                                         QMI_VOICE_CM_IF_SYS_MODE_HDR), as_id ))
      {
        return;
      }     
      if( qmi_voice_call_list_get_conn_idx_from_call_id( inband_info_ptr->call_id, &conn_idx ) == E_SUCCESS )
      {
        //Found the conn index = %d in the list", conn_idx
      }
      else /*do not proceed if associated call is not found*/
      {
        QM_MSG_ERROR_1("Not Found conn index for call id = %d in the list", inband_info_ptr->call_id);
        return;
      }

      /*if a DTMF request exists which is waiting for this event, send response*/
      if(qmi_voice_cmd_list_query_by_event_and_sub_id_all_states( event,inband_info_ptr->call_id, &cmd_info,as_id ) == E_SUCCESS)
      {
        if(inband_info_ptr->success)
        {         
          if(event == QMI_VOICE_CM_IF_EVT_INBAND_REV_START_CONT_DTMF_CONF)
          {
            start_cont_dtmf_resp.call_id_valid = TRUE;
            start_cont_dtmf_resp.call_id = conn_idx;
            response = &start_cont_dtmf_resp;
            response_len = sizeof(start_cont_dtmf_resp);
          }
          else if(event == QMI_VOICE_CM_IF_EVT_INBAND_REV_STOP_CONT_DTMF_CONF)
          {		
            stop_cont_dtmf_resp.call_id_valid = TRUE;
            stop_cont_dtmf_resp.call_id = conn_idx;
            response = &stop_cont_dtmf_resp;
            response_len = sizeof(stop_cont_dtmf_resp);
          }
          qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, response, response_len, TRUE );
        }      
        else
        { 
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_INTERNAL, TRUE , TRUE );
          /* Do not send DTMF IND when the request failed at network */
          return;
        }
      }

      /*send DTMF indication*/
      dtmf_ind.dtmf_info.call_id   = conn_idx;
      dtmf_ind.dtmf_info.dtmf_event  = (dtmf_event_enum_v02)(event - QMI_VOICE_CM_IF_EVT_INBAND_BASE - 1);     
      dtmf_ind.dtmf_info.digit_buffer_len = inband_info_ptr->cnt;
      memscpy(dtmf_ind.dtmf_info.digit_buffer, sizeof(dtmf_ind.dtmf_info.digit_buffer), inband_info_ptr->digits, inband_info_ptr->cnt);
      #ifdef FEATURE_DUAL_SIM
       if ((buf_ptr != NULL ) && (buf_ptr->pub.is_as_id_valid))
       {
         qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_DTMF_IND,(void *) &dtmf_ind, sizeof(dtmf_ind), buf_ptr->pub.asubs_id);
       }
      #else
      qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_DTMF_IND,(void *) &dtmf_ind, sizeof(dtmf_ind),as_id);
      #endif /*FEATURE_DUAL_SIM*/       
      return;

    case QMI_VOICE_CM_IF_EVT_INBAND_IP_START_DTMF_IND:
    case QMI_VOICE_CM_IF_EVT_INBAND_IP_STOP_DTMF_IND:

      //QMI_VOICE_CM_IF_EVT_INBAND_IP_START_DTMF_IND
      if( qmi_voice_call_list_get_conn_idx_from_call_id( inband_info_ptr->call_id, &conn_idx ) == E_SUCCESS )
      {
        //Found the conn index = %d in the list", conn_idx
      }
      dtmf_ind.dtmf_info.call_id   = conn_idx;
      dtmf_ind.dtmf_info.dtmf_event  = (dtmf_event_enum_v02)(event - QMI_VOICE_CM_IF_EVT_INBAND_BASE -1);
      dtmf_ind.dtmf_info.digit_buffer_len = inband_info_ptr->cnt;
      memscpy(dtmf_ind.dtmf_info.digit_buffer, sizeof(dtmf_ind.dtmf_info.digit_buffer), inband_info_ptr->digits, inband_info_ptr->cnt);
      dtmf_ind.volume_valid = TRUE;
      dtmf_ind.volume = inband_info_ptr->volume;

       QM_MSG_MED_4("INBAND_IP_DTMF_IND: call_id=%d, =dtmf_event%d, digit_cnt=%d(), volume= %",dtmf_ind.dtmf_info.call_id,
                     dtmf_ind.dtmf_info.dtmf_event, dtmf_ind.dtmf_info.digit_buffer_len, dtmf_ind.volume );	  
      break;

    default:
      /*Unsupported CM IF INBAND event */
      return;
  }
  #ifdef FEATURE_DUAL_SIM
  if ((buf_ptr != NULL ) && (buf_ptr->pub.is_as_id_valid))
  {
    as_id = buf_ptr->pub.asubs_id;
  }
  #endif
  qmi_voice_cm_if_unsol_response(QMI_VOICE_CM_IF_CMD_DTMF_IND,(void *) &dtmf_ind, sizeof(dtmf_ind), as_id);
}/* qmi_voice_cm_if_inband_evt_cb_handler() */



/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_INBAND_EVT_CALLBACK()

  DESCRIPTION
    Inband event callback to be invoked by CM

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_inband_evt_cb 
(
  cm_inband_event_e_type inband_event, 
  const cm_inband_info_s_type *inband_info_ptr
)
{
  qmi_voice_cm_if_evt_e_type event_id;
  qmi_mmode_cmd_data_buf_type *cmd_ptr;

  //Inside qmi_voice_cm_if_inband_evt_cb()


  if (qmi_voice_has_valid_client())
  {
    /* Figure out Event ID */
    event_id = (qmi_voice_cm_if_evt_e_type)(QMI_VOICE_CM_IF_EVT_INBAND_BASE + inband_event);

    cmd_ptr = qmi_mmode_get_cmd_data_buf();
    if(NULL == cmd_ptr)
    {
      QM_MSG_FATAL("Out of cmd bufs in inbandsvc event callback");
      return;
    }
    cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
    if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
    {
		qmi_voice_mem_fatal();
      qmi_mmode_free_cmd_data_buf(cmd_ptr);
      return;
    }
    cmd_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_INBAND_EVT_CB;
    cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)0x00;
    cmd_ptr->cmd.cm_if_data_ptr->data.sups_evt_cb.event = (int)event_id;
    memscpy( &cmd_ptr->cmd.cm_if_data_ptr->data.sups_evt_cb.sups_info,sizeof(cmd_ptr->cmd.cm_if_data_ptr->data.sups_evt_cb.sups_info), inband_info_ptr, sizeof(cm_inband_info_s_type));

    qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);
  }
}/* qmi_voice_cm_if_inband_evt_cb() */


/*===========================================================================
                    PHONE COMMAND, EVENT CALLBACKS
===========================================================================*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_PH_CMD_CB_HANDLER()

  DESCRIPTION
    Handle Phone command callback here.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_ph_cmd_cb_handler
(
  qmi_voice_cm_if_info_item_s *params_ptr
)
{
  qmi_error_e_type err_val = QMI_ERR_NONE;
  boolean cmd_exec_success = TRUE;
  qmi_voice_cmd_list_public_type cmd_info;
  void *response = NULL;
  size_t response_len = 0;
  qmi_voice_cm_if_ph_cmd_cb_s  *ph_cmd_cb = (qmi_voice_cm_if_ph_cmd_cb_s*)(&params_ptr->data);

  ASSERT(params_ptr != NULL);
  
  QM_MSG_MED_1("qmi_voice_cm_if_ph_cmd_cb_handler:  ph cmd %d", ph_cmd_cb->cmd);

  if(ph_cmd_cb->cmd_err != CM_PH_CMD_ERR_NOERR )
  {
    QM_MSG_MED_2("PH command callback error %d received for cmd %d from CM", ph_cmd_cb->cmd_err, ph_cmd_cb->cmd);
    cmd_exec_success = FALSE;
    err_val = qmi_voice_cm_if_map_ph_error_to_qmi(ph_cmd_cb->cmd_err);
  }

  /* Entry found in the cmd list */
  if ( qmi_voice_cmd_list_query( params_ptr->header.handle, &cmd_info ) == E_SUCCESS )
  {
    /* Fail to execute the command */
    if ( !cmd_exec_success )
    {
      /* If line selection failed, revert to the previously stored line data */
      if(CM_PH_CMD_SELECTED_LINE == ph_cmd_cb->cmd)
      {
        cm_if_info.als.curr_line =   cm_if_info.als.prev_line;
      }
      /* Send cmd FAILURE response */
      qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, err_val, TRUE , TRUE );
      return;
    }
    /* Not pending for AMSS events */
    else if ( cmd_info.pending_event_id == QMI_VOICE_CM_IF_EVT_NONE )
    {
      switch(ph_cmd_cb->cmd)
      {
        case CM_PH_CMD_LINE_SWITCHING:
        case CM_PH_CMD_SELECTED_LINE:
        case CM_PH_CMD_RESET_ACM:
        case CM_PH_CMD_SET_ACMMAX:
        case CM_PH_CMD_INFO_GET:
	case CM_PH_CMD_INFORM_SECURE_CALL_CAPABILITY:
          break;
        default:
          QM_MSG_ERROR_1("Unsupported CM PH command %d", ph_cmd_cb->cmd);
          return;
      }
      /* Send cmd SUCCESS response */
      qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, response, response_len, TRUE );
    }
    /* Force state transition to WaitingMoreAMSSEvents */
    else
    {
      qmi_voice_cm_if_force_state_transition_to_wait_amss_event( cmd_info.hdl, cmd_info.cmd, cmd_info.pending_event_id );
    }
  }
  /* Entry not found in the cmd List */
  else if ( params_ptr->header.handle != QMI_VOICE_CM_IF_HANDLE_ID_INTERNAL )
  {
    QM_MSG_ERROR_1("Cmd list entry not found :  handle %d", params_ptr->header.handle);
  }
} /* qmi_voice_cm_if_ph_cmd_cb_handler() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_PH_COMMAND_CALLBACK()

  DESCRIPTION
    Phone command callback to be invoked by CM.

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_ph_command_callback
(
  void                    *data_block_ptr,
  cm_ph_cmd_e_type        ph_cmd,
  cm_ph_cmd_err_e_type    ph_cmd_err
)
{
  qmi_mmode_cmd_data_buf_type *cmd_ptr;
  

  
  cmd_ptr = qmi_mmode_get_cmd_data_buf();
  if(NULL == cmd_ptr)
  {
	  qmi_voice_cmd_fatal();
    return;
  }
  cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
  if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(cmd_ptr);
    return;
  }

  cmd_ptr->cmd.cm_if_data_ptr->header.cmd    = QMI_VOICE_CM_IF_CMD_PH_CMD_CB;
  cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)data_block_ptr;

  /* Call CM command callback handler */
  cmd_ptr->cmd.cm_if_data_ptr->data.ph_cmd_cb.cmd     = ph_cmd;
  cmd_ptr->cmd.cm_if_data_ptr->data.ph_cmd_cb.cmd_err = ph_cmd_err;
  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);

} /* qmi_voice_cm_if_ph_command_callback() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_PH_EVT_CALLBACK()

  DESCRIPTION
    Phone event callback to be invoked by CM

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_ph_evt_cb (cm_ph_event_e_type ph_event, const cm_ph_info_s_type *ph_info_ptr)
{
  qmi_voice_cm_if_evt_e_type event_id;
  qmi_mmode_cmd_data_buf_type *cmd_ptr;


  if (qmi_voice_has_valid_client())
  {
    /* Figure out Event ID */
    event_id = (qmi_voice_cm_if_evt_e_type)(QMI_VOICE_CM_IF_EVT_PH_BASE + ph_event);

    cmd_ptr = qmi_mmode_get_cmd_data_buf();
    if(NULL == cmd_ptr)
    {
      QM_MSG_FATAL("Out of qmi_mmode cmd bufs in ph event callback");
      return;
    }
    cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
    if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
    {
		qmi_voice_mem_fatal();
      qmi_mmode_free_cmd_data_buf(cmd_ptr);
      return;
    }
    cmd_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_PH_EVT_CB;
    cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)0x00;
    cmd_ptr->cmd.cm_if_data_ptr->data.ph_evt_cb.event = (int)event_id;
    memscpy( &cmd_ptr->cmd.cm_if_data_ptr->data.ph_evt_cb.ph_info,sizeof(cmd_ptr->cmd.cm_if_data_ptr->data.ph_evt_cb.ph_info), ph_info_ptr, sizeof(cm_ph_info_s_type));

    qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);
  }
}/* qmi_voice_cm_if_ph_evt_cb() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_PH_EVT_CB_HANDLER()

  DESCRIPTION
    Handles CM phone events

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_ph_evt_cb_handler
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_ph_info_s_type *ph_info_ptr
)
{

  qmi_voice_cmd_list_public_type cmd_info;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  ASSERT(ph_info_ptr != NULL);

#ifdef FEATURE_DUAL_SIM
  as_id = (uint8)ph_info_ptr->asubs_id;
#endif

  QM_MSG_MED_1("QMI-Voice Handling phone event %s",qmi_voice_cm_if_lookup_event_name(event));
  switch(event)
  {
    case QMI_VOICE_CM_IF_EVT_PH_SELECTED_LINE:
    case QMI_VOICE_CM_IF_EVT_PH_SUBSCRIPTION_AVAILABLE:
      if( ph_info_ptr->line != cm_if_info.als.curr_line )
      {
        cm_if_info.als.prev_line = cm_if_info.als.curr_line;
        cm_if_info.als.curr_line = ph_info_ptr->line;
        QM_MSG_MED_2("Change in the line prev-%d, curr-%d", cm_if_info.als.prev_line, cm_if_info.als.curr_line);
      }
      break;
    case QMI_VOICE_CM_IF_EVT_OPRT_MODE:
      QM_MSG_MED_1("oprt_mode received from CM is --> %d", ph_info_ptr->oprt_mode);
      if((ph_info_ptr->oprt_mode != SYS_OPRT_MODE_ONLINE) && (!qmi_voice_cmd_list_is_empty()))
      {
        //Respond to all sups requests waiting for reg_conf with an error
        while(qmi_voice_cmd_list_query_by_event_all_states(QMI_VOICE_CM_IF_EVT_SUPS_REGISTER_CONF,
                                                           &cmd_info,as_id) == E_SUCCESS)
        {
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_ABORTED , TRUE, FALSE );
        }
        //Respond to all sups requests waiting for erase_conf with an error
        while(qmi_voice_cmd_list_query_by_event_all_states(QMI_VOICE_CM_IF_EVT_SUPS_ERASE_CONF,
                                                           &cmd_info,as_id) == E_SUCCESS)
        {
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_ABORTED , TRUE, FALSE );
        }
        //Respond to all sups requests waiting for activate_conf with an error
        while(qmi_voice_cmd_list_query_by_event_all_states(QMI_VOICE_CM_IF_EVT_SUPS_ACTIVATE_CONF,
                                                           &cmd_info,as_id) == E_SUCCESS)
        {
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_ABORTED , TRUE, FALSE );
        }
        //Respond to all sups requests waiting for deactivate_conf with an error
        while(qmi_voice_cmd_list_query_by_event_all_states(QMI_VOICE_CM_IF_EVT_SUPS_DEACTIVATE_CONF,
                                                           &cmd_info,as_id) == E_SUCCESS)
        {
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_ABORTED , TRUE, FALSE );
        }
        //Respond to all sups requests waiting for interrogate_conf with an error
        while(qmi_voice_cmd_list_query_by_event_all_states(QMI_VOICE_CM_IF_EVT_SUPS_INTERROGATE_CONF,
                                                           &cmd_info,as_id) == E_SUCCESS)
        {
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_ABORTED , TRUE, FALSE );
        }
        //Respond to all sups requests waiting for REG_PASSWORD_CONF with an error
        while(qmi_voice_cmd_list_query_by_event_all_states(QMI_VOICE_CM_IF_EVT_SUPS_REG_PASSWORD_CONF,
                                                           &cmd_info,as_id) == E_SUCCESS)
        {
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_ABORTED , TRUE, FALSE );
        }
        //Respond to all sups requests waiting for ussd_conf with an error
        while(qmi_voice_cmd_list_query_by_event_all_states(QMI_VOICE_CM_IF_EVT_SUPS_PROCESS_USS_CONF,
                                                           &cmd_info,as_id) == E_SUCCESS)
        {
          qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_ABORTED , TRUE, FALSE );
        }
      }
      break;
    case QMI_VOICE_CM_IF_EVT_PH_INFO:
  	  if ( qmi_voice_cmd_list_query_by_event( event, &cmd_info, as_id ) == E_SUCCESS )
  	  {
  	    if(cmd_info.cmd == QMI_VOICE_CM_IF_CMD_ALS_GET_LINE_SWITCHING_STATUS)
  	    {
          voice_als_get_line_switching_status_resp_msg_v02 get_line_switch_status_resp;
          memset(&get_line_switch_status_resp, 0, sizeof(get_line_switch_status_resp));
	      if(ph_info_ptr->als_allowed != CM_ALS_PROC_NONE)
	      {
            get_line_switch_status_resp.switch_value_valid = TRUE;
            get_line_switch_status_resp.switch_value = (voice_line_switching_enum_v02)ph_info_ptr->als_allowed;
            qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&get_line_switch_status_resp, sizeof(get_line_switch_status_resp), TRUE );
	      }
	      else
	      {
                 qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_NOT_SUPPORTED , TRUE, FALSE );
	      }		  
  	    }	
	    else if(cmd_info.cmd == QMI_VOICE_CM_IF_CMD_ALS_GET_SELECTED_LINE)
	    {
          voice_als_get_selected_line_resp_msg_v02 get_selected_line_resp;
  	      memset(&get_selected_line_resp, 0, sizeof(get_selected_line_resp));
	      if(ph_info_ptr->line != CM_ALS_LINE_NONE )
	      {
            get_selected_line_resp.line_value_valid = TRUE;
            get_selected_line_resp.line_value = (als_enum_v02)ph_info_ptr->line;
            qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&get_selected_line_resp, sizeof(get_selected_line_resp), TRUE );
	      }
 	      else
	      {
                 qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_NOT_SUPPORTED , TRUE, FALSE );
 	      } 
	    }
  	  }
      break;
    case QMI_VOICE_CM_IF_EVT_PH_RESET_ACM_COMPLETED:
      if ( qmi_voice_cmd_list_query_by_event( event, &cmd_info, as_id ) == E_SUCCESS )
      {
        if(cmd_info.cmd == QMI_VOICE_CM_IF_CMD_AOC_RESET_ACM)
        {
          voice_aoc_reset_acm_resp_msg_v02 aoc_reset_acm_resp;
          memset(&aoc_reset_acm_resp, 0, sizeof(aoc_reset_acm_resp));
          if((ph_info_ptr->aoc_info.aoc_ready == TRUE) && (ph_info_ptr->aoc_info.ACM == 0))
          {
            qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&aoc_reset_acm_resp, sizeof(aoc_reset_acm_resp), TRUE );
          }
          else
          {
            qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_NO_EFFECT, TRUE, FALSE );
          }
        }
      }
      break;
    case QMI_VOICE_CM_IF_EVT_PH_SET_ACMMAX_COMPLETED:
      if ( qmi_voice_cmd_list_query_by_event( event, &cmd_info, as_id ) == E_SUCCESS )
      {
        if(cmd_info.cmd == QMI_VOICE_CM_IF_CMD_AOC_SET_ACMMAX)
        {
          voice_aoc_set_acmmax_resp_msg_v02 aoc_set_acmmax_resp;          
          memset(&aoc_set_acmmax_resp, 0, sizeof(aoc_set_acmmax_resp));
          if(ph_info_ptr->aoc_info.aoc_ready == TRUE) //??
          {
            qmi_voice_cm_if_response_success( cmd_info.hdl, cmd_info.cmd, (void *)&aoc_set_acmmax_resp, sizeof(aoc_set_acmmax_resp), TRUE );
          }
          else
          {
            qmi_voice_cm_if_response_error( cmd_info.hdl, cmd_info.cmd, QMI_ERR_NO_EFFECT, TRUE, FALSE );
          }
        }
      }
      break;
    case QMI_VOICE_CM_IF_EVT_PH_FUNDS_LOW:
      qmi_voice_cm_if_send_aoc_low_funds_ind(as_id);
      break;
    default:
      QM_MSG_ERROR_1("Unsupported CM IF PH event %d", event);
      return;
  }

}/* qmi_voice_cm_if_ph_evt_cb_handler() */



/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SS_EVT_CALLBACK()

  DESCRIPTION
    Srv sys event callback to be invoked by CM

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_voice_cm_if_ss_evt_cb 
(
  cm_ss_event_e_type ss_event, 
  const cm_mm_msim_ss_info_s_type *ss_info_ptr
)
{
  qmi_voice_cm_if_evt_e_type event_id;
  qmi_mmode_cmd_data_buf_type *cmd_ptr;

  /* Figure out Event ID */
  event_id = (qmi_voice_cm_if_evt_e_type)(QMI_VOICE_CM_IF_EVT_SS_BASE + ss_event);

  cmd_ptr = qmi_mmode_get_cmd_data_buf();
  if(NULL == cmd_ptr)
  {
    QM_MSG_FATAL("Out of qmi_mmode cmd bufs in ss event callback");
    return;
  }
  cmd_ptr->cmd.cm_if_data_ptr = QMI_VOICE_CM_IF_MEM_ALLOC(sizeof(*(cmd_ptr->cmd.cm_if_data_ptr)));
  if( NULL == cmd_ptr->cmd.cm_if_data_ptr )
  {
	  qmi_voice_mem_fatal();
    qmi_mmode_free_cmd_data_buf(cmd_ptr);
    return;
  }
  cmd_ptr->cmd.cm_if_data_ptr->header.cmd = QMI_VOICE_CM_IF_CMD_SS_EVT_CB;
  cmd_ptr->cmd.cm_if_data_ptr->header.handle = (uint32)0x00;
  cmd_ptr->cmd.cm_if_data_ptr->data.ss_evt_cb.event = (int)event_id;
  memscpy( &cmd_ptr->cmd.cm_if_data_ptr->data.ss_evt_cb.ss_info,sizeof(cmd_ptr->cmd.cm_if_data_ptr->data.ss_evt_cb.ss_info), ss_info_ptr, sizeof(cm_mm_msim_ss_info_s_type));

  qmi_mmode_send_cmd(QMI_MMODE_CMD_VOICE_CM_IF_CB, cmd_ptr);

}/* qmi_voice_cm_if_ss_evt_cb() */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_SS_EVT_CB_HANDLER()

  DESCRIPTION
    Handles CM Srvsys events

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_ss_evt_cb_handler
( 
  qmi_voice_cm_if_evt_e_type event,
  cm_mm_msim_ss_info_s_type *ss_info_ptr
)
{
  ASSERT(ss_info_ptr != NULL);

  if ( (ss_info_ptr->asubs_id < SYS_MODEM_AS_ID_1) || (ss_info_ptr->asubs_id > SYS_MODEM_AS_ID_3) )
  {
    QM_MSG_FATAL_1("Invalid asubs_id %d in qmi_voice_cm_if_ss_evt_cb_handler()", ss_info_ptr->asubs_id);
    return;
  }

  switch(event)
  {
    case QMI_VOICE_CM_IF_EVT_SS_INFO:
    case QMI_VOICE_CM_IF_EVT_SS_SRV_CHANGED:
      qmi_voice_cm_util_set_ss_info(ss_info_ptr);
      break;

    default:
      QM_MSG_ERROR_1("Unsupported CM IF SS event %d", event);
      return;
  }

}/* qmi_voice_cm_if_ss_evt_cb_handler() */


/*===========================================================================
                    HELPER FUNCTIONS
===========================================================================*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_GET_CLIENTID()

  DESCRIPTION
    Returns the client id

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static cm_client_id_type qmi_voice_cm_if_get_clientid
(
  void
)
{
  return cm_if_info.cm_client_id;
}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_FORCE_STATE_TRANSITION_TO_WAIT_AMSS_EVENT()

  DESCRIPTION
    Update the state of the cmd in the cmd list

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_force_state_transition_to_wait_amss_event
(
  uint32                     handle,
  int                        cmd,
  qmi_voice_cm_if_evt_e_type pending_event_id
)
{
  IxErrnoType err_no;

  /*-----------------------------------------------------------------------*/

  /* Change the state of the entry in cmd list to QMI_VOICE_CMD_AWAITING_MORE_AMSS_EVENTS */
  err_no = qmi_voice_cmd_list_update_state( handle, QMI_VOICE_CMD_AWAITING_MORE_AMSS_EVENTS );
  QM_MSG_ERROR_4( "Change the state with err %d of cmd list entry to AWAITING_MORE_AMSS_EVENTS state : %s (%d), pending %s ", 
                     err_no,qmi_voice_cm_if_lookup_cmd_name( cmd ), cmd,
                     qmi_voice_cm_if_lookup_event_name( pending_event_id )); 
  /* State transition failure */
  if ( err_no == E_NOT_ALLOWED )
  {
    /* Send error response*/
    qmi_voice_cm_if_response_error( handle, cmd, QMI_ERR_INTERNAL, TRUE, FALSE );
    return;
  }
  else
  {
    QM_MSG_ERROR_3( "Cmd list entry not found : %s (%d), Handle %d", 
                     qmi_voice_cm_if_lookup_cmd_name( cmd ), cmd, handle );  
  }
}


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_READ_OTASP()

  DESCRIPTION
    Initialize the non std OTASP numbers after reading from NV

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_read_otasp
(
  void
)
{
  int i;
  memset(&cm_if_info.otasp_info,0,sizeof(qmi_voice_cm_if_otasp_info_s_type));  
  

  for (i = 0; i < QMI_VOICE_CM_IF_OTASP_NUM ; i++) 
  {		
        const byte* num2_buf;	   
	byte  num2_len;		
	nv_dial_type  ui_dial;		
	memset(&ui_dial, 0, sizeof(ui_dial));	
	ui_dial.address = (byte) (i + QMI_VOICE_NV_OTASP_NUMBER_START );
	
	if(NV_DONE_S != qmi_mmode_get_nv_item( NV_DIAL_I, ( nv_item_type * ) &ui_dial ))
	{
	  QM_MSG_HIGH_1("OTASP NV get Failed:Address:(%d)", ui_dial.address);
	}
	num2_buf = (byte *) ui_dial.digits; 	 
	num2_len = ui_dial.num_digits; 	 

	if( ui_dial.status == NV_OTASP_SD_NUM ||            
	    ui_dial.status == NV_OTASP2_SD_NUM )
	{
	  if(num2_len > QMI_VOICE_CM_IF_MAX_OTASP_NUM_LENGTH)
	  {
	    QM_MSG_HIGH_1("OTASP NV Corrupt OTASP num length = %d", num2_len);
  	    return;	
	  }
	  cm_if_info.otasp_info.num[i].num_len = (uint8) num2_len;
          memscpy(cm_if_info.otasp_info.num[i].num_buf,sizeof(cm_if_info.otasp_info.num[i].num_buf),(uint8 *) num2_buf,cm_if_info.otasp_info.num[i].num_len);
          QM_MSG_MED_2("OTASP NV Copied To:%s From:%s",cm_if_info.otasp_info.num[i].num_buf,num2_buf);
          cm_if_info.otasp_info.is_non_std_otasp_num_available = TRUE;
	}
  } /* end of for */
 
}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_ITC_AUX_INIT()

  DESCRIPTION
    Initialize the ITC aux by reading from EFS

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_itc_aux_init
(
  uint8 *itc_val
)
{
  mcfg_fs_status_e_type status = MCFG_FS_STATUS_OK;
  mm_nas_nv_items_T nas_efs_items;

  ASSERT(itc_val != NULL);

  /* Default value is 4 */
  *itc_val = QMI_VOICE_CM_IF_ITC_AUX_SPEECH_4;
  memset(&nas_efs_items, 0, sizeof(mm_nas_nv_items_T));
  

  
  status = mcfg_fs_read("/nv/item_files/modem/nas/nas_config_feature", 
                             &nas_efs_items,
                        sizeof(mm_nas_nv_items_T),
                        MCFG_FS_TYPE_EFS,
                        MCFG_FS_SUBID_0);

  if ( status != MCFG_FS_STATUS_OK )
  {
    QM_MSG_MED_1("EFS Get failed for itc: status %d", status);
    return;
  }
  else
  {
    QM_MSG_MED_1("ITC val present in EFS is %d", nas_efs_items.als_itc_value);
    if (nas_efs_items.als_itc_value == (byte)ALS_ITC_VALUE_6 )
    {
      *itc_val = QMI_VOICE_CM_IF_ITC_AUX_SPEECH_6;
    }
  }
}/* qmi_voice_cm_if_itc_aux_init */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_PROCESS_INFO_REC()

  DESCRIPTION
    Process CM events related to info rec and fill up info_record_buf 
    accordingly

  PARAMETERS
    e cm_call_event_e_type 
    p ptr to const cm_mm_call_info_s_type

  RETURN VALUE
    TRUE if it is the last info rec. FALSE otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_voice_cm_if_process_info_rec
(
  qmi_voice_cm_if_evt_e_type e, 
  const cm_mm_call_info_s_type *p 
)
{
  boolean retval=FALSE;
  uint8 conn_idx = 0;
  qmi_voice_call_list_call_ids_list_type call_ids_list;
  qmi_voice_call_list_public_type clir_call_info;
  uint8 as_id = (uint8)QMI_VOICE_CM_IF_AS_ID_PRIMARY;

  ASSERT(p != NULL);

  #ifdef FEATURE_DUAL_SIM
  if(qmi_voice_call_list_update_as_id(p->call_id, p->asubs_id) != E_SUCCESS)
  {
    //Failed to update the Active Subscription ID of CList entry 
  }
  as_id = (uint8) p->asubs_id;
  #endif

  switch (e)
  {
    case QMI_VOICE_CM_IF_EVT_CALL_DISPLAY:
      info_record_buf.display_buffer_valid = TRUE;
      memscpy(info_record_buf.display_buffer,sizeof(info_record_buf.display_buffer), p->alpha.buf, p->alpha.len);
      info_record_buf.display_buffer[p->alpha.len] = '\0';
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_CALLER_ID:
      info_record_buf.caller_id_info_valid = TRUE;
      info_record_buf.caller_id_info.caller_id_len = MIN(p->num.len, CM_MAX_CALLED_INFO_CHARS);
      memscpy(info_record_buf.caller_id_info.caller_id, sizeof(info_record_buf.caller_id_info.caller_id), 
              p->num.buf, info_record_buf.caller_id_info.caller_id_len);
      info_record_buf.caller_id_info.pi = (pi_num_enum_v02)p->num.pi;
      info_record_buf.calling_party_info_valid = TRUE;
      info_record_buf.calling_party_info.num_len = MIN(p->num.len, CM_MAX_NUMBER_CHARS);
      info_record_buf.calling_party_info.num_plan = (voice_num_plan_enum_v02)p->num.number_plan;
      info_record_buf.calling_party_info.num_type = (voice_num_type_enum_v02)p->num.number_type;
      info_record_buf.calling_party_info.pi = (pi_num_enum_v02)p->num.pi;
      info_record_buf.calling_party_info.si = (voice_si_enum_v02)p->num.si;
      memscpy(info_record_buf.calling_party_info.num, sizeof(info_record_buf.calling_party_info.num), 
              p->num.buf, info_record_buf.calling_party_info.num_len);
      
      /* check if there are any active calls, if none, update the number*/
      memset((void*)&call_ids_list, 0, sizeof(call_ids_list));
      qmi_voice_call_list_query_voice_call_ids_list_by_state(QMI_VOICE_CALL_LIST_STATE_ACTIVE,&call_ids_list, as_id);
      if(call_ids_list.num_of_call_ids == 0)
      {
        if(qmi_voice_call_list_update_num_info(p->call_id,(cm_num_s_type *)&(p->num)) != E_SUCCESS)
        {
          QM_MSG_HIGH_2( "%s %d", "Unable to update number info for call_id=",p->call_id);
        }
      }
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_SIGNAL:
      info_record_buf.signal_info.signal      = p->signal.signal;
      info_record_buf.signal_info.signal_type = p->signal.signal_type;
      info_record_buf.signal_info.alert_pitch = p->signal.alert_pitch;
      info_record_buf.signal_info_valid       = p->signal.is_signal_info_avail;
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_EXT_DISP:
      QM_MSG_HIGH_3("Extended display record call_id=%d,len=%d,display_type=%d", p->call_id, p->alpha.len, p->mode_info.info.cdma_call.ext_disp_type);
      info_record_buf.ext_display_buffer_valid = TRUE;
      memscpy(info_record_buf.ext_display_buffer, sizeof(info_record_buf.ext_display_buffer), p->alpha.buf, p->alpha.len);
      info_record_buf.ext_display_buffer[p->alpha.len] = '\0';
      //Additional Record added for Raw Extended display info .
      if(p->alpha.len <= QMI_VOICE_CM_IF_EXT_DISPLAY_RECORD_LEN_MAX)
      {
        info_record_buf.ext_display_record_valid = TRUE;
        info_record_buf.ext_display_record.display_type = p->mode_info.info.cdma_call.ext_disp_type;
        info_record_buf.ext_display_record.ext_display_info_len = p->alpha.len;
        memscpy(info_record_buf.ext_display_record.ext_display_info,sizeof(info_record_buf.ext_display_record.ext_display_info), p->alpha.buf, p->alpha.len);
      }
      //else:Invalid Record length recieved: alpha.len
      break;
      
    case QMI_VOICE_CM_IF_EVT_CALL_CONNECTED_NUM:
      if(qmi_voice_call_list_update_connected_num_info(p->call_id,(cm_num_s_type *)&(p->num), p->mode_info.info.ip_call.connected_num_is_ect_trig) != E_SUCCESS)
      {
        QM_MSG_HIGH_2( "%s %d", "Unable to update connected number info for call_id=",p->call_id);
      }   
      else
      {
        if(p->mode_info.info_type == CM_CALL_MODE_INFO_CDMA)
        {
          info_record_buf.conn_num_info_valid = TRUE;
          info_record_buf.conn_num_info.num_len = MIN(p->num.len, CM_MAX_NUMBER_CHARS);
          info_record_buf.conn_num_info.num_plan = (voice_num_plan_enum_v02)p->num.number_plan;
          info_record_buf.conn_num_info.num_type = (voice_num_type_enum_v02)p->num.number_type;
          info_record_buf.conn_num_info.pi = (pi_num_enum_v02)p->num.pi;
          info_record_buf.conn_num_info.si = (voice_si_enum_v02)p->num.si;
          memscpy(info_record_buf.conn_num_info.num, sizeof(info_record_buf.conn_num_info.num), p->num.buf, info_record_buf.conn_num_info.num_len);
        }
        else
        {
          qmi_voice_call_list_report_all_call_status_changed(p->asubs_id);
        }
      }      
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_CALLED_PARTY:
      info_record_buf.called_party_info_valid = TRUE;
      info_record_buf.called_party_info.num_len = MIN(p->num.len, CM_MAX_NUMBER_CHARS);
      info_record_buf.called_party_info.num_plan = (voice_num_plan_enum_v02)p->num.number_plan;
      info_record_buf.called_party_info.num_type = (voice_num_type_enum_v02)p->num.number_type;
      info_record_buf.called_party_info.pi = (pi_num_enum_v02)p->num.pi;
      info_record_buf.called_party_info.si = (voice_si_enum_v02)p->num.si;
      memscpy(info_record_buf.called_party_info.num,sizeof(info_record_buf.called_party_info.num),p->num.buf,info_record_buf.called_party_info.num_len);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_REDIRECTING_NUMBER:
      info_record_buf.redirecting_num_info_valid = TRUE;
      info_record_buf.redirecting_num_info.num_len = MIN(p->redirecting_number.num.len, CM_MAX_NUMBER_CHARS);
      info_record_buf.redirecting_num_info.num_plan = (voice_num_plan_enum_v02)p->redirecting_number.num.number_plan;
      info_record_buf.redirecting_num_info.num_type = (voice_num_type_enum_v02)p->redirecting_number.num.number_type;
      info_record_buf.redirecting_num_info.pi = (pi_num_enum_v02)p->redirecting_number.num.pi;
      info_record_buf.redirecting_num_info.si = (voice_si_enum_v02)p->redirecting_number.num.si;
      info_record_buf.redirecting_num_info.reason = (voice_redirecting_reason_enum_v02)p->redirecting_number.redirecting_reason;
      memscpy(info_record_buf.redirecting_num_info.num,sizeof(info_record_buf.redirecting_num_info.num),p->redirecting_number.num.buf,info_record_buf.redirecting_num_info.num_len);
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_NSS_AUD_CTRL:
      info_record_buf.audio_control_valid = TRUE;
      info_record_buf.audio_control.up_link = p->mode_info.info.cdma_call.nss_aud_ctrl_rec.up_link;
      info_record_buf.audio_control.down_link = p->mode_info.info.cdma_call.nss_aud_ctrl_rec.down_link;
      break;  

    case QMI_VOICE_CM_IF_EVT_CALL_NSS_CLIR_REC:
      info_record_buf.clir_cause_valid = TRUE;
      info_record_buf.clir_cause = (voice_nss_clir_cause_enum_v02)p->mode_info.info.cdma_call.nss_clir_rec.cause ;
      memset((void*)&call_ids_list, 0, sizeof(call_ids_list));
      memset((void*)&clir_call_info, 0 , sizeof(clir_call_info));
      qmi_voice_call_list_query_voice_call_ids_list_by_state(QMI_VOICE_CALL_LIST_STATE_INCOMING|QMI_VOICE_CALL_LIST_STATE_WAITING,&call_ids_list, as_id);

      QM_MSG_HIGH_1("Try to update number info for call_id in CLIR=%d", call_ids_list.num_of_call_ids);
      
      if(call_ids_list.num_of_call_ids != 0)
      {
        /* Rejected by user */
        QM_MSG_HIGH_2("In NSS_CLIR update number info for call_id =%d found %d", p->call_id, call_ids_list.call_id[0]);
        if( qmi_voice_call_list_query_call_id(call_ids_list.call_id[0], &clir_call_info) == E_SUCCESS ) 
        {
          QM_MSG_HIGH_1("CLIR Recieved=%d", p->mode_info.info.cdma_call.nss_clir_rec.cause);
          if( p->mode_info.info.cdma_call.nss_clir_rec.cause == 1 )
          {
            clir_call_info.num.pi = 1; 
          }
          /* Coin line */
          else if ( p->mode_info.info.cdma_call.nss_clir_rec.cause == 3 )
          {
            clir_call_info.num.pi = 4; 
          }
          /* No cause */
          else if ( p->mode_info.info.cdma_call.nss_clir_rec.cause == 0 )
          {
            clir_call_info.num.pi = 0; 
          }
          /* No cause, interaction with other service, or service not available */
          else
          {
            clir_call_info.num.pi = 2; 
          }

          if(qmi_voice_call_list_update_num_info(p->call_id,&clir_call_info.num) != E_SUCCESS)
          {
            QM_MSG_HIGH_2( "%s %d", "Unable to update number info for call_id=",p->call_id);
          }   
        }
      }
      break;  

    case QMI_VOICE_CM_IF_EVT_CALL_NSS_REL_REC:
      info_record_buf.nss_release_valid= TRUE;
      info_record_buf.nss_release = QMI_VOICE_NSS_RELEASE_FINISHED_V02;
      break;

    case QMI_VOICE_CM_IF_EVT_CALL_LINE_CTRL:
      info_record_buf.line_control_valid = TRUE;
      info_record_buf.line_control.polarity_included = p->mode_info.info.cdma_call.line_ctrl_polarity_included ;
      info_record_buf.line_control.toggle_mode = p->mode_info.info.cdma_call.line_ctrl_toggle ;
      info_record_buf.line_control.reverse_polarity = p->mode_info.info.cdma_call.line_ctrl_reverse ;
      info_record_buf.line_control.power_denial_time = p->mode_info.info.cdma_call.line_ctrl_power_denial ;
      retval = TRUE;
      break;  

    default:
      QM_MSG_MED_1("Unhandled info rec event %d", e);
      break;
  }

  if( qmi_voice_call_list_get_conn_idx_from_call_id( p->call_id, &conn_idx ) == E_SUCCESS )
  {
    ///Found the conn index
  }

  if(conn_idx != 0 )
  {
    info_record_buf.call_id = conn_idx;
  }
  else
  {
    //call id = 0xFE indicates that data is not associated with any call
    info_record_buf.call_id = 254; 
    QM_MSG_MED_1("Did not find any conn_idx associated with the call_id %d, assinging 254", p->call_id);
  }

  if ( p->mode_info.info.cdma_call.is_last_cdma_info_rec )
  {
    retval = TRUE;
  }

  return retval;
}


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_GEN_INFO_REC_IND()

  DESCRIPTION
    Generate QMI_VOICE_CM_IF_CMD_INFO_REC_IND message based on info_record_buf

  PARAMETERS
    e cm_call_event_e_type 
    p ptr to const cm_mm_call_info_s_type

  RETURN VALUE
    TRUE if it is the last info rec. FALSE otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_voice_cm_if_gen_info_rec_ind
(
  voice_info_rec_ind_msg_v02 *ind
)
{
  ASSERT(ind != NULL);


  // retrieve caller name information from ext display info rec.
  // caller name tlv if found will (now with CR#404621) be sent irrespective of call state
  if (info_record_buf.ext_display_buffer_valid)
    {
      uint8 curr=0; // current position within the alpha buf inside ext disp info rec
      uint8 len  = strlen(info_record_buf.ext_display_buffer);
      uint8 *buf = (uint8 *)info_record_buf.ext_display_buffer;
      uint8 len2=0; // length of string in buf2[]
      uint8 buf2[CM_MAX_ALPHA_TAG_CHARS]={0}; // temp buf for ext disp buf without caller id

      while ( curr < len )
      {
        if( (curr + buf[curr+1] + 2 > CM_MAX_ALPHA_TAG_CHARS) || (len2 > CM_MAX_ALPHA_TAG_CHARS) )// sanity check
          break;

        if ( !info_record_buf.caller_name_valid &&
            ( buf[curr] == (uint8)QMI_VOICE_CM_IF_DISPLAY_TAG_CALLING_PARTY_NAME   ||
              buf[curr] == (uint8)QMI_VOICE_CM_IF_DISPLAY_TAG_ORIGINAL_CALLED_NAME ||
              buf[curr] == (uint8)QMI_VOICE_CM_IF_DISPLAY_TAG_TEXT ) )
        {
          info_record_buf.caller_name_valid = TRUE;
          memscpy(info_record_buf.caller_name,sizeof(info_record_buf.caller_name), &buf[curr+2], buf[curr+1]);
          info_record_buf.caller_name[buf[curr+1]] = '\0';
        }
        else
        {
          memscpy(&buf2[len2], sizeof(buf2) - len2, &buf[curr+2], buf[curr+1]);
          len2 += buf[curr+1];
        }

        curr += 2 + buf[curr+1];
      }

      // update original ext disp buf and len
      memscpy(buf,sizeof(info_record_buf.ext_display_buffer), buf2, CM_MAX_ALPHA_TAG_CHARS);
      info_record_buf.ext_display_buffer[len2] = '\0';
    }
  

  QM_MSG_MED_2("gen_info_rec_ind is_callwaiting %d caller_name.valid %d", info_record_buf.call_waiting, info_record_buf.caller_name_valid);

  memscpy(ind,sizeof(voice_info_rec_ind_msg_v02), &info_record_buf, sizeof(info_record_buf));
}


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_EXTRACT_CALL_END_REASON()

  DESCRIPTION
    Extract the call end reason

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

static void qmi_voice_cm_if_extract_call_end_reason
(
  cm_mm_call_info_s_type *call_info_ptr
)
{
  int rej_val;
  /*-----------------------------------------------------------------------*/

  ASSERT( call_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_REL_NORMAL;

  /* Update last call fail reason for non-ps call */
  if ( call_info_ptr->call_type != CM_CALL_TYPE_PS_DATA  )
  {
    /* CDMA call end reason */
    QM_MSG_MED_2("End Recieved for call_id %d Call Info type %d", call_info_ptr->call_id, call_info_ptr->mode_info.info_type);
    QM_MSG_MED_1("End status %d", call_info_ptr->end_status);
    if( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA )
    {
      switch(call_info_ptr->end_status)
      {
        case CM_CALL_END_THERMAL_EMERGENCY:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_THERMAL_EMERGENCY;
          break;

        //SOFT and HARD CSFB failures are expected in CDMA case only
        case CM_CALL_END_1XCSFB_SOFT_FAILURE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_1XCSFB_SOFT_FAILURE;
          break;

        case CM_CALL_END_1XCSFB_HARD_FAILURE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_1XCSFB_HARD_FAILURE;
          break;

        case CM_CALL_END_CAUSE_TEMP_REDIAL_ALLOWED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_TEMP_REDIAL_ALLOWED;
          break;

        case CM_CALL_END_CAUSE_PERM_REDIAL_NOT_NEEDED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_PERM_REDIAL_NOT_NEEDED;
          break;

        default:
          cm_if_info.call_fail_cause = call_info_ptr->end_status;
          break;
      }
    }
    else if( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS )
    {
      if(( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.present == TRUE ) &&
         ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.diagnostic_length > 0 ))
      {
        if ( qmi_voice_call_list_update_diagnostic_info( call_info_ptr->call_id, 
                                                           &(call_info_ptr->mode_info.info.gw_cs_call.cc_cause) ) != E_SUCCESS )
        {
          QM_MSG_ERROR_1("Failed to update the diagnostic info for call :  call_id %d", call_info_ptr->call_id);
        }
      }

      switch(call_info_ptr->end_status)
      {
        case CM_CALL_END_CLIENT_END:
        case CM_CALL_END_REL_NORMAL:
        case CM_CALL_END_NETWORK_END:
        case CM_CALL_END_LL_CAUSE:
          if(call_info_ptr->mode_info.info.gw_cs_call.cc_cause.present)
          {
            QM_MSG_MED_1("cc_cause value:  %d", call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value);
            cm_if_info.call_fail_cause = qmi_voice_cm_if_map_cause_to_end_reason(call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value);
            cm_if_info.raw_call_fail_cause = (uint8)call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value;

          }
          if(call_info_ptr->mode_info.info.gw_cs_call.cc_reject.present)
          {
            rej_val = call_info_ptr->mode_info.info.gw_cs_call.cc_reject.rej_value;
            QM_MSG_MED_2("cc_reject_type:  %d, value %d", (int)call_info_ptr->mode_info.info.gw_cs_call.cc_reject.rej_type, rej_val);
            if(call_info_ptr->mode_info.info.gw_cs_call.cc_reject.rej_type == OTA_REJECT_CAUSE)
            {
              cm_if_info.call_fail_cause = qmi_voice_cm_if_map_ota_rej_cause_to_end_reason(rej_val);
            }
            else if(call_info_ptr->mode_info.info.gw_cs_call.cc_reject.rej_type == AS_REJECT_CAUSE)
            {
              switch(rej_val)
              {
                case 161:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_REJ_RR_REL_IND;
                  break;
                case 162:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_REJ_RR_RANDOM_ACCESS_FAILURE;
                  break;
                case 163:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_REJ_RRC_REL_IND;
                  break;
                case 164:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_REJ_RRC_CLOSE_SESSION_IND;
                  break;
                case 165:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_REJ_RRC_OPEN_SESSION_FAILURE;
                  break;
                case 166:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_REJ_LOW_LEVEL_FAIL;
                  break;
                case 167:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_REJ_LOW_LEVEL_FAIL_REDIAL_NOT_ALLOWED;
                  break;                  
                case 180:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_REJ_LOW_LEVEL_IMMED_RETRY;
                  break;                  
                case 181:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_REJ_LRRC_LOWER_LAYER_FAILURE;
                  break;
                case 182:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_REJ_ABORT_RADIO_UNAVAILABLE;
                  break;                  
                case 215:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NORMAL_CALL_CLEARING;
                  break;                   
                default:
              cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_STRATUM_FAILURE;
                  break;
              }
              
            }
            else if(call_info_ptr->mode_info.info.gw_cs_call.cc_reject.rej_type == MM_REJECT_CAUSE)
            {
              switch(rej_val)
              {
                case 168:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_INVALID_SIM;
                  break;
                case 169:
                  cm_if_info.call_fail_cause = CM_CALL_END_NO_SRV;
                  break;
                case 170:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_TIMER_T3230_EXPIRED;
                  break;                    
                case 171:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NO_CELL_AVAILABLE;
                  break;
                case 172:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_WRONG_STATE;
                  break;
                case 173:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ACCESS_CLASS_BLOCKED;
                  break;
                case 174:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ABORT_MSG_RECEIVED;
                 break;          
                case 214:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_RLF_DURING_CC_DISCONNECT;
                 break;            
                default:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_RADIO_LINK_LOST;
                  break;
              }
            }
            else if(call_info_ptr->mode_info.info.gw_cs_call.cc_reject.rej_type == CNM_MN_REJECT_CAUSE)
            {
              switch(rej_val)
              {
                case 176:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_TIMER_T303_EXPIRED;
                  break;              
                case 177:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NO_RESOURCES;
                  break;
                case 178:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CNM_MM_REL_PENDING;
                  break;                  
                case 179:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_INVALID_USER_DATA;
                  break;
                default:
                  cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_RADIO_LINK_LOST; /*Mapping to more closest error*/
                  break;
              }
            }
          }/*cc_reject present*/
          break;

        case CM_CALL_END_INCOM_REJ:
        case CM_CALL_END_SETUP_REJ:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_USER_BUSY;
          break;

        case CM_CALL_END_NO_GW_SRV:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NO_GW_SRV;
          break;

        case CM_CALL_END_NO_SRV:
          cm_if_info.call_fail_cause = CM_CALL_END_NO_SRV;
          break;

        case CM_CALL_END_NO_FULL_SRV:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NO_FULL_SRV;
          break;

        case CM_CALL_END_NO_CDMA_SRV:
          cm_if_info.call_fail_cause = CM_CALL_END_NO_CDMA_SRV;
          break;            

        case CM_CALL_END_MAX_PS_CALLS:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_MAX_PS_CALLS;
          break;

        case CM_CALL_END_NO_FUNDS:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NO_FUNDS;
          break;

        case CM_CALL_END_FADE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_FADE;
          break;

        case CM_CALL_END_THERMAL_EMERGENCY:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_THERMAL_EMERGENCY;
          break;

        case CM_CALL_END_FAIL_CAUSE_CONNECTION_EST_FAILURE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CONNECTION_EST_FAILURE;
          break;

        case CM_CALL_END_FAIL_CAUSE_CONNECTION_FAILURE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CONNECTION_FAILURE;
          break;

        case CM_CALL_END_FAIL_CAUSE_NO_RESPONSE_FROM_NW:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NO_RESPONSE_FROM_NW;
          break;

        case CM_CALL_END_FAIL_CAUSE_MT_CSFB_NO_RESPONSE_FROM_NW: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_MT_CSFB_NO_RESPONSE_FROM_NW;
          break;

        case CM_CALL_END_OFFLINE: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_OFFLINE;
          break;

        case CM_CALL_END_CAUSE_TEMP_REDIAL_ALLOWED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_TEMP_REDIAL_ALLOWED;
          break;

        case CM_CALL_END_CAUSE_PERM_REDIAL_NOT_NEEDED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_PERM_REDIAL_NOT_NEEDED;
          break;

        default:
          break;
      } /* switch end_status*/
    }
    else if((call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_IP) || 
            (call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_LTE)
           )
    {
      switch(call_info_ptr->end_status)
      {
        case CM_CALL_END_CLIENT_END:
          cm_if_info.call_fail_cause = CM_CALL_END_CLIENT_END;
          break;

        case CM_CALL_END_REL_NORMAL:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_REL_NORMAL;
          break;

        case CM_CALL_END_LL_CAUSE:  
        case CM_CALL_END_NETWORK_END:
          cm_if_info.call_fail_cause = CM_CALL_END_NETWORK_END;
          break;

        case CM_CALL_END_INCOM_REJ:
        case CM_CALL_END_SETUP_REJ:
        case CM_CALL_END_SIP_486_BUSY_HERE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_USER_BUSY;
          break;

        case CM_CALL_END_NO_GW_SRV:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NO_GW_SRV;
          break;

        case CM_CALL_END_NO_SRV:
          cm_if_info.call_fail_cause = CM_CALL_END_NO_SRV;
          break;

        case CM_CALL_END_NO_FULL_SRV:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NO_FULL_SRV;
          break;

        case CM_CALL_END_NO_CDMA_SRV:
          cm_if_info.call_fail_cause = CM_CALL_END_NO_CDMA_SRV;
          break;            

        case CM_CALL_END_MAX_PS_CALLS:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_MAX_PS_CALLS;
          break;

        case CM_CALL_END_NO_FUNDS:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NO_FUNDS;
          break;
          
        case CM_CALL_END_BAD_REQ_WAIT_INVITE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_BAD_REQ_WAIT_INVITE;
          break;
 
        case CM_CALL_END_BAD_REQ_WAIT_REINVITE: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_BAD_REQ_WAIT_REINVITE;
          break;
   
        case CM_CALL_END_INVALID_REMOTE_URI: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_INVALID_REMOTE_URI;
          break;
        
        case CM_CALL_END_REMOTE_UNSUPP_MEDIA_TYPE: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_REMOTE_UNSUPP_MEDIA_TYPE;
          break;
        
        case CM_CALL_END_PEER_NOT_REACHABLE: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_PEER_NOT_REACHABLE;
          break;
        
        case CM_CALL_END_NETWORK_NO_RESP_TIME_OUT: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NETWORK_NO_RESP_TIME_OUT;
          break;
        
        case CM_CALL_END_NETWORK_NO_RESP_HOLD_FAIL: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NETWORK_NO_RESP_HOLD_FAIL;
          break;		  
        
        case CM_CALL_END_DATA_CONNECTION_LOST: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_DATA_CONNECTION_LOST;
          break;
        
        case CM_CALL_END_UPGRADE_DOWNGRADE_REJ: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_UPGRADE_DOWNGRADE_REJ;
          break;
 
        case CM_CALL_END_SIP_403_FORBIDDEN: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_SIP_403_FORBIDDEN;
          break;

        case CM_CALL_END_FADE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_FADE;
          break;

        case CM_CALL_END_SIP_600_BUSY_EVERYWHERE: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_BUSY_EVERYWHERE;
          break;

        case CM_CALL_END_SIP_200_ANSWERED_ELSEWHERE: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ANSWERED_ELSEWHERE;
          break;
          
        case CM_CALL_END_FAIL_CAUSE_ESR_FAILURE: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ESR_FAILURE;
          break;

        case CM_CALL_END_FAIL_CAUSE_MT_CSFB_NO_RESPONSE_FROM_NW: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_MT_CSFB_NO_RESPONSE_FROM_NW;
          break;

        case CM_CALL_END_OFFLINE: 
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_OFFLINE;
          break;

        case CM_CALL_END_CALL_DEFLECTION:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CALL_DEFLECTED;
          break;
 
        case CM_CALL_END_NO_NETWORK_RESP:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NO_NETWORK_RESP;
          break;

        case CM_CALL_END_CAUSE_INTERNAL_RTP_RTCP_TIMEOUT:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_RTP_RTCP_TIMEOUT;
          break;

        case CM_CALL_END_CAUSE_INTERNAL_RINGING_RINGBACK_TIMEOUT:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_RINGING_RINGBACK_TIMEOUT;
          break;

        case CM_CALL_END_CAUSE_INTERNAL_REG_RESTORATION:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_REG_RESTORATION;
          break;

        case CM_CALL_END_CAUSE_INTERNAL_CODEC_ERROR :
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CODEC_ERROR;
          break;

        case CM_CALL_END_CAUSE_INTERNAL_UNSUPPORTED_SDP:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_UNSUPPORTED_SDP;
          break;

        case CM_CALL_END_CAUSE_INTERNAL_RTP_FAILURE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_RTP_FAILURE;
          break;

        case CM_CALL_END_CAUSE_INTERNAL_QoS_FAILURE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_QoS_FAILURE;
          break;

        case CM_CALL_END_MULTIPLE_CHOICES:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_MULTIPLE_CHOICES;
          break;

        case CM_CALL_END_MOVED_PERMANENTLY:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_MOVED_PERMANENTLY;
          break;

        case CM_CALL_END_MOVED_TEMPORARILY:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_MOVED_TEMPORARILY;
          break;

        case CM_CALL_END_USE_PROXY:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_USE_PROXY;
          break;

        case CM_CALL_END_ALTERNATE_SERVICE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ALTERNATE_SERVICE;
          break;

        case CM_CALL_END_ALTERNATE_EMERGENCY_CALL:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ALTERNATE_EMERGENCY_CALL;
          break;

        case CM_CALL_END_UNAUTHORIZED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_UNAUTHORIZED;
          break;

        case CM_CALL_END_PAYMENT_REQUIRED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_PAYMENT_REQUIRED;
          break;

        case CM_CALL_END_METHOD_NOT_ALLOWED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_METHOD_NOT_ALLOWED;
          break;

        case CM_CALL_END_NOT_ACCEPTABLE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NOT_ACCEPTABLE;
          break;

        case CM_CALL_END_PROXY_AUTHENTICATION_REQUIRED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_PROXY_AUTHENTICATION_REQUIRED;
          break;

        case CM_CALL_END_GONE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_GONE;
          break;

        case CM_CALL_END_REQUEST_ENTITY_TOO_LARGE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_REQUEST_ENTITY_TOO_LARGE;
          break;

        case CM_CALL_END_REQUEST_URI_TOO_LARGE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_REQUEST_URI_TOO_LARGE;
          break;

        case CM_CALL_END_UNSUPPORTED_URI_SCHEME:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_UNSUPPORTED_URI_SCHEME;
          break;

        case CM_CALL_END_BAD_EXTENSION:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_BAD_EXTENSION;
          break;

        case CM_CALL_END_EXTENSION_REQUIRED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_EXTENSION_REQUIRED;
          break;

        case CM_CALL_END_INTERVAL_TOO_BRIEF:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_INTERVAL_TOO_BRIEF;
          break;

        case CM_CALL_END_CALL_OR_TRANS_DOES_NOT_EXIST:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CALL_OR_TRANS_DOES_NOT_EXIST;
          break;

        case CM_CALL_END_LOOP_DETECTED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_LOOP_DETECTED;
          break;

        case CM_CALL_END_TOO_MANY_HOPS:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_TOO_MANY_HOPS;
          break;

        case CM_CALL_END_ADDRESS_INCOMPLETE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_ADDRESS_INCOMPLETE;
          break;

        case CM_CALL_END_AMBIGUOUS:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_AMBIGUOUS;
          break;

        case CM_CALL_END_REQUEST_TERMINATED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_REQUEST_TERMINATED;
          break;

        case CM_CALL_END_NOT_ACCEPTABLE_HERE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NOT_ACCEPTABLE_HERE;
          break;

        case CM_CALL_END_REQUEST_PENDING:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_REQUEST_PENDING;
          break;

        case CM_CALL_END_UNDECIPHERABLE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_UNDECIPHERABLE;
          break;

        case CM_CALL_END_CAUSE_SERVER_INTERNAL_ERROR:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_SERVER_INTERNAL_ERROR;
          break;

        case CM_CALL_END_NOT_IMPLEMENTED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_NOT_IMPLEMENTED;
          break;

        case CM_CALL_END_BAD_GATEWAY:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_BAD_GATEWAY;
          break;

        case CM_CALL_END_SERVER_TIME_OUT:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_SERVER_TIME_OUT;
          break;

        case CM_CALL_END_VERSION_NOT_SUPPORTED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_VERSION_NOT_SUPPORTED;
          break;

        case CM_CALL_END_MESSAGE_TOO_LARGE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_MESSAGE_TOO_LARGE;
          break;

        case CM_CALL_END_DOES_NOT_EXIST_ANYWHERE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_DOES_NOT_EXIST_ANYWHERE;
          break;

        case CM_CALL_END_SESS_DESCR_NOT_ACCEPTABLE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_SESS_DESCR_NOT_ACCEPTABLE;
          break;

        case CM_CALL_END_SRVCC_END_CALL:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_SRVCC_END_CALL;
          break;

        case CM_CALL_END_INTERNAL_ERROR:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_INTERNAL_ERROR;
          break;
 
        case CM_CALL_END_IP_USER_REJECT:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CALL_REJECTED;
          break;

        case CM_CALL_END_IP_LOW_BATTERY:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_LOW_BATTERY;
          break;

        case CM_CALL_END_IP_DEAD_BATTERY:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_DEAD_BATTERY;
          break;

        case CM_CALL_END_FALLBACK_TO_CS:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_FALLBACK_TO_CS;
          break;

	case CM_CALL_END_HO_NOT_FEASIBLE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_HO_NOT_FEASIBLE;
          break;
		  
        case CM_CALL_END_PDN_DISCONNECTED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_PDN_DISCONNECTED;
          break;

	case CM_CALL_END_REJECTED_ELSEWHERE:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_REJECTED_ELSEWHERE;
          break;

        case CM_CALL_END_CALL_PULLED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CALL_PULLED;
          break;

        case CM_CALL_END_CALL_PULL_OUT_OF_SYNC:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CALL_PULL_OUT_OF_SYNC;
          break;

        case CM_CALL_END_DRVCC_END_CALL:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_DRVCC_END_CALL;
          break;

        case CM_CALL_END_CAUSE_TEMP_REDIAL_ALLOWED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_TEMP_REDIAL_ALLOWED;
          break;

        case CM_CALL_END_CAUSE_PERM_REDIAL_NOT_NEEDED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_PERM_REDIAL_NOT_NEEDED;
          break;

        default:
          break;
      } /* switch end_status*/
    }    
    else
    {
      QM_MSG_HIGH_1("Unsupported info type %d", call_info_ptr->mode_info.info_type);
      /* To handle the case where CM doesn't send the call origination to lower layers and ends the call.
      QMI_Voice will receive info_type = NONE in that case with valid end status */
      switch(call_info_ptr->end_status)
      {
        case CM_CALL_END_CAUSE_TEMP_REDIAL_ALLOWED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_TEMP_REDIAL_ALLOWED;
          break;

        case CM_CALL_END_CAUSE_PERM_REDIAL_NOT_NEEDED:
          cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_PERM_REDIAL_NOT_NEEDED;
          break;

        default:
          cm_if_info.call_fail_cause = call_info_ptr->end_status;
          break;
      }
    }
  }

  /* Third Party end_status */
  if (call_info_ptr->end_status == CM_CALL_END_CS_HARD_FAILURE)
  {
    cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CS_HARD_FAILURE;
  }
  else if (call_info_ptr->end_status == CM_CALL_END_CS_ACQ_FAIL)
  {
    cm_if_info.call_fail_cause = QMI_VOICE_CM_IF_END_CS_ACQ_FAILURE;
  }

}/* qmi_voice_cm_if_extract_call_end_reason */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_MAP_QMI_TO_CM_SRV_TYPE()

  DESCRIPTION
    Map the QMI service type value to CM service type enum value

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static cm_srv_type_e_type qmi_voice_cm_if_map_qmi_to_cm_srv_type
(
  qmi_voice_cm_if_srv_type_e_type  qmi_srv_type
)
{
  cm_srv_type_e_type cm_srv_type = CM_SRV_TYPE_AUTOMATIC;

  switch(qmi_srv_type)
  {
    case QMI_VOICE_CM_IF_SRV_TYPE_AUTOMATIC:
      cm_srv_type = CM_SRV_TYPE_AUTOMATIC;
      break;
    case QMI_VOICE_CM_IF_SRV_TYPE_GSM:
      cm_srv_type = CM_SRV_TYPE_GSM;
      break;
    case QMI_VOICE_CM_IF_SRV_TYPE_WCDMA:
      cm_srv_type = CM_SRV_TYPE_WCDMA;
      break;
    case QMI_VOICE_CM_IF_SRV_TYPE_CDMA_AUTOMATIC:
      cm_srv_type = CM_SRV_TYPE_CDMA_AUTOMATIC;
      break;
    case QMI_VOICE_CM_IF_SRV_TYPE_GSM_WCDMA:
      cm_srv_type = CM_SRV_TYPE_GSM_WCDMA;
      break;
    case QMI_VOICE_CM_IF_SRV_TYPE_LTE:
      cm_srv_type = CM_SRV_TYPE_LTE;
      break;
    case QMI_VOICE_CM_IF_SRV_TYPE_TDSCDMA :
      cm_srv_type = CM_SRV_TYPE_TDS;
      break;
    case QMI_VOICE_CM_IF_SRV_TYPE_GSM_WCDMA_TDSCDMA:
      cm_srv_type = CM_SRV_TYPE_TDS_GSM_WCDMA;
      break;
    case QMI_VOICE_CM_IF_SRV_TYPE_CS_ONLY:
      cm_srv_type = CM_SRV_TYPE_CS_ONLY;
      break;
    default:
      break;
  }
  return cm_srv_type;
} /* qmi_voice_cm_if_map_qmi_to_cm_srv_type() */



/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_MAP_CAUSE_TO_END_REASON()

  DESCRIPTION
    Map the 3GPP cause value to QMI Call End reason
    The cause values can be found in 3gpp 24.008 Table-10.5.123
  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

static qmi_voice_cm_if_end_reason_e_type qmi_voice_cm_if_map_cause_to_end_reason
(
  int  cause_val
)
{
  qmi_voice_cm_if_end_reason_e_type  end_reason = QMI_VOICE_CM_IF_END_REL_NORMAL;
  uint8 i=0;
  uint8 total_size_of_end_reason_table=0;

  

  /* Cause Value to End Reason Mapping*/
  qmi_voice_cm_if_cause_to_end_reason_table_s_type qmi_voice_cm_if_end_reason_conv_table[] =
  {
    {1,          QMI_VOICE_CM_IF_END_UNASSIGNED_NUMBER},
    {3,          QMI_VOICE_CM_IF_END_NO_ROUTE_TO_DESTINATION},
    {6,          QMI_VOICE_CM_IF_END_CHANNEL_UNACCEPTABLE},
    {8,          QMI_VOICE_CM_IF_END_OPERATOR_DETERMINED_BARRING },
    {16,         QMI_VOICE_CM_IF_END_NORMAL_CALL_CLEARING},
    {17,         QMI_VOICE_CM_IF_END_USER_BUSY},
    {18,         QMI_VOICE_CM_IF_END_NO_USER_RESPONDING},
    {19,         QMI_VOICE_CM_IF_END_USER_ALERTING_NO_ANSWER},
    {21,         QMI_VOICE_CM_IF_END_CALL_REJECTED},
    {22,         QMI_VOICE_CM_IF_END_NUMBER_CHANGED},
    {25,         QMI_VOICE_CM_IF_END_PREEMPTION},
    {26,         QMI_VOICE_CM_IF_END_NORMAL_UNSPECIFIED}, /* As per Annex H of 3GPP TS 24.008, cause 26 is treated as 31*/
    {27,         QMI_VOICE_CM_IF_END_DESTINATION_OUT_OF_ORDER},
    {28,         QMI_VOICE_CM_IF_END_INVALID_NUMBER_FORMAT},
    {29,         QMI_VOICE_CM_IF_END_FACILITY_REJECTED},
    {30,         QMI_VOICE_CM_IF_END_RESP_TO_STATUS_ENQUIRY},
    {31,         QMI_VOICE_CM_IF_END_NORMAL_UNSPECIFIED},
    {34,         QMI_VOICE_CM_IF_END_NO_CIRCUIT_OR_CHANNEL_AVAILABLE},
    {38,         QMI_VOICE_CM_IF_END_NETWORK_OUT_OF_ORDER},
    {41,         QMI_VOICE_CM_IF_END_TEMPORARY_FAILURE},
    {42,         QMI_VOICE_CM_IF_END_SWITCHING_EQUIPMENT_CONGESTION},
    {43,         QMI_VOICE_CM_IF_END_ACCESS_INFORMATION_DISCARDED},
    {44,         QMI_VOICE_CM_IF_END_REQ_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE},
    {47,         QMI_VOICE_CM_IF_END_RESOURCES_UNAVAILABLE_OR_UNSPECIFIED},
    {49,         QMI_VOICE_CM_IF_END_QOS_UNAVAILABLE},
    {50,         QMI_VOICE_CM_IF_END_REQ_FACILITY_NOT_SUBSCRIBED},
    {55,         QMI_VOICE_CM_IF_END_INCOM_CALLS_BARRED_WITHIN_CUG},
    {57,         QMI_VOICE_CM_IF_END_BEARER_CAP_NOT_AUTH},
    {58,         QMI_VOICE_CM_IF_END_BEARER_CAP_UNAVAILABLE},
    {63,         QMI_VOICE_CM_IF_END_SERVICE_OPTION_NOT_AVAILABLE},
    {65,         QMI_VOICE_CM_IF_END_BEARER_SERVICE_NOT_IMPLEMENTED},
    {68,         QMI_VOICE_CM_IF_END_ACM_LIMIT_EXCEEDED},
    {69,         QMI_VOICE_CM_IF_END_REQ_FACILITY_NOT_IMPLEMENTED },
    {70,         QMI_VOICE_CM_IF_END_ONLY_DIGITAL_INFO_BEARER_AVAILABLE},
    {79,         QMI_VOICE_CM_IF_END_SERVICE_OR_OPTION_NOT_IMPLEMENTED },
    {81,         QMI_VOICE_CM_IF_END_INVALID_TRANSACTION_IDENTIFIER},
    {87,         QMI_VOICE_CM_IF_END_USER_NOT_MEMBER_OF_CUG},
    {88,         QMI_VOICE_CM_IF_END_INCOMPATIBLE_DESTINATION},
    {91,         QMI_VOICE_CM_IF_END_INVALID_TRANSIT_NW_SELECTION},
    {95,         QMI_VOICE_CM_IF_END_SEMNATICALLY_INCORRECT_MESSAGE},
    {96,         QMI_VOICE_CM_IF_END_INVALID_MANDATORY_INFORMATION},
    {97,         QMI_VOICE_CM_IF_END_MESSAGE_TYPE_NOT_IMPLEMENTED},
    {98,         QMI_VOICE_CM_IF_END_MSG_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE},
    {99,         QMI_VOICE_CM_IF_END_INFORMATION_ELEMENT_NON_EXISTENT},
    {100,        QMI_VOICE_CM_IF_END_CONDITIONAL_IE_ERROR},
    {101,        QMI_VOICE_CM_IF_END_MSG_NOT_COMPATIBLE_WITH_PROTOCOL_STATE},
    {102,        QMI_VOICE_CM_IF_END_RECOVERY_ON_TIMER_EXPIRED},
    {111,        QMI_VOICE_CM_IF_END_PROTOCOL_ERROR_UNSPECIFIED},
    {127,        QMI_VOICE_CM_IF_END_INTERWORKING_UNSPECIFIED},
    {129,        QMI_VOICE_CM_IF_END_OUTGOING_CALLS_BARRED_WITHIN_CUG},
    {130,        QMI_VOICE_CM_IF_END_NO_CUG_SELECTION},
    {131,        QMI_VOICE_CM_IF_END_UNKNOWN_CUG_INDEX},
    {132,        QMI_VOICE_CM_IF_END_CUG_INDEX_INCOMPATIBLE},
    {133,        QMI_VOICE_CM_IF_END_CUG_CALL_FAILURE_UNSPECIFIED},
    {134,        QMI_VOICE_CM_IF_END_CLIR_NOT_SUBSCRIBED},
    {135,        QMI_VOICE_CM_IF_END_CCBS_POSSIBLE},
    {136,        QMI_VOICE_CM_IF_END_CCBS_NOT_POSSIBLE}
  };

  total_size_of_end_reason_table = sizeof(qmi_voice_cm_if_end_reason_conv_table)/sizeof(qmi_voice_cm_if_cause_to_end_reason_table_s_type);

  while(i < total_size_of_end_reason_table)
  {
    if(cause_val == qmi_voice_cm_if_end_reason_conv_table[i].cause)
    {
      end_reason = qmi_voice_cm_if_end_reason_conv_table[i].reason;
      break;
    }
    i++;
  }

  /* All the cause values in the range 1 to 127 are not mapped above.
  per spec 3gpp 24.008, sec 10.5.4.11 - the unmapped cause values 
  have to be mapped as below */
  if(end_reason == QMI_VOICE_CM_IF_END_REL_NORMAL)
  {
    if((cause_val >= 0) && (cause_val < 31))
    {
      end_reason = QMI_VOICE_CM_IF_END_NORMAL_UNSPECIFIED;
    }
    else if((cause_val >= 32) && (cause_val < 47))
    {
      end_reason = QMI_VOICE_CM_IF_END_RESOURCES_UNAVAILABLE_OR_UNSPECIFIED;
    }
    else if((cause_val >= 48) && (cause_val < 63))
    {
      end_reason = QMI_VOICE_CM_IF_END_SERVICE_OPTION_NOT_AVAILABLE;
    }
    else if((cause_val >= 64) && (cause_val < 79))
    {
      end_reason = QMI_VOICE_CM_IF_END_SERVICE_OR_OPTION_NOT_IMPLEMENTED;
    }
    else if((cause_val >= 80) && (cause_val < 95))
    {
      end_reason = QMI_VOICE_CM_IF_END_SEMNATICALLY_INCORRECT_MESSAGE;
    }
    else if((cause_val >= 96) && (cause_val < 111))
    {
      end_reason = QMI_VOICE_CM_IF_END_PROTOCOL_ERROR_UNSPECIFIED;
    }
    else if((cause_val >= 112) && (cause_val < 127))
    {
      end_reason = QMI_VOICE_CM_IF_END_INTERWORKING_UNSPECIFIED;
    }
    else
    {
      QM_MSG_MED_2("cause val %d will have default end_reason %d", cause_val, end_reason);
    }
  }

  return end_reason;
}/* qmi_voice_cm_if_map_cause_to_end_reason() */


/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_MAP_OTA_REJ_CAUSE_TO_END_REASON()

  DESCRIPTION
    Map the 3GPP OTA reject cause values to QMI Call End reason
    The reject cause values can be found in 3gpp 24.008 Table-10.5.95
    
  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_voice_cm_if_end_reason_e_type qmi_voice_cm_if_map_ota_rej_cause_to_end_reason
(
  int  rej_cause_val
)
{
  qmi_voice_cm_if_end_reason_e_type  end_reason = QMI_VOICE_CM_IF_END_SERVICE_TEMPORARILY_OUT_OF_ORDER;
  uint8 i=0;
  uint8 total_size_of_end_reason_table=0;


  /* OTA Reject Cause Value to End Reason Mapping*/
  /* If none of the cause values in the table match the rej cause, then 
  the default value of SERVICE_TEMPORARILY_OUT_OF_ORDER will be taken for 
  end reason. This is mentioned in 3gpp 24.008, section-10.5.3.6 */
  qmi_voice_cm_if_cause_to_end_reason_table_s_type qmi_voice_cm_if_end_reason_conv_table[] =
  {
    {2,          QMI_VOICE_CM_IF_END_IMSI_UNKNOWN_IN_HLR},
    {3,          QMI_VOICE_CM_IF_END_ILLEGAL_MS},
    {4,          QMI_VOICE_CM_IF_END_IMSI_UNKNOWN_IN_VLR},
    {5,          QMI_VOICE_CM_IF_END_IMEI_NOT_ACCEPTED},
    {6,          QMI_VOICE_CM_IF_END_ILLEGAL_ME},
    {11,         QMI_VOICE_CM_IF_END_PLMN_NOT_ALLOWED},
    {12,         QMI_VOICE_CM_IF_END_LOCATION_AREA_NOT_ALLOWED},
    {13,         QMI_VOICE_CM_IF_END_ROAMING_NOT_ALLOWED_IN_THIS_LOC_AREA},
    {15,         QMI_VOICE_CM_IF_END_NO_SUITABLE_CELLS_IN_LOC_AREA},
    {17,         QMI_VOICE_CM_IF_END_NETWORK_FAILURE},
    {20,         QMI_VOICE_CM_IF_END_MAC_FAILURE},
    {21,         QMI_VOICE_CM_IF_END_SYNCH_FAILURE}, 
    {22,         QMI_VOICE_CM_IF_END_NETWORK_CONGESTION},
    {23,         QMI_VOICE_CM_IF_END_GSM_AUTHENTICATION_UNACCEPTABLE},
    {32,         QMI_VOICE_CM_IF_END_SERVICE_OPTION_NOT_SUPPORTED},
    {33,         QMI_VOICE_CM_IF_END_SERVICE_NOT_SUBSCRIBED},
    {34,         QMI_VOICE_CM_IF_END_SERVICE_TEMPORARILY_OUT_OF_ORDER},
    {38,         QMI_VOICE_CM_IF_END_CALL_CANNOT_BE_IDENTIFIED},
    {95,         QMI_VOICE_CM_IF_END_INCORRECT_SEMANTICS_IN_MESSAGE},
    {96,         QMI_VOICE_CM_IF_END_MANDATORY_INFORMATION_INVALID}
  };

  total_size_of_end_reason_table = sizeof(qmi_voice_cm_if_end_reason_conv_table)/sizeof(qmi_voice_cm_if_cause_to_end_reason_table_s_type);

  while(i < total_size_of_end_reason_table)
  {
    if(rej_cause_val == qmi_voice_cm_if_end_reason_conv_table[i].cause)
    {
      end_reason = qmi_voice_cm_if_end_reason_conv_table[i].reason;
      break;
    }
    i++;
  }

  return end_reason;
}/* qmi_voice_cm_if_map_ota_rej_cause_to_end_reason() */


/*===========================================================================
                    ERROR MAPPING FUNCTIONS
===========================================================================*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_MAP_CALL_ERROR_TO_QMI()

  DESCRIPTION
    Maps CM Call error codes to QMI error codes

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_voice_cm_if_map_call_error_to_qmi( cm_call_cmd_err_e_type cm_err )
{
  qmi_error_e_type result;

  switch(cm_err)
  {
    case CM_CALL_CMD_ERR_NOERR:
      result = QMI_ERR_NONE;
      break;
    case CM_CALL_CMD_ERR_NO_BUF_L:
      result = QMI_ERR_NO_MEMORY;
      break;
    case CM_CALL_CMD_ERR_CALL_ID_P:
      result = QMI_ERR_INVALID_ID;
      break;
    case CM_CALL_CMD_ERR_OFFLINE_S:
    case CM_CALL_CMD_ERR_LTE_ONLY_NO_IMS:
      result = QMI_ERR_NO_NETWORK_FOUND;
      break;
    case CM_CALL_CMD_ERR_IN_USE_S:
      result = QMI_ERR_DEVICE_IN_USE;
      break;
    case CM_CALL_CMD_ERR_OTHER:
      result = QMI_ERR_ABORTED;
      break;
    case CM_CALL_CMD_ERR_CALL_ORIG_FAIL_S:
      result = QMI_ERR_CALL_FAILED;
      break;
   case CM_CALL_CMD_ERR_NULL_NUM_P:
    case CM_CALL_CMD_ERR_NUM_LEN_P:
      result = QMI_ERR_REQUESTED_NUM_UNSUPPORTED;
      break;
    case CM_CALL_CMD_ERR_NO_COLLOC_HDR:
    case CM_CALL_CMD_ERR_NO_SO_S:
      result = QMI_ERR_OP_NETWORK_UNSUPPORTED;
      break;
    case CM_CALL_CMD_ERR_NULL_PARAM_P:
    case CM_CALL_CMD_ERR_NULL_ALPHA_P:
    case CM_CALL_CMD_ERR_NO_CALL_ID_S:
      result = QMI_ERR_MISSING_ARG;
      break;
    case CM_CALL_CMD_ERR_INVALID_BC_P:
    case CM_CALL_CMD_ERR_SRV_TYPE_P:
    case CM_CALL_CMD_ERR_SRV_TYPE_S:
    case CM_CALL_CMD_ERR_CALL_TYPE_P:
    case CM_CALL_CMD_ERR_MISMATCH_P:
      result = QMI_ERR_INVALID_ARG;
      break;
    case CM_CALL_CMD_ERR_MODE_PREF_P:
    case CM_CALL_CMD_ERR_INVALID_SIM_STATE_S:
    case CM_CALL_CMD_ERR_UIM_NOT_PRESENT_S:
    case CM_CALL_CMD_ERR_NO_FUNDS_S:
    case CM_CALL_CMD_ERR_REJECT_DURING_INCOMING_CALL:
    case CM_CALL_CMD_ERR_FAVORED_MODE_PREF_FOR_ORIGINATION:
    case CM_CALL_CMD_ERR_ORIG_RES_S:
    case CM_CALL_CMD_ERR_SRV_STATE_S:
    case CM_CALL_CMD_ERR_INVALID_MODE_S:
    case CM_CALL_CMD_ERR_DRVCC_IN_PROG:
      result = QMI_ERR_INCOMPATIBLE_STATE;
      break;
    case CM_CALL_CMD_ERR_EMERGENCY_CALL_ACTIVE:
      result = QMI_ERR_INVALID_OPERATION;
      break;
    case CM_CALL_CMD_ERR_FUNCTION_UNAVAILABLE_DUE_TO_UNDEFINED_FEATURE:
      result = QMI_ERR_OP_DEVICE_UNSUPPORTED;
      break;
    case CM_CALL_CMD_ERR_OP_NOT_SUPPORTED_ON_SUBS:
      result = QMI_ERR_NO_SUBSCRIPTION;
      break;
    default:
      result = QMI_ERR_INTERNAL;
      break;
  }
  QM_MSG_MED_2("cmd_err = %d mapped to qmi_err %d", cm_err, result);
  return result;
}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_IS_JCDMA_BUILD()

  DESCRIPTION
    Checks whether it is a JCDMA build or not 

  PARAMETERS
    None

  RETURN VALUE
    TRUE/FALSE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_voice_cm_if_is_jcdma_build
( 
  void
)
{

 #ifndef FEATURE_T53
   return FALSE;
 #else
   return TRUE;
 #endif /*!FEATURE_T53*/
 
}/*qmi_voice_cm_if_is_jcdma_build*/

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_MAP_INBAND_ERROR_TO_QMI()

  DESCRIPTION
    Maps CM inband error codes to QMI error codes

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_voice_cm_if_map_inband_error_to_qmi( cm_inband_cmd_err_e_type cm_err )
{
  qmi_error_e_type result;

  switch(cm_err)
  {
    case CM_INBAND_CMD_ERR_NOERR: /**< No errors found */
      result = QMI_ERR_NONE;
      break;

    case CM_INBAND_CMD_ERR_CLIENT_ID_P: /**< invalid client ID */
    case CM_INBAND_CMD_ERR_ON_LEN_P: /**< invalid DTMF pulse width */
    case CM_INBAND_CMD_ERR_OFF_LEN_P: /**< invalid DTMF inter-digit interval */
    case CM_INBAND_CMD_ERR_NULL_BUF_P: /**< null digit buffer */
    case CM_INBAND_CMD_ERR_DIGIT_P: /**< invalid digits */
      result = QMI_ERR_MALFORMED_MSG; /* Message was not formulated correctly by the control point, or message was corrupted during transmission */
      break;

    case CM_INBAND_CMD_ERR_NO_BUF_L: /**< No available CM command buffers to queue the command */
      result = QMI_ERR_NO_MEMORY; /* Device could not allocate memory to formulate response */
      break;

    case CM_INBAND_CMD_ERR_CALL_ID_P: /**< invalid call ID */
      result = QMI_ERR_INVALID_ID; /* Invalid Call ID sent in the cmd */
      break;

    case CM_INBAND_CMD_ERR_CNT_P: /**< the value of cnt exceeds the maximum allowed value */
      result = QMI_ERR_ARG_TOO_LONG; /* Argument is too long */
      break;

    case CM_INBAND_CMD_ERR_BAD_STATE_S: /**< invalid state for inband cmd */
    case CM_INBAND_CMD_ERR_OFFLINE_S: /**< Phone is offline */
    case CM_INBAND_CMD_ERR_OTHER: /**< A problem other than the above was found */
    case CM_INBAND_CMD_ERR_FUNCTION_UNAVAILABLE_DUE_TO_UNDEFINED_FEATURE: /**< The function is unavailable due to relavent feature being undefined */
    default:
      result = QMI_ERR_INTERNAL; /* An unexpected error occurred during processing */
      break;
  }
  return result;
}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_MAP_SUPS_ERROR_TO_QMI()

  DESCRIPTION
    Maps CM Sups error codes to QMI error codes

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_voice_cm_if_map_sups_error_to_qmi( cm_sups_cmd_err_e_type cm_err )
{
  qmi_error_e_type result;

  //QM_MSG_MED_1("Inside qmi_voice_cm_if_map_sups_error_to_qmi for cm_err=%d", cm_err);

  switch(cm_err)
  {
    case CM_SUPS_CMD_ERR_NOERR:
      result = QMI_ERR_NONE;
      break;
    case CM_SUPS_CMD_ERR_NO_BUF_L:
      result = QMI_ERR_NO_MEMORY;
      break;
    case CM_SUPS_CMD_ERR_OFFLINE_S:
      result = QMI_ERR_DEVICE_NOT_READY;
      break;
    case CM_SUPS_CMD_ERR_SRV_STATE_S:
      result = QMI_ERR_NO_NETWORK_FOUND;
      break;
    case CM_SUPS_CMD_ERR_CLIENT_ID_P:
    case CM_SUPS_CMD_ERR_NULL_PARAM_P:
      result = QMI_ERR_MALFORMED_MSG;
      break;
    case CM_SUPS_CMD_ERR_USSD_REJECTED:
      result = QMI_ERR_DEVICE_IN_USE;
      break;
    default:
      result = QMI_ERR_INTERNAL;
      break;
  }
  return result;
}


/*===========================================================================
  FUNCTION qmi_voice_cm_if_map_sups_event_error_to_qmi()

  DESCRIPTION
    Maps CM Sups event error codes to QMI error codes

  PARAMETERS
    None

  RETURN VALUE
    qmi error code

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_voice_cm_if_failure_cause_e_type qmi_voice_cm_if_map_sups_event_error_to_qmi
(
  ie_cm_ss_error_s_type ss_error,
  ie_cm_cc_cause_s_type cc_cause
)
{
  qmi_voice_cm_if_failure_cause_e_type ret_err=QMI_FAILURE_CAUSE_REL_NORMAL;
  
  //QM_MSG_MED("Inside qmi_voice_cm_if_map_sups_event_error_to_qmi():");
  
  if(ss_error.present == TRUE)
  {
    switch(ss_error.error_code_tag)
    {
      case QMI_SS_ERROR_ERROR_CODE_TAG:
        ret_err = qmi_voice_cm_sups_map_ss_errors_to_failure_cause(ss_error.error_code);
        break;
      case QMI_SS_ERROR_IMS_CODE_TAG:
        if(ss_error.error_code == QMI_CM_IF_SS_ERROR_CAUSE_403_FORBIDDEN)
        {
          ret_err = QMI_FAILURE_CAUSE_SIP_403_FORBIDDEN;
        }
        else if ( ss_error.error_code == QMI_CM_IF_SS_ERROR_CAUSE_404_NOT_FOUND )
        {
          ret_err = QMI_FAILURE_CAUSE_INVALID_REMOTE_URI;
        }
        break;
      case QMI_SS_ERROR_GENERAL_PROBLEM:
        switch( ss_error.error_code )
        {
          case QMI_CM_IF_SS_ERROR_UNRECOGNISED_COMPONENT:
          case QMI_CM_IF_SS_ERROR_BADLY_STRUCTURED_COMPONENT:
          case QMI_CM_IF_SS_ERROR_MISTYPED_COMPONENT:
            ret_err = QMI_FAILURE_CAUSE_RESOURCES_NOT_AVAILABLE;
            break;
          default:
            break;
        } /* switch general problem code */
        break;
      case QMI_SS_ERROR_INVOKE_PROBLEM:
        switch(ss_error.error_code )
        {
          case QMI_CM_IF_SS_ERROR_DUPLICATE_INVOKE_ID:
          case QMI_CM_IF_SS_ERROR_UNRECOGNISED_OPERATION:
          case QMI_CM_IF_SS_ERROR_INITIATING_RELEASE:
          case QMI_CM_IF_SS_ERROR_UNRECOGNISED_LINKED_ID:
          case QMI_CM_IF_SS_ERROR_LINKED_RESPONSE_UNEXPECTED:
          case QMI_CM_IF_SS_ERROR_UNEXPECTED_LINKED_OPERATION:
            ret_err = QMI_FAILURE_CAUSE_REJECTED_BY_NETWORK;
            break;
          case QMI_CM_IF_SS_ERROR_MISTYPED_PARAMETER:
          case QMI_CM_IF_SS_ERROR_RESOURCE_LIMITATION:
            ret_err = QMI_FAILURE_CAUSE_RESOURCES_NOT_AVAILABLE;
            break;
          default:
            break;
        } /* switch invoke problem code */
        break;

      case QMI_SS_ERROR_RETURN_RESULT_PROBLEM:
        switch( ss_error.error_code )
        {
          case QMI_CM_IF_SS_ERROR_UNRECOGNISED_INVOKE_ID:
          case QMI_CM_IF_SS_ERROR_RETURN_RESULT_UNEXPECTED:
            ret_err = QMI_FAILURE_CAUSE_REJECTED_BY_NETWORK;
            break;

          case QMI_CM_IF_SS_ERROR_MISTYPED_PARAMETER:
            ret_err = QMI_FAILURE_CAUSE_RESOURCES_NOT_AVAILABLE;
            break;

          default:
            break;
        } /* switch return result problem code  */
        break;

      case QMI_SS_ERROR_RETURN_ERROR_PROBLEM:
        switch(ss_error.error_code )
        {
          case QMI_CM_IF_SS_ERROR_UNRECOGNISED_INVOKE_ID:
          case QMI_CM_IF_SS_ERROR_RETURN_ERROR_UNEXPECTED:
          case QMI_CM_IF_SS_ERROR_UNRECOGNISED_ERROR:
          case QMI_CM_IF_SS_ERROR_UNEXPECTED_ERROR:
            ret_err = QMI_FAILURE_CAUSE_REJECTED_BY_NETWORK;
            break;
          case QMI_CM_IF_SS_ERROR_RE_MISTYPED_PARAMETER:
            ret_err = QMI_FAILURE_CAUSE_RESOURCES_NOT_AVAILABLE;
            break;
          default:
            break;
        } /* switch return result problem error code  */
        break;

      case QMI_SS_ERROR_MN_SS_ERROR_TAG:
        switch( ss_error.error_code )
        {
          case QMI_CM_IF_SS_ERROR_MN_NETWORK_NOT_RESPONDING:
            /* Timeout error Need to handle in case by case basis in future refer DSAT function etsicmif_report_sups_error*/
            ret_err = QMI_FAILURE_CAUSE_REJECTED_BY_NETWORK;
            break;
          case QMI_CM_IF_SS_ERROR_MN_INSUFFICIENT_RESOURCES:
            ret_err = QMI_FAILURE_CAUSE_RESOURCES_NOT_AVAILABLE;
            break;
          case QMI_CM_IF_SS_ERROR_MN_CALL_HOLD_REJ:
          case QMI_CM_IF_SS_ERROR_MN_CALL_RETRIEVE_REJ:
          case QMI_CM_IF_SS_ERROR_MN_SPLIT_MPTY_REJ:
            ret_err = QMI_FAILURE_CAUSE_REJECTED_BY_NETWORK;
            break;
        }
        break;
    }
  }
  else if(cc_cause.present == TRUE)
  {
    ret_err = qmi_voice_cm_sups_map_cc_cause_to_failure_cause(cc_cause.cause_value);
  }
  else
  {
    QM_MSG_HIGH_3( "%s %d %d", " Recieved Invalid Sups Event Error ",ss_error.error_code,cc_cause.cause_value);
    return QMI_FAILURE_CAUSE_UNKNOWN;
  }
  QM_MSG_HIGH_3("Sups Event with ss_error: error_code = %d, error_tag = %d mapped to QMI error = %d",
                ss_error.error_code, ss_error.error_code_tag, ret_err);
  return ret_err;
}

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_MAP_PH_ERROR_TO_QMI()

  DESCRIPTION
    Maps CM ph error codes to QMI error codes

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_e_type qmi_voice_cm_if_map_ph_error_to_qmi( cm_ph_cmd_err_e_type cm_err )
{
  qmi_error_e_type result;

  switch(cm_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      result = QMI_ERR_NONE;
      break;
    case CM_PH_CMD_ERR_IN_USE_S:
      result = QMI_ERR_DEVICE_IN_USE;
      break;
    case CM_PH_CMD_ERR_ONLINE_S:
    case CM_PH_CMD_ERR_OPRT_MODE_S:
      result = QMI_ERR_DEVICE_NOT_READY;
      break;
    case CM_PH_CMD_ERR_NO_BUF_L:
      result = QMI_ERR_NO_MEMORY;
      break;
    case CM_PH_CMD_ERR_ALS_SIM_WRITE_FAILED_S:
    case CM_PH_CMD_ERR_AOC_NOT_READY_S:
      result = QMI_ERR_NO_EFFECT;
      break;
    case CM_PH_CMD_ERR_SELECTED_LINE_P:
    case CM_PH_CMD_ERR_LINE_SWITCHING_P:
      result = QMI_ERR_INVALID_ARG;
      break;
    case CM_PH_CMD_ERR_LINE_SWITCHING_S:
    case CM_PH_CMD_ERR_ALS_NOT_SUPPORTED_S:
    case CM_PH_CMD_ERR_FUNCTION_UNAVAILABLE_DUE_TO_UNDEFINED_FEATURE:
      result = QMI_ERR_NOT_SUPPORTED; /* TBD */
      break;
    default:
      result = QMI_ERR_INTERNAL;
      break;
  }
  return result;
}/*qmi_voice_cm_if_map_ph_error_to_qmi*/


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_pref_voice_service_option_is_valid

===========================================================================*/
/*!
    @brief
    Checks if the passed preferred voice service option is valid or not

    @return
    retuns TRUE if class is valid else returns FALSE
*/
/*=========================================================================*/
boolean qmi_voice_cm_if_pref_voice_service_option_is_valid(uint16 srv_opt)
{
  boolean is_valid = FALSE;

  //QM_MSG_MED("Inside qmi_voice_cm_if_pref_voice_service_option_is_valid():");

  
  switch(srv_opt)
  {
    case QMI_VOICE_CM_IF_PREF_VOICE_SERVICE_OPT_WILD:
    case QMI_VOICE_CM_IF_PREF_VOICE_SERVICE_OPT_IS96A:
    case QMI_VOICE_CM_IF_PREF_VOICE_SERVICE_OPT_EVRC:
    case QMI_VOICE_CM_IF_PREF_VOICE_SERVICE_OPT_13KIS733:
    case QMI_VOICE_CM_IF_PREF_VOICE_SERVICE_OPT_SEL_MODE_VOCODER:
    case QMI_VOICE_CM_IF_PREF_VOICE_SERVICE_OPT_4GV_NARROW_BAND:
    case QMI_VOICE_CM_IF_PREF_VOICE_SERVICE_OPT_4GV_WIDE_BAND:
    case QMI_VOICE_CM_IF_PREF_VOICE_SERVICE_OPT_13k:
    case QMI_VOICE_CM_IF_PREF_VOICE_SERVICE_OPT_IS96:
    case QMI_VOICE_CM_IF_PREF_VOICE_SERVICE_OPT_WVRC:
      is_valid = TRUE;
      break;
    default:
      break;
  }
  return is_valid;
} /* qmi_voice_cm_if_pref_voice_service_option_is_valid() */


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_is_dial_call_type_valid

===========================================================================*/
/*!
    @brief
    Checks if the call type in DIAL Request is valid

    @return
    retuns TRUE if call type is valid, FALSE otherwise.
*/
/*=========================================================================*/

boolean qmi_voice_cm_if_is_dial_call_type_valid
(
  qmi_voice_cm_if_call_type_e_type call_type
)
{
  boolean is_valid = FALSE;
  
  switch(call_type)
  {
    case QMI_VOICE_CM_IF_CALL_TYPE_VOICE:
    case QMI_VOICE_CM_IF_CALL_TYPE_VOICE_FORCED:
    case QMI_VOICE_CM_IF_CALL_TYPE_STD_OTASP:
    case QMI_VOICE_CM_IF_CALL_TYPE_NON_STD_OTASP:
    case QMI_VOICE_CM_IF_CALL_TYPE_EMERGENCY:
    case QMI_VOICE_CM_IF_CALL_TYPE_VOIP:
    case QMI_VOICE_CM_IF_CALL_TYPE_VT:
    case QMI_VOICE_CM_IF_CALL_TYPE_VIDEOSHARE:
    case QMI_VOICE_CM_IF_CALL_TYPE_ECALL:
    case QMI_VOICE_CM_IF_CALL_TYPE_EMERGENCY_VT:
      is_valid =  TRUE;
      break;
    default:
      break;
  }
  return is_valid;
} /* qmi_voice_cm_if_is_dial_call_type_valid */


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_validate_dial_call_params

===========================================================================*/
/*!
    @brief
    Checks if the input data in DIAL Request is valid

    @return
    retuns QMI_ERR_NONE if data is valid, granular error otherwise.
*/
/*=========================================================================*/
qmi_error_e_type qmi_voice_cm_if_validate_dial_call_params
(
  voice_dial_call_req_msg_v02 *in_data_ptr
)
{
  qmi_error_e_type err = QMI_ERR_NONE;
  uint8 calling_number_len, sip_uri_overflow_len;
  uint16 vs_file_attributes_len;

  ASSERT( in_data_ptr != NULL );

  if(in_data_ptr->call_type_valid)
  {
    /* Call type Validation */
	QM_MSG_MED_2("call type %d for DIAL and eCall Variant %d (if call type= ECALL)", in_data_ptr->call_type,in_data_ptr->ecall_variant);
    if( !qmi_voice_cm_if_is_dial_call_type_valid((qmi_voice_cm_if_call_type_e_type)in_data_ptr->call_type))
    {
      //Unsupported call type  for DIAL
      err = QMI_ERR_INVALID_ARG;
    }
    else
    {
      /* Now that call_type is valid, check ofr other params  */
      switch (in_data_ptr->call_type)
      {
        case QMI_VOICE_CM_IF_CALL_TYPE_ECALL:
          if(in_data_ptr->ecall_variant_valid)
          {
            if( (in_data_ptr->ecall_variant == QMI_VOICE_CM_IF_ECALL_TYPE_NONE) || 
                (in_data_ptr->ecall_variant >= QMI_VOICE_CM_IF_ECALL_TYPE_MAX) )
            {
              //Invalid eCall Variant: in_data_ptr->ecall_variant
              err = QMI_ERR_INVALID_ARG;
            }
          }
          break;
        default:
          break;
      }
    }
  }

  if(err == QMI_ERR_NONE)
  {
    calling_number_len = strlen(in_data_ptr->calling_number);
    sip_uri_overflow_len = strlen(in_data_ptr->sip_uri_overflow);
    vs_file_attributes_len = strlen(in_data_ptr->videoshare_call_attribs.file_attributes);
    /* Called number validation if call type is not VOIP*/
    if ((!QMI_VOICE_CM_IF_VOIP_CALL(in_data_ptr->call_type)) &&
        (((calling_number_len == QMI_VOICE_NUMBER_MAX_V02) && (in_data_ptr->calling_number[0] != '+')) ||
        (calling_number_len > QMI_VOICE_NUMBER_MAX_V02) ||
        (sip_uri_overflow_len > QMI_VOICE_SIP_URI_OVERFLOW_MAX_V02) ||
        (vs_file_attributes_len > QMI_VOICE_VS_FILE_ATTRIBUTES_MAX_V02) ) 
       )   
    {
      QM_MSG_ERROR_3("Invalid len num %d, uri-overflow %d, file attr %d", calling_number_len, sip_uri_overflow_len, vs_file_attributes_len);
      err = QMI_ERR_ARG_TOO_LONG;
    }
  }

  return err;
}/* qmi_voice_cm_if_validate_dial_call_params */

/*===========================================================================
  FUNCTION QMI_VOICE_CM_IF_MAP_QMI_TO_ECALL_TYPE()

  DESCRIPTION
    Map the QMI type to eCall call type

  PARAMETERS
    qmi_type:  qmi_voice_cm_if_eCall_type_e_type

  RETURN VALUE
    eCall_type:  ecall_type_of_call

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
ecall_type_of_call qmi_voice_cm_if_map_qmi_to_eCall_type
(
   qmi_voice_cm_if_eCall_type_e_type qmi_type
)
{
  ecall_type_of_call eCall_type = ECALL_TEST;
  switch(qmi_type)
  {
    case QMI_VOICE_CM_IF_ECALL_TYPE_TEST:
      eCall_type = ECALL_TEST;
      break;
    case QMI_VOICE_CM_IF_ECALL_TYPE_EMERGENCY:
      eCall_type = ECALL_EMERGENCY;
      break;
    case QMI_VOICE_CM_IF_ECALL_TYPE_RECONFIG:
      eCall_type = ECALL_RECONFIG;
      break;
    default:
      break;
  }
  return eCall_type;
}/* qmi_voice_cm_if_map_qmi_to_eCall_type */


/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_ip_gen_param_destructor

===========================================================================*/
/*!
    @brief
    To free memory once the reference is released.

    @return
    
*/
/*=========================================================================*/
static void qmi_voice_cm_if_ip_gen_param_destructor(
  void *me
  )
{
  _ref_cnt_info_t *ip_param_ptr = (_ref_cnt_info_t *) me;
  QM_MSG_MED("Inside qmi_voice_cm_if_ip_gen_param_destructor ");
    
  QMI_VOICE_CM_IF_MEM_FREE(ip_param_ptr);
  ip_param_ptr = NULL;  
};

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_get_call_fail_cause

===========================================================================*/
/*!
    @brief
    To return the call fail cause from global variable

    @return
    
*/
/*=========================================================================*/
uint16 qmi_voice_cm_if_get_call_fail_cause(void)
{
  return (uint16)cm_if_info.call_fail_cause;
}


#define CC_CAUSE_NON_SELECTED_USER_CLEARING                   (26)
#define CC_CAUSE_NORMAL_UNSPECIFIED                           (31)

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_get_call_fail_cause

===========================================================================*/
/*!
    @brief
    To return the raw call fail cause from global variable

    @return
    
*/
/*=========================================================================*/
boolean qmi_voice_cm_if_get_raw_call_end_cause_code(uint8* raw_cause_code)
{
  if( raw_cause_code && (cm_if_info.raw_call_fail_cause == CC_CAUSE_NON_SELECTED_USER_CLEARING ||
      cm_if_info.raw_call_fail_cause == CC_CAUSE_NORMAL_UNSPECIFIED ) )
  {
     *raw_cause_code = cm_if_info.raw_call_fail_cause;
     return TRUE;
  }
  return FALSE;
}

/*=========================================================================
  FUNCTION:  qmi_voice_cm_if_barr_list_ptr_destructor

===========================================================================*/
/*!
    @brief
    To free memory once the reference is released.

    @return
    
*/
/*=========================================================================*/
static void qmi_voice_cm_if_barr_list_ptr_destructor(
  void *me
  )
{
  cm_call_barring_list_s_type *barr_list_ptr = (cm_call_barring_list_s_type *) me;
  //Inside qmi_voice_cm_if_barr_list_ptr_destructor
  QMI_VOICE_CM_IF_MEM_FREE(barr_list_ptr);
  barr_list_ptr = NULL;  
};

#endif/*!FEATURE_NO_QMI_VOICE*/

#endif // FEATURE_QMI_SERVICE_SPLIT

#ifdef FEATURE_MODEM_CONFIG_REFRESH
//called in case of MCFG refresh event (sim swap)
void qmi_voice_cm_if_mcfg_refresh_otasp( void )
{
  qmi_voice_cm_if_read_otasp();
}
#endif // FEATURE_MODEM_CONFIG_REFRESH
