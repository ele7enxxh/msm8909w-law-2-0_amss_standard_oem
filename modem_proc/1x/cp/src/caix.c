/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

              C D M A   T R A N S L A T I O N    S E R V I C E S

GENERAL DESCRIPTION
  This module contains the services which translate a CDMA message between
  the internal format used by the Main Control task and the external format
  used by the Transmit and Receive tasks.

EXTERNALIZED FUNCTIONS
  caix_int_to_ext
    Translates a message from internal to external format.

  caix_ext_to_int
    Translates a message from external to internal format.

INITIALIZATION AND SEQUENCING REQUIREMENTS
  None

  Copyright (c) 1991 - 2016 Qualcomm Technologies, Inc.
  All Rights Reserved Qualcomm Proprietary

  Export of this technology or software is regulated by the U.S. Government.
  Diversion contrary to U.S. law prohibited.

  All ideas, data and information contained in or disclosed by
  this document are confidential and proprietary information of
  Qualcomm Technologies, Inc. and all rights therein are expressly reserved.
  By accepting this material the recipient agrees that this material
  and the information contained therein are held in confidence and in
  trust and will not be used, copied, reproduced in whole or in part,
  nor its contents revealed in any manner to others without the express
  written permission of Qualcomm Technologies, Inc.

*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/

/*===========================================================================

                        EDIT HISTORY FOR MODULE

This section contains comments describing changes made to the module.
Notice that changes are listed in reverse chronological order.

$PVCSPath: L:/src/asw/MSM5100/CP_REL_A/vcs/caix.c_v   1.121   02 Oct 2002 22:52:22   louiel  $
$Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/1x/cp/src/caix.c#1 $ $DateTime: 2016/12/13 08:00:08 $ $Author: mplcsds1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
05/26/16   ppr     Logging changes
01/13/15   ppr     Feature clean up changes
12/01/14   agh     Added defensive checks to handle invalid GEM gracefully
05/07/14   agh     Reject UHDM/MEID_UHDM if num_pilots if equal to Zero
05/06/14   gga     1X_CP F3 redistribution
04/10/14   agh     Fix to parse GEM only if 1X-Advanced is enabled
03/18/14   agh     FR 16951: Avoiding BSR from C2K->LTE when UE supports 
                   C2K-LTE Cell Reselection
03/04/14   pap     Changes to resolve warnings by LLVM compiler.
02/28/14   agh     Added defensive checks in xlate_ext_chn_asn api for invalid
                   value of add_record_len field
02/05/14   gga     Fix to make sure that MS sends the correct reject order 
                   if unsupported record type is rxed in the GEM.
11/22/13   ppr     CSFB:1x CGI Reporting feature changes
10/24/13   pap     Removing all warnings for LLVM compiler.
10/09/13   pap     Removing warnings for LLVM.
08/20/13   dkb     Mainline FEATURE_PASSPORT_MODE
03/07/13   abd     Fix MSVC compilor errors
02/27/13   nee     Added defensive checks
01/28/13   gga     Klocwork Reviews Phase 2
12/28/12   gga     Klocwork Reviews
11/19/12   ssh     Added SMS over CSFB support.
10/19/12   ppr     Added defensive checks
09/25/12   ppr     Added defencive checks for NULL ptr access
09/24/12   ppr     Added defencive checks for NULL ptr access
09/15/12   ppr     FR#2370 - 1x memory optimization changes
06/29/12   ppr     FEATURE_IS2000_REL_A_CC cleanup changes
06/22/12   cjb     Ignore OTA MSG length check for RUMI.
06/21/12   ssh     NV based disabling of 1X to LTE reselections.
06/15/12   ppr     Feature Cleanup
05/24/12   ppr     Feature Cleanup
05/09/12   ppr     Feature Cleanup
04/10/12   ssh     Added support for PLMNSameAsPreviousChannel = 1.
02/21/12   ppr     Feature Cleanup
02/16/12   srk     Replaced FEATURE_LTE_TO_1X by FEATURE_MODEM_1X_IRAT_LTO1X.
02/04/12   ppr     Feature Cleanup
01/19/12   ppr     Reverting feature cleanup changes for
                   FEATURE_IS2000_REL_A_BSID
01/17/12   ppr     Feature Cleanup: Mainlined Always ON features
01/13/12   ppr     1X CP - Feature clean up: Mainline Always On features,
                   Remove Always Off Features
01/06/12   ppr     1X CP - Feature clean up: Mainline Always On features,
                   Remove Always Off Features
11/08/11   ssh     Fixed SPM parsing error.
10/11/11   ssh     Corrected the ATIM parsing logic.
09/14/11   ssh     Cleared the atim_ind field in SPM before parsing it.
08/29/11   cjb     Renamed FEATURE_MODEM_1X_IRAT_1XTOL to FEATURE_1X_TO_LTE.
08/26/11   ssh     1X to LTE reselection support - part 2.
07/15/11   ssh     Added ATIM support to perform the 1X to LTE reselection.
06/14/11   ssh     Added ATIM support to perform the 1X to LTE reselection.
05/04/11   ag      Removed featurization while packing rev_fch_rc_map because
                   this value is always stored in a word internally.
04/29/11   ag      CSFB: Added chanes to support SSD operation, Unique Challenge
                   in CSFB mode.
04/29/11   ag      Support for SPM field rc_bitmap_capability_ext_allowed.
04/19/11   jj      CSFB: Code merge from rel/1H11 branch.
04/13/11   ag      Added null pointer checks in xlate_ext_tc_msg().
03/09/11   jj      CSFB: Added changes to support Xlating of ECAM AM=5 received
                   in tunnel mode.
02/16/11   ag      Fixed an issue in parsing of GEM.
02/16/11   ssh     Mainlining JCDMA specific requirements.
02/07/11   ag      Renamed power_control_mode_01_supported to
                   rpc_mode_01_supported.
02/07/11   ag      Support for fpc_mode field in RCPM and RCP record of GEM.
01/31/11   ag      Added support for GEM extending MEID-ECAM.
01/04/11   ag      Fixed compiler and lint warnings.
12/17/10   jj      CSFB: Wrapped CSFB related change inside CSFB feature check.
12/14/10   ssh     CSFB: Added MT support contd. (GPM processing and
                   sending PRM support.)
12/13/10   jj      Indentation update.
12/03/10   jj      CSFB:Added support for Rel8 and Rel9 CSFB.
11/24/10   ag      Renamed pwr_cntl_step_zero_rate to pwr_cntl_step.
11/18/10   ag      Added support for optional SO73 COP0.
11/15/10   jtm     Initial SU API split for CP.
10/13/10   ag      Included header file modem_1x_defs.h.
09/28/10   ssh     Added overhead parameters range checks.
09/28/10   azh     Fixed compiler warnings.
05/04/10   ssh     Fixed KW warning.
11/02/09   ssh     Fixed compiler warnings.
11/02/09   jtm     Fixed compiler warnings.
09/29/09   ag      1X Advanced Signaling Support - Phase 2
08/02/09   jtm     Lint fixes.
07/14/09   jj      CMI change- make the definitions to the maximum value,
                   thus making both cai_v.h and cai.h have a uniform value.
06/24/09   pk      Added new information record MEID_ME parser and modified
                   existing ESN_ME to be supported for FEATURE_HWID_SUPPORT
06/01/09   pk      1x Advanced Feature Changes
05/14/09   ag      CMI phase2 changes
03/09/09   jj      Fixed discrepancy in array reference mismatch.
12/14/07   an      Added Passport Mode
05/11/07   pg      More Lint Cleanup.
03/19/07   pg      Lint Cleanup.
03/08/07   an      Fixed Critical Lint Errors
01/30/07   sb      Changed function prototype of caix_get_message_type.
01/15/07   sb      VOIP-1X handoff updates.
11/21/06   sb      Added support for VOIP-1X handoffs.
09/29/06   fh      AKA/AES: removed the AES testing code, and eliminated the
                            AES testing featurization of
                            FEATURE_IS2000_REL_A_AES_BS_SUPPORTS
09/29/06   fh      Added a new parameter to caix_int_to_ext to indicate whether
                   the function call is for calculating access channel message
                   size or for parsing before transmitting the message.
09/14/06   fh      Moved AES field setting from caix.c back into mccsa.c and rxtx.c
09/13/06   fh      Moved integrity field setting back into mccsa.c and rxtx.c
09/02/06   fh      AKA/AES: Miscellaneous code review changes
08/31/06   fc      Fixed TMSI address discrepanies for parser testing.
08/31/06   an      Rel D Addendum Sync Id Feature
08/29/06   fh      AKA/AES: removed mccap_ms_supports_aes condition check for
                            parser.
08/29/06   fh      AKA/AES: cleaned up the usage of AES capability functions
08/16/06   pg      Added support for release D Packet Zone Hysteresis.
08/07/06   fc      Fixed discrepanies for parser testing.
08/01/06   fc      Removed the p_rev_in_use check for maci paring on common
                   channel messages.
07/25/06   fc      Fixed discrepanies for parser testing.
07/25/06   fh      AKA/AES: put part of lab testing that is dependent on BS AES
                            support under a temporary feature of
                            FEATURE_IS2000_REL_A_AES_BS_SUPPORTS
07/07/06   fh      AKA/AES: Cleaned up AES capability helper functions.
06/13/06   fh      AES change: removed TREX_DORA, not necessary, just for debugging
06/12/06   fc      Changes for UMTS.
06/12/06   fh      fixed lint error during the merge when UMTS feature is turned on
06/07/06   fh      Added Voice Service AES encryption/decryption under the features
06/01/06   fc      Cleanup umts interface.
05/24/06   fh      AKA/AES: misclaneous fixes within AKA/AES features
05/17/06   fh      Merged in new development of AKA/AES features
05/12/06   fh      Changes under AES feature: the parser function caix_int_to_ext
                   carries an extra argument to indicate whether to just
                   get the buffer length for access channel messages, or parsing
                   and AES encrypting the whole message.
04/26/06   an      Fixed Lint Errors
04/27/06   fc      Fixed Rel C featurization.
04/24/06   fc      Fixed Rel A featurization.
02/24/06   fh      Fixed the parsing error for Retry Order in traffic channel
02/21/06   fc      Fixed parser issue on r-tch SRPM and UZURM.
02/16/06   fc      Fixed parser discrepancies.
01/20/06   fc      Merged the following :
           fh      Added support for AKA and MI.
10/19/05   sb      Added support for Band Class 14, Band Subclass I, J, K.
10/17/05   sb      Added reserved bits to MC Extended Display rec.
09/22/05   an      Fixed Lint Errors
09/21/05   an      Added support for published Release D Addendum new Info Recs
09/19/05   pg      Added support for published Release D Addendum f-dsch and
                   r-dsch message changes.
09/15/05   fc      Added support for published Release D Addendum f-csh
                   message changes.
08/29/05   fc      Changed FEATURE_MSG_PACK_UNIT_TEST_1 to
                   FEATURE_MSG_PACK_UNIT_TEST.
08/08/05   pg      Fixed merge error.
08/04/05   pg      Added support for Rel D Addendum f-dsch and r-dsch messages.
08/01/05   an      Added support for Rel D Addendum r-csh messages, IRs and
                   Orders.
07/25/05   fc      Added support for Rel D Addendum f-csh messages.
07/15/05   fc      Fixed lint errors.
07/12/05   ht      Added MEID Addressing support
07/08/05   sb      Merged the following from MSMSHARED:
07/05/05   sb       Added MEID support.
05/20/05   fc      Merged the following from MSMSHARED:
05/20/05   an       Added band subclass info record
05/16/05   fc      Merged the following from MSMSHARED:
05/11/05   an       Added CAI_NTL_SUP_SVC_REC to xlate_ext_tc_eawim.
05/03/05   fc      Fixed structure reference error in xlate_int_ac_rem.
03/23/05   fc      Merged the following from MSMSHARED:
03/22/05   an       Mainlined FEATURE_ENHANCED_BAND_CLASS. Eliminated
                    FEATURE_CDMA_800 and FEATURE_CDMA_1900
03/21/05   an       Mainlined IS2000 features and implemented the new
                    Dynamic Feature Design.
02/18/05   fc      Merged the following from MSMSHARED:
02/09/05   ph       When parsing PPM order from BS for >=PREV7, don't validate ORDQ range.
02/08/05   an       Mainlined IS95B features
09/28/04   fc       Fixed a merge error.
01/11/05   sb      Expanded arrays in NN-SCR so they correspond to bitmaps.
10/01/04   sb      More lint fixes.
09/30/04   sb      Fixed lint warning.
09/27/04   va      Merged following from REL B/C archive
07/21/04   sj        Added support for umts to 1x handover.
09/22/04   az      ECAM parser changes
09/16/04   sb      Added Rel C Addendum fields to BS Status Reponse Msg.
09/02/04   az      Added (add_record_len >= 2) check for retry order in
                   xlate_ext_tc_ord()
08/19/04   az      ECAM parser changes - AM5
08/18/04   fc      Removed silk incl flags on overhead messages.
08/13/04   fc      Resolved silk discrepancies on overhead messages.
08/13/04   az      Some more ECAM parser changes. Fixed Lint errors.
08/12/04   pg      Fixed a bug in Enhanced Multi-character Extended Record.
08/12/04   bkm     Added initialization of T79 in cai_tmo structure.
08/06/04   az      Few ECAM AM5 fixes.
08/04/04   sb      Fixed misc. lint errors.
08/03/04   ht      Added Rel D MEID LAC support
08/02/04   bkm     Corrected a compile error.
08/02/04   pg      Corrected some indentation issues.
07/28/04   pg      Added Enhanced Multi-character Extended Record.
07/28/04   fc      Latest Rel C addendum changes on GNLM and UNLM.
07/26/04   az      Updated ECAM Assign mode 4 with some bug fixes
07/21/04   sb      Added fix for info recs so they can handle /Zp1 flag.
07/12/04   az      Updated ECAM. Still has some problems with AM4 and AM5
07/09/04   sb      Added support for Release D orders.
07/07/04   sb      More Release D updates to info recs.
07/07/04   bkm     Lint cleanup.
07/06/04   bkm     #if 0 bits_to_pack variable.
07/06/04   sb      Made Release D updates to the info recs.
06/18/04   fc      Dword alignment fix for ECAM.
06/17/04   pg      Bug fix for a release D UHDM change.
06/17/04   fc      Rel C addendum changes on GNLM, UNLM and ECAM.
06/17/04   bkm     Put BCMCS msgs under Rel D subfeature.
06/16/04   va      Rel C addendum changes for Reg, Orig and Orig continuation
06/14/04   fc      Release C addendum changes on common channel messages.
06/11/04   sb      Release C Addendum changes for: GHDM, ERM, RATCHGM, ITSPM.
06/09/04   sb      Release C Addendum changes for UHDM.
06/09/04   pg      Added P_REV check for all the release D fields in UHDM.
06/08/04   fc      Changes on BSPM.
06/08/04   bkm     Fixed typos in feature names within comments.
06/08/04   bkm     More lint cleanup.
06/03/04   fc      Added support for Release D common channel messages.
06/04/04   bkm     Lint cleanup.  More to go.
06/03/04   bkm     Merged the following from IS2000_REL_B_C:
  06/01/04   sb      Fixed lint errors.
  05/21/04   fc      Fixed indentation.
06/02/04   bkm     Updated GHDM parsing for Rel D.
06/02/04   pg      Bug fix for NNSCR Rel D parsing.
05/28/04   bkm     Merged the following from IS2000_REL_B_C
  03/05/04   bkm     Lint cleanup.
05/21/04   bkm     A few changes to compile with FEATURE_IS2000_REL_D undefined.
05/20/04   va      Bug fix for RRRM  and ITBSPMRM
05/19/04   az      Added support for ECAM Rel D parsing
05/14/04   va      Support for REL D access chan & rev TC messages
05/06/04   pg      Added Release D fields for UHDM.
                   Added UNPACKQ_PG macro.
04/23/04   az      Added Release D fields for
                   Service Connect Message
                   Service Configuration Record
                   Non-Negotiable Service Configuration record
04/19/04   bkm     Added Release D fields for RATCHGM and ITBSPM.
04/16/04   bkm     Added Release D fields for CLAM, ERM, ESPM and BSSRSPM.
                   Use struct in PCNM for pz_hyst* fields.
04/13/04   bkm     Added Release D fields for ITSPM and Power Control Msg.
04/01/04   bkm     Updates for more concise cai_ext_chind enums.
02/29/04   yll     Revert back the JCDMA JTACS changes because of new JCDMA
                    requirements.
03/12/04   fc      Fixed merge error.
02/10/04   fc      Added PD validation.
02/12/04   va      Pack p_rev 7 fields in CCC IR only if p_rev_in_use
                   is 7
02/05/04   bkm     Merged the following from IS2000_REL_B.
  02/05/04   va      Merged from MSMSHARED but actual bug fixes already in here.
  01/13/04   sb      UHDM fix to get rid of SILK discrepancies for unknown ch_inds.
  01/12/04   sb      Rel C Registration Accepted Order fields only for ordq 7.
  01/12/04   sb      Maci fix for EHDM.
  01/12/04   sb      RTC Reject Order bug fixes; add Security Mode Completion Order.
  01/06/04   sb      Added Release C Order fields.
  12/19/03   sb      Added dword alignment to EAWIM/EFWIM, and fixed for loops.
01/20/04   bkm     Fixed compile warnings.
12/19/03   va      Merged following from msmshared:
 11/18/03  lh      Added dependency for qpch_code_chan on sr3_incl in MC_RR.
 11/11/03  yll     For JCDMA, the mobile shall ignore and discard the
                   (Extended) Global Service Redirection Message that
                   contains a JTACS or TACS record.
12/09/03   sb      Added Release C fields of UHDM and GHDM.
11/14/03   sb      Added Release C fields of Power Control Message.
11/13/03   sb      Miscellaneous Release C fixes.
11/11/03   sb      Added Release C fields of FTC Security Mode Command Msg.
11/10/03   sb      Added Release C fields of In-Traffic System Parameters Msg.
11/04/03   sb      Added Release C fields of Service Connect Message.
11/03/03   sb      Fixed len in RATCHGM and Auth Request on FTC.
10/24/03   fc      Fixed discrepancies on MC Extedned Dsplay Info Rec.
                   Fixed discrepancies on Feature Notification message.
10/22/03   va      Fixed REL_C turned off compilation errors.
10/21/03   va      Fixed misc Parser bugs
10/20/03   fc      Fixed discrepancies in band class info rec parsing.
10/17/03   fc      Fixed band class info rec size.
10/17/03   sb      Fixed bug in ERM.
10/16/03   fc      Fixed Extended Display Info Rec discrepancies.
10/15/03   lh      Changed access_ho_allowed[i] to access_ho_allowed inside
                   the FSIZ macro.
10/15/03   fc      Fixed FTC Maintenance Order and Continuous DTMF Order.
10/15/03   fc      Fixed User Zone Reject Message and info recs.
10/09/03   fc      Fixed FTC Order message and Power Up Function Completion
                   message.
                   Fixed AC Extended Status Response message.
10/08/03   fc      Fixed Alert With Info message, Flash With Info message
                   and Feature Notification message.
10/07/03   fc      Fixed Retrieve Paremeter message, Set Parameter message,
                   Neighbor List Update message and Analog Handoff Direction
                   message issues.
                   Changes for ECAM AM5 and  non-negotiable service configuration.
10/06/03   fc      Changes for CAM and order.
10/03/03   sb      Fixed bug in Mobile Station Registered Message.
10/03/03   fc      Fixed ECAM AM5 issues.
10/03/03   sb      Added Authentication Request Message on FTC.
10/03/03   sb      Fixed bug in Mobile Station Registered Message.
10/02/03   fc      Fixed PLCM issues.
10/01/03   fc      Fixed ECAM issues.
09/26/03   fc      Changes for f-csh data burst message, authentication
                   challenge message, SSD update message and feature
                   notification messages.
09/25/03   fc      Fixed bugs in status request message, feature notification
                   message and multi-character extended display information
                   record translation.
09/24/03   fc      Fixed FTC encryption translation.
09/23/02   lh      Parsing IT-SPM based on P_REV coming in the message, rather
                   than based on P_REV_IN_USE.
09/23/03   fc      Fixed access channel encryption and maci translation.
                   Fixed reverse traffic channel maci translation.
                   Fixed bugs in TMSI assignment message and PACA message.
09/23/03   va      Added unsupported record_types to EOM
                   Fixed bugs in Orig and EOM
09/21/03   fc      Changes for ECAM.
09/18/03   sb      Added Rate Change Msg, Rel C fields of ERM and CLAM.
09/18/03   fc      Changes for message integrity fields parsing.
09/17/03   fc      Fixed rtc header translation.
09/17/03   va      Fixed parser bugs
09/16/03   fc      Corrected extended enryption fields parsing for RTC
                   messages.
09/15/03   fc      Changes for system parameter message.
                   Changes for ANSI-41 System Parameter message.
09/08/03   va      Changed name to for_pdch_fields in Orig & page
                   Response caii structs
09/04/03   fc      Added support for UIM_ID and ESN_ME info recs.
09/04/03   sb      Fixed compiler warning.
09/02/03   az      Featurized mcc_burst_overflow_size within
                   FEATURE_MSG_PACK_UNIT_TEST
09/02/03   fc      Fixed buffer size sanity check for extended channel
                   assignment message.
                   Corrected the featurization for reference to
                   mcc_burst_overflow_size.
08/11/03   bkm     Made loop condition for record processing CAM same as ECAM,
                   adds error protection against case of len < order_pos,though
                   this should never happen.
08/08/03   fc      Added support for IS2000 Release C messages.
07/30/03   az      Added support to return overflow size for MO SDB
07/30/03   az      Added support for FEATURE_SO_8026
07/03/03   fc      Removed minimum message length check for ANSI-41 system
                   parameter message and MC-RR parameter message.
07/01/03   az      Added FEATURE_ENHANCED_BAND_CLASS
06/18/03   fc      Added support for the decoupling of FCH and DCCH MUX.
06/02/03   bkm     Lint cleanup.
04/09/03   sb      Removed featurization from alignment since SILK supports it.
03/31/03   sb      Moved cadence_type to fixed part of Para Alert info rec.
03/21/03   lh      Fixed a bug of skipping msg_pos when REL_A is not defined.
03/14/03   va      Fixed the bug in traversing recs after CCC in TC stat rsp
                   if REL_A is not defined.
02/27/03   sb      Removed unnecessary is2000_rel_a_incl from Sync Channel Message.
02/27/03   sb      Added Release B changes.
02/19/03   fc      Added Release B f-csh changes.
02/19/03   va      Added Release B changes.
02/19/03   fc      Corrected length comparsion on xlate_ext_gen_nl.
02/05/03   fc      Cleanup for f-csh forward compability.
01/31/03   bkm     Added MSG_HIGH on tranmsit of SCH errors Pwr Msg Rpt Msg.
01/14/03   sb      Removed checking for 0 frequency in CCLM.
01/03/03   sb      Only align ECAM if not in SILK.
12/12/02   sb      Added reserved field to MC-RR.
12/05/02   ph      Fixed cc_info_incl reference in UHDM parsing.
11/13/02   sb      Fixed featurization.
11/07/02   az      Removed FEATURE_IS2000_REV0_PREADDENDUM
11/07/02   az      Mainlined FEATURE_IS95B
10/31/02   va      Added support for dynamic p_rev
10/02/02   yll     Linted the code.
10/01/02   az      Mainlined FEATURE_IS2000 and FEATURE_IS2000_2_1_ADDENDUM
07/17/02   ph      fixed call wait ind rec parsing to skip the reserved field also.
06/27/02   fc      Changes for caii_univ_page_interleaved_addr_type.
06/25/02   az      Changed the name of the union for IMSI type specific
                   subfields from class to class_type.
06/18/02   yll     Added support for Base Station Status Req/Rsp Message.
06/13/02   yll     Changed the BCSMS feature name to be under Rel A CC.
06/11/02   fc      Removed num_page_recs from UPM structure.
06/10/02   sb      Removed P_PARAMS macro; changed page_pos to ext_msg_pos.
                   Changed Sync Channel Message parsing to be more efficient.
06/04/02   sb      Sync Channel Message now rejects messages with missing fields.
05/28/02   fc      Changes to match UPM interleaved address structure with
                   message pack unit test.
05/22/02   fc      Changes for message pack unit test.
                   Fixed length comparsion on xlate_ext_e_cl().
                   Fixed translation for Universal Page Message.
05/20/02   fc      Added support for Universal Page Message.
05/06/02   yll     Removed FEATURE_IS2000_REL_A_BCSMS for correct message
                   parsing.
04/16/02   va      Fixed emergency record packing for EFWIM.
04/12/02   lh      Added support for subaddress in Orig_C.
04/09/02   yll     Added Broadcast SMS support on IS2000 RelA common channel.
03/25/02   ph      Initialized cc_info_incl for REL_A
03/25/02   fc      Removed obsolete messages processing in xlate_ext_fccch_msg.
03/24/02   sb      Include ba_parms_len and ra_parms_len in caii_en_ac_parm_type.
03/08/02   sb      Updated CAM, ESP, ECAM, Ansi-41, MC-RR, EAPM and SMCM to be in
                   sync with Addendum 2 published version.
03/12/02   lh      Added CMEA support for release A messages.
03/06/02   sb      Fixed macro calls for ACCT fields in EAPM
03/04/02   ph      Updated with changes to SCM format to sync up with Add 2 pub version.
                   Also, fixed bug in filling reserved fields for Global Emer Rec
                   in FWIM and EFWIM.
03/04/02   sb      Removed +1's in xlate_ext_bcch_msg function calls (merge error)
02/06/02   lh      Fixed NNSCR.
02/22/02   fc      Added support for Release A common channels.
02/15/02   sb      qpch_power_level_config in MC-RR is now parsed conditionally
02/11/02   va      Fixed Global Emer record packing
02/08/02   lh      Fixed FTC messages blindly return CAIX_DONE_S.
02/07/02   lh      Changed some info rec in RTC msg from byte arry to dword array.
01/24/02   ph      Fixed packing of QOS record in outgoing TC msgs (EOM for now)
01/04/02   sb      Check p_rev only in SILK (ECCLM)
12/06/01   lh      Merged from MSM_CP.05.108.
  11/30/01   hxw     Added FEATURE_GPSONE_NEW_L2_ACK to support delay L2 Ack
                     mechanism.
  11/13/01   ph      In xlate_int_orig(), filled reserved field with '0' before
                     packing rev_fch_gating_req.
11/27/01   va      Merged from MSM_CP.05.100.01.00
  10/17/01 lcc     When sending release order on access channel, do not include
                   ORDQ if it is 0.
11/12/01   sb      Replaced length check in ECCLM with p_rev check (for Release A fields)
10/15/01   kk      Fixed compiler errors when Release A is not defined.
10/12/01   sb      Replaced probe_pn_ran in EAPM with reserved field, fixed spelling error
10/03/01   ph      fixed dword-alignment problem for Access STRSP and DIM.
10/02/01   ph      Merged in from CP VU 96
                   09/17/01   ht      Added a check for null freq in Channel List Message.
                   09/14/01   lcc     Added dword alignment in between translation of each record
                                      in ECAM to make sure that each record starts from a dword
                                      aligned address.
                   08/21/01   sj      Changed rs1_20ms_incl -> rc3_rc5_20ms_incl(Power Control
                                      Msg), rs2_20ms_incl ->rc4_rc6_20ms_incl(Power Control Msg)
                                      & num_visits -> max_num_visits(Candidate Frequency Search
                                      Response message).
09/28/01   kk      Added missing position location indicator to Flash msg.
09/10/01   lh      Taking out CC fields from GHDM.
09/06/01   sb      Replaced length fields in xlate_en_ac_parm with local vars.
08/23/01   ph      Fixed typo-bug in nnscr processing
08/20/01   lh      Paging channel fixes.
08/16/01   ph      Rel A Addendum 2 changes for the FTC
08/16/01   lh      Addendum 2 Changes for F-CSCH and R-CSCH.
08/15/01   kk      Addendum 2 Changes on Reverse Traffic Channel Added.
06/26/01   kk      Added missing field in EOM.
06/26/01   kk      Merge from main archive
  06/15/01 lcc     In xlate_ext_ho_msg, allows extra field to be included at
                   the end of the message.
  06/15/01 lcc     Added FEATURE_IS2000 around align_timing in CFSCM.
  06/14/01 lcc     Corrected Candidate Frequency Search Control Message and
                   Channel Configuration Capability Information Record to be
                   Rel. 0 Addendum 2 compliant.
05/29/01   kk      Fixed Resource Release msg.
05/22/01   ph      some fixes to FTC messages.
05/16/01   lh      Merged following changes from common archive.
  05/11/01   jq      Added length field in ERRM/RRM sending.
  05/03/01   lh      No logical changes, just added some more parenthesis in
                     ALIGN_DWORD macro calls, and type casting.
  05/02/01   fc      Added support of T_ADD_ABORT.
  05/02/01   lh      Fixed possible mis-alignment for FWD and REV info records.
  04/10/01   jq      Added msg process related to DCCH and contorl hold support.
05/07/01   ph      Fix con_ref so it is not extracted for lock_or_maint order
04/26/01   lh      Clean up Band Class Info Rec.
04/18/01   lh      Fixes in RTC Status Rsp Msg.
04/18/01   ph      some fixes to Ext Disp, changes to sync up "cadence_type" for testing.
04/17/01   lh      Changes for unit testing.
04/12/01   ph/kk   support for new power control fields, other fixes for FTC msgs.
04/09/01   lh      Added capability info rec.
04/09/01   ph      FTC uhdm/ghdm fixes.
03/27/01   lh      PCH and ACH fixes.
03/27/01   kk      Fixed warnings in various functions
03/26/01   kk      supplemental channel request message fixes.
03/22/01   ph      FTC and RTC fixes in the parser
03/14/01   kk      Order fixes
03/13/01   ph      Fixes related to FTC msgs
03/12/01   lh      UNLM optimization.
03/09/01   lh      Fixed compilation problem when FEATURE_IS2000_REL_A is off.
03/08/01   kk      Reverse traffic fixes.
03/07/01   lh      Release A PCH/ACH bug fixes.
03/06/01   kk      Various fixes, removal of pre rel 0 flags.
03/06/01   ph      Fixes of bugs found during parser test mostly related
                   to For traffic channel msgs of Rel A.
03/01/01   kk      Maerged changes from the mainline.
02/01/01   cah     Correct merge problem in xlate_int_page_resp().
01/24/01   ych     Merged T53 and JCDMA features.
01/02/01   lcc     Added 6 reserved bits in F/R SCH type specifics fields for BRV
                   which were missed before.
02/20/02   lh      Bug fixes.
02/09/01   lh      QOS support in Orig added for unit test.
02/02/01   lh      Bug fix in sync msg.
12/21/00   kk/lh   Added IS-2000 Release A support.
10/02/00   yll     Removed the packing of MSID type. MSID packing was moved
                   to PDSM.
08/31/00   lcc     Added reserved bits in nn-SCR for BRV version of CDMA 2000.
                   Also removed some lint warnings.
08/18/00   fc      Changed F3 PMRM message to use decimal system to indicate
                   FCH and/or SCH frame statistics.
08/03/00   fc      Added #ifdef FEATURE_IS2000 around F3 PMRM message which
                   indicates SCH statistics.
08/03/00   fc      Modified xlate_int_tc_msg() to clarify F3 PMRM message to
                   indicate FCH and SCH frame statitics.
07/06/00   yll     Added packing the MSID to be used by PDSM IS801 services.

07/06/00   yll     Added packing the MSID to be used by PDSM IS801 services.
07/06/00   jq      Added parser for ECCLM and EGSRM. Modified CFS_RSP and GSRM
                   parsing for addendum compliance.
06/19/00   jrw     1. Corrected a problem with power control message where the
                   init_setpt shouldn't have been included with the SCH set points.
                   2. Added checking for P_REV before parsing the new fields in PMRM.
06/16/00   ks      Removed the ifdef FEATURE_IS2000_REV0_PREADDENDUM checking
                   for flash record tyhpe CAI_FEAT_REC in xlate_int_flash()
06/12/00   ks      Added support for align_timing field in CFSRQM message.
06/02/00   jrw     Changes to support IS2000 Rev 0 published addendum.
05/25/00   ks      Added support for Neighbor Search Window offsets in
                   Candidate Frequency Search Request Message.
04/24/00   jrw     Added ESCAM, outer loop report message, and changes to PMRM.
03/30/00   ry      Added a check back to xlate_ext_srv_cfg() that was removed
                   during the previous merge, and featurized the check under
                   #ifndef FEATURE_IS2000
03/28/00   ry      Fixed compiler warning for Pink Panther build
03/23/00   va      Added back support for FEAT_REC_TYPE
                   Info records alogned at dword boundaries in caii_acstrsp_type
03/07/00   ry      Added IS2000 featurization
           ry      Replaced FEATURE_SILK with FEATURE_MSG_PACK_UNIT_TEST
02/24/00   jrw     Fixed access channel bug (layer 2 length field)
02/15/00   jrw     Added IS2000 check for new fields in Service Config Rec
02/11/00   jrw     Added support for IS2000 Addendum
12/17/99   jrw     Added support for IS2000 Phase 1.
10/18/99   kk      Added an extra sanity check for Service Redirection message
                   processing.
08/09/99   ry      Initialize pre_proc_done to FALSE in xlate_ext_tc_cfs_req()
                   and xlate_ext_tc_cfs_ctrl() for action time processing
06/30/99   kmp     in the cai_tmo enum correctly made the FEATURE definition
                   FEATURE_IS95B instead of FEATURE_ACCESS_HO.
06/17/99   kmp     Added T72m and N13m to cai_tmo if certain IS-95B features
                   are defined.
06/02/99   kmp     Merged the 2 changes below into the ASW archive.
           lh      Support release order on access channel, name change
                   from reserve to auth_mode.
           lh      Updated for Published version of IS-95B.
05/19/99   doj     Consolidated the parsers for HDM, EHDM and GHDM into one
                   generic handoff message parser.  Added macros UNPACKB_PG,
                   UNPACKW_PG, UNPACKB_PG_DRF, UNPACKW_PG_DRF.
02/13/99   doj     Added support for General Handoff Direction Message (GHDM).
                   Also includes several misc. updates by many people to
                   support FEATURE_SPECIAL_MDR.
01/18/99   ram     Added redirect_type field for SERVICE REDIRECTION Message
                   as part of IS95B MDR changes.
01/16/99   ram     Merged in the changes for IS95B MDR from MDR branch.
01/07/99   lh      Not include tmsi.h if FEATURE_TMSI is not defined.
01/06/99   lh      Extended Status Response and Status Response now share the
                   same internal formats.
01/06/99   lh      FEATURE_JSTD008 replaced with run-time P_REV and Band
                   Class checking.
12/23/98   lh      Modified ECAM. Now parser will parse the ECAM and pass the
                   caller a packed internal format.
11/24/98   lh      Added comments.
10/29/98   jcw     Modify parsing of 95B extended display records to support
                   new structure fields needed by MC
10/12/98   lh      Change soft_slop to soft_slope in ESPM processing.
10/05/98   jcw     Parsing of extended display record has been updated to
                   not treat blank & skip subrecords specially.
09/15/98   lh      IS-95B support.
08/12/98   lh      IS-95B WLL support added.
01/15/98   lh      Added IS-95B Line Control info record parsing.
01/14/98   dna     Add support for Korean PCS in Band Class Status Response
04/18/97   dna     Changed some #ifdefs to make class 1 IMSI its own feature
12/13/96   jca     Processing new fields in Channel Assignment Message
                   where the ASSIGN_MODE is set to '010'.
09/03/96   dna     Fixed unpack of nom_pwr_ext field in access params.
06/28/96   dna     Created xlate_ext_tc_hdr and xlate_int_tc_hdr functions.
05/30/96   dna     #ifdef JSTD_008 class 1 IMSI packing for access channel.
05/28/96   dna     Added Class 1 IMSI support for Access Channel messages.
04/09/96   day     Added TMSI addressing modifications.  Using T_TMSI ifdef.
03/13/96   day     Added J-STD-008 PCS message modifications.  Using FEATURE_JSTD008
                   ifdef.
10/10/95   jca     Fixed specific bug where IS95 formatted Analog Handoff
                   Direction Message was being dropped and in general made
                   code more robust to future message modifications.
10/03/95   dna     Fixed 2 bugs in xlate_ext_ext_ho_dir.
09/18/95   jca     Fixed bug in parsing Service Option Control messages.
08/28/95   rdb     Fixed processing of type 2 qualification info in
                   xlate_ext_pc_streq.
08/24/95   rdb     Added translation function for information records that
                   was inadvertently omitted.
08/22/95   gb      Fixed NLU message processing.
08/22/95   dna     Modified Sync Channel Message unpacking for new field
08/18/95   dna     Added assign mode '101' EXT_PAGING_CHAN_ASSIGN
08/10/95   rdb     Added translation routines for Status Request and Status
                   Response Messages, and for new information records
                   introduced in the IS-95-A TSB.
08/09/95   jca     Added General Page Message.  Added new Paging and Access
                   Channel address types including support for IMSI addresses.
08/03/95   dna     Added support for message encryption.
07/27/95   gb      Fixed a field in Extended Handoff Direction Message.
07/20/95   gb      Added Extended Handoff Direction Message.
07/13/95   rdb     Added support for service negotiation messages and
                   for assign mode 4 of chan assign message.
06/25/95   dy      Added Data Burst SMS message validation checks.
05/12/94   gb      Added F3 screen messages for every TC message.
04/25/94   gb      Parameterised all IS95 timeouts in cai_tmo.
04/21/94   jca     Fixed spec bug in Parameters Response Message.
12/22/93   jca     Switched to IS-95 message formats.
01/23/91   jai     Created module.

===========================================================================*/

/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/

#include "1x_variation.h"
#include "target.h"
#include "customer.h"
#include "modem_1x_utils.h"
#include "modem_1x_defs.h"

#include "comdef.h"
#include "qw.h"
#include "bit.h"
#include "msg.h"
#include "m1x_diag.h"

#include "cai_v.h"
#include "caii_v.h"
#include "caix.h"
#include "caix_i.h"

#include "mccdma_v.h"


#include "auth_v.h"
#include "auth_i.h"

#include "tmsi.h"
#include "mc_v.h"

#if defined(FEATURE_IS2000_REL_A_AES)
#include "mccdma_v.h"
#include "mccdma_i.h"
#endif /* FEATURE_IS2000_REL_A_AES */

#include "err.h"
#include "amssassert.h"

#if defined(FEATURE_IS2000_REL_A_AES)
#include "mccaka.h"
#include "mccsec.h"
#include "mccmi.h"
#include "mccaes.h"
#include "mcckey.h"
#endif /* FEATURE_IS2000_REL_A_AES */

/*===========================================================================

                DEFINITIONS AND DECLARATIONS FOR MODULE

This section contains definitions for constants, macros, types, variables
and other items needed by this module.

===========================================================================*/
#if defined(FEATURE_IS2000_REL_A_AES)
static mccsec_fwd_sseq_info_type sseq_info;
/* Stores SSEQ validation information */

/* provide an access function for other modules to use */
/*===========================================================================

FUNCTION get_sseq_validation_status

DESCRIPTION
  This function returns the SSEQ validation status

DEPENDENCIES
  None

RETURN VALUE
  an integer value of SSEQ validation status

SIDE EFFECTS
  buf_pos updated.

===========================================================================*/

mccsec_sseq_validation_status_type get_sseq_validation_status(void)
{
  return sseq_info.sseq_status;
}
#endif /* FEATURE_IS2000_REL_A_AES */

byte caix_p_rev_in_use;

void caix_set_p_rev_in_use(byte p_rev_in_use)
{
  caix_p_rev_in_use = p_rev_in_use;
}

#define AC_L2_LENGTH_NUM_BITS 5
word ac_l2_length_pos = 0;
word ac_l2_start_pos = 0;
word ac_l2_num_bits = 0;
word ac_l2_num_bytes = 0;
word ac_l2_num_reserved = 0;
word ac_plt_rpt_len = 0;

word xlate_int_plt_rpt
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  word buffer_offset,
    /* offset into buffer to start placing the message */
  caii_plt_rpt_type *int_ptr
    /* Pointer to internal message to be transmitted */
);

word global_buf_pos = 0;

/* Structure to hold all IS95 timeout values that may be changed for
 * debug purposes.
 */

cai_tmo_type cai_tmo =
{
  CAI_T1M,
  CAI_T2M,
  CAI_T3M,
  CAI_T4M,
  CAI_T5M,
  CAI_T20M,
  CAI_T21M,
  CAI_T30M,
  CAI_T31M,
  CAI_T40M,
  CAI_T41M,
  CAI_T42M,
  CAI_T50M,
  CAI_T51M,
  CAI_T52M,
  CAI_T53M,
  CAI_T55M,
  CAI_T57M,
  CAI_T69M,
  CAI_T72M,
  CAI_T75M,
  CAI_T79M,
  CAI_N1M,
  CAI_N2M,
  CAI_N3M,
  CAI_N5M,
  CAI_N6M,
  CAI_N7M,
  CAI_N8M,
  CAI_N9M,
  CAI_N10M,
  CAI_N11M
 ,CAI_N13M
};


/*-   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/
/*                       MACROS                                            */
/*-   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/
/* Suppress the following lint messages:
   e413: Likely use of null pointer in left argument to operator '->',
         which is heavily used in FPOS and FSIZ macros.
   e734:
   e713: Loss of precision (assignment).
   e737: Loss of sign in promotion from int to unsigned int.
   e715: Not referenced
   e573: Signed-unsigned mix with divide
   e574:
   e740: Unusual pointer cast (incompatible indirect types)
   e641: Converting enum to int
   e826: Suspicious Pointer to Pointer Conversion
   e834: Operator '-' followed by operator -
   e818: Pointer constant
  */

/*lint -e413 -e734 -e713 -e737 -e715 -e573 -e574 -e740 -e641 -e834 -e818 -e826 */

/* Macro to build parameters for use in b_unpack and b_pack routines while
   packing and unpacking messages other than Paging Channel orders */
#define PARAMS( field ) \
  buf_ptr, FPOS( MTYPE, field ), FSIZ( MTYPE, field )

/* Macro to compute the offset, in bytes, of the end of a specified field
   of a specified structure type */
#define FENDPOS( type, field ) \
  (FPOS( type, field ) + FSIZ( type, field ))

/* Macro to build parameters for packing and unpacking
   information record headers. */
#define  REC_P( field ) \
  buf_ptr, buf_pos + FPOS( cai_rec_hdr_type, field ), \
  FSIZ( cai_rec_hdr_type, field )

/* Macro to build parameters for packing and unpacking
   service configuration header records. */
#define  HDR_P( field ) \
  buf_ptr, buf_pos + FPOS( cai_srv_cfg_hdr_type, field ), \
  FSIZ( cai_srv_cfg_hdr_type, field )

/* Macro to build parameters for packing and unpacking
   service configuration connection records. */
#define  CON_P( field ) \
  buf_ptr, buf_pos + FPOS( cai_srv_cfg_con_type, field ), \
  FSIZ( cai_srv_cfg_con_type, field )

/* Macro to unpack a byte and advance the
   page position */
#define UNPACKB_PG(ext, type, field)                                \
  int_ptr->ext = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(type, field));   \
  ext_msg_pos += FSIZ(type, field)

/* Macro to unpack a word and advance the
   page position */
#define UNPACKW_PG(ext, type, field)                                \
  int_ptr->ext = b_unpackw(buf_ptr, ext_msg_pos, FSIZ(type, field));   \
  ext_msg_pos += FSIZ(type, field)


/* Macro to unpack a dword and advance to
   page position */
#define UNPACKD_PG(ext, type, field)                                \
  int_ptr->ext = b_unpackd(buf_ptr, ext_msg_pos, FSIZ(type, field));   \
  ext_msg_pos += FSIZ(type, field)

/* Macro to unpack a qword and advance to
   page position */
#define UNPACKQ_PG(ext, type, field)                                \
  b_unpackq(buf_ptr, ext_msg_pos, FSIZ(type, field), int_ptr->ext);   \
  ext_msg_pos += FSIZ(type, field)

#define UNPACK_MSG_TYPE(dest, msg_type)                             \
  dest = msg_type & 0x3F;

#define UNPACK_PD(dest, msg_type)                                         \
  dest = ( (msg_type & 0xC0) >> 6 ) & 0x03;


/* Macro to unpack a byte and advance the dereferenced
   page position pointer */
#define UNPACKB_PG_DRF(ext, type, field)                            \
  int_ptr->ext = b_unpackb(buf_ptr, *ext_msg_pos, FSIZ(type, field));  \
  *ext_msg_pos += FSIZ(type, field)

/* Macro to unpack a word and advance the dereferenced
   page position pointer */
#define UNPACKW_PG_DRF(ext, type, field)                            \
  int_ptr->ext = b_unpackw(buf_ptr, *ext_msg_pos, FSIZ(type, field));  \
  *ext_msg_pos += FSIZ(type, field)

word xlate_int_non_neg_srv_cfg
(
  byte *buf_ptr,
    /* Pointer to message buffer which is to contain translated
       service configuration record. */

  word *buf_pos,
    /* Offset in message buffer at which to start non-neg service
       configuration record. */

  caii_non_neg_srv_cfg_type *i_ptr
    /* Pointer to internal non_neg service configuration record to be
       translated */
);

#ifdef FEATURE_IS2000_REL_C
#define CAIX_MACI_REQUIRED     TRUE
#define CAIX_MACI_NOT_REQUIRED FALSE

/*===========================================================================

FUNCTION xlate_ext_mi_and_validate_maci

DESCRIPTION
  This function translates the message integrity fields
  from external to internal format and validates MACI.

DEPENDENCIES
  None

RETURN VALUE
  CAIX_DONE_S - if everything is good.

SIDE EFFECTS
  buf_pos updated.

===========================================================================*/

word xlate_ext_mi_and_validate_maci
(
  word len,
    /* Length of message */
  word chn,
    /* Physical Channel this message is received on */
  byte pd,
    /* Protocol discriminator */
  boolean maci_expected,
    /* Indicates if MACI field is expected */
  word *pos_ptr,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_msg_int_type *int_ptr,
    /* Pointer to place translated message integrity fields */
  byte msg_type,
    /* Message type */
  boolean ack_req
    /* Whether this message requires an Ack to be sent back or not */
)
{
  word status = CAIX_DONE_S;
  word maci_pos;

  M1X_MSG( DCP, LEGACY_LOW,
    "fwd link msg - chan %d, pd %d, prev %d",
    chn,
    pd,
    caix_p_rev_in_use);

  /* No Message Integrity for messages on BCCH */
  if (chn == CAIX_BCCH)
  {
    return status;
  }

  /* PD == 2 implies Message Integrity fields are included */
  if ( ( ( chn == CAIX_FCCCH ) || ( chn == CAIX_PC ) ) &&
       ( pd != 2 )
     )
  {
    return status;
  }

  /* If the message is received on traffic channel and prev < 9 */
  if ( (chn == CAIX_TC) && (caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_C) )
  {
    return status;
  }

  /* Unpack Message Integrity fields. */
  #define FTYPE cai_msg_int_type

  int_ptr->maci_incl = b_unpackb(buf_ptr, *pos_ptr, FSIZ(FTYPE, maci_incl));
  *pos_ptr += FSIZ(FTYPE, maci_incl);

  if (int_ptr->maci_incl)
  {
    int_ptr->randc = b_unpackb(buf_ptr, *pos_ptr, FSIZ(FTYPE, randc));
    *pos_ptr += FSIZ(FTYPE, randc);

    int_ptr->sdu_key_id = b_unpackb(buf_ptr, *pos_ptr,
      FSIZ(FTYPE, sdu_key_id));
    *pos_ptr += FSIZ(FTYPE, sdu_key_id);

    int_ptr->sdu_integrity_algo = b_unpackb(buf_ptr, *pos_ptr,
      FSIZ(FTYPE, sdu_integrity_algo));
    *pos_ptr += FSIZ(FTYPE, sdu_integrity_algo);

    int_ptr->sdu_sseq_or_sseqh = b_unpackb(buf_ptr, *pos_ptr,
      FSIZ(FTYPE, sdu_sseq_or_sseqh));
    *pos_ptr += FSIZ(FTYPE, sdu_sseq_or_sseqh);

    if (!int_ptr->sdu_sseq_or_sseqh)
    {
      /* 8 bit SSEQ is supplied by the BS */
      int_ptr->sdu_sseq = b_unpackb(buf_ptr, *pos_ptr,
        FSIZ(FTYPE, sdu_sseq));
      *pos_ptr += FSIZ(FTYPE, sdu_sseq);
    }
    else
    {
      /* 24 bit SSEQ is supplied by the BS */
      int_ptr->sdu_sseq_h = b_unpackd(buf_ptr, *pos_ptr,
        FSIZ(FTYPE, sdu_sseq_h));
      *pos_ptr += FSIZ(FTYPE, sdu_sseq_h);
    }

    /* ECAM is a special case since it can have multiple records and
       MACI is at the end of each record instead of just being at the end..

       For ECAM, the record addressed to this mobile has to be extracted.
       8 bit msg_type field (2 bits PD + 6 bits msg id) has to be appended
       at the start of this record. This constructed bit stream
       (8 bit msg_type + mobile addressed record) is then fed to EHMACSHA
       algorithm.
    */
    if ( ( (chn != CAIX_PC) && ( chn != CAIX_FCCCH ) ) ||
         ( msg_type != CAI_EXT_CHN_ASN_MSG ) )
    {
      /* Parse the MACI field itself */
      maci_pos = len - FSIZ(FTYPE, maci);
      int_ptr->maci = b_unpackd(buf_ptr, maci_pos, FSIZ(FTYPE, maci));
    }
  } /* if (int_ptr->maci_incl) */

  #undef FTYPE

  return status;

} /* xlate_ext_mi_and_validate_maci */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A

#ifdef FEATURE_IS2000_REL_A_AES
/*===========================================================================

FUNCTION AUTH_EXT_DECRYPT_CDMA

DESCRIPTION
  This function runs decryption algorithm for extended encryption. This
  function should reside in AUTH. It is here for early development of
  parser.

  After the decryption, it updates AES state, and also updates RX_TX_SSEQ
  when necessary.

DEPENDENCIES
  The decryption function is defined in AUTH module.

RETURN VALUE
  Plain text and modified message length.
  CAIX parsing status

SIDE EFFECTS
  The message may be translated from crypto text into
  plain text.

===========================================================================*/

word auth_ext_decrypt_cdma(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  uint16 buf_len,
    /* Pointer to Length of message */
  uint16 start_pos,
    /* Start Position of SDU */
  uint8 sdu_encrypt_mode,
    /* Encryption mode */
  uint8 ack_req,  /* ack mode */
  uint8 enc_seq,
  uint8 sdu_key_id,
  boolean maci_incl
)
{
  uint16 sseq_validation_status = CAIX_DONE_S;
  uint16 caix_status = CAIX_DONE_S;
  boolean decrypt_status;

  /* if maci_incl is TRUE, rx_ext_sseq should have already been calculated at
   * the time of MACI validation.
   *
   * if maci_incl is FALSE, it means either no AKA/MI feature, or MACI is not ON.
   * In either case, AES needs to obtain and validate rx_ext_sseq by itself
   */
  if ( ! maci_incl )
  {
    /* AES has to do its own job to obtain and validate a rx_ext_sseq for decryption */
    /* the possible return values are:
     *   CAIX_DONE_S -- sseq check OK
     *   MCCAES_AES_DECRYPT_FAIL_SSEQ_DUPLICATE -- sseq duplicated
     *   MCCAES_AES_DECRYPT_FAIL_SSEQ_OUT_OF_RANGE -- sseq out of range
     */
    sseq_validation_status = mccaes_check_enc_seq(enc_seq, ack_req, &sseq_info);

    /* if sseq_validation_status is CAIX_DONE_S, let it continue the decryption
     * procedure.
     *
     * if sseq_validation_status is not successful, we need to map the
     * sseq_validation_status into caix_status, and return this caix_status
     */
    if ( sseq_validation_status != CAIX_DONE_S )
    {
      /* the possible values of sseq_validation_status:
       *   MCCAES_AES_DECRYPT_FAIL_SSEQ_DUPLICATE -- sseq duplicated
       *   MCCAES_AES_DECRYPT_FAIL_SSEQ_OUT_OF_RANGE -- sseq out of range
       *
       * when sseq validation is failed, it is treated as a decryption
       * failure. The function call of mccaes_state_update updates AES
       * status, and maps the sseq faiulure type into a CAIX failure type.
       */
      caix_status = mccaes_state_update(sseq_validation_status);

      /* the sseq validation failure must have been mapped into a CAIX failure.
       * so no need to continue, return the CAIX failure from here
       */
      return caix_status;
    }  /* sseq_validation_status != CAIX_DONE_S */
  } /* ! maci_incl */
  else
  {

    /* If MACI is included, the MACI field needs to be excluded from the buffer
     * to be decrypted. This is because that MACI was added after the encryption.
     */
    buf_len -= MCCAES_MACI_SIZE_IN_BITS;

  }

  /* it comes here for one of the following 2 cases:
   *   -- MACI was included, and successfully validated. (if MACI validation failed,
   *      it won't come into point)
   *   -- MACI was not included, and AES procedure valiedated the sseq successfully.
   */
  if ( sdu_encrypt_mode == CAI_ENC_MODE_REA )
  {
    /* decryption can only be successful when the key of the specific sdu_key_id
     * is available
     */
    if ( mcckey_ck_available_with_id( sdu_key_id ) )
    {
      M1X_MSG( DCP, LEGACY_MED,
        "Rijndael decrypting message with key id %d...",
        sdu_key_id);

      /* the possible return value from the decryption function call:
       *
       * MCCAES_AES_DECRYPT_SUCCESS -- if the decryption was successful
       * MCCAES_AES_DECRYPT_FAIL_SSEQ_DUPLICATE -- if the decryption failed
       */
      decrypt_status = mccaes_decrypt_sig_msg(
                                               mcckey_get_ck_with_id,
                                               sdu_key_id,
                                               ack_req,
                                               MCCAES_DIRECTION_FORWARD,
                                               sseq_info.ext_sseq,
                                               buf_ptr,
                                               start_pos,
                                               buf_len
                                             );

      M1X_MSG( DCP, LEGACY_MED,
        "message decryption status: %d.",
        decrypt_status);

      /* regardless what decryption status is, we need to update AES state based
       * on the decryption status.
       *
       * the return value from mccaes_state_update is a status for caix to return.
       *
       * its possible values are:
       *   CAIX_DONE_S
       *   MCCAES_AES_DECRYPT_FAIL_SSEQ_DUPLICATE -- sseq duplicated
       *   MCCAES_AES_DECRYPT_FAIL_SSEQ_OUT_OF_RANGE -- sseq out of range
       *
       */
      caix_status = mccaes_state_update( decrypt_status );

      /* now before we return the caix_status, we need to make sure that crypto-sync
       * and the sseq map are updated correctly.
       *
       * if MACI was included, MACI procedure has taken care of this part. so
       * here AES takes care of this only when MACI was not included AND decryption
       * was successful.
       *
       */
      if ( ( decrypt_status == MCCAES_AES_DECRYPT_SUCCESS ) && ( ! maci_incl ) )
      {
        if ( sseq_info.sseq_status == MCCSEC_SSEQ_OK_FUTURE_SEQ_NUM )
        {
          M1X_MSG( DCP, LEGACY_MED,
            "Updating rx_ext_sseq after decryption");

          /* update the crypto sync value */
          mccsec_update_rx_ext_sseq( ack_req,
                                     sdu_key_id,
                                     sseq_info.ext_sseq
                                   );
        }

        /* update the duplicate detection map */
        mccsec_update_sseq_dup_detection_map(
                                              ack_req,
                                              sdu_key_id,
                                              enc_seq,   /* ENC_SEQ value from LAC header of received msg */
                                              &sseq_info  /* sseq segment info */
                                            );
      } /* ( decrypt_status == MCCAES_AES_DECRYPT_SUCCESS ) && ( ! maci_incl ) */
    } /* CK is available with the key ID sdu_key_id */
    else
    {
      /* if CK is not available, directly treat it as a decryption failure */
      M1X_MSG( DCP, LEGACY_ERROR,
        "The specified CK with key ID %d is not available, can not decrypt",
        sdu_key_id);

      /* update AES status and map the AES failure to CAIX failure */
      caix_status = mccaes_state_update( MCCAES_AES_DECRYPT_FAIL );
    } /* CK is not available with the key ID sdu_key_id */
  } /* decryption is needed */

  /* now return the caix_status*/
  return caix_status;
}


/*===========================================================================

FUNCTION AUTH_EXT_ENCRYPT_CDMA

DESCRIPTION
  This function runs encryption algorithm for extended encryption. This
  function should reside in AUTH. It is here for early development of
  parser.

DEPENDENCIES
  None.
  The encryption function is defined in AUTH module.

RETURN VALUE
  Plain text and modified message length.

SIDE EFFECTS
  The message may be translated from plain text into crypto text.

===========================================================================*/
void auth_ext_encrypt_cdma(
  byte *buf_ptr,
    /* Pointer to the message to be encrypted */
  word *len_ptr,
    /* Pointer to Length of message, including the LAC fields */
  uint16 start_pos,
    /* Start position of SDU */
  uint8 sdu_encrypt_mode,  /* the encrypt mode for this message */
  uint8 ack_req
    /* Encryption mode */
)
{
  uint32 tx_ext_sseq = cdma.aes_status.aes_tx_ext_sseq;

  if (
       ( mcckey_ck_available() ) &&
       ( sdu_encrypt_mode == CAI_ENC_MODE_REA )
     )
  {
    M1X_MSG( DCP, LEGACY_MED,
      "Rijndael encrypting: len=%d offset=%d tx_ext_sseq=%0x",
      *len_ptr,
      start_pos,
      tx_ext_sseq);
    *len_ptr = mccaes_encrypt_sig_msg(
                                       mcckey_get_ck_with_id,
                                       ack_req,
                                       MCCAES_DIRECTION_REVERSE,
                                       tx_ext_sseq,
                                       buf_ptr,
                                       start_pos,
                                       (*len_ptr) - start_pos
                                     );
    *len_ptr = (*len_ptr) + start_pos;
  }
  else
  {
    M1X_MSG( DCP, LEGACY_MED,
      "NO AES encryption: len=%d",
      *len_ptr);
  }

}
#endif /* FEATURE_IS2000_REL_A_AES */

/*===========================================================================

FUNCTION xlate_ext_ext_enc_tc

DESCRIPTION
  This function translates a Traffic Channel Message Extended Encryption
  fields from external to internal format.

DEPENDENCIES
  The decryption function is defined in AUTH module.

RETURN VALUE
  CAIX_DONE_S - if everything is good.
  CAIX_INV_MSG_S - if anything wrong.
  CAIX_INV_ENC_MODE_NOT_SUP_S - if encryption is not supported.

SIDE EFFECTS
  buf_pos updated. Extended encryption fields are put into the internal format
  just to preserve them. The message may be translated from crypto text into
  plain text.

===========================================================================*/

word xlate_ext_ext_enc_tc
(
  word *len_ptr,
    /* Pointer to Length of message, used by encryption*/
  word *pos_ptr,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_tc_hdr_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  uint8 msg_type,
  uint8 order,
  uint8 ordq
)
{
  word status = CAIX_DONE_S;

  #ifdef FEATURE_IS2000_REL_A_AES
  boolean maci_incl = FALSE;
  uint8 sdu_key_id = MCCAES_KEY_ID; /* when MI is not enabled, use 0 */

  #endif /* FEATURE_IS2000_REL_A_AES */

  /* at this point the hdr.encryption is already filled
     by XLATE_EXT_TC_HDR function call */

  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    if (int_ptr->encryption == CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
    {
      int_ptr->sdu_encrypt_mode = b_unpackb(buf_ptr, *pos_ptr,
        FSIZ( cai_tc_hdr_ext_enc_type, sdu_encrypt_mode));
      *pos_ptr += FSIZ(cai_tc_hdr_ext_enc_type, sdu_encrypt_mode);

      if (((int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_ECMEA) ||
           (int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_REA))
#ifdef FEATURE_IS2000_REL_C
          && ((caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_C) ||
              !int_ptr->msg_int.maci_incl)
#endif /* FEATURE_IS2000_REL_C */
         )
      {
        int_ptr->enc_seq = b_unpackb( buf_ptr, *pos_ptr,
          FSIZ( cai_tc_hdr_ext_enc_type, enc_seq ));
        *pos_ptr += FSIZ( cai_tc_hdr_ext_enc_type, enc_seq );
      }

      #ifdef FEATURE_IS2000_REL_A_AES
      if ( !mccaes_validate_sig_aes_mode(int_ptr->sdu_encrypt_mode) )
      {
        M1X_MSG( DCP, LEGACY_HIGH,
          "Invalid sdu_encrypt_mode %d",
          int_ptr->sdu_encrypt_mode);
        return CAIX_INV_ENC_MODE_NOT_SUP_S;
      }
      else if ( ( int_ptr->sdu_encrypt_mode != CAI_ENC_MODE_DISABLED ) &&
                ( cdma.aes_status.d_sig_encrypt_mode == CAI_ENC_MODE_DISABLED )
              )
      {
        M1X_MSG( DCP, LEGACY_HIGH,
          "AES encryption not turned on yet, the message should have not been encrypted");
        return CAIX_INV_ENC_MODE_NOT_SUP_S;
      }
      else if ( mccaes_supports_sig_aes() &&
                ( cdma.aes_status.d_sig_encrypt_mode != CAI_ENC_MODE_DISABLED ) &&
                ( int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_DISABLED ) &&
                ( ! ( ( msg_type == CAI_TC_AUTH_MSG ) ||
                      ( msg_type == CAI_TC_AUTH_REQ_MSG ) ||
                      ( msg_type == CAI_SECURITY_MODE_MSG) ||
                      ( ( msg_type == CAI_TC_FWD_ORD_MSG ) && ( order == CAI_BS_REJ_ORD ) )
                    )
                )
              )
      {
        return MCCAES_AES_NOT_ENCRYPTED;
      }
      else if ( int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_DISABLED )
      {
        /* do nothing here if the message was not encrypted, just return CAIX_DONE_S */
        return status;
      }
      /* now prepare RX_EXT_SSEQ for decryption purpose */

      /* ----------------------------------------------------------
       ** The message is encrypted, have to decrypt it first. The
       ** decryptor accepts the encryption fields, crypto text, and
       ** its start pointer, returns with plain text, and modified
       ** message length, so the parser can continue.
       ** ---------------------------------------------------------- */

      status = auth_ext_decrypt_cdma(buf_ptr,
                                     *len_ptr,
                                     *pos_ptr,
                                     int_ptr->sdu_encrypt_mode,
                                     int_ptr->ack_req,
                                     int_ptr->enc_seq,
                                     sdu_key_id,
                                     maci_incl
                                    );

      #endif /* FEATURE_IS2000_REL_A_AES */
    } /* enc_fields_incl */

    #ifdef FEATURE_IS2000_REL_A_AES
    else if ( ( cdma.aes_status.d_sig_encrypt_mode != CAI_ENC_MODE_DISABLED ) &&
              ( int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_DISABLED ) &&
              ( ! ( ( msg_type == CAI_TC_AUTH_MSG ) ||
                    ( msg_type == CAI_TC_AUTH_REQ_MSG ) ||
                    ( msg_type == CAI_SECURITY_MODE_MSG) ||
                    ( ( msg_type == CAI_TC_FWD_ORD_MSG ) && ( order == CAI_BS_REJ_ORD ) )
                  )
              )
            )
    {
      return MCCAES_AES_NOT_ENCRYPTED;
    }
    #else
    if ( ( int_ptr->encryption == CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG ) &&
         ( int_ptr->sdu_encrypt_mode != CAI_ENC_MODE_DISABLED )
       )
    {
      return CAIX_INV_ENC_MODE_NOT_SUP_S;
    }
    #endif /* FEATURE_IS2000_REL_A_AES */
  } /* P_REV >= 7 */

  return status;

} /* xlate_ext_ext_enc_tc() */
#endif /* FEATURE_IS2000_REL_A  */

/*===========================================================================

FUNCTION XLATE_EXT_TC_HDR

DESCRIPTION
  This function translates a Traffic Channel Message header from external to
  internal format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

void xlate_ext_tc_hdr
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_tc_hdr_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
    int_ptr->ack_seq = b_unpackb( buf_ptr,
                                  (word)FPOS( cai_gen_tc_type, hdr.ack_seq ),
                                  FSIZ( cai_gen_tc_type, hdr.ack_seq ));
    int_ptr->msg_seq = b_unpackb( buf_ptr,
                                  (word)FPOS( cai_gen_tc_type, hdr.msg_seq ),
                                  FSIZ( cai_gen_tc_type, hdr.msg_seq ));
    int_ptr->ack_req = b_unpackb( buf_ptr,
                                  (word)FPOS( cai_gen_tc_type, hdr.ack_req ),
                                  FSIZ( cai_gen_tc_type, hdr.ack_req ));
    int_ptr->encryption = b_unpackb( buf_ptr,
                                (word)FPOS( cai_gen_tc_type, hdr.encryption ),
                                     FSIZ( cai_gen_tc_type, hdr.encryption ));
} /* xlate_ext_tc_hdr() */

/*===========================================================================

FUNCTION XLATE_EXT_TC_ORD

DESCRIPTION
  This function translates a Traffic Channel Order Message from external to
  internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Order message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_ord
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word add_record_len;
    /* Used to store additional record length */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( cai_ftc_gen_ord_type )
#ifdef FEATURE_IS2000_REL_A
            - FSIZ(cai_ftc_gen_ord_type, con_ref_incl)
            - FSIZ(cai_ftc_gen_ord_type, con_ref)
#endif /* FEATURE_IS2000_REL_A */
     )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    #define FTYPE cai_ftc_ord_type

    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_ord.gen.hdr);

    /* Initialize msg_pos */
    msg_pos = FENDPOS(FTYPE, gen.hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(
                                len,
                                CAIX_TC,
                                0,
                                CAIX_MACI_REQUIRED,
                                &msg_pos,
                                buf_ptr,
                                &int_ptr->tc_ord.gen.hdr.msg_int,
                                int_ptr->tc_ord.gen.msg_type,
                                int_ptr->tc_ord.gen.hdr.ack_req
                                )) == CAIX_DONE_S)

#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
           &int_ptr->tc_ord.gen.hdr,
           int_ptr->tc_ord.gen.msg_type,
           int_ptr->tc_ord.gen.order,
           int_ptr->tc_ord.ordq.ordq
          )
         ) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {

        int_ptr->tc_ord.gen.use_time = b_unpackb(buf_ptr, msg_pos,
          FSIZ(FTYPE, gen.use_time));
        msg_pos += FSIZ(FTYPE, gen.use_time);

        int_ptr->tc_ord.gen.action_time = b_unpackb(buf_ptr, msg_pos,
          FSIZ(FTYPE, gen.action_time));
        msg_pos += FSIZ(FTYPE, gen.action_time);

        int_ptr->tc_ord.gen.order = b_unpackb(buf_ptr, msg_pos,
          FSIZ(FTYPE, gen.order));
        msg_pos += FSIZ(FTYPE, gen.order);

        add_record_len = b_unpackb(buf_ptr, msg_pos,
          FSIZ(FTYPE, gen.add_record_len));
        msg_pos += FSIZ(FTYPE, gen.add_record_len);

        if (add_record_len > 0)
        {
          word start_msg_pos = msg_pos;

          /* parse the order related info */
          int_ptr->tc_ord.ordq.ordq = b_unpackb(buf_ptr, start_msg_pos,
            FSIZ(FTYPE, ordq.ordq));
          start_msg_pos += FSIZ(FTYPE, ordq.ordq);

          switch (int_ptr->tc_ord.gen.order)
          {
            case CAI_BS_CHAL_CONF_ORD:
              if (add_record_len >= 4)
              {
                int_ptr->tc_ord.chal.authbs =
                  b_unpackd( buf_ptr, start_msg_pos, FSIZ(FTYPE, chal.authbs));
                start_msg_pos += FSIZ(FTYPE, chal.authbs);

              }
              break;

            case CAI_SO_REQ_ORD:
              if (add_record_len >= 3)
              {
                int_ptr->tc_ord.so_req.service_option = b_unpackw(buf_ptr,
                  start_msg_pos, FSIZ(FTYPE, so_req.service_option));
                start_msg_pos += FSIZ(FTYPE, so_req.service_option);
              }
              break;

            case CAI_SO_RESP_ORD:
              if (add_record_len >= 3)
              {
                int_ptr->tc_ord.so_res.service_option = b_unpackw(buf_ptr,
                  start_msg_pos, FSIZ(FTYPE, so_res.service_option));
                start_msg_pos += FSIZ(FTYPE, so_res.service_option);
              }
              break;

            case CAI_PILOT_MEASURE_ORD:
              if ((add_record_len >= 3)
                  && ( (int_ptr->tc_ord.ordq.ordq >= CAI_VAL_RPT_PER) ||
                       (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
                     )
                 )
              {
                int_ptr->tc_ord.ppm.min_pilot_pwr_thresh =
                  (byte) b_unpackw(buf_ptr, start_msg_pos,
                                   FSIZ(FTYPE, ppm.min_pilot_pwr_thresh));
                start_msg_pos += FSIZ(FTYPE, ppm.min_pilot_pwr_thresh);

                int_ptr->tc_ord.ppm.min_pilot_ec_io_thresh =
                  (byte) b_unpackw(buf_ptr, start_msg_pos,
                                   FSIZ(FTYPE, ppm.min_pilot_ec_io_thresh));
                start_msg_pos += FSIZ(FTYPE, ppm.min_pilot_ec_io_thresh);

#ifdef FEATURE_IS2000_REL_A
                if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
                {
                  int_ptr->tc_ord.ppm.incl_setpt = (boolean) b_unpackw(buf_ptr,
                    start_msg_pos, FSIZ(FTYPE, ppm.incl_setpt));
                  start_msg_pos += FSIZ(FTYPE, ppm.incl_setpt);
                }
#endif /* FEATURE_IS2000_REL_A */

              }
              break;

            case CAI_RETRY_ORD:
              if (add_record_len >= 2)
              {
                int_ptr->tc_ord.retry.retry_type = b_unpackb(buf_ptr,
                  start_msg_pos, FSIZ(FTYPE, retry.retry_type));
                start_msg_pos += FSIZ(FTYPE, retry.retry_type);

                if (int_ptr->tc_ord.retry.retry_type)
                {
                  int_ptr->tc_ord.retry.retry_delay = b_unpackb(buf_ptr,
                    start_msg_pos, FSIZ(FTYPE, retry.retry_delay));
                  start_msg_pos += FSIZ(FTYPE, retry.retry_delay);
                }

              }
              else
              {
                status = CAIX_INV_LEN_S;
              }
              break;

#ifdef FEATURE_IS2000_REL_A
            case CAI_BS_REJ_ORD:
              /* -------------------------------------------------------
              ** Prior to Release C, there were no additional fields, so
              ** there's no need to do anything.
              ** ------------------------------------------------------- */
  #ifdef FEATURE_IS2000_REL_C
              if (int_ptr->tc_ord.ordq.ordq == CAI_BS_REJ_ORDER_MSG_NOT_ACCEPTED)
              {
                int_ptr->tc_ord.bsrej.reject_reason =
                b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, bs_rej.reject_reason));
                start_msg_pos += FSIZ(FTYPE, bs_rej.reject_reason);

                int_ptr->tc_ord.bsrej.rejected_msg_type =
                b_unpackb(buf_ptr, start_msg_pos,
                          FSIZ(FTYPE, bs_rej.rejected_msg_type));
                start_msg_pos += FSIZ(FTYPE, bs_rej.rejected_msg_type);

                int_ptr->tc_ord.bsrej.rejected_msg_seq =
                b_unpackb(buf_ptr, start_msg_pos,
                          FSIZ(FTYPE, bs_rej.rejected_msg_seq));
                start_msg_pos += FSIZ(FTYPE, bs_rej.rejected_msg_seq);
              }
  #endif /* FEATURE_IS2000_REL_C */
              break;
#endif /* FEATURE_IS2000_REL_A */

           default:
              /* -------------------------------------------------------
              ** Must be an order which only requires an order qualifier
              ** ------------------------------------------------------- */
              break;

          } /* end switch */

          msg_pos += add_record_len * 8;

        } /* end if (add_record_len > 0) */

#ifdef FEATURE_IS2000_REL_A
        if ((int_ptr->tc_ord.gen.order == CAI_DTMF_ORD) ||
            (int_ptr->tc_ord.gen.order == CAI_MAINT_ORD))
        {
          int_ptr->tc_ord.ordq.con_ref_incl = b_unpackb(buf_ptr, msg_pos,
            FSIZ(FTYPE, ordq.con_ref_incl));
          msg_pos += FSIZ(FTYPE, ordq.con_ref_incl);

          if (int_ptr->tc_ord.ordq.con_ref_incl)
          {
            int_ptr->tc_ord.ordq.con_ref = b_unpackb(buf_ptr, msg_pos,
              FSIZ(FTYPE, ordq.con_ref));
            msg_pos += FSIZ(FTYPE, ordq.con_ref);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

      } /* decryption successful */
    }  /* MI Validation successful */

    #undef FTYPE

  } /* end if length is ok */

  return (status);

} /* xlate_ext_tc_ord */

/*===========================================================================

FUNCTION XLATE_EXT_AUTH_CH

DESCRIPTION
  This function translates a Traffic Channel Authentication Challenge
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Authentication Challenge message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_auth_ch
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_auth_ch_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    #define FTYPE cai_auth_ch_type

    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->auth_ch.hdr );

    ext_msg_pos = FENDPOS( cai_auth_ch_type, hdr.encryption );

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_NOT_REQUIRED,
         &ext_msg_pos, buf_ptr, &int_ptr->auth_ch.hdr.msg_int,
         int_ptr->auth_ch.msg_type,
         int_ptr->auth_ch.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &ext_msg_pos, buf_ptr,
          &int_ptr->auth_ch.hdr, int_ptr->auth_ch.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */

      {
        UNPACKD_PG(auth_ch.randu, FTYPE, randu);
      }

    }

    #undef FTYPE
  }

  return (status);

} /* xlate_ext_auth_ch */

/*===========================================================================

INFORMATION RECORD PARSING FUNCTIONS

DESCRIPTION
  The functions that follow consolidate code used to parse information
  records created by IS-95B that appear on the Paging and Forward Traffic
  Channel, specifically in the Feature Notification Message and the
  Alert With Information and Flash With Information messages.

===========================================================================*/

/*===========================================================================

FUNCTION XLATE_EXT_SUB_REC

DESCRIPTION
  This function translates the Called Party Subaddress/Calling Party
  Subaddress/Redirect Subaddress/Connected Subaddress information records
  appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_sub_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte *msg_ptr,
    /* Pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
 word i;
    /* Index for looping through neighbors */
 word status;
   /* Status to be returned to calling procedure */
 word msg_pos;
   /* Position of record inside the message */
 msg_pos = *msg_pos_ptr;

 /* --------------------------------------------------------
  ** Calling Party Subaddress or Called Party Subaddress
  ** or Redirecting Subaddress or Connected Subaddress info record
  ** -------------------------------------------------------- */
   ((caii_subaddr_rec_type *) msg_ptr)->fix.extension_bit =
      b_unpackb( buf_ptr, msg_pos,
                 FSIZ( cai_subaddr_fix_type, extension_bit ));
   msg_pos += FSIZ( cai_subaddr_fix_type, extension_bit );

   ((caii_subaddr_rec_type *) msg_ptr)->fix.subadd_type =
      b_unpackb( buf_ptr, msg_pos,
                 FSIZ( cai_subaddr_fix_type, subadd_type ));
   msg_pos += FSIZ( cai_subaddr_fix_type, subadd_type );

   ((caii_subaddr_rec_type *) msg_ptr)->fix.odd_even_ind =
      b_unpackb( buf_ptr, msg_pos,
                 FSIZ( cai_subaddr_fix_type, odd_even_ind ));
   msg_pos += FSIZ( cai_subaddr_fix_type, odd_even_ind );

   msg_pos += FSIZ( cai_subaddr_fix_type, reserved );
   /* End Unpacking of Fixed Type */

   /* Begin packing Variable Type */
   ((caii_subaddr_rec_type *) msg_ptr)->fix.num_char =
      (byte) (((rec_len - sizeof( cai_subaddr_fix_type ))
                / sizeof( cai_subaddr_var_type )));

   for (i=0;
        i < ((caii_subaddr_rec_type *) msg_ptr)->fix.num_char; i++)
   {
     (( caii_subaddr_rec_type*) msg_ptr)->var[i] =
        b_unpackb( buf_ptr, msg_pos,
                   FSIZ( cai_subaddr_var_type, chari ));
     msg_pos += FSIZ( cai_subaddr_var_type, chari );
   }

   status = CAIX_DONE_S;
   *msg_pos_ptr = msg_pos;
      /* Update the position inside the message which is to be parsed */

   return ( status );
}

/* <EJECT> */
/*===========================================================================

FUNCTION XLATE_EXT_REDIR_NUM_REC

DESCRIPTION
  This function translates the Redirecting Number information record
  appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels from the external to internal format.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_redir_num_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte *msg_ptr,
    /* Pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
  word i;
     /* Index for looping through neighbors */
  word status;
    /* Status to be returned to calling procedure */
  word msg_pos;
    /* Position of record inside the message */
  word start_pos;
    /* Temporary storage for the start point of the msg */
  msg_pos = *msg_pos_ptr;


  /* --------------------------------------------------------
  ** Redirecting Number info record
  ** -------------------------------------------------------- */
  start_pos = msg_pos;

  ((caii_redir_rec_type *) msg_ptr)->fix.extension_bit1 =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_redir_fix_type, extension_bit1 ));
  msg_pos += FSIZ( cai_redir_fix_type, extension_bit1 );

  ((caii_redir_rec_type *) msg_ptr)->fix.number_type =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_redir_fix_type, number_type ));
  msg_pos += FSIZ( cai_redir_fix_type, number_type );

  ((caii_redir_rec_type *) msg_ptr)->fix.number_plan =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_redir_fix_type, number_plan ));
  msg_pos += FSIZ( cai_redir_fix_type, number_plan );

  if( !((caii_redir_rec_type *) msg_ptr)->fix.extension_bit1 )
  {
    /* ---------------------------------------------------
    ** If EXTENSION_BIT1 is 0, the following is included
    ** --------------------------------------------------- */
    ((caii_redir_rec_type *) msg_ptr)->fix.extension_bit2 =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_redir_fix_type, extension_bit2 ));
    msg_pos += FSIZ( cai_redir_fix_type, extension_bit2 );

    ((caii_redir_rec_type *) msg_ptr)->fix.pi =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_redir_fix_type, pi ));
    msg_pos += FSIZ( cai_redir_fix_type, pi );

    msg_pos += FSIZ( cai_redir_fix_type, reserved1 );

    ((caii_redir_rec_type *) msg_ptr)->fix.si =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_redir_fix_type, si ));
    msg_pos += FSIZ( cai_redir_fix_type, si );

    /* ---------------------------------------------------
    ** If EXTENSION_BIT2 is ALSO 0, the following is included
    ** --------------------------------------------------- */
    if( !((caii_redir_rec_type *) msg_ptr)->fix.extension_bit2 )
    {
      ((caii_redir_rec_type *) msg_ptr)->fix.extension_bit3 =
         b_unpackb( buf_ptr, msg_pos,
                    FSIZ( cai_redir_fix_type, extension_bit3 ));
      msg_pos += FSIZ( cai_redir_fix_type, extension_bit3 );

      msg_pos += FSIZ( cai_redir_fix_type, reserved2 );

      ((caii_redir_rec_type *) msg_ptr)->fix.redir_reason =
         b_unpackb( buf_ptr, msg_pos,
                    FSIZ( cai_redir_fix_type, redir_reason ));
      msg_pos += FSIZ( cai_redir_fix_type, redir_reason );
    }
  }

  ((caii_redir_rec_type *) msg_ptr)->fix.num_char =
     (byte) (((rec_len - (msg_pos - start_pos))
             / sizeof( cai_redir_var_type )));

  for (i=0;
     i < ((caii_redir_rec_type *) msg_ptr)->fix.num_char; i++)
  {
    (( caii_redir_rec_type*) msg_ptr)->var[i] =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_redir_var_type, chari ));
    msg_pos += FSIZ( cai_redir_var_type, chari );
  }

  status = CAIX_DONE_S;
  *msg_pos_ptr = msg_pos;
    /* Update the pointer position inside the message which is
     being parsed */

  return ( status );
}


/* <EJECT> */
/*===========================================================================

FUNCTION XLATE_EXT_PARA_ALERT_REC

DESCRIPTION
  This function translates the Parametric Alerting information record
  appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels from the external to internal format.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_para_alert_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte *msg_ptr,
    /* Pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
  word i;
     /* Index for looping through neighbors */
  word status;
    /* Status to be returned to calling procedure */
  word msg_pos;
    /* Position of record inside the message */

  msg_pos = *msg_pos_ptr;


  /* --------------------------------------
  ** Parametric Alerting Information Record
  ** -------------------------------------- */
  ((caii_para_alert_rec_type *) msg_ptr)->fix.cadence_cnt =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_para_alert_fix_type, cadence_cnt ));
  msg_pos += FSIZ( cai_para_alert_fix_type, cadence_cnt );

  ((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_para_alert_fix_type, num_groups ));

  /* Range check */
  if(((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups
        > CAII_PARA_ALERT_MAX )
  {
    ((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups =
       CAII_PARA_ALERT_MAX;
  }
  msg_pos += FSIZ( cai_para_alert_fix_type, num_groups );

  for (i=0;
       i < ((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups;
       i++)
  {
    ((caii_para_alert_rec_type *) msg_ptr)->var[i].amplitude =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, amplitude ));
    msg_pos += FSIZ( cai_para_alert_var_type, amplitude );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].freq_1 =
       b_unpackw( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, freq_1 ));
    msg_pos += FSIZ( cai_para_alert_var_type, freq_1 );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].freq_2 =
       b_unpackw( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, freq_2 ));
    msg_pos += FSIZ( cai_para_alert_var_type, freq_2 );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].on_time =
       b_unpackb( buf_ptr, msg_pos,
                 FSIZ( cai_para_alert_var_type, on_time ));
    msg_pos += FSIZ( cai_para_alert_var_type, on_time );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].off_time =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, off_time ));
    msg_pos += FSIZ( cai_para_alert_var_type, off_time );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].repeat =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, repeat ));
    msg_pos += FSIZ( cai_para_alert_var_type, repeat );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].delay =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, delay ));
    msg_pos += FSIZ( cai_para_alert_var_type, delay );
  }

#ifdef FEATURE_IS2000_REL_A
  ((caii_para_alert_rec_type *) msg_ptr)->fix.cadence_type =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_para_alert_fix1_type, cadence_type ));
#endif /* FEATURE_IS2000_REL_A */

  msg_pos += 4;     /* Increment past reserved bit at end */

  status = CAIX_DONE_S;
  *msg_pos_ptr = msg_pos;
   /* Update the pointer position inside the message which is
      being parsed */

  return ( status );
}

/*===========================================================================

FUNCTION XLATE_EXT_EXT_DISP_REC

DESCRIPTION
  This function translates the Extended Display information record
  appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels from the external to internal format.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Updates the msg_ptr to point to the first byte past the translated
  message.

===========================================================================*/
word xlate_ext_ext_disp_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte **message_ptr,
    /* Pointer to pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
 word i;
    /* Index for looping through neighbors */
 word status = CAIX_DONE_S;
   /* Status to be returned to calling procedure */
 byte *rec_ptr;
   /* Pointer to sub-record */
 word end_pos;
   /* Temporary storage for the end point of the msg */
 byte len;
   /* temp storage for length of subrecord */
 byte *msg_ptr;
   /* Temporary storage for message pointer */

 msg_ptr = *message_ptr;
 end_pos = rec_len + *msg_pos_ptr;     /* End Position of this record */

 /* ------------------------------
 ** Extended Display Info Record
 ** ------------------------------ */

 #define RTYPE caii_ext_disp_type
 #define RVTYPE caii_ext_disp_var_type
 #define FTYPE cai_ext_disp_fix_type
 #define V1TYPE cai_ext_disp_var1_type
 #define V2TYPE cai_ext_disp_var2_type

 ((RTYPE *) msg_ptr)->fix.ext_display_ind =
   b_unpackb(buf_ptr, *msg_pos_ptr, FSIZ(FTYPE , ext_display_ind));
 *msg_pos_ptr += FSIZ(FTYPE, ext_display_ind);

 ((RTYPE *) msg_ptr)->fix.display_type =
   b_unpackb(buf_ptr, *msg_pos_ptr, FSIZ(FTYPE, display_type));
 *msg_pos_ptr += FSIZ(FTYPE, display_type);

 ((RTYPE *) msg_ptr)->fix.rec_len = 0;

 /* ------------------------------------------------------
 ** Here comes the hard part. The variable part of
 ** this record can contain variable length sub-records.
 ** To avoid excessive RAM requirement, the internal
 ** format is tightly packed. Be very careful when
 ** unpack the internal format !!!
 ** ------------------------------------------------------ */
 rec_ptr = &(((RTYPE *)msg_ptr)->var[0]);

 while ((end_pos - *msg_pos_ptr) >= sizeof(V1TYPE)) /*lint !e574*/
 {
   ((RVTYPE *) rec_ptr)->display_tag =
     b_unpackb(buf_ptr, *msg_pos_ptr, FSIZ(V1TYPE, display_tag));
   *msg_pos_ptr += FSIZ(V1TYPE, display_tag);

   ((RVTYPE *) rec_ptr)->display_len = len =
     b_unpackb(buf_ptr, *msg_pos_ptr, FSIZ(V1TYPE, display_len));
   *msg_pos_ptr += FSIZ(V1TYPE, display_len);

   if ((((RVTYPE *) rec_ptr)->display_tag != CAI_EXT_DISP_BLANK) &&
       (((RVTYPE *) rec_ptr)->display_tag != CAI_EXT_DISP_SKIP))
   {
     for (i=0; (i < len) && (*msg_pos_ptr < end_pos); i++)
     {
       ((RVTYPE *) rec_ptr)->chari[i] =
         b_unpackb(buf_ptr, *msg_pos_ptr, FSIZ(V2TYPE, chari));
       *msg_pos_ptr += FSIZ(V2TYPE, chari);
     }

     /* update length (use i incase loop ended because we hit the msg end) */
     ((RVTYPE *) rec_ptr)->display_len = (byte) i;

     /* ----------------------------------------------
     ** One more record - calculate addition length
     ** ---------------------------------------------- */
      ((RTYPE *) msg_ptr)->fix.rec_len += FENDPOS(RVTYPE, display_len) +
                                          ((RVTYPE *)rec_ptr)->display_len;

     if (i != len)
     {
       /* we hit the message end before the subrecord length */
       /* something is wrong */
       status = CAIX_INV_LEN_S;
       /* Fix internal message buffer */
       rec_ptr = *message_ptr + (rec_len /8);
       break; /* stop processing this record */
     }

     /* --------------------------------------------------
     ** Update sub-record pointer in the internal format
     ** -------------------------------------------------- */
     rec_ptr += FENDPOS(RVTYPE, chari[((RVTYPE *)rec_ptr)->display_len - 1] );
   }
   else
   {
     // we are here because the display_tag was CAI_EXT_DISP_BLANK or CAI_EXT_DISP_SKIP

     // Normally, in this case, the BS will set display_len to 0, but in case it does
     // not, the following line forces it to be.
     // we make the display_len = 0 here so we don't have to perform the BLANK or SKIP
     // check any further up the chain at CM.
     ((RVTYPE *) rec_ptr)->display_len = 0;
     rec_ptr += FENDPOS(RVTYPE, display_len);
   }


 } /* end while */

 /* Now update the pointer to the output message */
 *message_ptr = rec_ptr;

 #undef RTYPE

 #undef RVTYPE
 #undef FTYPE
 #undef V1TYPE
 #undef V2TYPE

 return ( status );

}  /* xlate_ext_ext_disp_rec */


#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_EXT_MC_EXT_DISP_REC

DESCRIPTION
  This function translates the Multi-character Extended Display information
  record appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels from the external to internal format.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Updates the msg_ptr to point to the first byte past the translated
  message.

===========================================================================*/
word xlate_ext_mc_ext_disp_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte **message_ptr,
    /* Pointer to pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word msg_pos;
    /* Position of record inside the message */
  word end_pos;
    /* Temporary storage for the end point of the msg */
  word len;
    /* Length of information record in bytes */
  byte *msg_ptr;
    /* temp storage for message pointer */
  byte *int_buf_ptr;
    /* Pointer to the buffer item to be used for storage */
  byte i, j;
    /* Loop indexes */
  byte num_displays;
    /* Number pf display records */
  caii_mc_ext_disp_rec_type *disp_ptr;
  caii_mc_ext_disp_rec_info_type *recs_ptr;
  len = rec_len / 8;

  if ((len * 8) < rec_len)
  {
    len++;
  }

  if ((len - 1) > CAII_MC_EXT_DISP_BUF_SIZ)
  {
    M1X_MSG( DCP, LEGACY_ERROR,
      "Buf is too small for this MC_EXT_DISP");
    return CAIX_INV_LEN_S;
  }

  msg_ptr = *message_ptr;
  msg_pos = *msg_pos_ptr;
  end_pos = rec_len + msg_pos;     /* End Position of this record */

  ((caii_mc_ext_disp_type *) msg_ptr)->mc_ext_display_ind = b_unpackb(buf_ptr,
                                                                      msg_pos, FSIZ(cai_mc_ext_disp_fix_type, mc_ext_display_ind));
  msg_pos += FSIZ(cai_mc_ext_disp_fix_type, mc_ext_display_ind);

  ((caii_mc_ext_disp_type *) msg_ptr)->display_type = b_unpackb(buf_ptr,
                                                                msg_pos, FSIZ(cai_mc_ext_disp_fix_type, display_type));
  msg_pos += FSIZ(cai_mc_ext_disp_fix_type, display_type);

  /* -----------------------------------------
  ** Initialize number of display records to 0
  ** ----------------------------------------- */
  num_displays = 0;

  /* --------------------------------------
  ** Initialize first record pointer to buf
  ** -------------------------------------- */
  int_buf_ptr = (byte *)((caii_mc_ext_disp_type *) msg_ptr)->buf;

  while (end_pos > msg_pos)
  {
    int_buf_ptr = (byte *)ALIGN_DWORD((dword) int_buf_ptr);

    disp_ptr = ((caii_mc_ext_disp_type *) msg_ptr)->displays[num_displays] =
               (caii_mc_ext_disp_rec_type *) int_buf_ptr;

    num_displays += 1;

    disp_ptr->display_tag = b_unpackb(buf_ptr, msg_pos,
                                      FSIZ(cai_mc_ext_disp_var1_type, display_tag));
    msg_pos += FSIZ(cai_mc_ext_disp_var1_type, display_tag);

    disp_ptr->num_record = b_unpackb(buf_ptr, msg_pos,
                                     FSIZ(cai_mc_ext_disp_var1_type, num_record));
    msg_pos += FSIZ(cai_mc_ext_disp_var1_type, num_record);

    int_buf_ptr += FPOS(caii_mc_ext_disp_rec_type, recs[disp_ptr->num_record]);

    for (i=0; i<disp_ptr->num_record; i++)
    {
      int_buf_ptr = (byte *)ALIGN_DWORD((dword) int_buf_ptr);

      recs_ptr = (caii_mc_ext_disp_rec_info_type*)int_buf_ptr;

      ((caii_mc_ext_disp_rec_type*)disp_ptr)->recs[i] = recs_ptr;

      /* We only support 8 bit characters for now, not 16 bit */
      recs_ptr->display_encoding = b_unpackb(buf_ptr, msg_pos,
                                             FSIZ(cai_mc_ext_disp_var2_type, display_encoding));
      msg_pos += FSIZ(cai_mc_ext_disp_var2_type, display_encoding);

      recs_ptr->num_fields = b_unpackb(buf_ptr, msg_pos,
                                       FSIZ(cai_mc_ext_disp_var2_type, num_fields));
      msg_pos += FSIZ(cai_mc_ext_disp_var2_type, num_fields);

      for (j=0; j<recs_ptr->num_fields; j++)
      {
        recs_ptr->chari[j] = b_unpackb(buf_ptr, msg_pos,
                                       FSIZ(cai_mc_ext_disp_var3_type, chari));
        msg_pos += FSIZ(cai_mc_ext_disp_var3_type, chari);

      }

      int_buf_ptr += FPOS(caii_mc_ext_disp_rec_info_type, chari[recs_ptr->num_fields]);
    }
  }

  ((caii_mc_ext_disp_type *) msg_ptr)->num_displays = num_displays;

  /* Add the reserved bits to msg_pos */
  msg_pos = end_pos;

  /* Update the pointer position inside the message which is
     being parsed */
  *msg_pos_ptr = msg_pos;

  /* now update the pointer to the output message */
  *message_ptr = int_buf_ptr;

  return status;
}
#endif /* FEATURE_IS2000_REL_A */


#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_EXT_ENH_MC_EXT_DISP_REC

DESCRIPTION
  This function translates the Enhanced Multi-character Extended Display information
  record appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels from the external to internal format.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Updates the msg_ptr to point to the first byte past the translated
  message.

===========================================================================*/
word xlate_ext_enh_mc_ext_disp_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte **message_ptr,
    /* Pointer to pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word msg_pos, start_msg_pos;
    /* Position of record inside the message */
  word len;
    /* Length of information record in bytes */
  byte *int_buf_ptr;
    /* Pointer to the buffer item to be used for storage */
  byte i, j, k;
    /* Loop indexes */
  caii_enh_mc_ext_disp_rec_type *disp_ptr;
  caii_enh_mc_ext_disp_rec_info_type *recs_ptr;
  byte record_length;
  word rec_start_pos;

  len = rec_len / 8;

  if ((len * 8) < rec_len)
  {
    len++;
  }

  if ((len - 1) > CAII_ENH_MC_EXT_DISP_BUF_SIZ)
  {
    M1X_MSG( DCP, LEGACY_ERROR,
      "Buf is too small for this ENH_MC_EXT_DISP");
    return CAIX_INV_LEN_S;
  }

  msg_pos = *msg_pos_ptr;
  start_msg_pos = msg_pos;

  ((caii_enh_mc_ext_disp_type*)*message_ptr)->display_type = b_unpackb(buf_ptr,
                                                                       msg_pos, FSIZ(cai_enh_mc_ext_disp_fix_type, display_type));
  msg_pos += FSIZ(cai_enh_mc_ext_disp_fix_type, display_type);

  ((caii_enh_mc_ext_disp_type*)*message_ptr)->num_displays = b_unpackb(buf_ptr,
                                                                       msg_pos, FSIZ(cai_enh_mc_ext_disp_fix_type, num_displays));
  msg_pos += FSIZ(cai_enh_mc_ext_disp_fix_type, num_displays);

  /* --------------------------------------
  ** Initialize first record pointer to buf
  ** -------------------------------------- */
  int_buf_ptr = (byte *)(((caii_enh_mc_ext_disp_type*)*message_ptr)->buf);

  for (i=0; i<(((caii_enh_mc_ext_disp_type*)*message_ptr)->num_displays + 1); i++)
  {
    int_buf_ptr = (byte *)ALIGN_DWORD((dword) int_buf_ptr);

    disp_ptr = ((caii_enh_mc_ext_disp_type*)*message_ptr)->displays[i] = (caii_enh_mc_ext_disp_rec_type *)int_buf_ptr;

    disp_ptr->display_tag = b_unpackb(buf_ptr, msg_pos,
                                      FSIZ(cai_enh_mc_ext_disp_var1_type, display_tag));
    msg_pos += FSIZ(cai_enh_mc_ext_disp_var1_type, display_tag);

    disp_ptr->num_record = b_unpackb(buf_ptr, msg_pos,
                                     FSIZ(cai_enh_mc_ext_disp_var1_type, num_record));
    msg_pos += FSIZ(cai_enh_mc_ext_disp_var1_type, num_record);

    int_buf_ptr += FPOS(caii_enh_mc_ext_disp_rec_type, recs[disp_ptr->num_record]);

    if ((disp_ptr->display_tag != CAI_EXT_DISP_BLANK) &&
        (disp_ptr->display_tag != CAI_EXT_DISP_SKIP))
    {

      for (j=0; j<disp_ptr->num_record; j++)
      {
        int_buf_ptr = (byte *)ALIGN_DWORD((dword) int_buf_ptr);

        recs_ptr = (caii_enh_mc_ext_disp_rec_info_type*)int_buf_ptr;

        ((caii_enh_mc_ext_disp_rec_type*)disp_ptr)->recs[j] = recs_ptr;

        rec_start_pos = msg_pos;
        record_length = b_unpackb(buf_ptr, msg_pos,
                                  FSIZ(cai_enh_mc_ext_disp_var2_type, record_length));
        msg_pos += FSIZ(cai_enh_mc_ext_disp_var2_type, record_length);

        /* We only support 8 bit characters for now, not 16 bit */
        recs_ptr->display_encoding = b_unpackb(buf_ptr, msg_pos,
                                               FSIZ(cai_enh_mc_ext_disp_var2_type, display_encoding));
        msg_pos += FSIZ(cai_enh_mc_ext_disp_var2_type, display_encoding);

        recs_ptr->num_fields = b_unpackb(buf_ptr, msg_pos,
                                         FSIZ(cai_enh_mc_ext_disp_var2_type, num_fields));
        msg_pos += FSIZ(cai_enh_mc_ext_disp_var2_type, num_fields);

        for (k=0; k<recs_ptr->num_fields; k++)
        {
          recs_ptr->chari[k] = b_unpackb(buf_ptr, msg_pos,
                                         FSIZ(cai_enh_mc_ext_disp_var3_type, chari));
          msg_pos += FSIZ(cai_enh_mc_ext_disp_var3_type, chari);
        }

        int_buf_ptr += FPOS(caii_enh_mc_ext_disp_rec_info_type, chari[recs_ptr->num_fields]);


        msg_pos = rec_start_pos + record_length*8;
      }

    }

  }

  /* Add the reserve bits to msg_pos */
  msg_pos += (rec_len - msg_pos + start_msg_pos);

  /* Update the pointer position inside the message which is
     being parsed */
  *msg_pos_ptr = msg_pos;

  /* now update the pointer to the output message */
  *message_ptr = int_buf_ptr;

  return status;
}
#endif /* FEATURE_IS2000_REL_C */

/*===========================================================================

FUNCTION XLATE_EXT_INFO

DESCRIPTION
  This function translates a Traffic Channel Alert With Information
  or Flash With Information Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Alert With Information or Flash With
  Information message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_info
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  byte i;
    /* Index */
  word msg_pos;
    /* Position of record in message */
  byte *msg_ptr;
    /* Pointer to position inside internal message type */
  byte rec_type;
    /* Temporary storage for record type */
  word rec_len;
    /* Temporary storage for record length */
  word min_len;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( cai_alert_fix_type )
#ifdef FEATURE_IS2000_REL_A
            - FSIZ( cai_tc_hdr_ext_enc_type, sdu_encrypt_mode )
            - FSIZ( cai_tc_hdr_ext_enc_type, enc_seq )
#endif /* FEATURE_IS2000_REL_A */
     )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> Convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->alert.hdr );

    msg_pos = FENDPOS( cai_alert_fix_type, hdr.encryption );

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr,
         &int_ptr->alert.hdr.msg_int,int_ptr->alert.msg_type,
         int_ptr->alert.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->alert.hdr, int_ptr->alert.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        /* Initialize number of records to 0 */
        int_ptr->alert.num_recs = 0;
        msg_ptr = (byte*)ALIGN_DWORD((dword)(&int_ptr->alert.recs[0]));

        min_len = FSIZ(cai_rec_hdr_type, record_type) +
                  FSIZ(cai_rec_hdr_type, record_len);

#ifdef FEATURE_IS2000_REL_C
        if (int_ptr->alert.hdr.msg_int.maci_incl)
        {
          min_len += FSIZ(cai_msg_int_type, maci);
        }
#endif /* FEATURE_IS2000_REL_C */

        while ((len > msg_pos) && ((len - msg_pos) >= min_len) &&
               (status == CAIX_DONE_S))
        {
          word start_msg_pos;

          /* ------------------------------
          ** Unpack message type and length
          ** ------------------------------ */
          ((caii_rec_hdr_type *) msg_ptr)->record_type = rec_type =
            b_unpackb( buf_ptr, msg_pos, FSIZ(cai_rec_hdr_type, record_type));
          msg_pos += FSIZ(cai_rec_hdr_type, record_type);

          /* -------------------------
          ** Get record length in bits
          ** ------------------------- */
          rec_len = b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_rec_hdr_type, record_len)) * 8;
          msg_pos += FSIZ(cai_rec_hdr_type, record_len);

          start_msg_pos = msg_pos;

          if ((rec_len + msg_pos) > len)
          {
            /* ---------------------
            ** Record length invalid
            ** --------------------- */
            status = CAIX_INV_LEN_S;
            break;
          }

          else
          {
            /* --------------------------------------
            ** Attempt to parse information record(s)
            ** -------------------------------------- */
            switch (rec_type)
            {
              case CAI_DISPLAY_REC:
                /* --------------------------
                ** Display Information Record
                ** -------------------------- */
                ((caii_display_rec_type *) msg_ptr)->fix.num_char =
                   (byte) (rec_len / sizeof(cai_display_rec_var_type));

                for (i=0; i < ((caii_display_rec_type *) msg_ptr)->fix.num_char;
                     i++)
                {
                  ((caii_display_rec_type *) msg_ptr)->var[i] =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_display_rec_var_type, chari));
                  start_msg_pos += FSIZ(cai_display_rec_var_type, chari);
                }

                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_display_rec_type,
                  var[((caii_display_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_CALLED_REC:
                /* --------------------------------------
                ** Called Party Number Information Record
                ** -------------------------------------- */
                ((caii_called_rec_type *) msg_ptr)->fix.number_type =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_called_fix_type, number_type));
                start_msg_pos += FSIZ(cai_called_fix_type, number_type);

                ((caii_called_rec_type *) msg_ptr)->fix.number_plan =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_called_fix_type, number_plan));
                start_msg_pos += FSIZ(cai_called_fix_type, number_plan);

                ((caii_called_rec_type *) msg_ptr)->fix.num_char =
                  (byte) ((rec_len - sizeof(cai_called_fix_type)) /
                  sizeof(cai_called_var_type));

                for (i=0; i < ((caii_called_rec_type *) msg_ptr)->fix.num_char;
                     i++)
                {
                  ((caii_called_rec_type *) msg_ptr)->var[i] =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_called_var_type, chari));
                  start_msg_pos += FSIZ(cai_called_var_type, chari);
                }

                /* ----------------------------------------------------------
                ** Increment internal message pointer to point to next record
                ** ---------------------------------------------------------- */
                msg_ptr += FENDPOS(caii_called_rec_type,
                  var[((caii_called_rec_type *) msg_ptr)->fix.num_char - 1] );

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_CALLING_REC:
              case CAI_CONNECT_REC:
                /* -----------------------------------------------------------
                ** Calling Party Number or Connected Number Information Record
                ** ----------------------------------------------------------- */
                ((caii_calling_rec_type *) msg_ptr)->fix.number_type =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_calling_fix_type, number_type));
                start_msg_pos += FSIZ(cai_calling_fix_type, number_type);

                ((caii_calling_rec_type *) msg_ptr)->fix.number_plan =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_calling_fix_type, number_plan));
                start_msg_pos += FSIZ(cai_calling_fix_type, number_plan);

                ((caii_calling_rec_type *) msg_ptr)->fix.pi =
                  b_unpackb(buf_ptr, start_msg_pos, FSIZ(cai_calling_fix_type, pi));
                start_msg_pos += FSIZ(cai_calling_fix_type, pi);

                ((caii_calling_rec_type *) msg_ptr)->fix.si =
                  b_unpackb(buf_ptr, start_msg_pos, FSIZ(cai_calling_fix_type, si));
                start_msg_pos += FSIZ(cai_calling_fix_type, si);

                ((caii_calling_rec_type *) msg_ptr)->fix.num_char =
                  (byte) ((rec_len - sizeof(cai_calling_fix_type)) /
                  sizeof(cai_calling_var_type));

                for (i=0; i < ((caii_calling_rec_type *) msg_ptr)->fix.num_char; i++)
                {
                  ((caii_calling_rec_type *) msg_ptr)->var[i] =
                    b_unpackb(buf_ptr, start_msg_pos,
                            FSIZ(cai_calling_var_type, chari));
                  start_msg_pos += FSIZ(cai_calling_var_type, chari);
                }

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += FENDPOS(caii_calling_rec_type,
                  var[((caii_calling_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_SIGNAL_REC:
                /* -------------------------
                ** Signal Information Record
                ** ------------------------- */
                ((caii_signal_rec_type *) msg_ptr)->signal_type =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_signal_rec_type, signal_type));
                start_msg_pos += FSIZ(cai_signal_rec_type, signal_type);

                ((caii_signal_rec_type *) msg_ptr)->alert_pitch =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_signal_rec_type, alert_pitch));
                start_msg_pos += FSIZ(cai_signal_rec_type, alert_pitch);

                ((caii_signal_rec_type *) msg_ptr)->signal =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_signal_rec_type, signal));
                start_msg_pos += FSIZ(cai_signal_rec_type, signal) +
                  FSIZ(cai_signal_rec_type, reserved);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_signal_rec_type);

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_MSG_WAITING_REC:
                /* ----------------------------------
                ** Message Waiting Information Record
                ** ---------------------------------- */
                ((caii_msg_waiting_rec_type *) msg_ptr)->msg_count =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_msg_waiting_rec_type, msg_count));
                start_msg_pos += FSIZ(cai_msg_waiting_rec_type, msg_count);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_msg_waiting_rec_type);

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_CALLED_SUB_REC:
              case CAI_CALLING_SUB_REC:
              case CAI_REDIR_SUB_REC:
              case CAI_CONNECT_SUB_REC:
                /* --------------------------------------------------------
                ** Calling Party Subaddress or Called Party Subaddress
                ** or Redirecting Subaddress or Connected Subaddress info
                ** record
                ** -------------------------------------------------------- */
                /* Unpack Information Record */
                status = xlate_ext_sub_rec(rec_len, buf_ptr, msg_ptr,
                  &start_msg_pos);

                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_subaddr_rec_type,
                  var[((caii_subaddr_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_REDIR_NUM_REC:
                /* --------------------------------------------------------
                ** Redirecting Number Information Record
                ** -------------------------------------------------------- */
                /* Unpack Information Record */
                status = xlate_ext_redir_num_rec(rec_len, buf_ptr, msg_ptr,
                  &start_msg_pos);

                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_redir_rec_type,
                  var[((caii_redir_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_EXT_DISPLAY_REC:
                /* ------------------------------
                ** Extended Display Info Record
                ** ------------------------------ */
                status = xlate_ext_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
                  &start_msg_pos);

                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_METER_PULSES_REC:
                /* --------------------------------
                ** Meter Pulses Information Record
                ** -------------------------------- */
                ((caii_meter_pulses_rec_type *) msg_ptr)->pulse_freq =
                  b_unpackw(buf_ptr, start_msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, pulse_freq));
                start_msg_pos += FSIZ(cai_meter_pulses_rec_type, pulse_freq);

                ((caii_meter_pulses_rec_type *) msg_ptr)->on_time =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, on_time));
                start_msg_pos += FSIZ(cai_meter_pulses_rec_type, on_time);

                ((caii_meter_pulses_rec_type *) msg_ptr)->off_time =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, off_time));
                start_msg_pos += FSIZ(cai_meter_pulses_rec_type, off_time);

                ((caii_meter_pulses_rec_type *) msg_ptr)->pulse_cnt =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, pulse_cnt));
                start_msg_pos += FSIZ(cai_meter_pulses_rec_type, pulse_cnt);

                /* Increment past reserved bit at end */
                start_msg_pos += FSIZ(cai_meter_pulses_rec_type, reserved);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_meter_pulses_rec_type); /*lint !e662 */

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_PARA_ALERT_REC:
                /* --------------------------------------
                ** Parametric Alerting Information Record
                ** -------------------------------------- */
                status = xlate_ext_para_alert_rec(rec_len, buf_ptr, msg_ptr,
                  &start_msg_pos);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                if (((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups == 0)
                {
                  msg_ptr += FENDPOS(caii_para_alert_rec_type,fix);
                }
                else
                {
                  msg_ptr += FENDPOS( caii_para_alert_rec_type,
                   var[((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups - 1] );
                }

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_LINE_CTRL_REC:
                /* -------------------------------------
                ** Line Control Information Record
                ** ------------------------------------- */
                ((caii_line_ctrl_rec_type *) msg_ptr)->pol_inc =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_line_ctrl_rec_type, pol_inc));
                start_msg_pos += FSIZ(cai_line_ctrl_rec_type, pol_inc);

                if (((caii_line_ctrl_rec_type *) msg_ptr)->pol_inc)
                {
                  ((caii_line_ctrl_rec_type *) msg_ptr)->tgl_mod =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, tgl_mod));
                  start_msg_pos += FSIZ(cai_line_ctrl_rec_type, tgl_mod);

                  ((caii_line_ctrl_rec_type *) msg_ptr)->rev_pol =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, rev_pol));
                  start_msg_pos += FSIZ(cai_line_ctrl_rec_type, rev_pol);

                  ((caii_line_ctrl_rec_type *) msg_ptr)->pow_dtm =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, pow_dtm));
                  start_msg_pos += FSIZ( cai_line_ctrl_rec_type, pow_dtm);
                }
                else
                {
                  ((caii_line_ctrl_rec_type *) msg_ptr)->pow_dtm =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, pow_dtm));
                  start_msg_pos += FSIZ(cai_line_ctrl_rec_type, pow_dtm);
                }

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_line_ctrl_rec_type); /*lint !e662 */

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_USER_ZONE_UPDATE_REC:
                ((caii_user_zone_update_type *) msg_ptr)->uzid =
                  b_unpackw(buf_ptr, start_msg_pos,
                  FSIZ(cai_user_zone_update_type, uzid));
                start_msg_pos += FSIZ(cai_user_zone_update_type, uzid);

                msg_ptr += FENDPOS( caii_user_zone_update_type,uzid );

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_USER_ZONE_REJECT_REC:
                ((caii_user_zone_reject_type *) msg_ptr)->reject_uzid =
                  b_unpackw(buf_ptr, start_msg_pos,
                  FSIZ(cai_user_zone_reject_type, reject_uzid));
                start_msg_pos += FSIZ(cai_user_zone_reject_type, reject_uzid);

                ((caii_user_zone_reject_type *) msg_ptr)->reject_action_indi =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_user_zone_reject_type, reject_action_indi));
                start_msg_pos += FSIZ(cai_user_zone_reject_type, reject_action_indi);

                ((caii_user_zone_reject_type *) msg_ptr)->uzid_assign_incl =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_user_zone_reject_type, uzid_assign_incl));
                start_msg_pos += FSIZ(cai_user_zone_reject_type, uzid_assign_incl);

                if (((caii_user_zone_reject_type *) msg_ptr)->uzid_assign_incl)
                {
                  ((caii_user_zone_reject_type *) msg_ptr)->assign_uzid =
                    b_unpackw(buf_ptr, start_msg_pos,
                    FSIZ(cai_user_zone_reject_type, assign_uzid));
                  start_msg_pos += FSIZ(cai_user_zone_reject_type, assign_uzid);
                  msg_ptr += FENDPOS( caii_user_zone_reject_type, assign_uzid );
                }
                else
                {
                  msg_ptr += FENDPOS(caii_user_zone_reject_type,
                    uzid_assign_incl );
                }

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

#ifdef FEATURE_IS2000_REL_A
              case CAI_MC_EXT_DISP_REC:
                /* ---------------------------------------------
                ** Multi-character Extended Display Info Record
                ** --------------------------------------------- */
                status = xlate_ext_mc_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
                  &start_msg_pos);

                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */
                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;

              case CAI_CALL_WAIT_IND_REC:
                /* ----------------------------------
                ** Call Waiting Indicator Record
                ** ---------------------------------- */
                ((caii_call_waiting_ind_type *) msg_ptr)->call_waiting_ind =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_call_wait_type, call_waiting_ind));
                start_msg_pos += (FSIZ(cai_call_wait_type, call_waiting_ind) +
                  FSIZ(cai_call_wait_type, reserved));

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_call_waiting_ind_type);

                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
              case CAI_ENH_MC_EXT_DISP_REC:
                /* ---------------------------------------------
                ** Enhanced Multi-character Extended Display Info Record
                ** --------------------------------------------- */
                status = xlate_ext_enh_mc_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
                  &start_msg_pos);

                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */
                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
                break;
#endif /* FEATURE_IS2000_REL_C */

              case CAI_NTL_SUP_SVC_REC:
              /* If JCDMA is not defined in the passport mode then treat
               * as if this code is not present. So slip into default case */
              if (mcc_passport_mode_is_jcdma() || mcc_is_jcdma_supported())
              {
                /* ------------------------------------------
                ** Record for National Supplementary Services
                ** ------------------------------------------ */

                /* Determine the country-specific record type */

                ((caii_ntl_sup_svc_type *) msg_ptr)->mcc =
                   b_unpackw( buf_ptr, start_msg_pos,
                   FSIZ(cai_ntl_sup_svc_type, mcc));

                ((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype =
                  b_unpackb(buf_ptr, start_msg_pos + FSIZ(cai_ntl_sup_svc_type, mcc),
                  FSIZ(cai_ntl_sup_svc_type, record_subtype));

                if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc == CAI_T53_COUNTRY_CODE) &&
                    (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype == CAI_CLIR_REC))
                {
                  /* -----------------------
                  ** CLIR Information Record
                  ** ----------------------- */
                  start_msg_pos += FSIZ(cai_ntl_sup_svc_type, mcc) +
                    FSIZ(cai_ntl_sup_svc_type, record_subtype);

                  ((caii_clir_sup_svc_type *) msg_ptr)->cause =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_clir_sup_svc_type, cause));
                  start_msg_pos += FSIZ( cai_clir_sup_svc_type, cause);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_clir_sup_svc_type);

                  msg_pos += rec_len;
                  int_ptr->alert.num_recs++;
                }
                else if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc ==
                          CAI_T53_COUNTRY_CODE) &&
                        (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype ==
                          CAI_RELEASE_REC))
                {
                  /* --------------------------
                  ** Release Information Record
                  ** -------------------------- */
                  start_msg_pos += FSIZ(cai_release_sup_svc_type, mcc) +
                    FSIZ(cai_release_sup_svc_type, record_subtype);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_release_sup_svc_type);

                  msg_pos += rec_len;
                  int_ptr->alert.num_recs++;
                }
                else if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc ==
                          CAI_T53_COUNTRY_CODE) &&
                        (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype ==
                          CAI_AUDIO_CONTROL_REC))
                {
                  /* --------------------------------
                  ** Audio Control Information Record
                  ** -------------------------------- */
                  start_msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, mcc) +
                    FSIZ(cai_audio_ctl_sup_svc_type, record_subtype);

                  ((caii_audio_ctl_sup_svc_type *) msg_ptr)->up_link =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_audio_ctl_sup_svc_type, up_link));
                  start_msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, up_link);

                  ((caii_audio_ctl_sup_svc_type *) msg_ptr)->down_link =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_audio_ctl_sup_svc_type, down_link));
                  start_msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, down_link) +
                    FSIZ(cai_audio_ctl_sup_svc_type, reserved);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_audio_ctl_sup_svc_type);

                  msg_pos += rec_len;
                  int_ptr->alert.num_recs++;
                }
                else
                {
                  /* ------------------------------------
                  ** Unknown country-specific record type
                  ** ------------------------------------ */
                  msg_ptr += sizeof( caii_ntl_sup_svc_type );
                  msg_pos += rec_len;
                  int_ptr->alert.num_recs++;
                }
              }
              else
              {
                /* ------------------------------------
                ** Unknown country-specific record type
                ** ------------------------------------ */
                msg_ptr += sizeof( caii_ntl_sup_svc_type );
                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
              }
              break;
              /* This is an intentional fall through. If feature is not defined
                 or if the mode is not JCDMA the code will fall through into
                 default */
              /*lint -fallthrough */
              default:
                /* -------------------
                ** Unknown record type
                ** ------------------- */
                msg_ptr += sizeof( caii_rec_hdr_type );
                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
            } /* end switch (rec_type) */

            msg_ptr = (byte*)ALIGN_DWORD(((dword) msg_ptr));
          } /* end if ((rec_len + msg_pos) > len) */

        } /* end of while */
      }
    }
  } /* else */

  return (status);

} /* xlate_ext_info */

/*===========================================================================

FUNCTION XLATE_EXT_TC_TMSI

DESCRIPTION
  This function translates a Forward Traffic Channel TMSI Assignment Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the TMSI Assignment message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_tmsi
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos = 0;
    /* Position in message relative to start of buf_ptr */

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_ftc_tmsi_asgn_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < CAI_FTC_TMSI_MIN)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_tmsi.hdr);

    msg_pos = FENDPOS(cai_ftc_tmsi_asgn_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tc_tmsi.hdr.msg_int,
         int_ptr->tc_tmsi.msg_type,
         int_ptr->tc_tmsi.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->tc_tmsi.hdr, int_ptr->tc_tmsi.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->tc_tmsi.data.zone_len = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, tmsi_zone_len));
        msg_pos += FSIZ(MTYPE, tmsi_zone_len);

        qw_set(int_ptr->tc_tmsi.data.info.tmsi_zone, 0L, 0L);
        b_unpackq(buf_ptr, msg_pos, (int_ptr->tc_tmsi.data.zone_len << 3),
          int_ptr->tc_tmsi.data.info.tmsi_zone);
        msg_pos += (int_ptr->tc_tmsi.data.zone_len << 3);

        int_ptr->tc_tmsi.data.info.tmsi_code =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, tmsi_code));
        msg_pos += FSIZ( MTYPE, tmsi_code);

        int_ptr->tc_tmsi.data.exp_time  =
          b_unpackd(buf_ptr, msg_pos, FSIZ( MTYPE, tmsi_exp_time));
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_tmsi */

/*===========================================================================

FUNCTION XLATE_EXT_TC_BURST

DESCRIPTION
  This function translates a Forward Traffic Channel Data Burst Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Data Burst message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_burst
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through characters */
  word msg_pos = 0;
  /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_fwd_tc_burst_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( cai_burst_tc_fix_type ))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_burst.hdr);

    msg_pos = FENDPOS(cai_burst_tc_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len,
                                                CAIX_TC,
                                                0,
                                                CAIX_MACI_REQUIRED,
                                                &msg_pos,
                                                buf_ptr,
                                                &int_ptr->tc_burst.hdr.msg_int,
                                                int_ptr->tc_burst.msg_type,
                                                int_ptr->tc_burst.hdr.ack_req
                                                )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->tc_burst.hdr, int_ptr->tc_burst.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->tc_burst.msg_number = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, fix.msg_number));
        msg_pos += FSIZ(MTYPE, fix.msg_number);

        int_ptr->tc_burst.burst_type = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, fix.burst_type));
        msg_pos += FSIZ(MTYPE, fix.burst_type);

        int_ptr->tc_burst.num_msgs = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, fix.num_msgs));
        msg_pos += FSIZ(MTYPE, fix.num_msgs);

        int_ptr->tc_burst.num_fields = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, fix.num_fields));
        msg_pos += FSIZ(MTYPE, fix.num_fields);

        for (i=0; i < int_ptr->tc_burst.num_fields; i++)
        {
          int_ptr->tc_burst.chari[i] = b_unpackb(buf_ptr, msg_pos,
            FSIZ(MTYPE, var[i]));
          msg_pos += FSIZ(MTYPE, var[i]);
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_burst */

/*===========================================================================

FUNCTION XLATE_EXT_FM_HO

DESCRIPTION
  This function translates a Traffic Channel Analog Handoff Direction
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Analog Handoff Direction type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_fm_ho
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos = 0;
  /* Position in message relative to start of buf_ptr */
  word min_len;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_fm_ho_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (sizeof(cai_fm_ho_type) -
               FSIZ(cai_fm_ho_type, an_chan_type) -
               FSIZ(cai_fm_ho_type, dscc_msb) -
               FSIZ(cai_fm_ho_type, band_class))
#ifdef FEATURE_IS2000_REL_A
             - FSIZ(MTYPE, con_ref_incl) - FSIZ(MTYPE, con_ref)
#endif /* FEATURE_IS2000_REL_A */
     )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->fm_ho.hdr );

    msg_pos = FENDPOS(cai_fm_ho_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->fm_ho.hdr.msg_int,
         int_ptr->fm_ho.msg_type,
         int_ptr->fm_ho.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->fm_ho.hdr, int_ptr->fm_ho.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->fm_ho.use_time =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
        msg_pos += FSIZ(MTYPE, use_time);

        int_ptr->fm_ho.action_time =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
        msg_pos += FSIZ(MTYPE, action_time);

        int_ptr->fm_ho.sid = b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, sid));
        msg_pos += FSIZ(MTYPE, sid);

        int_ptr->fm_ho.vmac = b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, vmac));
        msg_pos += FSIZ(MTYPE, vmac);

        int_ptr->fm_ho.analog_chan =
          b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, analog_chan));
        msg_pos += FSIZ(MTYPE, analog_chan);

        int_ptr->fm_ho.scc = b_unpackb(buf_ptr, msg_pos, FSIZ( MTYPE, scc));
        msg_pos += FSIZ(MTYPE, scc);

        int_ptr->fm_ho.mem = b_unpackb(buf_ptr, msg_pos, FSIZ( MTYPE, mem));
        msg_pos += FSIZ(MTYPE, mem);

        min_len = FSIZ(MTYPE, an_chan_type) + FSIZ(MTYPE, dscc_msb) +
                  FSIZ(MTYPE, band_class);

#ifdef FEATURE_IS2000_REL_C
        if (int_ptr->fm_ho.hdr.msg_int.maci_incl)
        {
          min_len += FSIZ(cai_msg_int_type, maci);
        }
#endif /* FEATURE_IS2000_REL_C */

        if ((len - msg_pos) >= min_len)
        {
          int_ptr->fm_ho.an_chan_type =
            b_unpackb(buf_ptr, msg_pos, FSIZ( MTYPE, an_chan_type));
          msg_pos += FSIZ(MTYPE, an_chan_type);

          int_ptr->fm_ho.dscc_msb =
            b_unpackb(buf_ptr, msg_pos, FSIZ( MTYPE, dscc_msb));
          msg_pos += FSIZ(MTYPE, dscc_msb);

          int_ptr->fm_ho.band_class =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, band_class));
          msg_pos += FSIZ(MTYPE, band_class);

          if(mcc_passport_mode_is_jcdma())
          {
            int_ptr->fm_ho.dtx          = b_unpackb( PARAMS( dtx ));
          }
        }

#ifdef FEATURE_IS2000_REL_A
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
        {
          int_ptr->fm_ho.con_ref_incl =
            b_unpackb(buf_ptr, msg_pos, FSIZ( MTYPE, con_ref_incl));
          msg_pos += FSIZ(MTYPE, con_ref_incl);

          if (int_ptr->fm_ho.con_ref_incl)
          {
            int_ptr->fm_ho.con_ref =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref));
            msg_pos += FSIZ(MTYPE, con_ref);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_fm_ho */

/*===========================================================================

FUNCTION XLATE_EXT_TC_SYS_PARM

DESCRIPTION
  This function translates a Traffic Channel In-Traffic System Parameter
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the In-Traffic System Parameter type.

RETURN VALUE
  Errors that were encountered while translating the message.
  p_rev field will be set to zero to indicate an pre IS-95B format.
  A non-zero p_rev indicates an IS-95B and newer format.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_sys_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word buf_pos;
    /* Location of next bit in buffer to be processed */

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_tc_sysparm_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** ( for IS-95B format, reserved bits are 4 )
  ** -------------------------------------------- */
  if (len < FENDPOS(MTYPE, nghbr_max_age ) + 4)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */

    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_sys.hdr);

    buf_pos = FENDPOS(cai_tc_sysparm_type, hdr.encryption);

    #ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &buf_pos, buf_ptr, &int_ptr->tc_sys.hdr.msg_int,
         int_ptr->tc_sys.msg_type,
         int_ptr->tc_sys.hdr.ack_req
         )) != CAIX_DONE_S)
    {
      return status;
    }
    #endif /* FEATURE_IS2000_REL_C */

    #ifdef FEATURE_IS2000_REL_A
    if ((status = xlate_ext_ext_enc_tc(&len, &buf_pos, buf_ptr,
               &int_ptr->tc_sys.hdr, int_ptr->tc_sys.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
    #endif /* FEATURE_IS2000_REL_A */

    int_ptr->tc_sys.sid = b_unpackw(buf_ptr, buf_pos, FSIZ(MTYPE, sid));
    buf_pos += FSIZ(MTYPE, sid);

    int_ptr->tc_sys.nid = b_unpackw(buf_ptr, buf_pos, FSIZ( MTYPE, nid));
    buf_pos += FSIZ(MTYPE, nid);

    int_ptr->tc_sys.srch_win_a = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, srch_win_a));
    buf_pos += FSIZ(MTYPE, srch_win_a);

    int_ptr->tc_sys.srch_win_n = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, srch_win_n));
    buf_pos += FSIZ(MTYPE, srch_win_n);

    int_ptr->tc_sys.srch_win_r = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, srch_win_r));
    buf_pos += FSIZ(MTYPE, srch_win_r);

    int_ptr->tc_sys.t_add = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, t_add));
    buf_pos += FSIZ(MTYPE, t_add);

    int_ptr->tc_sys.t_drop = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, t_drop));
    buf_pos += FSIZ(MTYPE, t_drop);

    int_ptr->tc_sys.t_comp = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, t_comp));
    buf_pos += FSIZ(MTYPE, t_comp);

    int_ptr->tc_sys.t_tdrop = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, t_tdrop));
    buf_pos += FSIZ(MTYPE, t_tdrop);

    int_ptr->tc_sys.nghbr_max_age = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, nghbr_max_age));
    buf_pos += FSIZ(MTYPE, nghbr_max_age);

    /* 95b functionality is already supported in rel a */
    if (len-buf_pos < FSIZ(cai_tc_sysparm_type, p_rev) +
        FSIZ(cai_tc_sysparm_type, soft_slope)+
        FSIZ(cai_tc_sysparm_type, add_intercept)+
        FSIZ(cai_tc_sysparm_type, drop_intercept)+
        FSIZ(cai_tc_sysparm_type, packet_zone_id)+
        FSIZ(cai_tc_sysparm_type, extension))
    {
      int_ptr->tc_sys.p_rev = CAIX_P_REV_UNKNOWN;
    }
    else
    {
      int_ptr->tc_sys.p_rev = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, p_rev ));
      buf_pos += FSIZ( MTYPE, p_rev );

      int_ptr->tc_sys.soft_slope = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, soft_slope ));
      buf_pos += FSIZ( MTYPE, soft_slope );

      int_ptr->tc_sys.add_intercept = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, add_intercept ));
      buf_pos += FSIZ( MTYPE, add_intercept );

      int_ptr->tc_sys.drop_intercept = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, drop_intercept ));
      buf_pos += FSIZ( MTYPE, drop_intercept );

      int_ptr->tc_sys.packet_zone_id = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, packet_zone_id ));
      buf_pos += FSIZ( MTYPE, packet_zone_id );

      int_ptr->tc_sys.extension = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, extension ));
      buf_pos += FSIZ( MTYPE, extension );

      if (int_ptr->tc_sys.extension)
      {
        int_ptr->tc_sys.t_mulchan =
          b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, t_mulchan));
        buf_pos += FSIZ(MTYPE, t_mulchan);

        int_ptr->tc_sys.begin_preamble =
          b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, begin_preamble));
        buf_pos += FSIZ(MTYPE, begin_preamble);

        int_ptr->tc_sys.resume_preamble =
          b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, resume_preamble));
        buf_pos += FSIZ(MTYPE, resume_preamble);
      }

      if (int_ptr->tc_sys.p_rev >= CAIX_P_REV_IS2000)
      {
        int_ptr->tc_sys.t_slotted_incl = b_unpackb(buf_ptr, buf_pos,
               FSIZ(cai_tc_sysparm_is2000_type, t_slotted_incl));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_type, t_slotted_incl);

        if (int_ptr->tc_sys.t_slotted_incl)
        {
          int_ptr->tc_sys.t_slotted = b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_tc_sysparm_is2000_type, t_slotted));
          buf_pos += FSIZ(cai_tc_sysparm_is2000_type, t_slotted);
        }
      }
    }

    #ifdef FEATURE_IS2000_REL_A
    if (int_ptr->tc_sys.p_rev >= CAIX_P_REV_IS2000_REL_A)
    {
      /* rel a enc fields */
      int_ptr->tc_sys.enc_supported = b_unpackb(buf_ptr, buf_pos,
            FSIZ(cai_tc_sysparm_is2000_Rel_A_type, enc_supported));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_A_type, enc_supported);

      if (int_ptr->tc_sys.enc_supported)
      {
        int_ptr->tc_sys.sig_encrypt_sup = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_tc_sysparm_is2000_Rel_A_type, sig_encrypt_sup));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_A_type, sig_encrypt_sup);

        int_ptr->tc_sys.ui_encrypt_sup = b_unpackb(buf_ptr, buf_pos,
               FSIZ(cai_tc_sysparm_is2000_Rel_A_type, ui_encrypt_sup));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_A_type, ui_encrypt_sup);
      }

      int_ptr->tc_sys.cs_supported = b_unpackb(buf_ptr, buf_pos,
                 FSIZ(cai_tc_sysparm_is2000_Rel_A_type, cs_supported));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_A_type,cs_supported);
    }

    #endif /* FEATURE_IS2000_REL_A */

    #ifdef FEATURE_IS2000_REL_C
    if (int_ptr->tc_sys.p_rev >= CAIX_P_REV_IS2000_REL_C)
    {
      int_ptr->tc_sys.chm_supported =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, chm_supported));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, chm_supported);

      int_ptr->tc_sys.cdma_off_time_rep_sup_ind =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_sup_ind));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_sup_ind);

      if (int_ptr->tc_sys.cdma_off_time_rep_sup_ind)
      {
        int_ptr->tc_sys.cdma_off_time_rep_threshold_unit =
          b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_threshold_unit));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_threshold_unit);

        int_ptr->tc_sys.cdma_off_time_rep_threshold =
          b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_threshold));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_threshold);
      }

      int_ptr->tc_sys.t_tdrop_range_incl =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, t_tdrop_range_incl));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, t_tdrop_range_incl);

      if (int_ptr->tc_sys.t_tdrop_range_incl)
      {
        int_ptr->tc_sys.t_tdrop_range =
          b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, t_tdrop_range));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, t_tdrop_range);
      }

      int_ptr->tc_sys.for_pdch_supported =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, for_pdch_supported));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, for_pdch_supported);

      if (int_ptr->tc_sys.for_pdch_supported)
      {
        int_ptr->tc_sys.pdch_chm_supported =
          b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, pdch_chm_supported));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, pdch_chm_supported);
      }

      int_ptr->tc_sys.sdb_supported =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, sdb_supported));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, sdb_supported);

      if (int_ptr->tc_sys.cs_supported)
      {
        int_ptr->tc_sys.mob_qos =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, mob_qos));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, mob_qos);
      }

      int_ptr->tc_sys.ms_init_pos_loc_sup_ind =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, ms_init_pos_loc_sup_ind));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, ms_init_pos_loc_sup_ind);

    } /* if (int_ptr->tc_sys.p_rev >= CAIX_P_REV_IS2000_REL_C) */

    #endif /* FEATURE_IS2000_REL_C */

    /* There is an error if we parsed beyond the length */
    if (buf_pos > len)
    {
      status = CAIX_INV_LEN_S;
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_sys_parm */

/*===========================================================================

FUNCTION XLATE_EXT_NLU

DESCRIPTION
  This function translates a Traffic Channel Neighbor List Update
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Neighbor List Update message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_nlu
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through neighbors */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  word var_len;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_nlu_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_nlu_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->nlu.hdr );

    msg_pos = FENDPOS(cai_nlu_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->nlu.hdr.msg_int,
         int_ptr->nlu.msg_type,
         int_ptr->nlu.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->nlu.hdr, int_ptr->nlu.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->nlu.pilot_inc =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix.pilot_inc));
        msg_pos += FSIZ(MTYPE, fix.pilot_inc);

        var_len = len - msg_pos;

#ifdef FEATURE_IS2000_REL_C
        if (int_ptr->nlu.hdr.msg_int.maci_incl)
        {
          var_len -= FSIZ(cai_msg_int_type, maci);
        }
#endif /* FEATURE_IS2000_REL_C */

        int_ptr->nlu.num_nghbr = var_len / FSIZ(cai_nlu_var_type, nghbr_pn);

        for (i=0; i < int_ptr->nlu.num_nghbr; i++)
        {
          int_ptr->nlu.nghbr[i].nghbr_pn =
            b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, var[i].nghbr_pn));
          msg_pos += FSIZ(MTYPE, var[i].nghbr_pn);
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_nlu */

/*===========================================================================

FUNCTION XLATE_EXT_SEND_BURST

DESCRIPTION
  This function translates a Traffic Channel Send Burst DTMF Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Send Burst DTMF message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_send_burst
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through digits */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_sbdtmf_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_sbdtmf_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->sbdtmf.hdr);

    msg_pos = FENDPOS(cai_sbdtmf_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->sbdtmf.hdr.msg_int,
         int_ptr->sbdtmf.msg_type,
         int_ptr->sbdtmf.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->sbdtmf.hdr, int_ptr->sbdtmf.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->sbdtmf.num_digits =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix.num_digits ));
        msg_pos += FSIZ(MTYPE, fix.num_digits);

        int_ptr->sbdtmf.dtmf_on_length =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix.dtmf_on_length));
        msg_pos += FSIZ(MTYPE, fix.dtmf_on_length);

        int_ptr->sbdtmf.dtmf_off_length =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix.dtmf_off_length));
        msg_pos += FSIZ(MTYPE, fix.dtmf_off_length );

        for (i=0; i < int_ptr->sbdtmf.num_digits; i++)
        {
          int_ptr->sbdtmf.digit[i] = b_unpackb(buf_ptr, msg_pos,
            FSIZ(MTYPE, var[i]));
          msg_pos += FSIZ(MTYPE, var[i]);
        }

#ifdef FEATURE_IS2000_REL_A
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
        {
          int_ptr->sbdtmf.con_ref_incl =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix2.con_ref_incl));
          msg_pos += FSIZ(MTYPE, fix2.con_ref_incl);

          if (int_ptr->sbdtmf.con_ref_incl)
          {
            int_ptr->sbdtmf.con_ref =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix2.con_ref));
            msg_pos += FSIZ(MTYPE, fix2.con_ref);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_send_burst */

/*===========================================================================

FUNCTION XLATE_EXT_PWR_CTL

DESCRIPTION
  This function translates a Traffic Channel Power Control Parameters
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Power Control Parameters message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pwr_ctl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_pwr_ctl_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( cai_pwr_ctl_type))
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->pwr_ctl.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->pwr_ctl.hdr.msg_int,
         int_ptr->pwr_ctl.msg_type,
         int_ptr->pwr_ctl.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->pwr_ctl.hdr, int_ptr->pwr_ctl.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->pwr_ctl.pwr_rep_thresh =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pwr_rep_thresh));
        msg_pos += FSIZ(MTYPE, pwr_rep_thresh);

        int_ptr->pwr_ctl.pwr_rep_frames =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pwr_rep_frames));
        msg_pos += FSIZ(MTYPE, pwr_rep_frames );

        int_ptr->pwr_ctl.pwr_thresh_enable =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pwr_thresh_enable));
        msg_pos += FSIZ(MTYPE, pwr_thresh_enable);

        int_ptr->pwr_ctl.pwr_period_enable =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pwr_period_enable));
        msg_pos += FSIZ(MTYPE, pwr_period_enable );

        int_ptr->pwr_ctl.pwr_rep_delay =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pwr_rep_delay));
        msg_pos += FSIZ(MTYPE, pwr_rep_delay);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_pwr_ctl */

/*===========================================================================

FUNCTION XLATE_EXT_RET_PARMS

DESCRIPTION
  This function translates a Traffic Channel Retrieve Parameters
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Retrieve Parameters message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None.

===========================================================================*/

word xlate_ext_ret_parms
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index through parameter ids */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  word var_len;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_ret_parms_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_ret_parms_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->ret.hdr);

    msg_pos = FENDPOS(cai_ret_parms_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->ret.hdr.msg_int,
         int_ptr->ret.msg_type,
         int_ptr->ret.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->ret.hdr, int_ptr->ret.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        var_len = len - msg_pos;

#ifdef FEATURE_IS2000_REL_C
        if (int_ptr->ret.hdr.msg_int.maci_incl)
        {
          var_len -= FSIZ(cai_msg_int_type, maci);
        }
#endif /* FEATURE_IS2000_REL_C */

        int_ptr->ret.num_parms = var_len / FSIZ(cai_ret_parms_var_type, parameter_id);

        for (i=0; i < int_ptr->ret.num_parms; i++)
        {
          int_ptr->ret.parameter_id[i] =
            b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, var[i]));
          msg_pos += FSIZ(MTYPE, var[i]);
        }
      }
    }
  }

  #undef MTYPE
  return (status);

} /* xlate_ext_ret_parms */

/*===========================================================================

FUNCTION XLATE_EXT_SET_PARM

DESCRIPTION
  This function translates a Traffic Channel Set Parameters Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Set Parameters message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_set_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word buf_pos;
    /* Location of next bit in buffer to be processed */
  word i;
    /* Index through parameters */
  word rec_min_len;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_set_parm_type

  /* -----------------------
  ** Initialize status to ok
  ** ----------------------- */
  status = CAIX_DONE_S;

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( cai_set_parm_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* --------------
    ** Unpack message
    ** -------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->set.hdr);

    buf_pos = FENDPOS(MTYPE, fix.hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &buf_pos, buf_ptr, &int_ptr->set.hdr.msg_int,
         int_ptr->set.msg_type,
         int_ptr->set.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &buf_pos, buf_ptr,
          &int_ptr->set.hdr, int_ptr->set.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->set.num_parms = 0;

        rec_min_len = FSIZ(MTYPE, var.parameter_id) +
          FSIZ(MTYPE, var.parameter_len);

#ifdef FEATURE_IS2000_REL_C
        if (int_ptr->set.hdr.msg_int.maci)
        {
          rec_min_len += FSIZ(cai_msg_int_type, maci);
        }
#endif /* FEATURE_IS2000_REL_C */

        /* -------------------------------------
        ** Loop through bits until reserved bits
        ** ------------------------------------- */
        while ((len > buf_pos)  && ((len - buf_pos) >= rec_min_len))
        {
          /* -----------------------------------------
          ** Unpack parameter id and parameter_len and
          ** increment buf_pos accordingly
          ** ----------------------------------------- */
          i = int_ptr->set.num_parms;  /* Set parameter index */

          int_ptr->set.parms[i].parameter_id =
            b_unpackw(buf_ptr, buf_pos, FSIZ(MTYPE, var.parameter_id));
          buf_pos += FSIZ(MTYPE, var.parameter_id);

          int_ptr->set.parms[i].parameter_len =
            b_unpackw(buf_ptr, buf_pos, FSIZ(MTYPE, var.parameter_len));
          buf_pos += FSIZ(MTYPE, var.parameter_len);

          if ((len - buf_pos) >= int_ptr->set.parms[i].parameter_len)
          {
            /* ---------------------------------------------------------
            ** There is enough room left in the buffer for the parameter
            ** --------------------------------------------------------- */
            if (int_ptr->set.parms[i].parameter_len > 31)
            {
              b_unpackq(buf_ptr, buf_pos,
                        int_ptr->set.parms[i].parameter_len + 1,
                        int_ptr->set.parms[i].parameter.parm_q);
            }
            else if (int_ptr->set.parms[i].parameter_len > 15)
            {
              int_ptr->set.parms[i].parameter.parm_d =
                b_unpackd(buf_ptr, buf_pos,
                          int_ptr->set.parms[i].parameter_len + 1);
            }
            else if (int_ptr->set.parms[i].parameter_len > 7)
            {
              int_ptr->set.parms[i].parameter.parm_w =
                b_unpackw(buf_ptr, buf_pos,
                          int_ptr->set.parms[i].parameter_len + 1);
            }
            else
            {
              int_ptr->set.parms[i].parameter.parm_b =
                b_unpackb(buf_ptr, buf_pos,
                          int_ptr->set.parms[i].parameter_len + 1);
            }

            /* -------------------------
            ** Increment buffer position
            ** ------------------------- */
            buf_pos += int_ptr->set.parms[i].parameter_len + 1;

            /* ------------------------------
            ** Increment number of parameters
            ** ------------------------------ */
            int_ptr->set.num_parms++;
          }
          else
          {
            /* --------------------------------------------------------
            ** There is an error in the message -> stop message parsing
            ** -------------------------------------------------------- */
            break;
          }
        } /* while */
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_set_parm */

/*===========================================================================

FUNCTION XLATE_EXT_SSD_UP

DESCRIPTION
  This function translates a Traffic Channel SSD Update Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the SSD Update message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_ssd_up
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */

  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_ssd_up_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_ssd_up_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->ssd_up.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->ssd_up.hdr.msg_int,
         int_ptr->ssd_up.msg_type,
         int_ptr->ssd_up.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->ssd_up.hdr, int_ptr->ssd_up.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        b_unpackq(buf_ptr, msg_pos, FSIZ(MTYPE,  randssd),
                  int_ptr->ssd_up.randssd);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_ssd_up */

/*===========================================================================

FUNCTION XLATE_EXT_MOB_REG

DESCRIPTION
  This function translates a Traffic Channel Mobile Station Registered
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Mobile Station Registered message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_mob_reg
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_registered_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_registered_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->reg.hdr);

    msg_pos = FENDPOS(cai_registered_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->reg.hdr.msg_int,
         int_ptr->reg.msg_type,
         int_ptr->reg.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->reg.hdr, int_ptr->reg.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->reg.sid =
          b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, sid));
        msg_pos += FSIZ(MTYPE, sid);

        int_ptr->reg.nid =
          b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, nid));
        msg_pos += FSIZ(cai_registered_type, nid);

        int_ptr->reg.reg_zone =
          b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, reg_zone));
        msg_pos += FSIZ(MTYPE, reg_zone);

        int_ptr->reg.total_zones =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, total_zones));
        msg_pos += FSIZ(MTYPE, total_zones);

        int_ptr->reg.zone_timer =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, zone_timer));
        msg_pos += FSIZ(MTYPE, zone_timer);

        int_ptr->reg.mult_sids =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, mult_sids));
        msg_pos += FSIZ(MTYPE, mult_sids);

        int_ptr->reg.mult_nids =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, mult_nids));
        msg_pos += FSIZ(MTYPE, mult_nids);

        int_ptr->reg.base_lat =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, base_lat));
        msg_pos += FSIZ(MTYPE, base_lat);

        int_ptr->reg.base_long =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, base_long));
        msg_pos += FSIZ(MTYPE, base_long);

        int_ptr->reg.reg_dist =
          b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, reg_dist));
        msg_pos += FSIZ(MTYPE, reg_dist);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_mob_reg */

/*===========================================================================

FUNCTION XLATE_EXT_TC_STREQ

DESCRIPTION
  This function translates a Forward Traffic Channel Status Request Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Status Request message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_streq
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  caii_tc_streq_type  *i_ptr = &int_ptr->tc_streq;
    /* Pointer to Status Request internal message */
  word i;
    /* Index for looping through info record types */
  byte qual_len;
    /* For receiving length of qualfication information */
  word msg_pos;
    /* For keeping track of bit offset into message */
  word status;
  /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_tc_streq_fix_type
  /* Set up MTYPE for PARAMS macro */

  status = CAIX_DONE_S;

  if (len < sizeof(MTYPE))
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &i_ptr->hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &i_ptr->hdr.msg_int, i_ptr->msg_type,
         i_ptr->hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, &i_ptr->hdr,
                                         i_ptr->msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        i_ptr->qual = b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, qual_typ));
        msg_pos += FSIZ(MTYPE, qual_typ);

        qual_len = (byte)(b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, qual_len)) * 8);
        msg_pos += FSIZ(MTYPE, qual_len);

        if (sizeof(MTYPE) + qual_len > len) /* Messge big enough? */
        {
          status =  CAIX_INV_LEN_S;
          return ( status ); /* Message too small for qual len to fit */
        }

        if (i_ptr->qual == CAI_NO_QUAL) /* If no qual info specified */
        {
          i_ptr->band = CAI_BAND_CLASS0;         /* Assume cellular band */

          i_ptr->op_mode = CAI_IS95_CDMA_OP_MODE; /* And CDMA mode */

          msg_pos += qual_len; /* Skip over qual info */
        }
        else if (i_ptr->qual == CAI_BAND_QUAL) /* Band qualification specified */
        {
          if (sizeof(cai_qual_info1_type) > qual_len) /* Will it fit? */
          {
            status =  CAIX_INV_LEN_S ;
            return (status); /* Message too small for band qual info */
          }
          else
          {
            i_ptr->band =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_qual_info1_type, band));
            /* Translate specified band qualfication */

            i_ptr->op_mode = CAI_IS95_CDMA_OP_MODE; /* Assume CDMA mode */

            msg_pos += qual_len; /* Skip over qual info field */
          }
        }
        else if (i_ptr->qual == CAI_BAND_OP_MODE_QUAL) /* Band and mode qual */
        {
          if (sizeof(cai_qual_info2_type) > qual_len) /* Will qual info fit? */
          {
            status = CAIX_INV_LEN_S ;
            return (status); /* Message too small for band and mode */
          }
          else
          {
            i_ptr->band =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_qual_info2_type, band));
            /* Translate band qual info */

            i_ptr->op_mode =
              b_unpackb(buf_ptr, msg_pos + FSIZ(cai_qual_info2_type, band),
                        FSIZ(cai_qual_info2_type, op_mode));
            /* Translate mode qual info */
            msg_pos += qual_len; /* Skip over qual info field */
          }
        }
        else
        {
          status = CAIX_INV_MSG_S;
          return (status);  /* Unknown qualification type */
        }

        i_ptr->num_fields =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_fields));
        /* Translate number of info rec requests. */
        msg_pos += FSIZ(MTYPE, num_fields);

        if (msg_pos + (i_ptr->num_fields * sizeof(cai_streq_var_type)) > len )
        {
          status = CAIX_INV_LEN_S ;
          return (status); /* Message too small */
        }

        /* Translate info rec requests */
        for (i = 0; (i < i_ptr->num_fields) && (i < CAI_REC_TYP_MAX); i++)
        {
          i_ptr->rec_typ[i] =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_streq_var_type, rec_typ));
          msg_pos += FSIZ(cai_streq_var_type, rec_typ);
        }
      }
    }
  }

  #undef MTYPE  /* Deactivate MTYPE definition */

  return ( status );

} /* xlate_ext_tc_streq */

/*===========================================================================

FUNCTION XLATE_EXT_SRV_CFG

DESCRIPTION
  This function translates a Service Configuration Record from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srv_cfg
(
  word len,
    /* Length, in bits, of message fragment containing the service
       configuration record. */

  byte *buf_ptr,
    /* Pointer to received message containing the service
       configuration record. */

  word buf_pos,
    /* Offset in message at which service configuration record
       begins. */

  caii_srv_cfg_type *int_ptr,
    /* Pointer to where translated service configuration record
       should be placed. */

  boolean full_cfg
    /* Is this a full config msg? */
    /* (does it have the for and rev multi_frame_offset fields?) */
)
{
  word  status;
    /* Status returned to calling procedure. */

  word  rec_len;
    /* For keeping track of the number of bits remaining to translate
       in the service configuration record. */

  word  con_len;
    /* For keeping track of the number of bits in the service option
       connection record being translated. */

  word temp_buf_pos;
  word sch_rec_len;

  word  i;
    /* For indexing through the service option connection records. */

  if (len < sizeof(cai_rec_hdr_type))
    /* Is there enough room for an info rec header? */
  {
    status = CAIX_INV_LEN_S;    /* Message too short */
  }

  else if (b_unpackb(REC_P(record_type)) != CAI_FTC_SRV_CFG_REC)
  {
    status = CAIX_INV_MSG_S;  /* Wrong record type */
  }

  else if ((rec_len = b_unpackw(REC_P(record_len)) * 8) <
            sizeof(cai_srv_cfg_hdr_type) )
  {
    status = CAIX_INV_LEN_S;
      /* There isn't enough room even to hold a service configuration
         record with zero service option connections. */
  }

  else if (len <sizeof(cai_rec_hdr_type) + rec_len)
  {
    status = CAIX_INV_LEN_S;
      /* There isn't enough room to hold a service configuration record
         of the size specified in the information record header. */
  }

  else
  {
    buf_pos += sizeof(cai_rec_hdr_type); /* Skip over info rec header */

    global_buf_pos = buf_pos + rec_len;

    /* Unpack fields of service config record header */
    int_ptr->fwd_mux   = b_unpackw(HDR_P(fwd_mux));
    int_ptr->rev_mux   = b_unpackw(HDR_P(rev_mux));
    int_ptr->fwd_rates = b_unpackb(HDR_P(fwd_rates));
    int_ptr->rev_rates = b_unpackb(HDR_P(rev_rates));
    int_ptr->num_con   = b_unpackb(HDR_P(num_con));
      /* Note that the num_con field will be set to the number of
         service option connection records specified in the received
         service configuration record, but the actual number of service
         option configuration records translated is limited to
         CAII_SRV_CON_MAX. */

    rec_len -= sizeof(cai_srv_cfg_hdr_type);
      /* Adjust remaining record size */

    buf_pos += sizeof(cai_srv_cfg_hdr_type);
      /* Advance over record header */

    status = CAIX_DONE_S;
      /* Set good status. This may get changed in the
         following for loop. */

    for (i = 0; i<int_ptr->num_con && i<CAII_SRV_CON_MAX; i++)
      /* Translate each service option connection record contained in
         the service configuration record. Stop when either the specified
         number of records are translated, or when the maximum number of
         records supported by the internal type is reached. */
    {
      /* Now we know we can at least look at the record length field */

      if (rec_len < (con_len = b_unpackw(CON_P(rec_len))*8))
      /* Is there room for a service option connection record of the
         actual length specified in the record? */
      {
        status = CAIX_INV_LEN_S;  /* Not enough room */
        break;
      }

      else
      {
        word cur;

        /* Translate the fields of the service option connection rec */
        int_ptr->con[i].con_ref  = b_unpackb(CON_P(con_ref));
        int_ptr->con[i].so       = b_unpackw(CON_P(so));
        int_ptr->con[i].fwd_traf = b_unpackb(CON_P(fwd_traf));
        int_ptr->con[i].rev_traf = b_unpackb(CON_P(rev_traf));

        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
        {
          int_ptr->con[i].ui_encrypt_mode = b_unpackb(CON_P(ui_encrypt_mode));
          int_ptr->con[i].sr_id           = b_unpackb(CON_P(sr_id));
          int_ptr->con[i].rlp_info_incl   = b_unpackb( CON_P(rlp_info_incl));
          temp_buf_pos = buf_pos + sizeof(cai_srv_cfg_con_type);

          if (int_ptr->con[i].rlp_info_incl)
          {
            #define VTYPE cai_srv_cfg_con_var_type

            int_ptr->con[i].rlp_blob_len = b_unpackb(buf_ptr, temp_buf_pos,
              FSIZ(VTYPE, rlp_blob_len));
            temp_buf_pos += FSIZ(VTYPE, rlp_blob_len);

            for (cur=0;cur<int_ptr->con[i].rlp_blob_len;cur++)
            {
              int_ptr->con[i].rlp_blob[cur] = b_unpackb(buf_ptr, temp_buf_pos,
                FSIZ(VTYPE, rlp_blob));
              temp_buf_pos += FSIZ(VTYPE, rlp_blob);
            }

            #undef VTYPE
          }

#ifdef FEATURE_IS2000_REL_A
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
            #define FTYPE cai_srv_cfg_con_is2000_rel_a_fix_type

            int_ptr->con[i].qos_parms_incl = b_unpackb(buf_ptr, temp_buf_pos,
              FSIZ(FTYPE, qos_parms_incl));
            temp_buf_pos += FSIZ(FTYPE, qos_parms_incl);

            if (int_ptr->con[i].qos_parms_incl)
            {
              #define VTYPE cai_srv_cfg_con_is2000_rel_a_var_type

              int_ptr->con[i].qos_parms_len = b_unpackb(buf_ptr, temp_buf_pos,
                FSIZ(VTYPE, qos_parms_len));
              temp_buf_pos += FSIZ(VTYPE, qos_parms_len);

              if( int_ptr->con[i].qos_parms_len <= CAI_ORIG_QOS_LEN_MAX )
              {
                for (cur=0; cur<int_ptr->con[i].qos_parms_len; cur++)
                {
                  int_ptr->con[i].qos_parms[cur] = b_unpackb(buf_ptr,
                    temp_buf_pos, FSIZ(VTYPE, qos_parms));
                  temp_buf_pos += FSIZ(VTYPE, qos_parms);
                }
              }
              else
              {
                M1X_MSG( DCP, LEGACY_ERROR,
                  "Unexpected number of characters:%d > CAI_ORIG_QOS_LEN_MAX",
                  int_ptr->con[i].qos_parms_len);
                status = CAIX_INV_MSG_S;
              }

              #undef VTYPE
            }

            #undef FTYPE
          } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A) */
#endif /* FEATURE_IS2000_REL_A */

        } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000) */
        rec_len -= con_len;    /* Adjust remaining record length */
        buf_pos += con_len;  /* Move ptr to start of next rec */
      }
    } /* end for */

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      #define FTYPE cai_srv_cfg_is2000_type

      int_ptr->fch_cc_incl = b_unpackb(buf_ptr, buf_pos, FSIZ(FTYPE, fch_cc_incl));
      buf_pos += FSIZ(FTYPE, fch_cc_incl);

      if (int_ptr->fch_cc_incl)
      {
        int_ptr->fch_frame_size = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, fch_frame_size));
        buf_pos += FSIZ(FTYPE, fch_frame_size);

        int_ptr->for_fch_rc = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, for_fch_rc));
        buf_pos += FSIZ(FTYPE, for_fch_rc);

        int_ptr->rev_fch_rc = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, rev_fch_rc));
        buf_pos += FSIZ(FTYPE, rev_fch_rc);
      }

      int_ptr->dcch_cc_incl = b_unpackb(buf_ptr, buf_pos,
        FSIZ(FTYPE, dcch_cc_incl));
      buf_pos += FSIZ(FTYPE, dcch_cc_incl);

      if (int_ptr->dcch_cc_incl)
      {
        int_ptr->dcch_frame_size = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, dcch_frame_size));
        buf_pos += FSIZ(FTYPE, dcch_frame_size);

        int_ptr->for_dcch_rc = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, for_dcch_rc));
        buf_pos += FSIZ(FTYPE, for_dcch_rc);

        int_ptr->rev_dcch_rc = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, rev_dcch_rc));
        buf_pos += FSIZ(FTYPE, rev_dcch_rc);
      }

      int_ptr->for_sch_cc_incl = b_unpackb(buf_ptr,buf_pos,
        FSIZ(FTYPE, for_sch_cc_incl));
      buf_pos += FSIZ(FTYPE, for_sch_cc_incl);

      if (int_ptr->for_sch_cc_incl)
      {
        int_ptr->num_for_sch = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, num_for_sch));

        if(int_ptr->num_for_sch > CAI_MAX_NUM_FOR_SCH)
        {
          M1X_MSG( DCP, LEGACY_ERROR,
            "Unsupported num_for_sch = %d is received",
            int_ptr->num_for_sch);
          status = CAIX_INV_MSG_S;
          return status;
        }

        buf_pos += FSIZ(FTYPE, num_for_sch);

        #define VTYPE1 cai_for_sch_type
        #define VTYPE2 cai_sch_chn_cfg_type

        for (i=0; i<int_ptr->num_for_sch; i++)
        {
          int_ptr->for_sch[i].for_sch_id = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE1, for_sch_id));
          buf_pos += FSIZ(VTYPE1, for_sch_id);

          int_ptr->for_sch[i].for_sch_mux = b_unpackw(buf_ptr, buf_pos,
            FSIZ(VTYPE1, for_sch_mux));
          buf_pos += FSIZ(VTYPE1, for_sch_mux);

          temp_buf_pos = buf_pos;

          sch_rec_len = b_unpackb(buf_ptr, buf_pos, FSIZ(VTYPE2, sch_rec_len));
          buf_pos += FSIZ(VTYPE2, sch_rec_len);

          int_ptr->for_sch[i].sch_chn_cfg.sch_rc = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE2, sch_rc));
          buf_pos += FSIZ(VTYPE2, sch_rc);

          int_ptr->for_sch[i].sch_chn_cfg.coding = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE2, coding));
          buf_pos += FSIZ(VTYPE2, coding);

#ifdef FEATURE_IS2000_REL_A
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
            int_ptr->for_sch[i].sch_chn_cfg.frame_40_used = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, frame_40_used));
            buf_pos += FSIZ(VTYPE2, frame_40_used);

            int_ptr->for_sch[i].sch_chn_cfg.frame_80_used = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, frame_80_used));
            buf_pos += FSIZ(VTYPE2, frame_80_used);

            int_ptr->for_sch[i].sch_chn_cfg.max_rate = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, max_rate));
            buf_pos += FSIZ(VTYPE2, max_rate);
          }
#endif /* FEATURE_IS2000_REL_A */

          buf_pos = temp_buf_pos + sch_rec_len*8;
        } /* end for */

        #undef VTYPE1
        #undef VTYPE2

      } /* end if (for_sch_cc_incl) */

      int_ptr->rev_sch_cc_incl = b_unpackb(buf_ptr, buf_pos,
        FSIZ(FTYPE, rev_sch_cc_incl));
      buf_pos += FSIZ(FTYPE, rev_sch_cc_incl);

      if (int_ptr->rev_sch_cc_incl)
      {
        int_ptr->num_rev_sch = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, num_rev_sch));

        if(int_ptr->num_rev_sch > CAI_MAX_NUM_REV_SCH)
        {
          M1X_MSG( DCP, LEGACY_ERROR,
            "Unsupported num_rev_sch = %d is received",
            int_ptr->num_rev_sch);
          status = CAIX_INV_MSG_S;
          return status;
        }

        buf_pos += FSIZ(FTYPE, num_rev_sch);

        #define VTYPE1 cai_rev_sch_type
        #define VTYPE2 cai_sch_chn_cfg_type

        for (i=0; i<int_ptr->num_rev_sch; i++)
        {
          int_ptr->rev_sch[i].rev_sch_id = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE1, rev_sch_id));
          buf_pos += FSIZ(VTYPE1, rev_sch_id);

          int_ptr->rev_sch[i].rev_sch_mux = b_unpackw(buf_ptr, buf_pos,
            FSIZ(VTYPE1, rev_sch_mux));
          buf_pos += FSIZ(VTYPE1, rev_sch_mux);

          temp_buf_pos = buf_pos;

          sch_rec_len = b_unpackb(buf_ptr, buf_pos, FSIZ(VTYPE2, sch_rec_len));
          buf_pos += FSIZ(VTYPE2, sch_rec_len);

          int_ptr->rev_sch[i].sch_chn_cfg.sch_rc = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE2, sch_rc));
          buf_pos += FSIZ(VTYPE2, sch_rc);

          int_ptr->rev_sch[i].sch_chn_cfg.coding = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE2, coding));
          buf_pos += FSIZ(VTYPE2, coding);

#ifdef FEATURE_IS2000_REL_A
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
            int_ptr->rev_sch[i].sch_chn_cfg.frame_40_used = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, frame_40_used));
            buf_pos += FSIZ(VTYPE2, frame_40_used);

            int_ptr->rev_sch[i].sch_chn_cfg.frame_80_used = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, frame_80_used));
            buf_pos += FSIZ(VTYPE2, frame_80_used);

            int_ptr->rev_sch[i].sch_chn_cfg.max_rate = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, max_rate));
            buf_pos += FSIZ(VTYPE2, max_rate);
          }
#endif /* FEATURE_IS2000_REL_A */

          buf_pos = temp_buf_pos + sch_rec_len * 8;
        } /* end for */

        #undef VTYPE1
        #undef VTYPE2

      } /* end if (rev_sch_cc_incl) */

      #undef FTYPE

#ifdef FEATURE_IS2000_REL_B
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
      {
        #define FTYPE cai_srv_cfg_is2000_rel_b_type

        int_ptr->fch_dcch_mux_option_ind = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, fch_dcch_mux_option_ind));
        buf_pos += FSIZ(FTYPE, fch_dcch_mux_option_ind);

        if (int_ptr->fch_dcch_mux_option_ind ==
            CAI_MUX_OPTION_DIFF_FOR_FCH_AND_DCCH)
        {
          int_ptr->for_dcch_mux = b_unpackw(buf_ptr, buf_pos,
            FSIZ(FTYPE, for_dcch_mux));
          buf_pos += FSIZ(FTYPE, for_dcch_mux);

          int_ptr->rev_dcch_mux = b_unpackw(buf_ptr, buf_pos,
            FSIZ(FTYPE, rev_dcch_mux));
          buf_pos += FSIZ(FTYPE, rev_dcch_mux);
        }

        #undef FTYPE
      } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B) */
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        #define FTYPE cai_srv_cfg_is2000_rel_c_fix_type
        #define VTYPE cai_srv_cfg_is2000_rel_c_var_type

        int_ptr->for_pdch_cc_incl = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, for_pdch_cc_incl));
        buf_pos += FSIZ(FTYPE, for_pdch_cc_incl);

        if (int_ptr->for_pdch_cc_incl)
        {
          int_ptr->for_pdch_mux_option = b_unpackw(buf_ptr, buf_pos,
            FSIZ(VTYPE, for_pdch_mux_option));
          buf_pos += FSIZ(VTYPE, for_pdch_mux_option);

          int_ptr->for_pdch_rc = (byte) b_unpackw(buf_ptr, buf_pos,
            FSIZ(VTYPE, for_pdch_rc));
          buf_pos += FSIZ(VTYPE, for_pdch_rc);
        }

        #undef VTYPE
        #undef FTYPE

      } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) */
#endif /* FEATURE_IS2000_REL_C */

    } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000) */

    if (buf_pos > global_buf_pos)
    {
      status = CAIX_INV_LEN_S;
      M1X_MSG( DCP, LEGACY_ERROR,
        "Gone past len of SCR %d %d",
        buf_pos,
        global_buf_pos);
    }

  } /* else */

  return ( status );

} /* xlate_ext_srv_cfg */

/*===========================================================================

FUNCTION XLATE_EXT_SRV_REQ

DESCRIPTION
  This function translates a Service Request Message from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srv_req
(
  word len,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to received message to be translated */

  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ftc_srv_req_fix_type

  /* Set up MTYPE for PARAMS macro */

  if (len < sizeof(MTYPE))
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }

  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->srv_req.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->srv_req.hdr.msg_int,
         int_ptr->srv_req.msg_type,
         int_ptr->srv_req.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->srv_req.hdr, int_ptr->srv_req.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->srv_req.req_seq =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, req_seq));
        msg_pos += FSIZ(MTYPE, req_seq);

        int_ptr->srv_req.purp = b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, purp));
        msg_pos += FSIZ(MTYPE, purp);

        if ( int_ptr->srv_req.purp == CAI_SRV_PRO_PURP )
        {
          /* Translate service configuration record */
          status = xlate_ext_srv_cfg(len - sizeof(MTYPE), buf_ptr, msg_pos,
                                     &int_ptr->srv_req.cfg ,0);
        }
      }
    }
  } /* else */

  #undef MTYPE  /* Deactivate MTYPE definition */

  return (status);

} /* xlate_ext_srv_req */

/*===========================================================================

FUNCTION XLATE_EXT_SRV_RSP

DESCRIPTION
  This function translates a Service Response Message from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srv_rsp
(
  word len,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to received message to be translated */

  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ftc_srv_rsp_fix_type
  /* Set up MTYPE for PARAMS macro */

  if ( len < sizeof( MTYPE ) )
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }

  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->srv_rsp.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->srv_rsp.hdr.msg_int,
         int_ptr->srv_rsp.msg_type,
         int_ptr->srv_rsp.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->srv_rsp.hdr, int_ptr->srv_rsp.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->srv_rsp.req_seq =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, req_seq));
        msg_pos += FSIZ(MTYPE, req_seq);

        int_ptr->srv_rsp.purp = b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, purp));
        msg_pos += FSIZ(MTYPE, purp);

        if (int_ptr->srv_rsp.purp == CAI_SRV_PRO_PURP)
        {
          /* Translate service configuration record */
          status = xlate_ext_srv_cfg(len - sizeof(MTYPE), buf_ptr, msg_pos,
                                     &int_ptr->srv_rsp.cfg ,0);
        }
      }
    }
  } /* else */

  #undef MTYPE  /* Deactivate MTYPE definition */

  return (status);

} /* xlate_ext_srv_rsp */

/*===========================================================================

FUNCTION XLATE_EXT_SRV_CON

DESCRIPTION
  This function translates a Service Connect Message from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srv_con
(
  word len,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to received message to be translated */

  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word local_len;
#ifdef FEATURE_IS2000_REL_A
  word i;
#endif /* FEATURE_IS2000_REL_A */

  word buf_pos = 0;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_srv_con_fix_type

  /* Set up MTYPE for PARAMS macro */

  if ( len < sizeof(MTYPE) )
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }

  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->srv_con.hdr);

    buf_pos = FENDPOS(cai_srv_con_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &buf_pos, buf_ptr, &int_ptr->srv_con.hdr.msg_int,
         int_ptr->srv_con.msg_type,
         int_ptr->srv_con.hdr.ack_req
         )) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
    if ((status = xlate_ext_ext_enc_tc(&len, &buf_pos, buf_ptr,
        &int_ptr->srv_con.hdr, int_ptr->srv_con.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_A */

    int_ptr->srv_con.use_time =
      b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, use_time));
    buf_pos += FSIZ(MTYPE, use_time);

    int_ptr->srv_con.action_time =
      b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, action_time));
    buf_pos += FSIZ(MTYPE, action_time);

    int_ptr->srv_con.con_seq =
      b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, con_seq));
    buf_pos += FSIZ(MTYPE, con_seq);

#ifndef FEATURE_IS2000_REL_A
    buf_pos = sizeof(MTYPE);
    local_len = 0;
#else
    buf_pos += FSIZ(MTYPE,reserved);

    int_ptr->srv_con.use_old_srv_cfg =
      b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, use_old_serv_config));
    buf_pos += FSIZ(MTYPE, use_old_serv_config);

#ifdef FEATURE_IS2000_REL_C
    if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) &&
        (int_ptr->srv_con.use_old_srv_cfg == CAI_USE_OLD_SRV_CFG_WITH_GIVEN_SR_ID))
    {
      int_ptr->srv_con.sr_id =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_srv_con_rel_c_type, sr_id));
      buf_pos += FSIZ(cai_srv_con_rel_c_type, sr_id);
    }
#endif /* FEATURE_IS2000_REL_C */


    int_ptr->srv_con.sync_id_incl =
      b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, sync_id_incl));
    buf_pos += FSIZ(MTYPE, sync_id_incl);

    /* we do this to be able to calculate the length of the
       sync_id related fields in the message */
    local_len = buf_pos;

    /* sync_id processing */
    if (int_ptr->srv_con.sync_id_incl)
    {
      int_ptr->srv_con.sync_id_len =
        b_unpackb(buf_ptr, buf_pos,
      FSIZ(cai_srv_cfg_sync_id_type, sync_id_len));
      buf_pos += FSIZ(cai_srv_cfg_sync_id_type, sync_id_len);

      for (i=0; (i<int_ptr->srv_con.sync_id_len) && (i < CAI_SYNC_ID_LEN_MAX); i++)
      {
        int_ptr->srv_con.sync_id[i] =
          b_unpackb(buf_ptr, buf_pos, FSIZ(cai_srv_cfg_sync_id_type, sync_id));
        buf_pos += FSIZ(cai_srv_cfg_sync_id_type, sync_id);
      }
    } /* if (int_ptr->srv_con.sync_id_incl) */

    /* calculate the length of the sync_id related fields for use below.*/
    local_len = buf_pos - local_len;
    /* Translate service configuration record */
    if ((int_ptr->srv_con.use_old_srv_cfg == CAI_USE_SRV_CFG_IN_MSG) ||
        (int_ptr->srv_con.use_old_srv_cfg == CAI_USE_OLD_SRV_CFG_WITH_CFG_IN_MSG)
       )
#endif /* FEATURE_IS2000_REL_A */
    {
      status = xlate_ext_srv_cfg(len - sizeof(MTYPE) - local_len,
         buf_ptr, buf_pos, &int_ptr->srv_con.cfg ,1);

      if (status != CAIX_DONE_S)
      {
        return status;
      }

      buf_pos = global_buf_pos;
    }

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
#ifdef FEATURE_IS2000_REL_A
      if ((int_ptr->srv_con.use_old_srv_cfg == CAI_USE_SRV_CFG_IN_MSG) ||
          (int_ptr->srv_con.use_old_srv_cfg == CAI_USE_OLD_SRV_CFG_WITH_CFG_IN_MSG)
         )
#endif /* FEATURE_IS2000_REL_A */
      {
        status = xlate_int_non_neg_srv_cfg(buf_ptr, &buf_pos,
                                  &(int_ptr->srv_con.non_neg_cfg));
        if (status != CAIX_DONE_S)
        {
          return status;
        }
      }
    }

#ifdef FEATURE_IS2000_REL_A
    int_ptr->srv_con.cc.cc_info_incl = 0;

    if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A) &&
        (int_ptr->srv_con.use_old_srv_cfg == CAI_USE_SRV_CFG_IN_MSG))
    {
      int_ptr->srv_con.cc.cc_info_incl =  b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_cc_info_fix_type, cc_info_incl));
      buf_pos += FSIZ(cai_cc_info_fix_type, cc_info_incl);

      if (int_ptr->srv_con.cc.cc_info_incl)
      {
        int_ptr->srv_con.cc.num_calls_assign =  b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_cc_info_fix_type, num_calls_assign));
        buf_pos += FSIZ(cai_cc_info_fix_type, num_calls_assign);

        for (i=0; i<int_ptr->srv_con.cc.num_calls_assign && i<CAI_SCM_MAX_NUM_CALLS_ASSIGN; i++ )
        {
          int_ptr->srv_con.cc.conn[i].con_ref =
            b_unpackb(buf_ptr, buf_pos, FSIZ(cai_cc_info_type, con_ref));
          buf_pos += FSIZ(cai_cc_info_type, con_ref);

          int_ptr->srv_con.cc.conn[i].response_ind =
            b_unpackb(buf_ptr, buf_pos, FSIZ(cai_cc_info_type, response_ind));
          buf_pos += FSIZ(cai_cc_info_type, response_ind);

          if (int_ptr->srv_con.cc.conn[i].response_ind)
          {
            int_ptr->srv_con.cc.conn[i].tag =
              b_unpackb(buf_ptr, buf_pos, FSIZ(cai_cc_info_type, tag));
            buf_pos += FSIZ(cai_cc_info_type, tag);
          }
          else
          {
            int_ptr->srv_con.cc.conn[i].bypass_alert_answer =
              b_unpackb(buf_ptr, buf_pos,
            FSIZ(cai_cc_info_type, bypass_alert_answer));
            buf_pos += FSIZ(cai_cc_info_type, bypass_alert_answer);
          }
        } // for (..)
      }
    } // if ( caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      int_ptr->srv_con.use_type0_plcm =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_srv_con_rel_c_type, use_type0_plcm));
      buf_pos += FSIZ(cai_srv_con_rel_c_type, use_type0_plcm);
    }
#endif /* FEATURE_IS2000_REL_C */

    /* Make sure the message contained all the fields advertised by the p-rev */
    if (buf_pos > len)
    {
      status = CAIX_INV_LEN_S;
    }

  } /* else length check failed*/

  #undef MTYPE  /* Deactivate MTYPE definition */

  return (status);

} /* xlate_ext_srv_con */

/*===========================================================================

FUNCTION XLATE_EXT_SRV_CTL

DESCRIPTION
  This function translates a Service Option Control Message from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srv_ctl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* For indexing through type specific bytes */
  word msg_pos;
    /* Position of record in message */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ftc_srv_ctl_fix_type
  /* Set up MTYPE for PARAMS macro */

  if ( len < sizeof(MTYPE) )
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }

  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->srv_ctl.hdr);

    msg_pos = FENDPOS(cai_ftc_srv_ctl_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->srv_ctl.hdr.msg_int,
         int_ptr->srv_ctl.msg_type,
         int_ptr->srv_ctl.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->srv_ctl.hdr, int_ptr->srv_ctl.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->srv_ctl.use_time =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
        msg_pos +=  FSIZ(MTYPE, use_time);

        int_ptr->srv_ctl.action_time =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
        msg_pos +=  FSIZ(MTYPE, action_time) ;

        int_ptr->srv_ctl.con_ref =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref));
        msg_pos +=  FSIZ(MTYPE, con_ref);

        int_ptr->srv_ctl.so = b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, so));
        msg_pos += FSIZ(MTYPE, so);

        int_ptr->srv_ctl.tsf_len =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, tsf_len));
        msg_pos +=  FSIZ(MTYPE, tsf_len);

        len -= sizeof(MTYPE);   /* Adjust len for remainder of msg */

        #undef MTYPE
        /* Done with this def for MTYPE */

        #define MTYPE cai_ftc_srv_ctl_var_type
        /* Set up MTYPE for PARAMS macro for variable part of msg */

        if (len < int_ptr->srv_ctl.tsf_len * sizeof(MTYPE))
          /* Is the remainder of the message long enough to include the
             number of type specific bytes specified? */
        {
          status = CAIX_INV_LEN_S;  /* Message too short */
        }
        else
        {
          /* Translate the type specific bytes */
          for (i = 0; i < int_ptr->srv_ctl.tsf_len; i++)
          {
            int_ptr->srv_ctl.tsf[i] =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, tsf));

            /* Advance pointer to next byte */
            msg_pos += sizeof(MTYPE);
          } /* for */
        } /* else */
      }
    }
  } /* else */

  #undef MTYPE
  /* Deactivate MTYPE def */

  return (status);

} /* xlate_ext_srv_ctl */

/*===========================================================================

FUNCTION XLATE_EXT_TC_SRV_REDIR

DESCRIPTION
  This function translates a Service Redirection Message from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_srv_redir
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* For indexing through type specific bytes */
  word msg_pos;
    /* Position of record in message */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ftc_srv_redir_fix_type
  /* Set up MTYPE for PARAMS macro */

  if (len < sizeof(MTYPE))
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }

  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_srv_redir.hdr);

    msg_pos = FENDPOS(cai_ftc_srv_redir_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tc_srv_redir.hdr.msg_int,
         int_ptr->tc_srv_redir.msg_type,
         int_ptr->tc_srv_redir.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->tc_srv_redir.hdr, int_ptr->tc_srv_redir.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->tc_srv_redir.return_if_fail =
          (boolean) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, return_if_fail));
        msg_pos += FSIZ(MTYPE, return_if_fail);

        int_ptr->tc_srv_redir.delete_tmsi =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, delete_tmsi));
        msg_pos += FSIZ(MTYPE, delete_tmsi);

        int_ptr->tc_srv_redir.redirect_type =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, redirect_type));
        msg_pos += FSIZ(MTYPE, redirect_type);

        int_ptr->tc_srv_redir.record_type =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, record_type));
        msg_pos += FSIZ(MTYPE, record_type);

        int_ptr->tc_srv_redir.record_len =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, record_len));
        msg_pos += FSIZ(MTYPE, record_len);

        #undef MTYPE
        /* Done with this def for MTYPE */

        /* ---------------------
        ** Switch on record type
        ** --------------------- */
        switch (int_ptr->tc_srv_redir.record_type)
        {
          case CAI_NDSS_OFF_INDICATION:
            /* IS-95B, NDSS off, no type specific fields included */
            break;

          case CAI_ANALOG_REDIRECTION_REC:
            int_ptr->tc_srv_redir.redir.rec1.expected_sid =
              b_unpackw(buf_ptr, msg_pos,
              FSIZ(cai_redirect_rec1_type, expected_sid));
            msg_pos += FSIZ(cai_redirect_rec1_type, expected_sid);

            int_ptr->tc_srv_redir.redir.rec1.ignore_cdma =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_redirect_rec1_type, ignore_cdma));
            msg_pos += FSIZ(cai_redirect_rec1_type, ignore_cdma);

            int_ptr->tc_srv_redir.redir.rec1.sys_ordering =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_redirect_rec1_type, sys_ordering));
            msg_pos += FSIZ(cai_redirect_rec1_type, sys_ordering);
            int_ptr->tc_srv_redir.redir.rec1.max_redirect_delay = 0;
            break;

          case CAI_CDMA_REDIRECTION_REC:

            #define RTYPE cai_redirect_rec2_type

            int_ptr->tc_srv_redir.redir.rec2.band_class =
              b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, band_class));
            msg_pos += FSIZ(RTYPE, band_class);

            int_ptr->tc_srv_redir.redir.rec2.expected_sid =
              b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_sid));
            msg_pos += FSIZ(RTYPE, expected_sid);

            int_ptr->tc_srv_redir.redir.rec2.expected_nid =
              b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_nid));
            msg_pos += FSIZ(RTYPE, expected_nid);

            msg_pos += FSIZ(RTYPE, reserved);

            int_ptr->tc_srv_redir.redir.rec2.num_chans =
              b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, num_chans));
            msg_pos += FSIZ(RTYPE, num_chans);

            if ((word)(len - msg_pos) >=
                (int_ptr->tc_srv_redir.redir.rec2.num_chans * FSIZ(RTYPE, cdma_chan)))
            {
              for (i=0; (i < int_ptr->tc_srv_redir.redir.rec2.num_chans) &&
                   (i < CAI_MAX_CDMA_CHANS); i++)
              {
                int_ptr->tc_srv_redir.redir.rec2.cdma_chan[i] =
                  b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, cdma_chan));
                msg_pos += FSIZ(RTYPE, cdma_chan);
              }
            }
            else
            {
              status = CAIX_INV_MSG_S;
            }

            #undef RTYPE

            break;

          case CAI_JTACS_REDIRECTION_REC:
            int_ptr->tc_srv_redir.redir.rec4.expected_aid =
              b_unpackw(buf_ptr, msg_pos,
              FSIZ(cai_redirect_rec4_type, expected_aid));
            msg_pos += FSIZ(cai_redirect_rec4_type, expected_aid);

            int_ptr->tc_srv_redir.redir.rec4.ignore_cdma =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_redirect_rec4_type, ignore_cdma));
            msg_pos += FSIZ(cai_redirect_rec4_type, ignore_cdma);
            break;

          default:
            M1X_MSG( DCP, LEGACY_MED,
              "Invalid rec type %d",
              int_ptr->tc_srv_redir.record_type);
            status = CAIX_INV_MSG_S;
            break;
        } /* end of switch */
      }
    }
  }

  return (status);

} /* xlate_ext_tc_srv_redir */

/*===========================================================================

FUNCTION XLATE_EXT_SCAM

DESCRIPTION
  This function translates a Supplemental Channel Assignment Message from
  external to internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_scam
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word pi, ch;
    /* For indexing through type specific bytes */
  word msg_pos;
    /* Position of record in message */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_scam_fix1_type
  /* Set up MTYPE for PARAMS macro */

  status = CAIX_DONE_S;

  if (len < sizeof(MTYPE) - 7)
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }
  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->scam.fix.hdr);

    msg_pos = FENDPOS(cai_scam_fix1_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->scam.fix.hdr.msg_int,
         int_ptr->scam.fix.msg_type,
         int_ptr->scam.fix.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->scam.fix.hdr, int_ptr->scam.fix.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->scam.fix.use_retry_delay =
          (boolean) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, use_retry_delay));
        msg_pos +=  FSIZ(MTYPE, use_retry_delay);

        if (int_ptr->scam.fix.use_retry_delay)
        {
          int_ptr->scam.fix.retry_delay =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, retry_delay));
          msg_pos += FSIZ(MTYPE, retry_delay);
        }

        int_ptr->scam.fix.rev_included =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_included));
        msg_pos += FSIZ(MTYPE, rev_included);

        #undef MTYPE
        /* Done with this def for MTYPE */

        if (int_ptr->scam.fix.rev_included )
        {
          int_ptr->scam.fix.rev_dtx_duration =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, rev_dtx_duration));
          msg_pos += FSIZ(cai_scam_var1_type, rev_dtx_duration);

          int_ptr->scam.fix.expl_rev_start_tm =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, expl_rev_start_tm));
          msg_pos += FSIZ(cai_scam_var1_type, expl_rev_start_tm);

          if (int_ptr->scam.fix.expl_rev_start_tm)
          {
            int_ptr->scam.fix.rev_start_tm =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, rev_start_tm));
            msg_pos += FSIZ(cai_scam_var1_type, rev_start_tm);
          }

          int_ptr->scam.fix.use_rev_dur =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var1_type, use_rev_dur));
          msg_pos += FSIZ(cai_scam_var1_type, use_rev_dur);

          if (int_ptr->scam.fix.use_rev_dur)
          {
            int_ptr->scam.fix.rev_dur =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var1_type, rev_dur));
            msg_pos += FSIZ(cai_scam_var1_type, rev_dur);
          }

          int_ptr->scam.fix.use_rev_hdm_seq =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, use_rev_hdm_seq));
          msg_pos += FSIZ(cai_scam_var1_type, use_rev_hdm_seq);

          if (int_ptr->scam.fix.use_rev_hdm_seq)
          {
            int_ptr->scam.fix.rev_hdm_seq =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, rev_hdm_seq));
            msg_pos += FSIZ(cai_scam_var1_type, rev_hdm_seq);
          }

          int_ptr->scam.fix.num_rev_codes =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, num_rev_codes));
          msg_pos += FSIZ(cai_scam_var1_type, num_rev_codes);

          int_ptr->scam.fix.use_t_add_abt =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, use_t_add_abt));
          msg_pos += FSIZ(cai_scam_var1_type, use_t_add_abt);

          int_ptr->scam.fix.use_scrm_seq =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, use_scrm_seq));
          msg_pos += FSIZ(cai_scam_var1_type, use_scrm_seq);

          if (int_ptr->scam.fix.use_scrm_seq)
          {
            int_ptr->scam.fix.scrm_seq_num =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, scrm_seq_num));
            msg_pos += FSIZ(cai_scam_var1_type, scrm_seq_num);
          }

          int_ptr->scam.fix.rev_parms_inc =
            b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, rev_parms_inc));
          msg_pos += FSIZ(cai_scam_var1_type, rev_parms_inc);

          if (int_ptr->scam.fix.rev_parms_inc)
          {
            int_ptr->scam.fix.t_mulchan =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, t_mulchan));
            msg_pos += FSIZ(cai_scam_var1_type, t_mulchan);

            int_ptr->scam.fix.begin_pre =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, begin_pre));
            msg_pos += FSIZ(cai_scam_var1_type, begin_pre);

            int_ptr->scam.fix.resume_pre =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, resume_pre));
            msg_pos += FSIZ(cai_scam_var1_type, resume_pre);
          }
        }

        int_ptr->scam.fix.for_inc =
          b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_fix2_type, for_inc));
        msg_pos += FSIZ(cai_scam_fix2_type, for_inc);

        if (int_ptr->scam.fix.for_inc)
        {
          int_ptr->scam.fix.for_sup_config =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var2_type, for_sup_config));
          msg_pos += FSIZ(cai_scam_var2_type, for_sup_config);

          /* The following two fields are included if FOR_SUP_CONFIG==1or3,
          ** if the mobile is to start processing the channels.            */
          if ((int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_START) ||
              (int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_SPEC_START))
          {
            int_ptr->scam.fix.expl_for_start_tm = b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var2_type, expl_for_start_tm));
            msg_pos += FSIZ(cai_scam_var2_type, expl_for_start_tm);

            if (int_ptr->scam.fix.expl_for_start_tm)
            {
              int_ptr->scam.fix.for_start_tm =
                b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var2_type, for_start_tm));
              msg_pos += FSIZ(cai_scam_var2_type, for_start_tm);
            }
          }

          int_ptr->scam.fix.use_for_dur =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var2_type, use_for_dur));
          msg_pos += FSIZ(cai_scam_var2_type, use_for_dur);

          if (int_ptr->scam.fix.use_for_dur)
          {
            int_ptr->scam.fix.for_dur =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var2_type, for_dur));
            msg_pos += FSIZ(cai_scam_var2_type, for_dur);
          }

          /* The following two fields are included if FOR_SUP_CONFIG==1or3,
          ** if the mobile is to start processing the channels.             */
          if ((int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_START) ||
              (int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_SPEC_START))
          {
            int_ptr->scam.fix.use_for_hdm_seq =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var2_type, use_for_hdm_seq));
            msg_pos += FSIZ(cai_scam_var2_type, use_for_hdm_seq);

            if( int_ptr->scam.fix.use_for_hdm_seq )
            {
              int_ptr->scam.fix.for_hdm_seq = b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_scam_var2_type, for_hdm_seq));
              msg_pos += FSIZ(cai_scam_var2_type, for_hdm_seq);
            }
          }

          if ((int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_SPEC_STOP)||
              (int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_SPEC_START))
          {
            int_ptr->scam.fix.num_sup_plt = b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var3_type, num_sup_plt));

            if(int_ptr->scam.fix.num_sup_plt > CAI_MAX_SUP_PILOTS)
            {
              M1X_MSG( DCP, LEGACY_ERROR,
                "Unsupported num_sup_plt = %d is received",
                int_ptr->scam.fix.num_sup_plt);
              status = CAIX_INV_MSG_S;
              return status;
            }

            msg_pos += FSIZ(cai_scam_var3_type, num_sup_plt);

            int_ptr->scam.fix.num_sup =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var3_type, num_sup));
            msg_pos += FSIZ(cai_scam_var3_type, num_sup);

            for (pi=0; pi < int_ptr->scam.fix.num_sup_plt; pi++)
            {
              int_ptr->scam.var[pi].plt_pn =
                b_unpackw(buf_ptr, msg_pos, FSIZ(cai_scam_var4_type, plt_pn));
              msg_pos += FSIZ(cai_scam_var4_type, plt_pn);

              int_ptr->scam.var[pi].expl_code_chan = b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_scam_var4_type, expl_code_chan));
              msg_pos += FSIZ(cai_scam_var4_type, expl_code_chan);

              if (int_ptr->scam.var[pi].expl_code_chan)
              {
                for (ch=0; (ch<int_ptr->scam.fix.num_sup) && (ch < CAI_MAX_NUM_SUP); ch++)
                {
                  int_ptr->scam.var[pi].chan_lst.sup_code_chan[ch] =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_scam_var5_type, sup_code_chan));
                  msg_pos += FSIZ(cai_scam_var5_type, sup_code_chan);
                }
              }
              else
              {
                int_ptr->scam.var[pi].chan_lst.base_code_chan =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_scam_var6_type, base_code_chan));
                msg_pos += FSIZ(cai_scam_var6_type, base_code_chan);
              }
            } /* for each pilot */
          } /* if FOR_SUP_CONFIG */
        } /* if FOR_INCLUDED */
      }
    }
  }

  return (status);

} /* xlate_ext_scam */

/*===========================================================================

FUNCTION XLATE_EXT_TC_PWR_CTRL

DESCRIPTION
  This function translates a Traffic Channel Power Control
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Mobile Station Registered message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_pwr_ctrl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */

  word buf_pos = 0;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_pwr_ctrl_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( MTYPE))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->pwr_ctrl.hdr);

    buf_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &buf_pos, buf_ptr, &int_ptr->pwr_ctrl.hdr.msg_int,
         int_ptr->pwr_ctrl.msg_type,
         int_ptr->pwr_ctrl.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &buf_pos, buf_ptr,
          &int_ptr->pwr_ctrl.hdr, int_ptr->pwr_ctrl.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->pwr_ctrl.pwr_cntl_step =
          (byte) b_unpackd(buf_ptr, buf_pos, FSIZ(MTYPE, pwr_cntl_step));
        buf_pos += FSIZ(MTYPE, pwr_cntl_step);

        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
        {
          word i;

          int_ptr->pwr_ctrl.use_time = b_unpackb(buf_ptr, buf_pos,
            FSIZ(cai_pwr_ctrl_is2000_type, use_time));
          buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, use_time);

          if (int_ptr->pwr_ctrl.use_time)
          {
            int_ptr->pwr_ctrl.action_time = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, action_time));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, action_time);
          }

          int_ptr->pwr_ctrl.fpc_incl = b_unpackb(buf_ptr,buf_pos,
            FSIZ(cai_pwr_ctrl_is2000_type, fpc_incl));
          buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_incl);

          if (int_ptr->pwr_ctrl.fpc_incl)
          {
            int_ptr->pwr_ctrl.fpc_mode = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_mode));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_mode);

            int_ptr->pwr_ctrl.fpc_pri_chan = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_pri_chan));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_pri_chan);

            int_ptr->pwr_ctrl.fpc_olpc_fch_incl = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_olpc_fch_incl));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_olpc_fch_incl);

            if (int_ptr->pwr_ctrl.fpc_olpc_fch_incl)
            {
              int_ptr->pwr_ctrl.fpc_fch_fer = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_fer));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_fer);

              int_ptr->pwr_ctrl.fpc_fch_min_setpt = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_min_setpt));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_min_setpt);

              int_ptr->pwr_ctrl.fpc_fch_max_setpt = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_max_setpt));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_max_setpt);
            }

            int_ptr->pwr_ctrl.fpc_olpc_dcch_incl = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_olpc_dcch_incl));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_olpc_dcch_incl);

            if (int_ptr->pwr_ctrl.fpc_olpc_dcch_incl)
            {
              int_ptr->pwr_ctrl.fpc_dcch_fer = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_fer));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_fer);

              int_ptr->pwr_ctrl.fpc_dcch_min_setpt = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_min_setpt));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_min_setpt);

              int_ptr->pwr_ctrl.fpc_dcch_max_setpt = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_max_setpt));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_max_setpt);
            }

            if ((int_ptr->pwr_ctrl.fpc_mode == 1) ||
                (int_ptr->pwr_ctrl.fpc_mode == 2))
            {
              int_ptr->pwr_ctrl.fpc_sec_chan = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_sec_chan));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_sec_chan);
            }

            int_ptr->pwr_ctrl.num_sup = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, num_sup));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, num_sup);

            for (i=0; i<int_ptr->pwr_ctrl.num_sup && i<CAI_MAX_NUM_FOR_SCH; i++)
            {
              int_ptr->pwr_ctrl.sup_chns[i].sch_id =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_fpc_sup_chn_type, sch_id));
              buf_pos += FSIZ(cai_fpc_sup_chn_type, sch_id);

              int_ptr->pwr_ctrl.sup_chns[i].fpc_sch_fer =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_fpc_sup_chn_type, fpc_sch_fer));
              buf_pos += FSIZ(cai_fpc_sup_chn_type, fpc_sch_fer);

              int_ptr->pwr_ctrl.sup_chns[i].fpc_sch_min_setpt =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_fpc_sup_chn_type, fpc_sch_min_setpt));
              buf_pos += FSIZ(cai_fpc_sup_chn_type, fpc_sch_min_setpt);

              int_ptr->pwr_ctrl.sup_chns[i].fpc_sch_max_setpt =
                b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_fpc_sup_chn_type, fpc_sch_max_setpt));
              buf_pos += FSIZ(cai_fpc_sup_chn_type, fpc_sch_max_setpt);
            }

            int_ptr->pwr_ctrl.fpc_thresh_incl =
              b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_thresh_incl));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_thresh_incl);

            if (int_ptr->pwr_ctrl.fpc_thresh_incl)
            {
              int_ptr->pwr_ctrl.fpc_setpt_thresh =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_setpt_thresh));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_setpt_thresh);
            }

            int_ptr->pwr_ctrl.fpc_thresh_sch_incl =
              b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_thresh_sch_incl));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_thresh_sch_incl);

            if (int_ptr->pwr_ctrl.fpc_thresh_sch_incl)
            {
              int_ptr->pwr_ctrl.fpc_setpt_thresh_sch =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_setpt_thresh_sch));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_setpt_thresh_sch);
            }
          }

          int_ptr->pwr_ctrl.rpc_incl = b_unpackb(buf_ptr, buf_pos,
            FSIZ(cai_pwr_ctrl_is2000_type, rpc_incl));
          buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, rpc_incl);

          if (int_ptr->pwr_ctrl.rpc_incl)
          {
            word record_len;
            word start_pos;

            int_ptr->pwr_ctrl.rpc_num_rec = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, rpc_num_rec));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, rpc_num_rec);

            for (i=0; i<int_ptr->pwr_ctrl.rpc_num_rec &&
                      i<CAI_MAX_NUM_RPC_RECS; i++)
            {
              int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj_rec_type =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_rpc_type, rpc_adj_rec_type));
              buf_pos += FSIZ(cai_rpc_type, rpc_adj_rec_type);

              record_len = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_rpc_type, rpc_adj_rec_len));
              buf_pos += FSIZ(cai_rpc_type, rpc_adj_rec_len);

              start_pos = buf_pos;
              if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj_rec_type == CAI_CHAN_ADJ_GAIN)
              {
                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.fch_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj0_type, fch_incl));
                buf_pos += FSIZ(cai_rpc_adj0_type, fch_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.fch_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.fch_chan_adj_gain =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, fch_chan_adj_gain));
                  buf_pos += FSIZ(cai_rpc_adj0_type, fch_chan_adj_gain);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.dcch_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj0_type, dcch_incl));
                buf_pos += FSIZ(cai_rpc_adj0_type, dcch_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.dcch_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.dcch_chan_adj_gain =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, dcch_chan_adj_gain));
                  buf_pos += FSIZ(cai_rpc_adj0_type, dcch_chan_adj_gain);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch0_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj0_type, sch0_incl));
                buf_pos += FSIZ(cai_rpc_adj0_type, sch0_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch0_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch0_chan_adj_gain =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, sch0_chan_adj_gain));
                  buf_pos += FSIZ(cai_rpc_adj0_type, sch0_chan_adj_gain);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch1_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj0_type, sch1_incl));
                buf_pos += FSIZ(cai_rpc_adj0_type, sch1_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch1_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch1_chan_adj_gain =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, sch1_chan_adj_gain));
                  buf_pos += FSIZ(cai_rpc_adj0_type, sch1_chan_adj_gain);
                }

#if defined(FEATURE_IS2000_REL_C) || defined(FEATURE_IS2000_1X_ADV)

                #ifndef FEATURE_IS2000_1X_ADV
                if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
                #endif /* FEATURE_IS2000_1X_ADV */
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_ackch_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, rev_ackch_incl));
                  buf_pos += FSIZ(cai_rpc_adj0_type, rev_ackch_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_ackch_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_ackch_chan_adj_gain =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj0_type, rev_ackch_chan_adj_gain));
                    buf_pos += FSIZ(cai_rpc_adj0_type, rev_ackch_chan_adj_gain);
                  }
                }

#endif /* FEATURE_IS2000_REL_C || FEATURE_IS2000_1X_ADV  */

#ifdef FEATURE_IS2000_REL_C
                if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_cqich_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, rev_cqich_incl));
                  buf_pos += FSIZ(cai_rpc_adj0_type, rev_cqich_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_cqich_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_cqich_chan_adj_gain =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj0_type, rev_cqich_chan_adj_gain));
                    buf_pos += FSIZ(cai_rpc_adj0_type, rev_cqich_chan_adj_gain);
                  }
                }
#endif /* FEATURE_IS2000_REL_C */

              } /* if rpc_adj_rec_type == 0 */
              else if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj_rec_type == CAI_BASIC_RATE_ADJ_GAIN)
              {
                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_type =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_type));
                buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_type);

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_20ms_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj1_type, rc3_rc5_20ms_incl));
                buf_pos += FSIZ(cai_rpc_adj1_type, rc3_rc5_20ms_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_20ms_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1500 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1500));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1500);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_2700 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2700));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2700);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_4800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_9600 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc4_rc6_20ms_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj1_type, rc4_rc6_20ms_incl));
                buf_pos += FSIZ(cai_rpc_adj1_type, rc4_rc6_20ms_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc4_rc6_20ms_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_3600 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_7200 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_14400 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.five_ms_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj1_type, five_ms_incl));
                buf_pos += FSIZ(cai_rpc_adj1_type, five_ms_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.five_ms_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.norm_att_gain_9600_5ms =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, norm_att_gain_9600_5ms));
                  buf_pos += FSIZ(cai_rpc_adj1_type, norm_att_gain_9600_5ms);
                }

#ifdef FEATURE_IS2000_REL_A
                if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_40ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rc3_rc5_40ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rc3_rc5_40ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_40ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1350_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1350_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1350_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_2400_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2400_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2400_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_4800_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_9600_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600_40ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc6_40ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rc3_rc6_40ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rc3_rc6_40ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc6_40ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1800_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_3600_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_7200_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_14400_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400_40ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_80ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rc3_rc5_80ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rc3_rc5_80ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_80ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1200_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1200_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1200_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_2400_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2400_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2400_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_4800_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_9600_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600_80ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc6_80ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rc3_rc6_80ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rc3_rc6_80ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc6_80ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1800_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_3600_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_7200_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_14400_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400_80ms);
                  }
                } //if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
#endif /* FEATURE_IS2000_REL_A */

              } /* if rpc_adj_rec_type == 1 */
              else if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj_rec_type == CAI_HIGH_RATE_ADJ_GAIN)
              {
                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.code_type =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj2_type, code_type));
                buf_pos += FSIZ(cai_rpc_adj2_type, code_type);

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_type =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_type));
                buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_type);

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_20ms_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj2_type, rc3_rc5_20ms_incl));
                buf_pos += FSIZ(cai_rpc_adj2_type, rc3_rc5_20ms_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_20ms_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_19200 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_38400 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_38400));
                  buf_pos += FSIZ(cai_rpc_adj2_type,rl_att_adj_gain_38400);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_76800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_153600 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_307200 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_307200));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_307200);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_614400 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_614400));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_614400);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc4_rc6_20ms_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj2_type, rc4_rc6_20ms_incl));
                buf_pos += FSIZ(cai_rpc_adj2_type, rc4_rc6_20ms_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc4_rc6_20ms_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_28800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_57600 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_115200 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_230400 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_230400));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_230400);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_460800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_460800));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_460800);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_1036800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_1036800));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_1036800);
                }

#ifdef FEATURE_IS2000_REL_A
                if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_40ms_incl =
                    b_unpackb(buf_ptr,buf_pos,
                    FSIZ(cai_rpc_adj2_type, rc3_rc5_40ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rc3_rc5_40ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_40ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_19200_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_38400_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_38400_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_38400_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_76800_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_153600_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_307200_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                               FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_307200_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_307200_40ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc6_40ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rc3_rc6_40ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rc3_rc6_40ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc6_40ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_28800_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_57600_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_115200_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_230400_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_230400_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_230400_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_518400_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_518400_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_518400_40ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_80ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rc3_rc5_80ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rc3_rc5_80ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_80ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_19200_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_38400_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_38400_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_38400_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_76800_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_153600_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600_80ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc6_80ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rc3_rc6_80ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rc3_rc6_80ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc6_80ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_28800_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_57600_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_115200_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_259200_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_259200_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_259200_80ms);
                  }
                } //if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
#endif /* FEATURE_IS2000_REL_A */

              } /* if rpc_adj_rec_type == 2 */

#ifdef FEATURE_IS2000_REL_C
              else if ((int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj_rec_type == CAI_RCQICH_ADJ_GAIN)
                      && (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C))
               {
                 int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_type =
                   b_unpackb(buf_ptr, buf_pos,
                   FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_type));
                 buf_pos += FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_type);

                 int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_high_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_high_incl));
                 buf_pos += FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_high_incl);

                 if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_high_incl)
                 {
                   int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_high =
                     b_unpackb(buf_ptr, buf_pos,
                     FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_high));
                   buf_pos += FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_high);
                 }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_low_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_low_incl));
                buf_pos += FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_low_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_low_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_low =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_low));
                  buf_pos += FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_low);
                }
              } /* if p-rev >= 9 and rpc_adj_rec_type == 3 */
#endif /* FEATURE_IS2000_REL_C */

              buf_pos = start_pos + 8*record_len;
            } /* for each rpc_num_rec */
          } /* if rpc_incl */

        } /* if p_rev_in_use >= 6 */

        /* There is an error if we parsed beyond the length */
        if (buf_pos > len)
        {
          status = CAIX_INV_LEN_S;
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_pwr_ctrl */

/*===========================================================================

FUNCTION XLATE_ADD_PILOT_REC

DESCRIPTION
  This function translates a pilot record from external to internal
formats.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the caii_add_pilot_rec_type message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

void xlate_add_pilot_rec
(
  byte type,
    /* type of the pilot: 000 - 1X Common Pilot w/ TD
                          001 - 1X Aux Pilot
                          010 - 1x Aux Pilot w/ TD
                          011 - 3X Common Pilot
                          100 - 3x Aux Pilot */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  word pos,
    /* current position in the buffer */
  caii_add_pilot_rec_type *int_ptr
    /* Pointer to the destination pilot record */
)
{
  word ext_msg_pos = pos;

  switch(type)
  {
    case CAI_PILOT_REC_1X_COM_TD:

      UNPACKB_PG(rec0.td_power_level, cai_add_pilot_rec0_type, td_power_level);
      UNPACKB_PG(rec0.td_mode, cai_add_pilot_rec0_type, td_mode);
      break;

#ifdef FEATURE_IS2000_REL_A
    case CAI_PILOT_REC_1X_AUX:
      UNPACKB_PG(rec1.qof, cai_add_pilot_rec1_type, qof);
      UNPACKB_PG(rec1.walsh_length, cai_add_pilot_rec1_type, walsh_length);

      int_ptr->rec1.aux_pilot_walsh = b_unpackw(buf_ptr, ext_msg_pos,
        FSIZ(cai_add_pilot_rec1_type, aux_pilot_walsh) + int_ptr->rec1.walsh_length);
      ext_msg_pos += FSIZ(cai_add_pilot_rec1_type, aux_pilot_walsh) +
        int_ptr->rec1.walsh_length;
      break;

    case CAI_PILOT_REC_1X_AUX_TD:
      UNPACKB_PG(rec2.qof, cai_add_pilot_rec2_type, qof);
      UNPACKB_PG(rec2.walsh_length, cai_add_pilot_rec2_type, walsh_length);

      int_ptr->rec2.aux_walsh = b_unpackw(buf_ptr, ext_msg_pos,
        FSIZ(cai_add_pilot_rec2_type, aux_walsh) + int_ptr->rec2.walsh_length);
      ext_msg_pos += FSIZ(cai_add_pilot_rec2_type, aux_walsh) +
        int_ptr->rec2.walsh_length;

      UNPACKB_PG(rec2.aux_td_power_level, cai_add_pilot_rec2_type, aux_td_power_level);
      UNPACKB_PG(rec2.td_mode, cai_add_pilot_rec2_type, td_mode);
      break;

    case CAI_PILOT_REC_3X_COM:
      UNPACKB_PG(rec3.sr3_primary_pilot, cai_add_pilot_rec3_type, sr3_primary_pilot);
      UNPACKB_PG(rec3.sr3_pilot_power1, cai_add_pilot_rec3_type, sr3_pilot_power1);
      UNPACKB_PG(rec3.sr3_pilot_power2, cai_add_pilot_rec3_type, sr3_pilot_power2);
      break;

    case CAI_PILOT_REC_3X_AUX:
      UNPACKB_PG(rec4.sr3_primary_pilot, cai_add_pilot_rec4_type, sr3_primary_pilot);
      UNPACKB_PG(rec4.sr3_pilot_power1, cai_add_pilot_rec4_type, sr3_pilot_power1);
      UNPACKB_PG(rec4.sr3_pilot_power2, cai_add_pilot_rec4_type, sr3_pilot_power2);
      UNPACKB_PG(rec4.qof, cai_add_pilot_rec4_type, qof);
      UNPACKB_PG(rec4.walsh_length, cai_add_pilot_rec4_type, walsh_length);

      int_ptr->rec4.aux_pilot_walsh = b_unpackw(buf_ptr, ext_msg_pos,
        FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh) + int_ptr->rec4.walsh_length);
      ext_msg_pos += FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh) +
        int_ptr->rec4.walsh_length;

      UNPACKB_PG(rec4.add_info_incl1, cai_add_pilot_rec4_type, add_info_incl1);
      if (int_ptr->rec4.add_info_incl1)
      {
        UNPACKB_PG(rec4.qof1, cai_add_pilot_rec4_type, qof1);
        UNPACKB_PG(rec4.walsh_length1, cai_add_pilot_rec4_type, walsh_length1);

        int_ptr->rec4.aux_pilot_walsh1 = b_unpackw(buf_ptr, ext_msg_pos,
          FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh1) +
          int_ptr->rec4.walsh_length1);
        ext_msg_pos += FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh1) +
          int_ptr->rec4.walsh_length1;
      }

      UNPACKB_PG(rec4.add_info_incl2, cai_add_pilot_rec4_type, add_info_incl2);
      if (int_ptr->rec4.add_info_incl2)
      {
        UNPACKB_PG(rec4.qof2, cai_add_pilot_rec4_type, qof2);
        UNPACKB_PG(rec4.walsh_length2, cai_add_pilot_rec4_type, walsh_length2);

        int_ptr->rec4.aux_pilot_walsh2 = b_unpackw(buf_ptr, ext_msg_pos,
          FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh2) + int_ptr->rec4.walsh_length2);
        ext_msg_pos += FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh2) +
          int_ptr->rec4.walsh_length2;
      }

      break;
#endif /* FEATURE_IS2000_REL_A */

    } /*lint !e744: Switch statement has not default */

}

/*===========================================================================

FUNCTION XLATE_EXT_ADD_PILOT_REC

DESCRIPTION
  This function translates a pilot record from internal to external
formats.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_add_pilot_rec
(
  byte type,
  /* type of the pilot: 000 - 1X Common Pilot w/ TD
                        001 - 1X Aux Pilot
                        010 - 1x Aux Pilot w/ TD
                        011 - 3X Common Pilot
                        100 - 3x Aux Pilot */
  caii_add_pilot_rec_type *rec_ptr,
    /* Pointer to the source pilot record */
  word *len_ptr,
  /* Pointer to length of the pilot record header in bits */
  byte *buf_ptr
  /* Pointer to where packed pilot record type should be placed */
)
{
#ifdef FEATURE_IS2000_REL_A
    byte reserve_bits;
#endif /* FEATURE_IS2000_REL_A */

    switch (type)
    {
      case 0: /* 000 - 1X Common Pilot with TD */
        b_packb( rec_ptr->rec0.td_power_level,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec0_type,td_power_level));
        *len_ptr += FSIZ( cai_add_pilot_rec0_type,td_power_level );

        b_packb( rec_ptr->rec0.td_mode,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec0_type,td_mode));
        *len_ptr += FSIZ( cai_add_pilot_rec0_type,td_mode );

        b_packb( 0,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec0_type,reserved));
        *len_ptr += FSIZ( cai_add_pilot_rec0_type,reserved );

        break;

#ifdef FEATURE_IS2000_REL_A
      case 1: /* 001 - 1X Auxiliary Pilot */
        b_packb( rec_ptr->rec1.qof,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec1_type,qof));
        *len_ptr += FSIZ( cai_add_pilot_rec1_type,qof );

        b_packb( rec_ptr->rec1.walsh_length,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec1_type,walsh_length));
        *len_ptr += FSIZ( cai_add_pilot_rec1_type,walsh_length );

        /* if the aux walsh is less than 3, pack a byte */
        b_packw( rec_ptr->rec1.aux_pilot_walsh, buf_ptr,
                   *len_ptr,
                   rec_ptr->rec1.walsh_length  + 6);

        *len_ptr += rec_ptr->rec1.walsh_length  + 6;

        /* Calculate the length of reserved bits */
        reserve_bits = (sizeof(cai_add_pilot_rec1_type) +
                            rec_ptr->rec1.walsh_length)
                           %8;

        if( reserve_bits != 0 )
        {
          reserve_bits = 8 - reserve_bits;

          /* Pack reserved bits */
          b_packb( 0, buf_ptr, *len_ptr, reserve_bits );
          *len_ptr += reserve_bits;
        }

        break;

      case 2: /* 010 - 1 Auxiliary Pilot with Transmit Diversity */

        b_packb( rec_ptr->rec2.qof,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec2_type,qof));
        *len_ptr += FSIZ( cai_add_pilot_rec2_type,qof );

        b_packb( rec_ptr->rec2.walsh_length,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec2_type,walsh_length));
        *len_ptr += FSIZ( cai_add_pilot_rec2_type,walsh_length );

        b_packw( rec_ptr->rec2.aux_walsh,
            buf_ptr, *len_ptr, rec_ptr->rec2.walsh_length + 6);
        *len_ptr += rec_ptr->rec2.walsh_length + 6;

        b_packb( rec_ptr->rec2.aux_td_power_level,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec2_type,aux_td_power_level));
        *len_ptr += FSIZ( cai_add_pilot_rec2_type,aux_td_power_level );

        b_packw( rec_ptr->rec2.td_mode,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec2_type,td_mode));
        *len_ptr += FSIZ( cai_add_pilot_rec2_type,td_mode );

        reserve_bits = (sizeof(cai_add_pilot_rec2_type) +
                            rec_ptr->rec2.walsh_length)
                           %8;

        if( reserve_bits != 0 )
        {
          reserve_bits = 8 - reserve_bits;

          /* Pack reserved bits */
          b_packb( 0, buf_ptr, *len_ptr, reserve_bits );
          *len_ptr += reserve_bits;
        }

        break;

      case 3: /* 011 - 3X Common Pilot */

        b_packb( rec_ptr->rec3.sr3_primary_pilot,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec3_type,sr3_primary_pilot));
        *len_ptr += FSIZ( cai_add_pilot_rec3_type,sr3_primary_pilot );

        b_packb( rec_ptr->rec3.sr3_pilot_power1,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec3_type,sr3_pilot_power1));
        *len_ptr += FSIZ( cai_add_pilot_rec3_type,sr3_pilot_power1 );

        b_packb( rec_ptr->rec3.sr3_pilot_power2,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec3_type,sr3_pilot_power2));
        *len_ptr += FSIZ( cai_add_pilot_rec3_type,sr3_pilot_power2 );

        break;

      case 4: /* 100 - 3X Auxiliary Pilot */

        b_packb( rec_ptr->rec4.sr3_primary_pilot,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,sr3_primary_pilot));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,sr3_primary_pilot );

        b_packb( rec_ptr->rec4.sr3_pilot_power1,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,sr3_pilot_power1));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,sr3_pilot_power1 );

        b_packb( rec_ptr->rec4.sr3_pilot_power2,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,sr3_pilot_power2));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,sr3_pilot_power2 );

        b_packb( rec_ptr->rec4.qof,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,qof));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,qof );

        b_packb( rec_ptr->rec4.walsh_length,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,walsh_length));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,walsh_length );

        /* if the aux walsh is less than 3, pack a byte */
        b_packw( rec_ptr->rec4.aux_pilot_walsh, buf_ptr,
                 *len_ptr,
                 rec_ptr->rec4.walsh_length  + 6);
        *len_ptr += rec_ptr->rec4.walsh_length  + 6;

        b_packb( rec_ptr->rec4.add_info_incl1,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,add_info_incl1));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,add_info_incl1 );

        if (rec_ptr->rec4.add_info_incl1)
        {
          b_packb( rec_ptr->rec4.qof1,
             buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,qof1));
          *len_ptr += FSIZ( cai_add_pilot_rec4_type,qof1 );

          b_packb( rec_ptr->rec4.walsh_length1,
            buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,walsh_length1));
          *len_ptr += FSIZ( cai_add_pilot_rec4_type,walsh_length1 );

          b_packw( rec_ptr->rec4.aux_pilot_walsh1, buf_ptr,
                   *len_ptr,
                   rec_ptr->rec4.walsh_length1 + 6);
          *len_ptr += rec_ptr->rec4.walsh_length1 + 6;
        }

        b_packb( rec_ptr->rec4.add_info_incl2,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,add_info_incl2));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,add_info_incl2 );

        if (rec_ptr->rec4.add_info_incl2)
        {
          b_packb( rec_ptr->rec4.qof2,
            buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,qof2));
          *len_ptr += FSIZ( cai_add_pilot_rec4_type,qof2 );

          b_packb( rec_ptr->rec4.walsh_length2,
            buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,walsh_length2));
          *len_ptr += FSIZ( cai_add_pilot_rec4_type,walsh_length2 );

          b_packw( rec_ptr->rec4.aux_pilot_walsh2, buf_ptr,
                     *len_ptr,
                     rec_ptr->rec4.walsh_length2 + 6);

          *len_ptr += rec_ptr->rec4.aux_pilot_walsh2 + 6;

          /* Calculate the length of reserved bits */
          reserve_bits = (sizeof(cai_add_pilot_rec4_type) +
                              rec_ptr->rec4.walsh_length +
                              rec_ptr->rec4.walsh_length1 +
                              rec_ptr->rec4.walsh_length2 )
                             %8;

          if( reserve_bits != 0 )
          {
            reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
            b_packb( 0, buf_ptr, *len_ptr, reserve_bits );
            *len_ptr += reserve_bits;
          }

        }
        break;
#endif /* FEATURE_IS2000_REL_A */

    } /*lint !e744: Switch statement has not default */
    return TRUE;
}

/*===========================================================================

FUNCTION XLATE_EXT_EXT_NLU

DESCRIPTION
  This function translates a Traffic Channel Extended Neighbor List Update
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Neighbor List Update message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_ext_nlu
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through neighbors */
  word msg_pos = 0;
    /* Position of record in message */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_ext_nlu_fix_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length, size of fixed type,
  ** without dependent fields.
  ** -------------------------------------------- */
  if (len < (sizeof(MTYPE)
             - FSIZ(MTYPE, global_timing_incl)
             - FSIZ(MTYPE, global_tx_duration)
             - FSIZ(MTYPE, global_tx_period)))
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->ext_nlu.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->ext_nlu.hdr.msg_int,
         int_ptr->ext_nlu.msg_type,
         int_ptr->ext_nlu.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->ext_nlu.hdr, int_ptr->ext_nlu.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->ext_nlu.pilot_inc =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, pilot_inc));
        msg_pos += FSIZ(MTYPE, pilot_inc);

        int_ptr->ext_nlu.nghbr_srch_mode =
          (boolean) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, nghbr_srch_mode));
        msg_pos += FSIZ(MTYPE, nghbr_srch_mode);

        int_ptr->ext_nlu.srch_win_n =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, srch_win_n));
        msg_pos += FSIZ(MTYPE, srch_win_n);

        int_ptr->ext_nlu.use_timing =
          (boolean) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, use_timing));
        msg_pos += FSIZ(MTYPE, use_timing);


        /* Begin unpacking dependent fields */
        if (int_ptr->ext_nlu.use_timing)
        {
          int_ptr->ext_nlu.global_timing_incl =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, global_timing_incl));
          msg_pos += FSIZ(MTYPE, global_timing_incl);

          if (int_ptr->ext_nlu.global_timing_incl)
          {
            int_ptr->ext_nlu.global_tx_duration =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, global_tx_duration));
            msg_pos += FSIZ(MTYPE, global_tx_duration);

            int_ptr->ext_nlu.global_tx_period =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, global_tx_period));
            msg_pos += FSIZ(MTYPE, global_tx_period);
          }
        }

        int_ptr->ext_nlu.num_nghbr =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_nghbr));
        msg_pos += FSIZ(MTYPE, num_nghbr);

        for (i=0; (i < int_ptr->ext_nlu.num_nghbr) &&
                  (i < CAI_EXT_NLU_MAX); i++)
        {
          int_ptr->ext_nlu.nghbr[i].nghbr_pn =
            b_unpackw(buf_ptr, msg_pos,
            FSIZ(cai_ext_nlu_var_type, nghbr_pn));
          msg_pos += FSIZ(cai_ext_nlu_var_type, nghbr_pn);

          if (int_ptr->ext_nlu.nghbr_srch_mode == SRCH_PRI_AND_WIN ||
              int_ptr->ext_nlu.nghbr_srch_mode == SRCH_PRI_ONLY)
          {
            int_ptr->ext_nlu.nghbr[i].search_pri =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_var_type, search_pri));
            msg_pos += FSIZ(cai_ext_nlu_var_type, search_pri);
          }

          if (int_ptr->ext_nlu.nghbr_srch_mode == SRCH_PRI_AND_WIN ||
              int_ptr->ext_nlu.nghbr_srch_mode == SRCH_WIN_ONLY)
          {
            int_ptr->ext_nlu.nghbr[i].srch_win_nghbr =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_var_type, srch_win_nghbr));
            msg_pos += FSIZ(cai_ext_nlu_var_type, srch_win_nghbr);
          }

          if (int_ptr->ext_nlu.use_timing)
          {
            int_ptr->ext_nlu.nghbr[i].timing_incl =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_var_type, timing_incl));
            msg_pos += FSIZ(cai_ext_nlu_var_type, timing_incl);

            if (int_ptr->ext_nlu.nghbr[i].timing_incl)
            {
              int_ptr->ext_nlu.nghbr[i].nghbr_tx_offset =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_var_type, nghbr_tx_offset));
              msg_pos += FSIZ(cai_ext_nlu_var_type, nghbr_tx_offset);

              /* Parse the following if GLOBAL_TIMING_INCL is zero. */
              if (!(int_ptr->ext_nlu.global_timing_incl))
              {
                int_ptr->ext_nlu.nghbr[i].nghbr_tx_duration =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_ext_nlu_var_type, nghbr_tx_duration));
                msg_pos += FSIZ(cai_ext_nlu_var_type, nghbr_tx_duration);

                int_ptr->ext_nlu.nghbr[i].nghbr_tx_period =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_ext_nlu_var_type, nghbr_tx_period));
                msg_pos += FSIZ(cai_ext_nlu_var_type, nghbr_tx_period);
              }
            }
          }
        }

        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
        {
          int_ptr->ext_nlu.srch_offset_incl =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_ext_nlu_fix_is2000_type, srch_offset_incl));
          msg_pos += FSIZ(cai_ext_nlu_fix_is2000_type, srch_offset_incl);

          for (i=0; (i < int_ptr->ext_nlu.num_nghbr) &&
                    (i < CAI_EXT_NLU_MAX); i++)
          {
            int_ptr->ext_nlu.add_nghbr[i].add_pilot_rec_incl =
               b_unpackb(buf_ptr, msg_pos,
               FSIZ(cai_ext_nlu_var_is2000_type, add_pilot_rec_incl));
            msg_pos += FSIZ(cai_ext_nlu_var_is2000_type, add_pilot_rec_incl);

            if (int_ptr->ext_nlu.add_nghbr[i].add_pilot_rec_incl)
            {
              word record_len = 0;
              word record_start_pos = 0;

              int_ptr->ext_nlu.add_nghbr[i].nghbr_pilot_rec_type =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_var_is2000_type, nghbr_pilot_rec_type));
              msg_pos += FSIZ(cai_ext_nlu_var_is2000_type, nghbr_pilot_rec_type);

              record_len = b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_var_is2000_type, record_len));
              msg_pos += FSIZ(cai_ext_nlu_var_is2000_type, record_len);

              record_start_pos = msg_pos;

              xlate_add_pilot_rec(int_ptr->ext_nlu.add_nghbr[i].nghbr_pilot_rec_type,
                                  buf_ptr, msg_pos,
                                  &(int_ptr->ext_nlu.add_nghbr[i].add_pilot_rec));
              msg_pos = record_start_pos + record_len * 8;
            }

            if ((int_ptr->ext_nlu.srch_offset_incl) &&
                (int_ptr->ext_nlu.nghbr_srch_mode == SRCH_PRI_AND_WIN ||
                 int_ptr->ext_nlu.nghbr_srch_mode == SRCH_WIN_ONLY))
            {
              int_ptr->ext_nlu.add_nghbr[i].srch_offset_nghbr =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_var_is2000_type, srch_offset_nghbr));
              msg_pos += FSIZ(cai_ext_nlu_var_is2000_type,srch_offset_nghbr);
            }
          }
        } /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000) */

#ifdef FEATURE_IS2000_REL_B
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
        {
          int_ptr->ext_nlu.resq_enabled =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_ext_nlu_fix_rel_b_type, resq_enabled));
          msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_enabled);

          if (int_ptr->ext_nlu.resq_enabled)
          {
            int_ptr->ext_nlu.resq_delay_time = b_unpackb(buf_ptr, msg_pos,
             FSIZ(cai_ext_nlu_fix_rel_b_type, resq_delay_time));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_delay_time);

            int_ptr->ext_nlu.resq_allowed_time = b_unpackb(buf_ptr, msg_pos,
             FSIZ(cai_ext_nlu_fix_rel_b_type, resq_allowed_time));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_allowed_time);

            int_ptr->ext_nlu.resq_attempt_time = b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_attempt_time ));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_attempt_time);

            int_ptr->ext_nlu.resq_code_chan = b_unpackw(buf_ptr, msg_pos,
             FSIZ(cai_ext_nlu_fix_rel_b_type, resq_code_chan));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_code_chan);

            int_ptr->ext_nlu.resq_qof = b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_qof));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_qof);

            int_ptr->ext_nlu.resq_min_period_incl = b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_min_period_incl ));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_min_period_incl);

            if (int_ptr->ext_nlu.resq_min_period_incl)
            {
              int_ptr->ext_nlu.resq_min_period = b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_fix_rel_b_type, resq_min_period));
              msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_min_period);
            }

            int_ptr->ext_nlu.resq_num_tot_trans_incl =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_incl));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_incl);

            if (int_ptr->ext_nlu.resq_num_tot_trans_incl)
            {
              int_ptr->ext_nlu.resq_num_tot_trans_20ms =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_20ms));
              msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_20ms);

              int_ptr->ext_nlu.resq_num_tot_trans_5ms =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_5ms ));
              msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_5ms);
            }

            int_ptr->ext_nlu.resq_num_preamble =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_preamble));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_preamble);

            int_ptr->ext_nlu.resq_power_delta =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_power_delta));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_power_delta);

            for ( i=0; (i < int_ptr->ext_nlu.num_nghbr) && (i < CAI_EXT_NLU_MAX); i++)
            {
              int_ptr->ext_nlu.resq[i].nghbr_resq_configured =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_var_rel_b_type, nghbr_resq_configured));
              msg_pos += FSIZ(cai_ext_nlu_var_rel_b_type, nghbr_resq_configured);
            }
          } /* if (int_ptr->ext_nlu.resq_enabled) */
        } /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B) */
#endif /* FEATURE_IS2000_REL_B */

      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_ext_nlu */

/*===========================================================================

FUNCTION XLATE_EXT_TC_CFS_REQ

DESCRIPTION
  This function translates a Traffic Channel Candidate Frequency Search Request
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Candidate Frequency Search Request
  message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_cfs_req
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through neighbors */
  word msg_pos;
    /* Position of record in message */

  word fix_len;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_cfs_req_fix_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(MTYPE ) + sizeof(cai_cfs_mod1_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {

    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->cfs_req.fix.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->cfs_req.fix.hdr.msg_int,
         int_ptr->cfs_req.fix.msg_type,
         int_ptr->cfs_req.fix.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->cfs_req.fix.hdr, int_ptr->cfs_req.fix.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->cfs_req.fix.pre_proc_done = FALSE;

        int_ptr->cfs_req.fix.use_time =
          (boolean) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
        msg_pos += FSIZ(MTYPE, use_time);

        int_ptr->cfs_req.fix.action_time =
          b_unpackb(buf_ptr, msg_pos,FSIZ(MTYPE, action_time));
        msg_pos += FSIZ(MTYPE, action_time );

        /* skip over reserved bits */
        msg_pos += FSIZ(MTYPE, reserved);

        int_ptr->cfs_req.fix.cfsrm_seq =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, cfsrm_seq));
        msg_pos += FSIZ(MTYPE, cfsrm_seq);

        int_ptr->cfs_req.fix.srch_type =
          b_unpackb(buf_ptr, msg_pos,FSIZ(MTYPE, srch_type));
        msg_pos += FSIZ(MTYPE, srch_type);

        int_ptr->cfs_req.fix.srch_period =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, srch_period));
        msg_pos += FSIZ(MTYPE, srch_period);

        int_ptr->cfs_req.fix.srch_mode =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, srch_mode));
        msg_pos += FSIZ(MTYPE, srch_mode);

        int_ptr->cfs_req.fix.mod_sp_len =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, mod_sp_len));
        msg_pos += FSIZ( cai_cfs_req_fix_type, mod_sp_len);

        fix_len = msg_pos;

        if (len - msg_pos < int_ptr->cfs_req.fix.mod_sp_len)
        {
          status = CAIX_INV_LEN_S;
        }
        else
        {
          /* Mode-Specific Fields */
          switch (int_ptr->cfs_req.fix.srch_mode)
          {
            case CAI_CF_SRCH_TYPE_CDMA:
              int_ptr->cfs_req.var.mod0.band_class =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, band_class));
              msg_pos += FSIZ( cai_cfs_mod0_fix_type, band_class);

              int_ptr->cfs_req.var.mod0.cdma_freq =
                b_unpackw(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, cdma_freq));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, cdma_freq);

              int_ptr->cfs_req.var.mod0.sf_total_ec_thresh =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, sf_total_ec_thresh));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, sf_total_ec_thresh);

              int_ptr->cfs_req.var.mod0.sf_total_ec_io_thresh =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, sf_total_ec_io_thresh));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, sf_total_ec_io_thresh);

              int_ptr->cfs_req.var.mod0.diff_rx_pwr_thresh =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, diff_rx_pwr_thresh));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, diff_rx_pwr_thresh);

              int_ptr->cfs_req.var.mod0.min_total_pilot_ecio =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, min_total_pilot_ecio));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, min_total_pilot_ecio);

              int_ptr->cfs_req.var.mod0.cf_t_add =
                b_unpackb(buf_ptr, msg_pos,
                       FSIZ(cai_cfs_mod0_fix_type, cf_t_add));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, cf_t_add);

              int_ptr->cfs_req.var.mod0.tf_wait_time =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, tf_wait_time));
              msg_pos += FSIZ( cai_cfs_mod0_fix_type, tf_wait_time);

              int_ptr->cfs_req.var.mod0.cf_pilot_inc =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, cf_pilot_inc));
              msg_pos += FSIZ( cai_cfs_mod0_fix_type, cf_pilot_inc);

              int_ptr->cfs_req.var.mod0.cf_srch_win_n =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, cf_srch_win_n));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, cf_srch_win_n);

              int_ptr->cfs_req.var.mod0.cf_srch_win_r =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, cf_srch_win_r));
              msg_pos += FSIZ( cai_cfs_mod0_fix_type, cf_srch_win_r);

              msg_pos += FSIZ( cai_cfs_mod0_fix_type, reserved );

              int_ptr->cfs_req.var.mod0.pilot_update =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, pilot_update));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, pilot_update);

              if (int_ptr->cfs_req.var.mod0.pilot_update)
              {
                int_ptr->cfs_req.var.mod0.num_pilot =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_cfs_mod0_fix_type, num_pilot));
                msg_pos += FSIZ(cai_cfs_mod0_fix_type, num_pilot);

                int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_cfs_mod0_fix_type, cf_nghbr_srch_mode));
                msg_pos += FSIZ(cai_cfs_mod0_fix_type, cf_nghbr_srch_mode);

                if (int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode <=
                    SRCH_PRI_AND_WIN)
                {
                  for (i=0; (i<int_ptr->cfs_req.var.mod0.num_pilot)
                            && (i<CAI_CFSREQ_REC_MAX) ; i++)
                  {
                    int_ptr->cfs_req.var.mod0.pilot_update_rec[i].nghbr_pn =
                      b_unpackw(buf_ptr, msg_pos,
                      FSIZ(cai_cfs_mod0_var_type, nghbr_pn));
                    msg_pos += FSIZ(cai_cfs_mod0_var_type, nghbr_pn);

                    int_ptr->cfs_req.var.mod0.pilot_update_rec[i].search_set =
                      (boolean) b_unpackw(buf_ptr, msg_pos,
                      FSIZ(cai_cfs_mod0_var_type, search_set));
                    msg_pos += FSIZ(cai_cfs_mod0_var_type, search_set);

                    if (int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode ==
                        SRCH_PRI_AND_WIN ||
                        int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode ==
                        SRCH_PRI_ONLY)
                    {
                      int_ptr->cfs_req.var.mod0.pilot_update_rec[i].search_priority =
                        (byte) b_unpackw(buf_ptr, msg_pos,
                        FSIZ(cai_cfs_mod0_var_type, search_priority));
                      msg_pos += FSIZ(cai_cfs_mod0_var_type, search_priority);
                    }

                    if (int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode ==
                        SRCH_PRI_AND_WIN ||
                        int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode ==
                        SRCH_WIN_ONLY)
                    {
                      int_ptr->cfs_req.var.mod0.pilot_update_rec[i].srch_win_nghbr =
                        (byte) b_unpackw(buf_ptr, msg_pos,
                        FSIZ(cai_cfs_mod0_var_type, srch_win_nghbr));
                      msg_pos += FSIZ(cai_cfs_mod0_var_type, srch_win_nghbr);
                    }
                  }
                }
              } /* check for Pilot Update is 1 */

             #define VTYPE cai_cfs_req_is2000_rec_var_type
             if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
             {
               word j;

               int_ptr->cfs_req.var.mod0.cf_srch_offset_incl =
                 b_unpackb(buf_ptr, msg_pos,
                 FSIZ(cai_cfs_req_is2000_type, cf_srch_offset_incl));
               msg_pos += FSIZ(cai_cfs_req_is2000_type, cf_srch_offset_incl);

               if (int_ptr->cfs_req.var.mod0.pilot_update )
               {
                 for (j=0; j<int_ptr->cfs_req.var.mod0.num_pilot && j<CAI_CFSREQ_REC_MAX; j++)
                 {
                   int_ptr->cfs_req.var.mod0.add_nghbr[j].add_pilot_rec_incl =
                     b_unpackb(buf_ptr, msg_pos,
                     FSIZ(cai_cfs_req_is2000_rec_fix_type, add_pilot_rec_incl));
                   msg_pos += FSIZ(cai_cfs_req_is2000_rec_fix_type, add_pilot_rec_incl);

                   if (int_ptr->cfs_req.var.mod0.add_nghbr[j].add_pilot_rec_incl)
                   {

                     word record_len = 0;
                     word record_start_pos = 0;

                     int_ptr->cfs_req.var.mod0.add_nghbr[j].nghbr_pilot_rec_type =
                       b_unpackb(buf_ptr, msg_pos,
                       FSIZ(VTYPE, nghbr_pilot_rec_type));
                     msg_pos += FSIZ(VTYPE, nghbr_pilot_rec_type);

                     record_len = b_unpackb(buf_ptr, msg_pos,
                       FSIZ(VTYPE,record_len));
                     msg_pos += FSIZ(VTYPE, record_len);

                     record_start_pos = msg_pos;

                     xlate_add_pilot_rec(int_ptr->cfs_req.var.mod0.add_nghbr[j].nghbr_pilot_rec_type,
                                         buf_ptr, msg_pos,
                                         &(int_ptr->cfs_req.var.mod0.add_nghbr[j].add_pilot_rec));

                     msg_pos = record_start_pos + record_len * 8;
                   }

                   if ((int_ptr->cfs_req.var.mod0.cf_srch_offset_incl) &&
                       ((int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode == SRCH_PRI_AND_WIN) ||
                        (int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode == SRCH_WIN_ONLY)))
                   {
                     int_ptr->cfs_req.var.mod0.add_nghbr[j].srch_offset_nghbr =
                       b_unpackb(buf_ptr, msg_pos, FSIZ(VTYPE, srch_offset_nghbr));
                     msg_pos += FSIZ(VTYPE, srch_offset_nghbr);
                   }
                 }
               } /* Checking for Pilot_Update = 1 */
             } /* If CAIX_P_REV_IS2000 checking */

             #undef VTYPE

             break;

           case CAI_CF_SRCH_TYPE_ANALOG:
             int_ptr->cfs_req.var.mod1.band_class =
               b_unpackb(buf_ptr, msg_pos,
               FSIZ(cai_cfs_mod1_fix_type, band_class));
             msg_pos += FSIZ(cai_cfs_mod1_fix_type, band_class);

             int_ptr->cfs_req.var.mod1.sf_total_ec_thresh =
               b_unpackb(buf_ptr, msg_pos,
               FSIZ(cai_cfs_mod1_fix_type, sf_total_ec_thresh));
             msg_pos += FSIZ(cai_cfs_mod1_fix_type, sf_total_ec_thresh);

             int_ptr->cfs_req.var.mod1.sf_total_ec_io_thresh =
               b_unpackb(buf_ptr, msg_pos,
               FSIZ(cai_cfs_mod1_fix_type, sf_total_ec_io_thresh));
             msg_pos += FSIZ(cai_cfs_mod1_fix_type, sf_total_ec_io_thresh);

             msg_pos += FSIZ(cai_cfs_mod1_fix_type, reserved );

             int_ptr->cfs_req.var.mod1.num_analog_freqs =
               b_unpackb(buf_ptr, msg_pos,
               FSIZ(cai_cfs_mod1_fix_type, num_analog_freqs));
             msg_pos += FSIZ(cai_cfs_mod1_fix_type, num_analog_freqs);

             for (i=0; (i<int_ptr->cfs_req.var.mod1.num_analog_freqs)
                       && (i<CAI_CFS_ANALOG_MAX); i++)
             {
               int_ptr->cfs_req.var.mod1.analog_freq[i] =
                 b_unpackw(buf_ptr, msg_pos,
                 FSIZ(cai_cfs_mod1_var_type, analog_freq));
               msg_pos += FSIZ( cai_cfs_mod1_var_type, analog_freq);
             }
             break;

           default:
             M1X_MSG( DCP, LEGACY_MED,
               "Invalid srch mode %d",
               int_ptr->cfs_req.fix.srch_mode);
             status = CAIX_INV_MSG_S;
             break;
          } /* switch*/

          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            // Append the Length with necessary Reserved.
            msg_pos = fix_len + int_ptr->cfs_req.fix.mod_sp_len * 8;

            int_ptr->cfs_req.align_timing =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_cfs_req_type, align_timing));
            msg_pos += FSIZ(cai_cfs_req_type,align_timing);

            if (int_ptr->cfs_req.align_timing)
            {
              int_ptr->cfs_req.search_offset =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_req_type, search_offset));
              msg_pos += FSIZ(cai_cfs_req_type,search_offset);
            }
          }
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_cfs_req */

/*===========================================================================

FUNCTION XLATE_EXT_TC_CFS_CTRL

DESCRIPTION
  This function translates a Traffic Channel Candidate Frequency Control
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Candidate Frequency Control
  message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_cfs_ctrl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_cfs_ctrl_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(MTYPE))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->cfs_ctrl.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->cfs_ctrl.hdr.msg_int,
         int_ptr->cfs_ctrl.msg_type,
         int_ptr->cfs_ctrl.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->cfs_ctrl.hdr, int_ptr->cfs_ctrl.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->cfs_ctrl.use_time =
          (boolean) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
        msg_pos += FSIZ(MTYPE, use_time);

        int_ptr->cfs_ctrl.action_time =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
        msg_pos += FSIZ(MTYPE, action_time);

        int_ptr->cfs_ctrl.cfscm_seq =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, cfscm_seq));
        msg_pos += FSIZ(MTYPE, cfscm_seq);

        int_ptr->cfs_ctrl.srch_type =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, srch_type));
        msg_pos += FSIZ(MTYPE, srch_type);

        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
        {
          int_ptr->cfs_ctrl.align_timing =
            (boolean) b_unpackd( buf_ptr, msg_pos, FSIZ(MTYPE, align_timing));
          msg_pos += FSIZ(MTYPE, align_timing);
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_cfs_ctrl */

/*===========================================================================

FUNCTION XLATE_EXT_TC_PUF

DESCRIPTION
  This function translates a Power Up Function
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Power Up Function
  message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_puf
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position of record in message */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_puf_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < FENDPOS( MTYPE, puf_freq_incl))
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->puf.hdr);

    msg_pos = FENDPOS(cai_puf_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->puf.hdr.msg_int,
         int_ptr->puf.msg_type,
         int_ptr->puf.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->puf.hdr, int_ptr->puf.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->puf.use_time =
          (boolean) b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, use_time));
        msg_pos += FSIZ(cai_puf_type, use_time);

        int_ptr->puf.action_time =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, action_time));
        msg_pos += FSIZ(cai_puf_type, action_time);

        int_ptr->puf.act_tm_frm =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, act_tm_frm));
        msg_pos += FSIZ(cai_puf_type, act_tm_frm);

        int_ptr->puf.puf_setup_sz =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_setup_sz));
        msg_pos += FSIZ(cai_puf_type, puf_setup_sz);

        int_ptr->puf.puf_pulse_sz =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_pulse_sz));
        msg_pos += FSIZ(cai_puf_type, puf_pulse_sz);

        int_ptr->puf.puf_interval =
          b_unpackw(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_interval));
        msg_pos += FSIZ(cai_puf_type, puf_interval);

        int_ptr->puf.puf_init_pwr =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_init_pwr));
        msg_pos += FSIZ(cai_puf_type, puf_init_pwr);

        int_ptr->puf.puf_pwr_step =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_pwr_step));
        msg_pos += FSIZ( cai_puf_type, puf_pwr_step);

        int_ptr->puf.tot_puf_prob =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, tot_puf_prob));
        msg_pos += FSIZ(cai_puf_type, tot_puf_prob);

        int_ptr->puf.max_pwr_puf =
          (byte) b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, max_pwr_puf));
        msg_pos += FSIZ(cai_puf_type, max_pwr_puf);

        int_ptr->puf.puf_freq_incl =
          (boolean) b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_freq_incl));
        msg_pos += FSIZ(cai_puf_type, puf_freq_incl);

        if ( int_ptr->puf.puf_freq_incl )
        {
          int_ptr->puf.band_class =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_puf_type, band_class));
          msg_pos += FSIZ(cai_puf_type, band_class);

          int_ptr->puf.cdma_freq =
            b_unpackw(buf_ptr, msg_pos, FSIZ(cai_puf_type, cdma_freq));
          msg_pos += FSIZ( cai_puf_type, cdma_freq );
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_puf */

/*===========================================================================

FUNCTION XLATE_EXT_TC_PUF_CMP

DESCRIPTION
  This function translates a Power Up Function Completion
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Power Up Function Completion
  message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_puf_cmp
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position of record in message */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_puf_comp_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < FENDPOS( MTYPE, loc_ind))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->puf_comp.hdr);

    msg_pos = FENDPOS(cai_puf_comp_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->puf_comp.hdr.msg_int,
         int_ptr->puf_comp.msg_type,
         int_ptr->puf_comp.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->puf_comp.hdr, int_ptr->puf_comp.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        msg_pos += FSIZ(MTYPE, reserved);
        int_ptr->puf_comp.loc_ind =
          (boolean) b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, loc_ind));
        msg_pos += FSIZ(MTYPE, loc_ind);

        if (int_ptr->puf_comp.loc_ind)
        {
          msg_pos += FSIZ(MTYPE, reserved1);
          int_ptr->puf_comp.ms_lat = b_unpackd(buf_ptr, msg_pos,
            FSIZ(MTYPE, ms_lat));
          msg_pos += FSIZ(MTYPE, ms_lat);

          int_ptr->puf_comp.ms_long = b_unpackd( buf_ptr, msg_pos,
            FSIZ(MTYPE, ms_long));
          msg_pos += FSIZ(MTYPE, ms_long);

          int_ptr->puf_comp.tm_stamp = b_unpackd( buf_ptr, msg_pos,
            FSIZ(MTYPE, tm_stamp));
          msg_pos += FSIZ(MTYPE, tm_stamp);
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_puf_cmp */

/*===========================================================================

FUNCTION XLATE_EXT_HO_SRCH_PARMS

DESCRIPTION
  This function translates the searh parameters of a Generic Traffic Channel
  Handoff Direction Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/

word xlate_ext_ho_srch_parms
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to srch parms */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  UNPACKB_PG_DRF(ho.srch.srch_win_a, cai_ho_srch_type, srch_win_a);

  if ((int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
      || (int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

     )
  {
    /* GHDM, UHDM and MEID UHDM contain SRCH_WIN_N and SRCH_WIN_R. */
    UNPACKB_PG_DRF(ho.srch.srch_win_n, cai_ho_srch_type, srch_win_n);
    UNPACKB_PG_DRF(ho.srch.srch_win_r, cai_ho_srch_type, srch_win_r);
  }

  UNPACKB_PG_DRF(ho.srch.t_add, cai_ho_srch_type, t_add);
  UNPACKB_PG_DRF(ho.srch.t_drop, cai_ho_srch_type, t_drop);
  UNPACKB_PG_DRF(ho.srch.t_comp, cai_ho_srch_type, t_comp);
  UNPACKB_PG_DRF(ho.srch.t_tdrop, cai_ho_srch_type, t_tdrop);

  if ((int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
      || (int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

     )
  {
    /* GHDM, UHDM and MEID UHDM have soft handoff improvement fields. */
    UNPACKB_PG_DRF(ho.srch.soft_slope, cai_ho_srch_type, soft_slope);
    UNPACKB_PG_DRF(ho.srch.add_intercept, cai_ho_srch_type, add_intercept);
    UNPACKB_PG_DRF(ho.srch.drop_intercept, cai_ho_srch_type, drop_intercept);
  }

  return (status);

} /* xlate_ext_ho_srch_parms */

/*===========================================================================

FUNCTION XLATE_EXT_HO_EXTRA_PARMS

DESCRIPTION
  This function translates the "extra" parameters of a Generic Traffic
  Channel Handoff Direction Message from external to internal format.
  The "extra" parameters include hard handoff plus service configuration
  parameters plus some search parameters

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/

word xlate_ext_ho_extra_parms
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
      /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to extra parms */
)
{
  word status;
    /* Status returned to calling procedure */

  word len;
    /* Temporary length variable */


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  if (int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
  {
    /* Only the GHDM contains P_REV and PACKET_ZONE_ID right here.
       The EHDM may contain a P_REV field later in the message (95-B). */

    UNPACKB_PG_DRF(ho.extra.p_rev, cai_ho_extra_type, p_rev);
    UNPACKB_PG_DRF(ho.extra.packet_zone_id,
                   cai_ho_extra_type, packet_zone_id);
  }

  if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

     )
  {
    UNPACKB_PG_DRF(ho.extra.packet_zone_id,
                   cai_ho_extra_type, packet_zone_id);
  }

  UNPACKB_PG_DRF(ho.extra.frame_offset, cai_ho_extra_type, frame_offset);
  UNPACKB_PG_DRF(ho.extra.private_lcm, cai_ho_extra_type, private_lcm);
  UNPACKB_PG_DRF(ho.extra.reset_l2, cai_ho_extra_type, reset_l2);

  if (int_ptr->ho.msg_type != CAI_HO_DIR_MSG)
  {
    /* HDM does not contain these fields. */

    UNPACKB_PG_DRF(ho.extra.reset_fpc, cai_ho_extra_type, reset_fpc);

    /* The inclusion of SERV_NEG_TYPE in the EHDM depends on P_REV.  If it
       is not included, this is a reserved field.  We will parse it here
       as SERV_NEG_TYPE, and let MC decide what to do with it. */

    if ((int_ptr->ho.msg_type != CAI_UNIV_HO_DIR_MSG)

        && (int_ptr->ho.msg_type != CAI_MEID_UNIV_HO_DIR_MSG)

       )
    {
      UNPACKB_PG_DRF(ho.extra.serv_neg_type, cai_ho_extra_type, serv_neg_type);
    }
  }

  UNPACKB_PG_DRF(ho.extra.encrypt_mode, cai_ho_extra_type, encrypt_mode);

  if (int_ptr->ho.msg_type != CAI_HO_DIR_MSG)
  {
    /* HDM does not contain these fields. */

    /* NOM_PWR_EXT is not in the EHDM from IS-95A, but it is included
       in J-STD-008 and beyond.  In IS-95A, there is a reserved field of
       the same size here, so we will parse it as NOM_PWR_EXT. */

    UNPACKB_PG_DRF(ho.extra.nom_pwr_ext, cai_ho_extra_type, nom_pwr_ext);
    UNPACKB_PG_DRF(ho.extra.nom_pwr, cai_ho_extra_type, nom_pwr);

    if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

        || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

       )
    {
      UNPACKB_PG_DRF(ho.extra.rlgain_traffic_pilot, cai_ho_msg_is2000_type,
                     rlgain_traffic_pilot);
      UNPACKB_PG_DRF(ho.extra.default_rlag, cai_ho_msg_is2000_type,
                     default_rlag);
    }

    UNPACKB_PG_DRF(ho.extra.num_preamble, cai_ho_extra_type, num_preamble);
    UNPACKB_PG_DRF(ho.extra.band_class, cai_ho_extra_type, band_class);
  }

  if (int_ptr->ho.msg_type == CAI_HO_DIR_MSG)
  {
    /* FREQ_INCL is only included in the HDM.  In the HDM, CDMA_FREQ is
       included only if FREQ_INCL == 1. */

    UNPACKB_PG_DRF(ho.extra.freq_incl, cai_ho_freq_inc_type, freq_incl);
  }

  if ((int_ptr->ho.msg_type != CAI_HO_DIR_MSG) ||
      int_ptr->ho.extra.freq_incl)
  {
    UNPACKW_PG_DRF(ho.extra.cdma_freq, cai_ho_extra_type, cdma_freq);
  }

  if ((int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
      || (int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

     )
  {
    /* GHDM, UHDM and MEID UHDM contain these fields. */

    UNPACKB_PG_DRF(ho.extra.return_if_ho_fail,
                   cai_ho_extra_type, return_if_ho_fail);

    if (int_ptr->ho.extra.return_if_ho_fail)
    {
      /* Include complete search flag if return_if_ho_fail is set */

      UNPACKB_PG_DRF(ho.extra.complete_srch,
                     cai_ho_comp_srch_type, complete_srch);
    }

    UNPACKB_PG_DRF(ho.extra.periodic_srch, cai_ho_extra_type, periodic_srch);
    UNPACKB_PG_DRF(ho.extra.scr_included,
                   cai_ho_extra_type, scr_included);

    if (int_ptr->ho.extra.scr_included)
    {
      /* Service configuration is included */

      UNPACKB_PG_DRF(ho.extra.serv_con_seq,
                     cai_ho_svc_inc_type, serv_con_seq);

      /* Cheat and look ahead to get length, so we can use existing
         xlate_ext_srv_cfg routine.  RECORD_LEN is in bytes, so convert
         to bits then add size of header, as xlate function expects it. */

      len = 8*b_unpackb(buf_ptr,
                        *ext_msg_pos + (word)FPOS(cai_rec_hdr_type, record_len),
                        FSIZ(cai_rec_hdr_type, record_len))
            + sizeof(cai_rec_hdr_type);

      /* Translate service configuration record */
      status = xlate_ext_srv_cfg(len, buf_ptr, *ext_msg_pos,
                                 &int_ptr->ho.extra.cfg,
                                 1
                                 );
      *ext_msg_pos += len;
    }  // scr_included
  }  // GHDM


  return (status);

} /* xlate_ext_ho_extra_parms */

/*===========================================================================

FUNCTION XLATE_EXT_HO_FOR_INC

DESCRIPTION
  This function translates the included forward parameters of a Generic
  Traffic Channel Handoff Direction Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/


word xlate_ext_ho_for_inc
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  UNPACKB_PG_DRF(ho.sup.for_sup_config, cai_ho_sup_for_type, for_sup_config);

  if ((int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_SPEC_STOP) ||
      (int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_SPEC_START))
  {
    UNPACKB_PG_DRF(ho.sup.num_for_sup, cai_ho_for_sup_cfg_type, num_for_sup);

    if (int_ptr->ho.sup.num_for_sup > CAI_MAX_NUM_SUP)
    {
      M1X_MSG( DCP, LEGACY_ERROR,
        "Unsupported num_for_sup = %d is received",
        int_ptr->ho.sup.num_for_sup);
      status = CAIX_INV_MSG_S;
      return status;
    }
  }

  if ((int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_START) ||
      (int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_SPEC_START))
  {
    UNPACKB_PG_DRF(ho.sup.use_for_dur,
                  cai_ho_for_sup_cfg_type, use_for_duration);

    if (int_ptr->ho.sup.use_for_dur)
    {
      /* Get forward duration field too */

      UNPACKB_PG_DRF(ho.sup.for_dur, cai_ho_sup_for_dur_type, for_duration);
    }
  }
  else
  {
    int_ptr->ho.sup.use_for_dur = FALSE;
  }

  return (status);

} /* xlate_ext_ho_for_inc */

/*===========================================================================

FUNCTION XLATE_EXT_HO_REV_INC

DESCRIPTION
  This function translates the included reverse parameters of a Generic
  Traffic Channel Handoff Direction Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/


word xlate_ext_ho_rev_inc
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  UNPACKB_PG_DRF(ho.sup.rev_dtx_duration,
                 cai_ho_sup_rev_type, rev_dtx_duration);
  UNPACKB_PG_DRF(ho.sup.clear_retry_delay,
                 cai_ho_sup_rev_type, clr_retry_dly);
  UNPACKB_PG_DRF(ho.sup.use_rev_dur, cai_ho_sup_rev_type, use_rev_duration);

  if (int_ptr->ho.sup.use_rev_dur)
  {
    /* Decode the reverse duration value */

    UNPACKB_PG_DRF(ho.sup.rev_dur, cai_ho_sup_rev_dur_type, rev_duration);
  }

  UNPACKB_PG_DRF(ho.sup.num_rev_codes, cai_ho_sup_rev_type, num_rev_codes);
  UNPACKB_PG_DRF(ho.sup.use_t_add_abt, cai_ho_sup_rev_type, use_t_add_abort);

  return (status);

} /* xlate_ext_ho_rev_inc */

/*===========================================================================

FUNCTION XLATE_EXT_HO_REV_PARMS

DESCRIPTION
  This function translates the included reverse parameters of a Generic
  Traffic Channel Handoff Direction Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/

word xlate_ext_ho_rev_parms
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  UNPACKB_PG_DRF(ho.sup.t_mulchan, cai_ho_sup_rev_parm_type, t_mulchan);
  UNPACKB_PG_DRF(ho.sup.begin_pre, cai_ho_sup_rev_parm_type, begin_preamble);
  UNPACKB_PG_DRF(ho.sup.resume_pre,
                 cai_ho_sup_rev_parm_type, resume_preamble);

  return (status);

} /* xlate_ext_ho_rev_parms */

/*===========================================================================

FUNCTION XLATE_EXT_HO_SUP_PARMS

DESCRIPTION
  This function translates the supplemental parameters of a Generic Traffic
  Channel Handoff Direction Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/

word xlate_ext_ho_sup_parms
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  UNPACKB_PG_DRF(ho.sup.for_included,
                cai_ho_sup_chan_parms_type, for_included);

  if (int_ptr->ho.sup.for_included)
  {
    /* Forward supplemental assignment information is included */

    status = xlate_ext_ho_for_inc(buf_ptr, int_ptr, ext_msg_pos);

    if (status != CAIX_DONE_S)
    {
      return (status);
    }
  }

  UNPACKB_PG_DRF(ho.sup.rev_included,
                 cai_ho_sup_chan_parms_type, rev_included);

  if (int_ptr->ho.sup.rev_included)
  {
    /* Reverse supplemental assignment information is included */

    status = xlate_ext_ho_rev_inc(buf_ptr, int_ptr, ext_msg_pos);

    if (status != CAIX_DONE_S)
    {
      return (status);
    }
  }

  UNPACKB_PG_DRF(ho.sup.rev_parms_inc,
                 cai_ho_sup_chan_parms_type, rev_parms_inc);

  if (int_ptr->ho.sup.rev_parms_inc)
  {
    /* Reverse supplemental parameters are included */

    status = xlate_ext_ho_rev_parms(buf_ptr, int_ptr, ext_msg_pos);
  }

  return (status);

} /* xlate_ext_ho_sup_parms */

/*===========================================================================

FUNCTION XLATE_EXT_HO_CHAN

DESCRIPTION
  This function translates the pilot and supplemental code channel
  information array of a Generic Traffic Channel Handoff Direction Message
  from external to internal format.

DEPENDENCIES
  The fields SUP_CAHN_PARMS_INC, FOR_INCLUDED, FOR_SUP_CONFIG, NUM_PILOTS
  and NUM_FOR_SUP must have already been parsed and put into int_ptr.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/

word xlate_ext_ho_chan
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
  word status;
    /* Status returned to calling procedure */
  byte pilot;
    /* Loop variable and array index for pilot array */

  byte chan;
    /* Loop variable and array index for supplemental channel array */

  boolean check_sup;
    /* Indicator to check for supplemental channels */
  byte num_for_sup;
    /* Temp variable to hold number of supplemental code channels */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ((int_ptr->ho.num_pilots == 0 ||
       int_ptr->ho.num_pilots > CAI_HO_MSG_MAX_PILOTS))
  {
    /* Message must have at least one pilot to be valid, but also
       do not want to write past end of array with too many pilots. */

    status = CAIX_INV_LEN_S;
    return (status);
  }

  status = CAIX_DONE_S;

  /* Check to see if key fields have valid info, and assign temp
     variables accordingly to help create channel array. */

  if (int_ptr->ho.sup_chan_parms_inc  &&
      int_ptr->ho.sup.for_included    &&
      ((int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_SPEC_STOP) ||
       (int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_SPEC_START)))
  {
    /* Check for forward supplemental channels */

    check_sup = TRUE;
    num_for_sup = int_ptr->ho.sup.num_for_sup;
  }
  else
  {
    /* No supplemental info is included. */

    check_sup = FALSE;
    num_for_sup = 0;
  }


  for (pilot = 0; pilot < int_ptr->ho.num_pilots; pilot++)
  {
    UNPACKW_PG_DRF(ho.pilot[pilot].pilot_pn,
                   cai_ho_msg_pilot_type, pilot_pn);
    UNPACKB_PG_DRF(ho.pilot[pilot].pwr_comb_ind,
                  cai_ho_msg_pilot_type, pwr_comb_ind);
    UNPACKB_PG_DRF(ho.pilot[pilot].code_chan_fch,
                  cai_ho_msg_pilot_type, code_chan);

    if (check_sup)
    {
      /* for_sup_included is included */

      UNPACKB_PG_DRF(ho.pilot[pilot].for_sup_inc,
                     cai_ho_for_sup_cfg_sup_type, for_sup_inc);

      if (int_ptr->ho.pilot[pilot].for_sup_inc)
      {
        /* Forward supplemental channel record is included */

        UNPACKB_PG_DRF(ho.pilot[pilot].expl_code_chan,
                       cai_ho_for_sup_ch_rec_type, expl_code_chan);

        if (int_ptr->ho.pilot[pilot].expl_code_chan)
        {
          /* forward supplemental code channels are explicitly listed */

          for (chan = 0; chan < num_for_sup; chan++)
          {
            UNPACKB_PG_DRF(ho.pilot[pilot].chan_rec.sup_code_chan[chan],
                           cai_ho_for_sup_chan_type, sup_code_chan);
          }
        }
        else
        {
          /* only base code channel is explicitly listed */

          UNPACKB_PG_DRF(ho.pilot[pilot].chan_rec.base_code_chan,
                         cai_ho_for_sup_base_type, base_code_chan);
        }
      } /* if (for_sup_included) */
    } /* if (check_sup) */


  } /* for (pilots) */

  return (status);

} /* xlate_ext_ho_chan */


/*===========================================================================

FUNCTION XLATE_HO_ENC_CC

DESCRIPTION
  This function translates cc info, sync_id and enc information for the GHDM & UHDM

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS

===========================================================================*/

word xlate_ho_enc_cc
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos_ptr
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
    int i;
      /* Status returned to calling procedure */
    word status = CAIX_DONE_S;
    word ext_msg_pos = *ext_msg_pos_ptr;

    if (int_ptr->ho.extra_parms)
    {
       /* unpack encrypt info */
       if (int_ptr->ho.extra.encrypt_mode == CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
       {
         int_ptr->ho.d_sig_encrypt_mode =  b_unpackb( buf_ptr, ext_msg_pos,
                        FSIZ(cai_ho_msg_sig_enc_type,d_sig_encrypt_mode));
         ext_msg_pos += FSIZ(cai_ho_msg_sig_enc_type,d_sig_encrypt_mode);
       }

       if ((int_ptr->ho.extra.encrypt_mode == CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG) ||
           (int_ptr->ho.extra.encrypt_mode == CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
       {
         /* key_size included */
         int_ptr->ho.key_size =  b_unpackb( buf_ptr, ext_msg_pos,
                          FSIZ(cai_ho_msg_sig_enc_type,key_size));
         ext_msg_pos += FSIZ(cai_ho_msg_sig_enc_type,key_size);
       }

    } // if (int_ptr->ho.extra_parms)

    // 3X fields only in UHDM and MEID UHDM
    if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

        || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

       )
    {
       int_ptr->ho.threexfl_1xrl_incl =  b_unpackb( buf_ptr, ext_msg_pos,
                     FSIZ(cai_ho_msg_1xrl_type,threexfl_1xrl_incl));
       ext_msg_pos += FSIZ(cai_ho_msg_1xrl_type,threexfl_1xrl_incl);

       if (int_ptr->ho.threexfl_1xrl_incl)
       {
         int_ptr->ho.onexrl_freq_offset =  b_unpackb( buf_ptr, ext_msg_pos,
                     FSIZ(cai_ho_msg_1xrl_type,onexrl_freq_offset));
         ext_msg_pos += FSIZ(cai_ho_msg_1xrl_type,onexrl_freq_offset);
       }
    }

    if (int_ptr->ho.extra_parms)
    {

      /* sync ID */
       if (int_ptr->ho.extra.scr_included || int_ptr->ho.extra.nnscr_included)
       {
         int_ptr->ho.sync_id_incl = b_unpackb( buf_ptr, ext_msg_pos,
                     FSIZ(cai_srv_con_fix_type, sync_id_incl));
         ext_msg_pos += FSIZ(cai_srv_con_fix_type, sync_id_incl);

         if (int_ptr->ho.sync_id_incl)
         {
           int_ptr->ho.sync_id_len = b_unpackb( buf_ptr, ext_msg_pos,
                       FSIZ(cai_srv_cfg_sync_id_type, sync_id_len));
           ext_msg_pos += FSIZ(cai_srv_cfg_sync_id_type, sync_id_len);

           for (i=0; (i<int_ptr->ho.sync_id_len) && (i < CAI_SYNC_ID_LEN_MAX); i++)
           {
             int_ptr->ho.sync_id[i] = b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ(cai_srv_cfg_sync_id_type, sync_id));
             ext_msg_pos += FSIZ(cai_srv_cfg_sync_id_type, sync_id);
           }
         }

       } /* if (int_ptr->ho.extra.scr_included ..) */

       if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

           || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

          )
       {
         /* cc info */
         if (int_ptr->ho.extra.scr_included)
         {
           int_ptr->ho.cc.cc_info_incl =  b_unpackb( buf_ptr, ext_msg_pos,
                    FSIZ(cai_cc_info_fix_type,cc_info_incl));
           ext_msg_pos += FSIZ(cai_cc_info_fix_type,cc_info_incl);

           /* CC Info is UHDM specific only */
           if (int_ptr->ho.cc.cc_info_incl)
           {
             int_ptr->ho.cc.num_calls_assign =  b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ(cai_cc_info_fix_type, num_calls_assign));

             if(int_ptr->ho.cc.num_calls_assign > CAI_SCM_MAX_NUM_CALLS_ASSIGN)
             {
               M1X_MSG( DCP, LEGACY_ERROR,
                 "Unsupported num_calls_assign = %d is received",
                 int_ptr->ho.cc.num_calls_assign);
               status = CAIX_INV_MSG_S;
               return status;
             }

             ext_msg_pos += FSIZ(cai_cc_info_fix_type, num_calls_assign);

             for (i=0; i<int_ptr->ho.cc.num_calls_assign ; i++ )
             {
               int_ptr->ho.cc.conn[i].con_ref =
                 b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ(cai_cc_info_type, con_ref));
               ext_msg_pos += FSIZ(cai_cc_info_type, con_ref);

               int_ptr->ho.cc.conn[i].response_ind =
                 b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ(cai_cc_info_type, response_ind));
               ext_msg_pos += FSIZ(cai_cc_info_type, response_ind);

               if (int_ptr->ho.cc.conn[i].response_ind)
               {
                 int_ptr->ho.cc.conn[i].tag =
                   b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ(cai_cc_info_type, tag));
                 ext_msg_pos += FSIZ(cai_cc_info_type, tag);
               }
               else
               {
                 int_ptr->ho.cc.conn[i].bypass_alert_answer =
                   b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ(cai_cc_info_type, bypass_alert_answer));
                 ext_msg_pos += FSIZ(cai_cc_info_type, bypass_alert_answer);
               }
             } /* for */
           } /* if (int_ptr->ho.cc.cc_info_incl) */
         }
         else
         {
           /* If SCR not included, set CC_INFO_INCL to 0 */
           int_ptr->ho.cc.cc_info_incl = 0;
         } /* if (int_ptr->ho.extra.scr_included) */
       } /* if UHDM */
       else
       {
         /* If not UHDM, set CC_INFO_INCL to 0 */
         int_ptr->ho.cc.cc_info_incl = 0;
       }
    } // if (int_ptr->ho.extra_parms)

    *ext_msg_pos_ptr = ext_msg_pos;
    return status;
}


/*===========================================================================

FUNCTION XLATE_EXT_HO_MSG

DESCRIPTION
  This function translates a Generic Traffic Channel Handoff Direction
  Message (HDM, EHDM, GHDM, UHDM, MEID UHDM) from external to internal format.

DEPENDENCIES
  Assumes that the internal message type field received as an input to the
  function already includes the Handoff Direction Message type.  Also
  assumes that the message buffer is pointing to the field after the
  message type field.  Note:  Since this is a sort of like a union of all of
  the handoff direction messages, generally one CANNOT use sizeof on the
  cai.h structures, as they may contain extra fields.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Puts parsed message in location pointed to by int_ptr.

===========================================================================*/

word xlate_ext_ho_msg
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of variable part of message */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (len < CAI_HO_MSG_MIN_LENGTH)
  {
    return CAIX_INV_LEN_S;
  }

  /* -----------------------------------------------------------------
  ** Length is OK --> convert message from external to internal format
  ** starting with the first field after message_type
  ** -------------------------------------------------------------- */

  /* Tell pre-processor that it hasn't looked at this message yet */
  int_ptr->ho.pre_proc_done = FALSE;

  /* buf_ptr points to first field (msg_type), so
     position ext_msg_pos right after to point to TC header. */

  /* For CSFB case, we have UHDM passed to us from use_time, which doesnt include
   * msg_type, hence start decoding from the start of buffer, which means
   * ext_msg_pos should be 0
   */

  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  if(cdma.entry_ptr->entry == MCC_CSFB)
  {
    ext_msg_pos = 0;
  }
  else
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
  {
    ext_msg_pos = (word)FENDPOS(cai_ho_msg_fix_type, msg_type);
  }

  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  /* For CSFB, we dont expect the L2 fields, hence skip parsing of
   * L2 header
   */
  if(cdma.entry_ptr->entry != MCC_CSFB)
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->ho.hdr);
    ext_msg_pos = FENDPOS(cai_ho_msg_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED, &ext_msg_pos, buf_ptr,
         &int_ptr->ho.hdr.msg_int, int_ptr->ho.msg_type,
         int_ptr->ho.hdr.ack_req)) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_C */
#ifdef FEATURE_IS2000_REL_A
    if ((status = xlate_ext_ext_enc_tc(&len, &ext_msg_pos, buf_ptr,
         &int_ptr->ho.hdr, int_ptr->ho.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_A */
  } /* if cdma.entry_ptr->entry != MCC_CSFB */

  UNPACKB_PG(ho.use_time, cai_ho_msg_fix_type, use_time);

  if (int_ptr->ho.use_time ||
       ((int_ptr->ho.msg_type != CAI_GEN_HO_DIR_MSG) &&
        (int_ptr->ho.msg_type != CAI_UNIV_HO_DIR_MSG)

        && (int_ptr->ho.msg_type != CAI_MEID_UNIV_HO_DIR_MSG)

       ))
  {
    /* In the GHDM, UHDM and MEID UHDM, action_time is absent
       if use_time == 0 */
    UNPACKB_PG(ho.action_time, cai_ho_action_time_type, action_time);
  }

  UNPACKB_PG(ho.hdm_seq, cai_ho_msg_fix_type, hdm_seq);

  if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

     )
  {
    UNPACKB_PG(ho.parms_incl, cai_ho_msg_is2000_type, parms_incl);
    if (int_ptr->ho.parms_incl)
    {
      UNPACKB_PG(ho.extra.p_rev, cai_ho_extra_type, p_rev);
      UNPACKB_PG(ho.extra.serv_neg_type, cai_ho_extra_type, serv_neg_type);
    }
  }

  if (int_ptr->ho.msg_type != CAI_HO_DIR_MSG)
  {
    UNPACKB_PG(ho.srch_inc, cai_ho_msg_fix_type, srch_inc);
  }
  else
  {
    /* There is no SRCH_INC field in the HDM, but SRCH parms are there. */
    int_ptr->ho.srch_inc = TRUE;
  }

  if (int_ptr->ho.srch_inc)
  {
    /* The search parameters are included for this message. */
    status = xlate_ext_ho_srch_parms(buf_ptr, int_ptr, &ext_msg_pos);

    if (status != CAIX_DONE_S)
    {
      return (status);
    }
  }

  if (int_ptr->ho.msg_type != CAI_HO_DIR_MSG)
  {
    /* This is the same bit as HARD_INCLUDED in the EHDM, and it serves
       roughly the same function, so parse it as EXTRA_PARMS. */

    UNPACKB_PG(ho.extra_parms, cai_ho_msg_fix_type, extra_parms);
  }
  else
  {
    /* There is no EXTRA_PARMS field in the HDM, but some of the
       subfields are there. */
    int_ptr->ho.extra_parms = TRUE;
  }

  if (int_ptr->ho.extra_parms)
  {
    /* The "extra" parameters include hard handoff plus service
       configuration parameters plus some search parameters. */

    status = xlate_ext_ho_extra_parms(buf_ptr, int_ptr, &ext_msg_pos);

    if (status != CAIX_DONE_S)
    {
      return (status);
    }

    if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

        || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

       )
    {
      int_ptr->ho.extra.nnscr_included =
        b_unpackb(buf_ptr,ext_msg_pos,
              FSIZ(cai_ho_msg_is2000_type,nnscr_included));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type,nnscr_included);
      if (int_ptr->ho.extra.nnscr_included)
      {
        status = xlate_int_non_neg_srv_cfg(buf_ptr,&ext_msg_pos,
                                  &(int_ptr->ho.extra.non_neg_cfg));
        if (status != CAIX_DONE_S)
        {
          return status;
        }
      }
    }
  }

  if (int_ptr->ho.msg_type == CAI_EXT_HO_DIR_MSG)
  {
    /* Only the EDHM has ADD_LENGTH field which may indicate that the
       message contains P_REV information (IS-95B and beyond).  At least
       in theory, P_REV could be included while HARD_INC == 0, so we
       parse it outside of the EXTRA_PARMS parser. */

    UNPACKB_PG(ho.add.add_length, cai_ho_add_length_type, add_length );

    if ((int_ptr->ho.add.add_length) != 0)
    {
      int_ptr->ho.add.ext_ho_p_rev = b_unpackb(
        buf_ptr, ext_msg_pos, FSIZ(cai_ho_add_length_type, ext_ho_p_rev));
    }

    ext_msg_pos += int_ptr->ho.add.add_length * 8;
  }

  if (int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
  {
    /* Only the GHDM contains supplemental channel information
             and PWR_CNTL_STEP. */

    UNPACKB_PG(ho.sup_chan_parms_inc, cai_ho_msg_fix_type, sup_chan_parms_inc);

    if (int_ptr->ho.sup_chan_parms_inc)
    {
      /* The Supplemental Channel Parameters are included. */

      status = xlate_ext_ho_sup_parms(buf_ptr, int_ptr, &ext_msg_pos);

      if (status != CAIX_DONE_S)
      {
        return (status);
      }
    }

    UNPACKB_PG(ho.use_pwr_cntl_step, cai_ho_msg_fix_type, use_pwr_cntl_step);

    if (int_ptr->ho.use_pwr_cntl_step)
    {
      /* Power control step size is included. */

      UNPACKB_PG(ho.pwr_cntl_step, cai_ho_pwr_cntl_type, pwr_cntl_step);
    }
  }
  else
  {
    /* There is no supplemental channel info or PWR_CNTL_STEP
       in the HDM or EHDM. */
    int_ptr->ho.sup_chan_parms_inc = FALSE;
    int_ptr->ho.use_pwr_cntl_step = FALSE;
  }

  if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

     )
  {
    UNPACKB_PG(ho.use_pwr_cntl_step,
               cai_ho_msg_fix_type, use_pwr_cntl_step);

    if (int_ptr->ho.use_pwr_cntl_step)
    {
      /* Power control step size is included. */
      UNPACKB_PG(ho.pwr_cntl_step, cai_ho_pwr_cntl_type, pwr_cntl_step);
    }

    UNPACKB_PG(ho.clear_retry_delay,
               cai_ho_msg_is2000_type, clear_retry_delay);
  }


  if ((int_ptr->ho.msg_type != CAI_UNIV_HO_DIR_MSG)

      && (int_ptr->ho.msg_type != CAI_MEID_UNIV_HO_DIR_MSG)

     )
  {
    if (int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
    {
      /* The GHDM tells us how many pilot records there are. */
      UNPACKB_PG(ho.num_pilots, cai_ho_msg_fix_type, num_pilots);
    }
    else
    {
      /* Note: This section is also part of the else from above
               (inside the #ifdef). */

      /* HDM and EHDM do not have a NUM_PILOTS field, so calculate it.  The
         calculation assumes that the pilot array is at the very end of the
         message (except for the RESERVED field).  This is true for the HDM
         and EHDM.  The integer division takes care of the RESERVED field
         which is always smaller than cai_ho_msg_pilot_type. */

      /* Since length is: ext_msg_pos (length of preceding fields)
                          + NUM_PILOTS*sizeof(cai_ho_msg_pilot_type)
                          + RESERVED

         then: (length - ext_msg_pos)/sizeof(cai_ho_msg_pilot_type)
         is:   NUM_PILOTS + RESERVED/sizeof(cai_ho_msg_pilot_type)
         now:  RESERVED/sizeof(cai_ho_msg_pilot_type) == 0 for integer math
         so: NUM_PILOTS == (length - ext_msg_pos)/sizeof(cai_ho_msg_pilot_type)
      */

      int temp_len = len - ext_msg_pos;

#ifdef FEATURE_IS2000_REL_C
      if (int_ptr->ho.hdr.msg_int.maci_incl)
      {
        /* Exclude MACI bits */
        temp_len -= FSIZ(cai_msg_int_type, maci);
      }
#endif /* FEATURE_IS2000_REL_C */

      if (temp_len > 0)
      {
        int_ptr->ho.num_pilots =
          (byte)temp_len/sizeof(cai_ho_msg_pilot_type);
      }
      else
      {
        return (status = CAIX_INV_LEN_S);
      }
    }

    status = xlate_ext_ho_chan(buf_ptr, int_ptr, &ext_msg_pos); /*lint !e725*/
    if (status != CAIX_DONE_S)
    {
      return status;
    }
  }

  /**********************************************************
                UHDM, MEID UHDM Specific parsing
  ***********************************************************/

  if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)

      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

     )
  {
    word i,j;
    word record_len;
    word start_record_pos;

#ifdef FEATURE_IS2000_REL_A
    boolean thx_info_included_in_msg;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    boolean parse_rev_fch_gating_mode;
#endif /* FEATURE_IS2000_REL_C */

    UNPACKB_PG(ho.sch_incl, cai_ho_msg_is2000_type, sch_incl);

    if (int_ptr->ho.sch_incl)
    {
      UNPACKB_PG(ho.num_for_assign, cai_ho_msg_is2000_type, num_for_assign);

      if(int_ptr->ho.num_for_assign > CAI_MAX_NUM_FOR_SCH)
      {
        M1X_MSG( DCP, LEGACY_ERROR,
          "Unsupported num_for_assign = %d is received",
          int_ptr->ho.num_for_assign);
        status = CAIX_INV_MSG_S;
        return status;
      }

      for (i=0;i<int_ptr->ho.num_for_assign;i++)
      {
        UNPACKB_PG(ho.for_assign[i].for_sch_id,cai_ho_msg_is2000_type,
                   for_sch_id);
        UNPACKB_PG(ho.for_assign[i].for_sch_duration,
                   cai_ho_msg_is2000_type,for_sch_duration);
        UNPACKB_PG(ho.for_assign[i].for_sch_start_time_incl,
                   cai_ho_msg_is2000_type,for_sch_start_time_incl);
        if (int_ptr->ho.for_assign[i].for_sch_start_time_incl)
        {
          UNPACKB_PG(ho.for_assign[i].for_sch_start_time,
                     cai_ho_msg_is2000_type,for_sch_start_time);
        }
        UNPACKB_PG(ho.for_assign[i].sccl_index,
                   cai_ho_msg_is2000_type,sccl_index);
      }

      UNPACKB_PG(ho.num_rev_assign, cai_ho_msg_is2000_type, num_rev_assign);
      for (i=0;i<int_ptr->ho.num_rev_assign && i<CAI_MAX_NUM_REV_SCH;i++)
      {
        UNPACKB_PG(ho.rev_assign[i].rev_sch_id,cai_ho_msg_is2000_type,
                   rev_sch_id);
        UNPACKB_PG(ho.rev_assign[i].rev_sch_duration,
                   cai_ho_msg_is2000_type,rev_sch_duration);
        UNPACKB_PG(ho.rev_assign[i].rev_sch_start_time_incl,
                   cai_ho_msg_is2000_type,rev_sch_start_time_incl);
        if (int_ptr->ho.rev_assign[i].rev_sch_start_time_incl)
        {
          UNPACKB_PG(ho.rev_assign[i].rev_sch_start_time,
                     cai_ho_msg_is2000_type,rev_sch_start_time);
        }
        UNPACKB_PG(ho.rev_assign[i].rev_sch_rate,
                   cai_ho_msg_is2000_type,rev_sch_rate);
      }
    }

    UNPACKB_PG(ho.fpc_subchan_gain,cai_ho_msg_is2000_type,fpc_subchan_gain);
    UNPACKB_PG(ho.use_pc_time,cai_ho_msg_is2000_type,use_pc_time);
    if (int_ptr->ho.use_pc_time)
    {
      UNPACKB_PG(ho.pc_action_time,cai_ho_msg_is2000_type,pc_action_time);
    }
    UNPACKB_PG(ho.ch_ind,cai_ho_msg_is2000_type,ch_ind);

    record_len = b_unpackb(buf_ptr,ext_msg_pos,
                           FSIZ(cai_ho_msg_is2000_type,active_set_rec_len));
    ext_msg_pos += FSIZ(cai_ho_msg_is2000_type,active_set_rec_len);
    start_record_pos = ext_msg_pos;

    if ((int_ptr->ho.ch_ind == CAI_DED_CTL) ||
        (int_ptr->ho.ch_ind == CAI_FUND_CONT_REV_PLT) ||
        (int_ptr->ho.ch_ind == CAI_DED_CTL_CONT_REV_PLT) ||
        (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
    {
      if (int_ptr->ho.sch_incl)
      {
        UNPACKB_PG(ho.sch_cfg.num_for_sch,cai_sch_cfg_type,num_for_sch);
        for (i=0; i<int_ptr->ho.sch_cfg.num_for_sch &&
                  i<CAI_MAX_NUM_FOR_SCH_CFG; i++)
        {
          UNPACKB_PG(ho.sch_cfg.for_sch_cfg[i].for_sch_id,
                     cai_sch_cfg_type,for_sch_id);
          UNPACKB_PG(ho.sch_cfg.for_sch_cfg[i].sccl_index,
                     cai_sch_cfg_type,sccl_index);
          UNPACKB_PG(ho.sch_cfg.for_sch_cfg[i].for_sch_rate,
                     cai_sch_cfg_type,for_sch_rate);
        }

        UNPACKB_PG(ho.sch_cfg.num_rev_sch,cai_sch_cfg_type,num_rev_sch);

        for (i=0; i<int_ptr->ho.sch_cfg.num_rev_sch &&
                  i<CAI_MAX_NUM_REV_SCH_CFG; i++)
        {
          UNPACKB_PG(ho.sch_cfg.rev_sch_cfg[i].rev_sch_id,
                     cai_sch_cfg_type,rev_sch_id);
          UNPACKB_PG(ho.sch_cfg.rev_sch_cfg[i].rev_walsh_id,
                     cai_sch_cfg_type,rev_walsh_id);
          UNPACKB_PG(ho.sch_cfg.rev_sch_cfg[i].rev_sch_rate,
                     cai_sch_cfg_type,rev_sch_rate);
        }
      }

      UNPACKB_PG(ho.num_pilots,cai_ho_msg_fix_type,num_pilots);

      if((int_ptr->ho.num_pilots == 0) ||
          (int_ptr->ho.num_pilots > CAI_HO_MSG_MAX_PILOTS)
        )
      {
        M1X_MSG( DCP, LEGACY_ERROR,
          "Unsupported num_pilots = %d is received",
          int_ptr->ho.num_pilots);
        status = CAIX_INV_MSG_S;
        return status;
      }

      UNPACKB_PG(ho.srch_offset_incl,cai_ho_msg_is2000_type,srch_offset_incl);

      for (i=0;i<int_ptr->ho.num_pilots;i++)
      {
        UNPACKW_PG(ho.pilot[i].pilot_pn,cai_ho_msg_pilot_type,pilot_pn);
        if (int_ptr->ho.srch_offset_incl)
        {
          UNPACKB_PG(ho.pilot[i].srch_offset,
                     cai_ho_msg_pilot_is2000_type,srch_offset);
        }
        else
        {
          int_ptr->ho.pilot[i].srch_offset = 0;
        }

        UNPACKB_PG(ho.pilot[i].add_pilot_rec_incl,
                   cai_ho_msg_pilot_is2000_type,add_pilot_rec_incl);

        if (int_ptr->ho.pilot[i].add_pilot_rec_incl)
        {
          word tmp_record_len = 0;
          word record_start_pos = 0;

          /* xlate_add_pilot_rec */
          UNPACKB_PG(ho.pilot[i].pilot_rec_type,
                     cai_ho_msg_pilot_is2000_type,pilot_rec_type);
          tmp_record_len = b_unpackb(buf_ptr,ext_msg_pos,
                           FSIZ(cai_ho_msg_pilot_is2000_type,record_len));
          ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type,record_len);

          record_start_pos = ext_msg_pos;

          xlate_add_pilot_rec(int_ptr->ho.pilot[i].pilot_rec_type,
                              buf_ptr, ext_msg_pos,
                              &(int_ptr->ho.pilot[i].add_pilot_rec));

          ext_msg_pos = record_start_pos + tmp_record_len*8;
        }

        UNPACKB_PG(ho.pilot[i].pwr_comb_ind,cai_ho_msg_pilot_type,
                   pwr_comb_ind);

        if ((int_ptr->ho.ch_ind == CAI_FUND_CONT_REV_PLT) ||
            (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
        {
          UNPACKW_PG(ho.pilot[i].code_chan_fch,
                     cai_ho_msg_pilot_is2000_type,code_chan_fch);
          UNPACKB_PG(ho.pilot[i].qof_mask_id_fch,
                     cai_ho_msg_pilot_is2000_type,qof_mask_id_fch);
        }

        if ((int_ptr->ho.ch_ind == CAI_DED_CTL) ||
            (int_ptr->ho.ch_ind == CAI_DED_CTL_CONT_REV_PLT) ||
            (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
        {
          UNPACKW_PG(ho.pilot[i].code_chan_dcch,
                     cai_ho_msg_pilot_is2000_type,code_chan_dcch);
          UNPACKB_PG(ho.pilot[i].qof_mask_id_dcch,
                     cai_ho_msg_pilot_is2000_type,qof_mask_id_dcch);
        }

        if (int_ptr->ho.sch_incl)
        {
          UNPACKB_PG(ho.pilot[i].num_sch,
                     cai_ho_msg_pilot_is2000_type,num_sch);

          for (j=0; j<int_ptr->ho.pilot[i].num_sch &&
                    j<CAI_MAX_NUM_SCH_CHAN; j++)
          {
            if (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT)
            {
              UNPACKB_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].for_sch_id,
                         cai_sch_chan_rec_type,for_sch_id_111);
            }
            else
            {
              UNPACKB_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].for_sch_id,
                         cai_sch_chan_rec_type,for_sch_id);
            }

            UNPACKB_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].sccl_index,
                       cai_sch_chan_rec_type,sccl_index);
            UNPACKB_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl,
                       cai_sch_chan_rec_type,pilot_incl);

            if (int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl)
            {
              UNPACKW_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].code_chan_sch,
                         cai_sch_chan_rec_type,code_chan_sch);
              UNPACKB_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].qof_mask_id_sch,
                         cai_sch_chan_rec_type,qof_mask_id_sch);
            }
          }
        }
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        thx_info_included_in_msg = FALSE;
        /* 3x fields can be fch only, dcch only or may exist for both */

        /* Get fch_info_incl, if present */
        if ((int_ptr->ho.ch_ind == CAI_FUND_CONT_REV_PLT ) ||
            (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
        {
          UNPACKB_PG(ho.thx_and_ccsh_info.thx_fch_info_incl,
                     cai_ho_msg_3xfch_fix_type, thx_fch_info_incl);

          if (int_ptr->ho.thx_and_ccsh_info.thx_fch_info_incl)
          {
             // this will be used later to figure out if SCH 3X info is present
             thx_info_included_in_msg = TRUE;
           }
         }

        /* get dcch_info_incl, if present */
        if ((int_ptr->ho.ch_ind == CAI_DED_CTL) ||
            (int_ptr->ho.ch_ind == CAI_DED_CTL_CONT_REV_PLT) ||
            (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
        {
          UNPACKB_PG(ho.thx_and_ccsh_info.thx_dcch_info_incl,
                     cai_ho_msg_3xdcch_fix_type, thx_dcch_info_incl);

          if (int_ptr->ho.thx_and_ccsh_info.thx_dcch_info_incl)
          {
             thx_info_included_in_msg = TRUE;
          }
        }

        for (i=0;i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS;i++)
        {
          if (((int_ptr->ho.ch_ind == CAI_FUND_CONT_REV_PLT) ||
               (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))  &&
                int_ptr->ho.thx_and_ccsh_info.thx_fch_info_incl)
          {
            UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].thx_fch_low_incl,
                        cai_ho_msg_3xfch_type, thx_fch_low_incl);

            if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].thx_fch_low_incl)
            {
              UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].qof_mask_id_fch_low,
                          cai_ho_msg_3xfch_type, qof_mask_id_fch_low);
              UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].code_chan_fch_low,
                          cai_ho_msg_3xfch_type, code_chan_fch_low);
            }

            UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].thx_fch_high_incl,
                       cai_ho_msg_3xfch_type, thx_fch_high_incl);

            if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].thx_fch_high_incl)
            {
              UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].qof_mask_id_fch_high,
                         cai_ho_msg_3xfch_type, qof_mask_id_fch_high);
              UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].code_chan_fch_high,
                         cai_ho_msg_3xfch_type, code_chan_fch_high);
            }
          } // if

          if (((int_ptr->ho.ch_ind == CAI_DED_CTL) ||
                (int_ptr->ho.ch_ind == CAI_DED_CTL_CONT_REV_PLT) ||
                (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT)) &&
               int_ptr->ho.thx_and_ccsh_info.thx_dcch_info_incl)
          {
             UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].thx_dcch_low_incl,
                        cai_ho_msg_3xdcch_type, thx_dcch_low_incl);

             if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].thx_dcch_low_incl)
             {
               UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].qof_mask_id_dcch_low,
                          cai_ho_msg_3xdcch_type, qof_mask_id_dcch_low);
               UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].code_chan_dcch_low,
                          cai_ho_msg_3xdcch_type, code_chan_dcch_low);
             }

             UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].thx_dcch_high_incl,
                        cai_ho_msg_3xdcch_type, thx_dcch_high_incl);

             if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].thx_dcch_high_incl)
             {
               UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].qof_mask_id_dcch_high,
                          cai_ho_msg_3xdcch_type, qof_mask_id_dcch_high);
               UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].code_chan_dcch_high,
                          cai_ho_msg_3xdcch_type, code_chan_dcch_high);
             }
          } // if

          /* Now unpack 3x sch fields, if present */
         if (thx_info_included_in_msg && int_ptr->ho.sch_incl)
         {
             UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].thx_sch_info_incl,
                        cai_sch_chan_rec_type, thx_sch_info_incl);

             if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].thx_sch_info_incl)
             {
               for (j=0; j<int_ptr->ho.pilot[i].num_sch &&
                         j<CAI_MAX_NUM_SCH_CHAN; j++)
               {
                 UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].for_sch_id,
                            cai_sch_chan_rec_type, for_sch_id);
                 UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].thx_sch_low_incl,
                            cai_sch_chan_rec_type, thx_sch_low_incl);

                 if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].thx_sch_low_incl)
                 {
                   UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].qof_mask_id_sch_low,
                              cai_sch_chan_rec_type, qof_mask_id_sch_low);
                   UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].code_chan_sch_low,
                              cai_sch_chan_rec_type, code_chan_sch_low);
                 }

                 UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].thx_sch_high_incl,
                            cai_sch_chan_rec_type, thx_sch_high_incl);

                 if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].thx_sch_high_incl)
                 {
                   UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].qof_mask_id_sch_high,
                              cai_sch_chan_rec_type, qof_mask_id_sch_high);
                   UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].code_chan_sch_high,
                   cai_sch_chan_rec_type, code_chan_sch_high);
                 }
               } // for (j = ..)
             }
         } // if (int_ptr->ho.sch_incl)
        } // for (i=0;i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS;i++)
      } // if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A))
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
      {
        UNPACKB_PG(ho.thx_and_ccsh_info.ccsh_included, cai_ho_msg_ccsh_type,
                   ccsh_included);

        if (int_ptr->ho.thx_and_ccsh_info.ccsh_included)
        {
          UNPACKB_PG(ho.thx_and_ccsh_info.use_ccsh_encoder_time,
            cai_ho_msg_ccsh_type, use_ccsh_encoder_time);

          if (int_ptr->ho.thx_and_ccsh_info.use_ccsh_encoder_time)
          {
            UNPACKB_PG(ho.thx_and_ccsh_info.ccsh_encoder_action_time,
                cai_ho_msg_ccsh_type, ccsh_encoder_action_time);
          }

          if (int_ptr->ho.sch_incl)
          {
            for (i=0; i<int_ptr->ho.num_pilots &&
                     i<CAI_HO_MSG_MAX_PILOTS; i++)
            {
              for (j=0; j<int_ptr->ho.pilot[i].num_sch &&
                       j<CAI_MAX_NUM_SCH_CHAN; j++)
              {
                if (int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl)
                {
                  UNPACKB_PG(ho.thx_and_ccsh_info.pilot[i].sch[j].ccsh_encoder_type,
                     cai_ho_msg_ccsh_type, ccsh_encoder_type);
                }
              }
            }
          }
        } /* if ccsh_included */
      }  /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B) */
#endif /* FEATURE_IS2000_REL_B */

    } // if ((int_ptr->ho.ch_ind == CAI_DED_CTL) || ...

#ifdef FEATURE_IS2000_REL_C
    else if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) && (int_ptr->ho.ch_ind == CAI_REFER_TO_EXT_CH_IND))
    {
      int_ptr->ho.ext_ch_ind =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, ext_ch_ind));
      ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, ext_ch_ind);

      ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, reserved);

      if ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_F) ||
          (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_D) ||
          (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_F) ||
          (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PD_D) ||
          (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_FD) ||
          (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PFD_FD))
      {
        int_ptr->ho.pdch_control_hold =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, pdch_control_hold));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, pdch_control_hold);

        int_ptr->ho.full_ci_feedback_ind =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, full_ci_feedback_ind));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, full_ci_feedback_ind);

        int_ptr->ho.rev_cqich_frame_offset =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_frame_offset));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_frame_offset);

        int_ptr->ho.rev_cqich_reps =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_reps));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_reps);

        int_ptr->ho.rev_ackch_reps =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rev_ackch_reps));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rev_ackch_reps);

        if (int_ptr->ho.sch_incl &&
            (int_ptr->ho.ext_ch_ind != CAI_EXT_CHIND_PC_F) &&
            (int_ptr->ho.ext_ch_ind != CAI_EXT_CHIND_PC_D))
        {
          int_ptr->ho.sch_cfg.num_for_sch =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, num_for_sch));
          ext_msg_pos += FSIZ(cai_sch_cfg_type, num_for_sch);

          for (i=0; i<int_ptr->ho.sch_cfg.num_for_sch &&
                 i<CAI_MAX_NUM_FOR_SCH_CFG; i++)
          {
            int_ptr->ho.sch_cfg.for_sch_cfg[i].for_sch_id =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, for_sch_id));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, for_sch_id);

            int_ptr->ho.sch_cfg.for_sch_cfg[i].sccl_index =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, sccl_index));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, sccl_index);

            int_ptr->ho.sch_cfg.for_sch_cfg[i].for_sch_rate =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, for_sch_rate));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, for_sch_rate);
          }
        }

        if (int_ptr->ho.sch_incl)
        {
          int_ptr->ho.sch_cfg.num_rev_sch =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, num_rev_sch));
          ext_msg_pos += FSIZ(cai_sch_cfg_type, num_rev_sch);

          for (i=0; i<int_ptr->ho.sch_cfg.num_rev_sch &&
                 i<CAI_MAX_NUM_REV_SCH_CFG; i++)
          {
            int_ptr->ho.sch_cfg.rev_sch_cfg[i].rev_sch_id =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, rev_sch_id));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, rev_sch_id);

            int_ptr->ho.sch_cfg.rev_sch_cfg[i].rev_walsh_id =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, rev_walsh_id));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, rev_walsh_id);

            int_ptr->ho.sch_cfg.rev_sch_cfg[i].rev_sch_rate =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, rev_sch_rate));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, rev_sch_rate);
          }
        }

        int_ptr->ho.num_pilots =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_fix_type, num_pilots));
        ext_msg_pos += FSIZ(cai_ho_msg_fix_type, num_pilots);

        if((int_ptr->ho.num_pilots == 0) ||
            (int_ptr->ho.num_pilots > CAI_HO_MSG_MAX_PILOTS)
          )
        {
          M1X_MSG( DCP, LEGACY_ERROR,
            "Unsupported num_pilots = %d is received",
            int_ptr->ho.num_pilots);
          status = CAIX_INV_MSG_S;
          return status;
        }

        int_ptr->ho.srch_offset_incl =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_is2000_type, srch_offset_incl));
        ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, srch_offset_incl);

        int_ptr->ho.pdch_group_ind_incl =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, pdch_group_ind_incl));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, pdch_group_ind_incl);

        int_ptr->ho.for_pdch_parms_incl =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_parms_incl));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_parms_incl);

        if (int_ptr->ho.for_pdch_parms_incl)
        {
          int_ptr->ho.for_pdch_params.for_pdch_rlgain_incl =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_rlgain_incl));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_rlgain_incl);

          if (int_ptr->ho.for_pdch_params.for_pdch_rlgain_incl)
          {
            int_ptr->ho.for_pdch_params.rlgain_ackch_pilot =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rlgain_ackch_pilot));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rlgain_ackch_pilot);

            int_ptr->ho.for_pdch_params.rlgain_cqich_pilot =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rlgain_cqich_pilot));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rlgain_cqich_pilot);
          }

          int_ptr->ho.for_pdch_params.num_soft_switching_frames =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_frames));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_frames);

          int_ptr->ho.for_pdch_params.num_softer_switching_frames =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_frames));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_frames);

          int_ptr->ho.for_pdch_params.num_soft_switching_slots =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_slots));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_slots);

          int_ptr->ho.for_pdch_params.num_softer_switching_slots =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_slots));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_slots);

          int_ptr->ho.for_pdch_params.chm_switching_params_incl =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, chm_switching_params_incl));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, chm_switching_params_incl);

          if (int_ptr->ho.for_pdch_params.chm_switching_params_incl)
          {
            int_ptr->ho.for_pdch_params.num_soft_switching_frames_chm =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_frames_chm));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_frames_chm);

            int_ptr->ho.for_pdch_params.num_softer_switching_frames_chm =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_frames_chm));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_frames_chm);

            int_ptr->ho.for_pdch_params.num_soft_switching_slots_chm =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_slots_chm));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_slots_chm);

            int_ptr->ho.for_pdch_params.num_softer_switching_slots_chm =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_slots_chm));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_slots_chm);
          }  /* if chm_switching_params_incl */

          int_ptr->ho.for_pdch_params.pdch_soft_switching_delay =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, pdch_soft_switching_delay));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, pdch_soft_switching_delay);

          int_ptr->ho.for_pdch_params.pdch_softer_switching_delay =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, pdch_softer_switching_delay));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, pdch_softer_switching_delay);

          int_ptr->ho.for_pdch_common_parms =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_common_parms));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_common_parms);

          if (int_ptr->ho.for_pdch_common_parms)
          {
            int_ptr->ho.walsh_table_id =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, walsh_table_id));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, walsh_table_id);

            int_ptr->ho.num_pdcch =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_pdcch));

            if((int_ptr->ho.num_pdcch + 1) > CAI_MAX_NUM_FOR_PDCCH)
            {
              M1X_MSG( DCP, LEGACY_ERROR,
                "Unsupported num_pdcch = %d is received",
                int_ptr->ho.num_pdcch);
              status = CAIX_INV_MSG_S;
              return status;
            }

            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_pdcch);

            for (i=0; i<int_ptr->ho.num_pdcch + 1; i++)
            {
              int_ptr->ho.for_pdcch_walsh[i] =
                b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdcch_walsh));
              ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdcch_walsh);
            } /* for */
          }  /* if for_pdch_common_parms */
        }  /* if for_pdch_parms_incl */

        for (i=0;i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS;i++)
        {
          int_ptr->ho.pilot[i].pilot_pn =
            b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_type, pilot_pn));
          ext_msg_pos += FSIZ(cai_ho_msg_pilot_type, pilot_pn);

          if (int_ptr->ho.srch_offset_incl)
          {
            int_ptr->ho.pilot[i].srch_offset =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, srch_offset));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, srch_offset);
          }
          else
          {
            int_ptr->ho.pilot[i].srch_offset = 0;
          }

          int_ptr->ho.pilot[i].add_pilot_rec_incl =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, add_pilot_rec_incl));
          ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, add_pilot_rec_incl);

          if (int_ptr->ho.pilot[i].add_pilot_rec_incl)
          {
            word tmp_record_len = 0;
            word record_start_pos = 0;

            int_ptr->ho.pilot[i].pilot_rec_type =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, pilot_rec_type));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, pilot_rec_type);

            tmp_record_len = b_unpackb(buf_ptr,ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type,record_len));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type,record_len);

            record_start_pos = ext_msg_pos;
            xlate_add_pilot_rec(int_ptr->ho.pilot[i].pilot_rec_type,
              buf_ptr, ext_msg_pos,
              &(int_ptr->ho.pilot[i].add_pilot_rec));
            ext_msg_pos = record_start_pos + tmp_record_len*8;
          }  /* if add_pilot_rec_incl */

          int_ptr->ho.pilot[i].for_pdch_incl =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_incl));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_incl);

          if (int_ptr->ho.pilot[i].for_pdch_incl &&
              !int_ptr->ho.for_pdch_common_parms)
          {
            int_ptr->ho.pilot[i].walsh_table_id =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, walsh_table_id));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, walsh_table_id);

            int_ptr->ho.pilot[i].num_pdcch =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_pdcch));

            if((int_ptr->ho.pilot[i].num_pdcch + 1) > CAI_MAX_NUM_FOR_PDCCH)
            {
              M1X_MSG( DCP, LEGACY_ERROR,
                "Unsupported num_pdcch = %d is received",
                int_ptr->ho.pilot[i].num_pdcch);
              status = CAIX_INV_MSG_S;
              return status;
            }

            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_pdcch);

            for (j=0; j<int_ptr->ho.pilot[i].num_pdcch + 1; j++)
            {
              int_ptr->ho.pilot[i].for_pdcch_walsh[j] =
                b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdcch_walsh));
              ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdcch_walsh);
            }
          }

          if (int_ptr->ho.pilot[i].for_pdch_incl)
          {
            int_ptr->ho.pilot[i].mac_id =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, mac_id));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, mac_id);

            int_ptr->ho.pilot[i].rev_cqich_cover =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_cover));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_cover);
          }

          if (int_ptr->ho.pilot[i].for_pdch_incl &&
              ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_F)
               || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_D)
                     ))
          {
            UNPACKB_PG(ho.pilot[i].for_cpcch_walsh, cai_ho_msg_ch_ind_0_type, for_cpcch_walsh);
          }

          if (int_ptr->ho.pilot[i].for_pdch_incl &&
              ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_F)
               || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_D)
               ))
          {
            UNPACKB_PG(ho.pilot[i].for_cpcsch, cai_ho_msg_ch_ind_0_type, for_cpcsch);
          }

          int_ptr->ho.pilot[i].pwr_comb_ind =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_type, pwr_comb_ind));
          ext_msg_pos += FSIZ(cai_ho_msg_pilot_type, pwr_comb_ind);

          if (int_ptr->ho.pdch_group_ind_incl)
          {
            int_ptr->ho.pilot[i].pdch_group_ind =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, pdch_group_ind));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, pdch_group_ind);
          }

          if ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_F)
              || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_FD)
              || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PFD_FD)
             )
          {
            int_ptr->ho.pilot[i].code_chan_fch =
              b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, code_chan_fch));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, code_chan_fch);

            int_ptr->ho.pilot[i].qof_mask_id_fch =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, qof_mask_id_fch));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, qof_mask_id_fch);
          }

          if ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PD_D)
              || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PFD_FD)
             )
          {
            int_ptr->ho.pilot[i].code_chan_dcch =
              b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, code_chan_dcch));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, code_chan_dcch);

            int_ptr->ho.pilot[i].qof_mask_id_dcch =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, qof_mask_id_dcch));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, qof_mask_id_dcch);
          }

          if (int_ptr->ho.sch_incl)
          {
            int_ptr->ho.pilot[i].num_sch =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, num_sch));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, num_sch);

            for (j=0;j<int_ptr->ho.pilot[i].num_sch && j<CAI_MAX_NUM_SCH_CHAN;j++)
            {
              int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].for_sch_id =
                b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_chan_rec_type, for_sch_id));
              ext_msg_pos += FSIZ(cai_sch_chan_rec_type, for_sch_id);

              int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].sccl_index =
                b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_chan_rec_type, sccl_index));
              ext_msg_pos += FSIZ(cai_sch_chan_rec_type, sccl_index);

              int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl =
                b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_chan_rec_type, pilot_incl));
              ext_msg_pos += FSIZ(cai_sch_chan_rec_type, pilot_incl);

              if ( int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl)
              {
                int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].code_chan_sch =
                  b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_sch_chan_rec_type, code_chan_sch));
                ext_msg_pos += FSIZ(cai_sch_chan_rec_type, code_chan_sch);

                int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].qof_mask_id_sch =
                  b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_chan_rec_type, qof_mask_id_sch));
                ext_msg_pos += FSIZ(cai_sch_chan_rec_type, qof_mask_id_sch);
              }
            } /* for (j=0;j<int_ptr->ho.pilot[i].num_sch && j<CAI_MAX_NUM_SCH_CHAN;j++) */
          }  /* if sch_incl */
        } /*  for (i=0;i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS;i++) */


        int_ptr->ho.thx_and_ccsh_info.ccsh_included =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ccsh_type, ccsh_included));
        ext_msg_pos += FSIZ(cai_ho_msg_ccsh_type, ccsh_included);

        if (int_ptr->ho.thx_and_ccsh_info.ccsh_included)
        {
          int_ptr->ho.thx_and_ccsh_info.use_ccsh_encoder_time =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ccsh_type, use_ccsh_encoder_time));
          ext_msg_pos += FSIZ(cai_ho_msg_ccsh_type, use_ccsh_encoder_time);

          if (int_ptr->ho.thx_and_ccsh_info.use_ccsh_encoder_time)
          {
            int_ptr->ho.thx_and_ccsh_info.ccsh_encoder_action_time =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ccsh_type, ccsh_encoder_action_time));
            ext_msg_pos += FSIZ(cai_ho_msg_ccsh_type, ccsh_encoder_action_time);
          }

          if (int_ptr->ho.sch_incl)
          {
            for (i=0; i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS; i++)
            {
              for (j=0; j<int_ptr->ho.pilot[i].num_sch &&
                        j<CAI_MAX_NUM_SCH_CHAN; j++)
              {
                if (int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl)
                {
                  int_ptr->ho.thx_and_ccsh_info.pilot[i].sch[j].ccsh_encoder_type =
                  b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ccsh_type, ccsh_encoder_type));
                  ext_msg_pos += FSIZ(cai_ho_msg_ccsh_type, ccsh_encoder_type);
                }
              }
            }
          }
        } /* if ccsh_included */

      }
    }  /* if p-rev >= 9 and ch_ind == 0 */
#endif /* FEATURE_IS2000_REL_C */

    /* This should work for ch_ind 0 as well as ch_ind 2, 5, 6 and 7 --
       since the length of ch_ind 0 is active_set_rec_len x 8 */
    ext_msg_pos = start_record_pos + record_len*8;

#ifdef FEATURE_IS2000_REL_C
    /* Rev_fch_gating_mode and its dependents became conditional in
       Release C.  Hence, if Release C is not defined, or the p-rev-in-use
       is less than 9, parse them unconditionally.  If the p-rev-in-use
       is 9 or greater, the field will be ommitted if:
       + ch_ind is 2 or 6
       + ch_ind is 0 and ext_ch_ind is 2 or 4
    */

    parse_rev_fch_gating_mode = FALSE;

    if (caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_C)
    {
      parse_rev_fch_gating_mode = TRUE;
    }
    else
    {
      if (int_ptr->ho.ch_ind == CAI_REFER_TO_EXT_CH_IND)
      {
        if ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_F)
            || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_F)
            || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_FD)
            || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PFD_FD)
           )
        {
          parse_rev_fch_gating_mode = TRUE;
        }
      }
      else if ((int_ptr->ho.ch_ind == CAI_FUND_CONT_REV_PLT) ||
         (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
      {
        parse_rev_fch_gating_mode = TRUE;
      }
    }

    if (parse_rev_fch_gating_mode)
#endif /* FEATURE_IS2000_REL_C */
    {
      int_ptr->ho.rev_fch_gating_mode = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_is2000_type, rev_fch_gating_mode));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_fch_gating_mode);

      if (int_ptr->ho.rev_fch_gating_mode)
      {
        int_ptr->ho.rev_pwr_cntl_delay_incl = b_unpackb(buf_ptr, ext_msg_pos,
              FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay_incl));
        ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay_incl);

        if (int_ptr->ho.rev_pwr_cntl_delay_incl)
        {
          int_ptr->ho.rev_pwr_cntl_delay = b_unpackb(buf_ptr, ext_msg_pos,
           FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay));
          ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay);
        }
      }
    }


    if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)

        || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

       )
    {
      status = xlate_ho_enc_cc(buf_ptr, int_ptr, &ext_msg_pos);
      if(status != CAIX_DONE_S)
      {
        return status;
      }
      int_ptr->ho.cs_supported =  b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_cs_type, cs_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_cs_type, cs_supported);
    }  // PREV 7



    if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)

        || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)

       )
    {
      int_ptr->ho.chm_supported =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, chm_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, chm_supported);

      int_ptr->ho.cdma_off_time_rep_sup_ind =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_sup_ind));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_sup_ind);

      if (int_ptr->ho.cdma_off_time_rep_sup_ind)
      {
        int_ptr->ho.cdma_off_time_rep_threshold_unit =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_threshold_unit));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_threshold_unit);

        int_ptr->ho.cdma_off_time_rep_threshold =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_threshold));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_threshold);
      }

      int_ptr->ho.release_to_idle_ind =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, release_to_idle_ind));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, release_to_idle_ind);

      int_ptr->ho.msg_integrity_sup =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, msg_integrity_sup));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, msg_integrity_sup);

      int_ptr->ho.gen_2g_key =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, gen_2g_key));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, gen_2g_key);

      int_ptr->ho.register_in_idle =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, register_in_idle));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, register_in_idle);
      int_ptr->ho.plcm_type_incl =
      b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_plcm_info_type, plcm_type_incl));
      ext_msg_pos += FSIZ(cai_plcm_info_type, plcm_type_incl);

      if (int_ptr->ho.plcm_type_incl)
      {
        int_ptr->ho.plcm_type =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_plcm_info_type, plcm_type));
        ext_msg_pos += FSIZ(cai_plcm_info_type, plcm_type);

        if (int_ptr->ho.plcm_type == CAI_PLCM_TYPE_BS_SPEC)
        {
          b_unpackq(buf_ptr, ext_msg_pos, FSIZ(cai_plcm_info_type, plcm_39), int_ptr->ho.plcm_39);
          ext_msg_pos += FSIZ(cai_plcm_info_type, plcm_39);
        }
      }
    }


#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      if (int_ptr->ho.srch_inc)
      {
        int_ptr->ho.t_tdrop_range_incl =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, t_tdrop_range_incl));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, t_tdrop_range_incl);

        if (int_ptr->ho.t_tdrop_range_incl)
        {
          int_ptr->ho.t_tdrop_range =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, t_tdrop_range));
          ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, t_tdrop_range);
        }
      }

      int_ptr->ho.for_pdch_supported =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, for_pdch_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, for_pdch_supported);

      if (int_ptr->ho.for_pdch_supported)
      {
        int_ptr->ho.pdch_chm_supported =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, pdch_chm_supported));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, pdch_chm_supported);

      }

      int_ptr->ho.pilot_info_req_supported =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, pilot_info_req_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, pilot_info_req_supported);

      int_ptr->ho.enc_supported =
      b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, enc_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, enc_supported);

      if (int_ptr->ho.enc_supported)
      {
        int_ptr->ho.sig_encrypt_sup.cmea =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sig_encrypt_sup_type, cmea));
        ext_msg_pos += FSIZ(cai_sig_encrypt_sup_type, cmea);

        int_ptr->ho.sig_encrypt_sup.ecmea =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sig_encrypt_sup_type, ecmea));
        ext_msg_pos += FSIZ(cai_sig_encrypt_sup_type, ecmea);

        int_ptr->ho.sig_encrypt_sup.rea =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sig_encrypt_sup_type, rea));
        ext_msg_pos += FSIZ(cai_sig_encrypt_sup_type, rea);

        ext_msg_pos += FSIZ(cai_sig_encrypt_sup_type, reserved);

        int_ptr->ho.ui_encrypt_sup.oryx =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ui_encrypt_sup_type, oryx));
        ext_msg_pos += FSIZ(cai_ui_encrypt_sup_type, oryx);

        int_ptr->ho.ui_encrypt_sup.rea =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ui_encrypt_sup_type, rea));
        ext_msg_pos += FSIZ(cai_ui_encrypt_sup_type, rea);

        ext_msg_pos += FSIZ(cai_ui_encrypt_sup_type, reserved);
      }

      int_ptr->ho.use_sync_id =
      b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, use_sync_id));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, use_sync_id);

      int_ptr->ho.sid_incl =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, sid_incl));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, sid_incl);

      if (int_ptr->ho.sid_incl)
      {
        int_ptr->ho.sid =
          b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, sid));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, sid);
      }

      int_ptr->ho.nid_incl =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, nid_incl));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, nid_incl);

      if (int_ptr->ho.nid_incl)
      {
        int_ptr->ho.nid =
          b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, nid));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, nid);
      }

      int_ptr->ho.sdb_supported =
      b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, sdb_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, sdb_supported);

      if (int_ptr->ho.cs_supported)
      {
        int_ptr->ho.mob_qos =
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, mob_qos));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, mob_qos);
      }

      int_ptr->ho.ms_init_pos_loc_sup_ind =
      b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, ms_init_pos_loc_sup_ind));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, ms_init_pos_loc_sup_ind);

    }
#endif /* FEATURE_IS2000_REL_C */

  } // if (UHDM specific parsing)

  /**********************************************************

              GHDM Specific parsing

  ***********************************************************/
  if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000) &&
      (int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG))
  {
    int_ptr->ho.fpc_subchan_gain = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(cai_ho_msg_is2000_type, fpc_subchan_gain));
    ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, fpc_subchan_gain);

    int_ptr->ho.use_pc_time = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(cai_ho_msg_is2000_type, use_pc_time));
    ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, use_pc_time);

    if (int_ptr->ho.use_pc_time)
    {
      int_ptr->ho.pc_action_time = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_is2000_type, pc_action_time));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, pc_action_time);
    }

    if (int_ptr->ho.extra_parms)
    {
      int_ptr->ho.extra.rlgain_traffic_pilot = b_unpackb(buf_ptr,
        ext_msg_pos, FSIZ(cai_ho_msg_is2000_type, rlgain_traffic_pilot));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rlgain_traffic_pilot);

      int_ptr->ho.extra.default_rlag = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_is2000_type, default_rlag));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, default_rlag);

      int_ptr->ho.extra.nnscr_included = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_is2000_type, nnscr_included));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, nnscr_included);

      if (int_ptr->ho.extra.nnscr_included)
      {
        status = xlate_int_non_neg_srv_cfg(buf_ptr,&ext_msg_pos,
                                  &(int_ptr->ho.extra.non_neg_cfg));
        if (status != CAIX_DONE_S)
        {
          return status;
        }
      }
    }

    int_ptr->ho.rev_fch_gating_mode = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(cai_ho_msg_is2000_type, rev_fch_gating_mode));
    ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_fch_gating_mode);

    if (int_ptr->ho.rev_fch_gating_mode)
    {
      int_ptr->ho.rev_pwr_cntl_delay_incl = b_unpackb( buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay_incl));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay_incl);

      if (int_ptr->ho.rev_pwr_cntl_delay_incl)
      {
        int_ptr->ho.rev_pwr_cntl_delay = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay));
        ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay);
      }
    }

#ifdef FEATURE_IS2000_REL_A
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      status = xlate_ho_enc_cc(buf_ptr, int_ptr, &ext_msg_pos);
      if(status != CAIX_DONE_S)
      {
        M1X_MSG( DCP, LEGACY_ERROR,
          "Translation of enc info (xlate_ho_enc_cc) failed ");
        return status;
      }
      int_ptr->ho.cs_supported = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_cs_type, cs_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_cs_type, cs_supported);
    }  // PREV 7
#endif /* FEATURE_IS2000_REL_A */

  } // if (GHDM specific parsing)


  /* If status okay so far, check processed length vs. len parameter
     including possible reserved bits (ext_msg_pos <= len <= ext_msg_pos+7) */
  if ((status == CAIX_DONE_S) && (ext_msg_pos > len))
  {
    /* If we go pass the end of the message, that's an error. */
    status = CAIX_INV_LEN_S;
  }

  return (status);

} /* xlate_ext_ho_msg */

/*===========================================================================

FUNCTION XLATE_EXT_TC_ESCAM

DESCRIPTION
  This function translates a Extended Supplemental Channel Assignment
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Supplemental Channel Assignment
  Message.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_escam
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position of record in message */
  word i, k;
    /* Loop Counters */
#ifdef FEATURE_IS2000_REL_A
  word j;
    /* Loop Counters */
  word num_sup_sho = 0;
    /* Num_sup_sho of the current 3X record */
  boolean found_num_sup_sho;
    /* Found num_sup_sho of the current 3X record */
#endif /* FEATURE_IS2000_REL_A */
#ifdef FEATURE_IS2000_REL_B
  word start_sch_rec_pos;
    /* Indicates beginning of sch record */
  word sch_rec_len;
    /* Length of sch record */
#endif /* FEATURE_IS2000_REL_B */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_escam_type

  msg_pos = 0;

  xlate_ext_tc_hdr(buf_ptr, &int_ptr->escam.hdr);

  msg_pos = FENDPOS(cai_escam_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
       CAIX_MACI_REQUIRED,
       &msg_pos, buf_ptr, &int_ptr->escam.hdr.msg_int,
       int_ptr->escam.msg_type,
       int_ptr->escam.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
  {
#ifdef FEATURE_IS2000_REL_A
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
        &int_ptr->escam.hdr, int_ptr->escam.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
    {
      int_ptr->escam.start_time_unit = b_unpackb(buf_ptr, msg_pos,
  FSIZ(MTYPE, start_time_unit));
      msg_pos += FSIZ(MTYPE, start_time_unit);

      int_ptr->escam.rev_sch_dtx_duration = b_unpackb(buf_ptr, msg_pos,
  FSIZ(MTYPE, rev_sch_dtx_duration));
      msg_pos += FSIZ(MTYPE, rev_sch_dtx_duration);

      int_ptr->escam.use_t_add_abort = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, use_t_add_abort));
      msg_pos += FSIZ(MTYPE, use_t_add_abort);

      int_ptr->escam.use_scrm_seq_num = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, use_scrm_seq_num));
      msg_pos += FSIZ(MTYPE, use_scrm_seq_num);

      if (int_ptr->escam.use_scrm_seq_num)
      {
        int_ptr->escam.scrm_seq_num = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, scrm_seq_num));
        msg_pos += FSIZ(MTYPE, scrm_seq_num);
      }

      int_ptr->escam.add_info_incl = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, add_info_incl));
      msg_pos += FSIZ(MTYPE, add_info_incl);

      if (int_ptr->escam.add_info_incl)
      {
        int_ptr->escam.fpc_pri_chan = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, fpc_pri_chan));
        msg_pos += FSIZ(MTYPE, fpc_pri_chan);
      }

      int_ptr->escam.rev_cfg_included = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, rev_cfg_included));
      msg_pos += FSIZ(MTYPE, rev_cfg_included);

      if (int_ptr->escam.rev_cfg_included)
      {
        int_ptr->escam.num_rev_cfg_recs = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, num_rev_cfg_recs));
        msg_pos += FSIZ(MTYPE, num_rev_cfg_recs);

        if ((int_ptr->escam.num_rev_cfg_recs+1) > CAI_ESCAM_MAX_REV_CFG)
        {
          return CAIX_INV_LEN_S;
        }

        for (i=0; i<(int_ptr->escam.num_rev_cfg_recs+1); i++)
        {
          int_ptr->escam.rev_cfg[i].rev_sch_id =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_id));
          msg_pos += FSIZ(MTYPE, rev_sch_id);

          int_ptr->escam.rev_cfg[i].rev_walsh_id =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_walsh_id));
          msg_pos += FSIZ(MTYPE, rev_walsh_id);

          int_ptr->escam.rev_cfg[i].rev_sch_rate =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_rate));
          msg_pos += FSIZ(MTYPE, rev_sch_rate);
        }
      }

      int_ptr->escam.num_rev_sch = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, num_rev_sch));

      if(int_ptr->escam.num_rev_sch > CAI_ESCAM_MAX_REV_SCH)
      {
        M1X_MSG( DCP, LEGACY_ERROR,
          "Unsupported num_rev_sch = %d is received",
          int_ptr->escam.num_rev_sch);
        status = CAIX_INV_MSG_S;
        return status;
      }

      msg_pos += FSIZ(MTYPE, num_rev_sch);

      for (i=0; i<int_ptr->escam.num_rev_sch; i++)
      {
        int_ptr->escam.rev_sch[i].rev_sch_id = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, rev_sch_id_2));
        msg_pos += FSIZ(MTYPE, rev_sch_id_2);

        int_ptr->escam.rev_sch[i].rev_sch_duration =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_duration));
        msg_pos += FSIZ(MTYPE, rev_sch_duration);

        int_ptr->escam.rev_sch[i].rev_sch_start_time_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_start_time_incl));
        msg_pos += FSIZ(MTYPE, rev_sch_start_time_incl);

        if (int_ptr->escam.rev_sch[i].rev_sch_start_time_incl)
        {
          int_ptr->escam.rev_sch[i].rev_sch_start_time =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_start_time));
          msg_pos += FSIZ(MTYPE, rev_sch_start_time);
        }

        int_ptr->escam.rev_sch[i].rev_sch_rate =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_rate_2));
        msg_pos += FSIZ(MTYPE, rev_sch_rate_2);
      }

      int_ptr->escam.for_cfg_included = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, for_cfg_included));
      msg_pos += FSIZ(MTYPE, for_cfg_included);

      if (int_ptr->escam.for_cfg_included)
      {
        int_ptr->escam.for_sch_fer_rep = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, for_sch_fer_rep));
        msg_pos += FSIZ(MTYPE, for_sch_fer_rep);

        int_ptr->escam.num_for_cfg_recs = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, num_for_cfg_recs));
        msg_pos += FSIZ(MTYPE, num_for_cfg_recs);

        if ((int_ptr->escam.num_for_cfg_recs + 1) > CAI_ESCAM_MAX_FOR_CFG)
        {
          return CAIX_INV_LEN_S;
        }

        for (i=0; i<int_ptr->escam.num_for_cfg_recs+1; i++)
        {
          int_ptr->escam.for_cfg[i].for_sch_id =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_id));
          msg_pos += FSIZ(MTYPE, for_sch_id);

          int_ptr->escam.for_cfg[i].sccl_index =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sccl_index));
          msg_pos += FSIZ(MTYPE, sccl_index);

          int_ptr->escam.for_cfg[i].for_sch_rate =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_rate));
          msg_pos += FSIZ(MTYPE, for_sch_rate);

          int_ptr->escam.for_cfg[i].num_sup_sho =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_sup_sho));

          if ((int_ptr->escam.for_cfg[i].num_sup_sho+1) > CAI_ESCAM_MAX_SUP_SHO)
          {
            M1X_MSG( DCP, LEGACY_ERROR,
              "Unsupported num_sup_sho = %d is received",
              int_ptr->escam.for_cfg[i].num_sup_sho);
            status = CAIX_INV_MSG_S;
            return status;
          }

          msg_pos += FSIZ(MTYPE, num_sup_sho);

          for (k=0; k<(int_ptr->escam.for_cfg[i].num_sup_sho+1); k++)
          {
            int_ptr->escam.for_cfg[i].sup_sho[k].pilot_pn =
              b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, pilot_pn));
            msg_pos += FSIZ(MTYPE, pilot_pn);

            int_ptr->escam.for_cfg[i].sup_sho[k].add_pilot_rec_incl =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, add_pilot_rec_incl));
            msg_pos += FSIZ(MTYPE, add_pilot_rec_incl);

            if (int_ptr->escam.for_cfg[i].sup_sho[k].add_pilot_rec_incl)
            {
              word record_len = 0;
              word record_start_pos = 0;

              int_ptr->escam.for_cfg[i].sup_sho[k].active_pilot_rec_type =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, active_pilot_rec_type));
              msg_pos += FSIZ(MTYPE, active_pilot_rec_type);

              record_len = b_unpackb(buf_ptr, msg_pos,
                FSIZ(MTYPE, record_len)); msg_pos += FSIZ(MTYPE, record_len);

              record_start_pos = msg_pos;

              xlate_add_pilot_rec(
                int_ptr->escam.for_cfg[i].sup_sho[k].active_pilot_rec_type,
                buf_ptr, msg_pos,
                &(int_ptr->escam.for_cfg[i].sup_sho[k].add_pilot_rec));

              msg_pos = record_start_pos + record_len*8;
            }

            int_ptr->escam.for_cfg[i].sup_sho[k].for_sch_cc_index =
              b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_cc_index));
            msg_pos += FSIZ(MTYPE, for_sch_cc_index);

            int_ptr->escam.for_cfg[i].sup_sho[k].qof_mask_id_sch =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, qof_mask_id_sch));
            msg_pos += FSIZ(MTYPE, qof_mask_id_sch);
          } /* end for */
        } /* end for */
      } /* end if (int_ptr->escam.for_cfg_included) */

      int_ptr->escam.num_for_sch =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_for_sch));
      msg_pos += FSIZ(MTYPE, num_for_sch);

      if ((int_ptr->escam.num_for_sch) > CAI_ESCAM_MAX_FOR_SCH)
      {
        return CAIX_INV_LEN_S;
      }

      for (i=0; i<int_ptr->escam.num_for_sch; i++)
      {
        int_ptr->escam.for_sch[i].for_sch_id =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_id_2));
        msg_pos += FSIZ(MTYPE, for_sch_id_2);

        int_ptr->escam.for_sch[i].for_sch_duration =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_duration));
        msg_pos += FSIZ(MTYPE, for_sch_duration);

        int_ptr->escam.for_sch[i].for_sch_start_time_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_start_time_incl));
        msg_pos += FSIZ(MTYPE, for_sch_start_time_incl);

        if (int_ptr->escam.for_sch[i].for_sch_start_time_incl)
        {
          int_ptr->escam.for_sch[i].for_sch_start_time =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_start_time));
          msg_pos += FSIZ(MTYPE, for_sch_start_time);
        }

        int_ptr->escam.for_sch[i].sccl_index =
          b_unpackb(buf_ptr,msg_pos, FSIZ(MTYPE,sccl_index_2));
        msg_pos += FSIZ(MTYPE,sccl_index_2);
      } /* end for */

      int_ptr->escam.fpc_incl =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_incl));
      msg_pos += FSIZ(MTYPE, fpc_incl);

      if (int_ptr->escam.fpc_incl)
      {
        int_ptr->escam.fpc_mode_sch =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_mode_sch));
        msg_pos += FSIZ(MTYPE, fpc_mode_sch);

        int_ptr->escam.fpc_sch_init_setpt_op =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sch_init_setpt_op));
        msg_pos += FSIZ(MTYPE, fpc_sch_init_setpt_op);

        if ((int_ptr->escam.fpc_mode_sch == 1) ||
            (int_ptr->escam.fpc_mode_sch == 2))
        {
          int_ptr->escam.fpc_sec_chan =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sec_chan));
          msg_pos += FSIZ(MTYPE, fpc_sec_chan);
        }

        int_ptr->escam.num_sup =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_sup));
        msg_pos += FSIZ(MTYPE, num_sup);

        if ((int_ptr->escam.num_sup) > CAI_ESCAM_MAX_SUP)
        {
          return CAIX_INV_LEN_S;
        }

        for (i=0; i<int_ptr->escam.num_sup; i++)
        {
          int_ptr->escam.sup[i].sch_id =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sch_id));
          msg_pos += FSIZ(MTYPE, sch_id);

          int_ptr->escam.sup[i].fpc_sch_fer =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sch_fer));
          msg_pos += FSIZ(MTYPE, fpc_sch_fer);

          int_ptr->escam.sup[i].fpc_sch_init_setpt =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sch_init_setpt));
          msg_pos += FSIZ(MTYPE, fpc_sch_init_setpt);

          int_ptr->escam.sup[i].fpc_sch_min_setpt =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sch_min_setpt));
          msg_pos += FSIZ(MTYPE, fpc_sch_min_setpt);

          int_ptr->escam.sup[i].fpc_sch_max_setpt =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sch_max_setpt));
          msg_pos += FSIZ(MTYPE, fpc_sch_max_setpt);
        } /* end for */

        int_ptr->escam.fpc_thresh_sch_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_thresh_sch_incl));
        msg_pos += FSIZ(MTYPE, fpc_thresh_sch_incl);

        if (int_ptr->escam.fpc_thresh_sch_incl)
        {
          int_ptr->escam.fpc_setpt_thresh_sch =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_setpt_thresh_sch));
          msg_pos += FSIZ(MTYPE, fpc_setpt_thresh_sch);
        }
      } /* end if (int_ptr->escam.fpc_incl) */

      int_ptr->escam.rpc_incl =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rpc_incl));
      msg_pos += FSIZ(MTYPE, rpc_incl);

      if (int_ptr->escam.rpc_incl)
      {
        int_ptr->escam.rpc_num_sup =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rpc_num_sup));
        msg_pos += FSIZ(MTYPE, rpc_num_sup);

        for (i=0; (i<int_ptr->escam.rpc_num_sup+1) && (i < CAI_ESCAM_MAX_SUP); i++)
        {
          int_ptr->escam.rpc_sup[i].sch_id =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sch_id));
          msg_pos += FSIZ(MTYPE, sch_id);

          int_ptr->escam.rpc_sup[i].rlgain_sch_pilot =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rlgain_sch_pilot));
          msg_pos += FSIZ(MTYPE, rlgain_sch_pilot);
        }
      } /* end if (int_ptr->escam.rpc_incl) */

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        int_ptr->escam.threex_sch_info_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threex_sch_info_incl));
        msg_pos += FSIZ(MTYPE, threex_sch_info_incl);

        if (int_ptr->escam.threex_sch_info_incl)
        {
          if (!int_ptr->escam.for_cfg_included)
          {
            M1X_MSG( DCP, LEGACY_ERROR,
              "Invalid ESCAM 3X SCH info");
            return CAIX_INV_LEN_S;
          }

          int_ptr->escam.num_threex_cfg =
      b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_threex_cfg));

          if(int_ptr->escam.num_threex_cfg > CAI_ESCAM_MAX_THREEX_CFG)
          {
            M1X_MSG( DCP, LEGACY_ERROR,
              "Unsupported num_threex_cfg = %d is received",
              int_ptr->escam.num_threex_cfg);
            status = CAIX_INV_MSG_S;
            return status;
          }

          msg_pos += FSIZ(MTYPE, num_threex_cfg);

          for (i=0; i < int_ptr->escam.num_threex_cfg; i++)
          {
            int_ptr->escam.threex_cfg[i].for_sch_id =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threex_for_sch_id));
            msg_pos += FSIZ(MTYPE, threex_for_sch_id);

            int_ptr->escam.threex_cfg[i].num_threex_rec =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_threex_rec));
            msg_pos += FSIZ(MTYPE, num_threex_rec);

            for (j=0; j < (int_ptr->escam.threex_cfg[i].num_threex_rec + 1);
                 j++)
            {
              int_ptr->escam.threex_cfg[i].rec[j].sccl_index =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threex_sccl_index));
              msg_pos += FSIZ(MTYPE, threex_sccl_index);

              found_num_sup_sho = FALSE;

              /* Retrieve corresponding NUM_SUP_SHO using FOR_SCH_ID and
                 SCCL_INDEX */
              for (k=0; (k < (int_ptr->escam.num_for_cfg_recs + 1)) &&
                   (k < CAI_ESCAM_MAX_FOR_CFG); k++)
              {
                if ((int_ptr->escam.for_cfg[k].for_sch_id ==
                     int_ptr->escam.threex_cfg[i].for_sch_id) &&
                (int_ptr->escam.for_cfg[k].sccl_index ==
                     int_ptr->escam.threex_cfg[i].rec[j].sccl_index))
                {
                  num_sup_sho = int_ptr->escam.for_cfg[k].num_sup_sho;
                  found_num_sup_sho = TRUE;
            /* If doing SILK testing, pick the last one if there are
                     duplicates */
                  break;
                }
              }

              if (!found_num_sup_sho)
              {
                M1X_MSG( DCP, LEGACY_ERROR,
                  "ESCAM: No 1X record matches 3X info");
                return CAIX_INV_LEN_S;
              }

              for (k=0; k < (num_sup_sho + 1); k++)
              {
                int_ptr->escam.threex_cfg[i].rec[j].sup[k].threex_sch_low_incl =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(MTYPE, threex_sch_low_incl));
                msg_pos += FSIZ(MTYPE, threex_sch_low_incl);

                if (int_ptr->escam.threex_cfg[i].rec[j].sup[k].threex_sch_low_incl)
                {
                  int_ptr->escam.threex_cfg[i].rec[j].sup[k].qof_mask_id_sch_low =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(MTYPE, threex_qof_mask_id_sch_low));
                  msg_pos += FSIZ(MTYPE, threex_qof_mask_id_sch_low);

                  int_ptr->escam.threex_cfg[i].rec[j].sup[k].code_chan_sch_low =
                    b_unpackw(buf_ptr, msg_pos,
                    FSIZ(MTYPE, threex_code_chan_sch_low));
                  msg_pos += FSIZ(MTYPE, threex_code_chan_sch_low);
                }

                int_ptr->escam.threex_cfg[i].rec[j].sup[k].threex_sch_high_incl =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threex_sch_high_incl));
                msg_pos += FSIZ(MTYPE, threex_sch_high_incl);

                if (int_ptr->escam.threex_cfg[i].rec[j].sup[k].threex_sch_high_incl)
                {
                  int_ptr->escam.threex_cfg[i].rec[j].sup[k].qof_mask_id_sch_high =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(MTYPE, threex_qof_mask_id_sch_high));
                  msg_pos += FSIZ(MTYPE, threex_qof_mask_id_sch_high);

                  int_ptr->escam.threex_cfg[i].rec[j].sup[k].code_chan_sch_high =
                    b_unpackw(buf_ptr, msg_pos,
                    FSIZ(MTYPE, threex_code_chan_sch_high));
                  msg_pos += FSIZ(MTYPE, threex_code_chan_sch_high);
                }
              } /* for (k=0; k < (num_sup_sho + 1); k++) */
            } /* for (j=0; j < (int_ptr->escam.threex_cfg[i].num_threex_rec + 1); j++) */
          } /* for (i=0; i < int_ptr->escam.num_threex_cfg; i++)  */
        } /* if (int_ptr->escam.threex_sch_info_incl) */
      } /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A) */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
      {
        int_ptr->escam.ccsh_included =
          b_unpackb(buf_ptr,msg_pos,FSIZ(MTYPE,ccsh_included));
        msg_pos += FSIZ(MTYPE,ccsh_included);

        if (int_ptr->escam.ccsh_included)
        {
          if (!int_ptr->escam.for_cfg_included)
          {
            M1X_MSG( DCP, LEGACY_ERROR,
              "Invalid ESCAM CCSH info");
            return CAIX_INV_LEN_S;
          }

          for (i=0; i < (int_ptr->escam.num_for_cfg_recs + 1); i++)
          {
          for (j=0; j < (int_ptr->escam.for_cfg[i].num_sup_sho + 1); j++)
            {
              int_ptr->escam.ccsh_cfg[i].sup[j].ccsh_encoder_type =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ccsh_encoder_type));
              msg_pos += FSIZ(MTYPE, ccsh_encoder_type);
            }
          }
        }

        int_ptr->escam.for_sch_cc_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_cc_incl));
        msg_pos += FSIZ(MTYPE, for_sch_cc_incl);

        if (int_ptr->escam.for_sch_cc_incl)
        {
          for (i=0; i < int_ptr->escam.num_for_sch; i++)
          {
            int_ptr->escam.for_sch_cc[i].for_sch_id =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_for_sch_type, for_sch_id));
            msg_pos += FSIZ(cai_for_sch_type, for_sch_id);

            int_ptr->escam.for_sch_cc[i].for_sch_mux =
              b_unpackw(buf_ptr, msg_pos, FSIZ(cai_for_sch_type, for_sch_mux));
            msg_pos += FSIZ(cai_for_sch_type, for_sch_mux);

            /* SCH_REC_LEN includes its own length */
            start_sch_rec_pos = msg_pos;

            sch_rec_len =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, sch_rec_len));
            msg_pos += FSIZ(cai_sch_chn_cfg_type,sch_rec_len);

            int_ptr->escam.for_sch_cc[i].sch_chn_cfg.sch_rc =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, sch_rc));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, sch_rc);

            int_ptr->escam.for_sch_cc[i].sch_chn_cfg.coding =
              b_unpackb(buf_ptr,msg_pos,FSIZ(cai_sch_chn_cfg_type, coding));
                msg_pos += FSIZ(cai_sch_chn_cfg_type, coding);

            int_ptr->escam.for_sch_cc[i].sch_chn_cfg.frame_40_used =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_sch_chn_cfg_type, frame_40_used));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, frame_40_used);

            int_ptr->escam.for_sch_cc[i].sch_chn_cfg.frame_80_used =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_sch_chn_cfg_type, frame_80_used));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, frame_80_used);

            int_ptr->escam.for_sch_cc[i].sch_chn_cfg.max_rate =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, max_rate));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, max_rate);

            msg_pos = start_sch_rec_pos + 8*sch_rec_len;

          }
        } /* if (int_ptr->escam.for_sch_cc_incl) */

        int_ptr->escam.rev_sch_cc_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_cc_incl));
        msg_pos += FSIZ(MTYPE, rev_sch_cc_incl);

        if (int_ptr->escam.rev_sch_cc_incl)
        {
          for (i=0; i < int_ptr->escam.num_rev_sch; i++)
          {
            int_ptr->escam.rev_sch_cc[i].rev_sch_id =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rev_sch_type, rev_sch_id));
            msg_pos += FSIZ(cai_rev_sch_type, rev_sch_id);

            int_ptr->escam.rev_sch_cc[i].rev_sch_mux =
              b_unpackw(buf_ptr, msg_pos, FSIZ(cai_rev_sch_type, rev_sch_mux));
            msg_pos += FSIZ(cai_rev_sch_type, rev_sch_mux);

            /* SCH_REC_LEN includes its own length */
            start_sch_rec_pos = msg_pos;

            sch_rec_len =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, sch_rec_len));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, sch_rec_len);

            int_ptr->escam.rev_sch_cc[i].sch_chn_cfg.sch_rc =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, sch_rc));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, sch_rc);

            int_ptr->escam.rev_sch_cc[i].sch_chn_cfg.coding =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, coding));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, coding);

            int_ptr->escam.rev_sch_cc[i].sch_chn_cfg.frame_40_used =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, frame_40_used));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, frame_40_used);

            int_ptr->escam.rev_sch_cc[i].sch_chn_cfg.frame_80_used =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, frame_80_used));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, frame_80_used);

            int_ptr->escam.rev_sch_cc[i].sch_chn_cfg.max_rate =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, max_rate));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, max_rate);

            msg_pos = start_sch_rec_pos + 8*sch_rec_len;
          }
        } /* if (int_ptr->escam.rev_sch_cc_incl) */
      } /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B) */
#endif /* FEATURE_IS2000_REL_B */

    }
  }
  /* There is an error if we parsed beyond the length */
  if (msg_pos > len)
  {
    status = CAIX_INV_LEN_S;
  }

 #undef MTYPE

 return (status);

} /* xlate_ext_tc_escam */

/*===========================================================================

FUNCTION XLATE_EXT_TC_RAM

DESCRIPTION
  This function translates a Traffic Channel Resource Allocation
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_ram
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ram_type
  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < ( sizeof(cai_ram_type) - FSIZ(MTYPE, action_time)))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->ram.hdr );
    msg_pos = FENDPOS( cai_ram_type, hdr.encryption );

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->ram.hdr.msg_int,
         int_ptr->ram.msg_type,
         int_ptr->ram.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->ram.hdr, int_ptr->ram.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->ram.use_time = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, use_time));
        msg_pos += FSIZ(MTYPE, use_time);

        if (int_ptr->ram.use_time)
        {
          int_ptr->ram.action_time =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
          msg_pos += FSIZ(MTYPE, action_time);
        }

        int_ptr->ram.fpc_pri_chan =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_pri_chan));
        msg_pos += FSIZ(MTYPE, fpc_pri_chan);
      }
    }
  }

  #undef MTYPE

  return (status);
} /* xlate_ext_tc_ram */

/*===========================================================================

FUNCTION XLATE_EXT_TC_ERM

DESCRIPTION
  This function translates a Traffic Channel Extended Release
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_erm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
#ifdef FEATURE_IS2000_REL_C
  int i;
    /* Loop counter */
#endif /* FEATURE_IS2000_REL_C */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_erm_type
  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (FSIZ(MTYPE, msg_type) + FSIZ(MTYPE, hdr) + FSIZ(MTYPE, use_time)
       + FSIZ(MTYPE, ch_ind) + FSIZ(MTYPE, gating_rate_incl)))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->erm.hdr);

    msg_pos = FENDPOS(cai_erm_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->erm.hdr.msg_int,
         int_ptr->erm.msg_type,
         int_ptr->erm.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->erm.hdr, int_ptr->erm.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->erm.use_time =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
        msg_pos += FSIZ(MTYPE, use_time);

        if (int_ptr->erm.use_time)
        {
          int_ptr->erm.action_time =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
          msg_pos += FSIZ(MTYPE,action_time);
        }

        int_ptr->erm.ch_ind =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ch_ind));
        msg_pos += FSIZ(MTYPE, ch_ind);

        int_ptr->erm.gating_rate_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, gating_rate_incl));
        msg_pos += FSIZ(MTYPE, gating_rate_incl);

        if (int_ptr->erm.gating_rate_incl)
        {
          int_ptr->erm.pilot_gating_rate =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pilot_gating_rate));
          msg_pos += FSIZ(MTYPE, pilot_gating_rate);
        }

#ifdef FEATURE_IS2000_REL_C
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
        {
          int_ptr->erm.use_ext_ch_ind =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_ext_ch_ind));
          msg_pos += FSIZ(MTYPE, use_ext_ch_ind);

          if (int_ptr->erm.use_ext_ch_ind)
          {
            int_ptr->erm.ext_ch_ind =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ext_ch_ind));
            msg_pos += FSIZ(MTYPE, ext_ch_ind);

            int_ptr->erm.pdch_control_hold =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pdch_control_hold));
            msg_pos += FSIZ(MTYPE, pdch_control_hold);

            if (int_ptr->erm.gating_rate_incl)
            {
              int_ptr->erm.switching_parms_incl =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, switching_parms_incl));
              msg_pos += FSIZ(MTYPE, switching_parms_incl);

              if (int_ptr->erm.switching_parms_incl)
              {
                int_ptr->erm.num_soft_switching_frames_chm =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_soft_switching_frames_chm));
                msg_pos += FSIZ(MTYPE, num_soft_switching_frames_chm);

                int_ptr->erm.num_softer_switching_frames_chm =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_softer_switching_frames_chm));
                msg_pos += FSIZ(MTYPE, num_softer_switching_frames_chm);
              }
            }
          }   /* if (int_ptr->erm.use_ext_ch_ind) */

          int_ptr->erm.direct_to_idle_info_incl =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, direct_to_idle_info_incl));
          msg_pos += FSIZ(MTYPE, direct_to_idle_info_incl);

          if (int_ptr->erm.direct_to_idle_info_incl)
          {
            int_ptr->erm.release_type =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, release_type));
            msg_pos += FSIZ(MTYPE, release_type);

            if (int_ptr->erm.release_type != CAI_RELEASE_TO_SYS_DETERMINATION)
            {
              int_ptr->erm.sid = b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, sid));
              msg_pos += FSIZ(MTYPE, sid);

              int_ptr->erm.nid = b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, nid));
              msg_pos += FSIZ(MTYPE, nid);

              int_ptr->erm.freq_incl =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, freq_incl));
              msg_pos += FSIZ(MTYPE, freq_incl);

              if (int_ptr->erm.freq_incl)
              {
                int_ptr->erm.cdma_freq =
                  b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, cdma_freq));
                msg_pos += FSIZ(MTYPE, cdma_freq);

                int_ptr->erm.band_class =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, band_class));
                msg_pos += FSIZ(MTYPE, band_class);
              }
            }  /* if (int_ptr->erm.release_type != CAI_RELEASE_TO_SYS_DETERMINATION) */

            if (int_ptr->erm.release_type == CAI_RELEASE_TO_IDLE_ON_PCH)
            {
              int_ptr->erm.page_ch =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, page_ch));
              msg_pos += FSIZ(MTYPE, page_ch);

              int_ptr->erm.prat =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, prat));
              msg_pos += FSIZ(MTYPE, prat);
            }

            if (int_ptr->erm.release_type == CAI_RELEASE_TO_IDLE_ON_BCCH)
            {
              int_ptr->erm.sr1_bcch_code_chan_non_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_bcch_code_chan_non_td));
              msg_pos += FSIZ(MTYPE, sr1_bcch_code_chan_non_td);

              int_ptr->erm.sr1_crat_non_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_crat_non_td));
              msg_pos += FSIZ(MTYPE, sr1_crat_non_td);

              int_ptr->erm.sr1_brat_non_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_brat_non_td));
              msg_pos += FSIZ(MTYPE, sr1_brat_non_td);
            }

            if (int_ptr->erm.release_type == CAI_RELEASE_TO_IDLE_ON_BCCH_TD)
            {
              int_ptr->erm.sr1_td_mode =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_td_mode));
              msg_pos += FSIZ(MTYPE, sr1_td_mode);

              int_ptr->erm.sr1_bcch_code_chan_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_bcch_code_chan_td));
              msg_pos += FSIZ(MTYPE, sr1_bcch_code_chan_td);

              int_ptr->erm.sr1_crat_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_crat_td));
              msg_pos += FSIZ(MTYPE, sr1_crat_td);

              int_ptr->erm.sr1_brat_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_brat_td));
              msg_pos += FSIZ(MTYPE, sr1_brat_td);

              int_ptr->erm.sr1_td_power_level =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_td_power_level));
              msg_pos += FSIZ(MTYPE, sr1_td_power_level);
            }

            if (int_ptr->erm.release_type != CAI_RELEASE_TO_SYS_DETERMINATION)
            {
              int_ptr->erm.num_pilots_d2i_incl =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_pilots_d2i_incl));
              msg_pos += FSIZ(MTYPE, num_pilots_d2i_incl);

              if (int_ptr->erm.num_pilots_d2i_incl)
              {
                int_ptr->erm.num_pilots_d2i =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_pilots_d2i));
                msg_pos += FSIZ(MTYPE, num_pilots_d2i);

                for (i=0; (i < int_ptr->erm.num_pilots_d2i) &&
                     (i < CAI_MAX_NUM_D2I_PILOTS); i++)
                {
                  int_ptr->erm.pilot_pn[i] =
                    b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, pilot_pn));
                  msg_pos += FSIZ(MTYPE, pilot_pn);
                }
              }
            }
          }  /* if (int_ptr->erm.direct_to_idle_info_incl) */
        } /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) */
#endif /* FEATURE_IS2000_REL_C */

        /* There is an error if we parsed beyond the length */
        if (msg_pos > len)
        {
          status = CAIX_INV_LEN_S;
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_erm */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_EXT_TC_MABOM

DESCRIPTION
  This function translates a Traffic Channel Mobile Assisted Burst
  Operation Parameters Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_mabom
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_mabop_type

  xlate_ext_tc_hdr(buf_ptr, &int_ptr->tcmabop.hdr);

  msg_pos = FENDPOS(cai_mabop_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
       CAIX_MACI_REQUIRED,
       &msg_pos, buf_ptr, &int_ptr->tcmabop.hdr.msg_int,
       int_ptr->tcmabop.msg_type,
       int_ptr->tcmabop.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
  {
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
        &int_ptr->tcmabop.hdr, int_ptr->tcmabop.msg_type, 0, 0)) == CAIX_DONE_S)
    {
      int_ptr->tcmabop.order_flag = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, order_flag));
      msg_pos += FSIZ(MTYPE, order_flag);

      if (int_ptr->tcmabop.order_flag)
      {
        int_ptr->tcmabop.psmin_delta =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, psmin_delta));
        msg_pos += FSIZ(MTYPE, psmin_delta);

        int_ptr->tcmabop.order_interval =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, order_interval));
        msg_pos += FSIZ(MTYPE, order_interval);
      }

      int_ptr->tcmabop.periodic_flag =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, periodic_flag));
      msg_pos += FSIZ(MTYPE, periodic_flag);

      if (int_ptr->tcmabop.periodic_flag)
      {
        int_ptr->tcmabop.num_pilots =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_pilots));
        msg_pos += FSIZ(MTYPE, num_pilots);

        int_ptr->tcmabop.periodic_interval =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, periodic_interval));
        msg_pos += FSIZ(MTYPE, periodic_interval);
      }

      int_ptr->tcmabop.threshold_flag =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threshold_flag));
      msg_pos += FSIZ(MTYPE, threshold_flag);

      if (int_ptr->tcmabop.threshold_flag)
      {
        int_ptr->tcmabop.ps_floor_high =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ps_floor_high));
        msg_pos += FSIZ(MTYPE, ps_floor_high);

        int_ptr->tcmabop.ps_floor_low =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ps_floor_low));
        msg_pos += FSIZ(MTYPE, ps_floor_low);

        int_ptr->tcmabop.ps_ceiling_high =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ps_ceiling_high));
        msg_pos += FSIZ(MTYPE, ps_ceiling_high);

        int_ptr->tcmabop.ps_ceiling_low =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ps_ceiling_low));
        msg_pos += FSIZ(MTYPE, ps_ceiling_low);

        int_ptr->tcmabop.threshold_interval =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threshold_interval));
        msg_pos += FSIZ(MTYPE, threshold_interval);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_mabom */

/*===========================================================================

FUNCTION XLATE_EXT_TC_UZRM
DESCRIPTION
  This function translates a Traffic Channel User Zone Reject
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_uzrm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_user_zone_rej_type

  xlate_ext_tc_hdr(buf_ptr, &int_ptr->tcuzrm.hdr);

  msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
       CAIX_MACI_REQUIRED,
       &msg_pos, buf_ptr, &int_ptr->tcuzrm.hdr.msg_int,
       int_ptr->tcuzrm.msg_type,
       int_ptr->tcuzrm.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
  {
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
        &int_ptr->tcuzrm.hdr, int_ptr->tcuzrm.msg_type, 0, 0)) == CAIX_DONE_S)
    {
      int_ptr->tcuzrm.reject_uzid =
        b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, reject_uzid));
      msg_pos += FSIZ(MTYPE, reject_uzid);

      int_ptr->tcuzrm.reject_action_indi =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, reject_action_indi));
      msg_pos += FSIZ(MTYPE, reject_action_indi);

      int_ptr->tcuzrm.user_assign_included =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, user_assign_included));
      msg_pos += FSIZ(MTYPE, user_assign_included);

      if (int_ptr->tcuzrm.user_assign_included)
      {
        int_ptr->tcuzrm.assign_id =
          b_unpackw( buf_ptr, msg_pos, FSIZ(MTYPE, assign_id));
        msg_pos += FSIZ(MTYPE, assign_id);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_uzrm */

/*===========================================================================

FUNCTION XLATE_EXT_TC_UZUM
DESCRIPTION
  This function translates a Traffic Channel User Zone Update
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_uzum
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_user_zone_upd_type

  xlate_ext_tc_hdr(buf_ptr, &int_ptr->tcuzum.hdr);

  msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
       CAIX_MACI_REQUIRED,
       &msg_pos, buf_ptr, &int_ptr->tcuzum.hdr.msg_int,
       int_ptr->tcuzum.msg_type,
       int_ptr->tcuzum.hdr.ack_req
       )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
  {
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
        &int_ptr->tcuzum.hdr, int_ptr->tcuzum.msg_type, 0, 0)) == CAIX_DONE_S)
    {
      int_ptr->tcuzum.uz_id =
        b_unpackw(buf_ptr, msg_pos, FSIZ( MTYPE, uz_id));
      msg_pos += FSIZ(MTYPE,uz_id);
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_uzum */

/*===========================================================================

FUNCTION xlate_ext_tc_clam
DESCRIPTION
  This function translates a Traffic Channel Call Assignement
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_clam
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_call_assignment_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (FSIZ(MTYPE, msg_type) + FSIZ(MTYPE, hdr) + FSIZ(MTYPE, response_ind)
       + FSIZ(MTYPE, bypass_alert_answer) + FSIZ(MTYPE, so_incl) +
       FSIZ(MTYPE, con_ref_incl)))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tccam.hdr);
    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tccam.hdr.msg_int,
         int_ptr->tccam.msg_type,
         int_ptr->tccam.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->tccam.hdr, int_ptr->tccam.msg_type, 0, 0)) == CAIX_DONE_S)
      {
        int_ptr->tccam.response_ind =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, response_ind));
        msg_pos += FSIZ(MTYPE, response_ind);

        if (int_ptr->tccam.response_ind)
        {
          int_ptr->tccam.tag =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, tag));
          msg_pos += FSIZ(MTYPE, tag);

          int_ptr->tccam.accept_ind =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, accept_ind));
          msg_pos += FSIZ(MTYPE, accept_ind);

          if (!int_ptr->tccam.accept_ind)
          {
            int_ptr->tccam.reject_pktdata_ind =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, reject_pktdata_ind));
            msg_pos += FSIZ(MTYPE, reject_pktdata_ind);
          }
        }
        else /* response_ind */
          /* bypass_alert_answer is included if CLAM is a response,
             hence response_ind is 1 */
        {
          int_ptr->tccam.bypass_alert_answer =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, bypass_alert_answer));
          msg_pos += FSIZ(MTYPE, bypass_alert_answer);
        }

        int_ptr->tccam.so_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, so_incl));
        msg_pos += FSIZ(MTYPE, so_incl);

        if (int_ptr->tccam.so_incl)
        {
          int_ptr->tccam.so =
            b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, so));
          msg_pos += FSIZ(MTYPE, so);
        }

        int_ptr->tccam.con_ref_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref_incl));
        msg_pos += FSIZ(MTYPE, con_ref_incl);

        if (int_ptr->tccam.con_ref_incl)
        {
          int_ptr->tccam.con_ref =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref));
          msg_pos += FSIZ(MTYPE, con_ref);
        }

#ifdef FEATURE_IS2000_REL_C
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
        {
          /* This field is included if either accept_ind is not included, or
             if it is included and set to 1.  Accept_ind is not included
             if response_ind is 0. */
          if (!int_ptr->tccam.response_ind || (int_ptr->tccam.response_ind && int_ptr->tccam.accept_ind))
          {
            int_ptr->tccam.use_old_serv_config =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_old_serv_config));
            msg_pos += FSIZ(MTYPE, use_old_serv_config);

            if (int_ptr->tccam.use_old_serv_config)
            {
              int_ptr->tccam.sr_id =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr_id));
              msg_pos += FSIZ(MTYPE, sr_id);
            }
          }
        }
#endif /* FEATURE_IS2000_REL_C */

  /* There is an error if we parsed beyond the length */
        if (msg_pos > len)
        {
          status = CAIX_INV_LEN_S;
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_clam */

/*===========================================================================

FUNCTION XLATE_EXT_TC_EAWIM  (also used for Extended Flash)
DESCRIPTION
  This function translates a Traffic Channel Extended Alert with Info
  Message and Extended Flash with Info from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_eawim
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  byte *msg_ptr;
   /* Pointer to position inside internal message type */
  byte rec_type;
   /* Temporary storage for record type */
  word rec_len;
   /* Temporary storage for record length */
  word i, j;
  /* counter */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_extended_alert_w_info_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_extended_alert_w_info_type) -
            FSIZ(MTYPE, con_ref))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tceawim.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tceawim.hdr.msg_int,
         int_ptr->tceawim.msg_type,
         int_ptr->tceawim.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->tceawim.hdr, int_ptr->tceawim.msg_type, 0, 0)) == CAIX_DONE_S)
      {
        int_ptr->tceawim.con_ref_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref_incl));
        msg_pos += FSIZ(MTYPE, con_ref_incl);

        if (int_ptr->tceawim.con_ref_incl)
        {
          int_ptr->tceawim.con_ref =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref));
          msg_pos += FSIZ(MTYPE, con_ref);
        }

        int_ptr->tceawim.num_recs =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_recs));
        msg_pos += FSIZ(MTYPE, num_recs);

        /* point to the start */
        msg_ptr = (byte*)&int_ptr->tceawim.recs[0];

        /* unpack records */
        for ( i=0; i < int_ptr->tceawim.num_recs; i++)
        {
          /* ------------------------------
          ** Unpack message type and length
          ** ------------------------------ */
          ((caii_rec_hdr_type *) msg_ptr)->record_type = rec_type =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rec_hdr_type, record_type));
          msg_pos += FSIZ(cai_rec_hdr_type, record_type);

          /* -------------------------
          ** Get record length in bits
          ** ------------------------- */
          rec_len = b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_rec_hdr_type, record_len)) * 8;
          msg_pos += FSIZ(cai_rec_hdr_type, record_len);

          if ((rec_len + msg_pos) > len)
          {
            status = CAIX_INV_LEN_S;
            break;
          }
          else
          {
            switch (rec_type)
            {
              case CAI_DISPLAY_REC:
                /* --------------------------
                ** Display Information Record
                ** -------------------------- */
                ((caii_display_rec_type *) msg_ptr)->fix.num_char =
                  (byte) (rec_len / sizeof(cai_display_rec_var_type));

                for (j=0;
                     j < ((caii_display_rec_type *) msg_ptr)->fix.num_char; j++)
                {
                  ((caii_display_rec_type *) msg_ptr)->var[j] =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_display_rec_var_type, chari));
                  msg_pos += FSIZ(cai_display_rec_var_type, chari);
                }

                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_display_rec_type,
                           var[((caii_display_rec_type *) msg_ptr)->fix.num_char - 1]);
                break;

              case CAI_CALLED_REC:
                /* --------------------------------------
                ** Called Party Number Information Record
                ** -------------------------------------- */
                ((caii_called_rec_type *) msg_ptr)->fix.number_type =
                   b_unpackb(buf_ptr, msg_pos,
                   FSIZ(cai_called_fix_type, number_type));
                msg_pos += FSIZ(cai_called_fix_type, number_type);

                ((caii_called_rec_type *) msg_ptr)->fix.number_plan =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_called_fix_type, number_plan));
                msg_pos += FSIZ(cai_called_fix_type, number_plan);

                ((caii_called_rec_type *) msg_ptr)->fix.num_char =
                  (byte)((rec_len - sizeof( cai_called_fix_type )) /
                         sizeof( cai_called_var_type));

                for (j=0;
                     j < ((caii_called_rec_type *) msg_ptr)->fix.num_char; j++)
                {
                  ((caii_called_rec_type *) msg_ptr)->var[j] =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_called_var_type, chari));
                  msg_pos += FSIZ(cai_called_var_type, chari);
                }

                /* ----------------------------------------------------------
                ** Increment internal message pointer to point to next record
                ** ---------------------------------------------------------- */
                msg_ptr += FENDPOS(caii_called_rec_type,
                  var[((caii_called_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += 1;  /* Increment past reserved bit at end */
                break;

              case CAI_CALLING_REC:
              case CAI_CONNECT_REC:
                /* -----------------------------------------------------------
                ** Calling Party Number or Connected Number Information Record
                ** ----------------------------------------------------------- */
                ((caii_calling_rec_type *) msg_ptr)->fix.number_type =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_calling_fix_type, number_type));
                msg_pos += FSIZ(cai_calling_fix_type, number_type);

                ((caii_calling_rec_type *) msg_ptr)->fix.number_plan =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_calling_fix_type, number_plan));
                msg_pos += FSIZ(cai_calling_fix_type, number_plan);

                ((caii_calling_rec_type *) msg_ptr)->fix.pi =
                   b_unpackb(buf_ptr, msg_pos,
                   FSIZ(cai_calling_fix_type, pi));
                msg_pos += FSIZ(cai_calling_fix_type, pi);

                ((caii_calling_rec_type *) msg_ptr)->fix.si =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_calling_fix_type, si));
                msg_pos += FSIZ(cai_calling_fix_type, si);

                ((caii_calling_rec_type *) msg_ptr)->fix.num_char =
                  (byte) ((rec_len - sizeof(cai_calling_fix_type)) /
                          sizeof(cai_calling_var_type));

                for (j=0;
                     j < ((caii_calling_rec_type *) msg_ptr)->fix.num_char; j++)
                {
                  ((caii_calling_rec_type *) msg_ptr)->var[j] =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_calling_var_type, chari));
                  msg_pos += FSIZ(cai_calling_var_type, chari);
                }

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += FENDPOS(caii_calling_rec_type,
                  var[((caii_calling_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += 5;  /* Increment past reserved bits at end */
                break;

              case CAI_SIGNAL_REC:
                /* -------------------------
                ** Signal Information Record
                ** ------------------------- */
                ((caii_signal_rec_type *) msg_ptr)->signal_type =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_signal_rec_type, signal_type));
                msg_pos += FSIZ( cai_signal_rec_type, signal_type);

                ((caii_signal_rec_type *) msg_ptr)->alert_pitch =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_signal_rec_type, alert_pitch));
                msg_pos += FSIZ( cai_signal_rec_type, alert_pitch);

                ((caii_signal_rec_type *) msg_ptr)->signal =
                  b_unpackb(buf_ptr, msg_pos,
                          FSIZ(cai_signal_rec_type, signal));
                msg_pos += FSIZ(cai_signal_rec_type, signal) +
                           FSIZ(cai_signal_rec_type, reserved);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_signal_rec_type);
                break;

              case CAI_MSG_WAITING_REC:
                /* ----------------------------------
                ** Message Waiting Information Record
                ** ---------------------------------- */
                ((caii_msg_waiting_rec_type *) msg_ptr)->msg_count =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_msg_waiting_rec_type, msg_count));
                msg_pos += FSIZ(cai_msg_waiting_rec_type, msg_count);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_msg_waiting_rec_type);
                break;

              case CAI_CALLED_SUB_REC:
              case CAI_CALLING_SUB_REC:
              case CAI_REDIR_SUB_REC:
              case CAI_CONNECT_SUB_REC:
                /* --------------------------------------------------------
                ** Calling Party Subaddress or Called Party Subaddress
                ** or Redirecting Subaddress or Connected Subaddress info
                ** record
                ** -------------------------------------------------------- */
                /* Unpack Information Record */
                status = xlate_ext_sub_rec(rec_len, buf_ptr, msg_ptr, &msg_pos);

                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_subaddr_rec_type,
                  var[((caii_subaddr_rec_type *) msg_ptr)->fix.num_char - 1]);
                break;

              case CAI_REDIR_NUM_REC:
                /* --------------------------------------------------------
                ** Redirecting Number Information Record
                ** -------------------------------------------------------- */
                /* Unpack Information Record */

                status = xlate_ext_redir_num_rec(rec_len, buf_ptr,
                         msg_ptr, &msg_pos);
                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_redir_rec_type,
                  var[((caii_redir_rec_type *) msg_ptr)->fix.num_char - 1]);
                break;

              case CAI_EXT_DISPLAY_REC:
                /* ------------------------------
                ** Extended Display Info Record
                ** ------------------------------ */
                status = xlate_ext_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
                  &msg_pos);
                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */
                break;

              case CAI_METER_PULSES_REC:
                /* --------------------------------
                ** Meter Pulses Information Record
                ** -------------------------------- */
                ((caii_meter_pulses_rec_type *) msg_ptr)->pulse_freq =
                  b_unpackw(buf_ptr, msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, pulse_freq));
                msg_pos += FSIZ(cai_meter_pulses_rec_type, pulse_freq);

                ((caii_meter_pulses_rec_type *) msg_ptr)->on_time =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, on_time));
                msg_pos += FSIZ(cai_meter_pulses_rec_type, on_time);

                ((caii_meter_pulses_rec_type *) msg_ptr)->off_time =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, off_time));
                msg_pos += FSIZ(cai_meter_pulses_rec_type, off_time);

                ((caii_meter_pulses_rec_type *) msg_ptr)->pulse_cnt =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, pulse_cnt));
                msg_pos += FSIZ(cai_meter_pulses_rec_type, pulse_cnt);

                msg_pos += FSIZ(cai_meter_pulses_rec_type, reserved);     /* Increment past reserved bit at end */

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_meter_pulses_rec_type); /*lint !e662 */
                break;

              case CAI_PARA_ALERT_REC:
                /* --------------------------------------
                ** Parametric Alerting Information Record
                ** -------------------------------------- */
                status = xlate_ext_para_alert_rec(rec_len, buf_ptr,
                         msg_ptr, &msg_pos);
                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                if (((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups == 0)
                {
                  msg_ptr += FENDPOS(caii_para_alert_rec_type,fix);
                }
                else
                {
                  msg_ptr += FENDPOS(caii_para_alert_rec_type,
                    var[((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups - 1]);
                }
                break;

              case CAI_LINE_CTRL_REC:
                /* -------------------------------------
                ** Line Control Information Record
                ** ------------------------------------- */
                ((caii_line_ctrl_rec_type *) msg_ptr)->pol_inc =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_line_ctrl_rec_type, pol_inc));
                msg_pos += FSIZ(cai_line_ctrl_rec_type, pol_inc);

                if (((caii_line_ctrl_rec_type *) msg_ptr)->pol_inc)
                {
                  ((caii_line_ctrl_rec_type *) msg_ptr)->tgl_mod =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, tgl_mod));
                  msg_pos += FSIZ(cai_line_ctrl_rec_type, tgl_mod);

                  ((caii_line_ctrl_rec_type *) msg_ptr)->rev_pol =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, rev_pol));
                  msg_pos += FSIZ(cai_line_ctrl_rec_type, rev_pol);

                  ((caii_line_ctrl_rec_type *) msg_ptr)->pow_dtm =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, pow_dtm));
                  msg_pos += FSIZ(cai_line_ctrl_rec_type, pow_dtm);

                  msg_pos += 5;     /* Increment past reserved bit at end */
                }
                else
                {
                  ((caii_line_ctrl_rec_type *) msg_ptr)->pow_dtm =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, pow_dtm));
                  msg_pos += FSIZ(cai_line_ctrl_rec_type, pow_dtm);

                  msg_pos += 7;     /* Increment past reserved bit at end */
                }

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_line_ctrl_rec_type); /*lint !e662 */
                break;

              case CAI_USER_ZONE_UPDATE_REC:
                ((caii_user_zone_update_type *) msg_ptr)->uzid =
                  b_unpackw(buf_ptr, msg_pos,
                  FSIZ(cai_user_zone_update_type, uzid));
                msg_pos += FSIZ(cai_user_zone_update_type, uzid);
                msg_ptr += FENDPOS(caii_user_zone_update_type,uzid);
                break;

              case CAI_USER_ZONE_REJECT_REC:
                ((caii_user_zone_reject_type *) msg_ptr)->reject_uzid =
                  b_unpackw(buf_ptr, msg_pos,
                  FSIZ(cai_user_zone_reject_type, reject_uzid));
                msg_pos += FSIZ( cai_user_zone_reject_type, reject_uzid);

                ((caii_user_zone_reject_type *) msg_ptr)->reject_action_indi =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_user_zone_reject_type, reject_action_indi));
                msg_pos += FSIZ(cai_user_zone_reject_type, reject_action_indi);

                ((caii_user_zone_reject_type *) msg_ptr)->uzid_assign_incl =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_user_zone_reject_type, uzid_assign_incl));
                msg_pos += FSIZ(cai_user_zone_reject_type, uzid_assign_incl);

                if (((caii_user_zone_reject_type *) msg_ptr)->uzid_assign_incl)
                {
                  ((caii_user_zone_reject_type *) msg_ptr)->assign_uzid =
                    b_unpackw(buf_ptr, msg_pos,
                    FSIZ(cai_user_zone_reject_type, assign_uzid));
                  msg_pos += FSIZ(cai_user_zone_reject_type, assign_uzid);

                  msg_ptr += FENDPOS(caii_user_zone_reject_type,assign_uzid);
                }
                else
                {
                  msg_ptr += FENDPOS(caii_user_zone_reject_type,uzid_assign_incl );
                }
                msg_pos += 4; /* reserved */
                break;

#ifdef FEATURE_IS2000_REL_A
              case CAI_MC_EXT_DISP_REC:
                /* ---------------------------------------------
                ** Multi-character Extended Display Info Record
                ** --------------------------------------------- */
                status = xlate_ext_mc_ext_disp_rec(rec_len, buf_ptr,
                         &msg_ptr, &msg_pos);
                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */
                break;

              case CAI_CALL_WAIT_IND_REC:
                /* ----------------------------------
                ** Call Waiting Indicator Record
                ** ---------------------------------- */
                ((caii_call_waiting_ind_type *) msg_ptr)->call_waiting_ind =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_call_wait_type, call_waiting_ind));
                msg_pos += (FSIZ( cai_call_wait_type, call_waiting_ind) +
                            FSIZ(cai_call_wait_type, reserved));

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof( caii_call_waiting_ind_type );
                break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
              case CAI_ENH_MC_EXT_DISP_REC:
                /* ---------------------------------------------
                ** Enhanced Multi-character Extended Display Info Record
                ** --------------------------------------------- */
                status = xlate_ext_enh_mc_ext_disp_rec(rec_len, buf_ptr,
                         &msg_ptr, &msg_pos);
                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */
                break;
#endif /* FEATURE_IS2000_REL_C */

              case CAI_NTL_SUP_SVC_REC:
              /* If JCDMA is not defined in the passport mode then treat
               * as if this code is not present. So slip into default case */
              if (mcc_passport_mode_is_jcdma())
              {
                /* ------------------------------------------
                ** Record for National Supplementary Services
                ** ------------------------------------------ */

                /* Determine the country-specific record type */

                ((caii_ntl_sup_svc_type *) msg_ptr)->mcc =
                   b_unpackw( buf_ptr, msg_pos,
                   FSIZ(cai_ntl_sup_svc_type, mcc));

                ((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype =
                  b_unpackb(buf_ptr, msg_pos + FSIZ(cai_ntl_sup_svc_type, mcc),
                  FSIZ(cai_ntl_sup_svc_type, record_subtype));

                if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc == CAI_T53_COUNTRY_CODE) &&
                    (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype == CAI_CLIR_REC))
                {
                  /* -----------------------
                  ** CLIR Information Record
                  ** ----------------------- */
                  msg_pos += FSIZ(cai_ntl_sup_svc_type, mcc) +
                    FSIZ(cai_ntl_sup_svc_type, record_subtype);

                  ((caii_clir_sup_svc_type *) msg_ptr)->cause =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_clir_sup_svc_type, cause));
                  msg_pos += FSIZ( cai_clir_sup_svc_type, cause);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_clir_sup_svc_type);

                }
                else if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc ==
                          CAI_T53_COUNTRY_CODE) &&
                        (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype ==
                          CAI_RELEASE_REC))
                {
                  /* --------------------------
                  ** Release Information Record
                  ** -------------------------- */
                  msg_pos += FSIZ(cai_release_sup_svc_type, mcc) +
                    FSIZ(cai_release_sup_svc_type, record_subtype);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_release_sup_svc_type);

                }
                else if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc ==
                          CAI_T53_COUNTRY_CODE) &&
                        (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype ==
                          CAI_AUDIO_CONTROL_REC))
                {
                  /* --------------------------------
                  ** Audio Control Information Record
                  ** -------------------------------- */
                  msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, mcc) +
                    FSIZ(cai_audio_ctl_sup_svc_type, record_subtype);

                  ((caii_audio_ctl_sup_svc_type *) msg_ptr)->up_link =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_audio_ctl_sup_svc_type, up_link));
                  msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, up_link);

                  ((caii_audio_ctl_sup_svc_type *) msg_ptr)->down_link =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_audio_ctl_sup_svc_type, down_link));
                  msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, down_link) +
                    FSIZ(cai_audio_ctl_sup_svc_type, reserved);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_audio_ctl_sup_svc_type);

                }
                else
                {
                  /* ------------------------------------
                  ** Unknown country-specific record type
                  ** ------------------------------------ */
                  msg_ptr += sizeof( caii_ntl_sup_svc_type );
                  msg_pos += rec_len;
                }
                break;
              }
              /* This is an intentional fall through. If feature is not defined
                 or if the mode is not JCDMA the code will fall through into
                 default */
              /*lint -fallthrough */
              default:
                /* -------------------
                ** Unknown record type
                ** ------------------- */
                msg_ptr += sizeof(caii_rec_hdr_type);
                msg_pos += rec_len;
            } /* end switch (rec_type) */

            msg_ptr = (byte*)ALIGN_DWORD(((dword) msg_ptr));

          }
        }
      }
    }
  } /* if length is ok */

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_eawim */

/*===========================================================================

FUNCTION XLATE_EXT_TC_SMCM
DESCRIPTION
  This function translates a Traffic Channel Security Mode Command
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_smcm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  word i;
    /* counter */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_security_mode_cmd_fix_type
  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (sizeof(cai_security_mode_cmd_fix_type ) +
             FSIZ(cai_security_mode_cmd_var2_type, c_sig_encrypt_mode_incl) -
       FSIZ(cai_security_mode_cmd_fix_type, action_time))
     )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tcsmcm.hdr);
    msg_pos = FENDPOS(cai_security_mode_cmd_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tcsmcm.hdr.msg_int,
         int_ptr->tcsmcm.msg_type,
         int_ptr->tcsmcm.hdr.ack_req
         )) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_C */

    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
               &int_ptr->tcsmcm.hdr, int_ptr->tcsmcm.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }

    int_ptr->tcsmcm.use_time =
      b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
    msg_pos += FSIZ(MTYPE, use_time);

    if (int_ptr->tcsmcm.use_time)
    {
      int_ptr->tcsmcm.action_time =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
      msg_pos += FSIZ(MTYPE, action_time);
    }

    int_ptr->tcsmcm.d_sig_encrypt_mode =
      b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, d_sig_encrypt_mode));
    msg_pos += FSIZ(MTYPE, d_sig_encrypt_mode);

    int_ptr->tcsmcm.num_recs =
      b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_recs));
    msg_pos += FSIZ(MTYPE, num_recs);

#undef MTYPE

#define MTYPE cai_security_mode_cmd_var_type

    for ( i=0; (i < int_ptr->tcsmcm.num_recs) && (i < MAX_SEC_REC); i++)
    {
      int_ptr->tcsmcm.recs[i].con_ref =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref));
      msg_pos += FSIZ(MTYPE, con_ref);

      int_ptr->tcsmcm.recs[i].ui_encrypt_mode =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ui_encrypt_mode));
      msg_pos += FSIZ(MTYPE, ui_encrypt_mode);
    }

#undef MTYPE

#define MTYPE cai_security_mode_cmd_var2_type

    if ((int_ptr->tcsmcm.d_sig_encrypt_mode == CAI_ENC_MODE_ECMEA) ||
        (int_ptr->tcsmcm.d_sig_encrypt_mode == CAI_ENC_MODE_REA))
    {
      int_ptr->tcsmcm.key_size =
        b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, key_size));
      msg_pos += FSIZ(MTYPE,key_size);
    }

    int_ptr->tcsmcm.c_sig_encrypt_mode_incl =
      b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, c_sig_encrypt_mode_incl));
    msg_pos += FSIZ(MTYPE, c_sig_encrypt_mode_incl);

    if (int_ptr->tcsmcm.c_sig_encrypt_mode_incl)
    {
      int_ptr->tcsmcm.c_sig_encrypt_mode =
        b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, c_sig_encrypt_mode));
      msg_pos += FSIZ(MTYPE, c_sig_encrypt_mode);
    }

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      int_ptr->tcsmcm.msg_int_info_incl =
        b_unpackb( buf_ptr, msg_pos, FSIZ(cai_security_mode_cmd_rel_c_type, msg_int_info_incl));
      msg_pos += FSIZ(cai_security_mode_cmd_rel_c_type, msg_int_info_incl);

      if (int_ptr->tcsmcm.msg_int_info_incl)
      {
        int_ptr->tcsmcm.change_keys =
          b_unpackb( buf_ptr, msg_pos, FSIZ(cai_security_mode_cmd_rel_c_type, change_keys));
        msg_pos += FSIZ(cai_security_mode_cmd_rel_c_type, change_keys);

        int_ptr->tcsmcm.use_uak =
          b_unpackb( buf_ptr, msg_pos, FSIZ(cai_security_mode_cmd_rel_c_type, use_uak));
        msg_pos += FSIZ(cai_security_mode_cmd_rel_c_type, use_uak);
      }
    }
#endif /* FEATURE_IS2000_REL_C */

    /* Make sure the message contained all the fields advertised by the p-rev */
    if (msg_pos > len)
    {
      status = CAIX_INV_LEN_S;
    }

  } /* else length check failed */

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_smcm */

#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_EXT_TC_BS_STATUS_RSP

DESCRIPTION
  This function translates a Forward Traffic Channel Base Station Status
  Response Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_bs_status_rsp
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i, j;
    /* Index for looping through characters */
  word msg_pos = 0;
  /* Position in message relative to start of buf_ptr */
  word record_pos, record_pos1;
  /* Position of the record */
  word reserved_bits, reserved_1_bits;
  /* Number of reserved bits, and reserved_1 bits. */
  word qual_info_len, record_length, record_len;
  /* Qualification Information Length, and Record Length */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_bs_status_rsp_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < FSIZ(MTYPE, bss_fix))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->bssrsp.hdr );

    msg_pos = FENDPOS(MTYPE, bss_fix.hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->bssrsp.hdr.msg_int,
         int_ptr->bssrsp.msg_type,
         int_ptr->bssrsp.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->bssrsp.hdr, int_ptr->bssrsp.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->bssrsp.qual = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, bss_fix.qual_info_type));
        msg_pos += FSIZ(MTYPE, bss_fix.qual_info_type);

        qual_info_len = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, bss_fix.qual_info_len));
        msg_pos += FSIZ(MTYPE, bss_fix.qual_info_len);

        switch (int_ptr->bssrsp.qual)
        {
          case CAI_NO_QUAL:
            if (qual_info_len != 0 )
            {
              M1X_MSG( DCP, LEGACY_ERROR,
                " BSSRSP: qual_info_len %d != 0",
                qual_info_len);
              status = CAIX_INV_MSG_S;
            }
            break;

          case CAI_BAND_QUAL:
            if (qual_info_len != (sizeof(cai_qual_info1_type)/8) )
            {
              M1X_MSG( DCP, LEGACY_ERROR,
                " BSSRSP: qual_info_len %d != 1",
                qual_info_len);
              status = CAIX_INV_MSG_S;
            }
            else
            {
              int_ptr->bssrsp.band =
                  b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, qi.qi1.band) );
              msg_pos += FSIZ(MTYPE, qi.qi1.band);
              msg_pos += FSIZ(MTYPE, qi.qi1.reserved);
            }
            break;

          case CAI_BAND_OP_MODE_QUAL:
            if (qual_info_len != (sizeof(cai_qual_info2_type)/8) )
            {
              M1X_MSG( DCP, LEGACY_ERROR,
                " BSSRSP: qual_info_len %d != 2",
                qual_info_len);
              status = CAIX_INV_MSG_S;
            }
            else
            {
              int_ptr->bssrsp.band =
                  b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, qi.qi2.band) );
              msg_pos += FSIZ(MTYPE, qi.qi2.band);
              int_ptr->bssrsp.op_mode =
                b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, qi.qi2.op_mode) );
              msg_pos += FSIZ(MTYPE, qi.qi2.op_mode);
              msg_pos += FSIZ(MTYPE, qi.qi2.reserved);
            }
            break;

          default:
            M1X_MSG( DCP, LEGACY_ERROR,
              " BSSRSP: qual_info_type %d not supported",
              int_ptr->bssrsp.qual);
            status = CAIX_INV_MSG_S;
        }

        if (status == CAIX_DONE_S)
        {
          int_ptr->bssrsp.num_record = b_unpackb(buf_ptr, msg_pos,
            FSIZ(MTYPE, bss_fix.num_record));
          msg_pos += FSIZ(MTYPE, bss_fix.num_record);

          for (i = 0; (status == CAIX_DONE_S) &&
                (i < int_ptr->bssrsp.num_record) &&
                (i < CAI_BSS_NUM_RECORDS); i++)
          {
            int_ptr->bssrsp.bss_rec[i].record_type =
              b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, rec_fix.record_type));
            msg_pos += FSIZ(MTYPE, rec_fix.record_type);

            record_length = b_unpackb(buf_ptr, msg_pos,
              FSIZ(MTYPE, rec_fix.record_length));
            msg_pos += FSIZ(MTYPE, rec_fix.record_length);

            record_pos = msg_pos;

            switch (int_ptr->bssrsp.bss_rec[i].record_type)
            {
              case CAI_BSS_PILOT_INFO_RSP:
                int_ptr->bssrsp.bss_rec[i].pi.num_pilots = b_unpackb(buf_ptr,
                  msg_pos, FSIZ(MTYPE, rec0.fix.num_pilots));
                msg_pos += FSIZ(MTYPE, rec0.fix.num_pilots);

                int_ptr->bssrsp.bss_rec[i].pi.sid_nid_ind = b_unpackb(buf_ptr,
                  msg_pos, FSIZ(MTYPE, rec0.fix.sid_nid_ind));
                msg_pos += FSIZ(MTYPE, rec0.fix.sid_nid_ind);

                for (j = 0; (status == CAIX_DONE_S) &&
                     (j < int_ptr->bssrsp.bss_rec[i].pi.num_pilots); j++)
                {
                  /* Save the record position */
                  record_pos1 = msg_pos;

                  record_len = b_unpackb(buf_ptr, msg_pos,
                    FSIZ(MTYPE, rec0.var_fix.record_len));
                  msg_pos += FSIZ(MTYPE, rec0.var_fix.record_len);

                  int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].pilot_pn =
                    b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE,
                    rec0.var_fix.pilot_pn));
                  msg_pos += FSIZ(MTYPE, rec0.var_fix.pilot_pn);

                  int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].base_id =
                    b_unpackw(buf_ptr, msg_pos,
                    FSIZ(MTYPE, rec0.var_fix.base_id));
                  msg_pos += FSIZ(MTYPE, rec0.var_fix.base_id);

                  if (int_ptr->bssrsp.bss_rec[i].pi.sid_nid_ind != 0)
                  {
                    int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].sid_nid_incl =
                      b_unpackb(buf_ptr, msg_pos,
                      FSIZ(MTYPE, rec0.var_var.sid_nid_incl));
                    msg_pos += FSIZ(MTYPE, rec0.var_var.sid_nid_incl);

                    if (int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].sid_nid_incl !=
                        0 )
                    {
                      int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].sid =
                        b_unpackw( buf_ptr, msg_pos,
                        FSIZ(MTYPE, rec0.var_var.sid));
                      msg_pos += FSIZ(MTYPE, rec0.var_var.sid);

                      int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].nid =

                      b_unpackw( buf_ptr, msg_pos,
                      FSIZ(MTYPE, rec0.var_var.nid));
                      msg_pos += FSIZ(MTYPE, rec0.var_var.nid);
                    }
                  } /* end if sid_nid_ind != 0 */

#ifdef FEATURE_IS2000_REL_C
                  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
                  {
                    int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].base_lat_long_incl =
                      b_unpackb(buf_ptr, msg_pos,
                      FSIZ(MTYPE, rec0.var_var.base_lat_long_incl));
                    msg_pos += FSIZ(MTYPE, rec0.var_var.base_lat_long_incl);

                    if (int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].base_lat_long_incl)
                    {
                      int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].base_lat =
                        b_unpackd(buf_ptr, msg_pos,
                        FSIZ(MTYPE, rec0.var_var.base_lat));
                      msg_pos += FSIZ(MTYPE, rec0.var_var.base_lat);

                      int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].base_long =
                        b_unpackd(buf_ptr, msg_pos,
                        FSIZ(MTYPE, rec0.var_var.base_long));
                      msg_pos += FSIZ(MTYPE, rec0.var_var.base_long);
                    }
                  } /* prev_in_use >= 9 */
#endif /* FEATURE_IS2000_REL_C */

                  /* Reserved 1 */
                  reserved_1_bits = 8 - ((msg_pos - record_pos1) % 8);
                  if ( reserved_1_bits != 8 )
                  {
                    msg_pos += reserved_1_bits;
                  }

                  /* Check if the record_len is valid */
                  if ((msg_pos - record_pos1) != (record_len * 8))
                  {
                    M1X_MSG( DCP, LEGACY_ERROR,
                      "record_len %d is invalid",
                      record_len);
                    status = CAIX_INV_MSG_S;
                  }
                } /* end for num_pilots */
                break; /* case 0 */

              default:
                M1X_MSG( DCP, LEGACY_ERROR,
                  " BSSRSP: record_type %d not supported",
                  int_ptr->bssrsp.bss_rec[i].record_type);
                status = CAIX_INV_MSG_S;
                break;
            } /* switch of record_type */

            if (status == CAIX_DONE_S)
            {
              /* Reserved bits */
              reserved_bits = 8 - ((msg_pos - record_pos) % 8);
              if ( reserved_bits != 8 )
              {
                msg_pos += reserved_bits;
              }

              /* Check if the record_length is valid */
              if ((msg_pos - record_pos) != (record_length * 8))
              {
                M1X_MSG( DCP, LEGACY_ERROR,
                  "record_length %d is invalid",
                  record_length);
                status = CAIX_INV_MSG_S;
              }
            }
          } /* end for num_records */
        } /* end if (status == CAIX_DONE_S) */
      }
    }
  } /* end if (len < FSIZ(MTYPE, bss_fix)) */

  #undef MTYPE

  return (status);

} /* xlate_ext_bs_status_rsp */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_EXT_TC_AUTH_REQ
DESCRIPTION
  This function translates a Traffic Channel Authentication Request
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_auth_req
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (sizeof( cai_tc_auth_req_type ) + FSIZ(cai_msg_int_type, maci_incl)))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tcauthreq.hdr);
    msg_pos = FENDPOS(cai_tc_auth_req_type, hdr.encryption);

    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_NOT_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tcauthreq.hdr.msg_int,
         int_ptr->tcauthreq.msg_type,
         int_ptr->tcauthreq.hdr.ack_req
         )) != CAIX_DONE_S)
    {
      return status;
    }

    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
               &int_ptr->tcauthreq.hdr, int_ptr->tcauthreq.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }

#define MTYPE cai_tc_auth_req_type

    b_unpackq(buf_ptr, msg_pos, FSIZ(MTYPE, randa)/2, int_ptr->tcauthreq.randa_hi);
    msg_pos += FSIZ(MTYPE, randa)/2;

    b_unpackq(buf_ptr, msg_pos, FSIZ(MTYPE, randa)/2, int_ptr->tcauthreq.randa_lo);
    msg_pos += FSIZ(MTYPE, randa)/2;

    b_unpackq(buf_ptr, msg_pos, FSIZ(MTYPE, con_sqn), int_ptr->tcauthreq.con_sqn);
    msg_pos += FSIZ(MTYPE, con_sqn);

    int_ptr->tcauthreq.amf = b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, amf));
    msg_pos += FSIZ(MTYPE, amf);

    b_unpackq(buf_ptr, msg_pos, FSIZ(MTYPE, mac_a), int_ptr->tcauthreq.mac_a);
    msg_pos += FSIZ(MTYPE, mac_a);

#undef MTYPE
  }

  return (status);

} /* xlate_ext_tc_auth_req */

/*===========================================================================

FUNCTION XLATE_EXT_TC_RATE_CHANGE
DESCRIPTION
  This function translates a Traffic Channel Rate Change
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_rate_change
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  word i;
    /* counter */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length.
  ** -------------------------------------------- */
  if (len < (sizeof( cai_rate_change_fix_type ) + FSIZ(cai_msg_int_type, maci_incl)))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->rate_change.hdr);
    msg_pos = FENDPOS(cai_rate_change_fix_type, hdr.encryption);

    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->rate_change.hdr.msg_int,
         int_ptr->rate_change.msg_type,
         int_ptr->rate_change.hdr.ack_req
         )) != CAIX_DONE_S)
    {
      return status;
    }
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
               &int_ptr->rate_change.hdr, int_ptr->rate_change.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }

#define MTYPE cai_rate_change_var_type

    int_ptr->rate_change.use_time =
      b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rate_change_fix_type, use_time));
    msg_pos += FSIZ(cai_rate_change_fix_type, use_time);

    int_ptr->rate_change.action_time =
      b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rate_change_fix_type, action_time));
    msg_pos += FSIZ(cai_rate_change_fix_type, action_time);

    int_ptr->rate_change.rev_cqich_rate_change_incl =
      b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rate_change_fix_type, rev_cqich_rate_change_incl));
    msg_pos += FSIZ(cai_rate_change_fix_type, rev_cqich_rate_change_incl);

    if(int_ptr->rate_change.rev_cqich_rate_change_incl)
    {
      int_ptr->rate_change.full_ci_feedback_ind =
  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, full_ci_feedback_ind));
      msg_pos += FSIZ(MTYPE, full_ci_feedback_ind);

      int_ptr->rate_change.rev_cqich_reps =
  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_cqich_reps));
      msg_pos += FSIZ(MTYPE, rev_cqich_reps);

      int_ptr->rate_change.switching_parms_incl =
  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, switching_parms_incl));
      msg_pos += FSIZ(MTYPE, switching_parms_incl);

      if (int_ptr->rate_change.switching_parms_incl)
      {
        int_ptr->rate_change.num_soft_switching_frames =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_soft_switching_frames));
        msg_pos += FSIZ(MTYPE, num_soft_switching_frames);

        int_ptr->rate_change.num_softer_switching_frames =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_softer_switching_frames));
        msg_pos += FSIZ(MTYPE, num_softer_switching_frames);

        int_ptr->rate_change.chm_switching_parms_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, chm_switching_parms_incl));
        msg_pos += FSIZ(MTYPE, chm_switching_parms_incl);

        if (int_ptr->rate_change.chm_switching_parms_incl)
        {
          int_ptr->rate_change.num_soft_switching_frames_chm =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_soft_switching_frames_chm));
          msg_pos += FSIZ(MTYPE, num_soft_switching_frames_chm);

          int_ptr->rate_change.num_softer_switching_frames_chm =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_softer_switching_frames_chm));
          msg_pos += FSIZ(MTYPE, num_softer_switching_frames_chm);
        }
      }  /* if (int_ptr->rate_change.switching_parms_incl) */

      int_ptr->rate_change.rl_cqich_att_adj_gain_incl =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_incl));
      msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_incl);

      if (int_ptr->rate_change.rl_cqich_att_adj_gain_incl)
      {
        int_ptr->rate_change.num_recs =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_recs));
        msg_pos += FSIZ(MTYPE, num_recs);

        for (i=0; (i < int_ptr->rate_change.num_recs + 1) && (i < CAI_MAX_RL_CQICH_RECS); i++)
        {
          int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_type =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_type));
          msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_type);

          int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_high_incl =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_high_incl));
          msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_high_incl);

          if (int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_high_incl)
          {
            int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_high =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_high));
            msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_high);
          }

          int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_low_incl =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_low_incl));
          msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_low_incl);

          if (int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_low_incl)
          {
            int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_low =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_low));
            msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_low);
          }

        }   /* for (i=0; i < int_ptr->rate_change.num_recs + 1; i++) */
      }   /*  if (int_ptr->rate_change.rl_cqich_att_adj_gain_incl) */
    }  /* if(int_ptr->rate_change.rev_cqich_rate_change_incl) */

    int_ptr->rate_change.rev_ackch_rate_change_incl =
      b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rate_change_fix_type, rev_ackch_rate_change_incl));
    msg_pos += FSIZ(cai_rate_change_fix_type, rev_ackch_rate_change_incl);

    if (int_ptr->rate_change.rev_ackch_rate_change_incl)
    {
      int_ptr->rate_change.rev_ackch_reps =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_ackch_reps));
      msg_pos += FSIZ(MTYPE, rev_ackch_reps);
    }

#undef MTYPE

  }
  return (status);

} /* xlate_ext_tc_rate_change */

#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_1X_ADV
/*===========================================================================

FUNCTION XLATE_EXT_RCP

DESCRIPTION
  This function translates the Radio Configuration Parameters Message
  parameteres from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_rcp
(
  word len,
    /* Length of message in bits */
  word *ext_msg_pos,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_radio_config_params_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  int i;
    /* Index for looping through records */

  UNPACKB_PG_DRF(use_time, cai_radio_config_param_fix_type, use_time);
  if (int_ptr->use_time)
  {
    UNPACKB_PG_DRF(action_time, cai_rcp_action_time_type, action_time);
  }

  UNPACKB_PG_DRF(for_fch_ack_mask_rl_blanking_inc, cai_radio_config_param_fix_type, for_fch_ack_mask_rl_blanking_inc);
  if (int_ptr->for_fch_ack_mask_rl_blanking_inc)
  {
    UNPACKW_PG_DRF(for_fch_ack_mask_rl_blanking, cai_rcp_ack_mask_type, ack_mask);
  }

  UNPACKB_PG_DRF(for_fch_ack_mask_no_rl_blanking_inc, cai_radio_config_param_fix_type, for_fch_ack_mask_no_rl_blanking_inc);
  if (int_ptr->for_fch_ack_mask_no_rl_blanking_inc)
  {
    UNPACKW_PG_DRF(for_fch_ack_mask_no_rl_blanking, cai_rcp_ack_mask_type, ack_mask);
  }

  UNPACKB_PG_DRF(rev_fch_ack_mask_inc, cai_radio_config_param_fix_type, rev_fch_ack_mask_inc);
  if (int_ptr->rev_fch_ack_mask_inc)
  {
    UNPACKW_PG_DRF(rev_fch_ack_mask, cai_rcp_ack_mask_type, ack_mask);
  }

  UNPACKB_PG_DRF(for_sch_ack_mask_rl_blanking_inc, cai_radio_config_param_fix_type, for_sch_ack_mask_rl_blanking_inc);
  if (int_ptr->for_sch_ack_mask_rl_blanking_inc)
  {
    UNPACKW_PG_DRF(for_sch_ack_mask_rl_blanking, cai_rcp_ack_mask_type, ack_mask);
  }

  UNPACKB_PG_DRF(for_sch_ack_mask_no_rl_blanking_inc, cai_radio_config_param_fix_type, for_sch_ack_mask_no_rl_blanking_inc);
  if (int_ptr->for_sch_ack_mask_no_rl_blanking_inc)
  {
    UNPACKW_PG_DRF(for_sch_ack_mask_no_rl_blanking, cai_rcp_ack_mask_type, ack_mask);
  }

  UNPACKB_PG_DRF(rev_sch_ack_mask_inc, cai_radio_config_param_fix_type, rev_sch_ack_mask_inc);
  if (int_ptr->rev_sch_ack_mask_inc)
  {
    UNPACKW_PG_DRF(rev_sch_ack_mask, cai_rcp_ack_mask_type, ack_mask);
  }

  UNPACKB_PG_DRF(for_n2m_ind, cai_radio_config_param_fix_type, for_n2m_ind);

  UNPACKB_PG_DRF(fpc_mode, cai_radio_config_param_fix_type, fpc_mode);

  UNPACKB_PG_DRF(power_control_mode, cai_radio_config_param_fix_type, power_control_mode);

  UNPACKB_PG_DRF(pwr_cntl_step, cai_radio_config_param_fix_type, pwr_cntl_step);

  UNPACKB_PG_DRF(for_fch_blanking_dutycycle, cai_radio_config_param_fix_type, for_fch_blanking_dutycycle);

  UNPACKB_PG_DRF(rev_fch_blanking_dutycycle, cai_radio_config_param_fix_type, rev_fch_blanking_dutycycle);

  UNPACKB_PG_DRF(rev_gain_adj_acs1_inc, cai_radio_config_param_fix_type, rev_ackch_gain_adj_acs1_inc);
  if (int_ptr->rev_gain_adj_acs1_inc)
  {
    UNPACKB_PG_DRF(rev_gain_adj_acs1, cai_rcp_ackch_gain_adj_type, rev_ackch_gain_adj);
  }

  UNPACKB_PG_DRF(rev_gain_adj_acs2plus_inc, cai_radio_config_param_fix_type, rev_ackch_gain_adj_acs2plus_inc);
  if (int_ptr->rev_gain_adj_acs2plus_inc)
  {
    UNPACKB_PG_DRF(rev_gain_adj_acs2plus, cai_rcp_ackch_gain_adj_type, rev_ackch_gain_adj);
  }

  UNPACKB_PG_DRF(num_rc_params_rec, cai_radio_config_param_fix_type, num_rc_params_records);

  for ( i = 0 ; (i < int_ptr->num_rc_params_rec) && (i < CAI_RC_PARM_MAX) ; i++ )
  {
    UNPACKW_PG_DRF(rc_params_records[i].pilot_pn, cai_rc_params_record_type, pilot_pn);

    UNPACKB_PG_DRF(rc_params_records[i].rc_pilot_params.qof_set_in_use, cai_rc_params_record_type, qof_set_in_use);

    UNPACKB_PG_DRF(rc_params_records[i].rc_pilot_params.rev_sch0_ack_bit_inc, cai_rc_params_record_type, rev_sch0_ack_bit_inc);
    if (int_ptr->rc_params_records[i].rc_pilot_params.rev_sch0_ack_bit_inc)
    {
      UNPACKB_PG_DRF(rc_params_records[i].rc_pilot_params.rev_sch0_ack_ch_walsh,
                 cai_rcp_sch_ack_params_type, rev_sch_ack_ch_walsh);
      UNPACKB_PG_DRF(rc_params_records[i].rc_pilot_params.rev_sch0_ack_bit,
                 cai_rcp_sch_ack_params_type, rev_sch_ack_bit);
    }

    UNPACKB_PG_DRF(rc_params_records[i].rc_pilot_params.rev_sch1_ack_bit_inc, cai_rc_params_record_type, rev_sch1_ack_bit_inc);
    if (int_ptr->rc_params_records[i].rc_pilot_params.rev_sch1_ack_bit_inc)
    {
      UNPACKB_PG_DRF(rc_params_records[i].rc_pilot_params.rev_sch1_ack_ch_walsh,
                 cai_rcp_sch_ack_params_type, rev_sch_ack_ch_walsh);
      UNPACKB_PG_DRF(rc_params_records[i].rc_pilot_params.rev_sch1_ack_bit,
                 cai_rcp_sch_ack_params_type, rev_sch_ack_bit);
    }

    UNPACKB_PG_DRF(rc_params_records[i].rc_pilot_params.for_fch_ccsh_interleaver_type,
               cai_rc_params_record_type, for_fch_ccsh_interleaver_type);
  } /* end for */

  return status;
} /* xlate_ext_rcp */

/*===========================================================================

FUNCTION XLATE_EXT_TC_RCPM

DESCRIPTION
  This function translates a Traffic Channel Radio Configuration Parameters Message
  from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_rcpm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos=0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_radio_config_param_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {

    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->rcpm.hdr);

    ext_msg_pos = FENDPOS(cai_radio_config_param_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &ext_msg_pos, buf_ptr, &int_ptr->rcpm.hdr.msg_int,
         int_ptr->rcpm.msg_type,
         int_ptr->rcpm.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &ext_msg_pos, buf_ptr,
          &int_ptr->rcpm.hdr, int_ptr->rcpm.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        /* Translate the parameters of the message */
        status = xlate_ext_rcp(len - ext_msg_pos, &ext_msg_pos, buf_ptr, &(int_ptr->rcpm.rcp));
      } /* end if */
    } /* end if */
  } /* end else */

  return (status);
} /* xlate_ext_tc_rcpm */

#ifdef FEATURE_1X_CP_MEM_OPT
caii_rx_msg_type *caii_gem_message_rec_ptr = NULL;
/* The structure to hold the Message Rec field of the GEM, i.e. the message
 * extended by GEM. Since any message can be extended by GEM, so it is not
 * possible to include the message body in the GEM structure. Rather, a
 * pointer is available in GEM structure which will point to the above
 * defined structure. */
#else /* !FEATURE_1X_CP_MEM_OPT */
caii_rx_msg_type caii_gem_message_rec;
/* The structure to hold the Message Rec field of the GEM, i.e. the message
 * extended by GEM. Since any message can be extended by GEM, so it is not
 * possible to include the message body in the GEM structure. Rather, a
 * pointer is available in GEM structure which will point to the above
 * defined structure. */
caii_rx_msg_type *caii_gem_message_rec_ptr = &caii_gem_message_rec;
#endif /* FEATURE_1X_CP_MEM_OPT */

/*===========================================================================

FUNCTION XLATE_EXT_TC_GEN_EXTN

DESCRIPTION
  This function translates a Traffic Channel General Extension Message
  from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_gen_extn
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  int i;
    /* Index for looping through records */
  word layer2_end_pos;
    /* Position of end of layer 2 header */
  word temp_msg_pos;
    /* Temporary message position in buffer */
  word len_msg;  /* Length of the message to be translated */
  word buf_pos;  /* Position in buffer to be packed */
  word n = 0, n_bits = 0;
  uint8 val_8 = 0;
  uint8 *s_addr_l3 = NULL;


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in macro
  ** ----------------------------------- */
  #define FTYPE cai_gen_extn_msg_fix_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (sizeof(FTYPE) + sizeof(cai_gen_tc_type)) )
  {
    status = CAIX_INV_LEN_S;
    return (status);
  }

  /* -----------------------------------------------------------------
  ** Length is OK --> convert message from external to internal format
  ** starting with the first field after message_type
  ** ----------------------------------------------------------------- */
  xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_gem.hdr);

  ext_msg_pos = FENDPOS(cai_gen_tc_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
       CAIX_MACI_REQUIRED,
       &ext_msg_pos, buf_ptr, &int_ptr->tc_gem.hdr.msg_int,
       int_ptr->tc_gem.msg_type,
       int_ptr->tc_gem.hdr.ack_req
       )) != CAIX_DONE_S)
  {
    return (status);
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  if ((status = xlate_ext_ext_enc_tc(&len, &ext_msg_pos, buf_ptr,
        &int_ptr->tc_gem.hdr, int_ptr->tc_gem.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return (status);
  }
#endif /* FEATURE_IS2000_REL_A */

  layer2_end_pos = ext_msg_pos;

  UNPACKB_PG(tc_gem.num_ge_rec, FTYPE, num_ge_rec);

  if(int_ptr->tc_gem.num_ge_rec > CAI_MAX_NUM_GE_REC)
  {
    M1X_MSG( DCP, LEGACY_HIGH,
      "Currently more than %d GEM records not supported",
      CAI_MAX_NUM_GE_REC);
    /* Return from here because even if we continue and parse the first record
     * while ignoring the rest, the parsing after exiting the for loop would be 
     * incorrect.
     */
    status = CAIX_INV_LEN_S;
    return (status);      
  }

  for ( i = 0; i < int_ptr->tc_gem.num_ge_rec && i < CAI_MAX_NUM_GE_REC; i++ )
  {
    UNPACKB_PG(tc_gem.gen_extn_rec[i].ge_rec_type, cai_gen_extn_rec_type, ge_rec_type);
    UNPACKB_PG(tc_gem.gen_extn_rec[i].ge_rec_len, cai_gen_extn_rec_type, ge_rec_len);

    if ( len < (ext_msg_pos +
                 int_ptr->tc_gem.gen_extn_rec[i].ge_rec_len) )
    {
      status = CAIX_INV_LEN_S;
      return (status);
    }

    switch(int_ptr->tc_gem.gen_extn_rec[i].ge_rec_type)
    {
      case CAI_GE_REC_REV_CHN_INFO:
      {
        UNPACKB_PG(tc_gem.gen_extn_rec[i].ge_rec.rev_chn_info.band_class, cai_ge_rec_rev_chn_type, band_class);
        UNPACKW_PG(tc_gem.gen_extn_rec[i].ge_rec.rev_chn_info.rev_chan, cai_ge_rec_rev_chn_type, rev_chan);
        break;
      }
      case CAI_GE_REC_RADIO_CONFIG_PARAMS:
      {
        /* Adding this check to ensure negative len is not passed to 
         * xlate_ext_rcp */
        if (len < ext_msg_pos)
        {
            M1X_MSG ( DCP, LEGACY_MED,
              "GEM : %d bits extra eaten up. Something wrong in parsing!!",
               ext_msg_pos - len);
            status = CAIX_INV_MSG_S;
            return (status);        
        }         
        temp_msg_pos = ext_msg_pos;
        /* Translate the RCP record fields carried in GEM */
        if ((status = xlate_ext_rcp((len - ext_msg_pos),
              &ext_msg_pos, buf_ptr,
              &(int_ptr->tc_gem.gen_extn_rec[i].ge_rec.rcp))) != CAIX_DONE_S)
        {
          M1X_MSG( DCP, LEGACY_ERROR,
            "RCP record parsing failed. Status = %d",
            status);
          return (status);
        }
        ext_msg_pos += ((ext_msg_pos - temp_msg_pos)%8 != 0) ?
                        (8 - (ext_msg_pos - temp_msg_pos)%8) : 0;
        break;
      }
      default:
      {
        M1X_MSG( DCP, LEGACY_ERROR,
          "Unknown general record type %d",
          int_ptr->tc_gem.gen_extn_rec[i].ge_rec_type);
        return (status);
      }
    }
  } /* for */

  UNPACKB_PG(tc_gem.message_type, FTYPE, message_type);

  if(int_ptr->tc_gem.message_type == CAI_FTC_GEN_EXTN_MSG)
  {
    M1X_MSG( DCP, LEGACY_ERROR,
      "GEM itself can not be extended by GEM");
    status = CAIX_INV_MSG_S;
    return (status);
  }

  #undef FTYPE

  /* Overwrite the L3 part of GEM with the L3 message being extended.
   * It will facilitate to use existing FTC messages translation functions.
   */
  {
    /* Replace message ID with the type of the message being extended */
    b_packb( int_ptr->tc_gem.message_type, buf_ptr,
               FPOS( cai_gen_type, msg_type ),
               FSIZ( cai_gen_type, msg_type ));

    /* Adding this check to ensure len_msg does not get 
     * assigned a negative value */
    if (len + layer2_end_pos < ext_msg_pos)
    {
        M1X_MSG ( DCP, LEGACY_MED,
          "GEM : %d bits extra eaten up. Something wrong in parsing!!",
          (ext_msg_pos - (len + layer2_end_pos)));
        status = CAIX_INV_MSG_S;
        return (status);        
    }  
    len_msg = len - ext_msg_pos + layer2_end_pos;
    buf_pos = layer2_end_pos;

    /* Copy the bits from Message Rec field in 3 steps.
       1) Copy the bits before next octet boundary in input bit stream
       2) Copy remaining bits in steps of octets from input bit stream
       3) Copy further remaining bits in last octet, if any.
    */
    /* Step 1 */
    /*lint -save -e702 */
    if (ext_msg_pos%8 != 0)
    {
      n_bits = 8 - (ext_msg_pos%8);
      s_addr_l3 = buf_ptr + ext_msg_pos/8;
      val_8 = *s_addr_l3; // 8 bit value
      val_8 = (val_8 << (8 - n_bits)) >> (8 - n_bits);
      b_packb( val_8, buf_ptr, buf_pos, n_bits);
      ext_msg_pos += n_bits;
      buf_pos += n_bits;
    }

    /* Adding this check to ensure temp_msg_pos does not get 
     * assigned a negative value */
    if (len < ext_msg_pos)
    {
        M1X_MSG ( DCP, LEGACY_MED,
          "GEM : %d bits extra eaten up. Something wrong in parsing!!",
           ext_msg_pos - len);
        status = CAIX_INV_MSG_S;
        return (status);        
    } 
    /* Step 2 */
    temp_msg_pos = len - ext_msg_pos;
    for (n = 0; n < temp_msg_pos/8; n++)
    {
      s_addr_l3 = buf_ptr + ext_msg_pos/8;
      val_8 = *s_addr_l3;
      b_packb( val_8, buf_ptr, buf_pos, 8);
      ext_msg_pos += 8;
      buf_pos += 8;
    }

    /* Step 3. Generally it should not be required. */
    if (ext_msg_pos < len)
    {
      M1X_MSG( DCP, LEGACY_MED,
        "%d bits remaining. Message length not in octets!",
        len - ext_msg_pos);

      n_bits = len - ext_msg_pos;
      s_addr_l3 = buf_ptr + ext_msg_pos/8;
      val_8 = *s_addr_l3;
      val_8 = val_8 >> (8 - n_bits);
      b_packb( val_8, buf_ptr, buf_pos, n_bits);
      ext_msg_pos += n_bits;
      buf_pos += n_bits;
    }
    else if (ext_msg_pos > len)
    {
      M1X_MSG( DCP, LEGACY_MED,
        "GEM : %d bits extra eaten up. Something wrong in parsing!!",
        ext_msg_pos - len);
      status = CAIX_INV_MSG_S;
      return (status);
    }
    /*lint -restore */

    /* Translate the message extended through GEM. Store the message rec field
     * along with message type and L2 header i.e. complete message in structure
     * of type caii_rx_msg_type. This will facilitate in processing of extended
     * message using existing functions.
     */
    if( caii_gem_message_rec_ptr != NULL )
    {
      int_ptr->tc_gem.message_rec = (byte*)(caii_gem_message_rec_ptr);
      status = xlate_ext_tc_msg(len_msg, buf_ptr, caii_gem_message_rec_ptr);
    }
    else
    {
      M1X_MSG( DCP, LEGACY_ERROR,
        "caii_gem_message_rec_ptr is NULL and returning status:%d",
        status);
      return (status);
    }
  }

  return (status);
} /* xlate_ext_tc_gen_extn */
#endif /* FEATURE_IS2000_1X_ADV */

/*===========================================================================

FUNCTION XLATE_EXT_TC_MSG

DESCRIPTION
  This function translates a received Traffic Channel Message from
  external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_msg
(
  word len,
    /* Length of message in bits */
  byte *tc_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Assert that tc_ptr and int_ptr are not NULL */
  ONEX_ASSERT(tc_ptr != NULL);
  ONEX_ASSERT(int_ptr != NULL);


  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  /* AUTH is skipped while operating in CSFB mode */
  if(cdma.entry_ptr->entry != MCC_CSFB)
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
  {
    byte encryption;

    /* the message encrypt mode could be one of the following values:
     *  0 (CAI_ENC_MODE_DISABLED)      -- no encryption
     *  1 (CAI_ENCRYPT_CALL_CTL_MSGS)  -- CMEA encrypted. the message
     *     will be decrypted by the function call of auth_decrypt_cdma
     *  2 (CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG) -- ECMEA. this mode is not
     *     supported
     *  3 (CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG  -- AES encrypted. later on
     *     in function xlate_ext_ext_enc_tc will handle the AES decryption.
     *
     */
    if ((encryption = b_unpackb( tc_ptr, FPOS( cai_gen_tc_type, hdr.encryption ),
        FSIZ( cai_gen_tc_type, hdr.encryption ))) == CAI_ENCRYPT_CALL_CTL_MSGS)
    {
      if (!auth_decrypt_cdma( &len, tc_ptr ))
      {
        /* The decryption failed, and we can't risk processing the message */
        return (CAIX_INV_MSG_S);
      }
    }
    else if (encryption == CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG)
    {
      /* We don't support ECMEA */
      return (CAIX_INV_MSG_S);
    }
    else
    {
      /* Either no encryption - pass through
      ** or Extended Encryption - processed later
      */
    }
  } /* if(cdma.entry_ptr->entry != MCC_CSFB) */


  /* -------------------
  ** Decode message type
  ** ------------------- */
  switch ((int_ptr->gen_tc.msg_type =
             b_unpackb( tc_ptr, FPOS( cai_gen_type, msg_type ),
                                FSIZ( cai_gen_type, msg_type ))))
  {
    case CAI_TC_FWD_ORD_MSG:
      status = xlate_ext_tc_ord( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX order type 0x%x ack_seq %x msg_seq %x",
        int_ptr->tc_ord.gen.order,
        int_ptr->tc_ord.gen.hdr.ack_seq,
        int_ptr->tc_ord.gen.hdr.msg_seq );
      break;

    case CAI_TC_AUTH_MSG:
      status = xlate_ext_auth_ch( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX auth chal encrypt %x randu %x",
        int_ptr->auth_ch.hdr.encryption,
        int_ptr->auth_ch.randu );
      break;

    case CAI_ALERT_MSG:
      status = xlate_ext_info( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX alert w/info #recs %x",
        int_ptr->alert.num_recs );
      break;

    case CAI_TC_FWD_BURST_MSG:
      status = xlate_ext_tc_burst( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX TC burst msg# %x type %x msgs %x",
        int_ptr->tc_burst.msg_number,
        int_ptr->tc_burst.burst_type,
        int_ptr->tc_burst.num_msgs );
      break;

    case CAI_HO_DIR_MSG:
    case CAI_EXT_HO_DIR_MSG:
    case CAI_GEN_HO_DIR_MSG:
    case CAI_UNIV_HO_DIR_MSG:

    case CAI_MEID_UNIV_HO_DIR_MSG:


      /* Yes, these five cases fall through, because we want to use
         the generic handoff function for all handoff types. */

      status = xlate_ext_ho_msg( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX HO type %d, hdm_seq %d #pilots %d",
        int_ptr->gen_tc.msg_type,
        int_ptr->ho.hdm_seq,
        int_ptr->ho.num_pilots );
      break;

    case CAI_FM_HO_MSG:
      status = xlate_ext_fm_ho( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX FM HO vmac %x chan %x scc %x",
        int_ptr->fm_ho.vmac,
        int_ptr->fm_ho.analog_chan,
        int_ptr->fm_ho.scc );
      break;

    case CAI_TC_SYS_PARM_MSG:
      status = xlate_ext_tc_sys_parm( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX In Traffic SysParm" );
      break;

    case CAI_TC_NLU_MSG:
      status = xlate_ext_nlu( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Nghbr List Update %x nghbrs ",
        int_ptr->nlu.num_nghbr );
      break;

    case CAI_SEND_BURST_MSG:
      status = xlate_ext_send_burst( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX DTMF %x",
        int_ptr->sbdtmf.digit[0] );
      break;

    case CAI_PWR_CTL_MSG:
      status = xlate_ext_pwr_ctl( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Pwr Ctl thresh %x, frms %x, delay %x",
        int_ptr->pwr_ctl.pwr_rep_thresh,
        int_ptr->pwr_ctl.pwr_rep_frames,
        int_ptr->pwr_ctl.pwr_rep_delay );
      break;

    case CAI_RET_PARMS_MSG:
      status = xlate_ext_ret_parms( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Ret Parms # %x, prm1 %x, prm2 %x",
        int_ptr->ret.num_parms,
        int_ptr->ret.parameter_id[0],
        int_ptr->ret.parameter_id[1] );
      break;

    case CAI_SET_PARMS_MSG:
      status = xlate_ext_set_parm( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Ret Parms # %x, prm1 %x, prm2 %x",
        int_ptr->set.num_parms,
        int_ptr->set.parms[0].parameter_id,
        int_ptr->set.parms[1].parameter_id );
      break;

    case CAI_TC_SSD_UP_MSG:
      status = xlate_ext_ssd_up( len, tc_ptr, int_ptr);
      M1X_MSG( DCP, LEGACY_MED,
        "RX SSD up randu %lx%lx",
        qw_lo(int_ptr->ssd_up.randssd),
        qw_hi (int_ptr->ssd_up.randssd ) );
      break;

    case CAI_FWD_FLASH_MSG:
      status = xlate_ext_info( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Flash with %x records",
        int_ptr->alert.num_recs );
      break;

    case CAI_MOB_REG_MSG:
      status = xlate_ext_mob_reg( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Mob Reg in SID %x NID %x",
        int_ptr->reg.sid,
        int_ptr->reg.nid );
      break;

    case CAI_TC_STREQ_MSG:
      status = xlate_ext_tc_streq( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Stat Req. num fields: %x",
        int_ptr->tc_streq.num_fields );
      break;

    case CAI_FTC_SRV_REQ_MSG:
      status = xlate_ext_srv_req( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Srv Req. Purp: %x Num Rec: %x",
        int_ptr->srv_req.purp,
        int_ptr->srv_req.cfg.num_con );
      break;

    case CAI_FTC_SRV_RSP_MSG:
      status = xlate_ext_srv_rsp( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Srv Rsp. Purp: %x Num Rec: %x",
        int_ptr->srv_rsp.purp,
        int_ptr->srv_rsp.cfg.num_con );
      break;

    case CAI_SRV_CON_MSG:
      status = xlate_ext_srv_con( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Srv Con. Con Seq: %x Num Rec: %x",
        int_ptr->srv_con.con_seq,
        int_ptr->srv_con.cfg.num_con );
      break;

    case CAI_FTC_SRV_CTL_MSG:
      status = xlate_ext_srv_ctl( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Srv Ctl. Con Ref: %x SO: %x",
        int_ptr->srv_ctl.con_ref,
        int_ptr->srv_ctl.so );
      break;

    case CAI_FTC_TMSI_ASGN_MSG:
      status = xlate_ext_tc_tmsi( len, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX FTC TMSI Assignment msg" );
      break;

    case CAI_FTC_SRV_REDIR_MSG:
      status = xlate_ext_tc_srv_redir( len,tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX FTC Srv Redir msg, redir_type %d",
        int_ptr->tc_srv_redir.redirect_type );
      break;

    case CAI_SUP_CHN_ASN_MSG:
      status = xlate_ext_scam( len,tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "" );
      break;

    case CAI_FTC_PWR_CTRL_MSG:
      status = xlate_ext_tc_pwr_ctrl( len,tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "" );
      break;

    case CAI_EXT_NLU_MSG:
      status = xlate_ext_ext_nlu( len,tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "" );
      break;

    case CAI_CF_SRCH_REQ_MSG:
      status = xlate_ext_tc_cfs_req( len,tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "" );
      break;

    case CAI_CFS_CTRL_MSG:
      status = xlate_ext_tc_cfs_ctrl( len,tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "" );
      break;

    case CAI_PUF_MSG:
      status = xlate_ext_tc_puf( len,tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "" );
      break;

    case CAI_PUF_CMP_MSG:
      status = xlate_ext_tc_puf_cmp( len,tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "" );
      break;

    case CAI_EXT_SUP_CHN_ASN_MSG:
      status = xlate_ext_tc_escam( len,tc_ptr,int_ptr );
      break;

    case CAI_RES_ALLOC_MSG:
      status = xlate_ext_tc_ram( len, tc_ptr, int_ptr );
      break;

    case CAI_EXT_RELEASE_MSG:
      status = xlate_ext_tc_erm( len, tc_ptr, int_ptr );
      break;

#ifdef FEATURE_IS2000_REL_A
    case CAI_MOB_ASSIST_BURST_OP_MSG:
      status = xlate_ext_tc_mabom( len,tc_ptr,int_ptr );
      break;

    case CAI_USER_ZONE_REJ_MSG:
      status = xlate_ext_tc_uzrm( len,tc_ptr,int_ptr );
      break;

    case CAI_USER_ZONE_UPDATE_MSG:
      status = xlate_ext_tc_uzum( len,tc_ptr,int_ptr );
      break;

    case CAI_CALL_ASSIGN_MSG:
      status = xlate_ext_tc_clam( len,tc_ptr,int_ptr );
      break;

    case CAI_EXT_ALERT_W_INFO_MSG:
      status = xlate_ext_tc_eawim( len,tc_ptr,int_ptr );
      break;

    case CAI_EXT_FLASH_W_INFO_MSG:
      status = xlate_ext_tc_eawim( len,tc_ptr,int_ptr );
      break;

    case CAI_SECURITY_MODE_MSG:
      status = xlate_ext_tc_smcm( len,tc_ptr,int_ptr );
      break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A
    case CAI_BS_STATUS_RSP_MSG:
      status = xlate_ext_bs_status_rsp( len, tc_ptr, int_ptr );
      break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    case CAI_TC_AUTH_REQ_MSG:
      status = xlate_ext_tc_auth_req( len, tc_ptr, int_ptr );
      break;

    case CAI_RATE_CHANGE_MSG:
      status = xlate_ext_tc_rate_change( len, tc_ptr, int_ptr );
      break;
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_1X_ADV
    case CAI_RADIO_CONFIG_PARAM_MSG:
      status = xlate_ext_tc_rcpm( len, tc_ptr, int_ptr );
      break;

    case CAI_FTC_GEN_EXTN_MSG:
      status = xlate_ext_tc_gen_extn( len, tc_ptr, int_ptr );
      break;
#endif /* FEATURE_IS2000_1X_ADV */

#ifdef FEATURE_1X_TO_LTE
    case CAI_TC_ALT_TECH_INFO_MSG:
      if(IS_1X_TO_LTE_RESELECTION_ENABLED)
      {
        status = xlate_ext_tc_alt_tech_info(len, tc_ptr, int_ptr, CAIX_TC);
      }
      else
      {
        M1X_MSG( DCP, LEGACY_HIGH,
          "1X to LTE reselections are not enabled. Ignoring ATIM!!");
        status = CAIX_INV_MSG_S;
      }

      break;
#endif /* FEATURE_1X_TO_LTE */

    default:
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

  return (status);

} /* xlate_ext_tc_msg */

/*===========================================================================

FUNCTION XLATE_EXT_SYS_PARM

DESCRIPTION
  This function translates a Paging Channel System Parameter Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the System Parameter message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_sys_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* status returned to calling procedure */
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */
  word min_len;
    /* Protocol dependent minimum length requirement */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_sysparm_msg_type

#ifdef FEATURE_1X_TO_LTE
    /* Initialize following fields. */
    int_ptr->sysparm.atim_ind = 0;
    int_ptr->sysparm.atim_cycle_index = 0;
#endif /*FEATURE_1X_TO_LTE*/

  /* ---------------------------------------
  ** Check length to make sure it is correct
  ** --------------------------------------- */
  if ( len < CAI_SYSPARM_MIN )
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* ----------------------------------------------------------------
    ** Length is ok - start translating message at field after msg_type
    ** ---------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(sysparm.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(sysparm.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKW_PG(sysparm.sid, MTYPE, sid);
    UNPACKW_PG(sysparm.nid, MTYPE, nid);
    UNPACKW_PG(sysparm.reg_zone, MTYPE, reg_zone);
    UNPACKB_PG(sysparm.total_zones, MTYPE, total_zones);
    UNPACKB_PG(sysparm.zone_timer, MTYPE, zone_timer);
    UNPACKB_PG(sysparm.mult_sids, MTYPE, mult_sids);
    UNPACKB_PG(sysparm.mult_nids, MTYPE, mult_nids);
    UNPACKW_PG(sysparm.base_id, MTYPE, base_id);
    UNPACKB_PG(sysparm.base_class, MTYPE, base_class);
    UNPACKB_PG(sysparm.page_chan, MTYPE, page_chan);
    UNPACKB_PG(sysparm.max_slot_cycle_index, MTYPE, max_slot_cycle_index);
    UNPACKB_PG(sysparm.home_reg, MTYPE, home_reg);
    UNPACKB_PG(sysparm.for_sid_reg, MTYPE, for_sid_reg);
    UNPACKB_PG(sysparm.for_nid_reg, MTYPE, for_nid_reg);
    UNPACKB_PG(sysparm.power_up_reg, MTYPE, power_up_reg);
    UNPACKB_PG(sysparm.power_down_reg, MTYPE, power_down_reg);
    UNPACKB_PG(sysparm.parameter_reg, MTYPE, parameter_reg);
    UNPACKB_PG(sysparm.reg_prd, MTYPE, reg_prd);
    UNPACKD_PG(sysparm.base_lat, MTYPE, base_lat);
    UNPACKD_PG(sysparm.base_long, MTYPE, base_long);
    UNPACKW_PG(sysparm.reg_dist, MTYPE, reg_dist);
    UNPACKB_PG(sysparm.srch_win_a, MTYPE, srch_win_a);
    UNPACKB_PG(sysparm.srch_win_n, MTYPE, srch_win_n);
    UNPACKB_PG(sysparm.srch_win_r, MTYPE, srch_win_r);
    UNPACKB_PG(sysparm.nghbr_max_age, MTYPE, nghbr_max_age);
    UNPACKB_PG(sysparm.pwr_rep_thresh, MTYPE, pwr_rep_thresh);
    UNPACKB_PG(sysparm.pwr_rep_frames, MTYPE, pwr_rep_frames);
    UNPACKB_PG(sysparm.pwr_thresh_enable, MTYPE, pwr_thresh_enable);
    UNPACKB_PG(sysparm.pwr_period_enable, MTYPE, pwr_period_enable);
    UNPACKB_PG(sysparm.pwr_rep_delay, MTYPE, pwr_rep_delay);
    UNPACKB_PG(sysparm.rescan, MTYPE, rescan);
    UNPACKB_PG(sysparm.t_add, MTYPE, t_add);
    UNPACKB_PG(sysparm.t_drop, MTYPE, t_drop);
    UNPACKB_PG(sysparm.t_comp, MTYPE, t_comp);
    UNPACKB_PG(sysparm.t_tdrop, MTYPE, t_tdrop);
    UNPACKB_PG(sysparm.ext_sys_parameter, MTYPE, ext_sys_parameter);
    UNPACKB_PG(sysparm.ext_nghbr_list, MTYPE, ext_nghbr_list);
    UNPACKB_PG(sysparm.gen_nghbr_list, MTYPE, gen_nghbr_list);

#ifdef FEATURE_IS2000_REL_A
    if (cdma.mob_cai_rev < P_REV_IS95B)
    {
      int_ptr->sysparm.gen_nghbr_list = FALSE;
    }
#endif /* FEATURE_IS2000_REL_A */

    UNPACKB_PG(sysparm.global_redirect, MTYPE, global_redirect);

#if !defined(FEATURE_IS2000_1X_ADV) && !defined(FEATURE_1X_TO_LTE) && defined(FEATURE_IS2000_REL_A)
    if (cdma.mob_cai_rev >= P_REV_IS2000)
#endif /*!FEATURE_IS2000_1X_ADV && !FEATURE_1X_TO_LTE && FEATURE_IS2000_REL_A */
    {
      /* Length check on mandatory fields + minimum reserved bits */
      min_len = FENDPOS( MTYPE, ext_chan_list ) - FENDPOS( MTYPE, gen_nghbr_list );
      if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
      {
        min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
      }

      if ( ( len - ext_msg_pos ) >= min_len )
      {
        int_ptr->sysparm.is2000_incl = TRUE;
        UNPACKB_PG(sysparm.pri_nghbr_list, MTYPE, pri_nghbr_list);
        UNPACKB_PG(sysparm.user_zone_id, MTYPE, user_zone_id);
        UNPACKB_PG(sysparm.ext_global_redirect, MTYPE, ext_global_redirect);
        UNPACKB_PG(sysparm.ext_chan_list, MTYPE, ext_chan_list);

#if defined(FEATURE_IS2000_1X_ADV) || defined(FEATURE_1X_TO_LTE)
        /* Set Rel E Included to FALSE */
        int_ptr->sysparm.is2000_rel_e_incl = FALSE;
#endif /* FEATURE_IS2000_1X_ADV || FEATURE_1X_TO_LTE */

#if defined (FEATURE_IS2000_1X_ADV) || defined(FEATURE_1X_TO_LTE) || defined(FEATURE_IS2000_REL_C)
#if !defined(FEATURE_IS2000_1X_ADV) && !defined(FEATURE_1X_TO_LTE) && defined(FEATURE_IS2000_REL_A)
        if (cdma.mob_cai_rev >= P_REV_IS2000_REL_C)
#endif /*!FEATURE_IS2000_1X_ADV && !FEATURE_1X_TO_LTE && FEATURE_IS2000_REL_A */
        {
          /* Length check on mandatory fields + minimum reserved bits */
          min_len = FSIZ( MTYPE, t_tdrop_range_incl );
          min_len += 8 - ( FENDPOS( MTYPE, t_tdrop_range_incl ) + CAI_PC_CRC_SIZE ) % 8;

          if ( (len - ext_msg_pos ) >= min_len )
          {
            int_ptr->sysparm.is2000_rel_c_incl = TRUE;
            UNPACKB_PG(sysparm.t_tdrop_range_incl, MTYPE, t_tdrop_range_incl);
            if (int_ptr->sysparm.t_tdrop_range_incl)
            {
              UNPACKB_PG(sysparm.t_tdrop_range, MTYPE, t_tdrop_range);
            }

#if defined (FEATURE_IS2000_1X_ADV) || defined(FEATURE_1X_TO_LTE)
#if !defined (FEATURE_IS2000_1X_ADV) && !defined(FEATURE_1X_TO_LTE) && defined(FEATURE_IS2000_REL_A)
            if (cdma.mob_cai_rev >= P_REV_IS2000_REL_D)
#endif /* !FEATURE_IS2000_1X_ADV && !FEATURE_1X_TO_LTE && FEATURE_IS2000_REL_A */
            {
              /* Length check on mandatory fields + minimum reservced bits */
              min_len = FSIZ( MTYPE, neg_slot_cycle_index_sup );
              if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
              {
                min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
              }

              if ( ( len - ext_msg_pos ) >= min_len )
              {
                int_ptr->sysparm.is2000_rel_d_incl = TRUE;
                UNPACKB_PG(sysparm.neg_slot_cycle_index_sup, MTYPE, neg_slot_cycle_index_sup);

#if defined(FEATURE_IS2000_1X_ADV) || defined(FEATURE_1X_TO_LTE)
                /* Length check on mandatory fields + minimum reservced bits */
                min_len = FSIZ( MTYPE, rc_bitmap_capability_ext_allowed );
                if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
                {
                  min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
                }

                if ( ( len - ext_msg_pos ) >= min_len )
                {
                  int_ptr->sysparm.is2000_rel_e_incl = TRUE;
                  UNPACKB_PG(sysparm.rc_bitmap_capability_ext_allowed, MTYPE, rc_bitmap_capability_ext_allowed);

#ifdef FEATURE_1X_TO_LTE

                  M1X_MSG( DCP, LEGACY_MED,
                    "len=%d, ext_msg_pos=%d, old_result=%d",
                    len,
                    ext_msg_pos,
                    ((len-CAI_PC_CRC_SIZE-ext_msg_pos)<FSIZ(MTYPE,
                    crrm_msg_ind)));
                  /* Check and Parse if the following fields are included. */
                  min_len = FSIZ(MTYPE, crrm_msg_ind);
                  if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
                  {
                    min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
                  }
                  M1X_MSG( DCP, LEGACY_MED,
                    "len=%d, ext_msg_pos=%d, min_len=%d",
                    len,
                    ext_msg_pos,
                    min_len);

                  if ( ( len - ext_msg_pos ) >= min_len )
                  {
                  UNPACKB_PG(sysparm.crrm_msg_ind, MTYPE, crrm_msg_ind);

                    /* Check and Parse if the following fields are included. */
                    min_len = FSIZ(MTYPE, num_opt_msg_bits);
                    if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
                  {
                      min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
                  }
                    M1X_MSG( DCP, LEGACY_MED,
                      "len=%d, ext_msg_pos=%d, min_len=%d",
                      len,
                      ext_msg_pos,
                      min_len);

                    if ( ( len - ext_msg_pos ) >= min_len )
                    {
                  UNPACKB_PG(sysparm.num_opt_msg_bits, MTYPE, num_opt_msg_bits);

                  if(int_ptr->sysparm.num_opt_msg_bits >= 1)
                  {
                    UNPACKB_PG(sysparm.ap_pilot_info, MTYPE, ap_pilot_info);
                    if(int_ptr->sysparm.num_opt_msg_bits >= 2)
                    {
                      UNPACKB_PG(sysparm.ap_idt, MTYPE, ap_idt);
                      if(int_ptr->sysparm.num_opt_msg_bits >= 3)
                      {
                        UNPACKB_PG(sysparm.ap_id_text, MTYPE, ap_id_text);
                        if(int_ptr->sysparm.num_opt_msg_bits >= 4)
                        {
                          UNPACKB_PG(sysparm.gen_ovhd_inf_ind, MTYPE, gen_ovhd_inf_ind);
                          if(int_ptr->sysparm.num_opt_msg_bits >= 5)
                          {
                            UNPACKB_PG(sysparm.fd_chan_lst_ind, MTYPE, fd_chan_lst_ind);
                            if(int_ptr->sysparm.num_opt_msg_bits >= 6)
                            {
                              UNPACKB_PG(sysparm.atim_ind, MTYPE, atim_ind);
                              if(int_ptr->sysparm.num_opt_msg_bits >= 7)
                              {
                                UNPACKB_PG(sysparm.freq_gen_ovhd_inf_ind, MTYPE, freq_gen_ovhd_inf_ind);
                                ext_msg_pos += (int_ptr->sysparm.num_opt_msg_bits - 7);
                              } /* if(int_ptr->sysparm.num_opt_msg_bits >= 7) */
                            } /* if(int_ptr->sysparm.num_opt_msg_bits >= 6) */
                          } /* if(int_ptr->sysparm.num_opt_msg_bits >= 5) */
                        } /* if(int_ptr->sysparm.num_opt_msg_bits >= 4) */
                      } /* if(int_ptr->sysparm.num_opt_msg_bits >= 3) */
                    } /* if(int_ptr->sysparm.num_opt_msg_bits >= 2) */
                  } /* if(int_ptr->sysparm.num_opt_msg_bits >= 1) */

                  if((int_ptr->sysparm.num_opt_msg_bits >= 1) &&
                     (int_ptr->sysparm.ap_pilot_info == 1)
                    )
                  {
                    UNPACKB_PG(sysparm.appim_period_index, MTYPE, appim_period_index);
                  }

                  if((int_ptr->sysparm.num_opt_msg_bits >= 4) &&
                     (int_ptr->sysparm.gen_ovhd_inf_ind == 1)
                    )
                  {
                    UNPACKB_PG(sysparm.gen_ovhd_cycle_index, MTYPE, gen_ovhd_cycle_index);
                  }

                  if((int_ptr->sysparm.num_opt_msg_bits >= 6) &&
                     (int_ptr->sysparm.atim_ind == 1)
                    )
                  {
                    UNPACKB_PG(sysparm.atim_cycle_index, MTYPE, atim_cycle_index);
                  }

                      /* Check and Parse if the following fields are included. */
                      min_len = FSIZ(MTYPE, add_loc_info_inc);
                      if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
                  {
                        min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
                  }
                      M1X_MSG( DCP, LEGACY_MED,
                        "len=%d, ext_msg_pos=%d, min_len=%d",
                        len,
                        ext_msg_pos,
                        min_len);

                      if ( ( len - ext_msg_pos ) >= min_len )
                      {
                  UNPACKB_PG(sysparm.add_loc_info_inc, MTYPE, add_loc_info_inc);

                  if(int_ptr->sysparm.add_loc_info_inc)
                  {
                    UNPACKB_PG(sysparm.loc_unc_h, MTYPE, loc_unc_h);
                    UNPACKW_PG(sysparm.height, MTYPE, height);
                    UNPACKB_PG(sysparm.loc_unc_v, MTYPE, loc_unc_v);
                  }

                        /* Check and Parse if the following fields are included. */
                        min_len = FSIZ(MTYPE, add_loc_gem_allowed);
                        if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
                  {
                          min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
                  }
                        M1X_MSG( DCP, LEGACY_MED,
                          "len=%d, ext_msg_pos=%d, min_len=%d",
                          len,
                          ext_msg_pos,
                          min_len);

                        if ( ( len - ext_msg_pos ) >= min_len )
                        {
                          UNPACKB_PG(sysparm.add_loc_gem_allowed, MTYPE, add_loc_gem_allowed);
                        }
                      }
                    }
                  }
#endif /* FEATURE_1X_TO_LTE */
                }

#endif /* FEATURE_IS2000_1X_ADV || FEATURE_1X_TO_LTE */
              }
            }
#endif /* FEATURE_IS2000_1X_ADV || FEATURE_1X_TO_LTE */

          }
        }
#endif /* FEATURE_IS2000_1X_ADV || FEATURE_1X_TO_LTE || FEATURE_IS2000_REL_C */

      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_sys_parm */

/*===========================================================================

FUNCTION XLATE_EXT_ACC_PARM

DESCRIPTION
  This function translates a Paging Channel Access Parameters Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Access Parameter message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_acc_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */

  #ifdef FEATURE_IS2000_REL_A
  word min_len;
    /* Protocol dependent minimum length requirement */
  byte  i;        /* Loop counter */
#endif /* FEATURE_IS2000_REL_A */


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_accparm_msg_type

  /* ---------------------------------------
  ** Check length to make sure it is correct
  ** --------------------------------------- */
  if ( len < CAI_ACCPARM_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ----------------------------------------------------------------
    ** Length is ok - start translating message at field after msg_type
    ** ---------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(accparm.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(accparm.acc_msg_seq, MTYPE, acc_msg_seq);
    UNPACKB_PG(accparm.acc_chan, MTYPE, acc_chan);
    UNPACKB_PG(accparm.nom_pwr, MTYPE, nom_pwr);
    UNPACKB_PG(accparm.init_pwr, MTYPE, init_pwr);
    UNPACKB_PG(accparm.pwr_step, MTYPE, pwr_step);
    UNPACKB_PG(accparm.num_step, MTYPE, num_step);
    UNPACKB_PG(accparm.max_cap_sz, MTYPE, max_cap_sz);
    UNPACKB_PG(accparm.pam_sz, MTYPE, pam_sz);
    UNPACKB_PG(accparm.psist_0_9, MTYPE, psist_0_9);
    UNPACKB_PG(accparm.psist_10, MTYPE, psist_10);
    UNPACKB_PG(accparm.psist_11, MTYPE, psist_11);
    UNPACKB_PG(accparm.psist_12, MTYPE, psist_12);
    UNPACKB_PG(accparm.psist_13, MTYPE, psist_13);
    UNPACKB_PG(accparm.psist_14, MTYPE, psist_14);
    UNPACKB_PG(accparm.psist_15, MTYPE, psist_15);
    UNPACKB_PG(accparm.msg_psist, MTYPE, msg_psist);
    UNPACKB_PG(accparm.reg_psist, MTYPE, reg_psist);
    UNPACKB_PG(accparm.probe_pn_ran, MTYPE, probe_pn_ran);
    UNPACKB_PG(accparm.acc_tmo, MTYPE, acc_tmo);
    UNPACKB_PG(accparm.probe_bkoff, MTYPE, probe_bkoff);
    UNPACKB_PG(accparm.bkoff, MTYPE, bkoff);
    UNPACKB_PG(accparm.max_req_seq, MTYPE, max_req_seq);
    UNPACKB_PG(accparm.max_rsp_seq, MTYPE, max_rsp_seq);
    UNPACKB_PG(accparm.auth, MTYPE, auth);

    /* New IS-95A requirement */
    if ((int_ptr->accparm.auth != 0) && (int_ptr->accparm.auth != 1))
    {
      int_ptr->accparm.auth = TRUE;
    }

    if (int_ptr->accparm.auth)
    {
      UNPACKD_PG(accparm.rand, MTYPE, rand);
    }

    UNPACKB_PG(accparm.nom_pwr_ext, MTYPE, nom_pwr_ext);

#ifdef FEATURE_IS2000_REL_A

    if (cdma.mob_cai_rev >= P_REV_IS2000_REL_A)

    {
      /* Length check on mandatory fields + minimum reserved bits */
      min_len = FSIZ( MTYPE, psist_emg_incl ) + FSIZ( MTYPE, acct_incl );
      min_len +=  8 - ( ext_msg_pos + min_len +  CAI_PC_CRC_SIZE ) % 8;
      if ( ( len - ext_msg_pos ) >=  min_len )
      {
        UNPACKB_PG(accparm.psist_emg_incl, MTYPE, psist_emg_incl);

        if (int_ptr->accparm.psist_emg_incl)
        {
          UNPACKB_PG(accparm.psist_emg, MTYPE, psist_emg);
        }

        /* Support for ACCT fields */
        UNPACKB_PG(accparm.acct_incl, MTYPE, acct_incl);

        if (int_ptr->accparm.acct_incl)
        {
          UNPACKB_PG(accparm.acct_incl_emg, MTYPE, acct_incl_emg);
          UNPACKB_PG(accparm.acct_aoc_bitmap_incl, MTYPE, acct_aoc_bitmap_incl);
          UNPACKB_PG(accparm.acct_so_incl, MTYPE, acct_so_incl);

          if (int_ptr->accparm.acct_so_incl)
          {
            UNPACKB_PG(accparm.num_acct_so, MTYPE, num_acct_so);

            for (i=0; i<(int_ptr->accparm.num_acct_so+1); i++)
            {
              if (int_ptr->accparm.acct_aoc_bitmap_incl)
              {
                UNPACKB_PG(accparm.acct_so_info[i].acct_aoc_bitmap1, MTYPE, acct_aoc_bitmap1);
              }
              UNPACKW_PG(accparm.acct_so_info[i].acct_so, MTYPE, acct_so);
            }
          }

          UNPACKB_PG(accparm.acct_so_grp_incl, MTYPE, acct_so_grp_incl);

          if (int_ptr->accparm.acct_so_grp_incl)
          {
            UNPACKB_PG(accparm.num_acct_so_grp, MTYPE, num_acct_so_grp);
            for (i=0; i<(int_ptr->accparm.num_acct_so_grp+1); i++)
            {
              if (int_ptr->accparm.acct_aoc_bitmap_incl)
              {
                UNPACKB_PG(accparm.acct_so_grp_info[i].acct_aoc_bitmap2, MTYPE, acct_aoc_bitmap2);
              }
              UNPACKB_PG(accparm.acct_so_grp_info[i].acct_so_grp, MTYPE, acct_so_grp);
            }
          }
        }
      }
    }
    #endif /* FEATURE_IS2000_REL_A */
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_acc_parm */

/*===========================================================================

FUNCTION XLATE_EXT_EXT_NL

DESCRIPTION
  This function translates a Paging Channel Extended Neighbor List Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Neighbor List message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_ext_nl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through neighbors */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_ext_nghbr_msg_type

  if ( len < CAI_EXT_NGHBR_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ---------------------------------------------------------------
    ** Length is ok - convert message from external to internal format
    ** starting with the first field after message_type
    ** --------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(ext_nghbr.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(ext_nghbr.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKB_PG(ext_nghbr.pilot_inc, MTYPE, pilot_inc);

    /* Initialize number of neighbors */
    int_ptr->ext_nghbr.num_nghbrs = 0;

    for (i=0; ( ( ext_msg_pos + FENDPOS( MTYPE, freq_incl ) -
                  FENDPOS( MTYPE, pilot_inc ) ) <= len ); i++)
    {
      UNPACKB_PG(ext_nghbr.nghbr[i].nghbr_config, MTYPE, nghbr_config);
      UNPACKW_PG(ext_nghbr.nghbr[i].nghbr_pn, MTYPE, nghbr_pn);
      UNPACKB_PG(ext_nghbr.nghbr[i].search_pri, MTYPE, search_pri);
      UNPACKB_PG(ext_nghbr.nghbr[i].freq_incl, MTYPE, freq_incl);

      /* Check if neighbor freq and band are included */
      /* for this set.                                */
      if (int_ptr->ext_nghbr.nghbr[i].freq_incl)
      {
        UNPACKB_PG(ext_nghbr.nghbr[i].nghbr_band, MTYPE, nghbr_band);
        UNPACKW_PG(ext_nghbr.nghbr[i].nghbr_freq, MTYPE, nghbr_freq);
      }

      /* ----------------------------------------------------
      ** If NGHBR_CONFIGr is equal to '000', '001', or '010',
      ** then NGHBR_CONFIGs = NGHBR_CONFIGr, otherwise,
      ** NGHBR_CONFIGs = '011'.
      ** ---------------------------------------------------- */
      if (int_ptr->ext_nghbr.nghbr[i].nghbr_config > 3)
      {
        int_ptr->ext_nghbr.nghbr[i].nghbr_config = 3;
      }

      /* Set number of neighbors */
      int_ptr->ext_nghbr.num_nghbrs++;
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_ext_nl */

/*===========================================================================

FUNCTION XLATE_EXT_NL

DESCRIPTION
  This function translates a Paging Channel Neighbor List Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Neigbor List message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_nl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through neighbors */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_nghbr_msg_type

  if ( len < CAI_NGHBR_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ---------------------------------------------------------------
    ** Length is ok - convert message from external to internal format
    ** starting with the first field after message_type
    ** --------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(nghbr.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(nghbr.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKB_PG(nghbr.pilot_inc, MTYPE, pilot_inc);

    /* -------------------------------------
    ** Translate variable portion of message
    ** ------------------------------------- */
    int_ptr->nghbr.num_nghbrs = ( len - FENDPOS(MTYPE, pilot_inc) ) /
                                ( sizeof( MTYPE ) - FENDPOS( MTYPE, pilot_inc ) );

    for (i=0; i < int_ptr->nghbr.num_nghbrs; i++)
    {
      UNPACKB_PG(nghbr.nghbr[i].nghbr_config, MTYPE, nghbr_config);
      UNPACKW_PG(nghbr.nghbr[i].nghbr_pn, MTYPE, nghbr_pn);

      /* ----------------------------------------------------
      ** If NGHBR_CONFIGr is equal to '000', '001', or '010',
      ** then NGHBR_CONFIGs = NGHBR_CONFIGr, otherwise,
      ** NGHBR_CONFIGs = '011'.
      ** ---------------------------------------------------- */
      if (int_ptr->nghbr.nghbr[i].nghbr_config > 3) {
        int_ptr->nghbr.nghbr[i].nghbr_config = 3;
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_nl */

/*===========================================================================

FUNCTION XLATE_EXT_CL

DESCRIPTION
  This function translates a CDMA Channel List Message from external
  to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the CDMA Channel List message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_cl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through channels */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_chnlist_msg_type

  if ( len < CAI_CHNLIST_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(chnlist.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(chnlist.config_msg_seq, MTYPE, config_msg_seq);

    int_ptr->chnlist.num_freq =
      ( len - FENDPOS( MTYPE, config_msg_seq ) ) /
      ( sizeof(MTYPE) - FENDPOS( MTYPE, config_msg_seq ) );

    for (i=0; i < int_ptr->chnlist.num_freq; i++)
    {
      UNPACKW_PG(chnlist.cdma_freq[i], MTYPE, cdma_freq);
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_cl */

/*===========================================================================

FUNCTION XLATE_EXT_SLT_PAGE

DESCRIPTION
  This function translates a Paging Channel Slotted Page Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Slotted Page message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_slt_page
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of page within page message */
  word num_pages;
    /* Number of pages in page array */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_slt_page_fix_type

  /* ------------------------------------------------------
  ** First determine if the message is of sufficient length
  ** ------------------------------------------------------ */
  if (len < sizeof( cai_slt_page_fix_type )) {
    status = CAIX_INV_LEN_S;
  }

  else {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */
    int_ptr->slt_page.config_msg_seq = b_unpackb( PARAMS( config_msg_seq ));
    int_ptr->slt_page.acc_msg_seq    = b_unpackb( PARAMS( acc_msg_seq ));
    int_ptr->slt_page.more_pages     = b_unpackb( PARAMS( more_pages ));

    num_pages = 0;
    ext_msg_pos = sizeof( cai_slt_page_fix_type );

    while (len >= (CAI_SLT_PAGE_MIN + ext_msg_pos)) {
      int_ptr->slt_page.pages[num_pages].msg_seq =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_slt_page_var_type, msg_seq ));
      ext_msg_pos += FSIZ( cai_slt_page_var_type, msg_seq );

      int_ptr->slt_page.pages[num_pages].ext_addr =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_slt_page_var_type, ext_addr ));
      ext_msg_pos += FSIZ( cai_slt_page_var_type, ext_addr );

      int_ptr->slt_page.pages[num_pages].min1 =
        b_unpackd( buf_ptr, ext_msg_pos,
                   FSIZ( cai_slt_page_var_type, min1 ));
      ext_msg_pos += FSIZ( cai_slt_page_var_type, min1 );

      if (int_ptr->slt_page.pages[num_pages].ext_addr) {
        int_ptr->slt_page.pages[num_pages].min2 =
          b_unpackw( buf_ptr, ext_msg_pos,
                     FSIZ( cai_slt_page_var_type, min2 ));
        ext_msg_pos += FSIZ( cai_slt_page_var_type, min2 );
      }

      int_ptr->slt_page.pages[num_pages].special_service =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_slt_page_var_type, special_service ));
      ext_msg_pos += FSIZ( cai_slt_page_var_type, special_service );

      if (int_ptr->slt_page.pages[num_pages].special_service) {
        int_ptr->slt_page.pages[num_pages].service_option =
          b_unpackw( buf_ptr, ext_msg_pos,
                     FSIZ( cai_slt_page_var_type, service_option ));
        ext_msg_pos += FSIZ( cai_slt_page_var_type, service_option );
      }

      num_pages++;
    } /* end of while */

    int_ptr->slt_page.num_pages = num_pages;

    status = CAIX_DONE_S;
  }

  #undef MTYPE
  return (status);

} /* xlate_ext_slt_page */

/* <EJECT> */
/*===========================================================================

FUNCTION XLATE_EXT_PAGE

DESCRIPTION
  This function translates a Paging Channel Page Message from external
  to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Page Message message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_page
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of page within page message */
  word num_pages;
    /* Number of pages in page array */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_page_fix_type

  /* ------------------------------------------------------
  ** First determine if the message is of sufficient length
  ** ------------------------------------------------------ */
  if (len < sizeof( cai_page_fix_type )) {
    status = CAIX_INV_LEN_S;
  }

  else {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */
    int_ptr->page.config_msg_seq = b_unpackb( PARAMS( config_msg_seq ));
    int_ptr->page.acc_msg_seq    = b_unpackb( PARAMS( acc_msg_seq ));

    num_pages  = 0;
    ext_msg_pos   = sizeof (cai_page_fix_type );

    while (len >= (ext_msg_pos + CAI_PAGE_MIN)) {
      int_ptr->page.pages[num_pages].msg_seq =
        b_unpackb( buf_ptr, ext_msg_pos, FSIZ( cai_page_var_type, msg_seq ));
      ext_msg_pos += FSIZ( cai_page_var_type, msg_seq );

      int_ptr->page.pages[num_pages].ext_addr =
        b_unpackb( buf_ptr, ext_msg_pos, FSIZ( cai_page_var_type, ext_addr ));
      ext_msg_pos += FSIZ( cai_page_var_type, ext_addr );

      int_ptr->page.pages[num_pages].min1 =
        b_unpackd( buf_ptr, ext_msg_pos, FSIZ( cai_page_var_type, min1 ));
      ext_msg_pos += FSIZ( cai_page_var_type, min1 );

      if (int_ptr->page.pages[num_pages].ext_addr) {
        int_ptr->page.pages[num_pages].min2 =
          b_unpackw( buf_ptr, ext_msg_pos, FSIZ( cai_page_var_type, min2 ));
        ext_msg_pos += FSIZ( cai_page_var_type, min2 );
      }

      int_ptr->page.pages[num_pages].special_service =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_page_var_type, special_service ));
      ext_msg_pos += FSIZ( cai_page_var_type, special_service );

      if (int_ptr->page.pages[num_pages].special_service) {
        int_ptr->page.pages[num_pages].service_option =
          b_unpackw( buf_ptr, ext_msg_pos,
                     FSIZ( cai_page_var_type, service_option ));
        ext_msg_pos += FSIZ( cai_page_var_type, service_option );
      }

      num_pages ++;
    } /* end of while */

    int_ptr->page.num_pages = num_pages;

    status = CAIX_DONE_S;
  }

  #undef MTYPE
  return (status);

} /* xlate_ext_page */

/*===========================================================================

FUNCTION XLATE_EXT_PC_HDR

DESCRIPTION

DEPENDENCIES
  None

RETURN VALUE
  status

SIDE EFFECTS
  None

===========================================================================*/

void xlate_ext_pc_hdr
(
  word *buf_pos,
    /* Position of header fields relative to start of buf_ptr */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_pc_hdr_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  byte i;
    /* Loop counter */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  int_ptr->ack_seq =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, ack_seq ));
  *buf_pos += FSIZ( cai_pc_hdr_type, ack_seq );

  int_ptr->msg_seq =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, msg_seq ));
  *buf_pos += FSIZ( cai_pc_hdr_type, msg_seq );

  int_ptr->ack_req =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, ack_req ));
  *buf_pos += FSIZ( cai_pc_hdr_type, ack_req );

  int_ptr->valid_ack =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, valid_ack ));
  *buf_pos += FSIZ( cai_pc_hdr_type, valid_ack );

  int_ptr->addr_type =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, addr_type ));
  *buf_pos += FSIZ( cai_pc_hdr_type, addr_type );

  int_ptr->addr_len =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, addr_len ));
  *buf_pos += FSIZ( cai_pc_hdr_type, addr_len );

  if (int_ptr->addr_type == CAI_MIN_ADDR_TYPE)   /* 0 */
  {
    int_ptr->addr.type0.min1 =
      b_unpackd( buf_ptr, *buf_pos, FSIZ( cai_addr0_type, min1 ));
    *buf_pos += FSIZ( cai_addr0_type, min1 );

    int_ptr->addr.type0.min2 =
      b_unpackw( buf_ptr, *buf_pos, FSIZ( cai_addr0_type, min2 ));
    *buf_pos += FSIZ( cai_addr0_type, min2 );

    *buf_pos += FSIZ( cai_addr0_type, reserved );
  }
  else if (int_ptr->addr_type == CAI_ESN_ADDR_TYPE)   /* 1 */
  {
    b_unpackq( buf_ptr, *buf_pos,
               (int_ptr->addr_len * FSIZ( cai_addr1_type, esn )),
               int_ptr->addr.type1.esn );
    *buf_pos += (int_ptr->addr_len * FSIZ( cai_addr1_type, esn ));
  }
  else if (int_ptr->addr_type == CAI_IMSI_ADDR_TYPE)    /* 2 */
  {
    int_ptr->addr.type2.imsi.imsi_class =
      b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_addr2_type, imsi_class ));
    *buf_pos += FSIZ( cai_addr2_type, imsi_class );

    if (int_ptr->addr.type2.imsi.imsi_class == 0)
    {
      int_ptr->addr.type2.imsi.class_type.zero.imsi_class_0_type =
        b_unpackb( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class0_type, imsi_class_0_type ));
      *buf_pos += FSIZ( cai_imsi_class0_type, imsi_class_0_type );

      if (int_ptr->addr.type2.imsi.class_type.zero.imsi_class_0_type == 0)
      {
        *buf_pos += FSIZ( cai_imsi_class0_type0_type, reserved );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class0_type0_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.zero.type.zero.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class0_type0_type, imsi_s );
      }
      else if (int_ptr->addr.type2.imsi.class_type.zero.imsi_class_0_type == 1)
      {
        *buf_pos += FSIZ( cai_imsi_class0_type1_type, reserved );

        int_ptr->addr.type2.imsi.class_type.zero.type.one.imsi_11_12 =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class0_type1_type, imsi_11_12 ));
        *buf_pos += FSIZ( cai_imsi_class0_type1_type, imsi_11_12 );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class0_type1_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.zero.type.one.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class0_type1_type, imsi_s );
      }
      else if (int_ptr->addr.type2.imsi.class_type.zero.imsi_class_0_type == 2)
      {
        *buf_pos += FSIZ( cai_imsi_class0_type2_type, reserved );

        int_ptr->addr.type2.imsi.class_type.zero.type.two.mcc =
          b_unpackw( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class0_type2_type, mcc ));
        *buf_pos += FSIZ( cai_imsi_class0_type2_type, mcc );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class0_type2_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.zero.type.two.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class0_type2_type, imsi_s );
      }
      else /* (int_ptr->addr.type2.imsi.class_type.zero.imsi_class_0_type == 3) */
      {
        *buf_pos += FSIZ( cai_imsi_class0_type3_type, reserved );

        int_ptr->addr.type2.imsi.class_type.zero.type.three.mcc =
          b_unpackw( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class0_type3_type, mcc ));
        *buf_pos += FSIZ( cai_imsi_class0_type3_type, mcc );

        int_ptr->addr.type2.imsi.class_type.zero.type.three.imsi_11_12 =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class0_type3_type, imsi_11_12 ));
        *buf_pos += FSIZ( cai_imsi_class0_type3_type, imsi_11_12 );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class0_type3_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.zero.type.three.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class0_type3_type, imsi_s );
      }
    }
    else /* (int_ptr->addr.type2.imsi.imsi_class == 1) */
    {
      int_ptr->addr.type2.imsi.class_type.one.imsi_class_1_type =
        b_unpackb( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class1_type, imsi_class_1_type ));
      *buf_pos += FSIZ( cai_imsi_class1_type, imsi_class_1_type );

      if (int_ptr->addr.type2.imsi.class_type.one.imsi_class_1_type == 0)
      {
        *buf_pos += FSIZ( cai_imsi_class1_type0_type, reserved );

        int_ptr->addr.type2.imsi.class_type.one.type.zero.imsi_addr_num =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class1_type0_type, imsi_addr_num ));
        *buf_pos += FSIZ( cai_imsi_class1_type0_type, imsi_addr_num );

        int_ptr->addr.type2.imsi.class_type.one.type.zero.imsi_11_12 =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class1_type0_type, imsi_11_12 ));
        *buf_pos += FSIZ( cai_imsi_class1_type0_type, imsi_11_12 );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class1_type0_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.one.type.zero.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class1_type0_type, imsi_s );
      }
      else /* (int_ptr->addr.type2.imsi.class_type.one.imsi_class_1_type == 1) */
      {
        int_ptr->addr.type2.imsi.class_type.one.type.one.imsi_addr_num =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class1_type1_type, imsi_addr_num ));
        *buf_pos += FSIZ( cai_imsi_class1_type1_type, imsi_addr_num );

        int_ptr->addr.type2.imsi.class_type.one.type.one.mcc =
          b_unpackw( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class1_type1_type, mcc ));
        *buf_pos += FSIZ( cai_imsi_class1_type1_type, mcc );

        int_ptr->addr.type2.imsi.class_type.one.type.one.imsi_11_12 =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class1_type1_type, imsi_11_12 ));
        *buf_pos += FSIZ( cai_imsi_class1_type1_type, imsi_11_12 );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class1_type1_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.one.type.one.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class1_type1_type, imsi_s );
      }
    }
  }
  /* Process TMSI address for header */
  else if (int_ptr->addr_type == CAI_TMSI_ADDR_TYPE)     /* 3 */
  {
    /* Initialize destination TMSI info to zero */
    /* before unpacking.                        */
    int_ptr->addr.type3.tmsi_code = 0;
    qw_set( int_ptr->addr.type3.tmsi_zone, 0L, 0L );

    /* Determine if address length is longer  */
    /* than the maximum sized TMSI code.  If  */
    /* so, then TMSI zone is present.  Unpack */
    /* TMSI zone.                             */
    if ( int_ptr->addr_len > MAX_TMSI_CODE_LEN )
    {
      b_unpackq( buf_ptr, *buf_pos,
                 (( int_ptr->addr_len - MAX_TMSI_CODE_LEN ) << 3 ), /*lint !e701*/
                 int_ptr->addr.type3.tmsi_zone );
      *buf_pos += ( int_ptr->addr_len - MAX_TMSI_CODE_LEN ) << 3; /*lint !e701*/

      int_ptr->addr.type3.tmsi_code =
        b_unpackd( buf_ptr, *buf_pos, FSIZ( cai_tmsi_type, tmsi_code ));
      *buf_pos += FSIZ( cai_tmsi_type, tmsi_code );
    }
    /* Only TMSI code was sent so use address length */
    /* to unpack variable sized TMSI code.           */
    else
    {
      int_ptr->addr.type3.tmsi_code =
        b_unpackd( buf_ptr, *buf_pos, ( int_ptr->addr_len << 3 ));
      *buf_pos += int_ptr->addr_len << 3;
    }
  }
  else if (int_ptr->addr_type == CAI_BCAST_ADDR_TYPE)    /* 5 */
  {
    for (i=0; (i < int_ptr->addr_len) && (i < CAII_BC_ADDR_MAX); i++)
    {
      int_ptr->addr.type5.bc_addr[i] =
        b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_addr5_type, bc_addr ));
      *buf_pos += FSIZ( cai_addr5_type, bc_addr );
    }
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Unknown ADDR_TYPE -> advance buffer pointer past ADDR_TYPE fields
    ** since we are unable to correctly parse them
    ** ----------------------------------------------------------------- */
    *buf_pos += (8 * int_ptr->addr_len);
  }

} /* end xlate_ext_pc_hdr() */


#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_EXT_EXT_ENC

DESCRIPTION
  This function translates the extended encryption fields and process them.

DEPENDENCIES
  The decryption function is defined in AUTH module.

RETURN VALUE
  CAIX_DONE_S - if everything is good.
  CAIX_INV_MSG_S - if anything wrong.


SIDE EFFECTS
  buf_pos updated. Extended encryption fields are put into the internal format
  just to preserve them. The message may be translated from crypto text into
  plain text.

===========================================================================*/

word xlate_ext_ext_enc
(
  word *len_ptr,
    /* Pointer to Length of message */
  word chn,
    /* Physical Channel this message is received on */
  byte pd,
    /* Protocol discriminator */
  word *buf_pos_ptr,
    /* Position of header fields relative to start of buf_ptr */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_pc_hdr_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  uint8 msg_type,  /* the message type */
  uint8 order,     /* the order type in case of an order message */
  uint8 ordq       /* the order qualification in case of an order message */
)
{
  word status = CAIX_DONE_S;

  #ifdef FEATURE_IS2000_REL_A_AES
  boolean maci_incl = FALSE;
  uint8 sdu_key_id = MCCAES_KEY_ID; /* when MI is not enabled, use 0 */
  #endif /* FEATURE_IS2000_REL_A_AES */

  /* -----------------------------------------------------------------------
  ** If the received channel is FCCCH, then there is Extended Encryption
  ** fields. If received channel is PCH, and if PD is 1, there is Extended
  ** Encryption fields. Otherwise, no extended encryption fields.
  ** ----------------------------------------------------------------------- */
  if ((chn == CAIX_BCCH) || (chn == CAIX_FCCCH) ||
      ((chn == CAIX_PC) && (pd != 0)))
  {
    /* ----------------------------------------------------------------------
    ** Parse the Extended Encryption fields. Notice that Extended Encryption
    ** fields are not useful after this step. But we put it into the internal
    ** format anyway.
    ** ---------------------------------------------------------------------- */
    int_ptr->enc.enc_fields_incl =
      b_unpackb( buf_ptr, *buf_pos_ptr, FSIZ( cai_ext_enc_type, enc_fields_incl ));
    *buf_pos_ptr += FSIZ( cai_ext_enc_type, enc_fields_incl );

    if (int_ptr->enc.enc_fields_incl)
    {
      int_ptr->enc.sdu_encrypt_mode =
        b_unpackb( buf_ptr, *buf_pos_ptr, FSIZ( cai_ext_enc_type, sdu_encrypt_mode ));
      *buf_pos_ptr += FSIZ( cai_ext_enc_type, sdu_encrypt_mode );

      if (((int_ptr->enc.sdu_encrypt_mode == CAI_ENC_MODE_ECMEA)
           || (int_ptr->enc.sdu_encrypt_mode == CAI_ENC_MODE_REA))
#ifdef FEATURE_IS2000_REL_C
          && !int_ptr->msg_int.maci_incl
#endif /* FEATURE_IS2000_REL_C */
         )
      {
        int_ptr->enc.enc_seq =
          b_unpackb( buf_ptr, *buf_pos_ptr, FSIZ( cai_ext_enc_type, enc_seq ));
        *buf_pos_ptr += FSIZ( cai_ext_enc_type, enc_seq );
      }

      #ifdef FEATURE_IS2000_REL_A_AES
      if ( !mccaes_validate_sig_aes_mode(int_ptr->enc.sdu_encrypt_mode) )
      {
        M1X_MSG( DCP, LEGACY_HIGH,
          "Invalid sdu_encrypt_mode %d",
          int_ptr->enc.sdu_encrypt_mode);
        return CAIX_INV_ENC_MODE_NOT_SUP_S;
      }
      else if ( ( int_ptr->enc.sdu_encrypt_mode != CAI_ENC_MODE_DISABLED ) &&
                ( cdma.aes_status.c_sig_encrypt_mode == CAI_ENC_MODE_DISABLED )
              )
      {
        M1X_MSG( DCP, LEGACY_HIGH,
          "AES encryption not turned on yet, the message should have not been encrypted");
        return CAIX_INV_ENC_MODE_NOT_SUP_S;
      }
      else if ( mccaes_supports_sig_aes() &&
                ( cdma.aes_status.c_sig_encrypt_mode != CAI_ENC_MODE_DISABLED ) &&
                ( int_ptr->enc.sdu_encrypt_mode == CAI_ENC_MODE_DISABLED ) &&
                 ( ! ( ( msg_type == CAI_PC_AUTH_MSG ) ||
                       ( msg_type == CAI_AUTH_REQ_MSG ) ||
                       ( msg_type == CAI_CHN_ASN_MSG ) ||
                       ( msg_type == CAI_EXT_CHN_ASN_MSG ) ||

                       ( msg_type == CAI_MEID_EXT_CHN_ASN_MSG ) ||

                       ( msg_type == CAI_SEC_MODE_CMD_MSG) ||
                       ( ( ( msg_type == CAI_PC_ORD_MSG ) && ( order == CAI_REG_ORD ) ) &&
                         ( ( ordq == CAI_REG_REQ ) || ( ordq == CAI_REG_ACC ) )
                       ) ||
                       ( ( msg_type == CAI_PC_ORD_MSG ) && ( order == CAI_BS_REJ_ORD ) )
                     )
                  )
              )
      {
        return CAIX_INV_ENC_MODE_NOT_SUP_S;
      }
      else if ( int_ptr->enc.sdu_encrypt_mode == CAI_ENC_MODE_DISABLED )
      {
        /* do nothing here if the message was not encrypted, just return CAIX_DONE_S */
        return status;
      }
      /* now prepare RX_EXT_SSEQ for decryption purpose */


      /* ----------------------------------------------------------
       ** The message is encrypted, have to decrypt it first. The
       ** decryptor accepts the encryption fields, crypto text, and
       ** its start pointer, returns with plain text, and modified
       ** message length, so the parser can continue.
       ** ---------------------------------------------------------- */

      status = auth_ext_decrypt_cdma(buf_ptr,
                                     *len_ptr,
                                     *buf_pos_ptr,
                                     int_ptr->enc.sdu_encrypt_mode,
                                     int_ptr->ack_req,
                                     int_ptr->enc.enc_seq,
                                     sdu_key_id,
                                     maci_incl
                                    );

      #endif /* FEATURE_IS2000_REL_A_AES */
    } /* enc_fields_incl */

    #ifdef FEATURE_IS2000_REL_A_AES
    else if ( mccaes_supports_sig_aes() &&
              ( cdma.aes_status.c_sig_encrypt_mode != CAI_ENC_MODE_DISABLED ) &&
              ( ! ( ( msg_type == CAI_PC_AUTH_MSG ) ||
                    ( msg_type == CAI_AUTH_REQ_MSG ) ||
                    ( msg_type == CAI_CHN_ASN_MSG ) ||
                    ( msg_type == CAI_EXT_CHN_ASN_MSG ) ||

                    ( msg_type == CAI_MEID_EXT_CHN_ASN_MSG ) ||

                    ( msg_type == CAI_SEC_MODE_CMD_MSG) ||
                    ( ( ( msg_type == CAI_PC_ORD_MSG ) && ( order == CAI_REG_ORD ) ) &&
                      ( ( ordq == CAI_REG_REQ ) || ( ordq == CAI_REG_ACC ) )
                    ) ||
                    ( ( msg_type == CAI_PC_ORD_MSG ) && ( order == CAI_BS_REJ_ORD ) )
                  )
               )
           )
    {
      return MCCAES_AES_NOT_ENCRYPTED;
    }
    #else
    if ( int_ptr->enc.sdu_encrypt_mode != CAI_ENC_MODE_DISABLED )
    {
      return CAIX_INV_ENC_MODE_NOT_SUP_S;
    }
    #endif /* FEATURE_IS2000_REL_A_AES */
  } /* pd != 0 */
  return status;
} /* xlate_ext_ext_enc */
#endif /* FEATURE_IS2000_REL_A*/

/*===========================================================================

FUNCTION XLATE_EXT_PC_ORD

DESCRIPTION
  This function translates a Paging Channel Order Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Order message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_ord
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word order_pos;
    /* Position of order relative to start of buf_ptr */
  byte add_record_len;
    /* Temporary storage for the add_record_len field */
  word num_recs;
    /* Number of orders contained in received Paging Channel Order Msg */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */
  word rec_min_len;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  order_pos = FSIZ(cai_pc_hdr_type, msg_type);

  /* ---------------------------------
  ** Initialize number of records to 0
  ** --------------------------------- */
  num_recs = 0;

  rec_min_len = CAI_PC_ORDER_MIN;

  while ((len > order_pos) && ((len - order_pos) >= rec_min_len))
  {
    xlate_ext_pc_hdr(&order_pos, buf_ptr,
      &int_ptr->pc_ord.ords[num_recs].gen.hdr);

#ifdef FEATURE_IS2000_REL_C
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Message Integrity fields and
    ** MACI field if there is one.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
         CAIX_MACI_REQUIRED, &order_pos,
         buf_ptr, &int_ptr->pc_ord.ords[num_recs].gen.hdr.msg_int,
         int_ptr->pc_ord.msg_type,
         int_ptr->pc_ord.ords[num_recs].gen.hdr.ack_req
         )) != CAIX_DONE_S)
    {
      return status;
    }

    if ((num_recs == 0) &&
        int_ptr->pc_ord.ords[num_recs].gen.hdr.msg_int.maci_incl)
    {
      rec_min_len += FSIZ(cai_msg_int_type,maci);
    }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Extended Encryption fields if
    ** there is one, and run the decryption algorithm.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_ext_enc(&len, chn, pd, &order_pos, buf_ptr,
                                    &int_ptr->pc_ord.ords[num_recs].gen.hdr,
                                    int_ptr->pc_ord.msg_type,
                                    int_ptr->pc_ord.ords[num_recs].gen.order,
                                    int_ptr->pc_ord.ords[num_recs].ordq.ordq
                                   )
        ) != CAIX_DONE_S
       )
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_A */

    int_ptr->pc_ord.ords[num_recs].gen.order =
      b_unpackb(buf_ptr, order_pos, FSIZ(cai_pc_gen_ord_type, order));
    order_pos += FSIZ( cai_pc_gen_ord_type, order );

    add_record_len = b_unpackb(buf_ptr, order_pos,
      FSIZ(cai_pc_gen_ord_type, add_record_len));
    order_pos += FSIZ(cai_pc_gen_ord_type, add_record_len);

    if ((order_pos + (add_record_len * 8)) > len)
    {
      /* ---------------------------------------------------
      ** ADD_RECORD_LEN field indicates that message exceeds
      ** received length -- stop parsing message
      ** --------------------------------------------------- */
      break;
    }

    /* ------------------------------
    ** Fill in order dependent fields
    ** ------------------------------ */
    switch (int_ptr->pc_ord.ords[num_recs].gen.order)
    {
      case CAI_ABBR_ALERT_ORD:
      case CAI_REORDER_ORD:
      case CAI_AUDIT_ORD:
      case CAI_INTERCEPT_ORD:
      case CAI_BS_ACK_ORD:
      case CAI_SLOTTED_MODE_ORD:
#ifdef FEATURE_IS2000_REL_C
      case CAI_TRANSIT_TO_IDLE_ORD:
#endif /* FEATURE_IS2000_REL_C */
        /* --------------------------------------------
        ** No order qualifier implicitly means ordq = 0
        ** (see PN-3118 Section 7.7.4)
        ** -------------------------------------------- */
        int_ptr->pc_ord.ords[num_recs].ordq.ordq = 0;

        /* -----------------------------------------
        ** Account for possible additional fields in
        ** future revs of the spec
        ** ----------------------------------------- */
        order_pos += (add_record_len * 8);
        num_recs++;
        break;

      case CAI_BS_CHAL_CONF_ORD:
        /* -----------------------------------------
        ** Base Station Challenge Confirmation Order
        ** ----------------------------------------- */
        if (add_record_len >= 4)
        {
          int_ptr->pc_ord.ords[num_recs].chal.ordq = b_unpackb(buf_ptr,
            order_pos, FSIZ(cai_pc_bs_chal_type, ordq));
          order_pos += FSIZ(cai_pc_bs_chal_type, ordq);

          int_ptr->pc_ord.ords[num_recs].chal.authbs = b_unpackd(buf_ptr,
            order_pos, FSIZ(cai_pc_bs_chal_type, authbs));
          order_pos += FSIZ(cai_pc_bs_chal_type, authbs) +
            FSIZ(cai_pc_bs_chal_type, reserved);

          if (add_record_len > 4)
          {
            /* -----------------------------------------
            ** Account for possible additional fields in
            ** future revs of the spec
            ** ----------------------------------------- */
            order_pos += ((add_record_len - 4) * 8);
          }
          num_recs++;
        }
        else
        {
          /* ----------------------------------------------------
          ** Invalid order length - something is very wrong here.
          ** Pretend like we didn't see it and let BS retransmit.
          ** ---------------------------------------------------- */
          order_pos += (add_record_len * 8);
        }
        break;

      case CAI_RETRY_ORD:
        int_ptr->pc_ord.ords[num_recs].retry.ordq = b_unpackb(buf_ptr,
          order_pos, FSIZ(cai_pc_retry_type, ordq));
        order_pos += FSIZ(cai_pc_retry_type, ordq);

        int_ptr->pc_ord.ords[num_recs].retry.retry_type = b_unpackb(buf_ptr,
          order_pos, FSIZ(cai_pc_retry_type, retry_type));
        order_pos += FSIZ(cai_pc_retry_type, retry_type);
        if (int_ptr->pc_ord.ords[num_recs].retry.retry_type)
        {
          int_ptr->pc_ord.ords[num_recs].retry.retry_delay =
            b_unpackb(buf_ptr, order_pos, FSIZ(cai_pc_retry_type, retry_delay));
          order_pos += FSIZ(cai_pc_retry_type, retry_delay);
        }
        order_pos += FSIZ(cai_pc_retry_type, reserved);
        num_recs++;
        break;

      case CAI_LOCK_OR_MAINT_ORD:
        /* -------------------------------------------
        ** Type which only requires an order qualifier
        ** ------------------------------------------- */
        if (add_record_len >= 1)
        {
          /* ---------------------
          ** Parse order qualifier
          ** --------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq = b_unpackb(buf_ptr,
            order_pos, FSIZ(cai_pc_ordq_type, ordq));

          /* -----------------------------------------
          ** Account for possible additional fields in
          ** future revs of the spec
          ** ----------------------------------------- */
          order_pos += (add_record_len * 8);
          num_recs++;
        }
        else
        {
          /* ----------------------------------------------------
          ** Invalid order length - something is very wrong here.
          ** Pretend like we didn't see it and let BS retransmit.
          ** ---------------------------------------------------- */
          order_pos += (add_record_len * 8);
        }
        break;

      case CAI_REG_ORD:
        if (add_record_len >= 1)
        {
          /* ---------------------
          ** Parse order qualifier
          ** --------------------- */

          msg_pos = order_pos;

          int_ptr->pc_ord.ords[num_recs].ordq.ordq =
            b_unpackb(buf_ptr, msg_pos, FSIZ( cai_pc_ordq_type, ordq));
          msg_pos += FSIZ(cai_pc_ordq_type, ordq);

          /* --------------------------------------------
          ** Registration Accepted Order, ROAM_INDI included
          ** -------------------------------------------- */
          if (int_ptr->pc_ord.ords[num_recs].ordq.ordq == CAI_REG_ACC)
          {
            int_ptr->pc_ord.ords[num_recs].regacc.roam_indi =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, roam_indi));
            msg_pos += FSIZ(cai_pc_reg_acc_type, roam_indi);
          }
#ifdef FEATURE_IS2000_REL_A
          else if (int_ptr->pc_ord.ords[num_recs].ordq.ordq ==
                   CAI_REG_ACC_ROAM_ENC)
          {
            int_ptr->pc_ord.ords[num_recs].regacc.roam_indi =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, roam_indi));
            msg_pos += FSIZ(cai_pc_reg_acc_type, roam_indi);

            int_ptr->pc_ord.ords[num_recs].regacc.c_sig_encrypt_mode =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ( cai_pc_reg_acc_type, c_sig_encrypt_mode));
            msg_pos += FSIZ(cai_pc_reg_acc_type, c_sig_encrypt_mode);

            if ((int_ptr->pc_ord.ords[num_recs].regacc.c_sig_encrypt_mode == CAI_ENC_MODE_ECMEA) ||
                (int_ptr->pc_ord.ords[num_recs].regacc.c_sig_encrypt_mode == CAI_ENC_MODE_REA))
            {
              int_ptr->pc_ord.ords[num_recs].regacc.key_size =
                b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, key_size));
              msg_pos += FSIZ(cai_pc_reg_acc_type, key_size);
            }

#ifdef FEATURE_IS2000_REL_C
            /* ----------------------------------------------------------------
            ** Parse Release C fields if the length indicates there are more
            ** fields.  We could be parsing reserved bits, but that will have the
            ** result of setting msg_int_info_incl to 0, which is okay.
            ** ---------------------------------------------------------------- */
            if ((order_pos + (add_record_len * 8)) > msg_pos)
            {
              int_ptr->pc_ord.ords[num_recs].regacc.msg_int_info_incl =
                b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, msg_int_info_incl));
              msg_pos += FSIZ(cai_pc_reg_acc_type, msg_int_info_incl);

              if (int_ptr->pc_ord.ords[num_recs].regacc.msg_int_info_incl)
              {
                int_ptr->pc_ord.ords[num_recs].regacc.change_keys =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, change_keys));
                msg_pos += FSIZ(cai_pc_reg_acc_type, change_keys);

                int_ptr->pc_ord.ords[num_recs].regacc.use_uak =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, use_uak));
                msg_pos += FSIZ(cai_pc_reg_acc_type, use_uak);
              }
            }
#endif /* FEATURE_IS2000_REL_C */

          }
#endif /* FEATURE_IS2000_REL_A */

        }
        else /* (add_record_len == 0) */
        {
          /* --------------------------------------------
          ** No order qualifier implicitly means ordq = 0
          ** (see PN-3118 Section 7.7.4)
          ** -------------------------------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq = 0;
        }

        /* -----------------------------------------
        ** Account for possible additional fields in
        ** future revs of the spec
        ** ----------------------------------------- */
        order_pos += (add_record_len * 8);
        num_recs++;
        break;

      case CAI_RELEASE_ORD:
      case CAI_LOCAL_CTL_ORD:
        if (add_record_len >= 1)
        {
          /* ---------------------
          ** Parse order qualifier
          ** --------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq =
            b_unpackb(buf_ptr, order_pos, FSIZ(cai_pc_ordq_type, ordq));

        }
        else /* (add_record_len == 0) */
        {
          /* --------------------------------------------
          ** No order qualifier implicitly means ordq = 0
          ** (see PN-3118 Section 7.7.4)
          ** -------------------------------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq = 0;
        }

        /* -----------------------------------------
        ** Account for possible additional fields in
        ** future revs of the spec
        ** ----------------------------------------- */
        order_pos += (add_record_len * 8);
        num_recs++;
        break;

#ifdef FEATURE_IS2000_REL_A
      case CAI_BS_REJ_ORD:
        if (add_record_len >= 1)
        {
          /* ---------------------
          ** Parse order qualifier
          ** --------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq =
            b_unpackb(buf_ptr, order_pos, FSIZ(cai_pc_ordq_type, ordq));

#ifdef FEATURE_IS2000_REL_C
          if (int_ptr->pc_ord.ords[num_recs].ordq.ordq ==
              CAI_BS_REJ_ORDER_MSG_NOT_ACCEPTED)
          {
            msg_pos = order_pos;

            /* Increment position for this record only */
            msg_pos += FSIZ(cai_pc_ordq_type, ordq);

            int_ptr->pc_ord.ords[num_recs].bsrej.reject_reason =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_bs_rej_type, reject_reason));
            msg_pos += FSIZ(cai_bs_rej_type, reject_reason);

            int_ptr->pc_ord.ords[num_recs].bsrej.rejected_msg_type =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_bs_rej_type, rejected_msg_type));
            msg_pos += FSIZ(cai_bs_rej_type, rejected_msg_type);

            int_ptr->pc_ord.ords[num_recs].bsrej.rejected_msg_seq =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_bs_rej_type, rejected_msg_seq));
            msg_pos += FSIZ(cai_bs_rej_type, rejected_msg_seq);
          }
#endif /* FEATURE_IS2000_REL_C */
        }
        else /* (add_record_len == 0) */
        {
          /* --------------------------------------------
          ** No order qualifier implicitly means ordq = 0
          ** (see PN-3118 Section 7.7.4)
          ** -------------------------------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq = 0;
        }

        /* -----------------------------------------
        ** Account for possible additional fields in
        ** future revs of the spec
        ** ----------------------------------------- */
        order_pos += (add_record_len * 8);
        num_recs++;
        break;
#endif /* FEATURE_IS2000_REL_A */

      default:

        /* ----------------------------
        ** Unknown Paging Channel Order
        ** ---------------------------- */
        order_pos += (add_record_len * 8);
        num_recs++;

        break;

    } /* end switch */

    int_ptr->pc_ord.num_ords = num_recs;

  } /* end while */


  return (status);

} /* xlate_ext_pc_ord */

/*===========================================================================

FUNCTION XLATE_EXT_CHN_ASN

DESCRIPTION
  This function translates a Paging Channel Channel Assignment Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Channel Assignment message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_chn_asn
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of channel assignment order relative to start of buf_ptr */
  byte add_record_len;
    /* Temporary storage for the add_record_len field */
  word num_recs;
    /* Number of variable parts of message */
  word i;
    /* Index through parameters */
  word old_ext_msg_pos;
    /* For caculating # of reserved bits in a single chn asn record */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  /* Force tunneled msg parsing only if we are not in CGI Req processing
   * for CSFB case */
  if( (csfb_cdma.cgi_req_proc_state == CSFB_CGI_REQ_NONE) &&
      (cdma.entry_ptr != NULL) &&
      (cdma.entry_ptr->entry == MCC_CSFB)
    )
  {
    /* Incase of CSFB mode , msg_type is given in the GCSNA header
     * What we are passing here is only the layer3 part of the msg.
     * Hence set ext_msg_pos will be set to 0
     */
    ext_msg_pos = 0;
  }
  else
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
  {
    ext_msg_pos = FSIZ( cai_pc_hdr_type, msg_type );
  }

  /* ---------------------------------
  ** Initialize number of records to 0
  ** --------------------------------- */
  num_recs = 0;

  while ((len > ext_msg_pos) && ((len - ext_msg_pos) >= CAI_CHN_ASN_REC_MIN))
  {
    #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
    /* Decode the PC header only for non-CSFB cases. For CSFB cases, it is covered
     * by TLAC header.
     */
    if( (cdma.entry_ptr != NULL) &&
        (cdma.entry_ptr->entry != MCC_CSFB)
      )
    #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
    {
      xlate_ext_pc_hdr(&ext_msg_pos, buf_ptr,
        &int_ptr->chnasn.chns[num_recs].gen.hdr );
    }

    #ifdef FEATURE_IS2000_REL_A
    #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
    /* Encryption is only applicable for non-CSFB cases.
     */
    if( (cdma.entry_ptr != NULL) &&
        (cdma.entry_ptr->entry != MCC_CSFB)
      )
    #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
    {
      /* ------------------------------------------------------------------
      ** Now we have to take a look at the Extended Encryption fields if
      ** there is one, and run the decryption algorithm.
      ** ------------------------------------------------------------------ */
      if ((status = xlate_ext_ext_enc(&len, chn, pd, &ext_msg_pos, buf_ptr,
           &int_ptr->chnasn.chns[num_recs].gen.hdr, int_ptr->chnasn.msg_type, 0, 0)) != CAIX_DONE_S)
      {
        return status;
      }
    }
    #endif /* FEATURE_IS2000_REL_A */

    /* ----------------------
    ** Unpack base of message
    ** ---------------------- */
    #define MTYPE cai_chnasn_base_type

    UNPACKB_PG(chnasn.chns[num_recs].gen.assign_mode,
      MTYPE, assign_mode);

    add_record_len = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(MTYPE, add_record_len));
    ext_msg_pos += FSIZ(cai_chnasn_base_type, add_record_len);
    if (add_record_len == 0)
    {
      M1X_MSG( DCP, LEGACY_HIGH,
              "Invalid CAM.. record len for assign mode %d is 0", 
               int_ptr->chnasn.chns[num_recs].gen.assign_mode );    
      return CAIX_INV_MSG_S;
    }
    old_ext_msg_pos = ext_msg_pos;

    #undef MTYPE

    /* -------------------------
    ** Switch on Assignment Mode
    ** ------------------------- */
    switch (int_ptr->chnasn.chns[num_recs].gen.assign_mode)
    {
      case CAI_TRAFFIC_CHAN_ASSIGN:

        #define VTYPE cai_chnasn_am0_type

        UNPACKB_PG(chnasn.chns[num_recs].am0.freq_incl, VTYPE, freq_incl);
        UNPACKB_PG(chnasn.chns[num_recs].am0.code_chan, VTYPE, code_chan);

        if (int_ptr->chnasn.chns[num_recs].am0.freq_incl)
        {
          UNPACKW_PG(chnasn.chns[num_recs].am0.cdma_freq, VTYPE, cdma_freq);
        }

        UNPACKB_PG(chnasn.chns[num_recs].am0.frame_offset, VTYPE, frame_offset);
        UNPACKB_PG(chnasn.chns[num_recs].am0.encrypt_mode, VTYPE, encrypt_mode);

#ifdef FEATURE_IS2000_REL_A
        if ((ext_msg_pos - old_ext_msg_pos) < (add_record_len * 8))
        {
          if (int_ptr->chnasn.chns[num_recs].am0.encrypt_mode ==
              CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
          {
            UNPACKB_PG(chnasn.chns[num_recs].am0.d_sig_encrypt_mode,
              VTYPE, d_sig_encrypt_mode);
          }

          if ((int_ptr->chnasn.chns[num_recs].am0.encrypt_mode ==
               CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG)||
              (int_ptr->chnasn.chns[num_recs].am0.encrypt_mode ==
               CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
          {
            UNPACKB_PG(chnasn.chns[num_recs].am0.enc_key_size,
              VTYPE, enc_key_size);
          }

          UNPACKB_PG(chnasn.chns[num_recs].am0.c_sig_encrypt_mode_incl,
            VTYPE, c_sig_encrypt_mode_incl);

          if (int_ptr->chnasn.chns[num_recs].am0.c_sig_encrypt_mode_incl)
          {
            UNPACKB_PG(chnasn.chns[num_recs].am0.c_sig_encrypt_mode,
              VTYPE, c_sig_encrypt_mode);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      case CAI_PAGING_CHAN_ASSIGN:

        #define VTYPE cai_chnasn_am1_type

        UNPACKB_PG(chnasn.chns[num_recs].am1.respond, VTYPE, respond);
        UNPACKB_PG(chnasn.chns[num_recs].am1.freq_incl, VTYPE, freq_incl);

        if (int_ptr->chnasn.chns[num_recs].am1.freq_incl)
        {
          UNPACKW_PG(chnasn.chns[num_recs].am1.cdma_freq, VTYPE, cdma_freq);
          if ( (int)( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, freq_incl ) - FSIZ( VTYPE, cdma_freq ) ) < 0)
          {
            M1X_MSG( DCP, LEGACY_HIGH,
              "Invalid CAM..incorrect record len %d for assign mode %d",
              add_record_len, int_ptr->chnasn.chns[num_recs].gen.assign_mode );
            return CAIX_INV_MSG_S;          
          }

          int_ptr->chnasn.chns[num_recs].am1.num_pilots =
            ( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, freq_incl ) - FSIZ( VTYPE, cdma_freq )
            ) / FSIZ( VTYPE, pilot_pn );
        }
        else
        {
          if ( (int)( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, freq_incl ) ) < 0)
          {
            M1X_MSG( DCP, LEGACY_HIGH,
              "Invalid CAM..incorrect record len %d for assign mode %d",
              add_record_len, int_ptr->chnasn.chns[num_recs].gen.assign_mode );
            return CAIX_INV_MSG_S;          
          }        
          int_ptr->chnasn.chns[num_recs].am1.num_pilots =
            ( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, freq_incl )
            ) / FSIZ( VTYPE, pilot_pn);
        }

        for (i=0; i < int_ptr->chnasn.chns[num_recs].am1.num_pilots; i++)
        {
          UNPACKW_PG(chnasn.chns[num_recs].am1.pilot_pn[i], VTYPE,
            pilot_pn);
        }

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      case CAI_ACQ_ANALOG_SYSTEM:

        #define VTYPE cai_chnasn_am2_type

        UNPACKB_PG(chnasn.chns[num_recs].am2.respond, VTYPE, respond);
        UNPACKB_PG(chnasn.chns[num_recs].am2.analog_sys, VTYPE, analog_sys);
        UNPACKB_PG(chnasn.chns[num_recs].am2.use_analog_sys, VTYPE,
          use_analog_sys);
        UNPACKB_PG(chnasn.chns[num_recs].am2.band_class, VTYPE, band_class);

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      case CAI_ANALOG_VCHAN_ASSIGN:

        #define VTYPE cai_chnasn_am3_type

        UNPACKW_PG(chnasn.chns[num_recs].am3.sid, VTYPE, sid);
        UNPACKB_PG(chnasn.chns[num_recs].am3.vmac, VTYPE, vmac);
        UNPACKW_PG(chnasn.chns[num_recs].am3.analog_chan, VTYPE, analog_chan);
        UNPACKB_PG(chnasn.chns[num_recs].am3.scc, VTYPE, scc);
        UNPACKB_PG(chnasn.chns[num_recs].am3.mem, VTYPE, mem);
        UNPACKB_PG(chnasn.chns[num_recs].am3.an_chan_type, VTYPE, an_chan_type);
        UNPACKB_PG(chnasn.chns[num_recs].am3.dscc_msb, VTYPE, dscc_msb);
        UNPACKB_PG(chnasn.chns[num_recs].am3.band_class, VTYPE, band_class);

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      case CAI_EXT_TRAF_CHAN_ASSIGN:

        #define VTYPE cai_chnasn_am4_type

        UNPACKB_PG(chnasn.chns[num_recs].am4.freq_incl, VTYPE, freq_incl);

        ext_msg_pos += FSIZ(VTYPE, reserved);

        UNPACKB_PG(chnasn.chns[num_recs].am4.bypass_alert_answer, VTYPE,
          bypass_alert_answer);
        UNPACKB_PG(chnasn.chns[num_recs].am4.default_config, VTYPE,
          default_config);
        UNPACKB_PG(chnasn.chns[num_recs].am4.grant_mode, VTYPE, grant_mode);
        UNPACKB_PG(chnasn.chns[num_recs].am4.code_chan, VTYPE, code_chan);
        UNPACKB_PG(chnasn.chns[num_recs].am4.frame_offset, VTYPE, frame_offset);
        UNPACKB_PG(chnasn.chns[num_recs].am4.encrypt_mode, VTYPE, encrypt_mode);

        if (int_ptr->chnasn.chns[num_recs].am4.freq_incl)
        {
          UNPACKB_PG(chnasn.chns[num_recs].am4.band_class, VTYPE, band_class);
          UNPACKW_PG(chnasn.chns[num_recs].am4.cdma_freq, VTYPE, cdma_freq);
        }

#ifdef FEATURE_IS2000_REL_A
        if ((ext_msg_pos - old_ext_msg_pos) < (add_record_len * 8))
        {
          if (int_ptr->chnasn.chns[num_recs].am4.encrypt_mode ==
              CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
          {
            UNPACKB_PG(chnasn.chns[num_recs].am4.d_sig_encrypt_mode,
              VTYPE, d_sig_encrypt_mode);
          }

          if ((int_ptr->chnasn.chns[num_recs].am4.encrypt_mode ==
               CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG)||
              (int_ptr->chnasn.chns[num_recs].am4.encrypt_mode ==
               CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
          {
            UNPACKB_PG(chnasn.chns[num_recs].am4.enc_key_size,
              VTYPE, enc_key_size);
          }

          UNPACKB_PG(chnasn.chns[num_recs].am4.c_sig_encrypt_mode_incl,
            VTYPE, c_sig_encrypt_mode_incl);

          if (int_ptr->chnasn.chns[num_recs].am4.c_sig_encrypt_mode_incl)
          {
            UNPACKB_PG(chnasn.chns[num_recs].am4.c_sig_encrypt_mode,
              VTYPE, c_sig_encrypt_mode);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      case CAI_EXT_PAGING_CHAN_ASSIGN:

        #define VTYPE cai_chnasn_am5_type

        UNPACKB_PG(chnasn.chns[num_recs].am5.respond, VTYPE, respond);
        UNPACKB_PG(chnasn.chns[num_recs].am5.freq_incl, VTYPE, freq_incl);

        if (int_ptr->chnasn.chns[num_recs].am5.freq_incl)
        {
          UNPACKB_PG(chnasn.chns[num_recs].am5.band, VTYPE, band_class);
          UNPACKW_PG(chnasn.chns[num_recs].am5.cdma_freq, VTYPE, cdma_freq);

          if ( (int)( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, band_class ) - FSIZ( VTYPE, freq_incl ) -
              FSIZ( VTYPE, cdma_freq ) ) < 0)
          {
            M1X_MSG( DCP, LEGACY_HIGH,
              "Invalid CAM..incorrect record len %d for assign mode %d",
              add_record_len, int_ptr->chnasn.chns[num_recs].gen.assign_mode );
            return CAIX_INV_MSG_S;          
          }
          int_ptr->chnasn.chns[num_recs].am5.num_pilots =
            ( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, band_class ) - FSIZ( VTYPE, freq_incl ) -
              FSIZ( VTYPE, cdma_freq )
            ) / FSIZ( VTYPE, pilot_pn );
        }
        else
        {
          if ( (int)( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, freq_incl ) ) < 0)
          {
            M1X_MSG( DCP, LEGACY_HIGH,
              "Invalid CAM..incorrect record len %d for assign mode %d",
              add_record_len, int_ptr->chnasn.chns[num_recs].gen.assign_mode );

            return CAIX_INV_MSG_S;          
          }        
          int_ptr->chnasn.chns[num_recs].am5.num_pilots =
            ( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, freq_incl )
            ) / FSIZ( VTYPE, pilot_pn );
        }

        for (i=0; i < int_ptr->chnasn.chns[num_recs].am5.num_pilots; i++)
        {
          UNPACKW_PG(chnasn.chns[num_recs].am5.pilot_pn[i], VTYPE, pilot_pn);
        }

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      default:
        M1X_MSG( DCP, LEGACY_MED,
          "Unknown ASSIGN_MODE %d",
          int_ptr->chnasn.chns[num_recs].gen.assign_mode );
        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;
    } /* end of switch */

    num_recs++;

  } /* end while */

  int_ptr->chnasn.num_chns = num_recs;

  return (status);

} /* xlate_ext_chn_asn */

/*===========================================================================

FUNCTION XLATE_EXT_PC_TMSI

DESCRIPTION
  This function translates a Paging Channel TMSI Assignment Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the TMSI Assignment message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_tmsi
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->pc_tmsi.hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
       CAIX_MACI_REQUIRED, &msg_pos,
       buf_ptr, &int_ptr->pc_tmsi.hdr.msg_int,
       int_ptr->pc_tmsi.msg_type,
       int_ptr->pc_tmsi.hdr.ack_req
         )) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
       &int_ptr->pc_tmsi.hdr, int_ptr->pc_tmsi.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define FTYPE cai_pc_tmsi_asgn_type

  msg_pos += FSIZ(FTYPE, reserved1);

  int_ptr->pc_tmsi.data.zone_len  = b_unpackb(buf_ptr, msg_pos,
    FSIZ(FTYPE, tmsi_zone_len));
  msg_pos += FSIZ(FTYPE, tmsi_zone_len);

  qw_set(int_ptr->pc_tmsi.data.info.tmsi_zone, 0L, 0L);
  b_unpackq(buf_ptr, msg_pos, (int_ptr->pc_tmsi.data.zone_len << 3),
    int_ptr->pc_tmsi.data.info.tmsi_zone);
  msg_pos += (int_ptr->pc_tmsi.data.zone_len << 3);

  int_ptr->pc_tmsi.data.info.tmsi_code = b_unpackd(buf_ptr, msg_pos,
    FSIZ(FTYPE, tmsi_code));
  msg_pos += FSIZ(FTYPE, tmsi_code);

  int_ptr->pc_tmsi.data.exp_time = b_unpackd(buf_ptr, msg_pos,
    FSIZ(FTYPE, tmsi_exp_time));
  msg_pos += FSIZ(FTYPE, tmsi_exp_time);

  #undef FTYPE

  return (status);

} /* xlate_ext_pc_tmsi */

/*===========================================================================

FUNCTION XLATE_EXT_PC_BURST

DESCRIPTION
  This function translates a Paging Channel Data Burst Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Data Burst message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_burst
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through characters */
  word msg_pos = 0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X_TUNNELED_SMS
  if( (cdma.entry_ptr != NULL) &&
      (cdma.entry_ptr->entry != MCC_CSFB)
    )
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X_TUNNELED_SMS */
  {

    msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

    xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->pc_burst.hdr);

#ifdef FEATURE_IS2000_REL_C
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Message Integrity fields and
    ** MACI field if there is one. Also validate MACI.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
         CAIX_MACI_REQUIRED, &msg_pos,
         buf_ptr, &int_ptr->pc_burst.hdr.msg_int, int_ptr->pc_burst.msg_type,
         int_ptr->pc_burst.hdr.ack_req
           ))
        != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Extended Encryption fields if
    ** there is one, and run the decryption algorithm.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
         &int_ptr->pc_burst.hdr, int_ptr->pc_burst.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_A */
  }

  #define FTYPE cai_burst_pc_fix_type

  int_ptr->pc_burst.msg_number =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, msg_number));
  msg_pos += FSIZ(FTYPE, msg_number );

  int_ptr->pc_burst.burst_type =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, burst_type));
  msg_pos += FSIZ(FTYPE, burst_type );

  int_ptr->pc_burst.num_msgs  =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, num_msgs));
  msg_pos += FSIZ(FTYPE, num_msgs);

  int_ptr->pc_burst.num_fields  =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, num_fields));
  msg_pos += FSIZ(FTYPE, num_fields );

  #ifndef FEATURE_IS2000_REL_A
  if( int_ptr->pc_burst.num_fields <= CAI_PC_BURST_MAX )
  #endif /* FEATURE_IS2000_REL_A */
  {
    #undef FTYPE

    for (i=0; i<int_ptr->pc_burst.num_fields; i++)
    {
      #define VTYPE cai_burst_pc_var_type

      int_ptr->pc_burst.chari[i] =
        b_unpackb(buf_ptr, msg_pos, FSIZ(VTYPE, chari));
      msg_pos += FSIZ(VTYPE, chari);

      #undef VTYPE
    }
  }
  #ifndef FEATURE_IS2000_REL_A
  else
  {
    M1X_MSG( DCP, LEGACY_ERROR,
      "Unexpected number of characters:%d > CAI_PC_BURST_MAX",
      int_ptr->pc_burst.num_fields);
    status = CAIX_INV_LEN_S;
  }
  #endif /* FEATURE_IS2000_REL_A */

  return (status);

} /* xlate_ext_pc_burst */

/*===========================================================================

FUNCTION XLATE_EXT_PC_AUTH

DESCRIPTION
  This function translates a Paging Channel Authentication Challenge Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Authentication Challenge message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_auth
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  if( (cdma.entry_ptr != NULL) &&
      (cdma.entry_ptr->entry != MCC_CSFB)
    )
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
  {
    ext_msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

    xlate_ext_pc_hdr(&ext_msg_pos, buf_ptr, &int_ptr->pc_auth.hdr);

    #ifdef FEATURE_IS2000_REL_C
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Message Integrity fields and
    ** MACI field if there is one.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
         CAIX_MACI_NOT_REQUIRED, &ext_msg_pos,
         buf_ptr, &int_ptr->pc_auth.hdr.msg_int, int_ptr->pc_auth.msg_type,
         int_ptr->pc_auth.hdr.ack_req
       ))
       != CAIX_DONE_S)
    {
      return status;
    }
    #endif /* FEATURE_IS2000_REL_C */

    #ifdef FEATURE_IS2000_REL_A
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Extended Encryption fields if
    ** there is one, and run the decryption algorithm.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_ext_enc(&len, chn, pd, &ext_msg_pos, buf_ptr,
         &int_ptr->pc_auth.hdr, int_ptr->pc_auth.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
    #endif /* FEATURE_IS2000_REL_A */
  }

  #define MTYPE cai_pc_auth_ch_type

  UNPACKD_PG(pc_auth.randu, MTYPE, randu);

  #undef MTYPE

  return (status);

} /* xlate_ext_pc_auth */

/*===========================================================================

FUNCTION XLATE_EXT_PC_SSD

DESCRIPTION
  This function translates a Paging Channel SSD Update Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the SSD Update message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None.

===========================================================================*/

word xlate_ext_pc_ssd
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  /* Force tunneled msg parsing only if we are not in CGI Req processing
   * for CSFB case */
  if( (csfb_cdma.cgi_req_proc_state == CSFB_CGI_REQ_NONE) &&
      (cdma.entry_ptr != NULL) &&
      (cdma.entry_ptr->entry == MCC_CSFB)
    )
  {
    /* While we are in CSFB mode, we dont expect MI and encryption to be
     * tunneled, hence skip the parsing for these. */
    msg_pos = 0;
  }
  else
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
  {
    msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

    xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->pc_ssd.hdr);

    #ifdef FEATURE_IS2000_REL_C
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Message Integrity fields and
    ** MACI field if there is one.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
         CAIX_MACI_REQUIRED, &msg_pos,
         buf_ptr, &int_ptr->pc_ssd.hdr.msg_int, int_ptr->pc_ssd.msg_type,
         int_ptr->pc_ssd.hdr.ack_req
        ))
        != CAIX_DONE_S)
    {
      return status;
    }
    #endif /* FEATURE_IS2000_REL_C */

    #ifdef FEATURE_IS2000_REL_A
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Extended Encryption fields if
    ** there is one, and run the decryption algorithm.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
         &int_ptr->pc_ssd.hdr, int_ptr->pc_ssd.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
    #endif /* FEATURE_IS2000_REL_A */
  } /* end of cdma.entry_ptr->entry == MCC_CSFB */

  #undef FTYPE
  #define FTYPE cai_pc_ssd_type

  b_unpackq(buf_ptr, msg_pos, FSIZ(FTYPE, randssd), int_ptr->pc_ssd.randssd);
  msg_pos += FSIZ(FTYPE, randssd);

  #undef FTYPE

  return (status);

} /* xlate_ext_pc_ssd */

/*===========================================================================

FUNCTION XLATE_EXT_PC_FEATURE

DESCRIPTION
  This function translates a Feature Notification Message from external
  to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Feature Notification message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_feature
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  byte i;
    /* Index */
  word msg_pos;
    /* Position of record in message */
  byte *msg_ptr;
    /* Pointer to position inside internal message type */
  byte rec_type;
    /* Temporary storage for record type */
  word rec_len;
    /* Temporary storage for record length */
  word min_rec_len;
    /* Minimum record length */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->pc_feat.hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
       CAIX_MACI_REQUIRED, &msg_pos,
       buf_ptr, &int_ptr->pc_feat.hdr.msg_int, int_ptr->pc_feat.msg_type,
       int_ptr->pc_feat.hdr.ack_req
       )) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
       &int_ptr->pc_feat.hdr, int_ptr->pc_feat.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define FTYPE cai_pc_feature_type

  int_ptr->pc_feat.release = b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, release));
  msg_pos += FSIZ(FTYPE, release);

  #undef FTYPE

  /* ---------------------------------
  ** Initialize number of records to 0
  ** --------------------------------- */
  int_ptr->pc_feat.num_recs = 0;

  msg_ptr = (byte*)(&int_ptr->pc_feat.recs[0]);

  min_rec_len = sizeof(cai_rec_hdr_type);

#ifdef FEATURE_IS2000_REL_C
  if (int_ptr->pc_feat.hdr.msg_int.maci_incl)
  {
    min_rec_len += FSIZ(cai_msg_int_type, maci);
  }
#endif /* FEATURE_IS2000_REL_C */

  while ((len > msg_pos) && ((len- msg_pos) >= min_rec_len))
  {
    word start_msg_pos;

    /* ------------------------------
    ** Unpack message type and length
    ** ------------------------------ */
    ((caii_rec_hdr_type *) msg_ptr)->record_type = rec_type =
      b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rec_hdr_type, record_type));
    msg_pos += FSIZ(cai_rec_hdr_type, record_type);

    /* -------------------------
    ** Get record length in bits
    ** ------------------------- */
    rec_len = b_unpackb(buf_ptr, msg_pos,
      FSIZ(cai_rec_hdr_type, record_len)) * 8;
    msg_pos += FSIZ(cai_rec_hdr_type, record_len);

    start_msg_pos = msg_pos;

    if ((rec_len + msg_pos) > len)
    {
      /* ---------------------------------------------------
      ** RECORD_LEN field indicates that record size exceeds
      ** received length -- stop parsing message
      ** --------------------------------------------------- */
      break;
    }
    else
    {
      /* --------------------------------------
      ** Attempt to parse information record(s)
      ** -------------------------------------- */
      switch (rec_type)
      {
        case CAI_DISPLAY_REC:
          /* --------------------------
          ** Display Information Record
          ** -------------------------- */

          #define RTYPE caii_display_rec_type
          #define VTYPE cai_display_rec_var_type

            ((RTYPE *) msg_ptr)->fix.num_char = (byte) (rec_len / sizeof(VTYPE));

            for (i=0; i < ((RTYPE *) msg_ptr)->fix.num_char; i++)
            {
              ((RTYPE *) msg_ptr)->var[i] =
                b_unpackb(buf_ptr, start_msg_pos, FSIZ(VTYPE, chari));
              start_msg_pos += FSIZ(VTYPE, chari);
            }

            /* -------------------------------------------------
            ** Increment internal message pointer to next record
            ** ------------------------------------------------- */
            msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_char - 1]);

            msg_pos += rec_len;

            int_ptr->pc_feat.num_recs++;

            #undef VTYPE
            #undef RTYPE

            break;

        case CAI_CALLED_REC:
          /* --------------------------------------
          ** Called Party Number Information Record
          ** -------------------------------------- */

          #define RTYPE caii_called_rec_type
          #define FTYPE cai_called_fix_type
          #define VTYPE cai_called_var_type

          ((RTYPE *) msg_ptr)->fix.number_type =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, number_type));
          start_msg_pos += FSIZ(FTYPE, number_type);

          ((RTYPE *) msg_ptr)->fix.number_plan =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, number_plan));
          start_msg_pos += FSIZ(FTYPE, number_plan);

          ((RTYPE *) msg_ptr)->fix.num_char =
            (byte) ((rec_len - sizeof(FTYPE)) / sizeof(VTYPE));

          for (i=0; i < ((RTYPE *) msg_ptr)->fix.num_char; i++) {
            ((RTYPE *) msg_ptr)->var[i] =
              b_unpackb(buf_ptr, start_msg_pos, FSIZ(VTYPE, chari));
            start_msg_pos += FSIZ(VTYPE, chari);
          }

          /* ----------------------------------------------------------
          ** Increment internal message pointer to point to next record
          ** ---------------------------------------------------------- */
          msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_char - 1] );

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;

          #undef VTYPE
          #undef FTYPE
          #undef RTYPE

          break;

        case CAI_CALLING_REC:
        case CAI_CONNECT_REC:
          /* -----------------------------------------------------------
          ** Calling Party Number or Connected Number Information Record
          ** ----------------------------------------------------------- */

          #define RTYPE caii_calling_rec_type
          #define FTYPE cai_calling_fix_type
          #define VTYPE cai_calling_var_type

          ((RTYPE *) msg_ptr)->fix.number_type =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, number_type ));
          start_msg_pos += FSIZ(FTYPE, number_type);

          ((RTYPE *) msg_ptr)->fix.number_plan =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, number_plan));
          start_msg_pos += FSIZ(FTYPE, number_plan);

          ((RTYPE *) msg_ptr)->fix.pi =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, pi ));
          start_msg_pos += FSIZ(FTYPE, pi);

          ((RTYPE *) msg_ptr)->fix.si =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, si ));
          start_msg_pos += FSIZ(FTYPE, si);

          ((RTYPE *) msg_ptr)->fix.num_char =
            (byte) ((rec_len - sizeof(FTYPE)) / sizeof(VTYPE));

          for (i=0; i < ((RTYPE *) msg_ptr)->fix.num_char; i++)
          {
            ((RTYPE *) msg_ptr)->var[i] =
              b_unpackb(buf_ptr, start_msg_pos, FSIZ(VTYPE, chari));
            start_msg_pos += FSIZ(VTYPE, chari);
          }

          /* -------------------------------
          ** Update internal message pointer
          ** ------------------------------- */
          msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_char - 1] );

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;

          #undef VTYPE
          #undef FTYPE
          #undef RTYPE

          break;

        case CAI_SIGNAL_REC:
          /* -------------------------
          ** Signal Information Record
          ** ------------------------- */

          #define RTYPE caii_signal_rec_type
          #define FTYPE cai_signal_rec_type

          ((RTYPE *) msg_ptr)->signal_type =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, signal_type));
          start_msg_pos += FSIZ(FTYPE, signal_type);

          ((RTYPE *) msg_ptr)->alert_pitch =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, alert_pitch));
          start_msg_pos += FSIZ(FTYPE, alert_pitch);

          ((RTYPE *) msg_ptr)->signal =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, signal));
          start_msg_pos += FSIZ(FTYPE, signal) + FSIZ(FTYPE, reserved);

          /* -------------------------------
          ** Update internal message pointer
          ** ------------------------------- */
          msg_ptr += sizeof(RTYPE);

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;

          #undef FTYPE
          #undef RTYPE

          break;

        case CAI_MSG_WAITING_REC:
          /* ----------------------------------
          ** Message Waiting Information Record
          ** ---------------------------------- */
          #define RTYPE caii_msg_waiting_rec_type
          #define FTYPE cai_msg_waiting_rec_type

          ((RTYPE *) msg_ptr)->msg_count =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, msg_count));
          start_msg_pos += FSIZ(FTYPE, msg_count);

          /* -------------------------------
          ** Update internal message pointer
          ** ------------------------------- */
          msg_ptr += sizeof(RTYPE);

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;

          #undef RTYPE
          #undef FTYPE

          break;

        case CAI_CALLED_SUB_REC:
        case CAI_CALLING_SUB_REC:
        case CAI_REDIR_SUB_REC:
          /* --------------------------------------------------------
          ** Calling Party Subaddress or Called Party Subaddress
          ** or Redirecting Subaddress info record
          ** -------------------------------------------------------- */
          /* Unpack Information Record */
          status = xlate_ext_sub_rec(rec_len, buf_ptr, msg_ptr, &start_msg_pos);

          /* -------------------------------------------------
          ** Increment internal message pointer to next record
          ** ------------------------------------------------- */
          #define RTYPE caii_subaddr_rec_type

          msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_char - 1]);

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;

          #undef RTYPE

          break;

        case CAI_REDIR_NUM_REC:
          /* --------------------------------------------------------
          ** Redirecting Number Information Record
          ** -------------------------------------------------------- */
          /* Unpack Information Record */
          status = xlate_ext_redir_num_rec(rec_len, buf_ptr, msg_ptr,
            &start_msg_pos);

          /* -------------------------------------------------
          ** Increment internal message pointer to next record
          ** ------------------------------------------------- */
          #define RTYPE caii_redir_rec_type

          msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_char - 1]);

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;

          #undef RTYPE

          break;

        case CAI_EXT_DISPLAY_REC:
          /* ------------------------------
          ** Extended Display Info Record
          ** ------------------------------ */
          status = xlate_ext_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
            &start_msg_pos);

          /* -------------------------------
          ** xlate function already updated
          ** internal message pointer
          ** ------------------------------- */

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;

          break;

        case CAI_PARA_ALERT_REC:
          /* --------------------------------------
          ** Parametric Alerting Information Record
          ** -------------------------------------- */
          status = xlate_ext_para_alert_rec(rec_len, buf_ptr, msg_ptr,
            &start_msg_pos);

          /* -------------------------------
          ** Update internal message pointer
          ** ------------------------------- */

          #define RTYPE caii_para_alert_rec_type

          if (((RTYPE *) msg_ptr)->fix.num_groups == 0)
          {
            msg_ptr += FENDPOS(RTYPE, fix);
          }
          else
          {
            msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_groups - 1]);
          }
          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;

          #undef RTYPE

          break;

        case CAI_USER_ZONE_REJECT_REC:

          #define RTYPE caii_user_zone_reject_type
          #define FTYPE cai_user_zone_reject_type

          ((RTYPE *) msg_ptr)->reject_uzid =
            b_unpackw(buf_ptr, start_msg_pos, FSIZ(FTYPE, reject_uzid));
          start_msg_pos += FSIZ(FTYPE, reject_uzid);

          ((RTYPE *) msg_ptr)->reject_action_indi =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, reject_action_indi));
          start_msg_pos += FSIZ(FTYPE, reject_action_indi);

          ((RTYPE *) msg_ptr)->uzid_assign_incl =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, uzid_assign_incl));
          start_msg_pos += FSIZ(FTYPE, uzid_assign_incl);

          if (((RTYPE *) msg_ptr)->uzid_assign_incl)
          {
            ((RTYPE *) msg_ptr)->assign_uzid =
              b_unpackw(buf_ptr, start_msg_pos, FSIZ(FTYPE, assign_uzid));
            start_msg_pos += FSIZ(FTYPE, assign_uzid);
            msg_ptr += FENDPOS(RTYPE, assign_uzid);
          }
          else
          {
            msg_ptr += FENDPOS(RTYPE, uzid_assign_incl);
          }

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;

          #undef FTYPE
          #undef RTYPE

          break;

#ifdef FEATURE_IS2000_REL_A
        case CAI_MC_EXT_DISP_REC:
          /* ---------------------------------------------
          ** Multi-character Extended Display Info Record
          ** --------------------------------------------- */
          status = xlate_ext_mc_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
            &start_msg_pos);

          /* -------------------------------
          ** xlate function already updated
          ** internal message pointer
          ** ------------------------------- */

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;
          break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
        case CAI_ENH_MC_EXT_DISP_REC:
          /* ---------------------------------------------
          ** Enhanced Multi-character Extended Display Info Record
          ** --------------------------------------------- */
          status = xlate_ext_enh_mc_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
            &start_msg_pos);

          /* -------------------------------
          ** xlate function already updated
          ** internal message pointer
          ** ------------------------------- */

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;
          break;
#endif /* FEATURE_IS2000_REL_C */

        default:
          /* ------------------------
          ** Unknown info record type
          ** ------------------------ */
          /* ----------------------------------------------------------
          ** Increment internal message pointer to point to next record
          ** ---------------------------------------------------------- */
          msg_ptr += FENDPOS(caii_rec_hdr_type, record_type);

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;
          break;
      } /* end switch (rec_type) */

      msg_ptr = (byte*)ALIGN_DWORD(((dword)msg_ptr));

    }
  } /* end of while */

  return (status);

} /* xlate_ext_pc_feature */

/*===========================================================================

FUNCTION XLATE_EXT_EXT_SYS_PARM

DESCRIPTION
  This function translates a Paging Channel Extended System Parameters
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended System Parameters message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_ext_sys_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
  word min_len;
    /* Protocol dependent minimum length requirement */
  byte i; /* Index */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_ext_sysparm_msg_type

  /* ---------------------------------------
  ** Check length to make sure it is correct
  ** --------------------------------------- */
  if ( len < CAI_EXT_SYSPARM_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ----------------------------------------------------------------
    ** Length is ok - start translating message at field after msg_type
    ** ---------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(ext_sysparm.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(ext_sysparm.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKB_PG(ext_sysparm.delete_for_tmsi, MTYPE, delete_for_tmsi);
    UNPACKB_PG(ext_sysparm.pref_msid_type, MTYPE, pref_msid_type);
    UNPACKW_PG(ext_sysparm.mcc, MTYPE, mcc);
    UNPACKB_PG(ext_sysparm.imsi_11_12, MTYPE, imsi_11_12);
    UNPACKB_PG(ext_sysparm.tmsi_zone_len, MTYPE, tmsi_zone_len);

    b_unpackq(buf_ptr, ext_msg_pos, int_ptr->ext_sysparm.tmsi_zone_len << 3,
              int_ptr->ext_sysparm.tmsi_zone );
    ext_msg_pos += int_ptr->ext_sysparm.tmsi_zone_len << 3;

    UNPACKB_PG(ext_sysparm.bcast_index, MTYPE, bcast_index);

    /* IS-95A and JSTD ends parsing right here */

    /* -------------------------------------------------------------
    ** At this point we need to check to see if the ESPM is in
    ** IS-95B format. If it is not IS-95B, there should not be
    ** enough length for P_REV field. Note: length passed into
    ** the parser is for the message body ( not including length
    ** field and CRC )
    ** ------------------------------------------------------------- */
    min_len = FSIZ( MTYPE, imsi_t_supported ) +
              FSIZ( MTYPE, p_rev ) +
              FSIZ( MTYPE, min_p_rev ) +
              FSIZ( MTYPE, soft_slope ) +
              FSIZ( MTYPE, add_intercept ) +
              FSIZ( MTYPE, drop_intercept ) +
              FSIZ( MTYPE, packet_zone_id ) +
              FSIZ( MTYPE, max_num_alt_so ) +
              FSIZ( MTYPE, reselect_included ) +
              FSIZ( MTYPE, pilot_report ) +
              FSIZ( MTYPE, nghbr_set_entry_info ) +
              FSIZ( MTYPE, nghbr_set_access_info );
    min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;

    if ((len - ext_msg_pos) < min_len )
    {
      /* -------------------------------------------------------------
      ** Length less than the minimum required by IS-95B, stop parsing
      ** and set p_rev to 0 to notify MC that we received a pre-IS95B
      ** format. MC should ignore all the IS-95B fields.
      ** ------------------------------------------------------------- */
      int_ptr->ext_sysparm.p_rev = CAIX_P_REV_UNKNOWN;
    }
#ifdef FEATURE_IS2000_REL_A
    else if (cdma.mob_cai_rev < P_REV_IS95B)
    {
      int_ptr->ext_sysparm.p_rev = CAIX_P_REV_UNKNOWN;
    }
#endif /* FEATURE_IS2000_REL_A */
    else
    {
      int_ptr->ext_sysparm.is95b_incl = TRUE;
      /* -------------------------------------------------------------
      ** Length greater or equal than the minimum required by IS-95B,
      ** keep parsing
      ** ------------------------------------------------------------- */
      UNPACKB_PG(ext_sysparm.imsi_t_supported, MTYPE, imsi_t_supported);
      UNPACKB_PG(ext_sysparm.p_rev, MTYPE, p_rev);
      UNPACKB_PG(ext_sysparm.min_p_rev, MTYPE, min_p_rev);
      UNPACKB_PG(ext_sysparm.soft_slope, MTYPE, soft_slope);
      UNPACKB_PG(ext_sysparm.add_intercept, MTYPE, add_intercept);
      UNPACKB_PG(ext_sysparm.drop_intercept, MTYPE, drop_intercept);
      UNPACKB_PG(ext_sysparm.packet_zone_id, MTYPE, packet_zone_id);
      UNPACKB_PG(ext_sysparm.max_num_alt_so, MTYPE, max_num_alt_so);
      UNPACKB_PG(ext_sysparm.reselect_included, MTYPE, reselect_included);

      if (int_ptr->ext_sysparm.reselect_included)
      {
        UNPACKB_PG(ext_sysparm.ec_thresh, MTYPE, ec_thresh);
        UNPACKB_PG(ext_sysparm.ec_io_thresh, MTYPE, ec_io_thresh);
      }

      UNPACKB_PG(ext_sysparm.pilot_report, MTYPE, pilot_report);
      UNPACKB_PG(ext_sysparm.nghbr_set_entry_info, MTYPE, nghbr_set_entry_info);

      if (int_ptr->ext_sysparm.nghbr_set_entry_info)
      {
        UNPACKB_PG(ext_sysparm.acc_ent_ho_order, MTYPE, acc_ent_ho_order);
      }

      UNPACKB_PG(ext_sysparm.nghbr_set_access_info, MTYPE, nghbr_set_access_info);

      if (int_ptr->ext_sysparm.nghbr_set_access_info)
      {
        UNPACKB_PG(ext_sysparm.access_ho, MTYPE, access_ho);

        if (int_ptr->ext_sysparm.access_ho)
        {
          UNPACKB_PG(ext_sysparm.access_ho_msg_rsp, MTYPE, access_ho_msg_rsp);
        }

        UNPACKB_PG(ext_sysparm.access_probe_ho, MTYPE, access_probe_ho);

        if (int_ptr->ext_sysparm.access_probe_ho)
        {
          UNPACKB_PG(ext_sysparm.acc_ho_list_upd, MTYPE, acc_ho_list_upd);
          UNPACKB_PG(ext_sysparm.acc_probe_ho_other_msg, MTYPE, acc_probe_ho_other_msg);
          UNPACKB_PG(ext_sysparm.max_num_probe_ho, MTYPE, max_num_probe_ho);
        }
      }

      if (int_ptr->ext_sysparm.nghbr_set_entry_info ||
          int_ptr->ext_sysparm.nghbr_set_access_info)
      {
        UNPACKB_PG(ext_sysparm.nghbr_set_size, MTYPE, nghbr_set_size);
      }

      if (int_ptr->ext_sysparm.nghbr_set_entry_info)
      {
        for (i = 0; ((i < int_ptr->ext_sysparm.nghbr_set_size) &&
                     (i < MAX_NGHBR_SET_SIZE)); i++)
        {
          UNPACKB_PG(ext_sysparm.access_entry_ho[i], MTYPE, access_entry_ho);
        }
      }

      if (int_ptr->ext_sysparm.nghbr_set_access_info)
      {
        for (i = 0; ((i < int_ptr->ext_sysparm.nghbr_set_size) &&
                     (i < MAX_NGHBR_SET_SIZE)); i++)
        {
          UNPACKB_PG(ext_sysparm.access_ho_allowed[i], MTYPE, access_ho_allowed);
        }
      }

      if (int_ptr->ext_sysparm.p_rev >= CAIX_P_REV_IS2000)
      {
        UNPACKB_PG(ext_sysparm.broadcast_gps_asst, MTYPE, broadcast_gps_asst);
        UNPACKB_PG(ext_sysparm.qpch_supported, MTYPE, qpch_supported);

        if (int_ptr->ext_sysparm.qpch_supported)
        {
          UNPACKB_PG(ext_sysparm.num_qpch, MTYPE, num_qpch);
          UNPACKB_PG(ext_sysparm.qpch_rate, MTYPE, qpch_rate);
          UNPACKB_PG(ext_sysparm.qpch_power_level_page, MTYPE, qpch_power_level_page);
          UNPACKB_PG(ext_sysparm.qpch_cci_supported, MTYPE, qpch_cci_supported);

          if (int_ptr->ext_sysparm.qpch_cci_supported)
          {
            UNPACKB_PG(ext_sysparm.qpch_power_level_config, MTYPE, qpch_power_level_config);
          }
        }

        UNPACKB_PG(ext_sysparm.sdb_supported, MTYPE, sdb_supported);
        UNPACKB_PG(ext_sysparm.rlgain_traffic_pilot, MTYPE, rlgain_traffic_pilot);
        UNPACKB_PG(ext_sysparm.rev_pwr_cntl_delay_incl, MTYPE, rev_pwr_cntl_delay_incl);

        if (int_ptr->ext_sysparm.rev_pwr_cntl_delay_incl)
        {
          UNPACKB_PG(ext_sysparm.rev_pwr_cntl_delay, MTYPE, rev_pwr_cntl_delay);
        }

        #undef R0VTYPE
        #undef R0MTYPE
      }

#ifdef FEATURE_IS2000_REL_A
      if (int_ptr->ext_sysparm.p_rev >= CAIX_P_REV_IS2000_REL_A)
      {
        UNPACKB_PG(ext_sysparm.auto_msg_supported, MTYPE, auto_msg_supported);

        if (int_ptr->ext_sysparm.auto_msg_supported)
        {
          UNPACKB_PG(ext_sysparm.auto_msg_interval, MTYPE, auto_msg_interval);
        }

        UNPACKB_PG(ext_sysparm.mob_qos, MTYPE, mob_qos);
        UNPACKB_PG(ext_sysparm.enc_supported, MTYPE, enc_supported);

        if (int_ptr->ext_sysparm.enc_supported)
        {
          UNPACKB_PG(ext_sysparm.sig_encrypt_sup, MTYPE, sig_encrypt_sup);
          UNPACKB_PG(ext_sysparm.ui_encrypt_sup, MTYPE, ui_encrypt_sup);
        }

        UNPACKB_PG(ext_sysparm.use_sync_id, MTYPE, use_sync_id);
        UNPACKB_PG(ext_sysparm.cs_supported, MTYPE, cs_supported);
        UNPACKB_PG(ext_sysparm.bcch_supported, MTYPE, bcch_supported);
        UNPACKB_PG(ext_sysparm.ms_init_pos_loc_sup_ind, MTYPE, ms_init_pos_loc_sup_ind);
        UNPACKB_PG(ext_sysparm.pilot_info_req_supported, MTYPE, pilot_info_req_supported);
      }
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
      if (int_ptr->ext_sysparm.p_rev >= CAIX_P_REV_IS2000_REL_B)
      {
        if (int_ptr->ext_sysparm.qpch_supported)
        {
          UNPACKB_PG(ext_sysparm.qpch_bi_supported, MTYPE, qpch_bi_supported);

          if (int_ptr->ext_sysparm.qpch_bi_supported)
          {
            UNPACKB_PG(ext_sysparm.qpch_power_level_bcast, MTYPE, qpch_power_level_bcast);
          }
        }

        UNPACKB_PG(ext_sysparm.band_class_info_req, MTYPE, band_class_info_req);

        if (int_ptr->ext_sysparm.band_class_info_req)
        {
          UNPACKB_PG(ext_sysparm.alt_band_class, MTYPE, alt_band_class);
        }

        UNPACKB_PG(ext_sysparm.cdma_off_time_rep_sup_ind, MTYPE,
          cdma_off_time_rep_sup_ind);

        if (int_ptr->ext_sysparm.cdma_off_time_rep_sup_ind)
        {
          UNPACKB_PG(ext_sysparm.cdma_off_time_rep_threshold_unit, MTYPE,
            cdma_off_time_rep_threshold_unit);
          UNPACKB_PG(ext_sysparm.cdma_off_time_rep_threshold, MTYPE,
            cdma_off_time_rep_threshold);
        }
      }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      if (int_ptr->ext_sysparm.p_rev >= CAIX_P_REV_IS2000_REL_C)
      {
        UNPACKB_PG(ext_sysparm.chm_supported, MTYPE, chm_supported);
        UNPACKB_PG(ext_sysparm.release_to_idle_ind, MTYPE, release_to_idle_ind);
        UNPACKB_PG(ext_sysparm.reconnect_msg_ind, MTYPE, reconnect_msg_ind);
        UNPACKB_PG(ext_sysparm.msg_integrity_sup, MTYPE, msg_integrity_sup);

        if (int_ptr->ext_sysparm.msg_integrity_sup)
        {
          UNPACKB_PG(ext_sysparm.sig_integrity_sup_incl, MTYPE, sig_integrity_sup_incl);

          if (int_ptr->ext_sysparm.sig_integrity_sup_incl)
          {
            UNPACKB_PG(ext_sysparm.sig_integrity_sup, MTYPE, sig_integrity_sup);
          }
        }

        UNPACKB_PG(ext_sysparm.for_pdch_supported, MTYPE, for_pdch_supported);

        if (int_ptr->ext_sysparm.for_pdch_supported)
        {
          UNPACKB_PG(ext_sysparm.pdch_chm_supported, MTYPE, pdch_chm_supported);
          UNPACKB_PG(ext_sysparm.pdch_parms_incl, MTYPE, pdch_parms_incl);

          if (int_ptr->ext_sysparm.pdch_parms_incl)
          {
            UNPACKB_PG(ext_sysparm.for_pdch_rlgain_incl, MTYPE, for_pdch_rlgain_incl);

            if (int_ptr->ext_sysparm.for_pdch_rlgain_incl)
            {
              UNPACKB_PG(ext_sysparm.rlgain_ackch_pilot, MTYPE, rlgain_ackch_pilot);
              UNPACKB_PG(ext_sysparm.rlgain_cqich_pilot, MTYPE, rlgain_cqich_pilot);
            }

            UNPACKB_PG(ext_sysparm.num_soft_switching_frames, MTYPE, num_soft_switching_frames);
            UNPACKB_PG(ext_sysparm.num_softer_switching_frames, MTYPE, num_softer_switching_frames);
            UNPACKB_PG(ext_sysparm.num_soft_switching_slots , MTYPE, num_soft_switching_slots);
            UNPACKB_PG(ext_sysparm.num_softer_switching_slots, MTYPE, num_softer_switching_slots);
            UNPACKB_PG(ext_sysparm.pdch_soft_switching_delay, MTYPE, pdch_soft_switching_delay);
            UNPACKB_PG(ext_sysparm.pdch_softer_switching_delay, MTYPE, pdch_softer_switching_delay);
            UNPACKB_PG(ext_sysparm.walsh_table_id, MTYPE, walsh_table_id);
            UNPACKB_PG(ext_sysparm.num_pdcch, MTYPE, num_pdcch);

            if((int_ptr->ext_sysparm.num_pdcch + 1) > CAI_MAX_NUM_FOR_PDCCH)
            {
              M1X_MSG( DCP, LEGACY_ERROR,
                "Unsupported num_pdcch = %d is rxed",
                int_ptr->ext_sysparm.num_pdcch);
              status = CAIX_INV_MSG_S;
              return status;
            }

            for (i = 0; i < int_ptr->ext_sysparm.num_pdcch+1; i++)
            {
              UNPACKB_PG(ext_sysparm.for_pdcch_walsh[i], MTYPE, for_pdcch_walsh);
            }
          }
        }

        UNPACKB_PG(ext_sysparm.imsi_10_incl, MTYPE, imsi_10_incl);

        if (int_ptr->ext_sysparm.imsi_10_incl)
        {
          UNPACKB_PG(ext_sysparm.imsi_10, MTYPE, imsi_10);
        }
      }
#endif /* FEATURE_IS2000_REL_C */

    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_ext_sys_parm */

/*===========================================================================

FUNCTION XLATE_EXT_PC_STREQ

DESCRIPTION
  This function translates a Paging Channel Status Request Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Status Request Message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_streq
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Return status */
  caii_pc_streq_type  *i_ptr = &int_ptr->pc_streq;
    /* Pointer to internal Status Request Message */
  word i;
    /* Index for looping through requested record types */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */
  byte qual_len;
    /* For reading length of qualification information */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Skip over message type */
  msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  /* Translate paging channel header */
  xlate_ext_pc_hdr(&msg_pos, buf_ptr, &i_ptr->hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
       CAIX_MACI_REQUIRED, &msg_pos,
       buf_ptr, &i_ptr->hdr.msg_int, i_ptr->msg_type,
       i_ptr->hdr.ack_req
      )) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
      &i_ptr->hdr, i_ptr->msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define FTYPE cai_pc_streq_fix_type
  #define VTYPE cai_streq_var_type

  msg_pos += FSIZ(FTYPE, reserved);  /* Skip over reserved field */

  i_ptr->qual = b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, qual_typ));
    /* Translate qualification info type */
  msg_pos += FSIZ(FTYPE, qual_typ);

  /* Translate qual info length */
  qual_len = (byte) (b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, qual_len)) * 8);
  msg_pos += FSIZ(FTYPE, qual_len);

  if (msg_pos + qual_len + FSIZ(FTYPE, num_fields ) > len)
  {
    return (CAIX_INV_LEN_S); /* Message too small */
  }

  if (i_ptr->qual == CAI_NO_QUAL) /* No qual info specified */
  {
    i_ptr->band = CAI_BAND_CLASS0;         /* Assume cellular band */

    i_ptr->op_mode = CAI_IS95_CDMA_OP_MODE; /* Assume CDMA mode */

    msg_pos += qual_len; /* Skip over qual info field */
  }
  else if (i_ptr->qual == CAI_BAND_QUAL) /* Band qual info specified */
  {
    if (sizeof(cai_qual_info1_type) > qual_len)
    {
      return (CAIX_INV_LEN_S); /* Message too small */
    }
    else
    {
      i_ptr->band = b_unpackb(buf_ptr, msg_pos, FSIZ(cai_qual_info1_type, band));
          /* Translate band qual info */
      msg_pos += qual_len; /* Skip over qual info field */

      i_ptr->op_mode = CAI_IS95_CDMA_OP_MODE; /* Assume CDMA mode */
    }
  }
  else if (i_ptr->qual == CAI_BAND_OP_MODE_QUAL) /* Band and mode */
  {
    if (sizeof(cai_qual_info2_type) > qual_len)
    {
      return (CAIX_INV_LEN_S);  /* Message too small */
    }
    else
    {
      i_ptr->band = b_unpackb(buf_ptr, msg_pos, FSIZ(cai_qual_info2_type, band));
          /* Unpack band qual info */

      i_ptr->op_mode = b_unpackb(buf_ptr, msg_pos +
        FSIZ(cai_qual_info2_type, band), FSIZ(cai_qual_info2_type, op_mode));
          /* Translate mode qual info */
      msg_pos += qual_len; /* Skip over qual info field */
    }
  }
  else
  {
    return (CAIX_INV_MSG_S);  /* Unknown qualification type */
  }

  /* Translate number of info req requests */
  i_ptr->num_fields = b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, num_fields));
  msg_pos += FSIZ(FTYPE, num_fields);

  if (msg_pos + (i_ptr->num_fields * sizeof(VTYPE)) > len)
  {
    return (CAIX_INV_LEN_S); /* Message too small */
  }

  /* Translate request info rec types */
  for ( i = 0; (i < i_ptr->num_fields) && (i < CAI_REC_TYP_MAX); i++ )
  {
    i_ptr->rec_typ[i] = b_unpackb(buf_ptr, msg_pos, FSIZ(VTYPE, rec_typ));
    msg_pos += FSIZ(VTYPE, rec_typ);
  }

  #undef FTYPE
  #undef VTYPE

  return (status);

} /* xlate_ext_pc_streq */

/*===========================================================================

FUNCTION XLATE_EXT_SRVC_REDIR

DESCRIPTION
  This function translates a Paging Channel Service Redirection Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Service Redirection message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srvc_redir
(
  word len,
    /* Length of message in bits */
    /*lint -esym(715,len) */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status;
    /* Status returned to calling procedure */
  word msg_pos = 0;
    /* Position of record in message */
  word i;
    /* Index */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ----------------------------------
  ** Initialize status to everything ok
  ** ---------------------------------- */
  status = CAIX_DONE_S;

    msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

    xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->serv_redir.hdr);

#ifdef FEATURE_IS2000_REL_C
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Message Integrity fields if
    ** there is one.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
         CAIX_MACI_REQUIRED, &msg_pos,
         buf_ptr, &int_ptr->serv_redir.hdr.msg_int,
         int_ptr->serv_redir.msg_type,
         int_ptr->serv_redir.hdr.ack_req
     )) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Extended Encryption fields if
    ** there is one, and run the decryption algorithm.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
        &int_ptr->serv_redir.hdr, int_ptr->serv_redir.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_A */

  /* ----------------------
  ** Unpack base of message
  ** ---------------------- */

  #define FTYPE cai_serv_redirect_fix_type

  int_ptr->serv_redir.return_if_fail =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, return_if_fail));
  msg_pos += FSIZ(FTYPE, return_if_fail);

  int_ptr->serv_redir.delete_tmsi =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, delete_tmsi));
  msg_pos += FSIZ(FTYPE, delete_tmsi);

  int_ptr->serv_redir.redirect_type =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, redirect_type));
  msg_pos += FSIZ(FTYPE, redirect_type);

  int_ptr->serv_redir.record_type =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, record_type));
  msg_pos += FSIZ(FTYPE, record_type);

  int_ptr->serv_redir.record_len =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, record_len));
  msg_pos += FSIZ(FTYPE, record_len);

  #undef FTYPE

  /* ---------------------
  ** Switch on record type
  ** --------------------- */
  switch (int_ptr->serv_redir.record_type)
  {
    case CAI_NDSS_OFF_INDICATION:
      /* IS-95B, NDSS off, no type specific fields included */
      break;

    case CAI_ANALOG_REDIRECTION_REC:

      #define RTYPE cai_redirect_rec1_type

      int_ptr->serv_redir.redir.rec1.expected_sid =
        b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_sid));
      msg_pos += FSIZ(RTYPE, expected_sid);

      int_ptr->serv_redir.redir.rec1.ignore_cdma =
        b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, ignore_cdma));
      msg_pos += FSIZ(RTYPE, ignore_cdma);

      int_ptr->serv_redir.redir.rec1.sys_ordering =
        b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, sys_ordering));
      msg_pos += FSIZ(RTYPE, sys_ordering);

      int_ptr->serv_redir.redir.rec1.max_redirect_delay = 0;

      #undef RTYPE

      break;

    case CAI_CDMA_REDIRECTION_REC:

      #define RTYPE cai_redirect_rec2_type

      int_ptr->serv_redir.redir.rec2.band_class =
        b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, band_class));
      msg_pos += FSIZ(RTYPE, band_class);

      int_ptr->serv_redir.redir.rec2.expected_sid =
        b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_sid));
      msg_pos += FSIZ(RTYPE, expected_sid);

      int_ptr->serv_redir.redir.rec2.expected_nid =
        b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_nid));
      msg_pos += FSIZ(RTYPE, expected_nid);

      msg_pos += FSIZ(RTYPE, reserved);

      int_ptr->serv_redir.redir.rec2.num_chans =
        b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, num_chans ));
      msg_pos += FSIZ(RTYPE, num_chans );

      if ((word)(len - msg_pos) >=
          (int_ptr->serv_redir.redir.rec2.num_chans * FSIZ(RTYPE, cdma_chan)))
      {
        for (i=0; (i < int_ptr->serv_redir.redir.rec2.num_chans) &&
             (i < CAI_MAX_CDMA_CHANS); i++)
        {
          int_ptr->serv_redir.redir.rec2.cdma_chan[i] =
            b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, cdma_chan));
          msg_pos += FSIZ(RTYPE, cdma_chan );
        }
      }
      else
      {
        status = CAIX_INV_MSG_S;
      }

      #undef RTYPE

      break;

    case CAI_JTACS_REDIRECTION_REC:

      #define RTYPE cai_redirect_rec4_type

      int_ptr->serv_redir.redir.rec4.expected_aid =
        b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_aid));
      msg_pos += FSIZ(RTYPE, expected_aid);

      int_ptr->serv_redir.redir.rec4.ignore_cdma =
        b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, ignore_cdma));
      msg_pos += FSIZ(RTYPE, ignore_cdma);

      #undef RTYPE

      break;

    default:
      M1X_MSG( DCP, LEGACY_MED,
        "Invalid rec type %d",
        int_ptr->serv_redir.record_type );
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

  return (status);

} /* xlate_ext_srvc_redir */

/*===========================================================================

FUNCTION XLATE_EXT_GENERAL_PAGE

DESCRIPTION
  This function translates a Paging Channel General Page Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the General Page message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_general_page
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word ext_msg_pos = 0;
    /* Position of page within page message */
  word num_pages;
    /* Number of pages in page array */
  byte add_length;
    /* Number of ADD_PFIELD octets in received General Page Message */
  byte i;
    /* Loop counter */
  boolean invalid_page_rec;
    /* Indicates if we have encountered an invalid page record */

  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  /* Force tunneled msg parsing only if we are not in CGI Req processing
   * for CSFB case */
  if( (csfb_cdma.cgi_req_proc_state == CSFB_CGI_REQ_NONE) &&
      (cdma.entry_ptr != NULL) &&
      (cdma.entry_ptr->entry == MCC_CSFB)
    )
  {
    /* In native 1X, GPM has common Layer 2 fields and addressed fields.
     * While, in tunneled mode, it will have the mobile addressed fields only.
     * Hence, GPM will be sent with only service option. To reuse the legacy code
     * for GPM processing, hard coding the special_service.
     */
    if(len != 0)
    {
      int_ptr->gen_page.gen_page[0].rec.format0.special_service = 1;
    }
    else
    {
      int_ptr->gen_page.gen_page[0].rec.format0.special_service = 0;
    }

    if (int_ptr->gen_page.gen_page[0].rec.format0.special_service)
    {
      int_ptr->gen_page.gen_page[0].rec.format0.service_option =
        b_unpackw( buf_ptr, ext_msg_pos, FSIZ( cai_pc_0_sc_0_type, service_option ));
      ext_msg_pos += FSIZ( cai_pc_0_sc_0_type, service_option );
    }

    return CAIX_DONE_S;
  }
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_gen_page_fix_type

  /* ------------------------------------------------------
  ** First determine if the message is of sufficient length
  ** ------------------------------------------------------ */
  if (len < sizeof( cai_gen_page_fix_type ))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */
    int_ptr->gen_page.config_msg_seq = b_unpackb( PARAMS( config_msg_seq ));
    int_ptr->gen_page.acc_msg_seq    = b_unpackb( PARAMS( acc_msg_seq ));
    int_ptr->gen_page.class_0_done   = b_unpackb( PARAMS( class_0_done ));
    int_ptr->gen_page.class_1_done   = b_unpackb( PARAMS( class_1_done ));
    int_ptr->gen_page.tmsi_done      = b_unpackb( PARAMS( tmsi_done ));
    int_ptr->gen_page.ordered_tmsis  = b_unpackb( PARAMS( ordered_tmsis ));
    int_ptr->gen_page.broadcast_done = b_unpackb( PARAMS( broadcast_done ));

    add_length = b_unpackb( PARAMS( add_length ));

    ext_msg_pos = sizeof( cai_gen_page_fix_type );

    for (i=0; i < add_length; i++)
    {
      ext_msg_pos += FSIZ( cai_gen_page_pfield_type, add_pfield );
    }

    /* ----------------------------------
    ** Initialize status to everything ok
    ** ---------------------------------- */
    invalid_page_rec = FALSE;

    num_pages = 0; /* Initialize */

    while ((len >= (CAI_GEN_PAGE_MIN + ext_msg_pos)) &&
           (!invalid_page_rec))
    {
      int_ptr->gen_page.gen_page[num_pages].page_class =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_gen_page_class_type, page_class ));
      ext_msg_pos += FSIZ( cai_gen_page_class_type, page_class );

      int_ptr->gen_page.gen_page[num_pages].page_subclass =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_gen_page_class_type, page_subclass ));
      ext_msg_pos += FSIZ( cai_gen_page_class_type, page_subclass );

#ifdef FEATURE_IS2000_REL_A
      if (int_ptr->gen_page.gen_page[num_pages].page_class == CAI_PAGE_CLASS_3 &&
          int_ptr->gen_page.gen_page[num_pages].page_subclass != CAI_PAGE_SUBCLASS_0)
      {
        int_ptr->gen_page.gen_page[num_pages].page_subclass_ext =
          b_unpackb( buf_ptr, ext_msg_pos,
                     FSIZ( cai_gen_page_class_type, page_subclass_ext ));
        ext_msg_pos += FSIZ( cai_gen_page_class_type, page_subclass_ext );
      }
#endif /* FEATURE_IS2000_REL_A */
      switch (int_ptr->gen_page.gen_page[num_pages].page_class)
      {
        case CAI_PAGE_CLASS_0:  /* PAGE_CLASS = '00' */
          if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
              CAI_PAGE_SUBCLASS_0)
          {
            /* -----------------------------------------
            ** PAGE_CLASS = '00' and PAGE_SUBCLASS = '00'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format0.msg_seq =
            b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_0_sc_0_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_0_type, msg_seq );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_0_sc_0_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format0.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_0_sc_0_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format0.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_0_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_0_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format0.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format0.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_0_sc_0_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_0_sc_0_type, service_option );
            }
          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '00' and PAGE_SUBCLASS = '01'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format1.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_1_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_1_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format1.imsi_11_12 =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_1_type, imsi_11_12 ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_1_type, imsi_11_12 );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_0_sc_1_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format1.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_0_sc_1_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format1.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_1_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_1_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format1.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format1.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_0_sc_1_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_0_sc_1_type, service_option );
            }
          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_2)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '00' and PAGE_SUBCLASS = '10'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format2.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_2_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_2_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format2.mcc =
              b_unpackw( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_2_type, mcc ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_2_type, mcc );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_0_sc_2_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format2.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_0_sc_2_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format2.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_2_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_2_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format2.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format2.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_0_sc_2_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_0_sc_2_type, service_option );
            }
          }
          else /* (page_subclass == 3) */
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '00' and PAGE_SUBCLASS = '11'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format3.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_3_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format3.mcc =
              b_unpackw( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_3_type, mcc ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, mcc );

            int_ptr->gen_page.gen_page[num_pages].rec.format3.imsi_11_12 =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_3_type, imsi_11_12 ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, imsi_11_12 );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_0_sc_3_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format3.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format3.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_3_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format3.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format3.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_0_sc_3_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, service_option );
            }
          }
          break;

        case CAI_PAGE_CLASS_1: /* PAGE_CLASS == '01' */
          if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
              CAI_PAGE_SUBCLASS_0)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '01' and PAGE_SUBCLASS = '00'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format4.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_0_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format4.imsi_addr_num =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_0_type, imsi_addr_num ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, imsi_addr_num );

            int_ptr->gen_page.gen_page[num_pages].rec.format4.imsi_11_12 =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_0_type, imsi_11_12 ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, imsi_11_12 );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_1_sc_0_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format4.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format4.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_0_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format4.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format4.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_1_sc_0_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, service_option );
            }
          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '01' and PAGE_SUBCLASS = '01'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format5.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_1_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format5.imsi_addr_num =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_1_type, imsi_addr_num ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, imsi_addr_num );

            int_ptr->gen_page.gen_page[num_pages].rec.format5.mcc =
              b_unpackw( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_1_type, mcc ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, mcc );

            int_ptr->gen_page.gen_page[num_pages].rec.format5.imsi_11_12 =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_1_type, imsi_11_12 ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, imsi_11_12 );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_1_sc_1_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format5.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format5.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_1_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format5.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format5.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_1_sc_1_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, service_option );
            }
          }
          else
          {
            /* ---------------------
            ** Illegal page subclass
            ** --------------------- */
            invalid_page_rec = TRUE;
            continue;
          }
          break;

        case CAI_PAGE_CLASS_2:  /* PAGE_CLASS = '10' - TMSI addressing */
          if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
              CAI_PAGE_SUBCLASS_0)
          {
            /* -----------------------------------------
            ** PAGE_CLASS = '10' and PAGE_SUBCLASS = '00'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format8.msg_seq =
            b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_2_sc_0_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_0_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format8.tmsi_code_addr =
              b_unpackd( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_0_type, tmsi_code_addr ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_0_type, tmsi_code_addr );

            int_ptr->gen_page.gen_page[num_pages].rec.format8.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_0_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_0_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format8.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format8.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_2_sc_0_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_2_sc_0_type, service_option );
            }
          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '10' and PAGE_SUBCLASS = '01'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format9.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_1_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_1_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format9.tmsi_code_addr =
              b_unpackd( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_1_type, tmsi_code_addr ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_1_type, tmsi_code_addr );

            int_ptr->gen_page.gen_page[num_pages].rec.format9.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_1_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_1_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format9.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format9.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_2_sc_1_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_2_sc_1_type, service_option );
            }
          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_2)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '10' and PAGE_SUBCLASS = '10'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format10.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_2_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_2_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format10.tmsi_code_addr =
              b_unpackw( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_2_type, tmsi_code_addr ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_2_type, tmsi_code_addr );

            int_ptr->gen_page.gen_page[num_pages].rec.format10.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_2_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_2_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format10.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format10.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_2_sc_2_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_2_sc_2_type, service_option );
            }
          }
          else /* (page_subclass == 3) */
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '10' and PAGE_SUBCLASS = '11'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format11.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_3_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_3_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format11.tmsi_zone_len =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_3_type, tmsi_zone_len ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_3_type, tmsi_zone_len );

            /* Initialize destination TMSI zone to zero */
            /* before unpacking.                        */
            qw_set(
              int_ptr->gen_page.gen_page[num_pages].rec.format11.info.tmsi_zone,
              0L, 0L );

            b_unpackq(
              buf_ptr, ext_msg_pos,
              (int_ptr->gen_page.gen_page[num_pages].rec.format11.tmsi_zone_len * 8 ),
              int_ptr->gen_page.gen_page[num_pages].rec.format11.info.tmsi_zone );
            ext_msg_pos +=
              int_ptr->gen_page.gen_page[num_pages].rec.format11.tmsi_zone_len * 8;

            int_ptr->gen_page.gen_page[num_pages].rec.format11.info.tmsi_code =
              b_unpackd( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_3_type, tmsi_code_addr ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_3_type, tmsi_code_addr );

            int_ptr->gen_page.gen_page[num_pages].rec.format11.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_3_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_3_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format11.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format11.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_2_sc_3_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_2_sc_3_type, service_option );
            }
          }
          break;

        case CAI_PAGE_CLASS_3:
          if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
              CAI_PAGE_SUBCLASS_0)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '11' and PAGE_SUBCLASS = '00'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format12.burst_type =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_0_fix_type, burst_type ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_0_fix_type, burst_type );

            int_ptr->gen_page.gen_page[num_pages].rec.format12.addr_len =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_0_fix_type, addr_len ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_0_fix_type, addr_len );

            for (i=0; i < int_ptr->gen_page.gen_page[num_pages].
                 rec.format12.addr_len; i++)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format12.bc_addr[i] =
                b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_0_var_type, bc_addr ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_0_var_type, bc_addr );
            }
          }
#ifdef FEATURE_IS2000_REL_A
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_0)
          {
            /* For page format 13.0, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format13_0.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_0_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_0_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_0_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format13_0.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_0_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_0_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format13_0.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format13_0.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_1_sce_0_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_0_type, service_option );
            }

          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_1)
          {
            /* For format 13.1, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format13_1.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_1_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_1_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_1_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format13_1.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_1_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_1_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format13_1.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format13_1.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_1_sce_1_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_1_type, service_option );
            }

          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_2)
          {
            /* For format 13.2, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format13_2.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_2_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_2_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_2_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format13_2.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_2_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_2_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format13_2.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format13_2.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_1_sce_2_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_2_type, service_option );
            }


          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_3)
          {
            /* For format 13.3, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format13_3.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_3_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_3_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format13_3.length =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_3_type, length ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_3_type, length );

            /* Skip the reserved fields */
            ext_msg_pos += (8*int_ptr->gen_page.gen_page[num_pages].rec.format13_3.length
              + FSIZ( cai_pc_3_sc_1_sce_3_type, reserved ));

            int_ptr->gen_page.gen_page[num_pages].rec.format13_3.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_3_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_3_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format13_3.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format13_3.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_1_sce_3_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_3_type, service_option );
            }


          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_2 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_0)
          {
            /* For format 14.0, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format14_0.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_0_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_0_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_0_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format14_0.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_0_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_0_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format14_0.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format14_0.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_2_sce_0_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_0_type, service_option );
            }

          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_2 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_1)
          {
            /* For format 14.1, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format14_1.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_1_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_1_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_1_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format14_1.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_1_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_1_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format14_1.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format14_1.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_2_sce_1_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_1_type, service_option );
            }

          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_2 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_2)
          {
            /* For format 14.1, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format14_2.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_2_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_2_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_2_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format14_2.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_2_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_2_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format14_2.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format14_2.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_2_sce_2_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_2_type, service_option );
            }

          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_3 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_0)
          {
            /* -------------------------------------------
            ** PAGE_CLASS = '11' and PAGE_SUBCLASS = '11'
            ** and PAGE_SUBCLASS_EXT = '00'
            ** ------------------------------------------- */
            caii_pc_3_sc_3_sce_0_type *pg_ptr;

            pg_ptr = &int_ptr->gen_page.gen_page[num_pages].rec.format15_0;

            pg_ptr->burst_type =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_3_sce_0_fix_type, burst_type ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type, burst_type );

            pg_ptr->addr_len =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_3_sce_0_fix_type, addr_len ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type, addr_len );

            for (i=0; i < pg_ptr->addr_len; i++)
            {
              pg_ptr->bc_addr[i] =
                b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_3_sce_0_var1_type, bc_addr ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_var1_type, bc_addr );
            }

            pg_ptr->ext_bcast_sdu_length_ind =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                               ext_bcast_sdu_length_ind ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                              ext_bcast_sdu_length_ind );

            if (pg_ptr->ext_bcast_sdu_length_ind == 2 ||
                pg_ptr->ext_bcast_sdu_length_ind == 3)
            {
              pg_ptr->ext_bcast_sdu_length =
                b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                                 ext_bcast_sdu_length ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                                ext_bcast_sdu_length );

            }

            pg_ptr->bcn =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_3_sce_0_fix_type, bcn ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type, bcn );

            pg_ptr->time_offset =
              b_unpackw( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_3_sce_0_fix_type, time_offset ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type, time_offset );

            if (pg_ptr->ext_bcast_sdu_length_ind == 1 ||
                pg_ptr->ext_bcast_sdu_length_ind == 3)
            {
              /* Length of the SDU is 18 or 18+8k */
              pg_ptr->repeat_time_offset =
                (byte) b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                                 repeat_time_offset ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                                repeat_time_offset );

            }
            else
            {
              /* if ext_bcast_sdu_length_ind is 0 or 2 */
              /* Length of the SDU is 13 or 13+8k */
              pg_ptr->repeat_time_offset = CAI_INV_REPEAT_TIME_OFFSET;
            }

            if (pg_ptr->ext_bcast_sdu_length_ind == 2 ||
                pg_ptr->ext_bcast_sdu_length_ind == 3)
            {
              for (i=0; i < pg_ptr->ext_bcast_sdu_length; i++)
              {
                pg_ptr->add_bcast_record[i] =
                  b_unpackb( buf_ptr, ext_msg_pos,
                             FSIZ( cai_pc_3_sc_3_sce_0_var2_type,
                                   add_bcast_record ));
                ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_var2_type,
                                  add_bcast_record );
              }
            }
          }
#endif /* FEATURE_IS2000_REL_A */
          else
          {
            /* ---------------------
            ** Illegal page subclass
            ** --------------------- */
            invalid_page_rec = TRUE;
            continue;
          }
          break;

        default:
          /* ------------------
          ** Illegal page class
          ** ------------------ */
          invalid_page_rec = TRUE;
          continue;
      } /* end switch (page_class) */

      num_pages++;
    } /* end of while */

    int_ptr->gen_page.num_pages = num_pages;

    status = CAIX_DONE_S;
  }

  #undef MTYPE
  return (status);

} /* xlate_ext_general_page */

/*===========================================================================

FUNCTION XLATE_EXT_GLOB_REDIR

DESCRIPTION
  This function translates a Paging Channel Global Service Redirection
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Global Service Redirection message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_glob_redir
(
  word len,
    /* Length of message in bits */
    /*lint -esym(715,len) */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
  word i;
    /* Index */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_global_redirect_type

  /* -------------------------------------------------
  ** Start translating message at field after msg_type
  ** ------------------------------------------------- */
  ext_msg_pos = FSIZ(MTYPE, msg_type);

  UNPACKW_PG(glob_redir.pilot_pn, MTYPE, pilot_pn);
  UNPACKB_PG(glob_redir.config_msg_seq, MTYPE, config_msg_seq);
  UNPACKW_PG(glob_redir.redirect_accolc, MTYPE, redirect_accolc);
  UNPACKB_PG(glob_redir.return_if_fail, MTYPE, return_if_fail);
  UNPACKB_PG(glob_redir.delete_tmsi, MTYPE, delete_tmsi);

  /* in pre-IS2000 system, this field is reserved. If P_REV is less than 6,
   * excl_p_rev_ms field has no meaning. */
  UNPACKB_PG(glob_redir.excl_p_rev_ms, MTYPE, reserved);

#ifdef FEATURE_IS2000_REL_A
  if (cdma.mob_cai_rev < P_REV_IS2000)
  {
    int_ptr->glob_redir.excl_p_rev_ms = 0;
  }
#endif /* FEATURE_IS2000_REL_A */

  UNPACKB_PG(glob_redir.record_type, MTYPE, record_type);
  UNPACKB_PG(glob_redir.record_len, MTYPE, record_len);

  /* ---------------------
  ** Switch on record type
  ** --------------------- */
  switch (int_ptr->glob_redir.record_type)
  {
    case CAI_NDSS_OFF_INDICATION:
      /* IS-95B, NDSS off, no type specific fields included */
      break;

    case CAI_ANALOG_REDIRECTION_REC:
      UNPACKW_PG(glob_redir.redir.rec1.expected_sid,
        cai_redirect_rec1_type, expected_sid);
      UNPACKB_PG(glob_redir.redir.rec1.ignore_cdma,
        cai_redirect_rec1_type, ignore_cdma);
      UNPACKB_PG(glob_redir.redir.rec1.sys_ordering,
        cai_redirect_rec1_type, sys_ordering);
      UNPACKB_PG(glob_redir.redir.rec1.max_redirect_delay,
        cai_redirect_rec1_type, max_redirect_delay);
      break;

    case CAI_CDMA_REDIRECTION_REC:
      UNPACKB_PG(glob_redir.redir.rec2.band_class,
        cai_redirect_rec2_type, band_class);
      UNPACKW_PG(glob_redir.redir.rec2.expected_sid,
        cai_redirect_rec2_type, expected_sid);
      UNPACKW_PG(glob_redir.redir.rec2.expected_nid,
        cai_redirect_rec2_type, expected_nid);

      ext_msg_pos += FSIZ(cai_redirect_rec2_type, reserved);

      UNPACKB_PG(glob_redir.redir.rec2.num_chans,
        cai_redirect_rec2_type, num_chans);

      for (i=0; (i < int_ptr->glob_redir.redir.rec2.num_chans) &&
           (i < CAI_MAX_CDMA_CHANS); i++)
      {
        UNPACKW_PG(glob_redir.redir.rec2.cdma_chan[i],
          cai_redirect_rec2_type, cdma_chan);
      }
      break;

    case CAI_JTACS_REDIRECTION_REC:
      UNPACKW_PG(glob_redir.redir.rec4.expected_aid,
        cai_redirect_rec4_type, expected_aid);
      UNPACKB_PG(glob_redir.redir.rec4.ignore_cdma,
        cai_redirect_rec4_type, ignore_cdma);
      break;

    default:
      M1X_MSG( DCP, LEGACY_MED,
        "Invalid rec type %d",
        int_ptr->glob_redir.record_type );
      status = CAIX_INV_MSG_S;
      break;

  } /* end of switch */

  #undef MTYPE

  return (status);

} /* xlate_ext_glob_redir */

/*===========================================================================

FUNCTION XLATE_EXT_PACA

DESCRIPTION
  This function translates a Paging Channel PACA
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the PACA message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_paca
(
  word len,
    /* Length of message in bits */
    /*lint -esym(715,len) */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------------------------------------
  ** Length is ok - finish converting message from external to internal
  ** format starting with the first field after message_type
  ** ------------------------------------------------------------------ */
  msg_pos = FSIZ( cai_pc_hdr_type, msg_type );

  xlate_ext_pc_hdr( &msg_pos, buf_ptr, &int_ptr->paca.hdr );

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields if
  ** there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
       CAIX_MACI_REQUIRED, &msg_pos,
       buf_ptr, &int_ptr->paca.hdr.msg_int, int_ptr->paca.msg_type,
       int_ptr->paca.hdr.ack_req
         ))
       != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
      &int_ptr->paca.hdr, int_ptr->paca.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define FTYPE cai_paca_type

  /* Skip reserved field */
  msg_pos += FSIZ(FTYPE, reserved);

  int_ptr->paca.purpose  = b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, purpose));
  msg_pos += FSIZ(FTYPE, purpose);

  int_ptr->paca.q_pos  = b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, q_pos));
  msg_pos += FSIZ(FTYPE, q_pos);

  int_ptr->paca.paca_timeout = b_unpackb(buf_ptr, msg_pos,
    FSIZ(FTYPE, paca_timeout));
  msg_pos += FSIZ(FTYPE, paca_timeout);

  #undef FTYPE

  return (status);

} /*  xlate_ext_paca  */

/*===========================================================================

FUNCTION XLATE_EXT_EXT_CHN_ASN

DESCRIPTION
  This function translates an ECAM or MEID ECAM from external to internal
  format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Channel Assignment message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_ext_chn_asn
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of channel assignment order relative to start of buf_ptr */
  byte add_record_len = 0;
    /* Temporary storage for the add_record_len field */
  word num_recs;
    /* Number of variable parts of message */
  word i = 0;
    /* for loop iterator */
  int  j;
    /* Index through parameters */
  word old_ext_msg_pos;
    /* For caculating # of reserved bits in a single chn asn record */
  byte *int_buf_ptr;
    /* Keep track of the starting point of the next packed order */
  word my_fendpos=0;
  word min_len;
    /* Protocol dependent minimum length */
  word temp_len;
#ifdef FEATURE_IS2000_REL_C
  word maci_pos; /* Postion of MACIa field */
#endif /* FEATURE_IS2000_REL_C */

  #ifdef FEATURE_IS2000_REL_A_AES
  boolean maci_incl = FALSE;
  uint8 sdu_key_id = MCCAES_KEY_ID; /* in case MI is off, use key id 0 */
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < CAI_EXT_CHN_ASN_MIN)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ---------------------------------------------------------------
    ** Length is ok - initialize pointer and finish converting message
    ** from external to internal format starting with the first field
    ** after message_type
    ** --------------------------------------------------------------- */
    ext_msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

    /* ---------------------------------
    ** Initialize number of records to 0
    ** --------------------------------- */
    num_recs = 0;

    /* ---------------------------------------------------------
    ** Initialize first record pointer to buf
    ** --------------------------------------------------------- */
    int_buf_ptr = int_ptr->ext_chnasn.buf;
    int_buf_ptr = (byte *)ALIGN_DWORD((dword)int_buf_ptr);
    int_ptr->ext_chnasn.chns[0] = (caii_ext_ca_ord_type*)int_buf_ptr;

    while ((len > ext_msg_pos) &&
           ((len - ext_msg_pos) >= CAI_EXT_CHN_ASN_REC_MIN))
    {
      xlate_ext_pc_hdr(&ext_msg_pos, buf_ptr,
        &int_ptr->ext_chnasn.chns[num_recs]->gen.hdr);

#ifdef FEATURE_IS2000_REL_C
      /* ------------------------------------------------------------------
      ** Now we have to take a look at the Message Integrity fields if
      ** there is one.
      ** ------------------------------------------------------------------ */
      if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
           CAIX_MACI_NOT_REQUIRED, &ext_msg_pos,
           buf_ptr, &int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.msg_int,
           int_ptr->ext_chnasn.msg_type,
           int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.ack_req
           ))
           != CAIX_DONE_S)
      {
        return status;
      }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
      /* ------------------------------------------------------------------
      ** Now we have to take a look at the Extended Encryption fields if
      ** there is one, and run the decryption algorithm.
      ** ------------------------------------------------------------------ */
      if ((status = xlate_ext_ext_enc(&len, chn, pd, &ext_msg_pos, buf_ptr,
           &int_ptr->ext_chnasn.chns[num_recs]->gen.hdr, int_ptr->ext_chnasn.msg_type, 0, 0)) != CAIX_DONE_S)
      {
        return status;
      }
#endif /* FEATURE_IS2000_REL_A */

      /* ----------------------
      ** Unpack base of message
      ** ---------------------- */
      ext_msg_pos += FSIZ(cai_ext_chnasn_base_type, reserved1);

      add_record_len = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ext_chnasn_base_type, add_record_len));
      ext_msg_pos += FSIZ(cai_ext_chnasn_base_type, add_record_len);

#ifdef FEATURE_IS2000_REL_C
      if ( int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.msg_int.maci_incl )
      {
        /* ------------------------------------------------------------------
        ** Now we have to take a look at the MACI field itself
        ** ------------------------------------------------------------------ */
        maci_pos = ext_msg_pos + add_record_len * 8;


        /* Unpack the MACI for this record */
        int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.msg_int.maci =
                    b_unpackd(buf_ptr, maci_pos, FSIZ(cai_msg_int_type, maci));

      } /* if maci_incl */

#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
      if (int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.enc.enc_fields_incl)
      {
        /* ----------------------------------------------------------
        ** The message is encrypted, have to decrypt it first. The
        ** decryptor accepts the encryption fields, crypto text, and
        ** its start pointer, returns with plain text, and modified
        ** message length, so the parser can continue.
        ** ---------------------------------------------------------- */
        temp_len = add_record_len * 8;

        #ifdef FEATURE_IS2000_REL_A_AES

        if ( !mccaes_validate_sig_aes_mode(int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.enc.sdu_encrypt_mode) )
        {
          M1X_MSG( DCP, LEGACY_HIGH,
            "Invalid sdu_encrypt_mode %d",
            int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.enc.sdu_encrypt_mode);
          return CAIX_INV_ENC_MODE_NOT_SUP_S;
        }
        else if ( ( int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.enc.sdu_encrypt_mode != CAI_ENC_MODE_DISABLED ) &&
                  ( cdma.aes_status.c_sig_encrypt_mode == CAI_ENC_MODE_DISABLED )
                )
        {
          M1X_MSG( DCP, LEGACY_HIGH,
            "AES encryption not turned on yet, the message should have not been encrypted");
          return CAIX_INV_ENC_MODE_NOT_SUP_S;
        }

        /* now prepare RX_EXT_SSEQ for decryption purpose */


        /* ----------------------------------------------------------
         ** The message is encrypted, have to decrypt it first. The
         ** decryptor accepts the encryption fields, crypto text, and
         ** its start pointer, returns with plain text, and modified
         ** message length, so the parser can continue.
         ** ---------------------------------------------------------- */

        status = auth_ext_decrypt_cdma(buf_ptr,
                                       temp_len,
                                       ext_msg_pos,
                                       int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.enc.sdu_encrypt_mode,
                                       int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.ack_req,
                                       int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.enc.enc_seq,
                                       sdu_key_id,
                                       maci_incl
                                      );
        if ( status != CAIX_DONE_S )
        {
          return status;
        }

        #else
        if ( int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.enc.sdu_encrypt_mode != CAI_ENC_MODE_DISABLED )
        {
          return CAIX_INV_ENC_MODE_NOT_SUP_S;
        }
        #endif /* FEATURE_IS2000_REL_A_AES */
      } /* enc_fields_incl */
#endif /* FEATURE_IS2000_REL_A */

      UNPACKB_PG(ext_chnasn.chns[num_recs]->gen.assign_mode,
        cai_ext_chnasn_base_type, assign_mode);

      ext_msg_pos += FSIZ(cai_ext_chnasn_base_type, direct_ch_assign_ind);

      ext_msg_pos += FSIZ(cai_ext_chnasn_base_type, reserved2);

      old_ext_msg_pos = ext_msg_pos;

      /* -------------------------
      ** Switch on Assignment Mode
      ** ------------------------- */
      switch (int_ptr->ext_chnasn.chns[num_recs]->gen.assign_mode)
      {
        /* ASSIGN_MODE = '000' */
        case CAI_TRAFFIC_CHAN_ASSIGN:

          #define MTYPE cai_ext_chnasn_am0_type

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.freq_incl, MTYPE,
            freq_incl);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.default_config, MTYPE,
            default_config);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.bypass_alert_answer, MTYPE,
            bypass_alert_answer);

          ext_msg_pos += FSIZ(MTYPE, reserved);

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.num_pilots, MTYPE,
            num_pilots);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.granted_mode, MTYPE,
            granted_mode);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.frame_offset, MTYPE,
            frame_offset);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.encrypt_mode, MTYPE,
            encrypt_mode);

          my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, encrypt_mode);

          if (int_ptr->ext_chnasn.chns[num_recs]->am0.freq_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.band_class, MTYPE,
              band_class);
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am0.cdma_freq, MTYPE,
              cdma_freq);

            my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, cdma_freq);
          }

          for (i=0; i < int_ptr->ext_chnasn.chns[num_recs]->am0.num_pilots+1 &&
                    i < CAI_EXT_CHNASN_AM0_MAX; i++)
          {
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am0.pilot_rec[i].pilot_pn,
              MTYPE, pilot_pn);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.pilot_rec[i].pwr_comb_ind,
              MTYPE, pwr_comb_ind);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.pilot_rec[i].code_chan,
              MTYPE, code_chan);

            my_fendpos = (word) FENDPOS(caii_ext_chnasn_am0_type, pilot_rec[i]);
          }

          /* Length check on mandatory fields */
          min_len = FENDPOS( MTYPE, rev_fch_gating_mode ) -
                    FENDPOS( MTYPE, code_chan );
          temp_len = ext_msg_pos - old_ext_msg_pos;
          if ( ( ( temp_len + min_len ) % 8 ) > 0 )
          {
            min_len += 8 - ( temp_len + min_len ) % 8;
          }


          if ( ( ( ( add_record_len - 1 ) * 8 ) > temp_len ) &&
               ( ( ( add_record_len - 1 ) * 8 - temp_len ) >= min_len )
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.for_fch_rc, MTYPE,
              for_fch_rc);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.rev_fch_rc, MTYPE,
              rev_fch_rc);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.fpc_fch_init_setpt,
              MTYPE, fpc_fch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.fpc_subchan_gain,
              MTYPE, fpc_subchan_gain);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.rl_gain_adj,
              MTYPE, rl_gain_adj);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.fpc_fch_fer, MTYPE,
              fpc_fch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.fpc_fch_min_setpt,
              MTYPE, fpc_fch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.fpc_fch_max_setpt,
              MTYPE, fpc_fch_max_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.rev_fch_gating_mode,
              MTYPE, rev_fch_gating_mode);

            my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, rev_fch_gating_mode);

            if (int_ptr->ext_chnasn.chns[num_recs]->am0.rev_fch_gating_mode)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.rev_pwr_cntl_delay_incl,
                MTYPE, rev_pwr_cntl_delay_incl);

              my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, rev_pwr_cntl_delay_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am0.rev_pwr_cntl_delay_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.rev_pwr_cntl_delay,
                  MTYPE, rev_pwr_cntl_delay);

                my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, rev_pwr_cntl_delay);
              }
            }

#ifdef FEATURE_IS2000_REL_A
            /* Length check on mandatory fields */
            min_len = FSIZ( MTYPE, c_sig_encrypt_mode_incl );
            temp_len = ext_msg_pos - old_ext_msg_pos;
            if ( ( ( temp_len + min_len ) % 8 ) > 0 )
            {
              min_len += 8 - ( temp_len + min_len ) % 8;
            }

            if ( ( ( ( add_record_len - 1 ) * 8 ) > temp_len ) &&
                 ( ( ( add_record_len - 1 ) * 8 - temp_len ) >= min_len )
               )
            {
              if (int_ptr->ext_chnasn.chns[num_recs]->am0.encrypt_mode ==
                  CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.d_sig_encrypt_mode,
                  MTYPE, d_sig_encrypt_mode);

                my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, d_sig_encrypt_mode);
              }

              if ((int_ptr->ext_chnasn.chns[num_recs]->am0.encrypt_mode ==
                   CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG)||
                  (int_ptr->ext_chnasn.chns[num_recs]->am0.encrypt_mode ==
                   CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.enc_key_size, MTYPE,
                  enc_key_size);
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.c_sig_encrypt_mode_incl,
                MTYPE, c_sig_encrypt_mode_incl);

              my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, c_sig_encrypt_mode_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am0.c_sig_encrypt_mode_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.c_sig_encrypt_mode,
                  MTYPE, c_sig_encrypt_mode);

                my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, c_sig_encrypt_mode);
              }

#ifdef FEATURE_IS2000_REL_C
              /* Length check on mandatory fields */
              min_len = FSIZ( MTYPE,  plcm_type_incl );
              temp_len = ext_msg_pos - old_ext_msg_pos;
              if ( ( ( temp_len + min_len ) % 8 ) > 0 )
              {
                min_len += 8 - ( temp_len + min_len ) % 8;
              }

              if ( ( ( ( add_record_len - 1 ) * 8 ) > temp_len ) &&
                   ( ( ( add_record_len - 1 ) * 8 - temp_len ) >= min_len )
                 )
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.msg_int_info_incl,
                  MTYPE, msg_int_info_incl);

                if (int_ptr->ext_chnasn.chns[num_recs]->am0.msg_int_info_incl)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.change_keys, MTYPE,
                    change_keys);
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.use_uak, MTYPE,
                    use_uak);
                }

                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.plcm_type_incl,
                  MTYPE, plcm_type_incl);

                my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, plcm_type_incl);

                if (int_ptr->ext_chnasn.chns[num_recs]->am0.plcm_type_incl)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.plcm_type, MTYPE,
                    plcm_type);

                  my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, plcm_type);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am0.plcm_type ==
                      CAI_PLCM_TYPE_BS_SPEC)
                  {
                    UNPACKQ_PG(ext_chnasn.chns[num_recs]->am0.plcm_39, MTYPE,
                      plcm_39);

                    my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, plcm_39);
                  }
                }
              }
#endif /* FEATURE_IS2000_REL_C */

            }
#endif /* FEATURE_IS2000_REL_A */

            #undef MTYPE
          }

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += my_fendpos;

          break;

        /* ASSIGN_MODE = '001' */
        case CAI_PAGING_CHAN_ASSIGN:

          #define MTYPE cai_ext_chnasn_am1_type

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am1.respond, MTYPE, respond);

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am1.freq_incl, MTYPE, freq_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am1.freq_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am1.band_class, MTYPE, band_class);
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am1.cdma_freq, MTYPE, cdma_freq);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am1.num_pilots, MTYPE, num_pilots);

          my_fendpos = FENDPOS(caii_ext_chnasn_am1_type, num_pilots);

          for (i=0; i < int_ptr->ext_chnasn.chns[num_recs]->am1.num_pilots+1 &&
                    i < CAI_EXT_CHNASN_AM1_MAX; i++)
          {
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am1.pilot_pn[i], MTYPE, pilot_pn);
            my_fendpos = (word) FENDPOS(caii_ext_chnasn_am1_type, pilot_pn[i]);
          }

          #undef MTYPE

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += my_fendpos;
          break;

        /* ASSIGN_MODE = '010' */
        case CAI_ACQ_ANALOG_SYSTEM:

          #define MTYPE cai_ext_chnasn_am2_type

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am2.respond, MTYPE, respond);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am2.analog_sys, MTYPE, analog_sys);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am2.use_analog_sys, MTYPE, use_analog_sys);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am2.band_class, MTYPE, band_class);

          #undef MTYPE

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += FENDPOS(caii_ext_chnasn_am2_type, band_class);

          break;

        /* ASSIGN_MODE = '011' */
        case CAI_ANALOG_VCHAN_ASSIGN:

          #define MTYPE cai_ext_chnasn_am3_type

          UNPACKW_PG(ext_chnasn.chns[num_recs]->am3.sid, MTYPE, sid);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.vmac, MTYPE, vmac);
          UNPACKW_PG(ext_chnasn.chns[num_recs]->am3.analog_chan, MTYPE,
            analog_chan);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.scc, MTYPE, scc);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.mem, MTYPE, mem);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.an_chan_type, MTYPE,
            an_chan_type);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.dscc_msb, MTYPE, dscc_msb);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.band_class, MTYPE, band_class);

          #undef MTYPE

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += FENDPOS(caii_ext_chnasn_am3_type, band_class);
          break;

        /* ASSIGN_MODE = '100' */
        case CAI_EXT_TRAF_CHAN_ASSIGN:
        {
          word record_start_pos = 0, record_len = 0;

          #define MTYPE cai_ext_chnasn_am4_type

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.freq_incl, MTYPE, freq_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am4.freq_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.band_class, MTYPE,
              band_class);
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.cdma_freq, MTYPE,
              cdma_freq);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.bypass_alert_answer, MTYPE,
            bypass_alert_answer);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.granted_mode, MTYPE,
            granted_mode);

#ifdef FEATURE_IS2000_REL_C
          if (int_ptr->ext_chnasn.chns[num_recs]->am4.granted_mode ==
              CAI_GRANT_SRID_RESTORE)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.sr_id_restore, MTYPE,
              sr_id_restore);

          }
#endif /* FEATURE_IS2000_REL_C */

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.default_config, MTYPE,
            default_config);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.for_rc, MTYPE, for_rc);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.rev_rc, MTYPE, rev_rc);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.frame_offset, MTYPE,
            frame_offset);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.encrypt_mode, MTYPE,
            encrypt_mode);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.fpc_subchan_gain, MTYPE,
            fpc_subchan_gain);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.rlgain_adj, MTYPE,
            rlgain_adj);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.num_pilots, MTYPE,
            num_pilots);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_ind, MTYPE, ch_ind);

          my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, ch_ind);

          record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(MTYPE, ch_record_len));
          ext_msg_pos += FSIZ(MTYPE, ch_record_len);

          record_start_pos = ext_msg_pos;

          if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_ind == CAI_CHIND_FCH_ONLY)
          {
            #define IND_TYPE   cai_ext_ch_ind1_type
            #define IND_PRTYPE cai_ext_ch_ind1_pilot_rec_type

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fpc_fch_init_setpt,
              IND_TYPE, fpc_fch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fpc_fch_fer,
              IND_TYPE, fpc_fch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fpc_fch_min_setpt,
              IND_TYPE, fpc_fch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fpc_fch_max_setpt,
              IND_TYPE, fpc_fch_max_setpt);

            for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                      j<CAI_EXT_CHNASN_AM4_MAX; j++)
            {
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].pilot_pn,
                IND_PRTYPE, pilot_pn);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].add_pilot_rec_incl,
                IND_PRTYPE, add_pilot_rec_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].add_pilot_rec_incl)
              {
                word tmp_record_len = 0;
                word tmp_record_start_pos = 0;

                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].pilot_rec_type,
                  IND_PRTYPE, pilot_rec_type);

                tmp_record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(IND_PRTYPE, record_len));
                ext_msg_pos += FSIZ(IND_PRTYPE, record_len);

                tmp_record_start_pos = ext_msg_pos;

                xlate_add_pilot_rec(int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].pilot_rec_type,
                  buf_ptr, ext_msg_pos,
                  &int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].add_pilot_rec);
                ext_msg_pos = tmp_record_start_pos + tmp_record_len*8;
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].pwr_comb_ind,
                IND_PRTYPE, pwr_comb_ind);
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].code_chan_fch,
                IND_PRTYPE, code_chan_fch);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].qof_mask_id_fch,
                IND_PRTYPE, qof_mask_id_fch);
            }

            #undef IND_TYPE
            #undef IND_PRTYPE

#ifdef FEATURE_IS2000_REL_A
            if (((8 * record_len) > (ext_msg_pos - record_start_pos))
               )
            {
              #define X3_MTYPE cai_ext_ch_3x_fch_fix_type
              #define X3_VTYPE cai_ext_ch_3x_fch_var_type

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.x3_fch_info_incl,
                X3_MTYPE, x3_fch_info_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.x3_fch_info_incl)
              {
                for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                          j<CAI_EXT_CHNASN_AM4_MAX; j++)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].x3_fch_low_incl,
                    X3_VTYPE, x3_fch_low_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].x3_fch_low_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].qof_mask_id_fch_low,
                      X3_VTYPE, qof_mask_id_fch_low);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].code_chan_fch_low,
                      X3_VTYPE, code_chan_fch_low);
                  }

                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].x3_fch_high_incl,
                    X3_VTYPE, x3_fch_high_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].x3_fch_high_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].qof_mask_id_fch_high,
                      X3_VTYPE, qof_mask_id_fch_high);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].code_chan_fch_high,
                      X3_VTYPE, code_chan_fch_high);
                  }
                }
              }

              #undef X3_MTYPE
              #undef X3_VTYPE
            }
#endif /* FEATURE_IS2000_REL_A */

          }

          else if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_ind ==
                   CAI_CHIND_DCCH_ONLY)
          {
            #define IND_TYPE   cai_ext_ch_ind2_type
            #define IND_PRTYPE cai_ext_ch_ind2_pilot_rec_type

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.fpc_dcch_init_setpt,
              IND_TYPE,fpc_dcch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.fpc_dcch_fer,
              IND_TYPE,fpc_dcch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.fpc_dcch_min_setpt,
              IND_TYPE,fpc_dcch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.fpc_dcch_max_setpt,
              IND_TYPE,fpc_dcch_max_setpt);

            for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                      j<CAI_EXT_CHNASN_AM4_MAX; j++)
            {
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].pilot_pn,
                IND_PRTYPE, pilot_pn);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].add_pilot_rec_incl,
                IND_PRTYPE, add_pilot_rec_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].add_pilot_rec_incl)
              {
                word tmp_record_len = 0;
                word tmp_record_start_pos = 0;

                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].pilot_rec_type,
                  IND_PRTYPE, pilot_rec_type);

                tmp_record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(IND_PRTYPE,record_len));
                ext_msg_pos += FSIZ(IND_PRTYPE, record_len);

                tmp_record_start_pos = ext_msg_pos;

                xlate_add_pilot_rec(
                  int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].pilot_rec_type,
                  buf_ptr, ext_msg_pos,
                  &int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].add_pilot_rec);

                ext_msg_pos = tmp_record_start_pos + tmp_record_len*8;
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].pwr_comb_ind,
                IND_PRTYPE, pwr_comb_ind);
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].code_chan_dcch,
                IND_PRTYPE, code_chan_dcch);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].qof_mask_id_dcch,
                IND_PRTYPE, qof_mask_id_dcch);
            }

            #undef IND_TYPE
            #undef IND_PRTYPE

#ifdef FEATURE_IS2000_REL_A
            if (((8 * record_len) > (ext_msg_pos - record_start_pos))
               )
            {
              #define X3_MTYPE cai_ext_ch_3x_dcch_fix_type
              #define X3_VTYPE cai_ext_ch_3x_dcch_var_type

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.x3_dcch_info_incl,
                X3_MTYPE, x3_dcch_info_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.x3_dcch_info_incl)
              {
                for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                          j<CAI_EXT_CHNASN_AM4_MAX; j++)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].x3_dcch_low_incl,
                    X3_VTYPE, x3_dcch_low_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].x3_dcch_low_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].qof_mask_id_dcch_low,
                      X3_VTYPE, qof_mask_id_dcch_low);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].code_chan_dcch_low,
                      X3_VTYPE, code_chan_dcch_low);
                  }

                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].x3_dcch_high_incl,
                    X3_VTYPE, x3_dcch_high_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].x3_dcch_high_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].qof_mask_id_dcch_high,
                      X3_VTYPE, qof_mask_id_dcch_high);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].code_chan_dcch_high,
                      X3_VTYPE, code_chan_dcch_high);
                  }
                } /* end for */
              } /* end if (ind_ptr->x3_dcch_info_incl) */

              #undef X3_MTYPE
              #undef X3_VTYPE
            }
#endif /* FEATURE_IS2000_REL_A */

          }

          else if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_ind ==
                   CAI_CHIND_FCH_AND_DCCH)
          {
            #define IND_TYPE   cai_ext_ch_ind3_type
            #define IND_PRTYPE cai_ext_ch_ind3_pilot_rec_type

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_fch_init_setpt,
              IND_TYPE, fpc_fch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_dcch_init_setpt,
              IND_TYPE, fpc_dcch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_pri_chan,
              IND_TYPE, fpc_pri_chan);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_fch_fer,
              IND_TYPE, fpc_fch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_fch_min_setpt,
              IND_TYPE, fpc_fch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_fch_max_setpt,
              IND_TYPE, fpc_fch_max_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_dcch_fer,
              IND_TYPE, fpc_dcch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_dcch_min_setpt,
              IND_TYPE, fpc_dcch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_dcch_max_setpt,
              IND_TYPE, fpc_dcch_max_setpt);

            for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                      j<CAI_EXT_CHNASN_AM4_MAX; j++)
            {
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].pilot_pn,
                IND_PRTYPE, pilot_pn);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].add_pilot_rec_incl,
                IND_PRTYPE,add_pilot_rec_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].add_pilot_rec_incl)
              {
                word tmp_record_len = 0;
                word tmp_record_start_pos = 0;

                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].pilot_rec_type,
                  IND_PRTYPE, pilot_rec_type);

                tmp_record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(IND_PRTYPE, record_len));
                ext_msg_pos += FSIZ(IND_PRTYPE, record_len);

                tmp_record_start_pos = ext_msg_pos;

                xlate_add_pilot_rec(
                  int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].pilot_rec_type,
                  buf_ptr, ext_msg_pos,
                  &int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].add_pilot_rec);

                ext_msg_pos = tmp_record_start_pos + tmp_record_len*8;
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].pwr_comb_ind,
                IND_PRTYPE, pwr_comb_ind);
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].code_chan_fch,
                IND_PRTYPE, code_chan_fch);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].qof_mask_id_fch,
                IND_PRTYPE, qof_mask_id_fch);
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].code_chan_dcch,
                IND_PRTYPE, code_chan_dcch);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].qof_mask_id_dcch,
                IND_PRTYPE, qof_mask_id_dcch);
            }

            #undef IND_TYPE
            #undef IND_PRTYPE

#ifdef FEATURE_IS2000_REL_A
            if (((8 * record_len) > (ext_msg_pos - record_start_pos))
               )
            {
              #define X3_FTYPE cai_ext_ch_3x_fch_fix_type
              #define X3_VTYPE cai_ext_ch_3x_fch_var_type

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.x3_fch_info_incl,
                X3_FTYPE, x3_fch_info_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.x3_fch_info_incl)
              {
                for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                           j<CAI_EXT_CHNASN_AM4_MAX; j++)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].x3_fch_low_incl,
                    X3_VTYPE, x3_fch_low_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].x3_fch_low_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].qof_mask_id_fch_low,
                      X3_VTYPE, qof_mask_id_fch_low);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].code_chan_fch_low,
                      X3_VTYPE, code_chan_fch_low);
                  }

                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].x3_fch_high_incl,
                    X3_VTYPE, x3_fch_high_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].x3_fch_high_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].qof_mask_id_fch_high,
                      X3_VTYPE, qof_mask_id_fch_high);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].code_chan_fch_high,
                      X3_VTYPE, code_chan_fch_high);
                  }
                }
              }

              #undef X3_FTYPE
              #undef X3_VTYPE
            }

            if (((8 * record_len) > (ext_msg_pos - record_start_pos))
               )
            {
              #define X3_MTYPE cai_ext_ch_3x_dcch_fix_type
              #define X3_VTYPE cai_ext_ch_3x_dcch_var_type

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.x3_dcch_info_incl,
                X3_MTYPE, x3_dcch_info_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.x3_dcch_info_incl)
              {
                for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                          j<CAI_EXT_CHNASN_AM4_MAX; j++)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].x3_dcch_low_incl,
                    X3_VTYPE, x3_dcch_low_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].x3_dcch_low_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].qof_mask_id_dcch_low,
                      X3_VTYPE, qof_mask_id_dcch_low);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].code_chan_dcch_low,
                      X3_VTYPE, code_chan_dcch_low);
                  }

                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].x3_dcch_high_incl,
                    X3_VTYPE, x3_dcch_high_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].x3_dcch_high_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].qof_mask_id_dcch_high,
                      X3_VTYPE, qof_mask_id_dcch_high);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].code_chan_dcch_high,
                      X3_VTYPE, code_chan_dcch_high);
                  }
                } /* end for */
              } /* end if (ind_ptr->x3_dcch_info_incl) */

              #undef X3_FTYPE
              #undef X3_VTYPE
            }
#endif /* FEATURE_IS2000_REL_A */

          }

          ext_msg_pos = record_start_pos + record_len * 8;

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.rev_fch_gating_mode, MTYPE,
            rev_fch_gating_mode);

          my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, rev_fch_gating_mode);

          if (int_ptr->ext_chnasn.chns[num_recs]->am4.rev_fch_gating_mode)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.rev_pwr_cntl_delay_incl,
              MTYPE, rev_pwr_cntl_delay_incl);

            my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, rev_pwr_cntl_delay_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am4.rev_pwr_cntl_delay_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.rev_pwr_cntl_delay,
                MTYPE, rev_pwr_cntl_delay);

              my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, rev_pwr_cntl_delay);
            }
          }


          /* Length check on mandatory fields */
          min_len = FSIZ( MTYPE, c_sig_encrypt_mode_incl ) +
                    FSIZ( MTYPE, x3fl_1xrl_incl );

          if ( ( ( ( ( add_record_len - 1 ) * 8 ) -
                   ( ext_msg_pos - old_ext_msg_pos )
                 ) >= min_len
               )
             )
          {
            if (int_ptr->ext_chnasn.chns[num_recs]->am4.encrypt_mode ==
                CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.d_sig_encrypt_mode,
                MTYPE, d_sig_encrypt_mode);
            }

            if ((int_ptr->ext_chnasn.chns[num_recs]->am4.encrypt_mode ==
                 CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG) ||
                (int_ptr->ext_chnasn.chns[num_recs]->am4.encrypt_mode ==
                 CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.enc_key_size,
                MTYPE, enc_key_size);
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.c_sig_encrypt_mode_incl,
              MTYPE, c_sig_encrypt_mode_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am4.c_sig_encrypt_mode_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.c_sig_encrypt_mode,
                MTYPE, c_sig_encrypt_mode);
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.x3fl_1xrl_incl,
              MTYPE, x3fl_1xrl_incl);

            my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, x3fl_1xrl_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am4.x3fl_1xrl_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.x1rl_freq_offset,
                MTYPE, x1rl_freq_offset);

              my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, x1rl_freq_offset);
            }


            /* Length check on mandatory fields */
            min_len = FSIZ( MTYPE, plcm_type_incl );

            if ( ( ( ( ( add_record_len - 1 ) * 8 ) -
                       ( ext_msg_pos - old_ext_msg_pos )
                   ) >= min_len
                 )
               )
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.msg_int_info_incl,
                MTYPE, msg_int_info_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.msg_int_info_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.change_keys,
                  MTYPE, change_keys);
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.use_uak,
                  MTYPE, use_uak);
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.plcm_type_incl,
                MTYPE, plcm_type_incl);

              my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, plcm_type_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.plcm_type_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.plcm_type,
                  MTYPE, plcm_type);

                my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, plcm_type);

                if (int_ptr->ext_chnasn.chns[num_recs]->am4.plcm_type ==
                    CAI_PLCM_TYPE_BS_SPEC)
                {
                  UNPACKQ_PG(ext_chnasn.chns[num_recs]->am4.plcm_39, MTYPE,
                    plcm_39);

                  my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, plcm_39);
                }
              }
            }


          }

          #undef MTYPE

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += my_fendpos;
          break;
        }

#ifdef FEATURE_IS2000_REL_C
        /* ASSIGN_MODE = '101' */
        case CAI_PACKET_DATA_TRAF_CHAN_ASSIGN:
        {
          #define MTYPE cai_ext_chnasn_am5_type

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.freq_incl, MTYPE, freq_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.freq_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.band_class, MTYPE, band_class);
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am5.cdma_freq, MTYPE, cdma_freq);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.bypass_alert_answer, MTYPE,
            bypass_alert_answer);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.granted_mode, MTYPE,
            granted_mode);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.granted_mode ==
              CAI_GRANT_SRID_RESTORE)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.sr_id_restore, MTYPE,
              sr_id_restore);

          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.frame_offset, MTYPE,
            frame_offset);

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.encrypt_mode, MTYPE,
            encrypt_mode);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.encrypt_mode ==
              CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.d_sig_encrypt_mode,
              MTYPE, d_sig_encrypt_mode);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.encrypt_mode ==
               CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG) ||
              (int_ptr->ext_chnasn.chns[num_recs]->am5.encrypt_mode ==
               CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.enc_key_size,
              MTYPE, enc_key_size);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.c_sig_encrypt_mode_incl,
            MTYPE, c_sig_encrypt_mode_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.c_sig_encrypt_mode_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.c_sig_encrypt_mode,
              MTYPE, c_sig_encrypt_mode);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.msg_int_info_incl,
            MTYPE, msg_int_info_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.msg_int_info_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.change_keys,
              MTYPE, change_keys);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.use_uak,
              MTYPE, use_uak);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.plcm_type_incl,
            MTYPE, plcm_type_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.plcm_type_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.plcm_type,
              MTYPE, plcm_type);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.plcm_type ==
                CAI_PLCM_TYPE_BS_SPEC)
            {
              UNPACKQ_PG(ext_chnasn.chns[num_recs]->am5.plcm_39, MTYPE,
                plcm_39);
            }
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rlgain_adj,
            MTYPE, rlgain_adj);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.num_pilots,
            MTYPE, num_pilots);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.ext_ch_ind,
            MTYPE, ext_ch_ind);

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PF_F)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PD_D)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_FD)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_subchan_gain,
              MTYPE, fpc_subchan_gain);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PC_F)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_F)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_FD)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_fch_gating_mode,
              MTYPE, rev_fch_gating_mode);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.rev_fch_gating_mode)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_pwr_cntl_delay_incl,
                MTYPE, rev_pwr_cntl_delay_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am5.rev_pwr_cntl_delay_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_pwr_cntl_delay,
                  MTYPE, rev_pwr_cntl_delay);
              }
            }
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.full_ci_feedback_ind,
            MTYPE, full_ci_feedback_ind);

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_cqich_frame_offset,
            MTYPE, rev_cqich_frame_offset);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_cqich_reps,
            MTYPE, rev_cqich_reps);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_ackch_reps,
            MTYPE, rev_ackch_reps);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_rc,
            MTYPE, for_pdch_rc);

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PF_F)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PD_D)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_FD)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_fch_dcch_rc,
              MTYPE, for_fch_dcch_rc);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PC_F)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PC_D)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_F)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PD_D)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_FD)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_fch_dcch_rc,
              MTYPE, rev_fch_dcch_rc);
          }

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PFD_FD)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_pri_chan,
              MTYPE, fpc_pri_chan);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PF_F)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_FD)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_fch_init_setpt,
              MTYPE, fpc_fch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_fch_fer,
              MTYPE, fpc_fch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_fch_min_setpt,
              MTYPE, fpc_fch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_fch_max_setpt,
              MTYPE, fpc_fch_max_setpt);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PD_D)
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_dcch_init_setpt,
              MTYPE, fpc_dcch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_dcch_fer,
              MTYPE, fpc_dcch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_dcch_min_setpt,
              MTYPE, fpc_dcch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_dcch_max_setpt,
              MTYPE, fpc_dcch_max_setpt);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pdch_group_ind_incl,
            MTYPE, pdch_group_ind_incl);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parms_incl,
            MTYPE, for_pdch_parms_incl);

          my_fendpos = FENDPOS(caii_ext_chnasn_am5_type, for_pdch_parms_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.for_pdch_parms_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.for_pdch_rlgain_incl,
              MTYPE, for_pdch_rlgain_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.for_pdch_parm.for_pdch_rlgain_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.rlgain_ackch_pilot,
                MTYPE, rlgain_ackch_pilot);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.rlgain_cqich_pilot,
                MTYPE, rlgain_cqich_pilot);
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_soft_switching_frames,
              MTYPE, num_soft_switching_frames);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_softer_switching_frames,
              MTYPE, num_softer_switching_frames);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_soft_switching_slots,
              MTYPE, num_soft_switching_slots);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_softer_switching_slots,
              MTYPE, num_softer_switching_slots);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.chm_switching_params_incl,
              MTYPE, chm_switching_params_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.for_pdch_parm.chm_switching_params_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_soft_switching_frames_chm,
                MTYPE, num_soft_switching_frames_chm);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_softer_switching_frames_chm,
                MTYPE, num_softer_switching_frames_chm);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_soft_switching_slots_chm,
                MTYPE, num_soft_switching_slots_chm);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_softer_switching_slots_chm,
                MTYPE, num_softer_switching_slots_chm);
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.pdch_soft_switching_delay,
              MTYPE, pdch_soft_switching_delay);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.pdch_softer_switching_delay,
              MTYPE, pdch_softer_switching_delay);

            my_fendpos = FENDPOS(caii_ext_chnasn_am5_type,
              for_pdch_parm.pdch_softer_switching_delay);

          } /* end if (int_ptr->ext_chnasn.chns[num_recs]->am5.for_pdch_parms_incl) */

          #define VTYPE cai_ext_chnasn_pilot_info_type

          for (i=0; i<int_ptr->ext_chnasn.chns[num_recs]->am5.num_pilots+1 &&
                    i<CAI_EXT_CHNASN_AM5_MAX; i++)
          {
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].pilot_pn,
              VTYPE, pilot_pn);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].add_pilot_rec_incl,
              VTYPE, add_pilot_rec_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].add_pilot_rec_incl)
            {
              word tmp_record_len = 0;
              word tmp_record_start_pos = ext_msg_pos;

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].pilot_rec_type,
                VTYPE, pilot_rec_type);

              tmp_record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(VTYPE, record_len));
              ext_msg_pos += FSIZ(VTYPE, record_len);

              tmp_record_start_pos = ext_msg_pos;

              xlate_add_pilot_rec(
                int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].pilot_rec_type,
                buf_ptr, ext_msg_pos,
                &int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].add_pilot_rec);

              ext_msg_pos = tmp_record_start_pos + tmp_record_len * 8;
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_pdch_incl,
              VTYPE, for_pdch_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_pdch_incl)
            {
              if (int_ptr->ext_chnasn.chns[num_recs]->am5.for_pdch_parms_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].walsh_table_id,
                  VTYPE, walsh_table_id);
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].num_pdcch,
                  VTYPE, num_pdcch);

                for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].num_pdcch+1 &&
                          j<CAI_EXT_CHNASN_AM5_MAX; j++)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_pdcch_walsh[j],
                    VTYPE, for_pdcch_walsh);
                }
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].mac_id,
                VTYPE, mac_id);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].rev_cqich_cover,
                VTYPE, rev_cqich_cover);
            } /* end if (int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_pdch_incl) */

            if ((((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                   CAI_EXT_CHIND_PC_F)
                  || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                      CAI_EXT_CHIND_PC_D)
                 )
                 && (int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_pdch_incl)
                )
               )
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_cpcch_walsh,
                VTYPE, for_cpcch_walsh);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_cpcsch,
                VTYPE, for_cpcsch);
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].pwr_comb_ind,
              VTYPE, pwr_comb_ind);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.pdch_group_ind_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].pdch_group_ind,
                VTYPE, pdch_group_ind);
            }

            if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                 CAI_EXT_CHIND_PF_F)
                || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                    CAI_EXT_CHIND_PF_FD)
                || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                    CAI_EXT_CHIND_PFD_FD)
               )
            {
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].code_chan_fch,
                VTYPE, code_chan_fch);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].qof_mask_id_fch,
                VTYPE, qof_mask_id_fch);
            }

            if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                 CAI_EXT_CHIND_PD_D)
                || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                    CAI_EXT_CHIND_PFD_FD)
               )
            {
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].code_chan_dcch,
                VTYPE, code_chan_dcch);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].qof_mask_id_dcch,
                VTYPE, qof_mask_id_dcch);
            }

            my_fendpos = (word) FENDPOS(caii_ext_chnasn_am5_type, pilot_rec[i]);

          } /* for loop */

          #undef VTYPE

          #undef MTYPE

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += my_fendpos;
          break;
        }

#endif /* FEATURE_IS2000_REL_C */

        default:
          M1X_MSG( DCP, LEGACY_MED,
            "Unknown ASSIGN_MODE %d",
            int_ptr->ext_chnasn.chns[num_recs]->gen.assign_mode );
          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          break;
      } /* end of switch */

#ifdef FEATURE_IS2000_REL_C
      /* ----------------------------------------
      ** Adjust order_pos according to MACI field
      ** ---------------------------------------- */
      if (int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.msg_int.maci_incl)
      {
        ext_msg_pos += FSIZ(cai_msg_int_type, maci);
      }
#endif /* FEATURE_IS2000_REL_C */

      num_recs++;

      if( num_recs < CAI_EXT_CHN_ASN_MAX )
      {
        int_buf_ptr = (byte *)ALIGN_DWORD((dword)int_buf_ptr);
        int_ptr->ext_chnasn.chns[num_recs] =
          (caii_ext_ca_ord_type*)int_buf_ptr;
      }
      else
      {
        /* ----------------------------------------------------
        ** num_recs is too big, stop processing and return
        ** ---------------------------------------------------- */
        M1X_MSG( DCP, LEGACY_HIGH,
          "Too many ECAM records");
        break;
      }

      if ((CAII_MAX_EXT_CHNASN_MSG_BUF_SIZ -
           (int_buf_ptr - int_ptr->ext_chnasn.buf)) < CAII_MAX_INT_ECAM_SIZ)
      {
        /* ----------------------------------------------------------------
        ** Because we have reserved worst case plus CAII_MAX_INT_ECAM_SIZ,
        ** if the empty space left is less than the headroom, we either
        ** under-estimated the worst case or something else went wrong.
        ** ---------------------------------------------------------------- */
        M1X_MSG( DCP, LEGACY_ERROR,
          "Buf is too small for this ECAM");
        break;
      }
    } /* end while */

    int_ptr->ext_chnasn.num_chns = num_recs;
  }

  return (status);

} /* xlate_ext_ext_chn_asn */

/*===========================================================================

FUNCTION XLATE_EXT_GEN_NL

DESCRIPTION
  This function translates a Paging Channel General Neighbor List Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the General Neighbor List message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_gen_nl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos;
    /* Bit offset in variable portion of message */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word min_len;
    /* Protocol dependent minimum length requirement */
  word i;
    /* Index for looping through neighbors */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_gen_nghbr_msg_type

  /* Minimum size is size of fixed type, minus all the dependant fields */
  if (len < CAI_GEN_NGHBR_MIN )
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* ---------------------------------------------------------------
    ** Length is ok - convert message from external to internal format
    ** starting with the first field after message_type
    ** --------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(gen_nghbr.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(gen_nghbr.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKB_PG(gen_nghbr.pilot_inc, MTYPE, pilot_inc);
    UNPACKB_PG(gen_nghbr.nghbr_srch_mode, MTYPE, nghbr_srch_mode);
    UNPACKB_PG(gen_nghbr.nghbr_config_pn_incl, MTYPE, nghbr_config_pn_incl);
    UNPACKB_PG(gen_nghbr.freq_fields_incl, MTYPE, freq_fields_incl);
    UNPACKB_PG(gen_nghbr.use_timing, MTYPE, use_timing);

    /*--------------------------------------------------------------- */
    /* Unpack dependent fields of fixed type                          */
    /*--------------------------------------------------------------- */
    if (int_ptr->gen_nghbr.use_timing)
    {
     UNPACKB_PG(gen_nghbr.global_timing_incl, MTYPE, global_timing_incl);

     if (int_ptr->gen_nghbr.global_timing_incl)
     {
       UNPACKB_PG(gen_nghbr.global_tx_duration, MTYPE, global_tx_duration);
       UNPACKB_PG(gen_nghbr.global_tx_period, MTYPE, global_tx_period);
     }
    }

    UNPACKB_PG(gen_nghbr.num_nghbr, MTYPE, num_nghbr);

    /*----------------------------------------------------------------- */
    /* Unpack variable type (cdma neighbors)                            */
    /*----------------------------------------------------------------- */
    for (i=0; i < int_ptr->gen_nghbr.num_nghbr && i < CAI_GEN_NGHBR_MAX; i++)
    {
      if (int_ptr->gen_nghbr.nghbr_config_pn_incl)
      {
        UNPACKB_PG(gen_nghbr.nghbr[i].nghbr_config, MTYPE, nghbr_config);
        UNPACKW_PG(gen_nghbr.nghbr[i].nghbr_pn, MTYPE, nghbr_pn);
      }

      if( int_ptr->gen_nghbr.nghbr_srch_mode == SRCH_PRI_AND_WIN ||
            int_ptr->gen_nghbr.nghbr_srch_mode == SRCH_PRI_ONLY )
      {
        UNPACKB_PG(gen_nghbr.nghbr[i].search_pri, MTYPE, search_pri);
      }

      if ((int_ptr->gen_nghbr.nghbr_srch_mode == SRCH_PRI_AND_WIN) ||
          (int_ptr->gen_nghbr.nghbr_srch_mode == SRCH_WIN_ONLY))
      {
        UNPACKB_PG(gen_nghbr.nghbr[i].srch_win_nghbr, MTYPE, srch_win_nghbr);
      }

      if (int_ptr->gen_nghbr.freq_fields_incl)
      {
        UNPACKB_PG(gen_nghbr.nghbr[i].freq_incl, MTYPE, freq_incl);

        /* Check if neighbor freq and band are included */
        /* for this set.                                */
        if (int_ptr->gen_nghbr.nghbr[i].freq_incl)
        {
          UNPACKB_PG(gen_nghbr.nghbr[i].nghbr_band, MTYPE, nghbr_band);
          UNPACKW_PG(gen_nghbr.nghbr[i].nghbr_freq, MTYPE, nghbr_freq);
        }
      }

      if (int_ptr->gen_nghbr.use_timing)
      {
        UNPACKB_PG(gen_nghbr.nghbr[i].timing_incl, MTYPE, timing_incl);

        /* Include timing information */
        if (int_ptr->gen_nghbr.nghbr[i].timing_incl)
        {
          UNPACKB_PG(gen_nghbr.nghbr[i].nghbr_tx_offset, MTYPE, nghbr_tx_offset );

          /* Only include if global_timing_incl is set to zero. */
          if ( !(int_ptr->gen_nghbr.global_timing_incl) )
          {
            UNPACKB_PG(gen_nghbr.nghbr[i].nghbr_tx_duration, MTYPE, nghbr_tx_duration);

            UNPACKB_PG(gen_nghbr.nghbr[i].nghbr_tx_period, MTYPE, nghbr_tx_period);
          }
        }
      }

      /* ----------------------------------------------------
      ** If NGHBR_CONFIGr is equal to '000', '001', or '010',
      ** then NGHBR_CONFIGs = NGHBR_CONFIGr, otherwise,
      ** NGHBR_CONFIGs = '011'.
      ** ---------------------------------------------------- */
      if (int_ptr->gen_nghbr.nghbr[i].nghbr_config > 3)
      {
        int_ptr->gen_nghbr.nghbr[i].nghbr_config = 3;
      }
    }  /* End num_neighbor occurences of a cdma neighbor record */

    UNPACKB_PG(gen_nghbr.num_analog_nghbr, MTYPE, num_analog_nghbr);

    /* Num_analog_neighbr occurrences of the following record */
    for (i=0; i < int_ptr->gen_nghbr.num_analog_nghbr &&
              i < CAI_GEN_ANALOG_NGHBR_MAX; i++)
    {
      UNPACKB_PG(gen_nghbr.analog_nghbr[i].band_class, MTYPE, band_class);
      UNPACKB_PG(gen_nghbr.analog_nghbr[i].sys_a_b, MTYPE, sys_a_b);
    } /* End num_analog_nghbr occurences of the prev. record. */

    /* Check length for mandatory fields and minimum reserved bits */
    min_len = ( int_ptr->gen_nghbr.num_nghbr * FSIZ( MTYPE, add_pilot_rec_incl ) ) +
              FSIZ( MTYPE, srch_offset_incl );
    if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
    {
      min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
    }

    if ( ( ( len - ext_msg_pos ) >= min_len )
#ifdef FEATURE_IS2000_REL_A
         && ( cdma.mob_cai_rev >= P_REV_IS2000 )
#endif /* FEATURE_IS2000_REL_A */
       )
    {
      word j;

      int_ptr->gen_nghbr.is2000_incl = TRUE;
      UNPACKB_PG(gen_nghbr.srch_offset_incl, MTYPE, srch_offset_incl);

      for (j=0; j<int_ptr->gen_nghbr.num_nghbr && j<CAI_GEN_NGHBR_MAX; j++)
      {
        UNPACKB_PG(gen_nghbr.add_nghbr[j].add_pilot_rec_incl, MTYPE,
          add_pilot_rec_incl);

        if (int_ptr->gen_nghbr.add_nghbr[j].add_pilot_rec_incl)
        {
          word record_len = 0;
          word record_start_pos = 0;

          UNPACKB_PG(gen_nghbr.add_nghbr[j].nghbr_pilot_rec_type, MTYPE, nghbr_pilot_rec_type);

          record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(MTYPE, record_len));
          ext_msg_pos += FSIZ(MTYPE, record_len);

          record_start_pos = ext_msg_pos;
          xlate_add_pilot_rec(int_ptr->gen_nghbr.add_nghbr[j].nghbr_pilot_rec_type,
                              buf_ptr, ext_msg_pos,
                              &(int_ptr->gen_nghbr.add_nghbr[j].add_pilot_rec));
          ext_msg_pos = record_start_pos + record_len*8;
        }

        if (int_ptr->gen_nghbr.srch_offset_incl)
        {
          UNPACKB_PG(gen_nghbr.add_nghbr[j].srch_offset_nghbr, MTYPE, srch_offset_nghbr);
        }
      }

#ifdef FEATURE_IS2000_REL_A
      /* Check length for mandatory fields and minimum reserved bits */
      min_len = FSIZ( MTYPE, bcch_ind_incl );
      if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
      {
        min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
      }

      if ( ( ( len - ext_msg_pos ) >= min_len )
#ifdef FEATURE_IS2000_REL_A
           && ( cdma.mob_cai_rev >= P_REV_IS2000_REL_A )
#endif /* FEATURE_IS2000_REL_A */
         )
      {
        int_ptr->gen_nghbr.is2000_rel_a_incl = TRUE;
        UNPACKB_PG(gen_nghbr.bcch_ind_incl, MTYPE, bcch_ind_incl);

        if (int_ptr->gen_nghbr.bcch_ind_incl)
        {
          for (j=0; j<int_ptr->gen_nghbr.num_nghbr && j<CAI_GEN_NGHBR_MAX; j++)
          {
            UNPACKB_PG(gen_nghbr.bcch_support[j], MTYPE, bcch_support);
          }
        }
      }
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
      /* Check length for mandatory fields and minimum reserved bits */
      min_len = FSIZ( MTYPE, resq_enabled );
      if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
      {
        min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
      }

      if ( ( ( len - ext_msg_pos ) >= min_len )
#ifdef FEATURE_IS2000_REL_A
           && ( cdma.mob_cai_rev >= P_REV_IS2000_REL_B )
#endif /* FEATURE_IS2000_REL_A */
         )
      {
        int_ptr->gen_nghbr.is2000_rel_b_incl = TRUE;

        UNPACKB_PG(gen_nghbr.resq_enabled, MTYPE, resq_enabled);

        if (int_ptr->gen_nghbr.resq_enabled)
        {
          UNPACKB_PG(gen_nghbr.resq_delay_time, MTYPE, resq_delay_time);
          UNPACKB_PG(gen_nghbr.resq_allowed_time, MTYPE, resq_allowed_time);
          UNPACKB_PG(gen_nghbr.resq_attempt_time , MTYPE, resq_attempt_time);
          UNPACKW_PG(gen_nghbr.resq_code_chan, MTYPE, resq_code_chan);
          UNPACKB_PG(gen_nghbr.resq_qof, MTYPE, resq_qof);
          UNPACKB_PG(gen_nghbr.resq_min_period_incl, MTYPE, resq_min_period_incl);

          if (int_ptr->gen_nghbr.resq_min_period_incl)
          {
            UNPACKB_PG(gen_nghbr.resq_min_period, MTYPE, resq_min_period);
          }

          UNPACKB_PG(gen_nghbr.resq_num_tot_trans_incl, MTYPE, resq_num_tot_trans_incl);

          if (int_ptr->gen_nghbr.resq_num_tot_trans_incl)
          {
            UNPACKB_PG(gen_nghbr.resq_num_tot_trans_20ms, MTYPE, resq_num_tot_trans_20ms);
            UNPACKB_PG(gen_nghbr.resq_num_tot_trans_5ms, MTYPE, resq_num_tot_trans_5ms);
          }

          UNPACKB_PG(gen_nghbr.resq_num_preamble_rc1_rc2, MTYPE, resq_num_preamble_rc1_rc2);
          UNPACKB_PG(gen_nghbr.resq_num_preamble, MTYPE, resq_num_preamble);
          UNPACKB_PG(gen_nghbr.resq_power_delta, MTYPE, resq_power_delta);

          for (j=0; j<int_ptr->gen_nghbr.num_nghbr && j<CAI_GEN_NGHBR_MAX; j++)
          {
            UNPACKB_PG(gen_nghbr.nghbr_resq_configured[j], MTYPE, nghbr_resq_configured);
          }
        }
      }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      /* Check length for mandatory fields and minimum reserved bits */
      min_len = ( int_ptr->gen_nghbr.num_nghbr * FSIZ( MTYPE, nghbr_pdch_supported) ) +
                FSIZ( MTYPE, hrpd_nghbr_incl );
      if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
      {
        min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
      }

      if ( ( ( len - ext_msg_pos ) >= min_len )
#ifdef FEATURE_IS2000_REL_A
           && ( cdma.mob_cai_rev >= P_REV_IS2000_REL_C )
#endif /* FEATURE_IS2000_REL_A */
         )
      {
        uint8 hrpd_nghbr_rec_len;
        word old_ext_msg_pos;

        int_ptr->gen_nghbr.is2000_rel_c_incl = TRUE;

        for (j=0; j<int_ptr->gen_nghbr.num_nghbr && j<CAI_GEN_NGHBR_MAX; j++)
        {
          UNPACKB_PG(gen_nghbr.nghbr_pdch_supported[j], MTYPE, nghbr_pdch_supported);
        }

        UNPACKB_PG(gen_nghbr.hrpd_nghbr_incl, MTYPE, hrpd_nghbr_incl);

        if (int_ptr->gen_nghbr.hrpd_nghbr_incl)
        {
          UNPACKB_PG(gen_nghbr.num_hrpd_nghbr, MTYPE, num_hrpd_nghbr);

          for (j=0; j<int_ptr->gen_nghbr.num_hrpd_nghbr && j<CAI_GEN_NGHBR_MAX; j++)
          {
            old_ext_msg_pos = ext_msg_pos;

            hrpd_nghbr_rec_len = b_unpackb(buf_ptr, ext_msg_pos,
              FSIZ(MTYPE, hrpd_nghbr_rec_len));
            ext_msg_pos += FSIZ(MTYPE, hrpd_nghbr_rec_len);

            UNPACKW_PG(gen_nghbr.hrpd_nghbr[j].nghbr_pn, MTYPE, nghbr_pn);
            UNPACKB_PG(gen_nghbr.hrpd_nghbr[j].nghbr_freq_incl, MTYPE, nghbr_freq_incl);

            if (int_ptr->gen_nghbr.hrpd_nghbr[j].nghbr_freq_incl)
            {
              UNPACKB_PG(gen_nghbr.hrpd_nghbr[j].nghbr_band, MTYPE, nghbr_band);
              UNPACKW_PG(gen_nghbr.hrpd_nghbr[j].nghbr_freq, MTYPE, nghbr_freq);
            }

            UNPACKB_PG(gen_nghbr.hrpd_nghbr[j].pn_association_ind, MTYPE, pn_association_ind);
            UNPACKB_PG(gen_nghbr.hrpd_nghbr[j].data_association_ind, MTYPE, data_association_ind);

            ext_msg_pos = old_ext_msg_pos + (hrpd_nghbr_rec_len + 1) * 8;
          }
        }
      }
#endif /* FEATURE_IS2000_REL_C */

    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_gen_nl */

/*===========================================================================

FUNCTION XLATE_EXT_E_GLB_REDIR_REC

DESCRIPTION
  This function translates a ESGRM redirection record from external to
  internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Global Service Redirection message
  type.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

void xlate_ext_e_glb_redir_rec
(
  word record_type,
    /* Type of redirection record */
  word len,
    /* Length of message in bits */
  word pos,
    /* Position of record in message */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_ext_glb_redir_rec_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos = pos;
    /* Position of record in message */
  word i;
    /* Index */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (record_type)
  {
    case CAI_ANALOG_REDIRECTION_REC:
    {
      #define RMTYPE cai_redirect_rec1_type

      UNPACKW_PG(rec1.expected_sid, RMTYPE, expected_sid);
      UNPACKB_PG(rec1.ignore_cdma, RMTYPE, ignore_cdma);
      UNPACKB_PG(rec1.sys_ordering, RMTYPE, sys_ordering);
      UNPACKB_PG(rec1.max_redirect_delay, RMTYPE, max_redirect_delay);

      #undef RMTYPE

      break;
    }

    case CAI_CDMA_REDIRECTION_REC:
    {
      #define RMTYPE cai_redirect_rec2_type

      UNPACKB_PG(rec2.band_class, RMTYPE, band_class);
      UNPACKW_PG(rec2.expected_sid, RMTYPE, expected_sid);
      UNPACKW_PG(rec2.expected_nid, RMTYPE, expected_nid);
      ext_msg_pos += FSIZ(RMTYPE, reserved);

      UNPACKB_PG(rec2.num_chans, RMTYPE, num_chans);

      for (i=0; i < int_ptr->rec2.num_chans && i < CAI_MAX_CDMA_CHANS; i++)
      {
        UNPACKW_PG(rec2.cdma_chan[i], RMTYPE, cdma_chan);
      }

      #undef RMTYPE

      break;
    }

    default:
    {
      M1X_MSG( DCP, LEGACY_MED,
        "Invalid rec type %d",
        record_type );
      break;
    }

  } /* end of switch */

} /* xlate_ext_e_glb_redir_rec */

/*===========================================================================

FUNCTION XLATE_EXT_E_GLB_REDIR

DESCRIPTION
  This function translates a Paging Channel Extended Global Service Redirection
  Message (EGSRM) from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Global Service Redirection message
  type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_e_glb_redir
(
  word len,
    /* Length of message in bits */
    /*lint -esym(715,len) */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
  byte record_len;


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ext_glb_redir_msg_type

  /* -------------------------------------------------
  ** Start translating message at field after msg_type
  ** ------------------------------------------------- */
  ext_msg_pos = FSIZ(MTYPE, msg_type);

  UNPACKW_PG(egsrm.pilot_pn, MTYPE, pilot_pn);
  UNPACKB_PG(egsrm.config_msg_seq, MTYPE, config_msg_seq);
  UNPACKW_PG(egsrm.first.redirect_accolc, MTYPE, redirect_accolc);
  UNPACKB_PG(egsrm.return_if_fail, MTYPE, return_if_fail);
  UNPACKB_PG(egsrm.first.delete_tmsi, MTYPE, delete_tmsi);
  UNPACKB_PG(egsrm.first.redirect_p_rev_incl, MTYPE, redirect_p_rev_incl);

  if (int_ptr->egsrm.first.redirect_p_rev_incl)
  {
    UNPACKB_PG(egsrm.first.excl_p_rev_ind, MTYPE, excl_p_rev_ind);
    UNPACKB_PG(egsrm.first.redirect_p_min, MTYPE, redirect_p_min);
    UNPACKB_PG(egsrm.first.redirect_p_max, MTYPE, redirect_p_max);
  }

  UNPACKB_PG(egsrm.first.record_type, MTYPE, record_type);

  record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(MTYPE, record_len));
  ext_msg_pos += FSIZ(MTYPE, record_len);

  xlate_ext_e_glb_redir_rec(int_ptr->egsrm.first.record_type, len, ext_msg_pos,
    buf_ptr, &int_ptr->egsrm.first.redir);
  ext_msg_pos += record_len * 8;

  #undef MTYPE

  return (status);

} /* xlate_ext_e_glb_redir */

/*===========================================================================

FUNCTION XLATE_EXT_E_CL

DESCRIPTION
  This function translates an Extended CDMA Channel List Message (ECCLM) from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the ExtendedCDMA Channel List message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_e_cl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
#ifdef FEATURE_IS2000_REL_A
  word min_len;
    /* Protocol dependent minimum length requirement */
#endif /* FEATURE_IS2000_REL_A */
  word i;
    /* Index for looping through channels */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_ext_chnlist_msg_type

  if ( len < CAI_EXT_CHNLIST_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(ecclm.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(ecclm.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKB_PG(ecclm.num_freq, MTYPE, num_freq);

    for (i=0; i < int_ptr->ecclm.num_freq &&
              i < CAI_EXT_CHNLIST_FREQ_MAX; i++)
    {
      UNPACKW_PG(ecclm.cdma_freq[i], MTYPE, cdma_freq);
    }

    UNPACKB_PG(ecclm.rc_qpch_sel_incl, MTYPE, rc_qpch_sel_incl);

    if (int_ptr->ecclm.rc_qpch_sel_incl)
    {
      for (i=0; i < int_ptr->ecclm.num_freq &&
                i < CAI_EXT_CHNLIST_FREQ_MAX; i++)
      {
        UNPACKB_PG(ecclm.rc_qpch_hash_ind[i], MTYPE, rc_qpch_hash_ind );
      }
    }

#ifdef FEATURE_IS2000_REL_A
    /* Length check on mandatory fields + minimim reserved bits */
    min_len = FSIZ( MTYPE, td_sel_incl );
    if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
    {
      min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
    }

    if ( ( ( len - ext_msg_pos ) >= min_len )
#ifdef FEATURE_IS2000_REL_A
         && ( cdma.mob_cai_rev >= CAIX_P_REV_IS2000_REL_A )
#endif /* FEATURE_IS2000_REL_A */
       )
    {
      int_ptr->ecclm.is2000_rel_a_incl = TRUE;

      UNPACKB_PG(ecclm.td_sel_incl, MTYPE, td_sel_incl);

      if (int_ptr->ecclm.td_sel_incl)
      {
        UNPACKB_PG(ecclm.td_mode, MTYPE, td_mode);

        for (i=0; i < int_ptr->ecclm.num_freq &&
                  i < CAI_EXT_CHNLIST_FREQ_MAX; i++)
        {
          UNPACKB_PG(ecclm.td_sel[i].td_hash_ind, MTYPE, td_hash_ind);
          if (int_ptr->ecclm.td_sel[i].td_hash_ind)
          {
            UNPACKB_PG(ecclm.td_sel[i].td_power_level, MTYPE, td_power_level);
          }
        }
      }

    }
#endif /* FEATURE_IS2000_REL_A */

  }

  #undef MTYPE

  return (status);

} /* xlate_ext_e_cl */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_EXT_SMCM

DESCRIPTION
  This function translates the Security Mode Command Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_smcm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position in message relative to start of buf_ptr */
  #ifdef FEATURE_IS2000_REL_C
  word min_len;
    /* Protocol dependent length check */
  #endif /* FEATURE_IS2000_REL_C */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ext_msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&ext_msg_pos, buf_ptr, &int_ptr->smcm.hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
       CAIX_MACI_REQUIRED, &ext_msg_pos,
       buf_ptr, &int_ptr->smcm.hdr.msg_int, int_ptr->smcm.msg_type,
       int_ptr->smcm.hdr.ack_req
       ))
       != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &ext_msg_pos, buf_ptr,
       &int_ptr->smcm.hdr, int_ptr->smcm.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define MTYPE cai_sec_mode_cmd_msg_type

  UNPACKB_PG(smcm.c_sig_encrypt_mode, MTYPE, c_sig_encrypt_mode);

  if ((int_ptr->smcm.c_sig_encrypt_mode == CAI_ENC_MODE_ECMEA) ||
      (int_ptr->smcm.c_sig_encrypt_mode == CAI_ENC_MODE_REA))
  {
    UNPACKB_PG(smcm.enc_key_size, MTYPE, enc_key_size);
  }

#ifdef FEATURE_IS2000_REL_C
  /* Minimum length check */
  min_len = FSIZ(MTYPE, msg_int_info_incl);
  if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
  {
    min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
  }

  if ( ( len - ext_msg_pos ) >= min_len )
  {
    int_ptr->smcm.is2000_rel_c_incl = TRUE;

    UNPACKB_PG(smcm.msg_int_info_incl, MTYPE, msg_int_info_incl);

    if (int_ptr->smcm.msg_int_info_incl)
    {
      UNPACKB_PG(smcm.change_keys, MTYPE, change_keys);
      UNPACKB_PG(smcm.use_uak, MTYPE, use_uak);
    }
  }
#endif /* FEATURE_IS2000_REL_C */

  #undef MTYPE

  return (status);

}  /* xlate_ext_smcm */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_EXT_AUTH_REQ

DESCRIPTION
  This function translates the Authentication Request Message from external
  to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_auth_req
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------------------------------------
  ** Length is ok - finish converting message from external to internal
  ** format starting with the first field after message_type
  ** ------------------------------------------------------------------ */
  msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->auth_req.hdr);

  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
       CAIX_MACI_NOT_REQUIRED, &msg_pos,
       buf_ptr, &int_ptr->auth_req.hdr.msg_int,
       int_ptr->auth_req.msg_type,
       int_ptr->auth_req.hdr.ack_req
       ))
      != CAIX_DONE_S)
  {
    return status;
  }

  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
      &int_ptr->auth_req.hdr, int_ptr->auth_req.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }

  #define FTYPE cai_auth_req_type

  b_unpackq(buf_ptr, msg_pos, FSIZ(FTYPE, randa)/2, int_ptr->auth_req.randa_hi);
  msg_pos += FSIZ(FTYPE, randa) / 2;

  b_unpackq(buf_ptr, msg_pos, FSIZ(FTYPE, randa)/2, int_ptr->auth_req.randa_lo);
  msg_pos += FSIZ(FTYPE, randa) / 2;

  b_unpackq(buf_ptr, msg_pos, FSIZ(FTYPE, con_sqn), int_ptr->auth_req.con_sqn);
  msg_pos += FSIZ(FTYPE, con_sqn);

  int_ptr->auth_req.amf = b_unpackw(buf_ptr, msg_pos, FSIZ(FTYPE, amf));
  msg_pos += FSIZ(FTYPE, amf);

  b_unpackq(buf_ptr, msg_pos, FSIZ(FTYPE, mac_a), int_ptr->auth_req.mac_a);
  msg_pos += FSIZ(FTYPE, mac_a);

  #undef FTYPE

  return (status);

}  /* xlate_ext_auth_req */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_1X_ADV
/*===========================================================================

FUNCTION XLATE_EXT_PC_GEN_EXTN

DESCRIPTION
  This function translates a PCH/FCCCH General Extension Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_gen_extn
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through array */
  word ext_msg_pos;
    /* Position in message relative to start of buf_ptr */
  word layer2_end_pos;
    /* Position of end of layer 2 header */
  word temp_msg_pos;
    /* Temporary message position in buffer */
  byte pd_and_msg_type;
  word len_msg; /* Length of the message to be translated */
  word buf_pos; /* Position in buffer to be packed */
  word n = 0, n_bits = 0;
  uint8 val_8 = 0;
  uint8 *s_addr_l3 = NULL;


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in macro
  ** ----------------------------------- */
  #define FTYPE cai_gen_extn_msg_fix_type

  /* ---------------------------------------
  ** Check length to make sure it is correct
  ** --------------------------------------- */
  if ( len < (sizeof(cai_pc_hdr_type) + sizeof(FTYPE)) )
  {
    status = CAIX_INV_LEN_S;
    return (status);
  }

  ext_msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&ext_msg_pos, buf_ptr, &int_ptr->pc_gem.hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one. Also validate MACI.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
       CAIX_MACI_REQUIRED, &ext_msg_pos,
       buf_ptr, &int_ptr->pc_gem.hdr.msg_int, int_ptr->pc_gem.msg_type,
       int_ptr->pc_gem.hdr.ack_req
         ))
      != CAIX_DONE_S)
  {
    return (status);
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &ext_msg_pos, buf_ptr,
       &int_ptr->pc_gem.hdr, int_ptr->pc_gem.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return (status);
  }
#endif /* FEATURE_IS2000_REL_A */

  layer2_end_pos = ext_msg_pos;

  UNPACKB_PG(pc_gem.num_ge_rec, FTYPE, num_ge_rec);

  if(int_ptr->pc_gem.num_ge_rec > CAI_MAX_NUM_GE_REC)
  {
    M1X_MSG( DCP, LEGACY_HIGH,
      "Currently more than %d GEM records not supported",
      CAI_MAX_NUM_GE_REC);
    /* Return from here because even if we continue and parse the first record
     * while ignoring the rest, the parsing after exiting the for loop would be 
     * incorrect.
     */
    status = CAIX_INV_LEN_S;
    return (status);      
  }

  for ( i = 0; i < int_ptr->pc_gem.num_ge_rec && i < CAI_MAX_NUM_GE_REC; i++ )
  {
    UNPACKB_PG(pc_gem.gen_extn_rec[i].ge_rec_type, cai_gen_extn_rec_type, ge_rec_type);
    UNPACKB_PG(pc_gem.gen_extn_rec[i].ge_rec_len, cai_gen_extn_rec_type, ge_rec_len);

    if ( len < (ext_msg_pos +
                 int_ptr->pc_gem.gen_extn_rec[i].ge_rec_len) )
    {
      status = CAIX_INV_LEN_S;
      return (status);
    }

    switch(int_ptr->pc_gem.gen_extn_rec[i].ge_rec_type)
    {
      case CAI_GE_REC_REV_CHN_INFO:
      {
        UNPACKB_PG(pc_gem.gen_extn_rec[i].ge_rec.rev_chn_info.band_class, cai_ge_rec_rev_chn_type, band_class);
        UNPACKW_PG(pc_gem.gen_extn_rec[i].ge_rec.rev_chn_info.rev_chan, cai_ge_rec_rev_chn_type, rev_chan);
        break;
      }
      case CAI_GE_REC_RADIO_CONFIG_PARAMS:
      {
        /* Adding this check to ensure negative len is not passed to
         * xlate_ext_rcp */
        if (len < ext_msg_pos)
        {
            M1X_MSG ( DCP, LEGACY_MED,
              "GEM : %d bits extra eaten up. Something wrong in parsing!!",
               ext_msg_pos - len);
            status = CAIX_INV_MSG_S;
            return (status);        
        }          
        temp_msg_pos = ext_msg_pos;
        /* Translate the RCP record fields carried in GEM */
        if ((status = xlate_ext_rcp((len - ext_msg_pos),
              &ext_msg_pos, buf_ptr,
              &(int_ptr->pc_gem.gen_extn_rec[i].ge_rec.rcp))) != CAIX_DONE_S)
        {
          M1X_MSG( DCP, LEGACY_ERROR,
            "Translating Radio config param record, Status = %d",
            status);
          return (status);
        }
        ext_msg_pos += ((ext_msg_pos - temp_msg_pos)%8 != 0) ?
                        (8 - (ext_msg_pos - temp_msg_pos)%8) : 0;
        break;
      }
      default:
      {
        M1X_MSG( DCP, LEGACY_ERROR,
          "Unknown general record type %d",
          int_ptr->pc_gem.gen_extn_rec[i].ge_rec_type);
        return (status);
      }
    }
  } /* for */

  UNPACKB_PG(pc_gem.message_type, FTYPE, message_type);

  if(int_ptr->pc_gem.message_type == CAI_PC_GEN_EXTN_MSG)
  {
    M1X_MSG( DCP, LEGACY_ERROR,
      "GEM itself can not be extended by GEM");
    status = CAIX_INV_MSG_S;
    return (status);
  }

  #undef FTYPE

  /* Overwrite the L3 part of GEM with the L3 message being extended.
   * It will facilitate to use existing PC messages translation functions.
   */
  {
    /* Combine protocol descriminator (2 bits) and msg_type (6 bits) */
    pd_and_msg_type = int_ptr->pc_gem.message_type;
    pd_and_msg_type |= ( (pd << 6) & 0xC0 );

    /* Overwrite PD and message type */
    b_packb( pd_and_msg_type, buf_ptr, FPOS( cai_pc_hdr_type, msg_type ),
             FSIZ( cai_pc_hdr_type, msg_type ));

    if ( (int_ptr->pc_gem.message_type == CAI_EXT_CHN_ASN_MSG) ||
         (int_ptr->pc_gem.message_type == CAI_MEID_EXT_CHN_ASN_MSG) )
    {
      byte add_record_len;

      b_packb(0, buf_ptr, layer2_end_pos, FSIZ(cai_ext_chnasn_base_type, reserved1));
      layer2_end_pos += FSIZ(cai_ext_chnasn_base_type, reserved1);

      /* Adding this check to ensure add_record_length does not get 
       * assigned a negative value */
      if (len < ext_msg_pos)
      {
        M1X_MSG ( DCP, LEGACY_MED,
          "GEM : %d bits extra eaten up. Something wrong in parsing!!",
          ext_msg_pos - len);
        status = CAIX_INV_MSG_S;
        return (status);        
      }      
      add_record_len = ((len - ext_msg_pos)%8 == 0) ?
                  ((len - ext_msg_pos)/8) : ((len - ext_msg_pos)/8 + 1);
      b_packb(add_record_len, buf_ptr, layer2_end_pos,
                     FSIZ(cai_ext_chnasn_base_type, add_record_len));
      layer2_end_pos += FSIZ(cai_ext_chnasn_base_type, add_record_len);
    }

    /* Adding this check to ensure len_msg does not get 
     * assigned a negative value */
    if (len + layer2_end_pos < ext_msg_pos)
    {
        M1X_MSG ( DCP, LEGACY_MED,
          "GEM : %d bits extra eaten up. Something wrong in parsing!!",
          (ext_msg_pos - (len + layer2_end_pos)));
        status = CAIX_INV_MSG_S;
        return (status);        
    }        
    len_msg = len - ext_msg_pos + layer2_end_pos;
    buf_pos = layer2_end_pos;

    /* Copy the bits from Message Rec field in 3 steps.
       1) Copy the bits before next octet boundary in input bit stream
       2) Copy remaining bits in steps of octets from input bit stream
       3) Copy further remaining bits in last octet, if any.
    */
    /* Step 1 */
    /* buf_ptr points to beginning of bit stream and ext_msg_pos points to last
       parsed so far */
    /*lint -save -e702 */
    if (ext_msg_pos%8 != 0)
    {
      n_bits = 8 - (ext_msg_pos%8);
      s_addr_l3 = buf_ptr + ext_msg_pos/8; /* start address of the byte currently being parsed */
      val_8 = *s_addr_l3; /* 8 bit value of the byte currently being parsed */
      val_8 = (val_8 << (8 - n_bits)) >> (8 - n_bits); /* masking already parsed bits */
      b_packb( val_8, buf_ptr, buf_pos, n_bits);
      ext_msg_pos += n_bits;
      buf_pos += n_bits;
    }


    /* Adding this check to ensure temp_msg_pos does not get 
     * assigned a negative value */
    if (len < ext_msg_pos)
    {
        M1X_MSG ( DCP, LEGACY_MED,
          "GEM : %d bits extra eaten up. Something wrong in parsing!!",
           ext_msg_pos - len);
        status = CAIX_INV_MSG_S;
        return (status);        
    }         
    /* Step 2 */
    temp_msg_pos = len - ext_msg_pos;
    for (n = 0; n < temp_msg_pos/8; n++)
    {
      s_addr_l3 = buf_ptr + ext_msg_pos/8;
      val_8 = *s_addr_l3;
      b_packb( val_8, buf_ptr, buf_pos, 8);
      ext_msg_pos += 8;
      buf_pos += 8;
    }

    /* Step 3. Generally it should not be required. */
    if (ext_msg_pos < len)
    {
      if( (len - ext_msg_pos) > 2)
      {
        M1X_MSG( DCP, LEGACY_MED,
          "%d bits remaining. Message length not in octets!",
          len - ext_msg_pos);
      }

      n_bits = len - ext_msg_pos;
      s_addr_l3 = buf_ptr + ext_msg_pos/8;
      val_8 = *s_addr_l3;
      val_8 = val_8 >> (8 - n_bits);
      b_packb( val_8, buf_ptr, buf_pos, n_bits);
      ext_msg_pos += n_bits;
      buf_pos += n_bits;
    }
    else if (ext_msg_pos > len)
    {
      M1X_MSG( DCP, LEGACY_MED,
        "GEM : %d bits extra eaten up. Something wrong in parsing!!",
        ext_msg_pos - len);
      status = CAIX_INV_MSG_S;
      return (status);
    }
    /* lint -restore */

    /* Translate the message extended through GEM */
    if( caii_gem_message_rec_ptr != NULL )
    {
      int_ptr->pc_gem.message_rec = (byte*)(caii_gem_message_rec_ptr);
      if(chn == CAIX_PC)
      {
        status = xlate_ext_pch_msg(len_msg, (byte*)buf_ptr, caii_gem_message_rec_ptr);
      }
      else
      {
        M1X_MSG( DCP, LEGACY_ERROR,
          "GEM not received on PCH/FCCCH???");
        status = CAIX_INV_CHN_S;
      }
    }
    else
    {
      M1X_MSG( DCP, LEGACY_ERROR,
        "caii_gem_message_rec_ptr is NULL and returning status:%d",
        status);
      return (status);
    }
  }

  return (status);
} /* xlate_ext_pc_gen_extn */
#endif /* FEATURE_IS2000_1X_ADV */

#ifdef FEATURE_1X_TO_LTE

/*===========================================================================

FUNCTION XLATE_EXT_TC_ALT_TECH_INFO

DESCRIPTION
  This function translates an Alternative Technologies Information Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the ANSI-41 Sys Parm type

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_tc_alt_tech_info(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
 word chn
    /* Physical Channel this message is received on */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos = 0;
    /* Position of record in message */
  word radio_iface_start_pos;
    /* Start position of the current radio interface being translated */
  #ifdef FEATURE_1X_SPLMN_SUPPORT
  word min_len;
  /* Protocol dependent minimum length requirement */
  #endif /* FEATURE_1X_SPLMN_SUPPORT */
  byte i,j,k;
    /* Looping index*/

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < FENDPOS( cai_tc_alt_tech_info_msg_type, num_radio_interface))
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_atim.hdr);

    ext_msg_pos = FENDPOS(cai_tc_alt_tech_info_msg_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &ext_msg_pos, buf_ptr, &int_ptr->tc_atim.hdr.msg_int,
         int_ptr->tc_atim.msg_type,
         int_ptr->tc_atim.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &ext_msg_pos, buf_ptr,
          &int_ptr->tc_atim.hdr, int_ptr->tc_atim.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {

        UNPACKB_PG(tc_atim.num_radio_interface, cai_alt_tech_info_msg_type, num_radio_interface);

        for(i=0; (i < int_ptr->tc_atim.num_radio_interface) &&
            (i < MAX_NUM_RADIO_INTERFACE); i++)
        {
          UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface_type, cai_radio_interface_rec_type, radio_interface_type);
          UNPACKW_PG(tc_atim.radio_interface_rec[i].radio_interface_len, cai_radio_interface_rec_type, radio_interface_len);
          if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface_type != RADIO_INTERFACE_EUTRAN_TYPE)
          {
            ext_msg_pos += int_ptr->tc_atim.radio_interface_rec[i].radio_interface_len * 8;
            continue;
          }
          radio_iface_start_pos = ext_msg_pos;

          UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.pri_inc, cai_radio_interface_type, pri_inc);
          if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.pri_inc)
          {
            UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.pri, cai_radio_interface_type, pri);
          }
          else
          {
            int_ptr->tc_atim.radio_interface_rec[i].radio_interface.pri = 0;
          }
          UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.thresh_srv, cai_radio_interface_type, thresh_srv);
          UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.perearfcn_params_inc, cai_radio_interface_type, perearfcn_params_inc);
          if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.perearfcn_params_inc == 0)
          {
            UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_common, cai_radio_interface_type, rx_lev_min_eutra_common);
            if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_common > MAX_RX_LEV_MIN_EUTRA_COMMON)
            {
              status = CAIX_INV_MSG_S;
              return status;
            }
            UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.pe_max_common, cai_radio_interface_type, pe_max_common);
            UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common_inc, cai_radio_interface_type, rx_lev_min_eutra_off_common_inc);
            if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common_inc)
            {
              UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common, cai_radio_interface_type, rx_lev_min_eutra_off_common);
            }
            else
            {
              int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common = 0;
            }
          }
          else
          {
            int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_common = 0;
            int_ptr->tc_atim.radio_interface_rec[i].radio_interface.pe_max_common = 0;
      int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common_inc = 0;
      int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common = 0;
          }
          UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.max_resel_timer_inc, cai_radio_interface_type, max_resel_timer_inc);
          if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.max_resel_timer_inc)
          {
            UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.max_resel_timer, cai_radio_interface_type, max_resel_timer);
          }
          else
          {
            int_ptr->tc_atim.radio_interface_rec[i].radio_interface.max_resel_timer = 0;
          }

          UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.srch_backoff_timer_inc, cai_radio_interface_type, srch_backoff_timer_inc);
          if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.srch_backoff_timer_inc)
          {
            UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.min_meas_back_off, cai_radio_interface_type, min_meas_back_off);
            UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.max_meas_back_off, cai_radio_interface_type, max_meas_back_off);
          }
          else
          {
            int_ptr->tc_atim.radio_interface_rec[i].radio_interface.min_meas_back_off = 0;
            int_ptr->tc_atim.radio_interface_rec[i].radio_interface.max_meas_back_off = 0;
          }
          UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.plmnid_inc, cai_radio_interface_type, plmnid_inc);
          UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.num_eutra_freq, cai_radio_interface_type, num_eutra_freq);
          for(j=0; j < int_ptr->tc_atim.radio_interface_rec[i].radio_interface.num_eutra_freq; j++)
          {
            UNPACKW_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].earfcn, cai_eutra_freq_type, earfcn);
            if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.pri_inc)
            {
              UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].earfcn_pri, cai_eutra_freq_type, earfcn_pri);
            }
            else
            {
              int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].earfcn_pri = 0;
            }

            UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].thresh_x, cai_eutra_freq_type, thresh_x);
            if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.perearfcn_params_inc)
            {
              UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra, cai_eutra_freq_type, rx_lev_min_eutra);
              if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra > MAX_RX_LEV_MIN_EUTRA_COMMON)
              {
                status = CAIX_INV_MSG_S;
                return status;
              }
              UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].pe_max, cai_eutra_freq_type, pe_max);
              UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset_inc, cai_eutra_freq_type, rx_lev_min_eutra_offset_inc);
              if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset_inc)
              {
                UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset, cai_eutra_freq_type, rx_lev_min_eutra_offset);
              }
              else
              {
                int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset = 0;
              }
            }
            else
            {
              int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra = 0;
              int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].pe_max = 0;
              int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset_inc = 0;
              int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset = 0;
            }
            UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].meas_band_width, cai_eutra_freq_type, meas_band_width);
            if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.plmnid_inc)
            {
              UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].plmn_same_as_prev_chn, cai_eutra_freq_type, plmn_same_as_prev_chn);
            }
            else
            {
              int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].plmn_same_as_prev_chn = 0;
            }
            if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.plmnid_inc == 0)
            {
              int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].num_plmnids = 0;
            }
            else if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].plmn_same_as_prev_chn == 0)
            {
              UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].num_plmnids, cai_eutra_freq_type, num_plmnids);
              for(k=0; k < int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].num_plmnids + 1; k++)
              {
                UNPACKD_PG(tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].plmnid[k].plmn, cai_plmnid_type, plmn);
              }
            }
            else
            {
              if(j == 0)
              {
                status = CAIX_INV_MSG_S;
                return status;
              }
              else
              {
                int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].num_plmnids = 
                  int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j-1].num_plmnids;
            
                for(k=0; k < int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].num_plmnids + 1; k++)
                {
                  int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j].plmnid[k].plmn =
                    int_ptr->tc_atim.radio_interface_rec[i].radio_interface.eutra_freq[j-1].plmnid[k].plmn;              
                }
              }   
            }

          } /* for(j=0; j < int_ptr->tc_atim.radio_interface_rec[i].radio_interface.num_eutra_freq; j++)*/

        #ifdef FEATURE_1X_SPLMN_SUPPORT
          
          int_ptr->tc_atim.radio_interface_rec[i].radio_interface.splmn_inc = 0;
          int_ptr->tc_atim.radio_interface_rec[i].radio_interface.num_splmnids = 0;
          int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc = 0;
          int_ptr->tc_atim.radio_interface_rec[i].radio_interface.qual_min_eutra_common = 0;
          int_ptr->tc_atim.radio_interface_rec[i].radio_interface.qual_min_eutra_offset_common_inc = 0;
          int_ptr->tc_atim.radio_interface_rec[i].radio_interface.qual_min_eutra_offset_common = 0;
        
          min_len = FSIZ(cai_radio_interface_type, splmn_inc);
          if ( ( int_ptr->tc_atim.radio_interface_rec[i].radio_interface_len*8 - (ext_msg_pos - radio_iface_start_pos)) >= min_len )
          {
            UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.splmn_inc, cai_radio_interface_type, splmn_inc);   
            if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.splmn_inc)
            {
               UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.num_splmnids, cai_radio_interface_type, num_splmnids);
               for(k=0; k < int_ptr->tc_atim.radio_interface_rec[i].radio_interface.num_splmnids + 1; k++)
               {
                 UNPACKD_PG(tc_atim.radio_interface_rec[i].radio_interface.splmnid[k].splmn, cai_splmnid_type, splmn);
               }
            } /* if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.splmn_inc) */

            min_len = FSIZ(cai_radio_interface_type, rsrq_parms_inc);
            if ( ( int_ptr->tc_atim.radio_interface_rec[i].radio_interface_len*8 - (ext_msg_pos - radio_iface_start_pos)) >= min_len )
            {
              UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc, cai_radio_interface_type, rsrq_parms_inc);

              if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc &&
                !int_ptr->tc_atim.radio_interface_rec[i].radio_interface.perearfcn_params_inc)
              {
                UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.qual_min_eutra_common, 
                           cai_radio_interface_type, qual_min_eutra_common);
                UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.qual_min_eutra_offset_common_inc, 
                           cai_radio_interface_type, qual_min_eutra_offset_common_inc);                
                
                if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.qual_min_eutra_offset_common_inc)
                {
                  UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.qual_min_eutra_offset_common,
                             cai_radio_interface_type, qual_min_eutra_offset_common);
                }
              } /* if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc && */
              else if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc &&
                      int_ptr->tc_atim.radio_interface_rec[i].radio_interface.perearfcn_params_inc)
              {
                for(j=0; j < int_ptr->tc_atim.radio_interface_rec[i].radio_interface.num_eutra_freq; j++)
                {
        
                  UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.qual_eutra_freq[j].thresh_xq, 
                             cai_qual_eutra_freq_type, thresh_xq); 
                  UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.qual_eutra_freq[j].qual_min_eutra, 
                             cai_qual_eutra_freq_type, qual_min_eutra);
                  UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.qual_eutra_freq[j].qual_min_eutra_offset_inc, 
                             cai_qual_eutra_freq_type, qual_min_eutra_offset_inc);
                  if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.qual_eutra_freq[j].qual_min_eutra_offset_inc)        
                  {
                    UNPACKB_PG(tc_atim.radio_interface_rec[i].radio_interface.qual_eutra_freq[j].qual_min_eutra_offset, 
                             cai_qual_eutra_freq_type, qual_min_eutra_offset);
                  }
                } /* for(j=0; j < int_ptr->tc_atim.radio_interface_rec[i].radio_interface.num_eutra_freq; j++)*/
              } /* else if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc && */
            } /* if ( ( int_ptr->tc_atim.radio_interface_rec[i].radio_interface_len*8 - */
          } /* if ( ( int_ptr->tc_atim.radio_interface_rec[i].radio_interface_len*8 - */
        #endif /* FEATURE_1X_SPLMN_SUPPORT */
          if(int_ptr->tc_atim.radio_interface_rec[i].radio_interface_len*8 - (ext_msg_pos - radio_iface_start_pos) < 0)
          {
            M1X_MSG( DCP, LEGACY_HIGH, 
                "Invalid tc ATIM msg, rec_len=%d, start_pos=%d, ext_msg_pos=%d",
                 int_ptr->tc_atim.radio_interface_rec[i].radio_interface_len*8, 
                 radio_iface_start_pos, ext_msg_pos );
            status = CAIX_INV_MSG_S;
            return status;
          }
          ext_msg_pos += int_ptr->tc_atim.radio_interface_rec[i].radio_interface_len*8 - (ext_msg_pos - radio_iface_start_pos);

        } /* for(i=0; i < int_ptr->tc_atim.num_radio_interface; i++) */
      }
    }
  }

  return (status);

}


/*===========================================================================

FUNCTION XLATE_EXT_ALT_TECH_INFO

DESCRIPTION
  This function translates an Alternative Technologies Information Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the ANSI-41 Sys Parm type

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_alt_tech_info
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
 word chn
    /* Physical Channel this message is received on */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
  word radio_iface_start_pos;
    /* Start position of the current radio interface being translated */
  #ifdef FEATURE_1X_SPLMN_SUPPORT
  word min_len;
  /* Protocol dependent minimum length requirement */
  #endif /* FEATURE_1X_SPLMN_SUPPORT */  
  byte i,j,k;
    /* Looping index*/
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -------------------------------------------------
  ** Start translating message at field after msg_type
  ** ------------------------------------------------- */
  ext_msg_pos = FSIZ(cai_alt_tech_info_msg_type, msg_type);

  UNPACKW_PG(atim.pilot_pn, cai_alt_tech_info_msg_type, pilot_pn);
  UNPACKB_PG(atim.config_msg_seq, cai_alt_tech_info_msg_type, config_msg_seq);

  UNPACKB_PG(atim.num_radio_interface, cai_alt_tech_info_msg_type, num_radio_interface);

  for(i=0; (i < int_ptr->atim.num_radio_interface) && (i < MAX_NUM_RADIO_INTERFACE); i++)
  {
    UNPACKB_PG(atim.radio_interface_rec[i].radio_interface_type, cai_radio_interface_rec_type, radio_interface_type);
    UNPACKW_PG(atim.radio_interface_rec[i].radio_interface_len, cai_radio_interface_rec_type, radio_interface_len);
    if(int_ptr->atim.radio_interface_rec[i].radio_interface_type != RADIO_INTERFACE_EUTRAN_TYPE)
    {
      ext_msg_pos += int_ptr->atim.radio_interface_rec[i].radio_interface_len * 8 ;
      continue;
    }
    radio_iface_start_pos = ext_msg_pos;

    UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.pri_inc, cai_radio_interface_type, pri_inc);
    if(int_ptr->atim.radio_interface_rec[i].radio_interface.pri_inc)
    {
      UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.pri, cai_radio_interface_type, pri);
    }
    else
    {
      int_ptr->atim.radio_interface_rec[i].radio_interface.pri = 0;
    }
    UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.thresh_srv, cai_radio_interface_type, thresh_srv);
    UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.perearfcn_params_inc, cai_radio_interface_type, perearfcn_params_inc);
    if(int_ptr->atim.radio_interface_rec[i].radio_interface.perearfcn_params_inc == 0)
    {
      UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_common, cai_radio_interface_type, rx_lev_min_eutra_common);
      if(int_ptr->atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_common > MAX_RX_LEV_MIN_EUTRA_COMMON)
      {
        status = CAIX_INV_MSG_S;
        return status;
      }
      UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.pe_max_common, cai_radio_interface_type, pe_max_common);
      UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common_inc, cai_radio_interface_type, rx_lev_min_eutra_off_common_inc);
      if(int_ptr->atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common_inc)
      {
        UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common, cai_radio_interface_type, rx_lev_min_eutra_off_common);
      }
      else
      {
        int_ptr->atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common = 0;
      }
    }
    else
    {
      int_ptr->atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_common = 0;
      int_ptr->atim.radio_interface_rec[i].radio_interface.pe_max_common = 0;
      int_ptr->atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common_inc = 0;
      int_ptr->atim.radio_interface_rec[i].radio_interface.rx_lev_min_eutra_off_common = 0;
    }
    UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.max_resel_timer_inc, cai_radio_interface_type, max_resel_timer_inc);
    if(int_ptr->atim.radio_interface_rec[i].radio_interface.max_resel_timer_inc)
    {
      UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.max_resel_timer, cai_radio_interface_type, max_resel_timer);
    }
    else
    {
      int_ptr->atim.radio_interface_rec[i].radio_interface.max_resel_timer = 0;
    }

    UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.srch_backoff_timer_inc, cai_radio_interface_type, srch_backoff_timer_inc);
    if(int_ptr->atim.radio_interface_rec[i].radio_interface.srch_backoff_timer_inc)
    {
      UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.min_meas_back_off, cai_radio_interface_type, min_meas_back_off);
      UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.max_meas_back_off, cai_radio_interface_type, max_meas_back_off);
    }
    else
    {
      int_ptr->atim.radio_interface_rec[i].radio_interface.min_meas_back_off = 0;
      int_ptr->atim.radio_interface_rec[i].radio_interface.max_meas_back_off = 0;
    }
    UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.plmnid_inc, cai_radio_interface_type, plmnid_inc);
    UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.num_eutra_freq, cai_radio_interface_type, num_eutra_freq);
    for(j=0; j < int_ptr->atim.radio_interface_rec[i].radio_interface.num_eutra_freq; j++)
    {
      UNPACKW_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].earfcn, cai_eutra_freq_type, earfcn);
      if(int_ptr->atim.radio_interface_rec[i].radio_interface.pri_inc)
      {
        UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].earfcn_pri, cai_eutra_freq_type, earfcn_pri);
      }
      else
      {
        int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].earfcn_pri = 0;
      }

      UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].thresh_x, cai_eutra_freq_type, thresh_x);
      if(int_ptr->atim.radio_interface_rec[i].radio_interface.perearfcn_params_inc)
      {
        UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra, cai_eutra_freq_type, rx_lev_min_eutra);
        if(int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra > MAX_RX_LEV_MIN_EUTRA_COMMON)
        {
          status = CAIX_INV_MSG_S;
          return status;
        }
        UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].pe_max, cai_eutra_freq_type, pe_max);
        UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset_inc, cai_eutra_freq_type, rx_lev_min_eutra_offset_inc);
        if(int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset_inc)
        {
          UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset, cai_eutra_freq_type, rx_lev_min_eutra_offset);
        }
        else
        {
          int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset = 0;
        }
      }
      else
      {
        int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra = 0;
        int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].pe_max = 0;
        int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset_inc = 0;
        int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].rx_lev_min_eutra_offset = 0;
      }
      UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].meas_band_width, cai_eutra_freq_type, meas_band_width);
      if(int_ptr->atim.radio_interface_rec[i].radio_interface.plmnid_inc)
      {
        UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].plmn_same_as_prev_chn, cai_eutra_freq_type, plmn_same_as_prev_chn);
      }
      else
      {
        int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].plmn_same_as_prev_chn = 0;
      }

      if(int_ptr->atim.radio_interface_rec[i].radio_interface.plmnid_inc == 0)
      {
        int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].num_plmnids = 0;
      }
      else if(int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].plmn_same_as_prev_chn == 0)
      {
        UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].num_plmnids, cai_eutra_freq_type, num_plmnids);
        for(k=0; k < int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].num_plmnids + 1; k++)
        {
          UNPACKD_PG(atim.radio_interface_rec[i].radio_interface.eutra_freq[j].plmnid[k].plmn, cai_plmnid_type, plmn);
        }
      }
      else
      {
        if(j == 0)
        {
          status = CAIX_INV_MSG_S;
          return status;
        }
        else
        {
          int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].num_plmnids =
            int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j-1].num_plmnids;

          for(k=0; k < int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].num_plmnids + 1; k++)
          {
            int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j].plmnid[k].plmn =
              int_ptr->atim.radio_interface_rec[i].radio_interface.eutra_freq[j-1].plmnid[k].plmn;
          }
        }
      }
    } /* for(j=0; j < int_ptr->atim.radio_interface_rec[i].radio_interface.num_eutra_freq; j++)*/

  #ifdef FEATURE_1X_SPLMN_SUPPORT

    int_ptr->atim.radio_interface_rec[i].radio_interface.splmn_inc = 0;
    int_ptr->atim.radio_interface_rec[i].radio_interface.num_splmnids = 0;
    int_ptr->atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc = 0;
    int_ptr->atim.radio_interface_rec[i].radio_interface.qual_min_eutra_common = 0;
    int_ptr->atim.radio_interface_rec[i].radio_interface.qual_min_eutra_offset_common_inc = 0;
    int_ptr->atim.radio_interface_rec[i].radio_interface.qual_min_eutra_offset_common = 0;    
    
    min_len = FSIZ(cai_radio_interface_type, splmn_inc);
    if ( ( int_ptr->atim.radio_interface_rec[i].radio_interface_len*8 - (ext_msg_pos - radio_iface_start_pos)) >= min_len )
    {
      UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.splmn_inc, cai_radio_interface_type, splmn_inc);   
      if(int_ptr->atim.radio_interface_rec[i].radio_interface.splmn_inc)
      {
         UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.num_splmnids, cai_radio_interface_type, num_splmnids);
         for(k=0; k < int_ptr->atim.radio_interface_rec[i].radio_interface.num_splmnids + 1; k++)
         {
           UNPACKD_PG(atim.radio_interface_rec[i].radio_interface.splmnid[k].splmn, cai_splmnid_type, splmn);
         }
      } /* if(int_ptr->atim.radio_interface_rec[i].radio_interface.splmn_inc) */

      min_len = FSIZ(cai_radio_interface_type, rsrq_parms_inc);
      if ( ( int_ptr->atim.radio_interface_rec[i].radio_interface_len*8 - (ext_msg_pos - radio_iface_start_pos)) >= min_len )
      {
        UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc, cai_radio_interface_type, rsrq_parms_inc);

        if(int_ptr->atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc &&
          !int_ptr->atim.radio_interface_rec[i].radio_interface.perearfcn_params_inc)
        {
          UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.qual_min_eutra_common, 
                     cai_radio_interface_type, qual_min_eutra_common);
          UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.qual_min_eutra_offset_common_inc, 
                     cai_radio_interface_type, qual_min_eutra_offset_common_inc);

          if(int_ptr->atim.radio_interface_rec[i].radio_interface.qual_min_eutra_offset_common_inc)
          {
            UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.qual_min_eutra_offset_common,
                       cai_radio_interface_type, qual_min_eutra_offset_common);
          }
        } /* if(int_ptr->atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc && */
        else if(int_ptr->atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc &&
                int_ptr->atim.radio_interface_rec[i].radio_interface.perearfcn_params_inc)
        {
          for(j=0; j < int_ptr->atim.radio_interface_rec[i].radio_interface.num_eutra_freq; j++)
          {

            UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.qual_eutra_freq[j].thresh_xq, 
                       cai_qual_eutra_freq_type, thresh_xq); 
            UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.qual_eutra_freq[j].qual_min_eutra, 
                       cai_qual_eutra_freq_type, qual_min_eutra);
            UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.qual_eutra_freq[j].qual_min_eutra_offset_inc, 
                       cai_qual_eutra_freq_type, qual_min_eutra_offset_inc);
            if(int_ptr->atim.radio_interface_rec[i].radio_interface.qual_eutra_freq[j].qual_min_eutra_offset_inc)        
            {
              UNPACKB_PG(atim.radio_interface_rec[i].radio_interface.qual_eutra_freq[j].qual_min_eutra_offset, 
                       cai_qual_eutra_freq_type, qual_min_eutra_offset);
            }
          } /* for(j=0; j < int_ptr->atim.radio_interface_rec[i].radio_interface.num_eutra_freq; j++) */
        } /* else if(int_ptr->atim.radio_interface_rec[i].radio_interface.rsrq_parms_inc && */
      } /* if ( ( int_ptr->atim.radio_interface_rec[i].radio_interface_len*8 -  */
    } /* if ( ( int_ptr->atim.radio_interface_rec[i].radio_interface_len*8 -  */
  #endif /* FEATURE_1X_SPLMN_SUPPORT */
    if(int_ptr->atim.radio_interface_rec[i].radio_interface_len*8 - (ext_msg_pos - radio_iface_start_pos) < 0)
    {
      M1X_MSG( DCP, LEGACY_HIGH, 
           "Invalid ATIM msg, rec_len=%d, start_pos=%d, ext_msg_pos = %d",
            int_ptr->atim.radio_interface_rec[i].radio_interface_len*8, 
            radio_iface_start_pos, ext_msg_pos );
      status = CAIX_INV_MSG_S;
      return status;
    }
    ext_msg_pos += int_ptr->atim.radio_interface_rec[i].radio_interface_len*8 - (ext_msg_pos - radio_iface_start_pos);

  } /* for(i=0; i < int_ptr->atim.num_radio_interface; i++) */

  return (status);

}

#endif /* FEATURE_1X_TO_LTE */

/*===========================================================================

FUNCTION XLATE_EXT_PCH_MSG

DESCRIPTION
  This function translates a received Paging Channel message from external to
  internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pch_msg
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word msg_type_pd;
    /* message type field, word for future extension */
  byte pd;
    /* Protocol discriminator */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -------------------
  ** Decode message type
  ** ------------------- */
  msg_type_pd = b_unpackb(buf_ptr, FPOS( cai_gen_type, msg_type ),
                                   FSIZ( cai_gen_type, msg_type ));
  UNPACK_MSG_TYPE(int_ptr->gen_pc.msg_type, msg_type_pd);

  /* -----------------------------
  ** Decode protocol discriminator
  ** ----------------------------- */
  UNPACK_PD(pd, msg_type_pd);

  /* PD validation */
  if (pd >
#ifdef FEATURE_IS2000_REL_C
      2
#elif defined(FEATURE_IS2000_REL_A)
      1
#else
      0
#endif /* FEATURE_IS2000_REL_C */
     )
  {
    return CAIX_INV_MSG_S;
  }

  switch (int_ptr->gen_pc.msg_type)
  {
    case CAI_SYS_PARM_MSG:
      status = xlate_ext_sys_parm(len, buf_ptr, int_ptr);
      break;

    case CAI_ACC_PARM_MSG:
      status = xlate_ext_acc_parm(len, buf_ptr, int_ptr);
      break;

    case CAI_EXT_NL_MSG:
      status = xlate_ext_ext_nl(len, buf_ptr, int_ptr);
      break;

    case CAI_NL_MSG:
      status = xlate_ext_nl(len, buf_ptr, int_ptr);
      break;

    case CAI_CL_MSG:
      status = xlate_ext_cl(len, buf_ptr, int_ptr);
      break;

    case CAI_SLT_PAGE_MSG:
      status = xlate_ext_slt_page(len, buf_ptr, int_ptr);
      break;

    case CAI_PAGE_MSG:
      status = xlate_ext_page(len, buf_ptr, int_ptr);
      break;

    case CAI_PC_ORD_MSG:
      status = xlate_ext_pc_ord(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_CHN_ASN_MSG:
      status = xlate_ext_chn_asn(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_PC_BURST_MSG:
      status = xlate_ext_pc_burst(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_PC_AUTH_MSG:
      status = xlate_ext_pc_auth(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_PC_SSD_UP_MSG:
      status = xlate_ext_pc_ssd(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_FEATURE_MSG:
      status = xlate_ext_pc_feature(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_EXT_SYS_PARM_MSG:
      status = xlate_ext_ext_sys_parm(len, buf_ptr, int_ptr);
      break;

    case CAI_PC_STREQ_MSG:
      status = xlate_ext_pc_streq(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_SERVICE_REDIR_MSG:
      status = xlate_ext_srvc_redir(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_GENERAL_PAGE_MSG:
      status = xlate_ext_general_page(len, buf_ptr, int_ptr);
      break;

    case CAI_GLOBAL_REDIR_MSG:
      status = xlate_ext_glob_redir(len, buf_ptr, int_ptr);
      break;

    case CAI_PC_TMSI_ASGN_MSG:
      status = xlate_ext_pc_tmsi(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_PACA_MSG:
      status = xlate_ext_paca(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_EXT_CHN_ASN_MSG:

    case CAI_MEID_EXT_CHN_ASN_MSG:

      status = xlate_ext_ext_chn_asn(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_GEN_NL_MSG:
      status = xlate_ext_gen_nl(len, buf_ptr, int_ptr);
      break;

    case CAI_EXT_GLB_REDIR_MSG:
      status = xlate_ext_e_glb_redir(len, buf_ptr, int_ptr);
      break;

    case CAI_EXT_CDMA_CHN_LIST_MSG:
      status = xlate_ext_e_cl(len, buf_ptr, int_ptr);
      break;

#ifdef FEATURE_IS2000_REL_A
    case CAI_SEC_MODE_CMD_MSG:
      status = xlate_ext_smcm(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    case CAI_AUTH_REQ_MSG:
      status = xlate_ext_auth_req(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_1X_ADV
    case CAI_PC_GEN_EXTN_MSG:
      if (cdma.onexadv_status.status ==  MC_1XADVANCED_ENABLED)
      {
      status = xlate_ext_pc_gen_extn(len, buf_ptr, int_ptr, CAIX_PC, pd);
      }
      else
      {
        status = CAIX_INV_MSG_S;
        M1X_MSG( DCP, LEGACY_HIGH,"Ignore parsing GEM as 1x Advanced is not enabled");
      }
      break;
#endif /* FEATURE_IS2000_1X_ADV */

#ifdef FEATURE_1X_TO_LTE
    case CAI_ALT_TECH_INFO_MSG:
      if(IS_1X_TO_LTE_RESELECTION_ENABLED)
      {
        status = xlate_ext_alt_tech_info(len, buf_ptr, int_ptr, CAIX_PC);
      }
      else
      {
        M1X_MSG( DCP, LEGACY_HIGH,
          "1X to LTE reselections are not enabled. Ignoring ATIM" );
        status = CAIX_INV_MSG_S;
      }
      break;
#endif /* FEATURE_1X_TO_LTE */

    default:
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

  return (status);

} /* xlate_ext_pch_msg */

/*===========================================================================

FUNCTION XLATE_EXT_SC_MSG

DESCRIPTION
  This function translates a received Sync Channel Message from
  external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_sc_msg
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
  /* ------------------------------------------------------
  ** Message must contain elements up to and including PRAT
  ** ------------------------------------------------------ */
  int  ext_msg_pos = FPOS(cai_sync_type,cdma_freq);

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
#define MTYPE cai_sync_type

  if ((int_ptr->sync.msg_type =
       b_unpackb( PARAMS( msg_type ))) != CAI_SYNC_MSG)
  {
    /* --------------------
    ** Invalid message type
    ** -------------------- */
    status = CAIX_INV_MSG_S;
  }

  else
  {
    /* ------------------------------------------------
    ** Convert message from external to internal format
    ** ------------------------------------------------ */
    int_ptr->sync.p_rev       = b_unpackb( PARAMS( p_rev ));
    int_ptr->sync.min_p_rev   = b_unpackb( PARAMS( min_p_rev ));
    int_ptr->sync.sid         = b_unpackw( PARAMS( sid ));
    int_ptr->sync.nid         = b_unpackw( PARAMS( nid ));
    int_ptr->sync.pilot_pn    = b_unpackw( PARAMS( pilot_pn ));
    b_unpackq( PARAMS( lc_state ), int_ptr->sync.lc_state );
    b_unpackq( PARAMS( sys_time ), int_ptr->sync.sys_time );
    int_ptr->sync.lp_sec      = b_unpackb( PARAMS( lp_sec ));
    int_ptr->sync.ltm_off     = b_unpackb( PARAMS( ltm_off ));
    int_ptr->sync.daylt       = b_unpackb( PARAMS( daylt ));
    int_ptr->sync.prat        = b_unpackb( PARAMS( prat ));

    if (len >= FENDPOS(MTYPE, cdma_freq))
    {
      int_ptr->sync.cdma_freq = b_unpackw( PARAMS( cdma_freq ));
      ext_msg_pos += FSIZ(MTYPE,cdma_freq);
    }

    if ((int_ptr->sync.p_rev >= CAIX_P_REV_IS2000)
#ifdef FEATURE_IS2000_REL_A
        && (cdma.mob_cai_rev >= CAIX_P_REV_IS2000)
#endif //FEATURE_IS2000_REL_A
       )
    {
      int_ptr->sync.ext_cdma_freq = b_unpackw ( PARAMS( ext_cdma_freq ));
      ext_msg_pos += FSIZ(MTYPE,ext_cdma_freq);
    }

#ifdef FEATURE_IS2000_REL_A
    if ((int_ptr->sync.p_rev >= CAIX_P_REV_IS2000_REL_A)
#ifdef FEATURE_IS2000_REL_A
      && (cdma.mob_cai_rev >= CAIX_P_REV_IS2000_REL_A)
#endif //FEATURE_IS2000_REL_A
       )
    {
      UNPACKB_PG(sync.sr1_bcch_non_td_incl,MTYPE,sr1_bcch_non_td_incl);
      if(int_ptr->sync.sr1_bcch_non_td_incl == 1)
      {
        UNPACKB_PG(sync.sr1_non_td_freq_incl,MTYPE,sr1_non_td_freq_incl);
        if(int_ptr->sync.sr1_non_td_freq_incl == 1)
        {
          UNPACKW_PG(sync.sr1_cdma_freq_non_td,MTYPE,sr1_cdma_freq_non_td);
        }
        UNPACKB_PG(sync.sr1_brat_non_td,MTYPE,sr1_brat_non_td);
        UNPACKB_PG(sync.sr1_crat_non_td,MTYPE,sr1_crat_non_td);
        UNPACKB_PG(sync.sr1_bcch_code_chan_non_td,MTYPE,sr1_bcch_code_chan_non_td);
      }

      UNPACKB_PG(sync.sr1_td_incl,MTYPE,sr1_td_incl);
      if(int_ptr->sync.sr1_td_incl == 1)
      {
        UNPACKW_PG(sync.sr1_cdma_freq_td ,MTYPE,sr1_cdma_freq_td );
        UNPACKB_PG(sync.sr1_brat_td ,MTYPE,sr1_brat_td );
        UNPACKB_PG(sync.sr1_crat_td ,MTYPE,sr1_crat_td );
        UNPACKB_PG(sync.sr1_bcch_code_chan_td ,MTYPE,sr1_bcch_code_chan_td );
        UNPACKB_PG(sync.sr1_td_mode ,MTYPE,sr1_td_mode );
        UNPACKB_PG(sync.sr1_td_power_level ,MTYPE,sr1_td_power_level );
      }

      UNPACKB_PG(sync.sr3_incl,MTYPE,sr3_incl);
      if(int_ptr->sync.sr3_incl == 1)
      {
        UNPACKB_PG(sync.sr3_center_freq_incl,MTYPE,sr3_center_freq_incl);
        if(int_ptr->sync.sr3_center_freq_incl== 1)
        {
          UNPACKW_PG(sync.sr3_center_freq,MTYPE,sr3_center_freq);
        }
        UNPACKB_PG(sync.sr3_brat,MTYPE,sr3_brat);
        UNPACKB_PG(sync.sr3_bcch_code_chan,MTYPE,sr3_bcch_code_chan);
        UNPACKB_PG(sync.sr3_primary_pilot,MTYPE,sr3_primary_pilot);
        UNPACKB_PG(sync.sr3_pilot_power1,MTYPE,sr3_pilot_power1);
        UNPACKB_PG(sync.sr3_pilot_power2,MTYPE,sr3_pilot_power2);
      }

      UNPACKB_PG(sync.ds_incl,MTYPE,ds_incl);
      if (int_ptr->sync.ds_incl)
      {
        UNPACKD_PG(sync.ds_blob,MTYPE,ds_blob);
      }
    }

#endif /* FEATURE_IS2000_REL_A */
  }

  if (ext_msg_pos > len)
  {
    #ifdef FEATURE_MODEM_1X_RUMI
    /* Ignore MSG length check for RUMI */
    M1X_MSG( DCP, LEGACY_FATAL,
      "RUMI: Ignoring MSG length mismatch. ext_msg_pos=%d > len=%d",
      ext_msg_pos,
      len);
    #else /* !FEATURE_MODEM_1X_RUMI */
    status = CAIX_INV_LEN_S;
    #endif /* FEATURE_MODEM_1X_RUMI */
  }

#undef MTYPE
  return (status);

} /* xlate_ext_sc_msg */

/*===========================================================================

FUNCTION CAIX_EXT_TO_INT

DESCRIPTION
  This function translates a message from the external format used
  by the Receive task to the internal format used by the Main Control
  task.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word caix_ext_to_int
(
  word len,
    /* Length of message in bits (not including length byte or CRC) */
  caix_chan_type chn,
    /* Channel message was received on */
  cai_rx_msg_type *rx_msg_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_msg_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_INV_LEN_S;
    /* Status to be returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  caix_p_rev_in_use = mc_get_p_rev_in_use();
  if (int_msg_ptr != NULL)
  {
    /* Initialize all fields of received message */
    memset(int_msg_ptr, 0, sizeof(caii_rx_msg_type));
  }

ASSERT(int_msg_ptr != NULL);

if (int_msg_ptr != NULL)
 {
  switch (chn) {
    case CAIX_SC:
      status = (len > CAI_SC_BODY_SIZE) ?
         CAIX_INV_LEN_S :
         xlate_ext_sc_msg( len, rx_msg_ptr->sc.body, int_msg_ptr );
      break;

    case CAIX_PC:
      status = (len > CAI_PC_BODY_SIZE) ?
        CAIX_INV_LEN_S :
        xlate_ext_pch_msg( len, rx_msg_ptr->pc.body, int_msg_ptr );
      break;

    case CAIX_TC:
      status = (len > CAI_FWD_TC_MSG_BODY_SIZE) ?
        CAIX_INV_LEN_S :
        xlate_ext_tc_msg( len, rx_msg_ptr->tc.body, int_msg_ptr );
      break;

    default:
      status = CAIX_INV_CHN_S;
      break;
  } /* end of switch */

 }
  return (status);

} /* caix_ext_to_int */

/*===========================================================================

FUNCTION CAIX_GET_MESSAGE_TYPE

DESCRIPTION
  This function peeks at the first byte of a bitstream to determine the
  message type.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while getting the message type.

SIDE EFFECTS
  Msg_type will hold the value of the message type.

===========================================================================*/

word caix_get_message_type
(
  byte * msg_type,
  /* This will hold the message type of the message */
  word chn,
  /* Channel message was received on */
  byte *buf_ptr
  /* Pointer to received message to be translated */
)
{
  word msg_type_pd;
  /* Message type field, word for future extension */
  word status = CAIX_DONE_S;
  /* Status to be returned to calling procedure */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (chn)
  {
    case CAIX_PC:
    {
      msg_type_pd = b_unpackb(buf_ptr, FPOS( cai_gen_type, msg_type ),
                              FSIZ( cai_gen_type, msg_type ));
      UNPACK_MSG_TYPE(*msg_type, msg_type_pd);
      break;
    }

    case CAIX_TC:
    {
      *msg_type = b_unpackb( buf_ptr, FPOS( cai_gen_type, msg_type ),
                             FSIZ( cai_gen_type, msg_type ));
      break;
    }

    default:
      M1X_MSG( DCP, LEGACY_HIGH,
        "Caix_get_message_type specified an invalid channel: %d",
        chn);
      status = CAIX_INV_CHN_S;
      break;
  } /* end of switch */

  return(status);

} /* caix_get_message_type */

/* <EJECT> */
/*===========================================================================

FUNCTION XLATE_INT_NON_NEG_SRV_CFG

DESCRIPTION
  This function translates a non-neg service configuration record from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_int_non_neg_srv_cfg
(
  byte *buf_ptr,
    /* Pointer to message buffer which is to contain translated
       service configuration record. */

  word *buf_pos,
    /* Offset in message buffer at which to start non-neg service
       configuration record. */

  caii_non_neg_srv_cfg_type *i_ptr
    /* Pointer to internal non_neg service configuration record to be
       translated */
)
{
  word ext_msg_pos = *buf_pos;
  word record_len;
  word record_start_pos;
  word i;
  word status = CAIX_DONE_S;
#ifdef FEATURE_IS2000_REL_A
  word j, k;
  byte temp_mux_header_len;
#endif /* FEATURE_IS2000_REL_A */

  (void) b_unpackb(buf_ptr,ext_msg_pos,
                   FSIZ(cai_ho_msg_is2000_type,record_type));
  ext_msg_pos += FSIZ(cai_ho_msg_is2000_type,record_type);
  record_len = b_unpackb(buf_ptr,ext_msg_pos,
                         FSIZ(cai_ho_msg_is2000_type,record_len));
  record_len *= 8;
  ext_msg_pos += FSIZ(cai_ho_msg_is2000_type,record_len);
  record_start_pos = ext_msg_pos;

  #define FTYPE cai_nnscr_type

  i_ptr->fpc_incl = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(FTYPE, fpc_incl));
  ext_msg_pos += FSIZ(FTYPE, fpc_incl);

  if (i_ptr->fpc_incl)
  {
    i_ptr->fpc_pri_chan = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, fpc_pri_chan));
    ext_msg_pos += FSIZ(FTYPE, fpc_pri_chan);

    i_ptr->fpc_mode = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(FTYPE, fpc_mode));
    ext_msg_pos += FSIZ(FTYPE, fpc_mode);

    i_ptr->fpc_olpc_fch_incl = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, fpc_olpc_fch_incl));
    ext_msg_pos += FSIZ(FTYPE, fpc_olpc_fch_incl);

    if (i_ptr->fpc_olpc_fch_incl)
    {
      i_ptr->fpc_fch_fer = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_fch_fer));
      ext_msg_pos += FSIZ(FTYPE, fpc_fch_fer);

      i_ptr->fpc_fch_min_setpt = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_fch_min_setpt));
      ext_msg_pos += FSIZ(FTYPE, fpc_fch_min_setpt);

      i_ptr->fpc_fch_max_setpt = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_fch_max_setpt));
      ext_msg_pos += FSIZ(FTYPE, fpc_fch_max_setpt);
    }

    i_ptr->fpc_olpc_dcch_incl = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, fpc_olpc_dcch_incl));
    ext_msg_pos += FSIZ(FTYPE, fpc_olpc_dcch_incl);

    if (i_ptr->fpc_olpc_dcch_incl)
    {
      i_ptr->fpc_dcch_fer = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_dcch_fer));
      ext_msg_pos += FSIZ(FTYPE, fpc_dcch_fer);

      i_ptr->fpc_dcch_min_setpt = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_dcch_min_setpt));
      ext_msg_pos += FSIZ(FTYPE, fpc_dcch_min_setpt);

      i_ptr->fpc_dcch_max_setpt = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_dcch_max_setpt));
      ext_msg_pos += FSIZ(FTYPE, fpc_dcch_max_setpt);
    }
  }

  i_ptr->gating_rate_incl = b_unpackb(buf_ptr, ext_msg_pos,
    FSIZ(FTYPE, gating_rate_incl));
  ext_msg_pos += FSIZ(FTYPE, gating_rate_incl);

  if (i_ptr->gating_rate_incl)
  {
    i_ptr->pilot_gate_rate = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, pilot_gate_rate));
    ext_msg_pos += FSIZ(FTYPE, pilot_gate_rate);
  }

  if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
  {
    /* Advance past reserved bits */
    ext_msg_pos += FSIZ(FTYPE, reserved);
  }

#ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    #define OTYPE cai_nnscr_sch_fix_type
    #define VTYPE cai_nnscr_sch_var_type

    i_ptr->for_sch_incl = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(OTYPE, for_sch_incl));
    ext_msg_pos += FSIZ(OTYPE, for_sch_incl);

    if (i_ptr->for_sch_incl)
    {
      i_ptr->num_for_sch = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(OTYPE, num_for_sch));
      ext_msg_pos += FSIZ(OTYPE, num_for_sch);

      for (i=0; (i<i_ptr->num_for_sch) && (i < CAI_NNSCR_MAX_NUM_SCH); i++)
      {
        i_ptr->for_sch[i].sch_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(VTYPE, sch_id));
        ext_msg_pos += FSIZ(VTYPE, sch_id);

        i_ptr->for_sch[i].frame_offset = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(VTYPE, frame_offset));
        ext_msg_pos += FSIZ(VTYPE, frame_offset);
      }
    }

    i_ptr->rev_sch_incl = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(OTYPE, rev_sch_incl));
    ext_msg_pos += FSIZ(OTYPE, rev_sch_incl);

    if (i_ptr->rev_sch_incl)
    {
      i_ptr->num_rev_sch = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(OTYPE, num_rev_sch));
      ext_msg_pos += FSIZ(OTYPE, num_rev_sch);

      for (i=0; (i<i_ptr->num_rev_sch) && (i < CAI_NNSCR_MAX_NUM_SCH); i++)
      {
        i_ptr->rev_sch[i].sch_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(VTYPE, sch_id));
        ext_msg_pos += FSIZ(VTYPE, sch_id);

        i_ptr->rev_sch[i].frame_offset = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(VTYPE, frame_offset));
        ext_msg_pos += FSIZ(VTYPE, frame_offset);
      }
    }

    #undef OTYPE
    #undef VTYPE
  }
#endif /* FEATURE_IS2000_REL_A */

  i_ptr->lpm_ind = b_unpackb(buf_ptr,ext_msg_pos,
    FSIZ(FTYPE, lpm_ind));
  ext_msg_pos += FSIZ(FTYPE, lpm_ind);

  if (i_ptr->lpm_ind == CAI_LPM_SUPPLIED)
  {
    i_ptr->num_lpm_entries = b_unpackb(buf_ptr,ext_msg_pos,
      FSIZ(FTYPE, num_lpm_entries));
    ext_msg_pos += FSIZ(FTYPE, num_lpm_entries);

    #define VTYPE cai_nnscr_lpm_entry_type

    for (i=0; (i<i_ptr->num_lpm_entries) && (i < CAI_MAX_NUM_LPM_ENTRIES); i++)
    {
      i_ptr->lpm_entries[i].sr_id = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, sr_id));
      ext_msg_pos += FSIZ(VTYPE, sr_id);

      i_ptr->lpm_entries[i].logical_resource = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, logical_resource));
      ext_msg_pos += FSIZ(VTYPE, logical_resource);

      i_ptr->lpm_entries[i].physical_resource = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, physical_resource));
      ext_msg_pos += FSIZ(VTYPE, physical_resource);

      i_ptr->lpm_entries[i].forward_flag = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, forward_flag));
      ext_msg_pos += FSIZ(VTYPE, forward_flag);

      i_ptr->lpm_entries[i].reverse_flag = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, reverse_flag));
      ext_msg_pos += FSIZ(VTYPE, reverse_flag);

      i_ptr->lpm_entries[i].priority = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, priority));
      ext_msg_pos += FSIZ(VTYPE, priority);
    }

    #undef VTYPE
  }

  #undef FTYPE

#ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    #define FTYPE cai_nnscr_so_rec_fix_type
    #define VTYPE cai_nnscr_so_rec_var_type

    i_ptr->numrec = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(FTYPE, numrec));
    ext_msg_pos += FSIZ(FTYPE, numrec);

    /* unpack each rec */
    for (i=0; (i<i_ptr->numrec) && (i < CAI_NNSCR_MAX_NUM_SR_REC); i++)
    {
      (void) b_unpackb(buf_ptr, ext_msg_pos, FSIZ(VTYPE, record_len));
      ext_msg_pos += FSIZ(VTYPE, record_len);

      i_ptr->rec[i].sr_id = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(VTYPE, sr_id));
      ext_msg_pos += FSIZ(VTYPE, sr_id);

      i_ptr->rec[i].sdb_so_omit = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, sdb_so_omit));
      ext_msg_pos += FSIZ(VTYPE, sdb_so_omit);

      ext_msg_pos += 4; /* for reserved */
    }

    #undef VTYPE
    #undef FTYPE

    /*----------------------------------------------------------
            FLEX TABLES
    ---------------------------------------------------------*/

    #define FTYPE cai_nnscr_num_bits_table_fix_type

    i_ptr->use_flex_num_bits = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, use_flex_num_bits));
    ext_msg_pos += FSIZ(FTYPE, use_flex_num_bits);

    if (i_ptr->use_flex_num_bits)
    {
      i_ptr->num_bits_tables_incl = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, num_bits_tables_incl));
      ext_msg_pos += FSIZ(FTYPE, num_bits_tables_incl);

      if (i_ptr->num_bits_tables_incl)
      {
        i_ptr->num_bits_tables_count = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, num_bits_tables_count));
        ext_msg_pos += FSIZ(FTYPE, num_bits_tables_count);

        #define VTYPE1 cai_nnscr_num_bits_table_var1_type
        #define VTYPE2 cai_nnscr_num_bits_table_var2_type

        for (i=0; (i<i_ptr->num_bits_tables_count+1) && (i < MAX_BIT_TABLE); i++)
        {
          i_ptr->bit_table[i].num_bits_table_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, num_bits_table_id));
          ext_msg_pos += FSIZ(VTYPE1, num_bits_table_id);

          i_ptr->bit_table[i].num_recs = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, num_recs));
          ext_msg_pos += FSIZ(VTYPE1, num_recs);

          for (j=0; (j<i_ptr->bit_table[i].num_recs+1) && (j < MAX_RECS); j++)
          {
            i_ptr->bit_table[i].recs[j].num_bits_idx = b_unpackb(buf_ptr,
              ext_msg_pos, FSIZ(VTYPE2, num_bits_idx));
            ext_msg_pos += FSIZ(VTYPE2, num_bits_idx);

            i_ptr->bit_table[i].recs[j].num_bits = b_unpackw(buf_ptr, ext_msg_pos,
              FSIZ(VTYPE2, num_bits));
            ext_msg_pos += FSIZ(VTYPE2, num_bits);

            i_ptr->bit_table[i].recs[j].crc_len_idx = b_unpackb(buf_ptr,
              ext_msg_pos, FSIZ(VTYPE2, crc_len_idx));
            ext_msg_pos += FSIZ(VTYPE2, crc_len_idx);
          }
        }

        #undef VTYPE1
        #undef VTYPE2

      } /* end if (num_bits_tables_incl) */
    } /* end if (use_flex_num_bits) */

    #undef FTYPE

    /*----------------------------------------------------------
            VAR TABLES
      ---------------------------------------------------------*/

    #define FTYPE cai_nnscr_var_rate_table_fix_type

    i_ptr->use_var_rate = b_unpackb(buf_ptr,ext_msg_pos, FSIZ(FTYPE, use_var_rate));
    ext_msg_pos += FSIZ(FTYPE, use_var_rate);

    if (i_ptr->use_var_rate)
    {
      i_ptr->var_tables_incl = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, var_tables_incl));
      ext_msg_pos += FSIZ(FTYPE, var_tables_incl);

      if (i_ptr->var_tables_incl)
      {
        i_ptr->var_rate_tables_count = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, var_rate_tables_count));
        ext_msg_pos += FSIZ(FTYPE, var_rate_tables_count);

        #define VTYPE1 cai_nnscr_var_rate_table_var1_type
        #define VTYPE2 cai_nnscr_var_rate_table_var2_type

        for (i=0; (i<i_ptr->var_rate_tables_count+1) && (i < MAX_VAR_TABLE); i++)
        {
          i_ptr->var_table[i].var_rate_table_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, var_rate_table_id));
          ext_msg_pos += FSIZ(VTYPE1, var_rate_table_id);

          i_ptr->var_table[i].num_recs = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, num_recs));
          ext_msg_pos += FSIZ(VTYPE1, num_recs);

          for (j=0; (j<i_ptr->var_table[i].num_recs+1) && (j < MAX_RECS); j++)
          {
            i_ptr->var_table[i].recs[j].num_bits_idx = b_unpackb(buf_ptr,
              ext_msg_pos, FSIZ(VTYPE2, num_bits_idx));
            ext_msg_pos += FSIZ(VTYPE2, num_bits_idx);

            i_ptr->var_table[i].recs[j].mask = b_unpackw(buf_ptr,
              ext_msg_pos, i_ptr->var_table[i].recs[j].num_bits_idx);
            ext_msg_pos += i_ptr->var_table[i].recs[j].num_bits_idx;
          }
        }

        #undef VTYPE2
        #undef VTYPE1

      } /* end if (var_tables_incl) */
    } /* end if (use_var_rate) */

    #undef FTYPE

    /*----------------------------------------------------------
            FLEX MAPPING
    ---------------------------------------------------------*/

    if (i_ptr->use_flex_num_bits)
    {
      #define FTYPE cai_nnscr_flex_map_type

      i_ptr->use_old_flex_mapping = b_unpackb(buf_ptr,ext_msg_pos,
        FSIZ(FTYPE, use_old_flex_mapping));
      ext_msg_pos += FSIZ(FTYPE, use_old_flex_mapping);

      if (!i_ptr->use_old_flex_mapping)
      {
        i_ptr->fsch0_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
         FSIZ(FTYPE, fsch0_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, fsch0_nbit_table_id);

        i_ptr->rsch0_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
         FSIZ(FTYPE, rsch0_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, rsch0_nbit_table_id);

        i_ptr->fsch1_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, fsch1_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, fsch1_nbit_table_id);

        i_ptr->rsch1_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, rsch1_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, rsch1_nbit_table_id);

        i_ptr->ffch_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, ffch_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, ffch_nbit_table_id);

        i_ptr->rfch_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, rfch_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, rfch_nbit_table_id);

        i_ptr->fdcch_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, fdcch_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, fdcch_nbit_table_id);

        if (i_ptr->fdcch_nbit_table_id != 0)
        {
          i_ptr->fdcch_nbits_idx = b_unpackb(buf_ptr, ext_msg_pos,
           FSIZ(FTYPE, fdcch_nbits_idx));
          ext_msg_pos += FSIZ(FTYPE, fdcch_nbits_idx);
        }

        i_ptr->rdcch_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, rdcch_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, rdcch_nbit_table_id);

        if (i_ptr->rdcch_nbit_table_id != 0)
        {
         i_ptr->rdcch_nbits_idx = b_unpackb(buf_ptr, ext_msg_pos,
           FSIZ(FTYPE, rdcch_nbits_idx));
         ext_msg_pos += FSIZ(FTYPE, rdcch_nbits_idx);
        }

      } /* end if (!use_old_flex_mapping) */

    #undef FTYPE

    } /* end if (use_flex_num_bits) */


  /*----------------------------------------------------------
            VAR MAPPING
    ---------------------------------------------------------*/

    if (i_ptr->use_var_rate)
    {
      #define FTYPE cai_nnscr_var_map_type

      i_ptr->use_old_var_mapping = b_unpackb(buf_ptr,ext_msg_pos,
        FSIZ(FTYPE, use_old_var_mapping));
      ext_msg_pos += FSIZ(FTYPE, use_old_var_mapping);

      if (!i_ptr->use_old_var_mapping)
      {
        i_ptr->fsch0_var_table_id = b_unpackb(buf_ptr,ext_msg_pos,
          FSIZ(FTYPE, fsch0_var_table_id));
        ext_msg_pos += FSIZ(FTYPE, fsch0_var_table_id);

        i_ptr->rsch0_var_table_id = b_unpackb(buf_ptr,ext_msg_pos,
          FSIZ(FTYPE, rsch0_var_table_id));
        ext_msg_pos += FSIZ(FTYPE, rsch0_var_table_id);

        i_ptr->fsch1_var_table_id = b_unpackb(buf_ptr,ext_msg_pos,
          FSIZ(FTYPE, fsch1_var_table_id));
        ext_msg_pos += FSIZ(FTYPE, fsch1_var_table_id);

        i_ptr->rsch1_var_table_id = b_unpackb(buf_ptr,ext_msg_pos,
          FSIZ(FTYPE, rsch1_var_table_id));
        ext_msg_pos += FSIZ(FTYPE, rsch1_var_table_id);
      }

      i_ptr->r_inc_rate_allowed = b_unpackb(buf_ptr,ext_msg_pos,
        FSIZ(FTYPE, r_inc_rate_allowed));
      ext_msg_pos += FSIZ(FTYPE, r_inc_rate_allowed);

      i_ptr->f_inc_rate_allowed = b_unpackb(buf_ptr,ext_msg_pos,
        FSIZ(FTYPE, f_inc_rate_allowed));
      ext_msg_pos += FSIZ(FTYPE, f_inc_rate_allowed);

      #undef FTYPE

    } /* end if (use_var_rate) */


    /*----------------------------------------------------------
            LTU TABLES
    ---------------------------------------------------------*/

    #define FTYPE cai_nnscr_ltu_fix_type

    i_ptr->ltu_info_incl = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, ltu_info_incl));
    ext_msg_pos += FSIZ(FTYPE, ltu_info_incl);

    if (i_ptr->ltu_info_incl)
    {
      i_ptr->ltu_tables_incl = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, ltu_tables_incl));
      ext_msg_pos += FSIZ(FTYPE, ltu_tables_incl);

      if (i_ptr->ltu_tables_incl)
      {

        i_ptr->num_ltu_tables = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, num_ltu_tables));
        ext_msg_pos += FSIZ(FTYPE, num_ltu_tables);

        #define VTYPE1 cai_nnscr_ltu_var1_type
        #define VTYPE2 cai_nnscr_ltu_var2_type

        for (i=0; (i<i_ptr->num_ltu_tables+1) && (i < MAX_TABLE); i++)
        {
          i_ptr->table[i].ltu_table_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, ltu_table_id));
          ext_msg_pos += FSIZ(VTYPE1, ltu_table_id);

          i_ptr->table[i].num_rows = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, num_rows));
          ext_msg_pos += FSIZ(VTYPE1, num_rows);

          for (j=0; (j<i_ptr->table[i].num_rows+1) && (j < MAX_ROW_1); j++)
          {
            i_ptr->table[i].row[j].nbits_idx = b_unpackb(buf_ptr, ext_msg_pos,
              FSIZ(VTYPE2, nbits_idx));
            ext_msg_pos += FSIZ(VTYPE2, nbits_idx);

            i_ptr->table[i].row[j].num_ltus = b_unpackb(buf_ptr, ext_msg_pos,
              FSIZ(VTYPE2, num_ltus));
            ext_msg_pos += FSIZ(VTYPE2, num_ltus);
          }
        }

        #undef VTYPE1
        #undef VTYPE2

      } /* end if (ltu_tables_incl) */
    } /* end if (ltu_info_incl) */

    #undef FTYPE

    /*----------------------------------------------------------
            LTU MAPPING
    ---------------------------------------------------------*/

    if (i_ptr->ltu_info_incl)
    {
      #define FTYPE cai_nnscr_ltu_map_type

      i_ptr->use_old_ltu_mapping = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, use_old_ltu_mapping));
      ext_msg_pos += FSIZ(FTYPE, use_old_ltu_mapping);

      if (!i_ptr->use_old_ltu_mapping)
      {
        i_ptr->fsch0_ltu_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, fsch0_ltu_tab_id));
        ext_msg_pos += FSIZ(FTYPE, fsch0_ltu_tab_id);

        i_ptr->rsch0_ltu_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, rsch0_ltu_tab_id));
        ext_msg_pos += FSIZ(FTYPE, rsch0_ltu_tab_id);

        i_ptr->fsch1_ltu_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, fsch1_ltu_tab_id));
        ext_msg_pos += FSIZ(FTYPE, fsch1_ltu_tab_id);

        i_ptr->rsch1_ltu_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, rsch1_ltu_tab_id));
        ext_msg_pos += FSIZ(FTYPE, rsch1_ltu_tab_id);
      } /* end if (!use_old_ltu_mapping) */

      #undef FTYPE

    } /* end if (ltu_info_incl) */

    /*----------------------------------------------------------
            PARTITION TABLES AND MAPPING
    ---------------------------------------------------------*/

    if (i_ptr->use_flex_num_bits)
    {
      #define FTYPE cai_nnscr_partition_table_fix_type

      i_ptr->partition_tables_info_incl = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, partition_tables_info_incl));
      ext_msg_pos += FSIZ(FTYPE, partition_tables_info_incl);

      if (i_ptr->partition_tables_info_incl)
      {
        i_ptr->partition_tables_incl = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, partition_tables_incl));
        ext_msg_pos += FSIZ(FTYPE, partition_tables_incl);

        if (i_ptr->partition_tables_incl)
        {
          i_ptr->num_partition_tables = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(FTYPE, num_partition_tables));
          ext_msg_pos += FSIZ(FTYPE, num_partition_tables);

          #define VTYPE1 cai_nnscr_partition_table_var1_type
          #define VTYPE2 cai_nnscr_partition_table_var2_type
          #define VTYPE3 cai_nnscr_partition_table_var3_type

          for (i=0; (i<i_ptr->num_partition_tables+1) && (i < MAX_PART_TABLE); i++)
          {
            i_ptr->part_table[i].partition_table_id = b_unpackb(buf_ptr,
              ext_msg_pos, FSIZ(VTYPE1, partition_table_id));
            ext_msg_pos += FSIZ(VTYPE1, partition_table_id);

            i_ptr->part_table[i].num_rows = b_unpackb(buf_ptr, ext_msg_pos,
              FSIZ(VTYPE1, num_rows));
            ext_msg_pos += FSIZ(VTYPE1, num_rows);

            for (j=0; (j<i_ptr->part_table[i].num_rows+1) && (j < MAX_ROW_2); j++)
            {
              i_ptr->part_table[i].row[j].category = b_unpackb(buf_ptr,
                ext_msg_pos, FSIZ(VTYPE2, category));
              ext_msg_pos += FSIZ(VTYPE2,category);

              temp_mux_header_len = b_unpackb(buf_ptr, ext_msg_pos,
                FSIZ(VTYPE2, mux_header_len));
              ext_msg_pos += FSIZ(VTYPE2, mux_header_len);

              i_ptr->part_table[i].row[j].mux_header = b_unpackb(buf_ptr,
                ext_msg_pos, temp_mux_header_len);
              ext_msg_pos += temp_mux_header_len;

              i_ptr->part_table[i].row[j].num_partitions = b_unpackb(buf_ptr,
                ext_msg_pos, FSIZ(VTYPE2, num_partitions));
              ext_msg_pos += FSIZ(VTYPE2, num_partitions);

              for (k=0 ; k<i_ptr->part_table[i].row[j].num_partitions+1 ; k++)
              {
                i_ptr->part_table[i].row[j].part[k].sr_id = b_unpackb(buf_ptr,
                  ext_msg_pos, FSIZ(VTYPE3, sr_id));
                ext_msg_pos += FSIZ(VTYPE3, sr_id);

                i_ptr->part_table[i].row[j].part[k].srv_num_bits =
                  b_unpackw(buf_ptr, ext_msg_pos, FSIZ(VTYPE3, srv_num_bits));
                ext_msg_pos += FSIZ(VTYPE3, srv_num_bits);
              }
            }
          }

          #undef VTYPE3
          #undef VTYPE2
          #undef VTYPE1

        } /* end if (part_tables_incl) */

        #define OTYPE cai_nnscr_part_map_type

        i_ptr->use_old_part_mapping = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(OTYPE, use_old_part_mapping));
        ext_msg_pos += FSIZ(OTYPE, use_old_part_mapping);

        if (!i_ptr->use_old_part_mapping)
        {
          i_ptr->ffpc_part_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(OTYPE, ffpc_part_tab_id));
          ext_msg_pos += FSIZ(OTYPE, ffpc_part_tab_id);

          i_ptr->rfpc_part_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(OTYPE, rfpc_part_tab_id));
          ext_msg_pos += FSIZ(OTYPE, rfpc_part_tab_id);

          i_ptr->fdcch_part_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(OTYPE, fdcch_part_tab_id));
          ext_msg_pos += FSIZ(OTYPE, fdcch_part_tab_id);

          i_ptr->rdcch_part_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(OTYPE, rdcch_part_tab_id));
          ext_msg_pos += FSIZ(OTYPE, rdcch_part_tab_id);
        } /* end if (!use_old_part_mapping) */

        #undef OTYPE

      } /* end if (part_tables_info_incl) */

        #undef FTYPE

    } /* end if (use_flex_num_bits) */
  } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A) */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
  {
      #define FTYPE cai_nnscr_is2000_rel_b_type

      if ((i_ptr->use_flex_num_bits) || (i_ptr->use_var_rate))
      {
        i_ptr->use_eram = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(FTYPE, use_eram));
        ext_msg_pos += FSIZ(FTYPE, use_eram);
      }

      #undef FTYPE
  }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
      #define FTYPE cai_nnscr_is2000_rel_c_type

      if (i_ptr->gating_rate_incl)
      {
        i_ptr->switching_params_incl = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, switching_params_incl));
        ext_msg_pos += FSIZ(FTYPE, switching_params_incl);
      }

      if (i_ptr->switching_params_incl)
      {
        i_ptr->num_soft_switching_frames_chm = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, num_soft_switching_frames_chm));
        ext_msg_pos += FSIZ(FTYPE, num_soft_switching_frames_chm);

        i_ptr->num_softer_switching_frames_chm = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, num_softer_switching_frames_chm));
        ext_msg_pos += FSIZ(FTYPE, num_softer_switching_frames_chm);
      }

      #undef FTYPE

  } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) */
#endif /* FEATURE_IS2000_REL_C */

  ext_msg_pos = record_start_pos + record_len;
  *buf_pos = ext_msg_pos;
  return status;

} /* xlate_int_non_neg_srv_cfg */

/*===========================================================================

FUNCTION XLATE_INT_SRV_CFG

DESCRIPTION
  This function translates a service configuration record from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_srv_cfg
(
  word *len_ptr,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to message buffer which is to contain translated
       service configuration record. */

  word buf_pos,
    /* Offset in message buffer at which to start service
       configuration record. */

  caii_srv_cfg_type *i_ptr
    /* Pointer to internal service configuration record to be
       translated */
)
{
  word status;
    /* Status to be returned to calling procedure */

  word i;
    /* For indexing through service option connection records */

  word record_len_pos = 0;
  word record_start_pos = 0;
  word record_num_bits = 0;
  word record_num_bytes = 0;
  word record_num_reserved = 0;


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (i_ptr->num_con > CAII_SRV_CON_MAX)
  {
    status = CAIX_INV_MSG_S;
      /* Too many service option connections specified */
  }

  else
  {
    /* First do service configuration record header fields. */

    b_packb(CAI_RTC_SRV_CFG_REC, REC_P(record_type));
      /* Fill in information record type */

    record_len_pos = buf_pos + FSIZ(cai_rec_hdr_type,record_type);

    buf_pos += sizeof(cai_rec_hdr_type);
      /* Skip over info rec header */

    record_start_pos = buf_pos;

    /* Translate the fixed message fields */
    b_packw(i_ptr->fwd_mux,   HDR_P(fwd_mux));
    b_packw(i_ptr->rev_mux,   HDR_P(rev_mux));
    b_packb(i_ptr->fwd_rates, HDR_P(fwd_rates));
    b_packb(i_ptr->rev_rates, HDR_P(rev_rates));
    b_packb(i_ptr->num_con,   HDR_P(num_con));

    buf_pos += sizeof(cai_srv_cfg_hdr_type);
      /* Skip over configuration header record */

    for (i = 0; i < i_ptr->num_con; i++)
    {
      /* Translate the specified number of service option connection
         records. */

      word con_rec_len;
      word con_num_bits = sizeof(cai_srv_cfg_con_type);
      word con_num_reserved = 0;

      con_rec_len = (FENDPOS(cai_srv_cfg_con_type, rev_traf))/8;


      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000 )
      {
        if (i_ptr->con[i].rlp_info_incl)
        {
          con_num_bits += FSIZ(cai_srv_cfg_con_var_type, rlp_blob_len) +
            (FSIZ(cai_srv_cfg_con_var_type, rlp_blob) *
             i_ptr->con[i].rlp_blob_len);
        }

#ifdef FEATURE_IS2000_REL_A
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
        {
          /* for qos_incl */
          con_num_bits += sizeof(cai_srv_cfg_con_is2000_rel_a_fix_type);

          if (i_ptr->con[i].qos_parms_incl)
          {
            con_num_bits += FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type,
              qos_parms_len) + (FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type,
              qos_parms) * i_ptr->con[i].qos_parms_len);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

        con_rec_len = (con_num_bits/8);
        con_num_reserved = 8 - (con_num_bits % 8);
        if (con_num_reserved != 8)
        {
          con_rec_len += 1;
        }
      }

      b_packb((byte) con_rec_len, CON_P(rec_len));
      b_packb(i_ptr->con[i].con_ref, CON_P( con_ref));
      b_packw(i_ptr->con[i].so, CON_P(so));
      b_packb(i_ptr->con[i].fwd_traf, CON_P(fwd_traf));
      b_packb(i_ptr->con[i].rev_traf, CON_P(rev_traf));

      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
      {
        b_packb(i_ptr->con[i].ui_encrypt_mode, CON_P(ui_encrypt_mode));
        b_packb(i_ptr->con[i].sr_id, CON_P(sr_id));
        b_packb(i_ptr->con[i].rlp_info_incl, CON_P(rlp_info_incl));
        buf_pos += sizeof(cai_srv_cfg_con_type);

        if (i_ptr->con[i].rlp_info_incl)
        {
          word cur;

          b_packb(i_ptr->con[i].rlp_blob_len, buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_con_var_type, rlp_blob_len));
          buf_pos += FSIZ(cai_srv_cfg_con_var_type, rlp_blob_len);

          for (cur=0; cur<i_ptr->con[i].rlp_blob_len; cur++)
          {
            b_packb(i_ptr->con[i].rlp_blob[cur], buf_ptr, buf_pos,
              FSIZ(cai_srv_cfg_con_var_type, rlp_blob));
            buf_pos += FSIZ(cai_srv_cfg_con_var_type,rlp_blob);
          }
        }

#ifdef FEATURE_IS2000_REL_A
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
        {
          b_packb(i_ptr->con[i].qos_parms_incl,buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_con_is2000_rel_a_fix_type, qos_parms_incl));
          buf_pos += FSIZ(cai_srv_cfg_con_is2000_rel_a_fix_type, qos_parms_incl);

          if (i_ptr->con[i].qos_parms_incl)
          {
            word cur;

            b_packb(i_ptr->con[i].qos_parms_len,buf_ptr, buf_pos,
              FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type, qos_parms_len));
            buf_pos += FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type, qos_parms_len);

            for (cur=0; cur<i_ptr->con[i].qos_parms_len; cur++)
            {
              b_packb(i_ptr->con[i].qos_parms[cur], buf_ptr, buf_pos,
                  FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type, qos_parms));
              buf_pos += FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type, qos_parms);
            }

            /* now pack the qos_reserved fields
            j = ((i_ptr->con[i].qos_parms_len + 6) % 8);
            b_packb(0, buf_ptr, buf_pos, j);
            buf_pos += j;       */
          }
        }
#endif /* FEATURE_IS2000_REL_A */

        if (con_num_reserved != 8)
        {
          b_packb(0, buf_ptr, buf_pos, con_num_reserved);
          buf_pos += con_num_reserved;
        }
      }
      else
      {
        buf_pos += con_rec_len * 8;
      }

      /* Skip to next service option connection record */
    } /* end for */

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      b_packb(i_ptr->fch_cc_incl, buf_ptr, buf_pos,
        FSIZ(cai_srv_cfg_is2000_type, fch_cc_incl));
      buf_pos += FSIZ(cai_srv_cfg_is2000_type, fch_cc_incl);

      if (i_ptr->fch_cc_incl)
      {
        b_packb(i_ptr->fch_frame_size, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, fch_frame_size));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, fch_frame_size);

        b_packb(i_ptr->for_fch_rc, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, for_fch_rc));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, for_fch_rc);

        b_packb(i_ptr->rev_fch_rc, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, rev_fch_rc));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, rev_fch_rc);
      }

      b_packb(i_ptr->dcch_cc_incl, buf_ptr, buf_pos,
        FSIZ(cai_srv_cfg_is2000_type, dcch_cc_incl));
      buf_pos += FSIZ(cai_srv_cfg_is2000_type, dcch_cc_incl);

      if (i_ptr->dcch_cc_incl)
      {
        b_packb(i_ptr->dcch_frame_size, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, dcch_frame_size));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, dcch_frame_size);

        b_packb(i_ptr->for_dcch_rc, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, for_dcch_rc));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, for_dcch_rc);

        b_packb(i_ptr->rev_dcch_rc, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, rev_dcch_rc));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, rev_dcch_rc);
      }

      b_packb(i_ptr->for_sch_cc_incl, buf_ptr, buf_pos,
        FSIZ(cai_srv_cfg_is2000_type, for_sch_cc_incl));
      buf_pos += FSIZ(cai_srv_cfg_is2000_type, for_sch_cc_incl);

      if (i_ptr->for_sch_cc_incl)
      {
        b_packb(i_ptr->num_for_sch, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, num_for_sch));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, num_for_sch);

        for (i=0; i<i_ptr->num_for_sch; i++)
        {
          b_packb(i_ptr->for_sch[i].for_sch_id, buf_ptr, buf_pos,
            FSIZ(cai_for_sch_type, for_sch_id));
          buf_pos += FSIZ(cai_for_sch_type, for_sch_id);

          b_packw(i_ptr->for_sch[i].for_sch_mux, buf_ptr, buf_pos,
            FSIZ(cai_for_sch_type, for_sch_mux));
          buf_pos += FSIZ(cai_for_sch_type, for_sch_mux);

          b_packb(2, buf_ptr, buf_pos, FSIZ(cai_sch_chn_cfg_type, sch_rec_len));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, sch_rec_len);

          b_packb(i_ptr->for_sch[i].sch_chn_cfg.sch_rc, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, sch_rc));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, sch_rc);

          b_packb(i_ptr->for_sch[i].sch_chn_cfg.coding, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, coding));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, coding);

#ifdef FEATURE_IS2000_REL_A
          b_packb(i_ptr->for_sch[i].sch_chn_cfg.frame_40_used, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, frame_40_used));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, frame_40_used);

          b_packb(i_ptr->for_sch[i].sch_chn_cfg.frame_80_used,buf_ptr,buf_pos,
            FSIZ(cai_sch_chn_cfg_type,frame_80_used));
          buf_pos += FSIZ(cai_sch_chn_cfg_type,frame_80_used);

          b_packb(i_ptr->for_sch[i].sch_chn_cfg.max_rate,buf_ptr,buf_pos,
            FSIZ(cai_sch_chn_cfg_type,max_rate));
          buf_pos += FSIZ(cai_sch_chn_cfg_type,max_rate);
#else
          b_packb(0, buf_ptr, buf_pos, 6);
          buf_pos += 6;
#endif /* FEATURE_IS2000_REL_A */
        }
      }

      b_packb(i_ptr->rev_sch_cc_incl, buf_ptr, buf_pos,
        FSIZ(cai_srv_cfg_is2000_type, rev_sch_cc_incl));
      buf_pos += FSIZ(cai_srv_cfg_is2000_type, rev_sch_cc_incl);

      if (i_ptr->rev_sch_cc_incl)
      {
        b_packb(i_ptr->num_rev_sch, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, num_rev_sch));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, num_rev_sch);

        for (i=0; i<i_ptr->num_rev_sch; i++)
        {
          b_packb(i_ptr->rev_sch[i].rev_sch_id, buf_ptr, buf_pos,
            FSIZ(cai_rev_sch_type, rev_sch_id));
          buf_pos += FSIZ(cai_rev_sch_type, rev_sch_id);

          b_packw(i_ptr->rev_sch[i].rev_sch_mux, buf_ptr,buf_pos,
            FSIZ(cai_rev_sch_type, rev_sch_mux));
          buf_pos += FSIZ(cai_rev_sch_type, rev_sch_mux);

          b_packb(2, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type,sch_rec_len));
          buf_pos += FSIZ(cai_sch_chn_cfg_type,sch_rec_len);

          b_packb(i_ptr->rev_sch[i].sch_chn_cfg.sch_rc,buf_ptr,buf_pos,
            FSIZ(cai_sch_chn_cfg_type,sch_rc));
          buf_pos += FSIZ(cai_sch_chn_cfg_type,sch_rc);

          b_packb(i_ptr->rev_sch[i].sch_chn_cfg.coding,buf_ptr,buf_pos,
            FSIZ(cai_sch_chn_cfg_type,coding));
          buf_pos += FSIZ(cai_sch_chn_cfg_type,coding);

#ifdef FEATURE_IS2000_REL_A
          b_packb(i_ptr->rev_sch[i].sch_chn_cfg.frame_40_used, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, frame_40_used));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, frame_40_used);

          b_packb(i_ptr->rev_sch[i].sch_chn_cfg.frame_80_used, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, frame_80_used));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, frame_80_used);

          b_packb(i_ptr->rev_sch[i].sch_chn_cfg.max_rate, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, max_rate));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, max_rate);
#else
          b_packb(0, buf_ptr, buf_pos, 6);
          buf_pos += 6;
#endif /* FEATURE_IS2000_REL_A */

        }
      }

#ifdef FEATURE_IS2000_REL_B
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
      {
        b_packb(i_ptr->fch_dcch_mux_option_ind, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_rel_b_type, fch_dcch_mux_option_ind));
        buf_pos += FSIZ(cai_srv_cfg_is2000_rel_b_type, fch_dcch_mux_option_ind);

        if (i_ptr->fch_dcch_mux_option_ind == CAI_MUX_OPTION_DIFF_FOR_FCH_AND_DCCH)
        {
          b_packw(i_ptr->for_dcch_mux, buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_is2000_rel_b_type, for_dcch_mux));
          buf_pos += FSIZ(cai_srv_cfg_is2000_rel_b_type, for_dcch_mux);

          b_packw(i_ptr->rev_dcch_mux, buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_is2000_rel_b_type, rev_dcch_mux));
          buf_pos += FSIZ(cai_srv_cfg_is2000_rel_b_type, rev_dcch_mux);
        }
      }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        b_packb(i_ptr->for_pdch_cc_incl, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_rel_c_fix_type, for_pdch_cc_incl));
        buf_pos += FSIZ(cai_srv_cfg_is2000_rel_c_fix_type, for_pdch_cc_incl);

        if (i_ptr->for_pdch_cc_incl)
        {
          b_packw(i_ptr->for_pdch_mux_option, buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_is2000_rel_c_var_type, for_pdch_mux_option));
          buf_pos += FSIZ(cai_srv_cfg_is2000_rel_c_var_type, for_pdch_mux_option);

          b_packb(i_ptr->for_pdch_rc, buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_is2000_rel_c_var_type, for_pdch_rc));
          buf_pos += FSIZ(cai_srv_cfg_is2000_rel_c_var_type, for_pdch_rc);
        }
      }
#endif /* FEATURE_IS2000_REL_C */

    }

    record_num_bits = buf_pos - record_start_pos;
    record_num_bytes = (record_num_bits / 8);
    record_num_reserved = 8 - (record_num_bits % 8);
    if (record_num_reserved != 8)
    {
      record_num_bytes += 1;
      b_packb(0, buf_ptr, buf_pos, record_num_reserved);
      buf_pos += record_num_reserved;
    }

    b_packb((byte) record_num_bytes, buf_ptr, record_len_pos,
      FSIZ(cai_rec_hdr_type, record_len));

    *len_ptr = (record_num_bytes * 8) + sizeof(cai_rec_hdr_type);

    status = CAIX_DONE_S;

  }

  return (status);

} /* xlate_int_srv_cfg */

/*===========================================================================

FUNCTION XLATE_INT_INFO_REC

DESCRIPTION
  This function translates an information record from internal to external
  format.

DEPENDENCIES
  Depends on the internal information record to be of valid format.

RETURN VALUE
  Errors that were encountered while translating the information record.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_info_rec
(
  byte *i_ptr,
    /* Pointer to internal info rec to be translated */
  word *ilen_ptr,
    /* Pointer to variable in which to return the length, in bytes,
       of the internal info rec processed. */
  word max_xlen,
    /* Specifies the maximum length, in bits, that can be used to
       hold the external info rec. */
  byte *x_ptr,
    /* Pointer to buffer which is to contain external information
       record. */
  word x_pos,
    /* Offset in buffer at which to start external info rec. */
  word *xlen_ptr
    /* On exit, set to the actual number of bits used to
       hold the external info rec. */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i, j = 0;
    /* Index to loop through records */
  word rec_len;
    /* Number of bits in record */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ----------------------------------------------------
  ** Check to make sure that there is room for the header
  ** ---------------------------------------------------- */
  if ( sizeof(cai_rec_hdr_type) > max_xlen )
  {
    return ( CAIX_INV_LEN_S ); /* No room even for info rec header */
  }

  /* Put record type into info rec header */
  b_packb(((caii_rec_hdr_type *) i_ptr)->record_type,
    x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_type ) );
  x_pos += FSIZ(cai_rec_hdr_type, record_type);

  switch ( ((caii_rec_hdr_type *)i_ptr)->record_type )
  {
    /* ----------------------------
    ** Call Mode Information Record
    ** ---------------------------- */
    case CAI_CALL_MODE_REC:
    {
      caii_call_mode_rec_type *rec_ptr = (caii_call_mode_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_call_mode_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->orig_mode,
               x_ptr, x_pos, FSIZ( cai_call_mode_type, orig_mode ));
      x_pos += FSIZ( cai_call_mode_type, orig_mode );

      b_packw( rec_ptr->pri_service,
               x_ptr, x_pos, FSIZ( cai_call_mode_type, pri_service ));
      x_pos += FSIZ( cai_call_mode_type, pri_service );

      b_packw( rec_ptr->sec_service,
               x_ptr, x_pos, FSIZ( cai_call_mode_type, sec_service ));
      x_pos += FSIZ( cai_call_mode_type, sec_service );

      b_packb( 0, x_ptr, x_pos, FSIZ( cai_call_mode_type, reserved ));
      x_pos += FSIZ( cai_call_mode_type, reserved );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_call_mode_rec_type);

      break;
    } /* case CAI_CALL_MODE_REC */

    /* --------------------------------
    ** Terminal Information Info Record
    ** -------------------------------- */
    case CAI_TERM_INFO_REC:
    {
      caii_term_rec_type *rec_ptr = (caii_term_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      /* Compute record length, add in reserved bits (3 for Rel D, 4 otherwise) */
        rec_len = sizeof(cai_term_info_fix_type) +
                  (sizeof(cai_term_info_var_type) * rec_ptr->fix.num_so) + 4;


      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ) );
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->fix.mob_p_rev,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, mob_p_rev ));
      x_pos += FSIZ( cai_term_info_fix_type, mob_p_rev );

      b_packb( rec_ptr->fix.mob_mfg_code,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, mob_mfg_code ) );
      x_pos += FSIZ( cai_term_info_fix_type, mob_mfg_code );

      b_packb( rec_ptr->fix.mob_model,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, mob_model ));
      x_pos += FSIZ( cai_term_info_fix_type, mob_model );

      b_packw( rec_ptr->fix.mob_firm_rev,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, mob_firm_rev ));
      x_pos += FSIZ( cai_term_info_fix_type, mob_firm_rev );

      b_packb( rec_ptr->fix.scm,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, scm ));
      x_pos += FSIZ( cai_term_info_fix_type, scm );

      b_packb( rec_ptr->fix.local_ctrl,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, local_ctrl ));
      x_pos += FSIZ( cai_term_info_fix_type, local_ctrl );

      b_packb( rec_ptr->fix.slot_cycle_index,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, slot_cycle_index ));
      x_pos += FSIZ( cai_term_info_fix_type, slot_cycle_index );

      /* -----------------------------
      ** Pack array of service options
      ** ----------------------------- */
      for ( i = 0; i < rec_ptr->fix.num_so; i++ )
      {
        b_packw( rec_ptr->var[i].service_option,
                 x_ptr, x_pos,
                 FSIZ( cai_term_info_var_type, service_option ) );
        x_pos += FSIZ( cai_term_info_var_type, service_option );
      }

      /* Otherwise, pack 4 reserved bits */
      b_packb( 0, x_ptr, x_pos, 4 );
      x_pos += 4;

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_term_rec_fix_type) +
                  (sizeof(caii_term_rec_var_type) * rec_ptr->fix.num_so);

      break;
    } /* case CAI_TERM_INFO_REC */

    /* -------------------------------
    ** Roaming Information Info Record
    ** ------------------------------- */
    case CAI_ROAM_INFO_REC:
    {
      caii_roam_rec_type *rec_ptr = (caii_roam_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      /* --------------------------
      ** Calculate RECORD_LEN field
      ** -------------------------- */
      rec_len = sizeof(cai_roam_info_fix_type) +
                (sizeof(cai_roam_info_var_type) * rec_ptr->fix.num_vars);

      if ( sizeof(cai_rec_hdr_type) + RND8( rec_len ) > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( RND8( rec_len ) / 8,
               x_ptr, x_pos,
               FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->fix.accolc, x_ptr,
               x_pos, FSIZ( cai_roam_info_fix_type, accolc ));
      x_pos += FSIZ( cai_roam_info_fix_type, accolc );

      b_packb( rec_ptr->fix.mob_term_home,
               x_ptr, x_pos,
               FSIZ( cai_roam_info_fix_type, mob_term_home ));
      x_pos += FSIZ( cai_roam_info_fix_type, mob_term_home );

      b_packb( rec_ptr->fix.mob_term_for_sid,
               x_ptr, x_pos,
               FSIZ( cai_roam_info_fix_type,mob_term_for_sid ));
      x_pos += FSIZ( cai_roam_info_fix_type, mob_term_for_sid );

      b_packb( rec_ptr->fix.mob_term_for_nid,
               x_ptr, x_pos,
               FSIZ( cai_roam_info_fix_type,mob_term_for_nid ));
      x_pos += FSIZ( cai_roam_info_fix_type, mob_term_for_nid );

      for ( i = 0; i < rec_ptr->fix.num_vars; i++ )
      {
        b_packw( rec_ptr->var[i].sid,
                 x_ptr, x_pos, FSIZ( cai_roam_info_var_type, sid ));
        x_pos += FSIZ( cai_roam_info_var_type, sid );

        b_packw( rec_ptr->var[i].nid,
                 x_ptr, x_pos, FSIZ( cai_roam_info_var_type, nid ));
        x_pos += FSIZ( cai_roam_info_var_type, nid );
      }

      b_packb ( 0, x_ptr, x_pos, RND8( rec_len ) - rec_len );
      x_pos += RND8( rec_len ) - rec_len;

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = RND8( rec_len ) + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_roam_rec_fix_type) +
                  (sizeof(caii_roam_rec_var_type) * rec_ptr->fix.num_vars);

      break;
    } /* case CAI_ROAM_INFO_REC */

    /* ----------------------------------
    ** Security Status Information Record
    ** ---------------------------------- */
    case CAI_SEC_REC:
    {
      caii_sec_stat_rec_type *rec_ptr = (caii_sec_stat_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      /* -----------------------------------------------------
      ** Compute record length
      ** ----------------------------------------------------- */
      rec_len = sizeof(cai_sec_stat_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->auth_mode,
               x_ptr, x_pos, FSIZ( cai_sec_stat_type, auth_mode ));
      x_pos += FSIZ( cai_sec_stat_type, auth_mode );

      b_packb( rec_ptr->encrypt_mode,
               x_ptr, x_pos, FSIZ( cai_sec_stat_type, encrypt_mode ));
      x_pos += FSIZ( cai_sec_stat_type, encrypt_mode );

      b_packb( rec_ptr->private_lcm,
               x_ptr, x_pos, FSIZ( cai_sec_stat_type, private_lcm ));
      x_pos += FSIZ( cai_sec_stat_type, private_lcm );

      b_packb( 0, x_ptr, x_pos, FSIZ( cai_sec_stat_type, reserved ));
      x_pos += FSIZ( cai_sec_stat_type, reserved );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_sec_stat_rec_type);

      break;
    } /* case CAI_SEC_REC */

    /* -----------------------
    ** IMSI Information Record
    ** ----------------------- */
    case CAI_IMSI_REC:
    case CAI_IMSI_M_REC:
    case CAI_IMSI_T_REC:
    {
      caii_imsi_rec_type *rec_ptr = (caii_imsi_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      /* --------------------------------------------
      ** IMSI Info Record length = 7 octets (56 bits)
      ** -------------------------------------------- */
      rec_len = sizeof(cai_imsi_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->imsi_class,
               x_ptr, x_pos, FSIZ( cai_imsi_info_type, imsi_class ));
      x_pos += FSIZ( cai_imsi_info_type, imsi_class );

      b_packb( rec_ptr->imsi_addr_num,
               x_ptr, x_pos,
               FSIZ( cai_imsi_info_type, imsi_addr_num ));
      x_pos += FSIZ( cai_imsi_info_type, imsi_addr_num );

      b_packw( rec_ptr->mcc,
               x_ptr, x_pos, FSIZ( cai_imsi_info_type, mcc ));
      x_pos += FSIZ( cai_imsi_info_type, mcc );

      b_packb( rec_ptr->imsi_11_12,
               x_ptr, x_pos, FSIZ( cai_imsi_info_type, imsi_11_12 ));
      x_pos += FSIZ( cai_imsi_info_type, imsi_11_12 );

      b_packq( rec_ptr->imsi_s,
               x_ptr, x_pos, FSIZ( cai_imsi_info_type, imsi_s ));
      x_pos += FSIZ( cai_imsi_info_type, imsi_s );

      b_packb( 0, x_ptr, x_pos, FSIZ( cai_imsi_info_type, reserved ));
      x_pos += FSIZ( cai_imsi_info_type, reserved );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_imsi_rec_type);

      break;
    } /* case CAI_IMSI_REC */

    /* ----------------------
    ** ESN Information Record
    ** ---------------------- */
    case CAI_ESN_REC:
    {
      caii_esn_rec_type *rec_ptr = (caii_esn_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      /* -------------------------------------------
      ** ESN Info Record length = 4 octets (32 bits)
      ** ------------------------------------------- */
      rec_len = sizeof(cai_esn_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packd( rec_ptr->esn,
               x_ptr, x_pos, FSIZ( cai_esn_info_type, esn ));
      x_pos += FSIZ( cai_esn_info_type, esn );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_esn_rec_type);

      break;
    } /* case CAI_ESN_REC */

    /* ---------------------------------
    ** Band Class Information Record
    ** --------------------------------- */
    case CAI_BAND_REC:
    {
      caii_band_rec_type *rec_ptr = (caii_band_rec_type *) i_ptr;
      /* Convenient helper pointer of correct type to avoid casting */
      uint8 num_bytes = 1;
      /* Num of bytes needed for this IR */
      uint32 band_mask = 0;
      /* Band classes can go all the way up to 32 */

      /* Construct the band mask to reflect how many band classes are
         supported. This is a bit mask with  LSB 0 representing BC 0 */
      for (i=0; i<CAI_MAX_BAND_CLASSES; i++)
      {
        if (rec_ptr->band[i])
        {
          band_mask |= 1 << i;
        }
      }

      /* Now use the band mask to figure out how many bytes we need for representing
         the band classes */
      if (band_mask > ((1<<24)-1))
      {
        /* Value needs more than 24 bits */
        num_bytes = 4;
      }
      else if (band_mask > ((1<<16)-1))
      {
        /* Value needs more than 16 bits */
        num_bytes = 3;
      }
      else if (band_mask > ((1<<8)-1))
      {
        /* Value needs more than 8 bits */
        num_bytes = 2;
      }

      /* Convert rec length to bits from bytes */
      rec_len = num_bytes << 3;

      if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
      {
        return(CAIX_INV_LEN_S); /* Rec won't fit */
      }

      /* Put in record len */
      b_packw(rec_len / 8,
              x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
      x_pos += FSIZ(cai_rec_hdr_type, record_len);

      /* Add other record fields */
      for (i=0 ; i<num_bytes*8 ; i++)
      {
        /* Now pack the band class values.  Note number of bits in the IR
           could be more than the array size itself as this accounts for
           reserved bits too, so do a bounds check here */
        if (i < CAI_MAX_BAND_CLASSES)
        {
          b_packb(rec_ptr->band[i],
                  x_ptr, x_pos, FSIZ( cai_band_info_type, band));
        }
        else
        {
          /* Past the array means we are certainly in reserved bits area,
             pack 0's here */
          b_packb(0, x_ptr, x_pos, FSIZ( cai_band_info_type, band));
        }
        x_pos += FSIZ(cai_band_info_type, band);
      }

      /* Set external info rec length, and internal rec length */
      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_band_rec_type);
      break;
    } /* case CAI_BAND_REC */

    /* ------------------------------
    ** Power Class Information Record
    ** ------------------------------ */
    case CAI_PWR_REC:
    {
      caii_pwr_rec_type *rec_ptr = (caii_pwr_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_pwr_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb ( rec_ptr->max_eirp,
                x_ptr, x_pos, FSIZ( cai_pwr_info_type, max_eirp ) );
      x_pos += FSIZ( cai_pwr_info_type, max_eirp );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_pwr_rec_type);

      break;
    } /* case CAI_PWR_REC */

    /* ---------------------------------
    ** Operating Mode Information Record
    ** --------------------------------- */
    case CAI_OP_MODE_REC:
    {
      caii_op_mode_rec_type *rec_ptr = (caii_op_mode_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_op_mode_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->op_mode0,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, op_mode0 ) );
      x_pos += FSIZ( cai_op_mode_info_type, op_mode0 );

      b_packb( rec_ptr->op_mode1,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, op_mode1 ) );
      x_pos += FSIZ( cai_op_mode_info_type, op_mode1 );

      b_packb( rec_ptr->op_mode2,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, op_mode2 ) );
      x_pos += FSIZ( cai_op_mode_info_type, op_mode2 );

      b_packb( rec_ptr->op_mode3,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, op_mode3 ) );
      x_pos += FSIZ( cai_op_mode_info_type, op_mode3 );

      b_packb( rec_ptr->op_mode4,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, op_mode4 ) );
      x_pos += FSIZ( cai_op_mode_info_type, op_mode4 );

      b_packb( 0,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, reserved ) );
      x_pos += FSIZ( cai_op_mode_info_type, reserved );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_op_mode_rec_type);

      break;
    } /* case CAI_OP_MODE_REC */

    /* ---------------------------------
    ** Service Option Information Record
    ** --------------------------------- */
    case CAI_SO_REC:
    {
      caii_so_rec_type *rec_ptr = (caii_so_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_so_info_var_type) * rec_ptr->fix.num_so;

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      for ( i = 0; i < rec_ptr->fix.num_so; i++ )
      {
        b_packb ( 0,
                  x_ptr, x_pos, FSIZ( cai_so_info_var_type, reserved ) );
        x_pos += FSIZ( cai_so_info_var_type, reserved );

        b_packb ( rec_ptr->var[i].fwd,
                  x_ptr, x_pos, FSIZ( cai_so_info_var_type, fwd ) );
        x_pos += FSIZ( cai_so_info_var_type, fwd );

        b_packb ( rec_ptr->var[i].rev,
                  x_ptr, x_pos, FSIZ( cai_so_info_var_type, rev ) );
        x_pos += FSIZ( cai_so_info_var_type, rev );

        b_packw ( rec_ptr->var[i].so,
                  x_ptr, x_pos, FSIZ( cai_so_info_var_type, so ) );
        x_pos += FSIZ( cai_so_info_var_type, so );
      } /* for */

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_so_rec_fix_type) +
                  (sizeof(caii_so_rec_var_type) * rec_ptr->fix.num_so);

      break;
    } /* case CAI_SO_REC */

    /* -----------------------------------
    ** Multiplex Option Information Record
    ** ----------------------------------- */
    case CAI_MUX_REC:
    {
      caii_mux_rec_type *rec_ptr = (caii_mux_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_mux_info_type) * rec_ptr->fix.num_mux;

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      for ( i = 0; i < rec_ptr->fix.num_mux; i++ )
      {
        b_packw ( rec_ptr->var[i].mux,
                  x_ptr, x_pos, FSIZ( cai_mux_info_type, mux ) );
        x_pos += FSIZ( cai_mux_info_type, mux );

        b_packb ( rec_ptr->var[i].fwd_rates,
                  x_ptr, x_pos, FSIZ( cai_mux_info_type, fwd_rates ) );
        x_pos += FSIZ( cai_mux_info_type, fwd_rates );

        b_packb ( rec_ptr->var[i].rev_rates,
                  x_ptr, x_pos, FSIZ( cai_mux_info_type, rev_rates ) );
        x_pos += FSIZ( cai_mux_info_type, rev_rates );
      } /* for */

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_mux_rec_fix_type) +
                  (sizeof(caii_mux_rec_var_type) * rec_ptr->fix.num_mux);

      break;
    } /* case CAI_MUX_REC */

    /* ----------------------------------------
    ** Service Configuration Information Record
    ** ---------------------------------------- */
    case CAI_RTC_SRV_CFG_REC:
    {
      caii_srv_cfg_type  *rec_ptr = (caii_srv_cfg_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_srv_cfg_hdr_type) +
                (sizeof(cai_srv_cfg_con_type) * rec_ptr->num_con);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      x_pos -= FSIZ( cai_rec_hdr_type, record_type );
        /* Backup to start of record. xlate_int_srv_cfg will fill in
           record type and record length */

      status =
        xlate_int_srv_cfg ( xlen_ptr,
                            x_ptr,
                            x_pos,
                            (caii_srv_cfg_type *) i_ptr );

      if ( status != CAIX_DONE_S )
      {
        return ( status );
      }

      /* Set external info rec length, and internal rec length */

      /* Note: *xlen_ptr will be set by xlate_int_srv_cfg */

      *ilen_ptr = sizeof(caii_srv_cfg_type);

      break;
    } /* case CAI_RTC_SRV_CFG_REC */

    /* ------------------------------
    ** Power Control Information Record
    ** ------------------------------ */
    case CAI_PWR_CTRL_REC:
    {
      caii_pwr_ctrl_rec_type *rec_ptr = (caii_pwr_ctrl_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_pwr_ctrl_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb ( rec_ptr->min_pwr_cntl_step,
                x_ptr, x_pos, FSIZ( cai_pwr_ctrl_info_type,
                                      min_pwr_cntl_step ) );
      x_pos += FSIZ( cai_pwr_ctrl_info_type, min_pwr_cntl_step );

      b_packb ( 0,
                x_ptr, x_pos, FSIZ( cai_pwr_ctrl_info_type,
                                      reserved ) );
      x_pos += FSIZ( cai_pwr_ctrl_info_type, reserved );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_pwr_ctrl_rec_type);

      break;
    } /* case CAI_PWR_CTRL_REC */

    /* ------------------------------
    ** Capability Information Record
    ** ------------------------------ */
    case CAI_CAPA_INFO_REC:
    {
      word rec_len_pos = 0;
      word rec_start_pos = 0;
      word rec_num_bits = 0;
      word rec_num_bytes = 0;
      word rec_num_reserved = 0;

      caii_capa_rec_type *rec_ptr = (caii_capa_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len_pos = x_pos;
      x_pos += FSIZ(cai_rec_hdr_type, record_len);
      rec_start_pos = x_pos;

      b_packb(rec_ptr->acc_entry_ho, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, acc_entry_ho));
      x_pos += FSIZ(cai_capa_info_type, acc_entry_ho);

      b_packb(rec_ptr->acc_probe_ho, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, acc_probe_ho));
      x_pos += FSIZ(cai_capa_info_type, acc_probe_ho);

      b_packb(rec_ptr->analog_search, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, analog_search));
      x_pos += FSIZ(cai_capa_info_type, analog_search);

      b_packb(rec_ptr->hop_beacon, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, hop_beacon));
      x_pos += FSIZ(cai_capa_info_type, hop_beacon);

      b_packb(rec_ptr->mahho, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, mahho));
      x_pos += FSIZ(cai_capa_info_type, mahho);

      b_packb(rec_ptr->puf, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, puf));
      x_pos += FSIZ(cai_capa_info_type, puf);

      b_packb(rec_ptr->analog_553, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, analog_553));
      x_pos += FSIZ(cai_capa_info_type, analog_553);

      *ilen_ptr = FENDPOS(caii_capa_rec_type, analog_553);

      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
      {
        b_packb(rec_ptr->qpch, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_type,qpch));
        x_pos += FSIZ(cai_capa_info_is2000_type,qpch);

        b_packb(rec_ptr->slotted_timer, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_type,slotted_timer));
        x_pos += FSIZ(cai_capa_info_is2000_type,slotted_timer);

        b_packb(rec_ptr->chs_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_type,chs_supported));
        x_pos += FSIZ(cai_capa_info_is2000_type,chs_supported);

        if (rec_ptr->chs_supported)
        {
          b_packb(rec_ptr->gating_rate_set, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_type,gating_rate_set));
          x_pos += FSIZ(cai_capa_info_is2000_type,gating_rate_set);
        }

        b_packb(rec_ptr->ext_cap_included, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_type, ext_cap_included));
        x_pos += FSIZ(cai_capa_info_is2000_type, ext_cap_included);

        if (rec_ptr->ext_cap_included)
        {
          b_packb(rec_ptr->mabo, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_type,mabo));
          x_pos += FSIZ(cai_capa_info_is2000_type, mabo);

          b_packb(rec_ptr->sdb, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_type, sdb));
          x_pos += FSIZ(cai_capa_info_is2000_type, sdb);
        }

        b_packb(rec_ptr->rlp_cap_blob_len, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_type,rlp_cap_blob_len));
        x_pos += FSIZ(cai_capa_info_is2000_type, rlp_cap_blob_len);

        *ilen_ptr = FENDPOS(caii_capa_rec_type, rlp_cap_blob_len);

        for (i=0; i<rec_ptr->rlp_cap_blob_len && i<CAI_MAX_RLP_INFO_LEN; i++)
        {
          b_packb(rec_ptr->rlp_cap_blob[i], x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_type, rlp_cap_blob));
          x_pos += FSIZ(cai_capa_info_is2000_type, rlp_cap_blob);

          *ilen_ptr = (word) FENDPOS(caii_capa_rec_type, rlp_cap_blob[i]);
        }
      }

#if defined(FEATURE_IS2000_REL_A) || defined(FEATURE_IS2000_1X_ADV)
      if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
#ifdef FEATURE_IS2000_1X_ADV
          || ((caix_p_rev_in_use >= CAIX_P_REV_IS2000) && rec_ptr->rel_e_cap_included)
#endif /* FEATURE_IS2000_1X_ADV */
         )
      {
        /* P_REV checking here is really not required by the standard.
           But since we've done that for Rel 0, we will keep the same
           behavior here
        */
        b_packb(rec_ptr->flex_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_a_type, flex_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, flex_supported);

        if (rec_ptr->flex_supported)
        {
          b_packb(rec_ptr->f_fch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, f_fch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, f_fch_flex_supported);

          b_packb(rec_ptr->r_fch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, r_fch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, r_fch_flex_supported);

          b_packb(rec_ptr->f_dcch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, f_dcch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, f_dcch_flex_supported);

          b_packb(rec_ptr->r_dcch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, r_dcch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, r_dcch_flex_supported);

          b_packb(rec_ptr->f_sch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_flex_supported);

          b_packb(rec_ptr->r_sch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_flex_supported);
        }

        b_packb(rec_ptr->var_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_a_type, var_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, var_supported);

        if (rec_ptr->var_supported)
        {
          b_packb(rec_ptr->f_sch_var_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_var_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_var_supported);

          b_packb(rec_ptr->r_sch_var_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_var_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_var_supported);

          if (rec_ptr->f_sch_var_supported)
          {
            b_packw(rec_ptr->max_num_bits_c, x_ptr, x_pos,
              FSIZ(cai_capa_info_is2000_rel_a_type, max_num_bits_c));
            x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, max_num_bits_c);

            b_packw(rec_ptr->max_num_bits_t, x_ptr, x_pos,
              FSIZ(cai_capa_info_is2000_rel_a_type, max_num_bits_t));
            x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, max_num_bits_t);
          }
        }

        b_packb(rec_ptr->cs_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_a_type, cs_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, cs_supported);

        b_packb(rec_ptr->f_sch_ltu_tab_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_ltu_tab_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_ltu_tab_supported);

        b_packb(rec_ptr->r_sch_ltu_tab_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_ltu_tab_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_ltu_tab_supported);

        *ilen_ptr = FENDPOS(caii_capa_rec_type, r_sch_ltu_tab_supported);
      }
#endif /* FEATURE_IS2000_REL_A || FEATURE_IS2000_1X_ADV */

#if defined(FEATURE_IS2000_REL_B) || defined(FEATURE_IS2000_1X_ADV)
      if (((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
#ifdef FEATURE_IS2000_1X_ADV
            || ((caix_p_rev_in_use >= CAIX_P_REV_IS2000) && rec_ptr->rel_e_cap_included)
#endif /* FEATURE_IS2000_1X_ADV */
          ) && (rec_ptr->var_supported || rec_ptr->flex_supported))
      {
        b_packb(rec_ptr->eram_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_b_type, eram_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_b_type, eram_supported);

        *ilen_ptr = FENDPOS(caii_capa_rec_type, eram_supported);
      }
#endif /* FEATURE_IS2000_REL_B || FEATURE_IS2000_1X_ADV */

#if defined(FEATURE_IS2000_REL_C) || defined(FEATURE_IS2000_1X_ADV)
      if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
#ifdef FEATURE_IS2000_1X_ADV
          || ((caix_p_rev_in_use >= CAIX_P_REV_IS2000) && rec_ptr->rel_e_cap_included)
#endif /* FEATURE_IS2000_1X_ADV */
         )
      {
        b_packb(rec_ptr->pdch_chm_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_c_type, pdch_chm_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_c_type, pdch_chm_supported);

        b_packb(rec_ptr->rev_fch_gating_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_c_type, rev_fch_gating_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_c_type, rev_fch_gating_supported);

        *ilen_ptr = FENDPOS(caii_capa_rec_type, rev_fch_gating_supported);
      } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) */
#endif /* FEATURE_IS2000_REL_C */

#if defined(FEATURE_IS2000_1X_ADV)
      if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_D)
#ifdef FEATURE_IS2000_1X_ADV
          || ((caix_p_rev_in_use >= CAIX_P_REV_IS2000) && rec_ptr->rel_e_cap_included)
#endif /* FEATURE_IS2000_1X_ADV */
         )
      {
        b_packb(rec_ptr->rer_mode_supported, x_ptr, x_pos,
                FSIZ(cai_capa_info_is2000_rel_d_type, rer_mode_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_d_type, rer_mode_supported);

        b_packb(rec_ptr->add_num_sync_id_incl, x_ptr, x_pos,
                FSIZ(cai_capa_info_is2000_rel_d_type, add_num_sync_id_incl));
        x_pos += FSIZ(cai_capa_info_is2000_rel_d_type, add_num_sync_id_incl);

        if (rec_ptr->add_num_sync_id_incl)
        {
          b_packb(rec_ptr->add_num_sync_id, x_ptr, x_pos,
                  FSIZ(cai_capa_info_is2000_rel_d_type, add_num_sync_id));
          x_pos += FSIZ(cai_capa_info_is2000_rel_d_type, add_num_sync_id);
        }

        b_packb(rec_ptr->rsc_mode_supported, x_ptr, x_pos,
                FSIZ(cai_capa_info_is2000_rel_d_type, rsc_mode_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_d_type, rsc_mode_supported);

        b_packb(rec_ptr->tkz_mode_supported, x_ptr, x_pos,
                FSIZ(cai_capa_info_is2000_rel_d_type, tkz_mode_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_d_type, tkz_mode_supported);

        *ilen_ptr = FENDPOS(caii_capa_rec_type, tkz_mode_supported);
      }
#endif /* FEATURE_IS2000_1X_ADV */

#ifdef FEATURE_IS2000_1X_ADV
      if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000) && rec_ptr->rel_e_cap_included)
      {
        M1X_MSG( DCP, LEGACY_MED,
          "Rel E Capability Info included");
        b_packb(rec_ptr->f_sch_early_term_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_e_type, f_sch_early_term_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_e_type, f_sch_early_term_supported);

        b_packb(rec_ptr->rpc_mode_01_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_e_type, rpc_mode_01_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_e_type, rpc_mode_01_supported);

        b_packb(rec_ptr->f_sch_delayed_arq_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_e_type, f_sch_delayed_arq_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_e_type, f_sch_delayed_arq_supported);

        b_packb(rec_ptr->r_sch_delayed_arq_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_e_type, r_sch_delayed_arq_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_e_type, r_sch_delayed_arq_supported);

        b_packb(rec_ptr->so73_op0_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_e_type, so73_op0_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_e_type, so73_op0_supported);

        *ilen_ptr = FENDPOS(caii_capa_rec_type, so73_op0_supported);
      }
#endif /* FEATURE_IS2000_1X_ADV */

      rec_num_bits = x_pos - rec_start_pos;
      rec_num_bytes = (rec_num_bits / 8);
      rec_num_reserved = 8 - (rec_num_bits % 8);

      if (rec_num_reserved != 8)
      {
        rec_num_bytes += 1;
        b_packb(0, x_ptr, x_pos, rec_num_reserved);
        x_pos += rec_num_reserved;
      }

      b_packb((byte) rec_num_bytes, x_ptr, rec_len_pos,
        FSIZ(cai_rec_hdr_type, record_len));

      *xlen_ptr = rec_num_bytes * 8 + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_CAPA_INFO_REC */

    /* ------------------------------
    ** Channel Config Capability Info
    ** ------------------------------ */
    case CAI_CHAN_CFG_CAPA_INFO_REC:
    {
      word rec_len_pos = 0;
      word rec_start_pos = 0;
      word rec_num_bits = 0;
      word rec_num_bytes = 0;
      word rec_num_reserved = 0;

      caii_chan_cfg_capa_info_type *rec_ptr =
        (caii_chan_cfg_capa_info_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len_pos = x_pos;
      x_pos += FSIZ(cai_rec_hdr_type, record_len);
      rec_start_pos = x_pos;

      b_packb(rec_ptr->otd_supported, x_ptr, x_pos,
        FSIZ(cai_chan_cfg_capa_info_type, otd_supported));
      x_pos += FSIZ(cai_chan_cfg_capa_info_type, otd_supported);

      b_packb(rec_ptr->fch_supported, x_ptr, x_pos,
        FSIZ(cai_chan_cfg_capa_info_type, fch_supported));
      x_pos += FSIZ(cai_chan_cfg_capa_info_type, fch_supported);

      if (rec_ptr->fch_supported)
      {
        b_packb(rec_ptr->fch_fields.fch_frame_size, x_ptr, x_pos,
          FSIZ(cai_fch_spec_fields_type, fch_frame_size));
        x_pos += FSIZ(cai_fch_spec_fields_type, fch_frame_size);

        b_packb(rec_ptr->fch_fields.for_fch_len, x_ptr, x_pos,
          FSIZ(cai_fch_spec_fields_type, for_fch_len));
        x_pos += FSIZ(cai_fch_spec_fields_type, for_fch_len);

        if (rec_ptr->fch_fields.for_fch_len)
        {
          b_packw(rec_ptr->fch_fields.for_fch_rc_map, x_ptr, x_pos,
            (rec_ptr->fch_fields.for_fch_len *
             FSIZ(cai_fch_spec_fields_type, for_fch_rc_map)));
          x_pos += (rec_ptr->fch_fields.for_fch_len *
            FSIZ(cai_fch_spec_fields_type, for_fch_rc_map));
        }

        b_packb(rec_ptr->fch_fields.rev_fch_len, x_ptr, x_pos,
          FSIZ(cai_fch_spec_fields_type, rev_fch_len));
        x_pos += FSIZ(cai_fch_spec_fields_type, rev_fch_len);

        if (rec_ptr->fch_fields.rev_fch_len)
        {
          b_packw(rec_ptr->fch_fields.rev_fch_rc_map, x_ptr, x_pos,
            (rec_ptr->fch_fields.rev_fch_len *
             FSIZ(cai_fch_spec_fields_type, rev_fch_rc_map)));
          x_pos += (rec_ptr->fch_fields.rev_fch_len *
            FSIZ(cai_fch_spec_fields_type, rev_fch_rc_map));
        }
      }

      b_packb(rec_ptr->dcch_supported, x_ptr, x_pos,
        FSIZ(cai_chan_cfg_capa_info_type, dcch_supported));
      x_pos += FSIZ(cai_chan_cfg_capa_info_type, dcch_supported);

      if (rec_ptr->dcch_supported)
      {
        b_packb(rec_ptr->dcch_fields.dcch_frame_size, x_ptr, x_pos,
          FSIZ(cai_dcch_spec_fields_type, dcch_frame_size));
        x_pos += FSIZ(cai_dcch_spec_fields_type, dcch_frame_size);

        b_packb(rec_ptr->dcch_fields.for_dcch_len, x_ptr, x_pos,
          FSIZ(cai_dcch_spec_fields_type, for_dcch_len));
        x_pos += FSIZ(cai_dcch_spec_fields_type, for_dcch_len);

        if (rec_ptr->dcch_fields.for_dcch_len)
        {
          b_packw(rec_ptr->dcch_fields.for_dcch_rc_map, x_ptr, x_pos,
            (rec_ptr->dcch_fields.for_dcch_len *
             FSIZ(cai_dcch_spec_fields_type ,for_dcch_rc_map)));
          x_pos += (rec_ptr->dcch_fields.for_dcch_len *
            FSIZ(cai_dcch_spec_fields_type,for_dcch_rc_map));
        }

        b_packb(rec_ptr->dcch_fields.rev_dcch_len, x_ptr, x_pos,
          FSIZ(cai_dcch_spec_fields_type, rev_dcch_len));
        x_pos += FSIZ(cai_dcch_spec_fields_type, rev_dcch_len);

        if (rec_ptr->dcch_fields.rev_dcch_len)
        {
          b_packb(rec_ptr->dcch_fields.rev_dcch_rc_map, x_ptr, x_pos,
            (rec_ptr->dcch_fields.rev_dcch_len *
             FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map)));
          x_pos += (rec_ptr->dcch_fields.rev_dcch_len *
            FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map));
        }
      }

      b_packb(rec_ptr->for_sch_supported, x_ptr, x_pos,
        FSIZ(cai_chan_cfg_capa_info_type, for_sch_supported));
      x_pos += FSIZ(cai_chan_cfg_capa_info_type, for_sch_supported);

      if (rec_ptr->for_sch_supported)
      {
        b_packb(rec_ptr->for_sch_fields.for_sch_len, x_ptr, x_pos,
          FSIZ(cai_for_sch_spec_fields_type, for_sch_len));
        x_pos += FSIZ(cai_for_sch_spec_fields_type, for_sch_len);

        if (rec_ptr->for_sch_fields.for_sch_len)
        {
          b_packw(rec_ptr->for_sch_fields.for_sch_rc_map, x_ptr, x_pos,
            (rec_ptr->for_sch_fields.for_sch_len *
             FSIZ(cai_for_sch_spec_fields_type, for_sch_rc_map)));
          x_pos += (rec_ptr->for_sch_fields.for_sch_len *
            FSIZ(cai_for_sch_spec_fields_type, for_sch_rc_map));
        }

        b_packb(rec_ptr->for_sch_fields.for_sch_num, x_ptr, x_pos,
          FSIZ(cai_for_sch_spec_fields_type, for_sch_num));
        x_pos += FSIZ(cai_for_sch_spec_fields_type, for_sch_num);

        for (i=0; i<rec_ptr->for_sch_fields.for_sch_num &&
                  i<CAI_MAX_NUM_FOR_SCH; i++)
        {
          b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_turbo_supported,
            x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_turbo_supported));
          x_pos += FSIZ(cai_for_sch_spec_fields_type, for_turbo_supported);

          if (rec_ptr->for_sch_fields.for_sch_recs[i].for_turbo_supported)
          {
            b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_max_turbo_block_size,
              x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_max_turbo_block_size));
            x_pos += FSIZ(cai_for_sch_spec_fields_type, for_max_turbo_block_size);
          }

          b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_conv_supported,
            x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_conv_supported));
          x_pos += FSIZ(cai_for_sch_spec_fields_type, for_conv_supported);

          if (rec_ptr->for_sch_fields.for_sch_recs[i].for_conv_supported)
          {
            b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_max_conv_block_size,
              x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_max_conv_block_size));
            x_pos += FSIZ(cai_for_sch_spec_fields_type, for_max_conv_block_size);
          }

#ifdef FEATURE_IS2000_REL_A
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
            b_packb( rec_ptr->for_sch_fields.for_sch_recs[i].for_frame_40_supported,
              x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_frame_40_supported));
            x_pos += FSIZ(cai_for_sch_spec_fields_type, for_frame_40_supported);

            b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_frame_80_supported,
              x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_frame_80_supported));
            x_pos += FSIZ(cai_for_sch_spec_fields_type, for_frame_80_supported);

            b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_max_rate,
              x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_max_rate));
            x_pos += FSIZ(cai_for_sch_spec_fields_type, for_max_rate);
          }
          else
#endif /* FEATURE_IS2000_REL_A */
          {
            b_packb(0, x_ptr, x_pos, 6);
            x_pos += 6;
          }
        }
      }

      b_packb(rec_ptr->rev_sch_supported, x_ptr, x_pos,
        FSIZ(cai_chan_cfg_capa_info_type, rev_sch_supported));
      x_pos += FSIZ( cai_chan_cfg_capa_info_type, rev_sch_supported);

      *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type, rev_sch_supported);

      if (rec_ptr->rev_sch_supported)
      {
        b_packb(rec_ptr->rev_sch_fields.rev_sch_len, x_ptr, x_pos,
          FSIZ(cai_rev_sch_spec_fields_type, rev_sch_len));
        x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_sch_len);

        if (rec_ptr->rev_sch_fields.rev_sch_len)
        {
          b_packb(rec_ptr->rev_sch_fields.rev_sch_rc_map,
            x_ptr, x_pos, (rec_ptr->rev_sch_fields.rev_sch_len *
            FSIZ(cai_rev_sch_spec_fields_type,rev_sch_rc_map)));

          x_pos += (rec_ptr->rev_sch_fields.rev_sch_len *
            FSIZ(cai_rev_sch_spec_fields_type, rev_sch_rc_map));
        }

        b_packb(rec_ptr->rev_sch_fields.rev_sch_num, x_ptr, x_pos,
          FSIZ(cai_rev_sch_spec_fields_type, rev_sch_num));
        x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_sch_num);

        *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type,
          rev_sch_fields.rev_sch_num);

        for (i=0; i<rec_ptr->rev_sch_fields.rev_sch_num &&
                  i<CAI_MAX_NUM_REV_SCH; i++)
        {
          b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_turbo_supported,
            x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_turbo_supported));
          x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_turbo_supported);

          if (rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_turbo_supported)
          {
            b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_max_turbo_block_size,
              x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_max_turbo_block_size));
            x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_max_turbo_block_size);
          }

          b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_conv_supported,
            x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_conv_supported));
          x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_conv_supported);

          *ilen_ptr = (word) FENDPOS(caii_chan_cfg_capa_info_type,
            rev_sch_fields.rev_sch_recs[i].rev_conv_supported);

          if (rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_conv_supported)
          {
            b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_max_conv_block_size,
              x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_max_conv_block_size));
            x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_max_conv_block_size);
          }

#ifdef FEATURE_IS2000_REL_A
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
            b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_frame_40_supported,
              x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_frame_40_supported));
            x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_frame_40_supported);

            b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_frame_80_supported,
              x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_frame_80_supported));
            x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_frame_80_supported);

            b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_max_rate,
              x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_max_rate));
            x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_max_rate);
          }
          else
#endif /* FEATURE_IS2000_REL_A */
          {
            b_packb(0, x_ptr, x_pos, 6);
            x_pos += 6;
          }
          *ilen_ptr = (word) FENDPOS(caii_chan_cfg_capa_info_type,
            rev_sch_fields.rev_sch_recs[i]);
        }
      }

      if ((rec_ptr->for_sch_supported) || (rec_ptr->rev_sch_supported))
      {
        b_packb(0, x_ptr, x_pos, FSIZ(cai_chan_cfg_capa_info_type, reserved));
        x_pos += FSIZ( cai_chan_cfg_capa_info_type, reserved );
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        b_packb(rec_ptr->sts_supported, /*lint !e539 */
          x_ptr, x_pos,
          FSIZ(cai_chan_cfg_capa_info_is2000_rel_a_type, sts_supported));
        x_pos += FSIZ(cai_chan_cfg_capa_info_is2000_rel_a_type, sts_supported);

        b_packb(rec_ptr->threex_cch_supported,
          x_ptr, x_pos,
          FSIZ(cai_chan_cfg_capa_info_is2000_rel_a_type, threex_cch_supported) );
        x_pos += FSIZ(cai_chan_cfg_capa_info_is2000_rel_a_type, threex_cch_supported);

        /* revisit with mccsup.c */
        *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type,threex_cch_supported);
      }
#endif /* FEATURE_IS2000_REL_A */


#ifdef FEATURE_IS2000_REL_B
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
      {
        if (rec_ptr->for_sch_supported)
        {
          b_packb(rec_ptr->ccsh_supported, x_ptr, x_pos,
            FSIZ(cai_chan_cfg_capa_info_is2000_rel_b_type, ccsh_supported));
          x_pos += FSIZ(cai_chan_cfg_capa_info_is2000_rel_b_type, ccsh_supported);

          *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type, ccsh_supported);
        }
      }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        b_packb(rec_ptr->for_pdch_supported, x_ptr, x_pos,
          FSIZ(cai_chan_cfg_capa_info_is2000_rel_c_type, for_pdch_supported));
        x_pos += FSIZ(cai_chan_cfg_capa_info_is2000_rel_c_type, for_pdch_supported);

        *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type, for_pdch_supported);

        if (rec_ptr->for_pdch_supported)
        {
          b_packb(rec_ptr->for_pdch_fields.ack_delay, x_ptr, x_pos,
            FSIZ(cai_for_pdch_spec_fields_type, ack_delay));
          x_pos += FSIZ(cai_for_pdch_spec_fields_type, ack_delay);

          b_packb(rec_ptr->for_pdch_fields.num_arq_chan, x_ptr, x_pos,
            FSIZ(cai_for_pdch_spec_fields_type, num_arq_chan));
          x_pos += FSIZ(cai_for_pdch_spec_fields_type, num_arq_chan);

          b_packb(rec_ptr->for_pdch_fields.for_pdch_len, x_ptr, x_pos,
            FSIZ(cai_for_pdch_spec_fields_type, for_pdch_len));
          x_pos += FSIZ(cai_for_pdch_spec_fields_type, for_pdch_len);

          b_packw(rec_ptr->for_pdch_fields.for_pdch_rc_map, x_ptr, x_pos,
            ((rec_ptr->for_pdch_fields.for_pdch_len + 1) *
            FSIZ(cai_for_pdch_spec_fields_type, for_pdch_rc_map)));
          x_pos += ((rec_ptr->for_pdch_fields.for_pdch_len + 1) *
            FSIZ(cai_for_pdch_spec_fields_type, for_pdch_rc_map));

          b_packb(rec_ptr->for_pdch_fields.ch_config_sup_map_len, x_ptr, x_pos,
            FSIZ(cai_for_pdch_spec_fields_type, ch_config_sup_map_len));
          x_pos += FSIZ(cai_for_pdch_spec_fields_type, ch_config_sup_map_len);

          b_packw(rec_ptr->for_pdch_fields.ch_config_sup_map, x_ptr, x_pos,
            ((rec_ptr->for_pdch_fields.ch_config_sup_map_len + 1) *
            FSIZ(cai_for_pdch_spec_fields_type, ch_config_sup_map)));
          x_pos += ((rec_ptr->for_pdch_fields.ch_config_sup_map_len + 1) *
            FSIZ(cai_for_pdch_spec_fields_type, ch_config_sup_map));

          *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type,
            for_pdch_fields.ch_config_sup_map);

          if (rec_ptr->for_sch_supported)
          {
            b_packb(rec_ptr->for_pdch_sch_supported, x_ptr, x_pos,
              FSIZ(cai_chan_cfg_capa_info_is2000_rel_c_type,
              for_pdch_sch_supported));
            x_pos += FSIZ(cai_chan_cfg_capa_info_is2000_rel_c_type,
              for_pdch_sch_supported);

            *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type, for_pdch_sch_supported);
          }
        }
      }
#endif /* FEATURE_IS2000_REL_C */

      rec_num_bits = x_pos - rec_start_pos;
      rec_num_bytes = (rec_num_bits / 8);
      rec_num_reserved = 8 - (rec_num_bits % 8);

      if (rec_num_reserved != 8)
      {
        rec_num_bytes += 1;
        b_packb(0, x_ptr, x_pos, rec_num_reserved);
        x_pos += rec_num_reserved;
      }

      b_packb((byte) rec_num_bytes, x_ptr, rec_len_pos,
        FSIZ(cai_rec_hdr_type, record_len));

      *xlen_ptr = rec_num_bytes * 8 + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_CHAN_CFG_CAPA_INFO_REC */

    /* ----------------------------
    ** Extended Multiplex Option Info
    ** ---------------------------- */
    case CAI_EXT_MULT_OPT_INFO_REC:
    {
      word rec_len_pos = 0;
      word rec_start_pos = 0;
      word rec_num_bits = 0;
      word rec_num_bytes = 0;
      word rec_num_reserved = 0;

      caii_ext_mult_opt_info_type *rec_ptr =
        (caii_ext_mult_opt_info_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len_pos = x_pos;
      x_pos += FSIZ(cai_rec_hdr_type, record_len);
      rec_start_pos = x_pos;

      b_packb(rec_ptr->num_mo_for_fch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_for_fch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_for_fch);

      for (i=0; i<rec_ptr->num_mo_for_fch && i<CAI_MAX_MULT_OPT_FCH_DCCH; i++)
      {
        b_packw(rec_ptr->mo_for_fch_recs[i].mo_for_fch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_for_fch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_for_fch);

        b_packb(rec_ptr->mo_for_fch_recs[i].for_rates_fch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, for_rates_fch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, for_rates_fch);
      }

      b_packb(rec_ptr->num_mo_rev_fch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_fch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_fch);

      for (i=0; i<rec_ptr->num_mo_rev_fch && i<CAI_MAX_MULT_OPT_FCH_DCCH; i++)
      {
        b_packw(rec_ptr->mo_rev_fch_recs[i].mo_rev_fch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_rev_fch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_rev_fch);

        b_packb(rec_ptr->mo_rev_fch_recs[i].rev_rates_fch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, rev_rates_fch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, rev_rates_fch);
      }

      b_packb(rec_ptr->num_mo_for_dcch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_for_dcch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_for_dcch);

      for (i=0; i<rec_ptr->num_mo_for_dcch && i<CAI_MAX_MULT_OPT_FCH_DCCH; i++)
      {
        b_packw(rec_ptr->mo_for_dcch[i], x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_for_dcch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_for_dcch);
      }

      b_packb(rec_ptr->num_mo_rev_dcch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_dcch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_dcch);

      for (i=0; i<rec_ptr->num_mo_rev_dcch && i<CAI_MAX_MULT_OPT_FCH_DCCH; i++)
      {
        b_packw(rec_ptr->mo_rev_dcch[i], x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_rev_dcch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_rev_dcch);
      }

      b_packb(rec_ptr->num_mo_for_sch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_for_sch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_for_sch);

      for (i=0; i<rec_ptr->num_mo_for_sch && i<CAI_MAX_MULT_OPT_SCH; i++)
      {
        b_packb(rec_ptr->mo_for_sch_recs[i].for_sch_id, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, for_sch_id));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, for_sch_id);

        b_packw(rec_ptr->mo_for_sch_recs[i].mo_for_sch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_for_sch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_for_sch);
      }

      b_packb(rec_ptr->num_mo_rev_sch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_sch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_sch);

      *ilen_ptr = FENDPOS(caii_ext_mult_opt_info_type, num_mo_rev_sch);

      for (i=0; i<rec_ptr->num_mo_rev_sch && i<CAI_MAX_MULT_OPT_SCH; i++)
      {
        b_packb(rec_ptr->mo_rev_sch_recs[i].rev_sch_id, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, rev_sch_id));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, rev_sch_id);

        b_packw(rec_ptr->mo_rev_sch_recs[i].mo_rev_sch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_rev_sch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_rev_sch);

        *ilen_ptr = (word) FENDPOS(caii_ext_mult_opt_info_type,
          mo_rev_sch_recs[i].mo_rev_sch);
      }

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        b_packb(rec_ptr->num_mo_for_pdch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_is2000_rel_c_type, num_mo_for_pdch));
        x_pos += FSIZ(cai_ext_mult_opt_info_is2000_rel_c_type, num_mo_for_pdch);

        *ilen_ptr = FENDPOS(caii_ext_mult_opt_info_type, num_mo_for_pdch);

        for (i=0; i<rec_ptr->num_mo_for_pdch && i<CAI_MAX_MULT_OPT_PDCH; i++)
        {
          b_packw(rec_ptr->mo_for_pdch[i], x_ptr, x_pos,
            FSIZ(cai_ext_mult_opt_info_is2000_rel_c_type, mo_for_pdch));
          x_pos += FSIZ(cai_ext_mult_opt_info_is2000_rel_c_type, mo_for_pdch);

          *ilen_ptr = (word) FENDPOS(caii_ext_mult_opt_info_type, mo_for_pdch[i]);
        }
      }
#endif /* FEATURE_IS2000_REL_C */

      rec_num_bits = x_pos-rec_start_pos;
      rec_num_bytes = (rec_num_bits / 8);
      rec_num_reserved = 8 - (rec_num_bits % 8);

      if (rec_num_reserved != 8)
      {
        rec_num_bytes += 1;
        b_packb (0,x_ptr,x_pos,rec_num_reserved);
        x_pos += rec_num_reserved;
      }

      b_packb((byte) rec_num_bytes,x_ptr,rec_len_pos,
        FSIZ(cai_rec_hdr_type, record_len));

      *xlen_ptr = rec_num_bytes*8 + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_EXT_MULT_OPT_INFO_REC */

    /* ----------------------------
    ** User Zone Update Request
    ** ---------------------------- */
    case CAI_USER_ZONE_UPDATE_REQ_REC:
    {
      caii_user_zone_update_req_type *rec_ptr =
        (caii_user_zone_update_req_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_user_zone_update_req_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packw( rec_ptr->uzid,
               x_ptr, x_pos, FSIZ( cai_user_zone_update_req_type, uzid ));
      x_pos += FSIZ( cai_user_zone_update_req_type, uzid );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_user_zone_update_req_type);

      break;
    } /* case CAI_USER_ZONE_UPDATE_REQ_REC */

    case CAI_GEO_LOC_INFO_REC:
    {
      caii_geo_loc_info_type *rec_ptr =
        (caii_geo_loc_info_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_geo_loc_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packb( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->geo_loc,
               x_ptr, x_pos, FSIZ( cai_geo_loc_info_type, geo_loc ));
      x_pos += FSIZ( cai_geo_loc_info_type, geo_loc );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_geo_loc_info_type);

      break;
    } /* case CAI_GEO_LOC_INFO_REC */


#ifdef FEATURE_IS2000_REL_A
    case CAI_HOOK_STATUS_REC:
    {
      caii_hook_status_type *rec_ptr =
        (caii_hook_status_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_hook_status_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packb( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->hook_status,
               x_ptr, x_pos, FSIZ( cai_hook_status_type, hook_status ));
      x_pos += FSIZ( cai_hook_status_type, hook_status );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_hook_status_type);

      break;
    }

    case CAI_ENC_CAP_REC:
    {
      caii_enc_cap_type *rec_ptr =
        (caii_enc_cap_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_enc_cap_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packb( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->sig_enc_sup,
               x_ptr, x_pos, FSIZ( cai_enc_cap_type, sig_enc_sup ));
      x_pos += FSIZ( cai_enc_cap_type, sig_enc_sup );

      b_packb( rec_ptr->ui_enc_sup,
               x_ptr, x_pos, FSIZ( cai_enc_cap_type, ui_enc_sup ));
      x_pos += FSIZ( cai_enc_cap_type, ui_enc_sup );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_hook_status_type);

      break;
    }

    case CAI_QOS_PARAM_REC:
    {
      caii_qos_parms_type  *rec_ptr = (caii_qos_parms_type *) i_ptr;

      rec_len = rec_ptr->qos_parms_len * 8; // bits

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packb( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      for (i=0; i< rec_ptr->qos_parms_len; i++)
      {
        b_packb( rec_ptr->qos_parms[i],
                 x_ptr, x_pos, FSIZ( cai_qos_parms_type, qos_parms ));
        x_pos += FSIZ( cai_qos_parms_type, qos_parms );
      }

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = (word) FENDPOS( caii_qos_parms_type, qos_parms[rec_ptr->qos_parms_len - 1] );

      break;
    } /* case CAI_QOS_PARAM_REC */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    case CAI_SIG_MSG_INT_CAP_REC:
    {
      caii_sig_msg_int_info_type *rec_ptr = (caii_sig_msg_int_info_type *) i_ptr;

      rec_len = sizeof(cai_sig_msg_int_info_type);

      if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
      {
        return (CAIX_INV_LEN_S); /* Rec won't fit */
      }

      /* Put in record len */
      b_packb(rec_len / 8, x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
      x_pos += FSIZ(cai_rec_hdr_type, record_len);

      /* Add other record fields */

      b_packb(rec_ptr->sig_integrity_sup, x_ptr, x_pos,
        FSIZ(cai_sig_msg_int_info_type, sig_integrity_sup));
      x_pos += FSIZ(cai_sig_msg_int_info_type, sig_integrity_sup);

      /* Set external info rec length, and internal rec length */

      *ilen_ptr = FENDPOS(caii_sig_msg_int_info_type, sig_integrity_sup);

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_SIG_MSG_INT_CAP_REC */

    case CAI_UIM_ID_REC:
    {
      caii_uim_id_info_type *rec_ptr = (caii_uim_id_info_type *) i_ptr;

      rec_len = FSIZ(cai_uim_id_info_type, uim_id_len) +
        rec_ptr->uim_id_len * 8 + FSIZ(cai_uim_id_info_type, reserved);

      if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
      {
        return (CAIX_INV_LEN_S); /* Rec won't fit */
      }

      /* Put in record len */
      b_packb(rec_len / 8, x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
      x_pos += FSIZ(cai_rec_hdr_type, record_len);

      /* Add other record fields */

      b_packb(rec_ptr->uim_id_len, x_ptr, x_pos,
        FSIZ(cai_uim_id_info_type, uim_id_len));
      x_pos += FSIZ(cai_uim_id_info_type, uim_id_len);

      *ilen_ptr = FENDPOS(caii_uim_id_info_type, uim_id_len);

      if (rec_ptr->uim_id_len > 0)
      {
        b_packd(rec_ptr->uim_id, x_ptr, x_pos, rec_ptr->uim_id_len * 8);
        x_pos += rec_ptr->uim_id_len * 8;

        *ilen_ptr = FENDPOS(caii_uim_id_info_type, uim_id);
      }

      b_packb(0, x_ptr, x_pos, FSIZ(cai_uim_id_info_type, reserved));
      x_pos += FSIZ(cai_uim_id_info_type, reserved);

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_UIM_ID_REC */
#endif /* FEATURE_IS2000_REL_C */


    case CAI_ESN_ME_REC:
    {
      caii_esn_me_info_type *rec_ptr = (caii_esn_me_info_type *) i_ptr;

      rec_len = FSIZ(cai_esn_me_info_type, esn_me_len) +
        rec_ptr->esn_me_len * 8 + FSIZ(cai_esn_me_info_type, reserved);

      if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
      {
        return (CAIX_INV_LEN_S); /* Rec won't fit */
      }

      /* Put in record len */
      b_packb(rec_len / 8, x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
      x_pos += FSIZ(cai_rec_hdr_type, record_len);

      /* Add other record fields */

      b_packb(rec_ptr->esn_me_len, x_ptr, x_pos,
        FSIZ(cai_esn_me_info_type, esn_me_len));
      x_pos += FSIZ(cai_esn_me_info_type, esn_me_len);

      *ilen_ptr = FENDPOS(caii_esn_me_info_type, esn_me_len);

      if (rec_ptr->esn_me_len > 0)
      {
        b_packd(rec_ptr->esn_me, x_ptr, x_pos, rec_ptr->esn_me_len * 8);
        x_pos += rec_ptr->esn_me_len * 8;

        *ilen_ptr = FENDPOS(caii_esn_me_info_type, esn_me);
      }

      b_packb(0, x_ptr, x_pos, FSIZ(cai_esn_me_info_type, reserved));
      x_pos += FSIZ(cai_esn_me_info_type, reserved);

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_ESN_ME_REC */



    /* -------------------------------------------
    ** MEID Information Record
    ** ------------------------------------------- */
    case CAI_MEID_REC:
      {
        caii_meid_info_type *rec_ptr = (caii_meid_info_type *) i_ptr;

        rec_len = FSIZ(cai_meid_info_type, meid_len) +
                  rec_ptr->meid_len * 8 + FSIZ(cai_meid_info_type, reserved);

        if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
        {
          return(CAIX_INV_LEN_S); /* Rec won't fit */
        }

        /* Put in record len */
        b_packb(rec_len / 8, x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
        x_pos += FSIZ(cai_rec_hdr_type, record_len);

        /* Add other record fields */

        b_packb(rec_ptr->meid_len, x_ptr, x_pos,
                FSIZ(cai_meid_info_type, meid_len));
        x_pos += FSIZ(cai_meid_info_type, meid_len);

        *ilen_ptr = FENDPOS(caii_meid_info_type, meid_len);

        if (rec_ptr->meid_len > 0)
        {
          b_packq(rec_ptr->meid, x_ptr, x_pos, rec_ptr->meid_len * 8);
          x_pos += rec_ptr->meid_len * 8;

          *ilen_ptr = FENDPOS(caii_meid_info_type, meid);
        }

        b_packb(0, x_ptr, x_pos, FSIZ(cai_meid_info_type, reserved));
        x_pos += FSIZ(cai_meid_info_type, reserved);

        *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

        break;
      } /* CAI_MEID_REC */

    /* -------------------------------------------
    ** Called Party Subaddress Informatin Record
    ** Calling Party Subaddress Informatin Record
    ** Connected Subaddress Informatin Record
    ** ------------------------------------------- */
    case CAI_REV_CALLED_SUB_REC:
    case CAI_REV_CALLING_SUB_REC:
    case CAI_REV_CONN_SUB_REC:
    {
      caii_subaddr_rec_type * rec_ptr = (caii_subaddr_rec_type *) i_ptr;
      *ilen_ptr = 0;
      /* ----------------------------------------------------
      ** RECORD_LEN = Number of CHARI fields + 1 (8 bits)
      ** ---------------------------------------------------- */
      b_packb(
        (byte) (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char + 1),
        x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
      x_pos += FSIZ( cai_rec_hdr_type, record_len);

      if ((x_pos + sizeof( cai_subaddr_fix_type ) +
              (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_subaddr_var_type, chari ))) >
                     CAI_REV_TC_MSG_BODY_SIZE)
      {
        status = CAIX_INV_LEN_S;
      }
      else
      {
        b_packb( ((caii_subaddr_rec_type *) rec_ptr)->fix.extension_bit,
                 x_ptr, x_pos,
                 FSIZ( cai_subaddr_fix_type, extension_bit ));
        x_pos += FSIZ(cai_subaddr_fix_type, extension_bit);

        b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.subadd_type,
                    x_ptr, x_pos,
                    FSIZ( cai_subaddr_fix_type, subadd_type));
        x_pos += FSIZ( cai_subaddr_fix_type, subadd_type);

        b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.odd_even_ind,
                    x_ptr, x_pos,
                    FSIZ( cai_subaddr_fix_type, odd_even_ind));
        x_pos += FSIZ( cai_subaddr_fix_type, odd_even_ind);

            /* -----------------------
            ** Pack 0 for reserved bit
            ** ----------------------- */
        b_packb( 0, x_ptr, x_pos, 3 );
        x_pos += 3;

        for (j=0;
               j < ((caii_subaddr_rec_type *) rec_ptr)->fix.num_char; j++)
        {
          b_packb( ((caii_subaddr_rec_type *) rec_ptr)->var[j], x_ptr,
                    x_pos, FSIZ( cai_subaddr_var_type, chari ));
          x_pos += FSIZ( cai_subaddr_var_type, chari ); /*lint !e662 */
        }

        /* Set external info rec length, and internal rec length */
        if (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char == 0)
        {
           *ilen_ptr += FSIZ( caii_subaddr_rec_type, fix ); /*lint !e662 */
        }
        else
        {
          *ilen_ptr += (word) FENDPOS( caii_subaddr_rec_type,
               var[((caii_subaddr_rec_type *) rec_ptr)->fix.num_char - 1]);
        }
        *xlen_ptr =  sizeof(cai_subaddr_fix_type) +  sizeof(cai_rec_hdr_type)+
          rec_ptr->fix.num_char * sizeof(cai_subaddr_var_type) ;

      }
      break;
    }

    /* -----------------------------------------------------------
     ** Calling Party Number or Connected Number Information Record
     ** ----------------------------------------------------------- */
    case CAI_REV_CALLING_REC:
    {
      caii_calling_rec_type * rec_ptr = (caii_calling_rec_type *) i_ptr;
      *ilen_ptr = 0;
      /* -----------------------------------------------------
      ** RECORD_LEN = Number of CHARI fields + 2 (16 bits) for
      ** NUMBER_TYPE, NUMBER_PLAN, PI, SI and RESERVED fields
      ** ----------------------------------------------------- */
      b_packb(
        (byte) ( rec_ptr->fix.num_char + 2),
        x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      if ((x_pos + sizeof( cai_calling_fix_type ) +
          ( rec_ptr->fix.num_char *
               FSIZ( cai_calling_var_type, chari )) + 5) >
                 CAI_REV_TC_MSG_BODY_SIZE)
      {
        status = CAIX_INV_LEN_S;
      }
      else
      {
        b_packb( rec_ptr->fix.number_type,
                  x_ptr, x_pos,
                  FSIZ( cai_calling_fix_type, number_type ));
        x_pos += FSIZ( cai_calling_fix_type, number_type );

        b_packb( rec_ptr->fix.number_plan,
                    x_ptr, x_pos, FSIZ( cai_calling_fix_type, number_plan ));
        x_pos += FSIZ(cai_calling_fix_type, number_plan);

        b_packb(  rec_ptr->fix.pi,
                    x_ptr, x_pos, FSIZ( cai_calling_fix_type, pi ));
        x_pos += FSIZ( cai_calling_fix_type, pi );

        b_packb( rec_ptr->fix.si,
                      x_ptr, x_pos, FSIZ( cai_calling_fix_type, si ));
        x_pos += FSIZ( cai_calling_fix_type, si);

        for (j=0; j < rec_ptr->fix.num_char; j++)
        {
          b_packb( rec_ptr->var[j],
                    x_ptr, x_pos, FSIZ( cai_calling_var_type, chari));
          x_pos += FSIZ( cai_calling_var_type, chari );
        }

        /* ------------------------
        ** Pack 0 for reserved bits
        ** ------------------------ */
        b_packb( 0, x_ptr, x_pos, 5 );
        x_pos += 5;

        if ( rec_ptr->fix.num_char == 0)
        {
          *ilen_ptr += FSIZ( caii_calling_rec_type, fix ); /*lint !e662 */
        }
        else
        {
          *ilen_ptr += (word) FENDPOS( caii_calling_rec_type,
            var[rec_ptr->fix.num_char - 1] );
        }
        *xlen_ptr =  sizeof(cai_calling_fix_type) +  sizeof(cai_rec_hdr_type)+
          rec_ptr->fix.num_char * sizeof(cai_calling_var_type) + 5 ;
      }
      break;
    }

#ifdef FEATURE_IS2000_REL_A
    case CAI_BAND_SUBCLASS_INFO_REC:
    {
      caii_band_subclass_type *rec_ptr = (caii_band_subclass_type *) i_ptr;
      /* Convenient helper pointer of correct type to avoid casting */
      uint8 num_bytes = 1;
      /* Number of bytes needed for this IR */

      uint32 band_subclass_mask = 0;
      /* Band subclasses can go all the way up to 32 */

      /* Construct the mask to reflect how many of the band subclasses
         are supported. This is a bit mask with  LSB 0 representing BSC 0 */
      for (i=0; i<CAI_MAX_BAND_SUBCLASSES; i++)
      {
        if (rec_ptr->subband[i])
        {
          band_subclass_mask |= 1 << i;
        }
      }

      /* Now use the band subclass mask to figure out how many bytes we need
         for representing the band subclasses */
      if (band_subclass_mask > ((1<<24)-1))
      {
        /* Value needs more than 24 bits */
        num_bytes = 4;
      }
      else if (band_subclass_mask > ((1<<16)-1))
      {
        /* Value needs more than 16 bits */
        num_bytes = 3;
      }
      else if (band_subclass_mask > ((1<<8)-1))
      {
        /* Value needs more than 8 bits */
        num_bytes = 2;
      }

      /* Convert rec length to bits from bytes */
      rec_len = num_bytes << 3;

      if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
      {
        return(CAIX_INV_LEN_S); /* Rec won't fit */
      }

      /* Put in record len */
      b_packw(rec_len / 8,
              x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
      x_pos += FSIZ(cai_rec_hdr_type, record_len);

      /* Add other record fields */
      for (i=0 ; i<num_bytes*8 ; i++)
      {
        /* Now pack the band subclass values.  Note number of bits in the
           IR could be more than the array size itself as this accounts
           for reserved bits too, so do a bounds check here */
        if (i < CAI_MAX_BAND_SUBCLASSES)
        {
          b_packb(rec_ptr->subband[i],
                  x_ptr, x_pos, FSIZ( cai_band_subclass_type, subband));
        }
        else
        {
          /* Past the array means we are certainly in reserved bits area,
             so pack 0's here */
          b_packb(0, x_ptr, x_pos, FSIZ( cai_band_subclass_type, subband));
        }
        x_pos += FSIZ(cai_band_subclass_type, subband);
      }

      /* Set external info rec length, and internal rec length */
      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_band_subclass_type);
      break;
    }
#endif /* FEATURE_IS2000_REL_A */


    /* -------------------------------------------
    ** MEID ME Information Record
    ** ------------------------------------------- */
    case CAI_MEID_ME_REC:
      {
        caii_meid_me_info_type *rec_ptr = (caii_meid_me_info_type *) i_ptr;

        rec_len = FSIZ(cai_meid_me_info_type, meid_me_len) +
                  rec_ptr->meid_me_len * 8 + FSIZ(cai_meid_me_info_type, reserved);

        if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
        {
          return(CAIX_INV_LEN_S); /* Rec won't fit */
        }

        /* Put in record len */
        b_packb(rec_len / 8, x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
        x_pos += FSIZ(cai_rec_hdr_type, record_len);

        /* Add other record fields */

        b_packb(rec_ptr->meid_me_len, x_ptr, x_pos,
                FSIZ(cai_meid_me_info_type, meid_me_len));
        x_pos += FSIZ(cai_meid_me_info_type, meid_me_len);

        *ilen_ptr = FENDPOS(caii_meid_me_info_type, meid_me_len);

        if (rec_ptr->meid_me_len > 0)
        {
          b_packq(rec_ptr->meid_me, x_ptr, x_pos, rec_ptr->meid_me_len * 8);
          x_pos += rec_ptr->meid_me_len * 8;

          *ilen_ptr = FENDPOS(caii_meid_me_info_type, meid_me);
        }

        b_packb(0, x_ptr, x_pos, FSIZ(cai_meid_me_info_type, reserved));
        x_pos += FSIZ(cai_meid_me_info_type, reserved);

        *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

        break;
      } /* CAI_MEID_ME_REC */


    default:
      return ( CAIX_INV_MSG_S );
  } /* switch */

  return status;

} /* xlate_int_info_rec() */

/*===========================================================================

FUNCTION CAI_PACK_IMSI

DESCRIPTION
  This function packs the IMSI field from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Status.

SIDE EFFECTS
  None

===========================================================================*/
word cai_pack_imsi
(
    caii_imsi_addr_type  * imsi_ptr,   /* pointer to the imsi structure */
    byte                 * buf_ptr,    /* the translated buffer */
    word                 * buffer_pos  /* the buffer bit position */
)
{
    word   status = CAIX_DONE_S;   /* status */

    b_packb( imsi_ptr->imsi_class,
             buf_ptr, *buffer_pos, FSIZ( cai_ext_msid2_type, imsi_class ));
    *buffer_pos += FSIZ( cai_ext_msid2_type, imsi_class );

    if (imsi_ptr->imsi_class == 0)
    {
      b_packb(
        imsi_ptr->class_type.zero.imsi_class_0_type,
        buf_ptr, *buffer_pos,
        FSIZ( cai_imsi_class0_type, imsi_class_0_type ));
      *buffer_pos += FSIZ( cai_imsi_class0_type, imsi_class_0_type );

      switch (imsi_ptr->class_type.zero.imsi_class_0_type)
      {
        case 0:
          /* -------------------------------------------
          ** Pack IMSI class 0 type 0 specific subfields
          ** ------------------------------------------- */
          b_packb( 0, buf_ptr, *buffer_pos,
                  FSIZ( cai_imsi_class0_type0_type, reserved ));
          *buffer_pos += FSIZ( cai_imsi_class0_type0_type, reserved );

          b_packq(
            imsi_ptr->class_type.zero.type.zero.imsi_s,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type0_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class0_type0_type, imsi_s );
          break;

        case 1:
          /* -------------------------------------------
          ** Pack IMSI class 0 type 1 specific subfields
          ** ------------------------------------------- */
          b_packb( 0, buf_ptr, *buffer_pos,
                  FSIZ( cai_imsi_class0_type1_type, reserved ));
          *buffer_pos += FSIZ( cai_imsi_class0_type1_type, reserved );

          b_packb(
            imsi_ptr->class_type.zero.type.one.imsi_11_12,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class0_type1_type, imsi_11_12 ));
          *buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_11_12 );

          b_packq(
            imsi_ptr->class_type.zero.type.one.imsi_s,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type1_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_s );
          break;

        case 2:
          /* -------------------------------------------
          ** Pack IMSI class 0 type 2 specific subfields
          ** ------------------------------------------- */
          b_packb( 0, buf_ptr, *buffer_pos,
                  FSIZ( cai_imsi_class0_type2_type, reserved ));
          *buffer_pos += FSIZ( cai_imsi_class0_type2_type, reserved );

          b_packw(
            imsi_ptr->class_type.zero.type.two.mcc,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type2_type, mcc ));
          *buffer_pos += FSIZ( cai_imsi_class0_type2_type, mcc );

          b_packq(
            imsi_ptr->class_type.zero.type.two.imsi_s,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type2_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class0_type2_type, imsi_s );
          break;

        case 3:
          /* -------------------------------------------
          ** Pack IMSI class 0 type 3 specific subfields
          ** ------------------------------------------- */
          b_packb( 0, buf_ptr, *buffer_pos,
                  FSIZ( cai_imsi_class0_type3_type, reserved ));
          *buffer_pos += FSIZ( cai_imsi_class0_type3_type, reserved );

          b_packw(
            imsi_ptr->class_type.zero.type.three.mcc,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type3_type, mcc ));
          *buffer_pos += FSIZ( cai_imsi_class0_type3_type, mcc );

          b_packb(
            imsi_ptr->class_type.zero.type.three.imsi_11_12,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class0_type3_type, imsi_11_12 ));
          *buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_11_12 );

          b_packq(
            imsi_ptr->class_type.zero.type.three.imsi_s,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type3_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_s );
          break;

        default:
          return (CAIX_INV_MSG_S);
      }
    } /* Class 0 IMSI */
    else /* Class 1 IMSI */
    {
      b_packb(
        imsi_ptr->class_type.one.imsi_class_1_type,
        buf_ptr, *buffer_pos,
        FSIZ( cai_imsi_class1_type, imsi_class_1_type ));
      *buffer_pos += FSIZ( cai_imsi_class1_type, imsi_class_1_type );

      switch (
        imsi_ptr->class_type.one.imsi_class_1_type)
      {
        case 0:
          /* -------------------------------------------
          ** Pack IMSI class 1 type 0 specific subfields
          ** ------------------------------------------- */
          b_packb( 0, buf_ptr, *buffer_pos,
                  FSIZ( cai_imsi_class1_type0_type, reserved ));
          *buffer_pos += FSIZ( cai_imsi_class1_type0_type, reserved );

          b_packb(
            imsi_ptr->class_type.one.type.zero.imsi_addr_num,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class1_type0_type, imsi_addr_num ));
          *buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_addr_num );

          b_packb(
            imsi_ptr->class_type.one.type.zero.imsi_11_12,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class1_type0_type, imsi_11_12 ));
          *buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_11_12 );

          b_packq(
            imsi_ptr->class_type.one.type.zero.imsi_s,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class1_type0_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_s );
          break;

        case 1:
          /* -------------------------------------------
          ** Pack IMSI class 1 type 1 specific subfields
          ** ------------------------------------------- */
          b_packb(
            imsi_ptr->class_type.one.type.one.imsi_addr_num,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class1_type1_type, imsi_addr_num ));
          *buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_addr_num );

          b_packw(
            imsi_ptr->class_type.one.type.one.mcc,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class1_type1_type, mcc ));
          *buffer_pos += FSIZ( cai_imsi_class1_type1_type, mcc );

          b_packb(
            imsi_ptr->class_type.one.type.one.imsi_11_12,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class1_type1_type, imsi_11_12 ));
          *buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_11_12 );

          b_packq(
            imsi_ptr->class_type.one.type.one.imsi_s,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class1_type1_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_s );
          break;

        default:
          return (CAIX_INV_MSG_S);
      }
    } /* Class 1 IMSI */

    return status;

}  /* CAI_PACK_IMSI */

/*===========================================================================

FUNCTION XLATE_INT_AC_HDR

DESCRIPTION
  This function translates an Access Channel Message header (MSG_TYPE
  field through the MSID field) from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_hdr
(
  word *len_ptr,
    /* Pointer to length of Access Channel header in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* Status returned to calling procedure */
  word buffer_pos = 0;
    /* Position to pack bits in message */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ----------------------------------------------------------------
  ** Translate Access Channel header from internal to external format
  ** ---------------------------------------------------------------- */

  #ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    b_packb( 2, buf_ptr, buffer_pos,FSIZ(cai_ac_msg_type_type,prot_disc));
  }
  else
  #endif /* FEATURE_IS2000_REL_A */
  if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
  {
    b_packb( 1, buf_ptr, buffer_pos,FSIZ(cai_ac_msg_type_type,prot_disc));
  }
  else
  {
    b_packb( 0, buf_ptr, buffer_pos,FSIZ(cai_ac_msg_type_type,prot_disc));
  }
  buffer_pos += FSIZ(cai_ac_msg_type_type,prot_disc);
  b_packb( int_ptr->gen_ac.msg_type, buf_ptr, buffer_pos,
           (FSIZ( cai_ac_msg_type_type, msg_type)));
  buffer_pos += (FSIZ( cai_ac_msg_type_type, msg_type));

  if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
  {
    ac_l2_length_pos = buffer_pos;
    ac_l2_start_pos = buffer_pos;
    buffer_pos += AC_L2_LENGTH_NUM_BITS;
  }

  b_packb( int_ptr->gen_ac.hdr.ack_seq, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, ack_seq ));
  buffer_pos += FSIZ( cai_ac_hdr_type, ack_seq );

  b_packb( int_ptr->gen_ac.hdr.msg_seq, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, msg_seq ));
  buffer_pos += FSIZ( cai_ac_hdr_type, msg_seq );

  b_packb( int_ptr->gen_ac.hdr.ack_req, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, ack_req ));
  buffer_pos += FSIZ( cai_ac_hdr_type, ack_req );

  b_packb( int_ptr->gen_ac.hdr.valid_ack, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, valid_ack ));
  buffer_pos += FSIZ( cai_ac_hdr_type, valid_ack );

  b_packb( int_ptr->gen_ac.hdr.ack_type, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, ack_type ));
  buffer_pos += FSIZ( cai_ac_hdr_type, ack_type );

  b_packb( int_ptr->gen_ac.hdr.msid_type, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, msid_type ));
  buffer_pos += FSIZ( cai_ac_hdr_type, msid_type );

  b_packb( int_ptr->gen_ac.hdr.msid_len, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, msid_len ));

  buffer_pos += FSIZ( cai_ac_hdr_type, msid_len );

  /* -------------------------------------
  ** Pack mobile station identifier fields
  ** ------------------------------------- */
  switch (int_ptr->gen_ac.hdr.msid_type)
  {
    case CAI_MIN_AND_ESN_ADDR_TYPE:                     /* 0 */
      /* ---------------------------
      ** IMSI_S and ESN address type
      ** --------------------------- */
      b_packd( int_ptr->gen_ac.hdr.msid.type0.min1, buf_ptr, buffer_pos,
               FSIZ( cai_msid0_type, min1 ));
      buffer_pos += FSIZ( cai_msid0_type, min1 );

      b_packw( int_ptr->gen_ac.hdr.msid.type0.min2, buf_ptr, buffer_pos,
               FSIZ( cai_msid0_type, min2 ));
      buffer_pos += FSIZ( cai_msid0_type, min2 );

      b_packd( int_ptr->gen_ac.hdr.msid.type0.esn, buf_ptr, buffer_pos,
             FSIZ( cai_msid0_type, esn ));
      buffer_pos += FSIZ( cai_msid0_type, esn );

      b_packb( 0, buf_ptr, buffer_pos, FSIZ( cai_msid0_type, reserved ));
      buffer_pos += FSIZ( cai_msid0_type, reserved );
      break;

    case CAI_ESN_ADDR_TYPE:                             /* 1 */
      /* ----------------
      ** ESN address type
      ** ---------------- */
      b_packd( int_ptr->gen_ac.hdr.msid.type1.esn, buf_ptr, buffer_pos,
               FSIZ( cai_msid1_type, esn ));
      buffer_pos += FSIZ( cai_msid1_type, esn );
      break;

    case CAI_IMSI_ADDR_TYPE:                            /* 2 */
      /* -----------------
      ** IMSI address type
      ** ----------------- */
      b_packb( int_ptr->gen_ac.hdr.msid.type2.imsi.imsi_class,
               buf_ptr, buffer_pos, FSIZ( cai_msid2_type, imsi_class ));
      buffer_pos += FSIZ( cai_msid2_type, imsi_class );

      if (int_ptr->gen_ac.hdr.msid.type2.imsi.imsi_class == 0)
      {
        b_packb(
          int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.imsi_class_0_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class0_type, imsi_class_0_type ));
        buffer_pos += FSIZ( cai_imsi_class0_type, imsi_class_0_type );

        switch ( int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.imsi_class_0_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, reserved );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.zero.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type1_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, reserved );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.one.imsi_s,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_s );
            break;

          case 2:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 2 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type2_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, reserved );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.two.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, mcc );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.two.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, imsi_s );
            break;

          case 3:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 3 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class0_type3_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, reserved );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.three.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, mcc );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.three.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type3_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.three.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);

        }
      } /* Class 0 IMSI */
      else /* Class 1 IMSI */
      {
        b_packb(
          int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.imsi_class_1_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class1_type, imsi_class_1_type ));
        buffer_pos += FSIZ( cai_imsi_class1_type, imsi_class_1_type );

        switch ( int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.imsi_class_1_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class1_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, reserved );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.zero.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_addr_num );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.zero.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.zero.imsi_s,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.one.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_addr_num );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.one.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, mcc );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.one.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);
        }
      } /* Class 1 IMSI */
      break;

    case CAI_IMSI_AND_ESN_ADDR_TYPE:                    /* 3 */
      /* -------------------------
      ** IMSI and ESN address type
      ** ------------------------- */
      b_packd( int_ptr->gen_ac.hdr.msid.type3.esn, buf_ptr, buffer_pos,
               FSIZ( cai_msid3_type, esn ));
      buffer_pos += FSIZ( cai_msid3_type, esn );

      b_packb( int_ptr->gen_ac.hdr.msid.type3.imsi.imsi_class,
               buf_ptr, buffer_pos, FSIZ( cai_msid3_type, imsi_class ));
      buffer_pos += FSIZ( cai_msid3_type, imsi_class );

      if (int_ptr->gen_ac.hdr.msid.type3.imsi.imsi_class == 0)
      {
        b_packb(
          int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.imsi_class_0_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class0_type, imsi_class_0_type ));
        buffer_pos += FSIZ( cai_imsi_class0_type, imsi_class_0_type );

        switch ( int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.imsi_class_0_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class0_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, reserved );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.zero.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class0_type1_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, reserved );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.one.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_s );
            break;

          case 2:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 2 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class0_type2_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, reserved );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.two.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, mcc );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.two.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, imsi_s );
            break;

          case 3:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 3 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class0_type3_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, reserved );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.three.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, mcc );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.three.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type3_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.three.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);
        }
      } /* Class 0 IMSI */
      else /* Class 1 IMSI */
      {
        b_packb(
          int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.imsi_class_1_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class1_type, imsi_class_1_type ));
        buffer_pos += FSIZ( cai_imsi_class1_type, imsi_class_1_type );

        switch ( int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.imsi_class_1_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class1_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, reserved );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.zero.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_addr_num );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.zero.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.zero.imsi_s,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.one.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_addr_num );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.one.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, mcc );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.one.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);
        }
      } /* Class 1 IMSI */
      break;

    case CAI_TMSI_AC_MSID_ADDR_TYPE:                    /* 5 */
      /* -------------------------
      ** TMSI address type
      ** ------------------------- */
      /* If MSID length is greater than the maximum size */
      /* of TMSI code, then TMSI zone needs to be sent.  */

      if ( int_ptr->gen_ac.hdr.msid_len > MAX_TMSI_CODE_LEN )
      {
        /* Bit-pack TMSI zone */
        /* Use only the Assigning Zone Length most significant */
        /* octets of the Assigning TMSI Zone.                  */
        b_packq( int_ptr->gen_ac.hdr.msid.type5.tmsi_zone,
          buf_ptr, buffer_pos, (cdma.assigning_tmsi.zone_len << 3) );
        buffer_pos += (cdma.assigning_tmsi.zone_len << 3);

        /* Bit-pack TMSI code */
        b_packd( int_ptr->gen_ac.hdr.msid.type5.tmsi_code,
          buf_ptr, buffer_pos, FSIZ( cai_tmsi_type, tmsi_code ) );
        buffer_pos += FSIZ( cai_tmsi_type, tmsi_code );
      }
      /* Send only the TMSI code.  Determine the */
      /* size of TMSI code to be sent.           */
      else
      {
        /* Bit-pack TMSI code */
        /* Determine size of TMSI code to send by  */
        /* checking if the most significant octets */
        /* of the TMSI code are equal to zero.     */
        if (( int_ptr->gen_ac.hdr.msid.type5.tmsi_code >> 16 ) == 0 )
        {
          /* 16-bit TMSI code */
          b_packw( (word) int_ptr->gen_ac.hdr.msid.type5.tmsi_code,
            buf_ptr, buffer_pos, 16 );
          buffer_pos += 16;
        }
        else if (( int_ptr->gen_ac.hdr.msid.type5.tmsi_code >> 24 ) == 0 )
        {
          /* 24-bit TMSI code */
          b_packd( int_ptr->gen_ac.hdr.msid.type5.tmsi_code,
            buf_ptr, buffer_pos, 24 );
          buffer_pos += 24;
        }
        else
        {
          /* 32-bit TMSI code */
          b_packd( int_ptr->gen_ac.hdr.msid.type5.tmsi_code,
            buf_ptr, buffer_pos, FSIZ( cai_tmsi_type, tmsi_code ) );
          buffer_pos += FSIZ( cai_tmsi_type, tmsi_code );
        }
      }

      break;

    default:
      return (CAIX_INV_MSG_S);
  }

  *len_ptr = buffer_pos;

  status = CAIX_DONE_S;

  return (status );

} /* xlate_int_ac_hdr */

#ifdef FEATURE_GPSONE
/*===========================================================================

FUNCTION CAIX_MSID_INT_TO_EXT

DESCRIPTION
  This function translates an MSID from internal to external format. The
  external format is as follows:

  Field         Length(bits)
  RESERVED      1
  EXT_MSID_TYPE 3

        In Rel D, a new field ext_msid_type(3 bits) is added here to support MEID.
        The Rel D ext_msid_type will be added in the code where it is needed
        when a Rel D MS is talking to a Rel D BS
  MSID_LEN      4
  MSID          8xMSID_LEN

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word caix_msid_int_to_ext
(
  word *len_ptr,
    /* Pointer to length of MSID header and fields in bits */
  byte *buf_ptr,
    /* Pointer to where translated data should be placed */
  caii_ac_hdr_type *int_ptr
    /* Pointer to internal data to be xlated */
)
{
  word status;
    /* Status returned to calling procedure */
  word buffer_pos = 0;
    /* Position to pack bits in message */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ----------------------------------------------------------------
  ** Translate MSID header from internal to external format
  ** ---------------------------------------------------------------- */
  b_packb( 0, buf_ptr, buffer_pos,
           FSIZ( cai_msid_hdr_type, reserved ));
  buffer_pos += FSIZ( cai_msid_hdr_type, reserved );

  b_packb( int_ptr->msid_type, buf_ptr, buffer_pos,
           FSIZ( cai_msid_hdr_type, msid_type ));
  buffer_pos += FSIZ( cai_msid_hdr_type, msid_type );

  b_packb( int_ptr->msid_len, buf_ptr, buffer_pos,
           FSIZ( cai_msid_hdr_type, msid_len ));
  buffer_pos += FSIZ( cai_msid_hdr_type, msid_len );

  /* -------------------------------------
  ** Pack mobile station identifier fields
  ** ------------------------------------- */
  switch (int_ptr->msid_type)
  {
    case CAI_MIN_AND_ESN_ADDR_TYPE:
      /* ---------------------------
      ** IMSI_S and ESN address type
      ** --------------------------- */
      b_packd( int_ptr->msid.type0.min1, buf_ptr, buffer_pos,
               FSIZ( cai_msid0_type, min1 ));
      buffer_pos += FSIZ( cai_msid0_type, min1 );

      b_packw( int_ptr->msid.type0.min2, buf_ptr, buffer_pos,
               FSIZ( cai_msid0_type, min2 ));
      buffer_pos += FSIZ( cai_msid0_type, min2 );

      b_packd( int_ptr->msid.type0.esn, buf_ptr, buffer_pos,
               FSIZ( cai_msid0_type, esn ));
      buffer_pos += FSIZ( cai_msid0_type, esn );

      b_packb( 0, buf_ptr, buffer_pos, FSIZ( cai_msid0_type, reserved ));
      buffer_pos += FSIZ( cai_msid0_type, reserved );
      break;

    case CAI_ESN_ADDR_TYPE:
      /* ----------------
      ** ESN address type
      ** ---------------- */
      b_packd( int_ptr->msid.type1.esn, buf_ptr, buffer_pos,
               FSIZ( cai_msid1_type, esn ));
      buffer_pos += FSIZ( cai_msid1_type, esn );
      break;

    case CAI_IMSI_ADDR_TYPE:
      /* -----------------
      ** IMSI address type
      ** ----------------- */
      b_packb( int_ptr->msid.type2.imsi.imsi_class,
               buf_ptr, buffer_pos, FSIZ( cai_msid2_type, imsi_class ));
      buffer_pos += FSIZ( cai_msid2_type, imsi_class );

      if (int_ptr->msid.type2.imsi.imsi_class == 0)
      {
        b_packb(
          int_ptr->msid.type2.imsi.class_type.zero.imsi_class_0_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class0_type, imsi_class_0_type ));
        buffer_pos += FSIZ( cai_imsi_class0_type, imsi_class_0_type );

        switch (
          int_ptr->msid.type2.imsi.class_type.zero.imsi_class_0_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, reserved );

            b_packq(
              int_ptr->msid.type2.imsi.class_type.zero.type.zero.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type1_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, reserved );

            b_packb(
              int_ptr->msid.type2.imsi.class_type.zero.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->msid.type2.imsi.class_type.zero.type.one.imsi_s,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_s );
            break;

          case 2:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 2 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type2_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, reserved );

            b_packw(
              int_ptr->msid.type2.imsi.class_type.zero.type.two.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, mcc );

            b_packq(
              int_ptr->msid.type2.imsi.class_type.zero.type.two.imsi_s,
              buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type2_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, imsi_s );
            break;

          case 3:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 3 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type3_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, reserved );

            b_packw(
              int_ptr->msid.type2.imsi.class_type.zero.type.three.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, mcc );

            b_packb(
              int_ptr->msid.type2.imsi.class_type.zero.type.three.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type3_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_11_12 );

            b_packq(
              int_ptr->msid.type2.imsi.class_type.zero.type.three.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);
        }
      } /* Class 0 IMSI */
      else /* Class 1 IMSI */
      {
        b_packb(
          int_ptr->msid.type2.imsi.class_type.one.imsi_class_1_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class1_type, imsi_class_1_type ));
        buffer_pos += FSIZ( cai_imsi_class1_type, imsi_class_1_type );

        switch (
          int_ptr->msid.type2.imsi.class_type.one.imsi_class_1_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class1_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, reserved );

            b_packb(
              int_ptr->msid.type2.imsi.class_type.one.type.zero.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_addr_num );

            b_packb(
              int_ptr->msid.type2.imsi.class_type.one.type.zero.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_11_12 );

            b_packq(
              int_ptr->msid.type2.imsi.class_type.one.type.zero.imsi_s,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb(
              int_ptr->msid.type2.imsi.class_type.one.type.one.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_addr_num );

            b_packw(
              int_ptr->msid.type2.imsi.class_type.one.type.one.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, mcc );

            b_packb(
              int_ptr->msid.type2.imsi.class_type.one.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->msid.type2.imsi.class_type.one.type.one.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);
        }
      } /* Class 1 IMSI */
      break;

    case CAI_IMSI_AND_ESN_ADDR_TYPE:
      /* -------------------------
      ** IMSI and ESN address type
      ** ------------------------- */
      b_packd( int_ptr->msid.type3.esn, buf_ptr, buffer_pos,
               FSIZ( cai_msid3_type, esn ));
      buffer_pos += FSIZ( cai_msid3_type, esn );

      b_packb( int_ptr->msid.type3.imsi.imsi_class,
               buf_ptr, buffer_pos, FSIZ( cai_msid3_type, imsi_class ));
      buffer_pos += FSIZ( cai_msid3_type, imsi_class );

      if (int_ptr->msid.type3.imsi.imsi_class == 0)
      {
        b_packb(
          int_ptr->msid.type3.imsi.class_type.zero.imsi_class_0_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class0_type, imsi_class_0_type ));
        buffer_pos += FSIZ( cai_imsi_class0_type, imsi_class_0_type );

        switch (
          int_ptr->msid.type3.imsi.class_type.zero.imsi_class_0_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, reserved );

            b_packq(
              int_ptr->msid.type3.imsi.class_type.zero.type.zero.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type1_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, reserved );

            b_packb(
              int_ptr->msid.type3.imsi.class_type.zero.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->msid.type3.imsi.class_type.zero.type.one.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_s );
            break;

          case 2:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 2 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type2_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, reserved );

            b_packw(
              int_ptr->msid.type3.imsi.class_type.zero.type.two.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, mcc );

            b_packq(
              int_ptr->msid.type3.imsi.class_type.zero.type.two.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, imsi_s );
            break;

          case 3:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 3 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type3_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, reserved );

            b_packw(
              int_ptr->msid.type3.imsi.class_type.zero.type.three.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, mcc );

            b_packb(
              int_ptr->msid.type3.imsi.class_type.zero.type.three.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type3_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_11_12 );

            b_packq(
              int_ptr->msid.type3.imsi.class_type.zero.type.three.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);
        }
      } /* Class 0 IMSI */
      else /* Class 1 IMSI */
      {
        b_packb(
          int_ptr->msid.type3.imsi.class_type.one.imsi_class_1_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class1_type, imsi_class_1_type ));
        buffer_pos += FSIZ( cai_imsi_class1_type, imsi_class_1_type );

        switch (
          int_ptr->msid.type3.imsi.class_type.one.imsi_class_1_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class1_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, reserved );

            b_packb(
              int_ptr->msid.type3.imsi.class_type.one.type.zero.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_addr_num );

            b_packb(
              int_ptr->msid.type3.imsi.class_type.one.type.zero.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_11_12 );

            b_packq(
              int_ptr->msid.type3.imsi.class_type.one.type.zero.imsi_s,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb(
              int_ptr->msid.type3.imsi.class_type.one.type.one.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_addr_num );

            b_packw(
              int_ptr->msid.type3.imsi.class_type.one.type.one.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, mcc );

            b_packb(
              int_ptr->msid.type3.imsi.class_type.one.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->msid.type3.imsi.class_type.one.type.one.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);
        }
      } /* Class 1 IMSI */
      break;

    case CAI_TMSI_AC_MSID_ADDR_TYPE:
      /* -------------------------
      ** TMSI address type
      ** ------------------------- */
      /* If MSID length is greater than the maximum size */
      /* of TMSI code, then TMSI zone needs to be sent.  */
      if ( int_ptr->msid_len > MAX_TMSI_CODE_LEN )
      {
        /* Bit-pack TMSI zone */
        /* Use only the Assigning Zone Length most significant */
        /* octets of the Assigning TMSI Zone.                  */
        b_packq(
          int_ptr->msid.type5.tmsi_zone,
          buf_ptr, buffer_pos, (cdma.assigning_tmsi.zone_len << 3));
        buffer_pos += (cdma.assigning_tmsi.zone_len << 3);

        /* Bit-pack TMSI code */
        b_packd(
          int_ptr->msid.type5.tmsi_code,
          buf_ptr, buffer_pos, FSIZ( cai_tmsi_type, tmsi_code ));
        buffer_pos += FSIZ( cai_tmsi_type, tmsi_code );
      }
      /* Send only the TMSI code.  Determine the */
      /* size of TMSI code to be sent.           */
      else
      {
        /* Bit-pack TMSI code */
        /* Determine size of TMSI code to send by  */
        /* checking if the most significant octets */
        /* of the TMSI code are equal to zero.     */
        if (( int_ptr->msid.type5.tmsi_code >> 16 ) == 0 )
        {
          /* 16-bit TMSI code */
          b_packw(
            (word) int_ptr->msid.type5.tmsi_code,
            buf_ptr, buffer_pos, 16);
          buffer_pos += 16;
        }
        else if (( int_ptr->msid.type5.tmsi_code >> 24 ) == 0 )
        {
          /* 24-bit TMSI code */
          b_packd(
            int_ptr->msid.type5.tmsi_code,
            buf_ptr, buffer_pos, 24);
          buffer_pos += 24;
        }
        else
        {
          /* 32-bit TMSI code */
          b_packd(
            int_ptr->msid.type5.tmsi_code,
            buf_ptr, buffer_pos, FSIZ( cai_tmsi_type, tmsi_code ));
          buffer_pos += FSIZ( cai_tmsi_type, tmsi_code );
        }
      }
      break;

    default:
      return (CAIX_INV_MSG_S);
  }

  *len_ptr = buffer_pos;

  status = CAIX_DONE_S;

  return (status );

} /* caix_msid_int_to_ext */
#endif /* FEATURE_GPSONE */

/*===========================================================================

FUNCTION XLATE_INT_AC_AUTH_MSG_INT

DESCRIPTION
  This function translates Authentication fields and message integrity fields
   from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_ac_auth_msg_int
(
  word *len_ptr,
    /* Pointer to length of Access Channel header in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  byte msg_type,
    /* Message type */
  caii_ac_hdr_type *hdr_ptr,
    /* Pointer to the internal format of layer2 fields */
  caii_ac_auth_msg_int_type *int_ptr
    /* Pointer to the internal format of authentication and message integrity
       fields */
)
{
  byte auth_mode_len;

  /* ----------------------------
  ** Pack the rest of the message
  ** ---------------------------- */

  #define FTYPE cai_ac_auth_msg_int_type

  auth_mode_len = FSIZ(FTYPE, auth_mode);

  #ifdef FEATURE_IS2000_REL_C
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
    auth_mode_len -= FSIZ(FTYPE, maci_incl);
    b_packb(int_ptr->maci_incl, buf_ptr, *len_ptr,
      FSIZ(FTYPE, maci_incl));
    *len_ptr += FSIZ(FTYPE, maci_incl);
  }
  #endif /* FEATURE_IS2000_REL_C */

  b_packb(int_ptr->auth_mode, buf_ptr, *len_ptr, auth_mode_len);
  *len_ptr += auth_mode_len;

  if (int_ptr->auth_mode == CAI_AUTH)
  {
    b_packd(int_ptr->authr, buf_ptr, *len_ptr, FSIZ(FTYPE, authr));
    *len_ptr += FSIZ(FTYPE, authr);
  }

  if ( (int_ptr->auth_mode == CAI_AUTH)
       #ifdef FEATURE_IS2000_REL_C
       || ( (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) &&
            (int_ptr->maci_incl) )
       #endif /* FEATURE_IS2000_REL_C */
     )
  {
    b_packb(int_ptr->randc, buf_ptr, *len_ptr, FSIZ(FTYPE, randc));
    *len_ptr += FSIZ(FTYPE, randc);
  }

  if (int_ptr->auth_mode == CAI_AUTH)
  {
    b_packb(int_ptr->count, buf_ptr, *len_ptr, FSIZ(FTYPE, count));
    *len_ptr += FSIZ(FTYPE, count);
  }

  #ifdef FEATURE_IS2000_REL_C
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
    if (int_ptr->maci_incl)
    {
      b_packb(int_ptr->sdu_key_id, buf_ptr, *len_ptr, FSIZ(FTYPE, sdu_key_id));
      *len_ptr += FSIZ(FTYPE, sdu_key_id);

      b_packb(int_ptr->sdu_integrity_algo, buf_ptr, *len_ptr,
        FSIZ(FTYPE, sdu_integrity_algo));
      *len_ptr += FSIZ(FTYPE, sdu_integrity_algo);

      b_packb(int_ptr->sdu_sseq_or_sseqh, buf_ptr, *len_ptr,
        FSIZ(FTYPE, sdu_sseq_or_sseqh));
      *len_ptr += FSIZ(FTYPE, sdu_sseq_or_sseqh);

      if (!int_ptr->sdu_sseq_or_sseqh)
      {
        b_packb(int_ptr->sdu_sseq, buf_ptr, *len_ptr, FSIZ(FTYPE, sdu_sseq));
        *len_ptr += FSIZ(FTYPE, sdu_sseq);
      }
      else
      {
        b_packd(int_ptr->sdu_sseq_h, buf_ptr, *len_ptr, FSIZ(FTYPE, sdu_sseq_h));
        *len_ptr += FSIZ(FTYPE, sdu_sseq_h);
      }
    }
  }
  #endif /* FEATURE_IS2000_REL_C */

  #undef FTYPE

} /* xlate_int_ac_auth_msg_int */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_INT_MACI

DESCRIPTION
  This function translates MACI field from internal to external format.

DEPENDENCIES
  None
RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_maci
(
  /* Pointer to length of message in bits */
  word *len_ptr,

  /* Pointer to where translated message should be placed */
  byte *buf_ptr,

  /* Length of CRC */
  word crc_len,

  /* whether ack is required or not */
  boolean ack_req,

  /* Physical Channel this message is to be transmitted on */
  word phy_chan,

  /* Key id of the integrity key to be used to compute the MAC-I value
     for this PDU. */
  byte sdu_key_id,

  byte msg_type,

  /* Identity of the message integrity algorithm that is used for the
     SDU carried by this PDU. */
  byte sdu_integrity_algo,

  /* This holds calculated MACI */
  dword * maci
  )
{
  /* padding bits to align it at the octet boundary */
  byte pdu_padding_bits;

  /* Make sure the prev is greater than 9 */
  if (caix_p_rev_in_use <= CAIX_P_REV_IS2000_REL_C)
  {
    return;
  }

  /* Include the padding bits to align it at the octet boundary */
  pdu_padding_bits =  (*len_ptr + crc_len) % 8;

  if (pdu_padding_bits != 0)
  {
    pdu_padding_bits = 8 - pdu_padding_bits;
    b_packb(0, buf_ptr, *len_ptr, pdu_padding_bits);
    *len_ptr += pdu_padding_bits;
  }

  #define FTYPE cai_msg_int_type

  {
    /* ERROR case.
       just increment the length pointer and let MACI be non-deterministic
       value.
    */
    *len_ptr += FSIZ(FTYPE, maci);
  }

  #undef FTYPE

} /* xlate_int_maci */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_INT_AC_ENC

DESCRIPTION
  This function translates Extended Encryption fields from internal to
  external format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_ac_enc
(
  word *len_ptr,
    /* Pointer to length of Access Channel header in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_ac_enc_type *int_ptr,
    /* Pointer to the internal format of the encryption fields */
  caii_ac_auth_msg_int_type *ami_ptr
    /* Pointer to the internal format of the authentication and message
       integrity fields */
)
{
  word buffer_pos = *len_ptr;
    /* Position to pack bits in message */

  if ( caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    b_packb(int_ptr->enc_fields_incl, buf_ptr, buffer_pos,
      FSIZ( cai_ext_enc_type, enc_fields_incl));
    buffer_pos += FSIZ( cai_ext_enc_type, enc_fields_incl);

    if (int_ptr->enc_fields_incl)
    {
      /* ----------------------------------------
      ** Pack extended encryption specific fields
      ** ---------------------------------------- */
      b_packb(int_ptr->sdu_encrypt_mode, buf_ptr, buffer_pos,
        FSIZ(cai_ext_enc_type, sdu_encrypt_mode));
      buffer_pos += FSIZ(cai_ext_enc_type, sdu_encrypt_mode);

      if (((int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_ECMEA)
           || (int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_REA))
#ifdef FEATURE_IS2000_REL_C
          && ((caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_C) ||
              (!ami_ptr->maci_incl)
             )
#endif /* FEATURE_IS2000_REL_C */
         )
      {
        b_packb(int_ptr->enc_seq, buf_ptr, buffer_pos,
          FSIZ(cai_ext_enc_type, enc_seq));
        buffer_pos += FSIZ(cai_ext_enc_type, enc_seq);
      }
    }

    *len_ptr = buffer_pos;

  }

}  /* xlate_int_ac_enc */

#endif /* FEATURE_IS2000_REL_A */

/*===========================================================================

FUNCTION XLATE_INT_REG

DESCRIPTION
  This function translates a Registration Message from internal
  to external format.

DEPENDENCIES
  p_rev_in_use is required in the internal format.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_reg
(
  word *len_ptr,
    /* Pointer to length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position of L3 SDU */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------
  ** Pack Registration Message up through the MSID field
  ** --------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->reg.msg_type,
      &int_ptr->reg.hdr, &int_ptr->reg.ami);

#ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr,
                     &int_ptr->reg.enc,
                     &int_ptr->reg.ami
                    );

#endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb ((byte) ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    /* -----------------------------
    ** Add RER fields for P_REV >= 6
    **------------------------------ */

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,&(int_ptr->reg.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A_AES
    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    sdu_start_pos = buffer_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    b_packb( int_ptr->reg.reg_type, buf_ptr, buffer_pos,
             FSIZ( cai_reg_type, reg_type ));
    buffer_pos += FSIZ( cai_reg_type, reg_type );

    b_packb( int_ptr->reg.slot_cycle_index, buf_ptr, buffer_pos,
             FSIZ( cai_reg_type, slot_cycle_index ));
    buffer_pos += FSIZ( cai_reg_type, slot_cycle_index );

    b_packb( int_ptr->reg.mob_p_rev, buf_ptr, buffer_pos,
             FSIZ( cai_reg_type, mob_p_rev ));
    buffer_pos += FSIZ( cai_reg_type, mob_p_rev );

    b_packb( int_ptr->reg.scm, buf_ptr, buffer_pos,
             FSIZ( cai_reg_type, scm ));
    buffer_pos += FSIZ( cai_reg_type, scm );

    b_packb( int_ptr->reg.mob_term, buf_ptr, buffer_pos,
             FSIZ( cai_reg_type, mob_term ));
    buffer_pos += FSIZ( cai_reg_type, mob_term );


    /* ------------------------------------------------------
    ** This field is new to IS-95B, it is up to the higher
    ** layer to set p_rev_in_use
    ** ------------------------------------------------------ */
    if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
    {
      b_packb( int_ptr->reg.return_cause, buf_ptr, buffer_pos,
               FSIZ( cai_reg_type, return_cause ));
      buffer_pos += FSIZ( cai_reg_type, return_cause );

      if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
      {
        (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,&(int_ptr->reg.pilot_rpt));
        buffer_pos += ac_plt_rpt_len;
      }
      else
      {
        b_packb( int_ptr->reg.qpch_supported, buf_ptr, buffer_pos,
                 FSIZ(cai_reg_is2000_type,qpch_supported));
        buffer_pos += FSIZ(cai_reg_is2000_type,qpch_supported);
        b_packb( int_ptr->reg.enhanced_rc, buf_ptr, buffer_pos,
                 FSIZ(cai_reg_is2000_type,enhanced_rc));
        buffer_pos += FSIZ(cai_reg_is2000_type,enhanced_rc);
        b_packb( int_ptr->reg.uzid_incl, buf_ptr, buffer_pos,
                 FSIZ(cai_reg_is2000_type,uzid_incl));
        buffer_pos += FSIZ(cai_reg_is2000_type,uzid_incl);
        if (int_ptr->reg.uzid_incl)
        {
          b_packw( int_ptr->reg.uzid, buf_ptr, buffer_pos,
                   FSIZ(cai_reg_is2000_type,uzid));
          buffer_pos += FSIZ(cai_reg_is2000_type,uzid);
        }
      }
    }

#ifdef FEATURE_IS2000_REL_A
    if(caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      b_packb( int_ptr->reg.geo_loc_incl, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, geo_loc_incl ));
      buffer_pos += FSIZ( cai_reg_is2000_type, geo_loc_incl );

      if( int_ptr->reg.geo_loc_incl)
      {
        b_packb( int_ptr->reg.geo_loc_type, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, geo_loc_type ));
        buffer_pos += FSIZ( cai_reg_is2000_type, geo_loc_type );

      }

      b_packb( int_ptr->reg.otd_supported, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, otd_supported ));
      buffer_pos += FSIZ( cai_reg_is2000_type, otd_supported );

      b_packb( int_ptr->reg.sts_supported, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, sts_supported ));
      buffer_pos += FSIZ( cai_reg_is2000_type, sts_supported );

      b_packb( int_ptr->reg.thx_cch_supported, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, thx_cch_supported ));
      buffer_pos += FSIZ( cai_reg_is2000_type, thx_cch_supported );

      b_packb( int_ptr->reg.wll_incl, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, wll_incl ));
      buffer_pos += FSIZ( cai_reg_is2000_type, wll_incl );

      if (int_ptr->reg.wll_incl)
      {
        b_packb( int_ptr->reg.wll_device_type, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, wll_device_type ));
        buffer_pos += FSIZ( cai_reg_is2000_type, wll_device_type );

        b_packb( int_ptr->reg.hook_status, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, hook_status ));
        buffer_pos += FSIZ( cai_reg_is2000_type, hook_status );
      }

      b_packb( int_ptr->reg.enc_info_incl, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, enc_info_incl ));
      buffer_pos += FSIZ( cai_reg_is2000_type, enc_info_incl );

      if (int_ptr->reg.enc_info_incl)
      {
        b_packb( int_ptr->reg.sig_encrypt_sup, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, sig_encrypt_sup ));
        buffer_pos += FSIZ( cai_reg_is2000_type, sig_encrypt_sup );

        b_packb( int_ptr->reg.c_sig_encrypt_req, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, c_sig_encrypt_req ));
        buffer_pos += FSIZ( cai_reg_is2000_type, c_sig_encrypt_req );

        if (((int_ptr->reg.sig_encrypt_sup & CAI_ENC_SUP_ECMEA) != 0)||
            ((int_ptr->reg.sig_encrypt_sup & CAI_ENC_SUP_REA) != 0))
        {
          b_packd( int_ptr->reg.enc_seq_h, buf_ptr, buffer_pos,
                   FSIZ( cai_reg_is2000_type, enc_seq_h ));
          buffer_pos += FSIZ( cai_reg_is2000_type, enc_seq_h );

          b_packb( int_ptr->reg.enc_seq_h_sig, buf_ptr, buffer_pos,
                   FSIZ( cai_reg_is2000_type, enc_seq_h_sig ));
          buffer_pos += FSIZ( cai_reg_is2000_type, enc_seq_h_sig );
        }

        b_packb( int_ptr->reg.ui_encrypt_sup, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, ui_encrypt_sup ));
        buffer_pos += FSIZ( cai_reg_is2000_type, ui_encrypt_sup );
      }

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        b_packb( int_ptr->reg.msg_int_info_incl, buf_ptr, buffer_pos,
                     FSIZ( cai_reg_is2000_type, msg_int_info_incl ));
        buffer_pos += FSIZ( cai_reg_is2000_type, msg_int_info_incl);

        if (int_ptr->reg.msg_int_info_incl)
        {
          b_packb( int_ptr->reg.sig_integrity_sup_incl, buf_ptr, buffer_pos,
                   FSIZ( cai_reg_is2000_type, sig_integrity_sup_incl ));
          buffer_pos += FSIZ( cai_reg_is2000_type, sig_integrity_sup_incl);

          if (int_ptr->reg.sig_integrity_sup_incl)
          {
            b_packb( int_ptr->reg.sig_integrity_sup, buf_ptr, buffer_pos,
                     FSIZ( cai_reg_is2000_type, sig_integrity_sup ));
            buffer_pos += FSIZ( cai_reg_is2000_type, sig_integrity_sup);

            b_packb( int_ptr->reg.sig_integrity_req, buf_ptr, buffer_pos,
                        FSIZ( cai_reg_is2000_type, sig_integrity_req ));
            buffer_pos += FSIZ( cai_reg_is2000_type, sig_integrity_req);
          }
          b_packb( int_ptr->reg.new_key_id, buf_ptr, buffer_pos,
                    FSIZ( cai_reg_is2000_type, new_key_id ));
           buffer_pos += FSIZ( cai_reg_is2000_type, new_key_id);

          b_packb( int_ptr->reg.new_sseq_h_incl, buf_ptr, buffer_pos,
                         FSIZ( cai_reg_is2000_type, new_sseq_h_incl ));
          buffer_pos += FSIZ( cai_reg_is2000_type, new_sseq_h_incl);

          if (int_ptr->reg.new_sseq_h_incl)
          {
            b_packd( int_ptr->reg.new_sseq_h, buf_ptr, buffer_pos,
                      FSIZ( cai_reg_is2000_type, new_sseq_h ));
            buffer_pos += FSIZ( cai_reg_is2000_type, new_sseq_h);

            b_packb( int_ptr->reg.new_sseq_h_sig, buf_ptr, buffer_pos,
                          FSIZ( cai_reg_is2000_type, new_sseq_h_sig ));
            buffer_pos += FSIZ( cai_reg_is2000_type, new_sseq_h_sig);
          }
        }

      }
#endif /* FEATURE_IS2000_REL_C */

      #ifdef FEATURE_IS2000_REL_A_AES
      if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
      {
        buffer_pos = mccaes_calculate_new_buf_length(int_ptr->reg.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
      }
      else
      {
        auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                              int_ptr->reg.enc.sdu_encrypt_mode,
                              int_ptr->reg.hdr.ack_req
                             );
      }
      #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        /* ----------------------------
        ** Pack the MACI field
        ** ---------------------------- */
        if (int_ptr->reg.ami.maci_incl)
        {
          xlate_int_maci(&buffer_pos,
                         buf_ptr,
                         CAI_AC_CRC_SIZE,
                         int_ptr->reg.hdr.ack_req,
                         chn,
                         int_ptr->reg.ami.sdu_key_id,
                          int_ptr->reg.msg_type,
                         int_ptr->reg.ami.sdu_integrity_algo,
                         &int_ptr->reg.ami.maci
                         );
        }  /* maci_incl */
       } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
    } /* prev >= 7 */
#endif /* FEATURE_IS2000_REL_A */

  } /* status DONE_S */
  *len_ptr = buffer_pos;

  return (status );

} /* xlate_int_reg */

/*===========================================================================

FUNCTION XLATE_INT_AC_ORD

DESCRIPTION
  This function translates an Access Channel Order Message from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_ord
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos = 0;
    /* Position to pack bits in message */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos = 0;
    /* Position of the place where encryption should start */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  if(cdma.entry_ptr->entry != MCC_CSFB)
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
  {
    /* -----------------------------------------------------------
    ** Pack Access Channel Order Message up through the MSID field
    ** ----------------------------------------------------------- */
    status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );
  } /* end of cdma.entry_ptr->entry != MCC_CSFB */

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
    if(cdma.entry_ptr->entry != MCC_CSFB)
    #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
    {
      /* The following was needed because we would pack 00 knowing
       * auth_mode is always 0 for ORDER messages but that is now taken
       * care of */
      //b_packb( 0, buf_ptr, buffer_pos, FSIZ( cai_ac_gen_ord_type, reserved ));
      //buffer_pos += FSIZ( cai_ac_gen_ord_type, reserved );

      /* -----------------------------------------------------------
      ** Pack the authentication fields and message integrity fields
      ** ----------------------------------------------------------- */
      xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_ord.gen.msg_type,
        &int_ptr->ac_ord.gen.hdr, &int_ptr->ac_ord.gen.ami);

      #ifdef FEATURE_IS2000_REL_A
      /* -------------------------------
      ** Pack Extended Encryption fields
      ** ------------------------------- */
      xlate_int_ac_enc(&buffer_pos, buf_ptr,
                       &int_ptr->ac_ord.gen.enc,
                       &int_ptr->ac_ord.gen.ami
                      );
      #endif /* FEATURE_IS2000_REL_A */

      if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
      {
        ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
        ac_l2_num_bytes = (ac_l2_num_bits/8);
        ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
        if (ac_l2_num_reserved != 8)
        {
          ac_l2_num_bytes += 1;
          b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
          buffer_pos += ac_l2_num_reserved;
        }
        b_packb ((byte) ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
      }

      /* -----------------------------
      ** Add RER fields for P_REV >= 6
      **------------------------------ */
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
      {
        (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,&(int_ptr->ac_ord.gen.pilot_rpt));
        buffer_pos += ac_plt_rpt_len;
      }
    } /* end of (cdma.entry_ptr->entry != MCC_CSFB) */

#ifdef FEATURE_IS2000_REL_A_AES
    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    sdu_start_pos = buffer_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packb( int_ptr->ac_ord.gen.order, buf_ptr, buffer_pos,
             FSIZ( cai_ac_gen_ord_type, order ));
    buffer_pos += FSIZ( cai_ac_gen_ord_type, order );

    switch (int_ptr->ac_ord.gen.order)
    {
      case CAI_BS_CHAL_ORD:
        /* ----------------------------
        ** Base Station Challenge Order
        ** ---------------------------- */
        b_packb( 5, buf_ptr, buffer_pos,
                 FSIZ( cai_ac_bs_chal_type, add_record_len ));
        buffer_pos += FSIZ( cai_ac_bs_chal_type, add_record_len );

        b_packb( 0, buf_ptr, buffer_pos, FSIZ( cai_ac_bs_chal_type, ordq ));
        buffer_pos += FSIZ( cai_ac_bs_chal_type, ordq );

        b_packd( int_ptr->ac_ord.chal.randbs, buf_ptr, buffer_pos,
                 FSIZ( cai_ac_bs_chal_type, randbs ));
        buffer_pos += FSIZ( cai_ac_bs_chal_type, randbs );
        break;

      case CAI_SSD_UPDATE_ORD:
      case CAI_LOCAL_CTL_RESP_ORD:
      case CAI_RELEASE_ORD:
        /* -------------------------------------------------
        ** Messages with potential order qualification codes
        ** ------------------------------------------------- */
        if (int_ptr->ac_ord.ordq.ordq == 0)
        {
          /* ----------------------------------------
          ** No need to pack order qualification code
          ** ---------------------------------------- */
          b_packb( 0, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_gen_ord_type, add_record_len ));
          buffer_pos += FSIZ( cai_ac_gen_ord_type, add_record_len );
        }
        else
        {
          b_packb( 1, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_ordq_type, add_record_len ));
          buffer_pos += FSIZ( cai_ac_ordq_type, add_record_len );

          b_packb( int_ptr->ac_ord.ordq.ordq, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_ordq_type, ordq ));
          buffer_pos += FSIZ( cai_ac_ordq_type, ordq );
        }
        break;

      case CAI_MS_REJECT_ORD:

        if (int_ptr->ac_ord.rej.rej_msg_type == CAI_PC_ORD_MSG)
        {
          byte my_record_len = 4;
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            my_record_len++;
          }
          b_packb( my_record_len, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_ord_type, add_record_len ));
          buffer_pos += FSIZ( cai_ac_rej_ord_type, add_record_len );
          b_packb( int_ptr->ac_ord.rej.ordq, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_ord_type, ordq ));
          buffer_pos += FSIZ( cai_ac_rej_ord_type, ordq );

          b_packb( int_ptr->ac_ord.rej.rej_msg_type, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_ord_type, rej_msg_type ));
          buffer_pos += FSIZ( cai_ac_rej_ord_type, rej_msg_type );

          b_packb( int_ptr->ac_ord.rej_ord.rej_order, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_ord_type, rej_order ));
          buffer_pos += FSIZ( cai_ac_rej_ord_type, rej_order );

          b_packb( int_ptr->ac_ord.rej_ord.rej_ordq, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_ord_type, rej_ordq ));
          buffer_pos += FSIZ( cai_ac_rej_ord_type, rej_ordq );

          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            b_packb( int_ptr->ac_ord.rej_ord.rejected_pdu_type, buf_ptr,
                     buffer_pos,
                     FSIZ(cai_ac_rej_ord_is2000_type,rejected_pdu_type));
            buffer_pos += FSIZ(cai_ac_rej_ord_is2000_type,rejected_pdu_type);

            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ(cai_ac_rej_ord_is2000_type,reserved));
            buffer_pos += FSIZ(cai_ac_rej_ord_is2000_type,reserved);
          }
          break;
        }
        else if (int_ptr->ac_ord.rej.rej_msg_type == CAI_FEATURE_MSG)
        {
          byte my_record_len = 3;
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            my_record_len++;
          }
          b_packb( my_record_len, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_rec_type, add_record_len ));
          buffer_pos +=  FSIZ( cai_ac_rej_rec_type, add_record_len );
          b_packb( int_ptr->ac_ord.rej.ordq, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_rec_type, ordq ));
          buffer_pos += FSIZ( cai_ac_rej_rec_type, ordq );

          b_packb( int_ptr->ac_ord.rej.rej_msg_type, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_rec_type, rej_msg_type ));
          buffer_pos += FSIZ( cai_ac_rej_rec_type, rej_msg_type );

          b_packb( int_ptr->ac_ord.rej_rec.rej_record, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_rec_type, rej_record ));
          buffer_pos += FSIZ( cai_ac_rej_rec_type, rej_record );
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            b_packb( int_ptr->ac_ord.rej_ord.rejected_pdu_type, buf_ptr,
                     buffer_pos,
                     FSIZ(cai_ac_rej_rec_is2000_type,rejected_pdu_type));
            buffer_pos += FSIZ(cai_ac_rej_rec_is2000_type,rejected_pdu_type);

            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ(cai_ac_rej_rec_is2000_type,reserved));
            buffer_pos += FSIZ(cai_ac_rej_rec_is2000_type,reserved);
          }
        }
        else
        {
          byte my_record_len = 2;
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            my_record_len++;
          }
          b_packb( my_record_len, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_type, add_record_len ));
          buffer_pos +=  FSIZ( cai_ac_rej_type, add_record_len );
          b_packb( int_ptr->ac_ord.rej.ordq, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_type, ordq ));
          buffer_pos += FSIZ( cai_ac_rej_type, ordq );

          b_packb( int_ptr->ac_ord.rej.rej_msg_type, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_type, rej_msg_type ));
          buffer_pos += FSIZ( cai_ac_rej_type, rej_msg_type );
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            b_packb( int_ptr->ac_ord.rej_ord.rejected_pdu_type, buf_ptr,
                     buffer_pos,
                     FSIZ(cai_ac_rej_is2000_type,rejected_pdu_type));
            buffer_pos += FSIZ(cai_ac_rej_is2000_type,rejected_pdu_type);

            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ(cai_ac_rej_is2000_type,reserved));
            buffer_pos += FSIZ(cai_ac_rej_is2000_type,reserved);
          }
        }
        break;

#ifdef FEATURE_IS2000_REL_C
      case CAI_SEC_MODE_CMP_ORD:
#endif /* FEATURE_IS2000_REL_C */
      case CAI_MS_ACK_ORD:
        /* -------------------------------------
        ** No order qualification code necessary
        ** ------------------------------------- */
        b_packb( 0, buf_ptr, buffer_pos,
                 FSIZ( cai_ac_gen_ord_type, add_record_len ));
        buffer_pos += FSIZ( cai_ac_gen_ord_type, add_record_len );
        break;

      default:
        /* ---------------------------------
        ** Invalid Access Channel Order Code
        ** --------------------------------- */
        status = CAIX_INV_MSG_S;
        break;
    } /* end switch */

    if ( status == CAIX_DONE_S
         #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
         && (cdma.entry_ptr->entry != MCC_CSFB)
         #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
       )
    {
      if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
      {
        if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
        {
          (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                            buf_ptr,buffer_pos,&(int_ptr->ac_ord.gen.pilot_rpt));
          buffer_pos += ac_plt_rpt_len;
        }
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        #ifdef FEATURE_IS2000_REL_A_AES
        if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
        {
          buffer_pos = mccaes_calculate_new_buf_length(int_ptr->ac_ord.gen.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
        }
        else
        {
          auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                                int_ptr->ac_ord.gen.enc.sdu_encrypt_mode,
                                int_ptr->ac_ord.gen.hdr.ack_req
                               );
        }
        #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
        {
          /* ----------------------------
           ** Pack the MACI field
           ** ---------------------------- */
          if (int_ptr->ac_ord.gen.ami.maci_incl)
          {
            xlate_int_maci(&buffer_pos,
                           buf_ptr,
                           CAI_AC_CRC_SIZE,
                           int_ptr->ac_ord.gen.hdr.ack_req,
                           chn,
                           int_ptr->ac_ord.gen.ami.sdu_key_id,
                          int_ptr->ac_ord.gen.msg_type,
                           int_ptr->ac_ord.gen.ami.sdu_integrity_algo,
                           &int_ptr->ac_ord.gen.ami.maci
                           );
          } /* maci_incl */
        } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
      } /* prev >= 7 */
#endif /* FEATURE_IS2000_REL_A */

    } /* status DONE_S */
  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

} /* xlate_int_ac_ord */

/*===========================================================================

FUNCTION XLATE_INT_AC_TMSI_CMP

DESCRIPTION
  This function translates an Access Channel TMSI Assignment Completion
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_tmsi_cmp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */

  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ----------------------------------------------------------------
  ** Pack Access Channel Data Burst Message up through the MSID field
  ** ---------------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_tmsi_cmp.msg_type,
      &int_ptr->ac_tmsi_cmp.hdr, &int_ptr->ac_tmsi_cmp.ami);

    #ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr,
                     &int_ptr->ac_tmsi_cmp.enc,
                     &int_ptr->ac_tmsi_cmp.ami
                    );
    #endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb ((byte) ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    if (caix_p_rev_in_use >= CAIX_P_REV_IS95B)
    {
      /* -----------------------------
      ** Add RER fields for P_REV >= 4
      **------------------------------ */
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,
                        &(int_ptr->ac_tmsi_cmp.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      /* ---------------------------------------
      ** L3 SDU Fields
      **---------------------------------------- */

      #ifdef FEATURE_IS2000_REL_A_AES

      sdu_start_pos = buffer_pos;
      if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
      {
        buffer_pos = mccaes_calculate_new_buf_length(int_ptr->ac_tmsi_cmp.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
      }
      else
      {
        auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                              int_ptr->ac_tmsi_cmp.enc.sdu_encrypt_mode,
                              int_ptr->ac_tmsi_cmp.hdr.ack_req
                             );
      }
      #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {

        /* ----------------------------
        ** Pack the MACI field
        ** ---------------------------- */
        if (int_ptr->ac_tmsi_cmp.ami.maci_incl)
        {
          xlate_int_maci(&buffer_pos,
                         buf_ptr,
                         CAI_AC_CRC_SIZE,
                         int_ptr->ac_tmsi_cmp.hdr.ack_req,
                         chn,
                         int_ptr->ac_tmsi_cmp.ami.sdu_key_id,
                         int_ptr->ac_tmsi_cmp.msg_type,
                         int_ptr->ac_tmsi_cmp.ami.sdu_integrity_algo,
                         &int_ptr->ac_tmsi_cmp.ami.maci
                         );

        } /* maci_incl */
      } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
    } /* prev >= 7 */
#endif /* FEATURE_IS2000_REL_A */

  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

} /* xlate_int_ac_tmsi_cmp */

/*===========================================================================

FUNCTION XLATE_INT_AC_PACA_CAN

DESCRIPTION
  This function translates an Access Channel PACA Cancel
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_paca_can
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Position of the place where encryption should start */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* ---------------------------------------------------
  ** Pack PACA Cancel Message up through the MSID field
  ** --------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_paca_can.msg_type,
      &int_ptr->ac_paca_can.hdr, &int_ptr->ac_paca_can.ami);

#ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */

    /* Since this message has no L3 fields, to parse LAC field correctly,
     * we sent enc_fields_incl to be FALSE
     */
    int_ptr->ac_paca_can.enc.enc_fields_incl = FALSE;
    xlate_int_ac_enc(&buffer_pos, buf_ptr,
                     &int_ptr->ac_paca_can.enc,
                     &int_ptr->ac_paca_can.ami
                    );
#endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb ((byte) ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    /* -----------------------------
    ** Add RER fields for P_REV >= 4
    **------------------------------ */
    if (caix_p_rev_in_use >= CAIX_P_REV_IS95B )
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,
                        &(int_ptr->ac_paca_can.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      /* ---------------------------------------
      ** L3 SDU Fields
      **---------------------------------------- */

      #ifdef FEATURE_IS2000_REL_A_AES
      sdu_start_pos = buffer_pos;
      if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
      {
        buffer_pos = mccaes_calculate_new_buf_length(int_ptr->ac_paca_can.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
      }
      else
      {
        /* actually this message has no L3 fields, so it should never be encrypted.
         * skip the extended encryption function call here
         */
        /* auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                              int_ptr->ac_paca_can.enc.sdu_encrypt_mode,
                              int_ptr->ac_paca_can.hdr.ack_req);
         */
      }
      #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        /* ----------------------------
        ** Pack the MACI field
        ** ---------------------------- */
        if (int_ptr->ac_paca_can.ami.maci_incl)
        {
          xlate_int_maci(&buffer_pos,
                         buf_ptr,
                         CAI_AC_CRC_SIZE,
                         int_ptr->ac_paca_can.hdr.ack_req,
                         chn,
                         int_ptr->ac_paca_can.ami.sdu_key_id,
                         int_ptr->ac_paca_can.msg_type,
                         int_ptr->ac_paca_can.ami.sdu_integrity_algo,
                         &int_ptr->ac_paca_can.ami.maci
                         );
        } /* maci_incl */
      } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
    } /* p_rev >= 7 */
#endif /* FEATURE_IS2000_REL_A */

  }

  *len_ptr = buffer_pos;

  return (status );

} /* xlate_int_ac_paca_can */

/*===========================================================================

FUNCTION XLATE_INT_AC_EXT_STRSP

DESCRIPTION
  This function translates an Access Channel Extended Status Response
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_ext_strsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */

)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack bits in message */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */

#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos = 0;
    /* Position of the place where encryption should start */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------------------------
  ** Pack Extended Status Response Message up through the MSID field
  ** ------------------------------------------------------ */
  status = xlate_int_ac_hdr( &msg_pos, buf_ptr, int_ptr );

  if ( status != CAIX_DONE_S )
  {
    return ( status ); /* Header translation failed */
  }

  /* ----------------------------
  ** Pack the rest of the message
  ** ---------------------------- */

  /* ------------------------------------------------------------
  ** Pack the authentication fields and message intergrity fields
  ** ------------------------------------------------------------ */
  xlate_int_ac_auth_msg_int(&msg_pos, buf_ptr, int_ptr->ac_ext_strsp.msg_type,
    &int_ptr->ac_ext_strsp.hdr, &int_ptr->ac_ext_strsp.ami);

#ifdef FEATURE_IS2000_REL_A
  /* -------------------------------
  ** Pack Extended Encryption fields
  ** ------------------------------- */
  xlate_int_ac_enc(&msg_pos, buf_ptr,
                   &int_ptr->ac_ext_strsp.enc,
                   &int_ptr->ac_ext_strsp.ami
                  );
#endif /* FEATURE_IS2000_REL_A */

  if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
  {
    ac_l2_num_bits = msg_pos-ac_l2_start_pos;
    ac_l2_num_bytes = (ac_l2_num_bits/8);
    ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
    if (ac_l2_num_reserved != 8)
    {
      ac_l2_num_bytes += 1;
      b_packb (0,buf_ptr,msg_pos,ac_l2_num_reserved);
      msg_pos += ac_l2_num_reserved;
    }
    b_packb ((byte) ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
  }

  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
  {
    /* -----------------------------
    ** Add RER fields for P_REV >= 6
    **------------------------------_ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,msg_pos,
                      &(int_ptr->ac_ext_strsp.pilot_rpt));
    msg_pos += ac_plt_rpt_len;
  }

#ifdef FEATURE_IS2000_REL_A_AES
  /* ---------------------------------------
  ** L3 SDU Fields
  **---------------------------------------- */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->ac_ext_strsp.qual,
           buf_ptr, msg_pos, FSIZ( cai_ac_ext_strsp_fix_type, qual_info_type));
  msg_pos += FSIZ( cai_ac_ext_strsp_fix_type, qual_info_type );

  if ( int_ptr->ac_ext_strsp.qual == CAI_NO_QUAL ) /* No qual info */
  {
    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_ac_ext_strsp_fix_type,
              qual_info_len ) );
    msg_pos += FSIZ( cai_ac_ext_strsp_fix_type, qual_info_len );
  }
  else if ( int_ptr->ac_ext_strsp.qual == CAI_BAND_QUAL )
  {
    /* Band qual info */
    b_packb( sizeof(cai_qual_info1_type) / 8,
             buf_ptr, msg_pos, FSIZ(cai_ac_ext_strsp_fix_type, qual_info_len));
    msg_pos += FSIZ( cai_ac_ext_strsp_fix_type, qual_info_len );

    b_packb( int_ptr->ac_ext_strsp.band,
             buf_ptr, msg_pos, FSIZ( cai_qual_info1_type, band ) );
    msg_pos += FSIZ( cai_qual_info1_type, band );

    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_qual_info1_type, reserved ) );
    msg_pos += FSIZ( cai_qual_info1_type, reserved );
  }
  else if ( int_ptr->ac_ext_strsp.qual == CAI_BAND_OP_MODE_QUAL )
  {
    b_packb( sizeof(cai_qual_info2_type) / 8,
             buf_ptr, msg_pos, FSIZ(cai_ac_ext_strsp_fix_type, qual_info_len));
    msg_pos += FSIZ( cai_ac_ext_strsp_fix_type, qual_info_len );

    b_packb( int_ptr->ac_ext_strsp.band,
             buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, band ) );
    msg_pos += FSIZ( cai_qual_info2_type, band );

    b_packb( int_ptr->ac_ext_strsp.op_mode,
             buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, op_mode ) );
    msg_pos += FSIZ( cai_qual_info2_type, op_mode );

    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, reserved ) );
    msg_pos += FSIZ( cai_qual_info2_type, reserved );
  }
  else
  {
    return ( CAIX_INV_MSG_S ); /* Unknown qual info type */
  }

  b_packb( int_ptr->ac_ext_strsp.num_recs, buf_ptr, msg_pos,
           FSIZ( cai_ac_ext_strsp_fix_type, num_info_rec ) );
  msg_pos += FSIZ( cai_ac_ext_strsp_fix_type, num_info_rec );

  /* Translate the information records */
  for ( i = irec_pos = 0; (i < int_ptr->ac_ext_strsp.num_recs) ; i++ )
  {
    if((irec_pos/4) < CAII_MAX_INFO_REC_DWORDS)
    {
      status =
      xlate_int_info_rec(
                        (byte*)(&int_ptr->ac_ext_strsp.recs[irec_pos/4]),
                        &irec_len,
                        CAI_AC_BODY_SIZE - msg_pos,
                        buf_ptr,
                        msg_pos,
                        &xrec_len );
    }

    if ( status != CAIX_DONE_S )
    {
      return ( status ); /* Problem translating info rec */
    }

    msg_pos  += xrec_len;  /* Advance external msg buf position */
    irec_pos += irec_len;  /* Advance internal msg buf position */
    /* The next record will start only on a dword boundary, so move positions accordingly */
    irec_pos = (irec_pos%4)?(irec_pos+(sizeof(dword))-irec_pos%4):irec_pos;
  } /* for */

  if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
  {
    if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,msg_pos,&(int_ptr->ac_ext_strsp.pilot_rpt));
      msg_pos += ac_plt_rpt_len;
    }
  }

#ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    #ifdef FEATURE_IS2000_REL_A_AES
    if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
    {
      msg_pos = mccaes_calculate_new_buf_length(int_ptr->ac_ext_strsp.enc.sdu_encrypt_mode, sdu_start_pos, msg_pos);
    }
    else
    {
      auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                            int_ptr->ac_ext_strsp.enc.sdu_encrypt_mode,
                            int_ptr->ac_ext_strsp.hdr.ack_req
                           );
    }
    #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
      if (int_ptr->ac_ext_strsp.ami.maci_incl)
      {
        xlate_int_maci(&msg_pos,
                       buf_ptr,
                       CAI_AC_CRC_SIZE,
                       int_ptr->ac_ext_strsp.hdr.ack_req,
                       chn,
                       int_ptr->ac_ext_strsp.ami.sdu_key_id,
                       int_ptr->ac_ext_strsp.msg_type,
                       int_ptr->ac_ext_strsp.ami.sdu_integrity_algo,
                       &int_ptr->ac_ext_strsp.ami.maci
                      );
      } /* maci_incl */
    } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */

  } /* P_REV >= 7 */
#endif /* FEATURE_IS2000_REL_A */

  *len_ptr = msg_pos; /* Set length of message */

  return ( status );

} /* xlate_int_ac_ext_strsp */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_INT_AC_DIM

DESCRIPTION
  This function translates Device Information
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_dim
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Position of the place where encryption should start */
  #endif /* FEATURE_IS2000_REL_A_AES */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(caix_p_rev_in_use <= CAIX_P_REV_IS2000)
  {
    M1X_MSG( DCP, LEGACY_HIGH,
      "Msg not supported by P_REV");
    return CAIX_INV_MSG_S;
  }

  /* ---------------------------------------------------
  ** Pack Message up through the MSID field
  ** --------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->dim.msg_type,
      &int_ptr->dim.hdr, &int_ptr->dim.ami);

    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    
    /* for some reason, there is no message building function for Device
     * Information Message at Layer 3. This means that the LAC field setting
     * is un-predictable.
     *
     * To make sure the parsing goes correctly with AES, we call a function
     * to set encryption fields as messages built in mccsa.c
     */
    int_ptr->dim.enc.enc_fields_incl = FALSE;

    #ifdef FEATURE_IS2000_REL_A_AES
    mccaes_setup_ac_encrypt_fields(&int_ptr->dim.enc,
                                   &int_ptr->dim.ami,
                                   int_ptr->dim.msg_type,
                                   int_ptr->dim.hdr.ack_req,
                                   0, 0  /* order and orderq are dummy values here */
                                  );
    #endif /* FEATURE_IS2000_REL_A_AES */

    xlate_int_ac_enc(&buffer_pos, buf_ptr,
                     &int_ptr->dim.enc,
                     &int_ptr->dim.ami
                    );

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,buffer_pos,
                      &(int_ptr->dim.pilot_rpt));
    buffer_pos += ac_plt_rpt_len;


    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    #ifdef FEATURE_IS2000_REL_A_AES
    sdu_start_pos = buffer_pos;
    #endif /* FEATURE_IS2000_REL_A_AES */

    b_packb (int_ptr->dim.wll_device_type, buf_ptr, buffer_pos,
             FSIZ( cai_ac_dim_type, wll_device_type));
    buffer_pos += FSIZ( cai_ac_dim_type, wll_device_type);


    b_packb (int_ptr->dim.num_recs, buf_ptr, buffer_pos,
             FSIZ( cai_ac_dim_type, num_recs));
    buffer_pos += FSIZ( cai_ac_dim_type, num_recs);

    /* Translate the information records */
    for ( i = irec_pos = 0; (i < int_ptr->dim.num_recs); i++ )
    {
      if((irec_pos/4) < CAII_MAX_INFO_REC_DWORDS)
      {
        status =
        xlate_int_info_rec(
                          (byte*)(&int_ptr->dim.recs[irec_pos/4]),
                          &irec_len,
                          CAI_AC_BODY_SIZE - buffer_pos,
                          buf_ptr,
                          buffer_pos,
                          &xrec_len );
      }

      if ( status != CAIX_DONE_S )
      {
        return ( status ); /* Problem translating info rec */
      }

      buffer_pos  += xrec_len;  /* Advance external msg buf position */
      irec_pos += irec_len;  /* Advance internal msg buf position */
      /* The next record will start only on a dword boundary, so move positions accordingly */
      irec_pos = (irec_pos%4)?(irec_pos+(sizeof(dword))-irec_pos%4):irec_pos;

    } /* for */

    #ifdef FEATURE_IS2000_REL_A_AES
    if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
    {
      buffer_pos = mccaes_calculate_new_buf_length(int_ptr->dim.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
    }
    else
    {
      auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                            int_ptr->dim.enc.sdu_encrypt_mode,
                            int_ptr->dim.hdr.ack_req
                           );
    }
    #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
    if (int_ptr->dim.ami.maci_incl)
    {
      xlate_int_maci(&buffer_pos,
                     buf_ptr,
                     CAI_AC_CRC_SIZE,
                     int_ptr->dim.hdr.ack_req,
                     chn,
                     int_ptr->dim.ami.sdu_key_id,
                       int_ptr->dim.msg_type,
                     int_ptr->dim.ami.sdu_integrity_algo,
                     &int_ptr->dim.ami.maci
                     );
      } /* maci_incl */
    } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
  } /* status == CAIX_DONE */

  *len_ptr = buffer_pos;

  return (status );

} /* xlate_int_ac_dim */

/*===========================================================================

FUNCTION XLATE_INT_AC_SMRM

DESCRIPTION
  This function translates Security Mode Request
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_smrm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Position of the place where encryption should start */
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(caix_p_rev_in_use <= CAIX_P_REV_IS2000)
  {
    M1X_MSG( DCP, LEGACY_HIGH,
      "Msg not supported by P_REV");
    return CAIX_INV_MSG_S;
  }

  /* ---------------------------------------------------
  ** Pack Message up through the MSID field
  ** --------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->smrm.msg_type,
      &int_ptr->smrm.hdr, &int_ptr->smrm.ami);

    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr,
                     &int_ptr->smrm.enc,
                     &int_ptr->smrm.ami
                    );

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,buffer_pos,
                      &(int_ptr->smrm.pilot_rpt));
    buffer_pos += ac_plt_rpt_len;


    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    #ifdef FEATURE_IS2000_REL_A_AES
    sdu_start_pos = buffer_pos;
    #endif /* FEATURE_IS2000_REL_A_AES */

    b_packb (int_ptr->smrm.ui_enc_incl, buf_ptr, buffer_pos,
             FSIZ( cai_ac_smrm_type, ui_enc_incl));
    buffer_pos += FSIZ( cai_ac_smrm_type, ui_enc_incl);

    if(int_ptr->smrm.ui_enc_incl)
    {
      b_packb (int_ptr->smrm.ui_encrypt_sup, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, ui_encrypt_sup));
      buffer_pos += FSIZ( cai_ac_smrm_type, ui_encrypt_sup);

    }

    b_packb (int_ptr->smrm.sig_enc_incl, buf_ptr, buffer_pos,
             FSIZ( cai_ac_smrm_type, sig_enc_incl));
    buffer_pos += FSIZ( cai_ac_smrm_type, sig_enc_incl);

    if(int_ptr->smrm.sig_enc_incl)
    {
      b_packb (int_ptr->smrm.sig_encrypt_sup, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, sig_encrypt_sup));
      buffer_pos += FSIZ( cai_ac_smrm_type, sig_encrypt_sup);

      b_packb (int_ptr->smrm.c_sig_encrypt_req, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, c_sig_encrypt_req));
      buffer_pos += FSIZ( cai_ac_smrm_type, c_sig_encrypt_req);

    }

    b_packb (int_ptr->smrm.enc_seq_h_incl, buf_ptr, buffer_pos,
             FSIZ( cai_ac_smrm_type, enc_seq_h_incl));
    buffer_pos += FSIZ( cai_ac_smrm_type, enc_seq_h_incl);

    if (int_ptr->smrm.enc_seq_h_incl)
    {
      b_packd (int_ptr->smrm.enc_seq_h, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, enc_seq_h));
      buffer_pos += FSIZ( cai_ac_smrm_type, enc_seq_h);

      b_packb (int_ptr->smrm.enc_seq_h_sig, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, enc_seq_h_sig));
      buffer_pos += FSIZ( cai_ac_smrm_type, enc_seq_h_sig);

    }

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      b_packb( int_ptr->smrm.msg_int_info_incl, buf_ptr, buffer_pos,
           FSIZ( cai_ac_smrm_type, msg_int_info_incl));
      buffer_pos += FSIZ( cai_ac_smrm_type, msg_int_info_incl);
      if (int_ptr->smrm.msg_int_info_incl)
      {
        b_packb( int_ptr->smrm.sig_integrity_sup_incl, buf_ptr, buffer_pos,
             FSIZ( cai_ac_smrm_type, sig_integrity_sup_incl));
        buffer_pos += FSIZ( cai_ac_smrm_type, sig_integrity_sup_incl);

        if (int_ptr->smrm.sig_integrity_sup_incl)
        {
          b_packb( int_ptr->smrm.sig_integrity_sup, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, sig_integrity_sup));
          buffer_pos += FSIZ( cai_ac_smrm_type, sig_integrity_sup);
          b_packb( int_ptr->smrm.sig_integrity_req, buf_ptr, buffer_pos,
                 FSIZ( cai_ac_smrm_type, sig_integrity_req));
          buffer_pos += FSIZ( cai_ac_smrm_type, sig_integrity_req);
        }
      }

    }
#endif /* FEATURE_IS2000_REL_C */


    #ifdef FEATURE_IS2000_REL_A_AES
    if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
    {
      buffer_pos = mccaes_calculate_new_buf_length(int_ptr->smrm.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
    }
    else
    {
      auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                            int_ptr->smrm.enc.sdu_encrypt_mode,
                            int_ptr->smrm.hdr.ack_req
                           );
    }
    #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
    if (int_ptr->smrm.ami.maci_incl)
    {
      xlate_int_maci(&buffer_pos,
                     buf_ptr,
                     CAI_AC_CRC_SIZE,
                     int_ptr->smrm.hdr.ack_req,
                     chn,
                     int_ptr->smrm.ami.sdu_key_id,
                       int_ptr->smrm.msg_type,
                     int_ptr->smrm.ami.sdu_integrity_algo,
                     &int_ptr->smrm.ami.maci
                     );
      } /* maci_incl */
    } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
  } /* status = CAIX_DONE */

  *len_ptr = buffer_pos;

  return (status );

} /* xlate_int_ac_smrm */
#endif /* FEATURE_IS2000_REL_A */

/*===========================================================================

FUNCTION XLATE_INT_PLT_RPT

DESCRIPTION
  This function translates an Access Channel Pilot Report from internal to
  external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_plt_rpt
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  word buffer_offset,
    /* offset into buffer to start placing the message */
  caii_plt_rpt_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
  byte i;
    /* Temporary loop counter */
#ifdef FEATURE_IS2000_REL_A
  word rec_len_pos;
  word rec_start_pos;
    /* temporary positions */
  byte reserve_bits;
    /* number of reserve bits */
#endif /* FEATURE_IS2000_REL_A */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  buffer_pos = buffer_offset;

  /* --------------------------------
  ** Pack the fix part of the message
  ** -------------------------------- */
  b_packb( int_ptr->fix.act_plt_str, buf_ptr, buffer_pos,
           FSIZ( cai_plt_rpt_fix_type, act_plt_str));
  buffer_pos += FSIZ( cai_plt_rpt_fix_type, act_plt_str );

  b_packb( int_ptr->fix.first_is_act, buf_ptr, buffer_pos,
           FSIZ( cai_plt_rpt_fix_type, first_is_act));
  buffer_pos += FSIZ( cai_plt_rpt_fix_type, first_is_act );

  b_packb( int_ptr->fix.first_is_pta, buf_ptr, buffer_pos,
           FSIZ( cai_plt_rpt_fix_type, first_is_pta));
  buffer_pos += FSIZ( cai_plt_rpt_fix_type, first_is_pta );

  b_packb( int_ptr->fix.num_add_plt, buf_ptr, buffer_pos,
           FSIZ( cai_plt_rpt_fix_type, num_add_plt));
  buffer_pos += FSIZ( cai_plt_rpt_fix_type, num_add_plt );

  /* -------------------------------------
  ** Pack the variable part of the message
  ** ------------------------------------- */
  for (i=0; i<int_ptr->fix.num_add_plt; i++)
  {
    b_packw( int_ptr->var[i].plt_pn_phase, buf_ptr, buffer_pos,
             FSIZ( cai_plt_rpt_var_type, plt_pn_phase));
    buffer_pos += FSIZ( cai_plt_rpt_var_type, plt_pn_phase );

    b_packb( int_ptr->var[i].plt_strength, buf_ptr, buffer_pos,
             FSIZ( cai_plt_rpt_var_type, plt_strength));
    buffer_pos += FSIZ( cai_plt_rpt_var_type, plt_strength );

    b_packb( int_ptr->var[i].acc_ho_en, buf_ptr, buffer_pos,
             FSIZ( cai_plt_rpt_var_type, acc_ho_en));
    buffer_pos += FSIZ( cai_plt_rpt_var_type, acc_ho_en );

    b_packb( int_ptr->var[i].acc_attempted, buf_ptr, buffer_pos,
             FSIZ( cai_plt_rpt_var_type, acc_attempted));
    buffer_pos += FSIZ( cai_plt_rpt_var_type, acc_attempted );
  }

#ifdef FEATURE_IS2000_REL_A
  if( caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
  {
    b_packb( int_ptr->aux_fix.num_aux_plt, buf_ptr, buffer_pos,
             FSIZ( cai_aux_plt_rpt_fix_type, num_aux_plt));
    buffer_pos += FSIZ( cai_aux_plt_rpt_fix_type, num_aux_plt );

    for(i=0; i<int_ptr->aux_fix.num_aux_plt; i++)
    {
      b_packw( int_ptr->aux_var[i].plt_pn_phase, buf_ptr, buffer_pos,
               FSIZ( cai_aux_plt_rpt_var_type, plt_pn_phase));
      buffer_pos += FSIZ( cai_aux_plt_rpt_var_type, plt_pn_phase );

      b_packb( int_ptr->aux_var[i].plt_strength, buf_ptr, buffer_pos,
               FSIZ( cai_aux_plt_rpt_var_type, plt_strength));
      buffer_pos += FSIZ( cai_aux_plt_rpt_var_type, plt_strength );

      b_packb( int_ptr->aux_var[i].plt_rec_type, buf_ptr, buffer_pos,
               FSIZ( cai_aux_plt_rpt_var_type, plt_rec_type));
      buffer_pos += FSIZ( cai_aux_plt_rpt_var_type, plt_rec_type );

      rec_len_pos = buffer_pos;

      /* Skip record length and come back later */
      buffer_pos += FSIZ( cai_aux_plt_rpt_var_type, plt_rec_len );

          rec_start_pos = buffer_pos;

      switch (int_ptr->aux_var[i].plt_rec_type)
      {
        case CAI_AUX_PILOT_TYPE_0:
          b_packb( int_ptr->aux_var[i].rec0.qof, buf_ptr, buffer_pos,
                   FSIZ( cai_aux_plt_rec0_fix_type, qof));
          buffer_pos += FSIZ( cai_aux_plt_rec0_fix_type, qof );

          b_packb( int_ptr->aux_var[i].rec0.walsh_length, buf_ptr,
                   buffer_pos,
                   FSIZ( cai_aux_plt_rec0_fix_type, walsh_length));
          buffer_pos += FSIZ( cai_aux_plt_rec0_fix_type, walsh_length );

          b_packw( int_ptr->aux_var[i].rec0.pilot_walsh, buf_ptr,
                   buffer_pos,
                   int_ptr->aux_var[i].rec0.walsh_length+6);
          buffer_pos += int_ptr->aux_var[i].rec0.walsh_length+6;

          /* Calculate the length of reserved bits */
          reserve_bits = (sizeof(cai_aux_plt_rec0_fix_type) +
                              int_ptr->aux_var[i].rec0.walsh_length+6)
                             %8;

          if( reserve_bits != 0 )
          {
            reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
            b_packb( 0, buf_ptr, buffer_pos, reserve_bits );
            buffer_pos += reserve_bits;
          }


          /* Pack the record length fields */
          b_packb( (buffer_pos-rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
                   FSIZ( cai_aux_plt_rpt_var_type, plt_rec_len));


          break;
        default:
          M1X_MSG( DCP, LEGACY_ERROR,
            "Unknown aux pilot type");
          status = CAIX_INV_MSG_S;
          break;
      }
    }
  }
#endif /* FEATURE_IS2000_REL_A */

  *len_ptr = buffer_pos - buffer_offset;

  return (status );

} /* xlate_int_plt_rpt */

/*===========================================================================

FUNCTION XLATE_INT_AC_BURST

DESCRIPTION
  This function translates an Access Channel Data Burst Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_burst
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through characters */
  word buffer_pos = 0;;
    /* Position to pack bits in message */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Position of the place where encryption should start */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
#ifdef FEATURE_MODEM_1X_IRAT_LTO1X_TUNNELED_SMS
  if(cdma.entry_ptr->entry != MCC_CSFB)
#endif /* FEATURE_MODEM_1X_IRAT_LTO1X_TUNNELED_SMS */
  {
#ifndef FEATURE_IS2000_REL_A

    if (int_ptr->ac_burst.num_fields > CAI_AC_BURST_MAX)  /*lint !e685 */
    {
      mcc_burst_overflow_size = int_ptr->ac_burst.num_fields - CAI_AC_BURST_MAX;
      return (CAIX_INV_LEN_S);
    }
#endif /* FEATURE_IS2000_REL_A */
    /* ----------------------------------------------------------------
    ** Pack Access Channel Data Burst Message up through the MSID field
    ** ---------------------------------------------------------------- */
    status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );
  }

  if (status == CAIX_DONE_S)
  {

#ifdef FEATURE_MODEM_1X_IRAT_LTO1X_TUNNELED_SMS
    if(cdma.entry_ptr->entry != MCC_CSFB)
#endif /* FEATURE_MODEM_1X_IRAT_LTO1X_TUNNELED_SMS */
    {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_burst.msg_type,
      &int_ptr->ac_burst.hdr, &int_ptr->ac_burst.ami);

#ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr,
                     &int_ptr->ac_burst.enc,
                     &int_ptr->ac_burst.ami
                    );
#endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb ((byte) ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,&(int_ptr->ac_burst.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A_AES
    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    sdu_start_pos = buffer_pos;

#endif /* FEATURE_IS2000_REL_A_AES */
    }

    b_packb( int_ptr->ac_burst.msg_number, buf_ptr, buffer_pos,
             FSIZ( cai_burst_ac_fix_type, msg_number ));
    buffer_pos += FSIZ( cai_burst_ac_fix_type, msg_number );

    b_packb( int_ptr->ac_burst.burst_type, buf_ptr, buffer_pos,
             FSIZ( cai_burst_ac_fix_type, burst_type ));
    buffer_pos += FSIZ( cai_burst_ac_fix_type, burst_type );

    b_packb( int_ptr->ac_burst.num_msgs, buf_ptr, buffer_pos,
             FSIZ( cai_burst_ac_fix_type, num_msgs ));
    buffer_pos += FSIZ( cai_burst_ac_fix_type, num_msgs );

    b_packb( int_ptr->ac_burst.num_fields, buf_ptr, buffer_pos,
             FSIZ( cai_burst_ac_fix_type, num_fields ));
    buffer_pos += FSIZ( cai_burst_ac_fix_type, num_fields );

    for (i=0; i < int_ptr->ac_burst.num_fields; i++)
    {
      b_packb( int_ptr->ac_burst.chari[i], buf_ptr, buffer_pos,
               sizeof( cai_burst_ac_var_type ));
      buffer_pos += sizeof( cai_burst_ac_var_type );
    }

#ifdef FEATURE_MODEM_1X_IRAT_LTO1X_TUNNELED_SMS
    if(cdma.entry_ptr->entry != MCC_CSFB)
#endif /* FEATURE_MODEM_1X_IRAT_LTO1X_TUNNELED_SMS */
    {
      if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
      {
        if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
        {
          (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                            buf_ptr,buffer_pos,&(int_ptr->ac_burst.pilot_rpt));
          buffer_pos += ac_plt_rpt_len;
        }
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        #ifdef FEATURE_IS2000_REL_A_AES
        if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
        {
          buffer_pos = mccaes_calculate_new_buf_length(int_ptr->ac_burst.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
        }
        else
        {
          auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                                int_ptr->ac_burst.enc.sdu_encrypt_mode,
                                int_ptr->ac_burst.hdr.ack_req
                               );
        }
        #endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_C
        /* ----------------------------
         ** Pack the MACI field
         ** ---------------------------- */
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
        {
          if (int_ptr->ac_burst.ami.maci_incl)
          {
            xlate_int_maci(&buffer_pos,
                           buf_ptr,
                           CAI_AC_CRC_SIZE,
                           int_ptr->ac_burst.hdr.ack_req,
                           chn,
                           int_ptr->ac_burst.ami.sdu_key_id,
                           int_ptr->ac_burst.msg_type,
                           int_ptr->ac_burst.ami.sdu_integrity_algo,
                           &int_ptr->ac_burst.ami.maci
                          );
          } /* maci_incl */
        } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
      } /* prev >= 7 */
#endif /* FEATURE_IS2000_REL_A */

    } /* status DONE_S */
  }

  *len_ptr = buffer_pos;

  return (status);

} /* xlate_int_ac_burst */

/*===========================================================================

FUNCTION XLATE_INT_ORIG

DESCRIPTION
  This function translates an Origination Message from internal to
  external format.

DEPENDENCIES
  p_rev_in_use must be set correctly in the internal format.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_orig
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason,
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */

   boolean is_voip_1x_handoff
  /* Indicates if this is a VOIP-1X handoff */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  byte i;
    /* Index to looped through dialed digits */
  word buffer_pos = 0;
    /* Position in buffer to pack next field */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* L3 SDU start position */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  if(cdma.entry_ptr->entry == MCC_CSFB)
  {
    status = CAIX_DONE_S;
  }
  else
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
  {
    if (int_ptr->orig.num_fields > CAI_AC_ORIG_MAX)
    {
      return (CAIX_INV_LEN_S);
    }

    /* --------------------------------------------------
    ** Pack Origination Message up through the MSID field
    ** -------------------------------------------------- */
    status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );
  } /* if(cdma.entry_ptr->entry == MCC_CSFB) */
  if (status == CAIX_DONE_S)
  {
    #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
    if(cdma.entry_ptr->entry != MCC_CSFB)
    {
    #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
      /* ----------------------------
      ** Pack the rest of the message
      ** ---------------------------- */

      /* -------------------------------------------------------
      ** Pack authentication fields and message integrity fields
      ** ------------------------------------------------------- */
      xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->orig.msg_type,
        &int_ptr->orig.hdr, &int_ptr->orig.ami);

#ifdef FEATURE_IS2000_REL_A
      /* -------------------------------
      ** Pack Extended Encryption fields
      ** ------------------------------- */
      xlate_int_ac_enc(&buffer_pos, buf_ptr,
                       &int_ptr->orig.enc,
                       &int_ptr->orig.ami
                      );

#endif /* FEATURE_IS2000_REL_A */

      if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
      {
        ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
        ac_l2_num_bytes = (ac_l2_num_bits/8);
        ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
        if (ac_l2_num_reserved != 8)
        {
          ac_l2_num_bytes += 1;
          b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
          buffer_pos += ac_l2_num_reserved;
        }
        b_packb ((byte) ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
      }

      /* -----------------------------------------------
      ** Add RER fields for P_REV 6 & 7
      **------------------------------------------------ */

      if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          && !is_voip_1x_handoff
         )
      {
        (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,&(int_ptr->orig.pilot_rpt));
        buffer_pos += ac_plt_rpt_len;
      }

#ifdef FEATURE_IS2000_REL_A_AES
      /* ---------------------------------------
      ** L3 SDU Fields
      **---------------------------------------- */
      sdu_start_pos = buffer_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_MODEM_1X_IRAT_LTO1X
    }
#endif /* FEATURE_MODEM_1X_IRAT_LTO1X */

    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    b_packb( int_ptr->orig.mob_term, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, mob_term ));
    buffer_pos += FSIZ( cai_orig_fix1_type, mob_term );

    b_packb( int_ptr->orig.slot_cycle_index, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, slot_cycle_index ));
    buffer_pos += FSIZ( cai_orig_fix1_type, slot_cycle_index );

    b_packb( int_ptr->orig.mob_p_rev, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, mob_p_rev ));
    buffer_pos += FSIZ( cai_orig_fix1_type, mob_p_rev );

    b_packb( int_ptr->orig.scm, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, scm ));
    buffer_pos += FSIZ( cai_orig_fix1_type, scm );

    b_packb( int_ptr->orig.request_mode, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, request_mode ));
    buffer_pos += FSIZ( cai_orig_fix1_type, request_mode );

    b_packb( int_ptr->orig.special_service, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, special_service ));
    buffer_pos += FSIZ( cai_orig_fix1_type, special_service );

    if (int_ptr->orig.special_service) {
      b_packw( int_ptr->orig.service_option, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix1_type, service_option ));
      buffer_pos += FSIZ( cai_orig_fix1_type, service_option );
    }

    b_packb( int_ptr->orig.pm, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, pm ));
    buffer_pos += FSIZ( cai_orig_fix1_type, pm );

    b_packb( int_ptr->orig.digit_mode, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, digit_mode ));
    buffer_pos += FSIZ( cai_orig_fix1_type, digit_mode );

    if (int_ptr->orig.digit_mode
#ifdef FEATURE_IS2000_REL_C
        || (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
#endif /* FEATURE_IS2000_REL_C */
       )
    {
      b_packb( int_ptr->orig.number_type, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix1_type, number_type ));
      buffer_pos += FSIZ( cai_orig_fix1_type, number_type );

#ifdef FEATURE_IS2000_REL_C
      if (int_ptr->orig.digit_mode)
#endif /* FEATURE_IS2000_REL_C */
      {
        b_packb( int_ptr->orig.number_plan, buf_ptr, buffer_pos,
                 FSIZ( cai_orig_fix1_type, number_plan ));
        buffer_pos += FSIZ( cai_orig_fix1_type, number_plan );
      }
    }

    b_packb( int_ptr->orig.more_fields, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, more_fields ));
    buffer_pos += FSIZ( cai_orig_fix1_type, more_fields );

    b_packb( int_ptr->orig.num_fields, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, num_fields ));
    buffer_pos += FSIZ( cai_orig_fix1_type, num_fields );

    for (i=0; i < int_ptr->orig.num_fields; i++) {
      if (int_ptr->orig.digit_mode) {
        b_packb( int_ptr->orig.chari[i], buf_ptr, buffer_pos,
                 FSIZ( cai_orig_var_type, char8 ));
        buffer_pos += FSIZ( cai_orig_var_type, char8 );
      }
      else {
        b_packb( int_ptr->orig.chari[i], buf_ptr, buffer_pos,
                 FSIZ( cai_orig_var_type, char4 ));
        buffer_pos += FSIZ( cai_orig_var_type, char4 );
      }
    }

    b_packb( int_ptr->orig.nar_an_cap, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix2_type, nar_an_cap ));
    buffer_pos += FSIZ( cai_orig_fix2_type, nar_an_cap );

// Note: for special MDR, p_rev_in_use will be set to 4 to use the IS95B format.
    if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
    {
      b_packb( int_ptr->orig.paca_reorig, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix2_type, paca_reorig ));
      buffer_pos += FSIZ( cai_orig_fix2_type, paca_reorig );

      b_packb( int_ptr->orig.return_cause, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix2_type, return_cause ));
      buffer_pos += FSIZ( cai_orig_fix2_type, return_cause );

      b_packb( int_ptr->orig.more_records, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix2_type, more_records ));
      buffer_pos += FSIZ( cai_orig_fix2_type, more_records );

      if (
#ifdef FEATURE_IS2000_REL_A
           caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_A &&
#endif /* FEATURE_IS2000_REL_A */
           int_ptr->orig.ami.auth_mode != CAI_NO_AUTH)
      {
        /* -----------------------------------
        ** Pack authentication specific fields
        ** ----------------------------------- */
        b_packb( int_ptr->orig.encry_sup, buf_ptr, buffer_pos,
                 FSIZ( cai_orig_fix2_type, encry_sup ));
        buffer_pos += FSIZ( cai_orig_fix2_type, encry_sup );
      }

      b_packb( int_ptr->orig.paca_sup, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix2_type, paca_sup ));
      buffer_pos += FSIZ( cai_orig_fix2_type, paca_sup );

      b_packb( int_ptr->orig.num_alt_so, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix2_type, num_alt_so ));
      buffer_pos += FSIZ( cai_orig_fix2_type, num_alt_so );

      for( i=0; i<int_ptr->orig.num_alt_so && i<cai_ac_alt_so_max; i++ )
      {
        b_packw( int_ptr->orig.alt_so[i], buf_ptr, buffer_pos,
                 FSIZ( cai_alt_so_type, alt_so ));
        buffer_pos += FSIZ( cai_alt_so_type, alt_so );
      }

#define FTYPE cai_orig_fix_is2000_type
#define VTYPE cai_orig_var_is2000_type
      if ((caix_p_rev_in_use < CAIX_P_REV_IS2000)
          && !is_voip_1x_handoff
         )
      {
        #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
        if(cdma.entry_ptr->entry != MCC_CSFB)
        #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
        {
          (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                            buf_ptr,buffer_pos,&(int_ptr->orig.pilot_rpt));
          buffer_pos += ac_plt_rpt_len;
        }  /* if(cdma.entry_ptr->entry != MCC_CSFB) */
      }
      else
      {
        b_packb( int_ptr->orig.drs, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,drs));
        buffer_pos += FSIZ(FTYPE,drs);

        b_packb( int_ptr->orig.uzid_incl, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,uzid_incl));
        buffer_pos += FSIZ(FTYPE,uzid_incl);

        if( int_ptr->orig.uzid_incl )
        {
          b_packw( int_ptr->orig.uzid, buf_ptr, buffer_pos,
                   FSIZ(VTYPE,uzid));
          buffer_pos += FSIZ(VTYPE,uzid);
        }

        b_packb( int_ptr->orig.ch_ind, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,ch_ind));
        buffer_pos += FSIZ(FTYPE,ch_ind);

        b_packb( int_ptr->orig.sr_id, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,sr_id));
        buffer_pos += FSIZ(FTYPE,sr_id);
        b_packb( int_ptr->orig.otd_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,otd_supported));
        buffer_pos += FSIZ(FTYPE,otd_supported);

        b_packb( int_ptr->orig.qpch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,qpch_supported));
        buffer_pos += FSIZ(FTYPE,qpch_supported);

        b_packb( int_ptr->orig.enhanced_rc, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,enhanced_rc));
        buffer_pos += FSIZ(FTYPE,enhanced_rc);

        b_packb( int_ptr->orig.for_rc_pref, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,for_rc_pref));
        buffer_pos += FSIZ(FTYPE,for_rc_pref);

        b_packb( int_ptr->orig.rev_rc_pref, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,rev_rc_pref));
        buffer_pos += FSIZ(FTYPE,rev_rc_pref);

        b_packb( int_ptr->orig.fch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,fch_supported));
        buffer_pos += FSIZ(FTYPE,fch_supported);

        if ( int_ptr->orig.fch_supported )
        {
          b_packb( int_ptr->orig.fch_fields.fch_frame_size,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,fch_frame_size));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,fch_frame_size);

          b_packb( int_ptr->orig.fch_fields.for_fch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,for_fch_len));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,for_fch_len);

          if (int_ptr->orig.fch_fields.for_fch_len)
          {
            b_packw ( int_ptr->orig.fch_fields.for_fch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->orig.fch_fields.for_fch_len*
                       FSIZ(cai_fch_spec_fields_type,for_fch_rc_map)));
            buffer_pos += (int_ptr->orig.fch_fields.for_fch_len*
                           FSIZ(cai_fch_spec_fields_type,for_fch_rc_map));
          }

          b_packb( int_ptr->orig.fch_fields.rev_fch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,rev_fch_len));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,rev_fch_len);

          if (int_ptr->orig.fch_fields.rev_fch_len)
          {
            b_packw ( int_ptr->orig.fch_fields.rev_fch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->orig.fch_fields.rev_fch_len*
                       FSIZ(cai_fch_spec_fields_type,rev_fch_rc_map)));
            buffer_pos += (int_ptr->orig.fch_fields.rev_fch_len*
                           FSIZ(cai_fch_spec_fields_type,rev_fch_rc_map));
          }
        }

        b_packb( int_ptr->orig.dcch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,dcch_supported));
        buffer_pos += FSIZ(FTYPE,dcch_supported);

        if ( int_ptr->orig.dcch_supported )
        {
          b_packb( int_ptr->orig.dcch_fields.dcch_frame_size,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,dcch_frame_size));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,dcch_frame_size);

          b_packb( int_ptr->orig.dcch_fields.for_dcch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,for_dcch_len));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,for_dcch_len);

          if (int_ptr->orig.dcch_fields.for_dcch_len)
          {
            b_packw ( int_ptr->orig.dcch_fields.for_dcch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->orig.dcch_fields.for_dcch_len*
                       FSIZ(cai_dcch_spec_fields_type,for_dcch_rc_map)));
            buffer_pos += (int_ptr->orig.dcch_fields.for_dcch_len*
                           FSIZ(cai_dcch_spec_fields_type,for_dcch_rc_map));
          }

          b_packb( int_ptr->orig.dcch_fields.rev_dcch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,rev_dcch_len));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,rev_dcch_len);

          if (int_ptr->orig.dcch_fields.rev_dcch_len)
          {
            b_packb ( int_ptr->orig.dcch_fields.rev_dcch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->orig.dcch_fields.rev_dcch_len*
                       FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map)));
            buffer_pos += (int_ptr->orig.dcch_fields.rev_dcch_len*
                           FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map));
          }
        }

#ifndef FEATURE_IS2000_REL_A
        b_packb(0, buf_ptr, buffer_pos, FSIZ(FTYPE,reserved));
        buffer_pos += FSIZ(FTYPE,reserved);
        b_packb( int_ptr->orig.rev_fch_gating_req, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,rev_fch_gating_req));
        buffer_pos += FSIZ(FTYPE,rev_fch_gating_req);
#endif /* !FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A
        if (int_ptr->orig.geo_loc_incl &&
            (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A))
        {
          b_packb( 1, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,geo_loc_incl));
          buffer_pos += FSIZ(FTYPE,geo_loc_incl);

          b_packb( int_ptr->orig.geo_loc_type, buf_ptr, buffer_pos,
           FSIZ(FTYPE,geo_loc_type));
          buffer_pos += FSIZ(FTYPE, geo_loc_type);

        }
        else
        {
          b_packb( 0, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,geo_loc_incl));
          buffer_pos += FSIZ(FTYPE,geo_loc_incl);
        }

        b_packb( int_ptr->orig.rev_fch_gating_req, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,rev_fch_gating_req));
        buffer_pos += FSIZ(FTYPE,rev_fch_gating_req);

        /* Now starts the fields defined for P_REV 7 only */
        if ( caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
        {
          b_packb( int_ptr->orig.orig_reason, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,orig_reason));
          buffer_pos += FSIZ(FTYPE,orig_reason);

          b_packb( int_ptr->orig.orig_count, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,orig_count));
          buffer_pos += FSIZ(FTYPE,orig_count);

          b_packb( int_ptr->orig.sts_supported, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,sts_supported));
          buffer_pos += FSIZ(FTYPE,sts_supported);

          b_packb( int_ptr->orig.thx_cch_supported, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,thx_cch_supported));
          buffer_pos += FSIZ(FTYPE,thx_cch_supported);

          b_packb( int_ptr->orig.wll_incl, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,wll_incl));
          buffer_pos += FSIZ(FTYPE,wll_incl);

          if (int_ptr->orig.wll_incl)
          {
            b_packb( int_ptr->orig.wll_device_type, buf_ptr, buffer_pos,
                     FSIZ(FTYPE,wll_device_type));
            buffer_pos += FSIZ(FTYPE,wll_device_type);

          }

          b_packb( int_ptr->orig.global_emergency_call, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,global_emergency_call));
          buffer_pos += FSIZ(FTYPE,global_emergency_call);

          if (int_ptr->orig.global_emergency_call)
          {
            b_packb( int_ptr->orig.ms_init_pos_loc_ind, buf_ptr, buffer_pos,
                     FSIZ(FTYPE,ms_init_pos_loc_ind));
            buffer_pos += FSIZ(FTYPE,ms_init_pos_loc_ind);
          }

          b_packb( int_ptr->orig.qos_parms_incl, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,qos_parms_incl));
          buffer_pos += FSIZ(FTYPE,qos_parms_incl);

          if (int_ptr->orig.qos_parms_incl)
          {
            b_packb( int_ptr->orig.qos_parms_len, buf_ptr, buffer_pos,
                     FSIZ(FTYPE,qos_parms_len));
            buffer_pos += FSIZ(FTYPE,qos_parms_len);

            for (i=0; i<int_ptr->orig.qos_parms_len; i++)
            {
              b_packb( int_ptr->orig.qos_parms[i], buf_ptr, buffer_pos,
                       FSIZ(FTYPE,qos_parms));
              buffer_pos += FSIZ(FTYPE,qos_parms);
            }

            // The standard specifies a reserved field here. We don't need
            // to pack it because of the following:
            // The qos_parms_len above is in units of 'bytes' and so
            // qos_parms field is guaranteed to be of length an integer number
            // of octets.
          }

          b_packb( int_ptr->orig.enc_info_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, enc_info_incl ));
          buffer_pos += FSIZ( FTYPE, enc_info_incl );

          if (int_ptr->orig.enc_info_incl)
          {
            b_packb( int_ptr->orig.sig_encrypt_sup, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, sig_encrypt_sup ));
            buffer_pos += FSIZ( FTYPE, sig_encrypt_sup );

            b_packb( int_ptr->orig.d_sig_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, d_sig_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, d_sig_encrypt_req );

            b_packb( int_ptr->orig.c_sig_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, c_sig_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, c_sig_encrypt_req );

            if (((int_ptr->orig.sig_encrypt_sup & CAI_ENC_SUP_ECMEA) != 0)||
                ((int_ptr->orig.sig_encrypt_sup & CAI_ENC_SUP_REA) != 0)
               )
            {
              b_packd( int_ptr->orig.enc_seq_h, buf_ptr, buffer_pos,
                       FSIZ( FTYPE, enc_seq_h ));
              buffer_pos += FSIZ( FTYPE, enc_seq_h );

              b_packb( int_ptr->orig.enc_seq_h_sig, buf_ptr, buffer_pos,
                       FSIZ( FTYPE, enc_seq_h_sig ));
              buffer_pos += FSIZ( FTYPE, enc_seq_h_sig );
            }

            b_packb( int_ptr->orig.ui_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, ui_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, ui_encrypt_req );

            b_packb( int_ptr->orig.ui_encrypt_sup, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, ui_encrypt_sup ));
            buffer_pos += FSIZ( FTYPE, ui_encrypt_sup );
          }

          b_packb( int_ptr->orig.sync_id_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, sync_id_incl ));
          buffer_pos += FSIZ( FTYPE, sync_id_incl );

          if (int_ptr->orig.sync_id_incl)
          {
            b_packb( int_ptr->orig.sync_id_len, buf_ptr, buffer_pos,
                    FSIZ( FTYPE, sync_id_len ));
             buffer_pos += FSIZ( FTYPE, sync_id_len );

            for (i=0; i<int_ptr->orig.sync_id_len; i++)
            {
              b_packb( int_ptr->orig.sync_id[i],
                       buf_ptr, buffer_pos,
                       FSIZ( FTYPE, sync_id ));

              buffer_pos += FSIZ( FTYPE, sync_id );
            }
          }

          b_packb( int_ptr->orig.prev_sid_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, prev_sid_incl ));
          buffer_pos += FSIZ( FTYPE, prev_sid_incl );

          if (int_ptr->orig.prev_sid_incl)
          {
            b_packw( int_ptr->orig.prev_sid, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, prev_sid ));
            buffer_pos += FSIZ( FTYPE, prev_sid );

          }

          b_packb( int_ptr->orig.prev_nid_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, prev_nid_incl ));
          buffer_pos += FSIZ( FTYPE, prev_nid_incl );

          if (int_ptr->orig.prev_nid_incl)
          {
            b_packw( int_ptr->orig.prev_nid, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, prev_nid ));
            buffer_pos += FSIZ( FTYPE, prev_nid );

          }

          b_packb( int_ptr->orig.prev_pzid_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, prev_pzid_incl ));
          buffer_pos += FSIZ( FTYPE, prev_pzid_incl );

          if (int_ptr->orig.prev_pzid_incl)
          {
            b_packb( int_ptr->orig.prev_pzid, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, prev_pzid ));
            buffer_pos += FSIZ( FTYPE, prev_pzid );

          }

          b_packb( int_ptr->orig.so_bitmap_ind, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, so_bitmap_ind ));
          buffer_pos += FSIZ( FTYPE, so_bitmap_ind );

          if (int_ptr->orig.so_bitmap_ind != SO_BITMAP_SIZE_0)
          {
            b_packb( int_ptr->orig.so_group_num, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, so_group_num ));
            buffer_pos += FSIZ( FTYPE, so_group_num );

            b_packw( int_ptr->orig.so_bitmap, buf_ptr, buffer_pos,
                     (1 << (int_ptr->orig.so_bitmap_ind + 1)));
            buffer_pos += (1 << (int_ptr->orig.so_bitmap_ind + 1));

          }

#ifdef FEATURE_IS2000_REL_B
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
          {
            b_packb( int_ptr->orig.sdb_desired_only, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, sdb_desired_only ));
            buffer_pos += FSIZ( FTYPE, sdb_desired_only);

            b_packb( int_ptr->orig.alt_band_class_sup , buf_ptr, buffer_pos,
                     FSIZ( FTYPE, alt_band_class_sup  ));
            buffer_pos += FSIZ( FTYPE, alt_band_class_sup);

#ifdef FEATURE_IS2000_REL_C
            if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
            {
              b_packb( int_ptr->orig.msg_int_info_incl, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, msg_int_info_incl ));
              buffer_pos += FSIZ( FTYPE, msg_int_info_incl);

              if (int_ptr->orig.msg_int_info_incl)
              {
                b_packb( int_ptr->orig.sig_integrity_sup_incl, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, sig_integrity_sup_incl ));
                buffer_pos += FSIZ( FTYPE, sig_integrity_sup_incl);

                if (int_ptr->orig.sig_integrity_sup_incl)
                {
                  b_packb( int_ptr->orig.sig_integrity_sup, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, sig_integrity_sup ));
                  buffer_pos += FSIZ( FTYPE, sig_integrity_sup);

                  b_packb( int_ptr->orig.sig_integrity_req, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, sig_integrity_req ));
                  buffer_pos += FSIZ( FTYPE, sig_integrity_req);
                }
                b_packb( int_ptr->orig.new_key_id, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, new_key_id ));
                buffer_pos += FSIZ( FTYPE, new_key_id);

                b_packb( int_ptr->orig.new_sseq_h_incl, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, new_sseq_h_incl ));
                buffer_pos += FSIZ( FTYPE, new_sseq_h_incl);

                if (int_ptr->orig.new_sseq_h_incl)
                {
                  b_packd( int_ptr->orig.new_sseq_h, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, new_sseq_h ));
                  buffer_pos += FSIZ( FTYPE, new_sseq_h);

                  b_packb( int_ptr->orig.new_sseq_h_sig, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, new_sseq_h_sig ));
                  buffer_pos += FSIZ( FTYPE, new_sseq_h_sig);
                }
              }

              b_packb( int_ptr->orig.for_pdch_supported, buf_ptr, buffer_pos,
                         FSIZ( FTYPE,for_pdch_supported ));
              buffer_pos += FSIZ( FTYPE, for_pdch_supported);

              if (int_ptr->orig.for_pdch_supported)
              {
                b_packb( int_ptr->orig.for_pdch_fields.ack_delay, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ack_delay ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, ack_delay);

                b_packb( int_ptr->orig.for_pdch_fields.num_arq_chan, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, num_arq_chan ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, num_arq_chan);

                b_packb( int_ptr->orig.for_pdch_fields.for_pdch_len, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, for_pdch_len ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, for_pdch_len);

                b_packw( int_ptr->orig.for_pdch_fields.for_pdch_rc_map, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, for_pdch_rc_map )*
                         (int_ptr->orig.for_pdch_fields.for_pdch_len+1));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type,
                              for_pdch_rc_map) * (int_ptr->orig.for_pdch_fields.for_pdch_len+1);

                b_packb( int_ptr->orig.for_pdch_fields.ch_config_sup_map_len, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map_len ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map_len);

                b_packw( int_ptr->orig.for_pdch_fields.ch_config_sup_map, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map )*
                         (int_ptr->orig.for_pdch_fields.ch_config_sup_map_len+1));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type,
                              ch_config_sup_map) * (int_ptr->orig.for_pdch_fields.ch_config_sup_map_len+1);
              }

              if (int_ptr->orig.ch_ind == 0)
              {
                b_packb( int_ptr->orig.ext_ch_ind, buf_ptr, buffer_pos,
                         FSIZ( FTYPE,ext_ch_ind ));
                buffer_pos += FSIZ( FTYPE, ext_ch_ind);
              }
            }
#endif /* FEATURE_IS2000_REL_C */
          }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_MODEM_1X_IRAT_LTO1X
          if(cdma.entry_ptr->entry != MCC_CSFB)
#endif  /* FEATURE_MODEM_1X_IRAT_LTO1X */
          {
            #ifdef FEATURE_IS2000_REL_A_AES
            if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
            {
              buffer_pos = mccaes_calculate_new_buf_length(int_ptr->orig.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
            }
            else
            {
              auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                                    int_ptr->orig.enc.sdu_encrypt_mode,
                                    int_ptr->orig.hdr.ack_req
                                   );

            }
            #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
            if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
            {
               /* ----------------------------
                ** Pack the MACI field
                ** ---------------------------- */
               if (int_ptr->orig.ami.maci_incl)
               {
                  xlate_int_maci(&buffer_pos,
                                 buf_ptr,
                                 CAI_AC_CRC_SIZE,
                                 int_ptr->orig.hdr.ack_req,
                                 chn,
                                 int_ptr->orig.ami.sdu_key_id,
                                 int_ptr->orig.msg_type,
                                 int_ptr->orig.ami.sdu_integrity_algo,
                                 &int_ptr->orig.ami.maci
                                );
               } /* maci_incl */
            } /* p_rev >= P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
          } /* if(cdma.entry_ptr->entry != MCC_CSFB) */
        } /* If p_rev_in_use > = 7 */
#endif /* FEATURE_IS2000_REL_A */

      } /* p_rev_in_use > = 6 */

#undef VTYPE
#undef FTYPE

    } /* p_rev_in_use > = 5 */

    /* ------------------------------
    ** Calculate total message length
    ** ------------------------------ */
    *len_ptr = buffer_pos;

    #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
    if(cdma.entry_ptr->entry == MCC_CSFB)
    {
      return status;
    }
    #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */

    if (*len_ptr > CAI_AC_BODY_SIZE)
    {
      status = CAIX_INV_LEN_S;
    }
  }

  return (status);

} /* xlate_int_orig */

/*===========================================================================

FUNCTION XLATE_INT_PAGE_RESP

DESCRIPTION
  This function translates a Page Response Message from internal to
  external format.

DEPENDENCIES
  p_rev_in_use in the internal format is required.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_page_resp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos = 0;
    /* Position in buffer to pack bits */
  int i;
    /* Loop variable */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start point of L3 SDU */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  if(cdma.entry_ptr->entry != MCC_CSFB)
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
  {
    /* ----------------------------------------------------
    ** Pack Page Response Message up through the MSID field
    ** ---------------------------------------------------- */
    status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );
  } /* if(cdma.entry_ptr->entry != MCC_CSFB) */

  if (status == CAIX_DONE_S)
  {
    #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
    if(cdma.entry_ptr->entry != MCC_CSFB)
    {
    #endif /*FEATURE_MODEM_1X_IRAT_LTO1X */
      /* ----------------------------
      ** Pack the rest of the message
      ** ---------------------------- */

      /* -------------------------------------------------------
      ** Pack authentication fields and message integrity fields
      ** ------------------------------------------------------- */
      xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->page_resp.msg_type,
        &int_ptr->page_resp.hdr, &int_ptr->page_resp.ami);

#ifdef FEATURE_IS2000_REL_A
      /* -------------------------------
      ** Pack Extended Encryption fields
      ** ------------------------------- */
      xlate_int_ac_enc(&buffer_pos, buf_ptr,
                       &int_ptr->page_resp.enc,
                       &int_ptr->page_resp.ami
                      );

#endif /* FEATURE_IS2000_REL_A */

      if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
      {
        ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
        ac_l2_num_bytes = (ac_l2_num_bits/8);
        ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
        if (ac_l2_num_reserved != 8)
        {
          ac_l2_num_bytes += 1;
          b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
          buffer_pos += ac_l2_num_reserved;
        }
        b_packb ((byte) ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);

      }

      /* -----------------------------------------------
      ** Add RER fields for P_REV 6 & 7
      **------------------------------------------------ */

      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
      {
        (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,&(int_ptr->page_resp.pilot_rpt));
        buffer_pos += ac_plt_rpt_len;
      }

#ifdef FEATURE_IS2000_REL_A_AES
      /* ---------------------------------------
      ** L3 SDU Fields
      **---------------------------------------- */
      sdu_start_pos = buffer_pos;
#endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_MODEM_1X_IRAT_LTO1X
    } /* if(cdma.entry_ptr->entry != MCC_CSFB) */
#endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
    b_packb( int_ptr->page_resp.mob_term, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, mob_term ));
    buffer_pos += FSIZ( cai_page_resp_type, mob_term );

    b_packb( int_ptr->page_resp.slot_cycle_index, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, slot_cycle_index ));
    buffer_pos += FSIZ( cai_page_resp_type, slot_cycle_index );

    b_packb( int_ptr->page_resp.mob_p_rev, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, mob_p_rev ));
    buffer_pos += FSIZ( cai_page_resp_type, mob_p_rev );

    b_packb( int_ptr->page_resp.scm, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, scm ));
    buffer_pos += FSIZ( cai_page_resp_type, scm );

    b_packb( int_ptr->page_resp.request_mode, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, request_mode ));
    buffer_pos += FSIZ( cai_page_resp_type, request_mode );

    b_packw( int_ptr->page_resp.service_option, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, service_option ));
    buffer_pos += FSIZ( cai_page_resp_type, service_option );

    b_packb( int_ptr->page_resp.pm, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, pm ));
    buffer_pos += FSIZ( cai_page_resp_type, pm );

    b_packb( int_ptr->page_resp.nar_an_cap, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, nar_an_cap ));
    buffer_pos += FSIZ( cai_page_resp_type, nar_an_cap );

// Note: for special MDR, p_rev_in_use will be set to 4 to use the IS95B format.
    /* ------------------------------------------------
    ** The following is for IS-95B only
    ** ------------------------------------------------ */
    if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
    {
      if (
#ifdef FEATURE_IS2000_REL_A
          caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_A &&
#endif /* FEATURE_IS2000_REL_A */
          int_ptr->page_resp.ami.auth_mode != CAI_NO_AUTH)
      {
        /* -----------------------------------
        ** Pack authentication specific fields
        ** ----------------------------------- */
        b_packb( int_ptr->page_resp.encry_sup, buf_ptr, buffer_pos,
                 FSIZ( cai_page_resp_type, encry_sup ));
        buffer_pos += FSIZ( cai_page_resp_type, encry_sup );
      }

      b_packb( int_ptr->page_resp.num_alt_so, buf_ptr, buffer_pos,
               FSIZ( cai_page_resp_type, num_alt_so ));
      buffer_pos += FSIZ( cai_page_resp_type, num_alt_so );

      for( i=0; i<int_ptr->page_resp.num_alt_so && i<cai_ac_alt_so_max ; i++ )
      {
        b_packw( int_ptr->page_resp.alt_so[i], buf_ptr, buffer_pos,
                 FSIZ( cai_alt_so_type, alt_so ));
        buffer_pos += FSIZ( cai_alt_so_type, alt_so );
      }
#define FTYPE cai_page_resp_fix_is2000_type
#define VTYPE cai_page_resp_var_is2000_type
      if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
      {
        #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
        if(cdma.entry_ptr->entry != MCC_CSFB)
        #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
        {
          (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,&(int_ptr->page_resp.pilot_rpt));
          buffer_pos += ac_plt_rpt_len;
        } /* if(cdma.entry_ptr->entry != MCC_CSFB) */
      }
      else
      {
        b_packb( int_ptr->page_resp.uzid_incl, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,uzid_incl));
        buffer_pos += FSIZ(FTYPE,uzid_incl);

        if( int_ptr->page_resp.uzid_incl )
        {
          b_packw( int_ptr->page_resp.uzid, buf_ptr, buffer_pos,
                   FSIZ(VTYPE,uzid));
          buffer_pos += FSIZ(VTYPE,uzid);
        }

        b_packb( int_ptr->page_resp.ch_ind, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,ch_ind));
        buffer_pos += FSIZ(FTYPE,ch_ind);

        b_packb( int_ptr->page_resp.otd_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,otd_supported));
        buffer_pos += FSIZ(FTYPE,otd_supported);

        b_packb( int_ptr->page_resp.qpch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,qpch_supported));
        buffer_pos += FSIZ(FTYPE,qpch_supported);

        b_packb( int_ptr->page_resp.enhanced_rc, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,enhanced_rc));
        buffer_pos += FSIZ(FTYPE,enhanced_rc);

        b_packb( int_ptr->page_resp.for_rc_pref, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,for_rc_pref));
        buffer_pos += FSIZ(FTYPE,for_rc_pref);

        b_packb( int_ptr->page_resp.rev_rc_pref, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,rev_rc_pref));
        buffer_pos += FSIZ(FTYPE,rev_rc_pref);

        b_packb( int_ptr->page_resp.fch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,fch_supported));
        buffer_pos += FSIZ(FTYPE,fch_supported);

        if ( int_ptr->page_resp.fch_supported )
        {
          b_packb( int_ptr->page_resp.fch_fields.fch_frame_size,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,fch_frame_size));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,fch_frame_size);

          b_packb( int_ptr->page_resp.fch_fields.for_fch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,for_fch_len));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,for_fch_len);

          if (int_ptr->page_resp.fch_fields.for_fch_len)
          {
            b_packw ( int_ptr->page_resp.fch_fields.for_fch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->page_resp.fch_fields.for_fch_len*
                       FSIZ(cai_fch_spec_fields_type,for_fch_rc_map)));
            buffer_pos += (int_ptr->page_resp.fch_fields.for_fch_len*
                           FSIZ(cai_fch_spec_fields_type,for_fch_rc_map));
          }

          b_packb( int_ptr->page_resp.fch_fields.rev_fch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,rev_fch_len));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,rev_fch_len);

          if (int_ptr->page_resp.fch_fields.rev_fch_len)
          {
            b_packw ( int_ptr->page_resp.fch_fields.rev_fch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->page_resp.fch_fields.rev_fch_len*
                       FSIZ(cai_fch_spec_fields_type,rev_fch_rc_map)));
            buffer_pos += (int_ptr->page_resp.fch_fields.rev_fch_len*
                           FSIZ(cai_fch_spec_fields_type,rev_fch_rc_map));
          }
        }

        b_packb( int_ptr->page_resp.dcch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,dcch_supported));
        buffer_pos += FSIZ(FTYPE,dcch_supported);

        if ( int_ptr->page_resp.dcch_supported )
        {
          b_packb( int_ptr->page_resp.dcch_fields.dcch_frame_size,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,dcch_frame_size));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,dcch_frame_size);

          b_packb( int_ptr->page_resp.dcch_fields.for_dcch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,for_dcch_len));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,for_dcch_len);

          if (int_ptr->page_resp.dcch_fields.for_dcch_len)
          {
            b_packw ( int_ptr->page_resp.dcch_fields.for_dcch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->page_resp.dcch_fields.for_dcch_len*
                       FSIZ(cai_dcch_spec_fields_type,for_dcch_rc_map)));
            buffer_pos += (int_ptr->page_resp.dcch_fields.for_dcch_len*
                           FSIZ(cai_dcch_spec_fields_type,for_dcch_rc_map));
          }

          b_packb( int_ptr->page_resp.dcch_fields.rev_dcch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,rev_dcch_len));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,rev_dcch_len);

          if (int_ptr->page_resp.dcch_fields.rev_dcch_len)
          {
            b_packb ( int_ptr->page_resp.dcch_fields.rev_dcch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->page_resp.dcch_fields.rev_dcch_len*
                       FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map)));
            buffer_pos += (int_ptr->page_resp.dcch_fields.rev_dcch_len*
                           FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map));
          }
        }

        b_packb( int_ptr->page_resp.rev_fch_gating_req, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,rev_fch_gating_req));
        buffer_pos += FSIZ(FTYPE,rev_fch_gating_req);

#ifdef FEATURE_IS2000_REL_A
        /* Now starts the fields defined for P_REV 7 only */
        if ( caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
        {
          b_packb( int_ptr->page_resp.sts_supported, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,sts_supported));
          buffer_pos += FSIZ(FTYPE,sts_supported);

          b_packb( int_ptr->page_resp.thx_cch_supported, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,thx_cch_supported));
          buffer_pos += FSIZ(FTYPE,thx_cch_supported);

          b_packb( int_ptr->page_resp.wll_incl, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,wll_incl));
          buffer_pos += FSIZ(FTYPE,wll_incl);

          if (int_ptr->page_resp.wll_incl)
          {
            b_packb( int_ptr->page_resp.wll_device_type, buf_ptr, buffer_pos,
                     FSIZ(FTYPE,wll_device_type));
            buffer_pos += FSIZ(FTYPE,wll_device_type);

            b_packb( int_ptr->page_resp.hook_status, buf_ptr, buffer_pos,
                     FSIZ(FTYPE,hook_status));
            buffer_pos += FSIZ(FTYPE,hook_status);
          }

          b_packb( int_ptr->page_resp.enc_info_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, enc_info_incl ));
          buffer_pos += FSIZ( FTYPE, enc_info_incl );

          if (int_ptr->page_resp.enc_info_incl)
          {
            b_packb( int_ptr->page_resp.sig_encrypt_sup, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, sig_encrypt_sup ));
            buffer_pos += FSIZ( FTYPE, sig_encrypt_sup );

            b_packb( int_ptr->page_resp.d_sig_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, d_sig_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, d_sig_encrypt_req );

            b_packb( int_ptr->page_resp.c_sig_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, c_sig_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, c_sig_encrypt_req );

            if(((int_ptr->page_resp.sig_encrypt_sup & CAI_ENC_SUP_ECMEA) != 0)||
                ((int_ptr->page_resp.sig_encrypt_sup & CAI_ENC_SUP_REA) != 0)
              )
            {
              b_packd( int_ptr->page_resp.enc_seq_h, buf_ptr, buffer_pos,
                       FSIZ( FTYPE, enc_seq_h ));
              buffer_pos += FSIZ( FTYPE, enc_seq_h );

              b_packb( int_ptr->page_resp.enc_seq_h_sig, buf_ptr, buffer_pos,
                       FSIZ( FTYPE, enc_seq_h_sig ));
              buffer_pos += FSIZ( FTYPE, enc_seq_h_sig );
            }

            b_packb( int_ptr->page_resp.ui_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, ui_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, ui_encrypt_req );

            b_packb( int_ptr->page_resp.ui_encrypt_sup, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, ui_encrypt_sup ));
            buffer_pos += FSIZ( FTYPE, ui_encrypt_sup );
          }

          b_packb( int_ptr->page_resp.sync_id_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, sync_id_incl ));
          buffer_pos += FSIZ( FTYPE, sync_id_incl );

          if (int_ptr->page_resp.sync_id_incl)
          {
            b_packb( int_ptr->page_resp.sync_id_len, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, sync_id_len ));
            buffer_pos += FSIZ( FTYPE, sync_id_len );

            for (i=0; i<int_ptr->page_resp.sync_id_len; i++)
            {
              b_packb( int_ptr->page_resp.sync_id[i], buf_ptr, buffer_pos,
                       FSIZ( FTYPE, sync_id ));
              buffer_pos += FSIZ( FTYPE, sync_id );
            }
          }

          b_packb( int_ptr->page_resp.so_bitmap_ind, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, so_bitmap_ind ));
          buffer_pos += FSIZ( FTYPE, so_bitmap_ind );

          if (int_ptr->page_resp.so_bitmap_ind != SO_BITMAP_SIZE_0)
          {
            b_packb( int_ptr->page_resp.so_group_num, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, so_group_num ));
            buffer_pos += FSIZ( FTYPE, so_group_num );

            b_packw( int_ptr->page_resp.so_bitmap, buf_ptr, buffer_pos,
                     (1 << (int_ptr->page_resp.so_bitmap_ind + 1)));
            buffer_pos += (1 << (int_ptr->page_resp.so_bitmap_ind + 1));

          }
#ifdef FEATURE_IS2000_REL_B
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
          {
            b_packb( int_ptr->page_resp.alt_band_class_sup , buf_ptr, buffer_pos,
                     FSIZ( FTYPE, alt_band_class_sup  ));
            buffer_pos += FSIZ( FTYPE, alt_band_class_sup);

#ifdef FEATURE_IS2000_REL_C
            if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
            {
              b_packb( int_ptr->page_resp.msg_int_info_incl, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, msg_int_info_incl ));
              buffer_pos += FSIZ( FTYPE, msg_int_info_incl);

              if (int_ptr->page_resp.msg_int_info_incl)
              {
                b_packb( int_ptr->page_resp.sig_integrity_sup_incl, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, sig_integrity_sup_incl ));
                buffer_pos += FSIZ( FTYPE, sig_integrity_sup_incl);

                if (int_ptr->page_resp.sig_integrity_sup_incl)
                {
                  b_packb( int_ptr->page_resp.sig_integrity_sup, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, sig_integrity_sup ));
                  buffer_pos += FSIZ( FTYPE, sig_integrity_sup);

                  b_packb( int_ptr->page_resp.sig_integrity_req, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, sig_integrity_req ));
                  buffer_pos += FSIZ( FTYPE, sig_integrity_req);
                }
                b_packb( int_ptr->page_resp.new_key_id, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, new_key_id ));
                buffer_pos += FSIZ( FTYPE, new_key_id);

                b_packb( int_ptr->page_resp.new_sseq_h_incl, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, new_sseq_h_incl ));
                buffer_pos += FSIZ( FTYPE, new_sseq_h_incl);

                if (int_ptr->page_resp.new_sseq_h_incl)
                {
                  b_packd( int_ptr->page_resp.new_sseq_h, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, new_sseq_h ));
                  buffer_pos += FSIZ( FTYPE, new_sseq_h);

                  b_packb( int_ptr->page_resp.new_sseq_h_sig, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, new_sseq_h_sig ));
                  buffer_pos += FSIZ( FTYPE, new_sseq_h_sig);
                }
              }

              b_packb( int_ptr->page_resp.for_pdch_supported, buf_ptr, buffer_pos,
                         FSIZ( FTYPE,for_pdch_supported ));
              buffer_pos += FSIZ( FTYPE, for_pdch_supported);

              if (int_ptr->page_resp.for_pdch_supported)
              {
                b_packb( int_ptr->page_resp.for_pdch_fields.ack_delay, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ack_delay ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, ack_delay);

                b_packb( int_ptr->page_resp.for_pdch_fields.num_arq_chan, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, num_arq_chan ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, num_arq_chan);

                b_packb( int_ptr->page_resp.for_pdch_fields.for_pdch_len, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, for_pdch_len ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, for_pdch_len);

                b_packw( int_ptr->page_resp.for_pdch_fields.for_pdch_rc_map, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, for_pdch_rc_map )*
                         (int_ptr->page_resp.for_pdch_fields.for_pdch_len+1));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type,
                              for_pdch_rc_map) * (int_ptr->page_resp.for_pdch_fields.for_pdch_len+1);

                b_packb( int_ptr->page_resp.for_pdch_fields.ch_config_sup_map_len, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map_len ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map_len);

                b_packw( int_ptr->page_resp.for_pdch_fields.ch_config_sup_map, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map )*
                         (int_ptr->page_resp.for_pdch_fields.ch_config_sup_map_len+1));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type,
                              ch_config_sup_map) * (int_ptr->page_resp.for_pdch_fields.ch_config_sup_map_len+1);
              }

              if (int_ptr->page_resp.ch_ind == 0)
              {
                b_packb( int_ptr->page_resp.ext_ch_ind, buf_ptr, buffer_pos,
                         FSIZ( FTYPE,ext_ch_ind ));
                buffer_pos += FSIZ( FTYPE, ext_ch_ind);
              }
            }
#endif /* FEATURE_IS2000_REL_C */

          }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_MODEM_1X_IRAT_LTO1X
          if(cdma.entry_ptr->entry != MCC_CSFB)
#endif  /* FEATURE_MODEM_1X_IRAT_LTO1X */
          {
            #ifdef FEATURE_IS2000_REL_A_AES
            if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
            {
              buffer_pos = mccaes_calculate_new_buf_length(int_ptr->page_resp.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
            }
            else
            {
              auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                                    int_ptr->page_resp.enc.sdu_encrypt_mode,
                                    int_ptr->page_resp.hdr.ack_req
                                   );
            }
            #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
            if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
            {
              if (int_ptr->page_resp.ami.maci_incl)
              {
                xlate_int_maci(&buffer_pos,
                               buf_ptr,
                               CAI_AC_CRC_SIZE,
                               int_ptr->page_resp.hdr.ack_req,
                               chn,
                               int_ptr->page_resp.ami.sdu_key_id,
                               int_ptr->page_resp.msg_type,
                               int_ptr->page_resp.ami.sdu_integrity_algo,
                               &int_ptr->page_resp.ami.maci
                              );
              } /* maci_incl */
            } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
          } /* if(cdma.entry_ptr->entry != MCC_CSFB) */
        } /* p_rev_in_use >= 7 */
#endif /* FEATURE_IS2000_REL_A */

      } /* p_rev_in_use > = 6 */

#undef VTYPE
#undef FTYPE

    } /* p_rev_in_use >=5 */
  } /* if status is DONE */

  *len_ptr = buffer_pos;

  return (status);

} /* xlate_int_page_resp */

/*===========================================================================

FUNCTION XLATE_INT_AUTH_CH

DESCRIPTION
  This function translates an Authentication Challenge Response Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_auth_ch
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos = 0;
    /* Position in buffer to pack bits */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos = 0;
    /* Start position of L3 SDU */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
  if(cdma.entry_ptr->entry != MCC_CSFB)
  #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
  {
    /* --------------------------------------------------------------------
    ** Pack Authentication Challenge Response Msg up through the MSID field
    ** -------------------------------------------------------------------- */
    status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );
  }

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
    if(cdma.entry_ptr->entry != MCC_CSFB)
    #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
    {
      /* -------------------------------------------------------
      ** Pack authentication fields and message integrity fields
      ** ------------------------------------------------------- */
      xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->auth_ch.msg_type,
        &int_ptr->auth_ch.hdr, &int_ptr->auth_ch.ami);

#ifdef FEATURE_IS2000_REL_A
      /* -------------------------------
      ** Pack Extended Encryption fields
      ** ------------------------------- */
      xlate_int_ac_enc(&buffer_pos, buf_ptr,
                       &int_ptr->auth_ch.enc,
                       &int_ptr->auth_ch.ami
                      );

#endif /* FEATURE_IS2000_REL_A */

      if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
      {
        ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
        ac_l2_num_bytes = (ac_l2_num_bits/8);
        ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
        if (ac_l2_num_reserved != 8)
        {
          ac_l2_num_bytes += 1;
          b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
          buffer_pos += ac_l2_num_reserved;
        }
        b_packb ((byte) ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
      }

      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
      {
        /* -----------------------------
        ** Add RER fields for P_REV >= 6
        **------------------------------ */
        (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,
                          &(int_ptr->auth_ch.pilot_rpt));
        buffer_pos += ac_plt_rpt_len;
      }
    }
#ifdef FEATURE_IS2000_REL_A_AES
    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    sdu_start_pos = buffer_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packd( int_ptr->auth_ch.authu, buf_ptr, buffer_pos,
             FSIZ( cai_auth_ch_resp_type, authu ));
    buffer_pos += FSIZ( cai_auth_ch_resp_type, authu );

    #ifdef FEATURE_MODEM_1X_IRAT_LTO1X
    if(cdma.entry_ptr->entry != MCC_CSFB)
    #endif /* FEATURE_MODEM_1X_IRAT_LTO1X */
    {
      if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
      {
        if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
        {
          (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                            buf_ptr,buffer_pos,&(int_ptr->auth_ch.pilot_rpt));
          buffer_pos += ac_plt_rpt_len;
        }
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        #ifdef FEATURE_IS2000_REL_A_AES
        if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
        {
          buffer_pos = mccaes_calculate_new_buf_length(int_ptr->auth_ch.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
        }
        else
        {
          auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                                int_ptr->auth_ch.enc.sdu_encrypt_mode,
                                int_ptr->auth_ch.hdr.ack_req
                               );
        }
        #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
        {
          /* ----------------------------
          ** Pack the MACI field
          ** ---------------------------- */
          if (int_ptr->auth_ch.ami.maci_incl)
          {
            xlate_int_maci(&buffer_pos,
                           buf_ptr,
                           CAI_AC_CRC_SIZE,
                           int_ptr->auth_ch.hdr.ack_req,
                           chn,
                           int_ptr->auth_ch.ami.sdu_key_id,
                           int_ptr->auth_ch.msg_type,
                           int_ptr->auth_ch.ami.sdu_integrity_algo,
                           &int_ptr->auth_ch.ami.maci
                          );
          } /* maci_incl */
        } /* p_rev > CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
      }  /* p_rev >= 7 */
    }
#endif /* FEATURE_IS2000_REL_A */
  } /* status = CAIX_DONE */

  *len_ptr = buffer_pos;

  return (status);

} /* xlate_int_auth_ch */

/*===========================================================================

FUNCTION XLATE_INT_AC_STRSP

DESCRIPTION
  This function translates an Access Channel Status Response Message from
  internal to external format. This message is only for pre-IS95B.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_strsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */
  caix_l2_fields_pack_type l2_fields_pack_ind
    /* Indicates if L2 fields are to be packed */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack bits in message */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( l2_fields_pack_ind == CAIX_L2_FIELDS_PACK )
  {
    /* ------------------------------------------------------
    ** Pack Status Response Message up through the MSID field
    ** ------------------------------------------------------ */
    status = xlate_int_ac_hdr( &msg_pos, buf_ptr, int_ptr );

    if ( status != CAIX_DONE_S )
    {
      return ( status ); /* Header translation failed */
    }

    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, auth_mode ) );
    msg_pos += FSIZ( cai_ac_strsp_fix_type, auth_mode );

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = msg_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,msg_pos,ac_l2_num_reserved);
        msg_pos += ac_l2_num_reserved;
      }
      b_packb ((byte) ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }
  }

  b_packb( int_ptr->ac_strsp.qual,
           buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, qual_typ ) );
  msg_pos += FSIZ( cai_ac_strsp_fix_type, qual_typ );

  if ( int_ptr->ac_strsp.qual == CAI_NO_QUAL ) /* No qual info */
  {
    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, qual_len ) );
    msg_pos += FSIZ( cai_ac_strsp_fix_type, qual_len );
  }
  else if ( int_ptr->ac_strsp.qual == CAI_BAND_QUAL ) /* Band qual info */
  {
    b_packb( sizeof(cai_qual_info1_type) / 8,
             buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, qual_len ) );
    msg_pos += FSIZ( cai_ac_strsp_fix_type, qual_len );

    b_packb( int_ptr->ac_strsp.band,
             buf_ptr, msg_pos, FSIZ( cai_qual_info1_type, band ) );
    msg_pos += FSIZ( cai_qual_info1_type, band );

    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_qual_info1_type, reserved ) );
    msg_pos += FSIZ( cai_qual_info1_type, reserved );
  }
  else if ( int_ptr->ac_strsp.qual == CAI_BAND_OP_MODE_QUAL )
  {
    b_packb( sizeof(cai_qual_info2_type) / 8,
             buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, qual_len ) );
    msg_pos += FSIZ( cai_ac_strsp_fix_type, qual_len );

    b_packb( int_ptr->ac_strsp.band,
             buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, band ) );
    msg_pos += FSIZ( cai_qual_info2_type, band );

    b_packb( int_ptr->ac_strsp.op_mode,
             buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, op_mode ) );
    msg_pos += FSIZ( cai_qual_info2_type, op_mode );

    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, reserved ) );
    msg_pos += FSIZ( cai_qual_info2_type, reserved );
  }
  else
  {
    return ( CAIX_INV_MSG_S ); /* Unknown qual info type */
  }

  /* Translate the information records */
  for ( i = irec_pos = 0; (i < int_ptr->ac_strsp.num_recs); i++ )
  {
    if((irec_pos/4) < CAII_MAX_INFO_REC_DWORDS)
    {
      status =
      xlate_int_info_rec(
                        (byte*)(&int_ptr->ac_strsp.recs[irec_pos/4]),
                        &irec_len,
                        CAI_AC_BODY_SIZE - msg_pos - FSIZ( cai_ac_strsp_fix_type,
                                                           reserved2 ),
                        buf_ptr,
                        msg_pos,
                        &xrec_len );

      if ( status != CAIX_DONE_S )
      {
        return ( status ); /* Problem translating info rec */
      }
    }

    msg_pos  += xrec_len;  /* Advance external msg buf position */
    irec_pos += irec_len;  /* Advance internal msg buf position */
    /* The next record will start only on a dword boundary, so move positions accordingly */
    irec_pos = (irec_pos%4)?(irec_pos+(sizeof(dword))-irec_pos%4):irec_pos;
  } /* for */

  if ( l2_fields_pack_ind == CAIX_L2_FIELDS_PACK )
  {
    if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
    {
      b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, reserved2 ) );
      msg_pos += FSIZ( cai_ac_strsp_fix_type, reserved2 );
    }
  }

  *len_ptr = msg_pos; /* Set length of message */

  return ( CAIX_DONE_S );

} /* xlate_int_ac_strsp */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_INT_AC_AURSPM

DESCRIPTION
  This function translates an Authentication Response Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_aurspm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position in buffer to pack bits */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position of L3 SDU */
  #endif /* FEATURE_IS2000_REL_A_AES */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------------------------------
  ** Pack Authentication Response Msg up through the MSID field
  ** -------------------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_aurspm.msg_type,
      &int_ptr->ac_aurspm.hdr, &int_ptr->ac_aurspm.ami);

    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr,
                     &int_ptr->ac_aurspm.enc,
                     &int_ptr->ac_aurspm.ami
                    );

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,buffer_pos,
                      &(int_ptr->ac_aurspm.pilot_rpt));
    buffer_pos += ac_plt_rpt_len;

    #ifdef FEATURE_IS2000_REL_A_AES
    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    sdu_start_pos = buffer_pos;
    #endif /* FEATURE_IS2000_REL_A_AES */

    b_packq(int_ptr->ac_aurspm.res_hi, buf_ptr, buffer_pos,
              FSIZ(cai_ac_aurspm_type,  res )/2);
    buffer_pos += FSIZ(cai_ac_aurspm_type,  res )/2;
    b_packq(int_ptr->ac_aurspm.res_lo, buf_ptr, buffer_pos,
              FSIZ(cai_ac_aurspm_type,  res )/2);
    buffer_pos += FSIZ(cai_ac_aurspm_type,  res )/2;

    b_packb(int_ptr->ac_aurspm.sig_integrity_sup_incl, buf_ptr, buffer_pos,
            FSIZ(cai_ac_aurspm_type,sig_integrity_sup_incl));
    buffer_pos += FSIZ(cai_ac_aurspm_type,sig_integrity_sup_incl);
    if (int_ptr->ac_aurspm.sig_integrity_sup_incl)
    {
      b_packb(int_ptr->ac_aurspm.sig_integrity_sup, buf_ptr, buffer_pos,
              FSIZ(cai_ac_aurspm_type ,sig_integrity_sup));
      buffer_pos += FSIZ(cai_ac_aurspm_type,sig_integrity_sup);
      b_packb(int_ptr->ac_aurspm.sig_integrity_req, buf_ptr, buffer_pos,
              FSIZ(cai_ac_aurspm_type,sig_integrity_req));
      buffer_pos += FSIZ(cai_ac_aurspm_type,sig_integrity_req);
    }
    b_packb(int_ptr->ac_aurspm.new_key_id, buf_ptr, buffer_pos,
            FSIZ(cai_ac_aurspm_type,new_key_id));
    buffer_pos += FSIZ(cai_ac_aurspm_type,new_key_id);

    b_packd(int_ptr->ac_aurspm.new_sseq_h, buf_ptr, buffer_pos,
            FSIZ(cai_ac_aurspm_type,new_sseq_h));
    buffer_pos += FSIZ(cai_ac_aurspm_type,new_sseq_h);


    #ifdef FEATURE_IS2000_REL_A_AES
    if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
    {
      buffer_pos = mccaes_calculate_new_buf_length(int_ptr->ac_aurspm.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
    }
    else
    {
      auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                            int_ptr->ac_aurspm.enc.sdu_encrypt_mode,
                            int_ptr->ac_aurspm.hdr.ack_req
                           );
    }
    #endif /* FEATURE_IS2000_REL_A_AES */

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
      if (int_ptr->ac_aurspm.ami.maci_incl)
      {
        xlate_int_maci(&buffer_pos,
                       buf_ptr,
                       CAI_AC_CRC_SIZE,
                       int_ptr->ac_aurspm.hdr.ack_req,
                       chn,
                       int_ptr->ac_aurspm.ami.sdu_key_id,
                       int_ptr->ac_aurspm.msg_type,
                       int_ptr->ac_aurspm.ami.sdu_integrity_algo,
                       &int_ptr->ac_aurspm.ami.maci
                       );
      } /* maci_incl */
    } /* p_rex >= CAIX_P_REV_IS2000_REL_C */
  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

}

/*===========================================================================

FUNCTION XLATE_INT_AC_AURSYNM

DESCRIPTION
  This function translates an Authentication Resync Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_aursynm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position in buffer to pack bits */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position of L3 SDU */
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------------------------------
  ** Pack Authentication Resync Msg up through the MSID field
  ** -------------------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_aursynm.msg_type,
      &int_ptr->ac_aursynm.hdr, &int_ptr->ac_aursynm.ami);

    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr,
                     &int_ptr->ac_aursynm.enc,
                     &int_ptr->ac_aursynm.ami
                    );

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,buffer_pos,
                      &(int_ptr->ac_aursynm.pilot_rpt));
    buffer_pos += ac_plt_rpt_len;

    #ifdef FEATURE_IS2000_REL_A_AES
    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    sdu_start_pos = buffer_pos;
    #endif /* FEATURE_IS2000_REL_A_AES */

    b_packq(int_ptr->ac_aursynm.con_ms_sqn, buf_ptr, buffer_pos,
              FSIZ(cai_aursynm_type,  con_ms_sqn ));
    buffer_pos += FSIZ(cai_aursynm_type,  con_ms_sqn );
    b_packq(int_ptr->ac_aursynm.mac_s, buf_ptr, buffer_pos,
              FSIZ(cai_aursynm_type,  mac_s ));
    buffer_pos += FSIZ(cai_aursynm_type,  mac_s );

    #ifdef FEATURE_IS2000_REL_A_AES
    if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
    {
      buffer_pos = mccaes_calculate_new_buf_length(int_ptr->ac_aursynm.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
    }
    else
    {
      auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                            int_ptr->ac_aursynm.enc.sdu_encrypt_mode,
                            int_ptr->ac_aursynm.hdr.ack_req
                           );
    }
    #endif /* FEATURE_IS2000_REL_A_AES */

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
      if (int_ptr->ac_aursynm.ami.maci_incl)
      {
        xlate_int_maci(&buffer_pos,
                       buf_ptr,
                       CAI_AC_CRC_SIZE,
                       int_ptr->ac_aursynm.hdr.ack_req,
                       chn,
                       int_ptr->ac_aursynm.ami.sdu_key_id,
                       int_ptr->ac_aursynm.msg_type,
                       int_ptr->ac_aursynm.ami.sdu_integrity_algo,
                       &int_ptr->ac_aursynm.ami.maci
                       );
      } /* maci_incl */
    } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

}

/*===========================================================================

FUNCTION XLATE_INT_AC_RCNM

DESCRIPTION
  This function translates a Reconnect Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_rcnm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position in buffer to pack bits */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position of L3 SDU */
  #endif /* FEATURE_IS2000_REL_A_AES */
  uint8 i;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------------------------------
  ** Pack a Recoonect Msg up through the MSID field
  ** -------------------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->rcnm.msg_type,
      &int_ptr->rcnm.hdr, &int_ptr->rcnm.ami);

    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr,
                     &int_ptr->rcnm.enc,
                     &int_ptr->rcnm.ami
                    );

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,buffer_pos,
                      &(int_ptr->rcnm.pilot_rpt));
    buffer_pos += ac_plt_rpt_len;

    #ifdef FEATURE_IS2000_REL_A_AES
    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    sdu_start_pos = buffer_pos;
    #endif /* FEATURE_IS2000_REL_A_AES */

    b_packb(int_ptr->rcnm.orig_ind, buf_ptr, buffer_pos,
              FSIZ(cai_ac_rcnm_type,  orig_ind ));
    buffer_pos += FSIZ(cai_ac_rcnm_type,  orig_ind );

    b_packb(int_ptr->rcnm.sync_id_incl, buf_ptr, buffer_pos,
              FSIZ(cai_ac_rcnm_type, sync_id_incl  ));
    buffer_pos += FSIZ(cai_ac_rcnm_type, sync_id_incl  );

    if (int_ptr->rcnm.sync_id_incl)
    {
      b_packb( int_ptr->rcnm.sync_id_len, buf_ptr, buffer_pos,
             FSIZ( cai_ac_rcnm_type, sync_id_len ));
      buffer_pos += FSIZ( cai_ac_rcnm_type, sync_id_len );
      for (i=0; i < int_ptr->rcnm.sync_id_len; i++)
      {
        b_packb( int_ptr->rcnm.sync_id[i], buf_ptr, buffer_pos,
               FSIZ( cai_ac_rcnm_type, sync_id ));
        buffer_pos += FSIZ( cai_ac_rcnm_type, sync_id );
      }
    }
    else
    {
      b_packw( int_ptr->rcnm.service_option, buf_ptr, buffer_pos,
             FSIZ( cai_ac_rcnm_type, service_option ));
      buffer_pos += FSIZ( cai_ac_rcnm_type, service_option );
    }

    if (int_ptr->rcnm.orig_ind)
    {
      b_packb( int_ptr->rcnm.sr_id, buf_ptr, buffer_pos,
             FSIZ( cai_ac_rcnm_type, sr_id ));
      buffer_pos += FSIZ( cai_ac_rcnm_type, sr_id );
    }

    #ifdef FEATURE_IS2000_REL_A_AES
    if ( parsing_reason == CAIX_CALC_MSG_LENGTH )
    {
      buffer_pos = mccaes_calculate_new_buf_length(int_ptr->rcnm.enc.sdu_encrypt_mode, sdu_start_pos, buffer_pos);
    }
    else
    {
      auth_ext_encrypt_cdma(buf_ptr, &buffer_pos, sdu_start_pos,
                            int_ptr->rcnm.enc.sdu_encrypt_mode,
                            int_ptr->rcnm.hdr.ack_req
                           );
    }
    #endif /* FEATURE_IS2000_REL_A_AES */

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
      if (int_ptr->rcnm.ami.maci_incl)
      {
        xlate_int_maci(&buffer_pos,
                       buf_ptr,
                       CAI_AC_CRC_SIZE,
                       int_ptr->rcnm.hdr.ack_req,
                       chn,
                       int_ptr->rcnm.ami.sdu_key_id,
                       int_ptr->rcnm.msg_type,
                       int_ptr->rcnm.ami.sdu_integrity_algo,
                       &int_ptr->rcnm.ami.maci);

      } /* maci_incl */
    } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

}
#endif /* FEATURE_IS2000_REL_C */

/*===========================================================================

FUNCTION XLATE_INT_AC_MSG

DESCRIPTION
  This function translates an Access Channel message to be transmitted
  to the base station from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_msg
(
  word *len_ptr,
    /* Length of message in bits */
  byte *ac_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status;
    /* Status to be returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (int_ptr->gen_ac.msg_type) {
    case CAI_REG_MSG:
      status = xlate_int_reg( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_ORD_MSG:
      status = xlate_int_ac_ord( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_BURST_MSG:
      status = xlate_int_ac_burst( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_ORIG_MSG:
      status = xlate_int_orig( len_ptr, ac_ptr, int_ptr, chn, parsing_reason, FALSE );
      break;

    case CAI_PAGE_RESP_MSG:
      status = xlate_int_page_resp( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_AUTH_RESP_MSG:
      status = xlate_int_auth_ch( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_STRSP_MSG:
      /* REL A does not apply to Status Response Message */
      status = xlate_int_ac_strsp( len_ptr, ac_ptr, int_ptr, chn,
                 CAIX_L2_FIELDS_PACK );
      break;

    case CAI_AC_TMSI_CMP_MSG:
      status = xlate_int_ac_tmsi_cmp( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_PACA_CAN_MSG:
      status = xlate_int_ac_paca_can( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_EXT_STRSP_MSG:
      status = xlate_int_ac_ext_strsp( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;


#ifdef FEATURE_IS2000_REL_A
    case CAI_AC_DIM_MSG:
      status = xlate_int_ac_dim( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_SMRM_MSG:
      status = xlate_int_ac_smrm( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    case CAI_AC_AUTH_RSP_MSG:
      status = xlate_int_ac_aurspm( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_AUTH_RESYNC_MSG:
      status = xlate_int_ac_aursynm( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_RECONNECT_MSG:
      status = xlate_int_ac_rcnm( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;
#endif /* FEATURE_IS2000_REL_C */

    default:
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

  return (status);

} /* xlate_int_ac_msg */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_INT_MSG_INT_TC

DESCRIPTION
  This function translates message integrity fields from internal to external
  format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_msg_int_tc
(
  word *pos_ptr,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_gen_tc_type *int_ptr
    /* Pointer to the internal format of the message integrity fields */
)
{
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
    #define FTYPE cai_msg_int_type

    M1X_MSG( DCP, LEGACY_LOW,
      "rdsch msg. key id: %d",
      int_ptr->hdr.msg_int.sdu_key_id);

    b_packb(int_ptr->hdr.msg_int.maci_incl, buf_ptr, *pos_ptr, FSIZ(FTYPE, maci_incl));
    *pos_ptr += FSIZ(FTYPE, maci_incl);

    if (int_ptr->hdr.msg_int.maci_incl)
    {
      b_packb(int_ptr->hdr.msg_int.randc, buf_ptr, *pos_ptr, FSIZ(FTYPE, randc));
      *pos_ptr += FSIZ(FTYPE, randc);

      b_packb(int_ptr->hdr.msg_int.sdu_key_id, buf_ptr, *pos_ptr, FSIZ(FTYPE, sdu_key_id));
      *pos_ptr += FSIZ(FTYPE, sdu_key_id);

      b_packb(int_ptr->hdr.msg_int.sdu_integrity_algo, buf_ptr, *pos_ptr,
        FSIZ(FTYPE, sdu_integrity_algo));
      *pos_ptr += FSIZ(FTYPE, sdu_integrity_algo);

      b_packb(int_ptr->hdr.msg_int.sdu_sseq_or_sseqh, buf_ptr, *pos_ptr,
        FSIZ(FTYPE, sdu_sseq_or_sseqh));
      *pos_ptr += FSIZ(FTYPE, sdu_sseq_or_sseqh);

      if (!int_ptr->hdr.msg_int.sdu_sseq_or_sseqh)
      {
        b_packb(int_ptr->hdr.msg_int.sdu_sseq, buf_ptr, *pos_ptr, FSIZ(FTYPE, sdu_sseq));
        *pos_ptr += FSIZ(FTYPE, sdu_sseq);
      }
      else
      {
        b_packd(int_ptr->hdr.msg_int.sdu_sseq_h, buf_ptr, *pos_ptr, FSIZ(FTYPE, sdu_sseq_h));
        *pos_ptr += FSIZ(FTYPE, sdu_sseq_h);
      }
    }

    #undef FTYPE

  }

}  /* xlate_int_msg_int_tc */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_INT_EXT_ENC_TC

DESCRIPTION
  This function translate extended encryption fields from internal to external
  format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_ext_enc_tc
(
  word *pos_ptr,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_gen_tc_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  /* This part should only be packed when PREV is less than 7 )*/
  if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A))
  {

    if (int_ptr->hdr.encryption == CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
    {
      b_packb(int_ptr->hdr.sdu_encrypt_mode, buf_ptr, *pos_ptr,
        FSIZ(cai_tc_hdr_ext_enc_type, sdu_encrypt_mode));
      *pos_ptr +=  FSIZ(cai_tc_hdr_ext_enc_type, sdu_encrypt_mode);

      /* If the SDU_ENCRYPT_MODE field is set to '001' or '010' and if MACI_INCL
       * field is not present in the PDU or it is present, but it is eaqual to '0',
       * the mobile station shall include the ENC_SEQ field and shall it to the value
       * provided by Layer 3; otherwise, the mobile station shall omit the ENC_SEQ field
       *
       *
       * The understanding here is: if the condition is met, the ENC_SEQ field should be
       * set to the specified value. if the condition is not met, this field should still
       * be there but ignore the value.
       *
       */
      if (((int_ptr->hdr.sdu_encrypt_mode == CAI_ENC_MODE_ECMEA) ||
           (int_ptr->hdr.sdu_encrypt_mode == CAI_ENC_MODE_REA))
#ifdef FEATURE_IS2000_REL_C
          && ((caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_C) ||
              !int_ptr->hdr.msg_int.maci_incl)
#endif /* FEATURE_IS2000_REL_C */
         )
      {
        b_packb(int_ptr->hdr.enc_seq, buf_ptr, *pos_ptr,
           FSIZ(cai_tc_hdr_ext_enc_type, enc_seq));
        *pos_ptr +=  FSIZ(cai_tc_hdr_ext_enc_type, enc_seq);
      }  /* CAI_ENC_MODE_ECMEA || CAI_ENC_MODE_REA */
    }  /* CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG */
  }
} /* xlate_int_ext_enc_tc */
#endif /* FEATURE_IS2000_REL_A */

/*===========================================================================

FUNCTION XLATE_INT_TC_HDR

DESCRIPTION
  This function translates a Traffic Channel Message header from internal to
  external format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_tc_hdr
(
  word *pos_ptr,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_gen_tc_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  *pos_ptr = FPOS(cai_gen_tc_type, msg_type);

  b_packb(int_ptr->msg_type, buf_ptr, *pos_ptr,
    FSIZ(cai_gen_tc_type, msg_type));
  *pos_ptr += FSIZ(cai_gen_tc_type, msg_type);

  b_packb(int_ptr->hdr.ack_seq, buf_ptr, *pos_ptr,
    FSIZ(cai_gen_tc_type, hdr.ack_seq));
  *pos_ptr += FSIZ(cai_gen_tc_type, hdr.ack_seq);

  b_packb(int_ptr->hdr.msg_seq, buf_ptr, *pos_ptr,
    FSIZ(cai_gen_tc_type, hdr.msg_seq));
  *pos_ptr += FSIZ(cai_gen_tc_type, hdr.msg_seq);

  b_packb(int_ptr->hdr.ack_req, buf_ptr, *pos_ptr,
    FSIZ(cai_gen_tc_type, hdr.ack_req));
  *pos_ptr += FSIZ(cai_gen_tc_type, hdr.ack_req);

  b_packb(int_ptr->hdr.encryption, buf_ptr, *pos_ptr,
    FSIZ(cai_gen_tc_type, hdr.encryption));
  *pos_ptr += FSIZ(cai_gen_tc_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  /* Pack message integrity fields */
  xlate_int_msg_int_tc(pos_ptr, buf_ptr, (caii_gen_tc_type *)int_ptr);
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* Pack extended encryption fields */
  xlate_int_ext_enc_tc(pos_ptr, buf_ptr, int_ptr);
#endif /* FEATURE_IS2000_REL_A */
} /* xlate_int_tc_hdr() */

/*===========================================================================

FUNCTION XLATE_INT_TC_ORD

DESCRIPTION
  This function translates a Traffic Channel Order Message from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_ord
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */
  word add_rec_len_pos;
    /* the point where we will pack additional record length */

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_rtc_ord_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->tc_ord.gen);

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->tc_ord.gen.order, buf_ptr, msg_pos,
          FSIZ( cai_rtc_gen_ord_type, order ));
  msg_pos += FSIZ( cai_rtc_gen_ord_type, order );

  switch (int_ptr->tc_ord.gen.order)
  {
    case CAI_BS_CHAL_ORD:
      /* ----------------------------
      ** Base Station Challenge Order
      ** ---------------------------- */
      b_packb( 5, buf_ptr, msg_pos, FSIZ( MTYPE, gen.add_record_len ));
      msg_pos += FSIZ( MTYPE, gen.add_record_len );
      b_packb( 0, buf_ptr, msg_pos, FSIZ( MTYPE, ordq.ordq ));
      msg_pos += FSIZ( MTYPE, ordq.ordq );
      b_packd( int_ptr->tc_ord.chal.randbs, buf_ptr, msg_pos,
               FSIZ( MTYPE, chal.randbs ));
      msg_pos += FSIZ( MTYPE, chal.randbs );
      break;

    case CAI_DTMF_ORD:  /* Call Control Order so con_ref can be filled */

      if (int_ptr->tc_ord.ordq.ordq != 0)
      {
        /* move msg_pos */
        b_packb( 1, buf_ptr, msg_pos ,
          FSIZ( MTYPE, gen.add_record_len ));
        msg_pos += FSIZ( MTYPE, gen.add_record_len );

        b_packb( int_ptr->tc_ord.ordq.ordq, buf_ptr, msg_pos,
          FSIZ( MTYPE, ordq.ordq ));
        msg_pos += FSIZ( MTYPE, ordq.ordq );
      }
      else
      {
        b_packb( 0, buf_ptr, msg_pos ,
          FSIZ( MTYPE, gen.add_record_len ));
        msg_pos += FSIZ( MTYPE, gen.add_record_len );
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        if (int_ptr->tc_ord.ordq.con_ref_incl)
        {
          b_packb( int_ptr->tc_ord.ordq.con_ref_incl, buf_ptr,
               msg_pos,
               FSIZ( cai_rtc_ord_var_type, con_ref_incl ));
          msg_pos += FSIZ(cai_rtc_ord_var_type, con_ref_incl);

          b_packb( int_ptr->tc_ord.ordq.con_ref, buf_ptr,
               msg_pos,
               FSIZ( cai_rtc_ord_var_type, con_ref ));
          msg_pos += FSIZ(cai_rtc_ord_var_type, con_ref);
        }
      }
#endif /* FEATURE_IS2000_REL_A */
      break;

    case CAI_SSD_UPDATE_ORD:
    case CAI_PARAM_UPDATE_CONF_ORD:
    case CAI_PLC_ORD:
    case CAI_SO_CTL_ORD:
    case CAI_LOCAL_CTL_RESP_ORD:
    case CAI_FM_REQUEST_ORD:
      if (int_ptr->tc_ord.ordq.ordq == 0)
      {
        /* ----------------------------------------
        ** No need to pack order qualification code
        ** ---------------------------------------- */
        b_packb( 0, buf_ptr, msg_pos, FSIZ( MTYPE, gen.add_record_len ));
          msg_pos += FSIZ( MTYPE, gen.add_record_len );
      }
      else
      {
        b_packb( 1, buf_ptr, msg_pos, FSIZ( MTYPE, gen.add_record_len ));
        msg_pos += FSIZ( MTYPE, gen.add_record_len );
        b_packb( int_ptr->tc_ord.ordq.ordq, buf_ptr, msg_pos,
           FSIZ( MTYPE, ordq.ordq ));
        msg_pos += FSIZ( MTYPE, ordq.ordq );
      }
      break;

    case CAI_SO_REQ_ORD:
    case CAI_SO_RESP_ORD:
      b_packb( 3, buf_ptr, msg_pos, FSIZ( MTYPE, so.add_record_len ));
      msg_pos += FSIZ( MTYPE, gen.add_record_len );
      b_packb( int_ptr->tc_ord.so.ordq, buf_ptr, msg_pos, FSIZ( MTYPE, so.ordq ));
      msg_pos += FSIZ( MTYPE, so.ordq );
      b_packw( int_ptr->tc_ord.so.service_option, buf_ptr, msg_pos, FSIZ( MTYPE, so.service_option ));
      msg_pos += FSIZ( MTYPE, so.service_option );
      break;

    case CAI_MS_REJECT_ORD:

      /* ---------------------------
      ** Mobile Station Reject Order
      ** --------------------------- */
      /* length will be packed after packing all order specific fields */
      add_rec_len_pos = msg_pos;
      msg_pos += FSIZ( MTYPE, gen.add_record_len );

      b_packb( int_ptr->tc_ord.rej.fix.ordq, buf_ptr, msg_pos,
               FSIZ( MTYPE, rej.fix.ordq ));
      msg_pos += FSIZ( MTYPE, rej.fix.ordq );

      b_packb( int_ptr->tc_ord.rej.fix.rej_msg_type, buf_ptr, msg_pos,
               FSIZ( MTYPE, rej.fix.rej_msg_type ));
      msg_pos += FSIZ( MTYPE, rej.fix.rej_msg_type );

      /* type is 00000001 or 00000111 */
      if (int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_TC_FWD_ORD_MSG)
      {
        /* ---------------------------------------------
        ** Order Message -> must pack rejected_order and
        **                  rejected_ordq fields
        ** --------------------------------------------- */

        b_packb( int_ptr->tc_ord.rej.var.order.rej_order, buf_ptr, msg_pos,
                 FSIZ( MTYPE, rej.var.order.rej_order ));
        msg_pos += FSIZ( MTYPE, rej.var.order.rej_order );
        b_packb( int_ptr->tc_ord.rej.var.order.rej_ordq, buf_ptr, msg_pos,
                 FSIZ( MTYPE, rej.var.order.rej_ordq ));
        msg_pos += FSIZ( MTYPE, rej.var.order.rej_ordq );
      }

      else if (int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_SET_PARMS_MSG)
      {
        /* --------------------------------------------------
  ** Pack rejected_param_id for Set Parameters Message.
        ** -------------------------------------------------- */
        b_packw( int_ptr->tc_ord.rej.var.param.rej_param_id,
                 buf_ptr, msg_pos, FSIZ( MTYPE, rej.var.param.rej_param_id ));
        msg_pos += FSIZ( MTYPE, rej.var.param.rej_param_id );
      }

      else if ((int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_ALERT_MSG) ||
               (int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_FWD_FLASH_MSG)
#ifdef FEATURE_IS2000_REL_A
               || (int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_EXT_ALERT_W_INFO_MSG)
               || (int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_EXT_FLASH_W_INFO_MSG)
#endif /* FEATURE_IS2000_REL_A */
              )
      {
        /* -----------------------------------------------------------
        ** Alert with Information or Flash with Information Message ->
        **   must pack rejected_record field
        ** ----------------------------------------------------------- */

        b_packb( int_ptr->tc_ord.rej.var.rec.rej_record,
                 buf_ptr, msg_pos, FSIZ( MTYPE, rej.var.rec.rej_record ));
        msg_pos += FSIZ( MTYPE, rej.var.rec.rej_record );
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        switch (int_ptr->tc_ord.rej.fix.ordq)
        {
          case  CAI_REJ_NO_CC_INST :
          case  CAI_REJ_CALL_ASSIGN_REJ  :
          case  CAI_REJ_CC_ALREADY_PRESENT :

            b_packb( int_ptr->tc_ord.rej.con_ref, buf_ptr,
                msg_pos, FSIZ(cai_rtc_rej_ord_is2000_relA_type,con_ref));
            msg_pos += FSIZ(cai_rtc_rej_ord_is2000_relA_type,con_ref);

            break;

          case CAI_REJ_CC_TAG_MISMATCH:

            b_packb( int_ptr->tc_ord.rej.con_ref, buf_ptr,
                 msg_pos, FSIZ(cai_rtc_rej_ord_is2000_relA_type,con_ref));
              msg_pos += FSIZ(cai_rtc_rej_ord_is2000_relA_type,con_ref);

            b_packb( int_ptr->tc_ord.rej.tag, buf_ptr,
              msg_pos, FSIZ(cai_rtc_rej_ord_is2000_relA_type,tag));
            msg_pos += FSIZ(cai_rtc_rej_ord_is2000_relA_type,tag);
            break;

          default:
            break;
        }
      }
#endif /* FEATURE_IS2000_REL_A */

      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
      {
        b_packb( int_ptr->tc_ord.rej.rejected_pdu_type, buf_ptr,
                 msg_pos,
                 FSIZ(cai_rtc_rej_ord_is2000_type,rejected_pdu_type));
        msg_pos += FSIZ(cai_rtc_rej_ord_is2000_type,rejected_pdu_type);

        /* Now reserved part needs to be packed */

        /* if we've packed the tag pack only two bits of zeros
          otherwise pack 6 bits of zeros */
        #ifdef FEATURE_IS2000_REL_A
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
        {
          /* if tag is packed above */
          if (int_ptr->tc_ord.rej.fix.ordq == CAI_REJ_CC_TAG_MISMATCH)
          {
            b_packb( 0, buf_ptr, msg_pos, 2);
            msg_pos += 2;
          }
          else
          {
            b_packb( 0, buf_ptr, msg_pos, 6);
            msg_pos += 6;
          }
        }
        else
        #endif /* FEATURE_IS2000_REL_A */
        {
          b_packb( 0, buf_ptr, msg_pos, 6);
          msg_pos += 6;
        }
      }

      /* now that we have packed all Order specific fields, put the length info to the
      saved address. Note that the length should be in octets

      add_rec_len_pos:  position where order specific length must be packed into
      msg_pos: where we are now

      ((msg_pos - add_rec_len_pos - 1) >> 3) + 1 : Number of octets packed in the mean time
      i.e
      msg_pos = 10, add_rec_len_pos = 2 ===>  1 Octet
      msg_pos = 10, add_rec_len_pos = 3 ===>  1 Octet
      msg_pos = 15, add_rec_len_pos = 6 ===>  2 Octets
      */

      b_packb( ((msg_pos - add_rec_len_pos - 1) >> 3), /*lint !e702*/
               buf_ptr, add_rec_len_pos, FSIZ( MTYPE, gen.add_record_len ));
      break;

   case CAI_MS_ACK_ORD:
     /* -----------------
     ** No order qualifer
     ** ----------------- */
     b_packb( 0, buf_ptr, msg_pos, FSIZ( MTYPE, so.add_record_len ));
     msg_pos += FSIZ( MTYPE, gen.add_record_len );
     break;

  case CAI_MS_CONNECT_ORD: /* Call Control Order so con_ref can be filled */
     /* -----------------
     ** No order qualifer
     ** ----------------- */
     b_packb( 0, buf_ptr, msg_pos, FSIZ( MTYPE, gen.add_record_len ));
     msg_pos += FSIZ( MTYPE, gen.add_record_len );

#ifdef FEATURE_IS2000_REL_A
     if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
     {
       b_packb( int_ptr->tc_ord.gen.con_ref_incl, buf_ptr,
         msg_pos, FSIZ( cai_rtc_ord_var_type, con_ref_incl ));
       msg_pos += FSIZ(cai_rtc_ord_var_type, con_ref_incl);

       if (int_ptr->tc_ord.gen.con_ref_incl)
       {
         b_packb( int_ptr->tc_ord.gen.con_ref, buf_ptr,
              msg_pos, FSIZ( cai_rtc_ord_var_type, con_ref ));
         msg_pos += FSIZ(cai_rtc_ord_var_type, con_ref);
       }
     }
#endif /* FEATURE_IS2000_REL_A */

     break;

#ifdef FEATURE_IS2000_REL_B
#ifdef FEATURE_IS2000_REL_C
    case CAI_SEC_MODE_CMP_ORD:
#endif /* FEATURE_IS2000_REL_C */
    case CAI_CALL_RESQ_CANCEL_ORD:
      /* -----------------
      ** No order qualifer
      ** ----------------- */
      b_packb( 0, buf_ptr, msg_pos, FSIZ( MTYPE, gen.add_record_len ));
      msg_pos += FSIZ( MTYPE, gen.add_record_len );
      break;
#endif /* FEATURE_IS2000_REL_B */

    case CAI_RELEASE_ORD:
      if (int_ptr->tc_ord.ordq.ordq == CAI_REL_NORMAL)
      {
        b_packb( 0, buf_ptr, msg_pos ,
                 FSIZ( MTYPE, gen.add_record_len ));
        msg_pos += FSIZ( MTYPE, gen.add_record_len );
      }
      else if (int_ptr->tc_ord.ordq.ordq == CAI_REL_PWDN
               || int_ptr->tc_ord.ordq.ordq == CAI_REL_SO)
      {
        b_packb( 1, buf_ptr, msg_pos ,
                 FSIZ( MTYPE, gen.add_record_len ));
        msg_pos += FSIZ( MTYPE, gen.add_record_len );

        b_packb( int_ptr->tc_ord.ordq.ordq, buf_ptr, msg_pos,
                 FSIZ( MTYPE, ordq.ordq ));
        msg_pos += FSIZ( MTYPE, ordq.ordq );
      }
      break;

   default:
     /* -------------------------------------
     ** Invalid Reverse Traffic Channel Order
     ** ------------------------------------- */
     status = CAIX_INV_MSG_S;
     break;
  } /* end switch (int_ptr->tc_ord.gen.order) */

  #ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                        int_ptr->tc_ord.gen.hdr.sdu_encrypt_mode,
                        int_ptr->tc_ord.gen.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  if (int_ptr->tc_ord.gen.hdr.msg_int.maci_incl)
  {
  /* Pack MACI field */
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->tc_ord.gen.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->tc_ord.gen.hdr.msg_int.sdu_key_id,
                   int_ptr->tc_ord.gen.msg_type,
                   int_ptr->tc_ord.gen.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->tc_ord.gen.hdr.msg_int.maci
                   );
  }
 #endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;

  #undef MTYPE

  return (status);

} /* xlate_int_tc_ord */

/*===========================================================================

FUNCTION XLATE_INT_AUTH_RESP

DESCRIPTION
  This function translates an Authentication Challenge Response Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_auth_resp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* Status to be returned to calling procedure */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_auth_type

  /* ------------
  ** Pack message
  ** ------------ */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->auth_resp);

#ifdef FEATURE_IS2000_REL_A_AES
/* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packd(int_ptr->auth_resp.authu, buf_ptr, msg_pos, FSIZ( MTYPE, authu));
  msg_pos += FSIZ( MTYPE, authu);

#ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                        int_ptr->auth_resp.hdr.sdu_encrypt_mode,
                        int_ptr->auth_resp.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  if (int_ptr->auth_resp.hdr.msg_int.maci_incl)
  {
  /* Pack MACI field */
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->auth_resp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->auth_resp.hdr.msg_int.sdu_key_id,
                   int_ptr->auth_resp.msg_type,
                   int_ptr->auth_resp.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->auth_resp.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

  #undef MTYPE

  return (status);
} /* xlate_int_auth_resp */

/*===========================================================================

FUNCTION XLATE_INT_FLASH

DESCRIPTION
  This function translates a Flash With Information Message from internal
  to external format.

DEPENDENCIES
  Depends on the internal message type having the correct number of variable
  record parts.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None.

===========================================================================*/

word xlate_int_flash
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through records */
  word j;
    /* Index to loop through characters */
  byte *rec_ptr;
    /* Pointer to internal format information record */
  word msg_pos = 0;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */
  #ifdef FEATURE_IS2000_REL_A
  word rec_len_pos = 0;
  word reserv_len = 0;
  #endif /* FEATURE_IS2000_REL_A */
  #ifdef FEATURE_IS2000_REL_C
  word rec_len;
  /* Size of record in bits */
  #endif /* FEATURE_IS2000_REL_C */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------
  ** Pack message
  ** ------------ */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->flash);

  rec_ptr = (byte*)&int_ptr->flash.recs[0];

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos; /* msg_pos already moved */
#endif /* FEATURE_IS2000_REL_A_AES */

  for (i=0; (i < int_ptr->flash.num_recs) && (status == CAIX_DONE_S); i++)
  {
    /* ----------------------------------------------------
    ** Check to make sure that there is room for the header
    ** ---------------------------------------------------- */
    if ((msg_pos + sizeof( cai_rec_hdr_type )) > CAI_REV_TC_MSG_BODY_SIZE)
    {
      status = CAIX_INV_LEN_S;
    }
    else
    {
      b_packb( ((caii_rec_hdr_type *) rec_ptr)->record_type,
                 buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_type ));
      msg_pos += FSIZ( cai_rec_hdr_type, record_type );

      switch (((caii_rec_hdr_type *) rec_ptr)->record_type)
      {
        /* ------------------------------------
        ** Feature Indicator Information Record
        ** ------------------------------------ */
        case CAI_FEAT_REC:
          /* -------------------------------------------------------
          ** Feature Indicator Info Record length = 1 octet (8 bits)
          ** ------------------------------------------------------- */
          b_packb( 1, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos + sizeof( cai_feat_type )) > CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else {
            b_packb( ((caii_feat_rec_type *) rec_ptr)->feature,
                       buf_ptr, msg_pos, FSIZ( cai_feat_type, feature ));
            msg_pos += FSIZ( cai_feat_type, feature );

            /* -----------------------
            ** Pack reserved bits as 0
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_feat_type, reserved ));
            msg_pos += FSIZ( cai_feat_type, reserved );
            rec_ptr += FENDPOS( caii_feat_rec_type, feature );
          }
          break;

        /* ----------------------------------
        ** Keypad Facility Information Record
        ** ---------------------------------- */
        case CAI_KEYPAD_REC:
          if ((((caii_key_rec_type *) rec_ptr)->fix.num_char) == 0)
          {
            /* --------------------------------------------------------
            ** There must be at least one occurrence of the chari field
            ** -------------------------------------------------------- */
            return (CAIX_INV_LEN_S);
          }

          b_packb( ((caii_key_rec_type *) rec_ptr)->fix.num_char, buf_ptr,
                   msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos +
              (((caii_key_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_keypad_type, chari ))) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            /* --------------------------------------------
            ** Not enough room to pack keypad facility type
            ** -------------------------------------------- */
            status = CAIX_INV_LEN_S;
          }
          else
          {
            for (j=0; j < ((caii_key_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_key_rec_type *) rec_ptr)->var[j], buf_ptr,
                       msg_pos, FSIZ(cai_keypad_type, chari) );
              msg_pos += FSIZ( cai_keypad_type, chari );
            }

            rec_ptr += FENDPOS( caii_key_rec_type,
              var[((caii_key_rec_type *) rec_ptr)->fix.num_char - 1] );
          }
          break;

        /* --------------------------------------
        ** Called Party Number Information Record
        ** -------------------------------------- */
        case CAI_REV_CALLED_REC:
          /* ----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 1 (8 bits) for
          ** NUMBER_TYPE, NUMBER_PLAN and RESERVED fields
          ** ---------------------------------------------------- */
          b_packb(
            (byte) (((caii_called_rec_type *) rec_ptr)->fix.num_char + 1),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len);

          if ((msg_pos + sizeof( cai_called_fix_type ) +
              (((caii_called_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_called_var_type, chari )) + 1) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else
          {
            b_packb( ((caii_called_rec_type *) rec_ptr)->fix.number_type,
                     buf_ptr, msg_pos,
                     FSIZ( cai_called_fix_type, number_type ));
            msg_pos += FSIZ(cai_called_fix_type, number_type);

            b_packb( ((caii_called_rec_type *)rec_ptr)->fix.number_plan,
                     buf_ptr, msg_pos,
                     FSIZ( cai_called_fix_type, number_plan));
            msg_pos += FSIZ( cai_called_fix_type, number_plan);

            for (j=0;
                 j < ((caii_called_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_called_rec_type *) rec_ptr)->var[j], buf_ptr,
                        msg_pos, FSIZ( cai_called_var_type, chari ));
              msg_pos += FSIZ( cai_called_var_type, chari );
            }

            /* -----------------------
            ** Pack 0 for reserved bit
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, 1 );
            msg_pos += 1;

            if (((caii_called_rec_type *) rec_ptr)->fix.num_char == 0)
            {
              rec_ptr += FSIZ( caii_called_rec_type, fix );
            }
            else
            {
              rec_ptr += FENDPOS( caii_called_rec_type,
                   var[((caii_called_rec_type *) rec_ptr)->fix.num_char - 1] );
            }
          }
          break;

        /* -----------------------------------------------------------
        ** Calling Party Number or Connected Number Information Record
        ** ----------------------------------------------------------- */
        case CAI_REV_CALLING_REC:
        case CAI_REV_CONN_REC:
          /* -----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 2 (16 bits) for
          ** NUMBER_TYPE, NUMBER_PLAN, PI, SI and RESERVED fields
          ** ----------------------------------------------------- */
          b_packb(
            (byte) (((caii_calling_rec_type *) rec_ptr)->fix.num_char + 2),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos + sizeof( cai_calling_fix_type ) +
              (((caii_calling_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_calling_var_type, chari )) + 5) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }
          else
          {
            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.number_type,
                      buf_ptr, msg_pos,
                      FSIZ( cai_calling_fix_type, number_type ));
            msg_pos += FSIZ( cai_calling_fix_type, number_type );

            b_packb( (( caii_calling_rec_type *) rec_ptr)->fix.number_plan,
                     buf_ptr, msg_pos,
                     FSIZ( cai_calling_fix_type, number_plan ));
            msg_pos += FSIZ(cai_calling_fix_type, number_plan);

            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.pi,
                     buf_ptr, msg_pos, FSIZ( cai_calling_fix_type, pi ));
            msg_pos += FSIZ( cai_calling_fix_type, pi );

            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.si,
                      buf_ptr, msg_pos, FSIZ( cai_calling_fix_type, si ));
            msg_pos += FSIZ( cai_calling_fix_type, si);

            for (j=0;
                 j < ((caii_calling_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_calling_rec_type *) rec_ptr)->var[j],
                        buf_ptr, msg_pos, FSIZ( cai_calling_var_type, chari));
              msg_pos += FSIZ( cai_calling_var_type, chari );
            }

            /* ------------------------
            ** Pack 0 for reserved bits
            ** ------------------------ */
            b_packb( 0, buf_ptr, msg_pos, 5 );
            msg_pos += 5;

            if (((caii_calling_rec_type *) rec_ptr)->fix.num_char == 0)
            {
              rec_ptr += FSIZ( caii_calling_rec_type, fix ); /*lint !e662 */
            }
            else {
              rec_ptr += FENDPOS( caii_calling_rec_type,
                var[((caii_calling_rec_type *) rec_ptr)->fix.num_char - 1] );
            }
          }
          break;

        /* -------------------------------------------
        ** Called Party Subaddress Informatin Record
        ** Calling Party Subaddress Informatin Record
        ** Connected Subaddress Informatin Record
        ** ------------------------------------------- */
        case CAI_REV_CALLED_SUB_REC:
        case CAI_REV_CALLING_SUB_REC:
        case CAI_REV_CONN_SUB_REC:
          /* ----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 1 (8 bits)
          ** ---------------------------------------------------- */
          b_packb(
            (byte) (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char + 1),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len);

          if ((msg_pos + sizeof( cai_subaddr_fix_type ) +
              (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_subaddr_var_type, chari ))) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }
          else
          {
            b_packb( ((caii_subaddr_rec_type *) rec_ptr)->fix.extension_bit,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, extension_bit ));
            msg_pos += FSIZ(cai_subaddr_fix_type, extension_bit);

            b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.subadd_type,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, subadd_type));
            msg_pos += FSIZ( cai_subaddr_fix_type, subadd_type);

            b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.odd_even_ind,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, odd_even_ind));
            msg_pos += FSIZ( cai_subaddr_fix_type, odd_even_ind);

            /* -----------------------
            ** Pack 0 for reserved bit
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, 3 );
            msg_pos += 3;

            for (j=0;
                 j < ((caii_subaddr_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_subaddr_rec_type *) rec_ptr)->var[j], buf_ptr,
                        msg_pos, FSIZ( cai_subaddr_var_type, chari ));
              msg_pos += FSIZ( cai_subaddr_var_type, chari ); /*lint !e662 */
            }

            if (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char == 0) {
              rec_ptr += FSIZ( caii_subaddr_rec_type, fix ); /*lint !e662 */
            }
            else
            {
              rec_ptr += FENDPOS( caii_subaddr_rec_type,
                   var[((caii_subaddr_rec_type *) rec_ptr)->fix.num_char - 1]);
            }
          }
          break;

#ifdef FEATURE_IS2000_REL_A
        case CAI_GLOB_EM_CALL_REC:
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
             if (  !((caii_global_emerg_type *) rec_ptr)->num_incl  )
             {
               b_packb(1, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
               msg_pos += FSIZ( cai_rec_hdr_type, record_len);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_incl,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix1_type, num_incl ));
               msg_pos += FSIZ(cai_global_emerg_fix1_type, num_incl);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->ms_orig_pos_loc_ind,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_var2_type, ms_orig_pos_loc_ind ));
               msg_pos += FSIZ(cai_global_emerg_var2_type, ms_orig_pos_loc_ind);

               b_packb( 0, buf_ptr, msg_pos, 6 );
               msg_pos += 6;

               /* that's all */
             }
             else /* digits included */
             {
               rec_len_pos = msg_pos;

               /* save the space for record length */
               msg_pos += FSIZ( cai_rec_hdr_type, record_len);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_incl,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix1_type, num_incl ));
                 msg_pos += FSIZ(cai_global_emerg_fix1_type, num_incl);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->digit_mode,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, digit_mode ));
                 msg_pos += FSIZ(cai_global_emerg_fix2_type, digit_mode);

               if (((caii_global_emerg_type *) rec_ptr)->digit_mode)
               {
                 b_packb( ((caii_global_emerg_type *) rec_ptr)->number_type,
                     buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, number_type ));
                   msg_pos += FSIZ(cai_global_emerg_fix2_type, number_type);

                 b_packb( ((caii_global_emerg_type *) rec_ptr)->number_plan,
                     buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, number_plan ));
                   msg_pos += FSIZ(cai_global_emerg_fix2_type, number_plan);
               }

               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_char,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, num_char ));
                 msg_pos += FSIZ(cai_global_emerg_fix2_type, num_char);

               for (j=0;
                    j < ((caii_global_emerg_type *) rec_ptr)->num_char; j++)
               {
                   if (((caii_global_emerg_type *) rec_ptr)->digit_mode)
                   {
                     b_packb( ((caii_global_emerg_type *) rec_ptr)->chari[j], buf_ptr,
                              msg_pos, FSIZ( cai_orig_var_type, char8 ));
                     msg_pos += FSIZ( cai_orig_var_type, char8 );
                   }
                   else
                   {
                     b_packb( ((caii_global_emerg_type *) rec_ptr)->chari[j], buf_ptr,
                              msg_pos, 4);
                     msg_pos += 4;
                   }
               }

               b_packb( ((caii_global_emerg_type *) rec_ptr)->ms_orig_pos_loc_ind,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_var2_type, ms_orig_pos_loc_ind ));
               msg_pos += FSIZ(cai_global_emerg_var2_type, ms_orig_pos_loc_ind);

               reserv_len = (msg_pos - rec_len_pos ) % 8;
               if (reserv_len != 0)
               {
                 reserv_len = 8 - reserv_len;
                 b_packb( 0, buf_ptr, msg_pos, reserv_len );
                 msg_pos += reserv_len;
               }

               /* put length (byte)(msg_pos - rec_len_pos) */
               b_packb( (int)(((msg_pos - rec_len_pos ) / 8) - 1) ,
                 buf_ptr, rec_len_pos, FSIZ( cai_rec_hdr_type, record_len ));

             } /* digits included */
          } /* REL A */
          rec_ptr += sizeof (caii_global_emerg_type); /*lint !e662 */
          break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
        /* -------------------------------------------
        ** Extended Keypad Facility Information Record
        ** ------------------------------------------- */
        case CAI_EXT_KEYPAD_REC:
          {
            if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
            {
              /* Compute record length, add in reserved bits */
              if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
              {
                rec_len = sizeof(cai_ext_keypad_facility_info_fix_type) +
                          (sizeof(cai_ext_keypad_facility_info_var_type) *
                           ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields) + 2;
              }
              else
              {
                rec_len = FSIZ(cai_ext_keypad_facility_info_fix_type, number_info_incl) +
                          FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields) +
                          (sizeof(cai_ext_keypad_facility_info_var_type) *
                           ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields) + 1;
              }

              if ( msg_pos + rec_len > CAI_REV_TC_MSG_BODY_SIZE )
              {
                status = CAIX_INV_LEN_S;
              }
              else
              {
                /* Pack record length */
                b_packb(rec_len / 8, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
                msg_pos += FSIZ( cai_rec_hdr_type, record_len);

                /* Add other record fields */
                b_packb( ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl,
                         buf_ptr, msg_pos,
                         FSIZ( cai_ext_keypad_facility_info_fix_type, number_info_incl ));
                msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, number_info_incl);

                if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
                {
                  b_packb( ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_type,
                           buf_ptr, msg_pos,
                           FSIZ(cai_ext_keypad_facility_info_fix_type , number_type ));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, number_type);

                  b_packb( ((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.number_plan,
                           buf_ptr, msg_pos,
                           FSIZ(cai_ext_keypad_facility_info_fix_type , number_plan));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type , number_plan);
                }

                b_packb(((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.num_fields,
                        buf_ptr, msg_pos,
                        FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields));
                msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields);

                for (j=0; j < ((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.num_fields; j++)
                {
                  b_packb(((caii_ext_keypad_facility_info_type *)rec_ptr)->var[j].chari,
                          buf_ptr, msg_pos,
                          FSIZ(cai_ext_keypad_facility_info_var_type, chari));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_var_type, chari);
                }

                if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
                {
                  /* There are two reserved bits if number_info_incl is 1 */
                  b_packb(0, buf_ptr, msg_pos, 2);
                  msg_pos += 2;
                }
                else
                {
                  /* Otherwise, there is 1 */
                  b_packb(0, buf_ptr, msg_pos, 1);
                  msg_pos += 1;
                }

              }
            } /* REL C*/

            rec_ptr += sizeof(caii_ext_keypad_facility_info_fix_type) +
                       (sizeof(caii_ext_keypad_facility_info_var_type) *
                        ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields);

            break;
          } /* CAI_EXT_KEYPAD_REC */

#endif /* FEATURE_IS2000_REL_C */

        default:
          status = CAIX_INV_MSG_S;
          break;
      } /* end switch (((caii_rec_hdr_type *) rec_ptr)->record_type) */

      rec_ptr = (byte*)ALIGN_DWORD(((dword)rec_ptr));
    }
  } /* end for loop */

#ifdef FEATURE_IS2000_REL_A_AES
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    /* SDU done, call encryption function */
    auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                          int_ptr->auth_resp.hdr.sdu_encrypt_mode,
                          int_ptr->auth_resp.hdr.ack_req
                         );
  }
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->flash.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->flash.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->flash.hdr.msg_int.sdu_key_id,
                   int_ptr->flash.msg_type,
                   int_ptr->flash.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->flash.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;

  return (status);

} /* xlate_int_flash */

/*===========================================================================

FUNCTION XLATE_INT_TC_TMSI_CMP

DESCRIPTION
  This function translates a Reverse Traffic Channel TMSI Assignment
  Completion Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_tmsi_cmp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word msg_pos = 0;
  /* Position to pack message in */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->tc_tmsi_cmp);

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->tc_tmsi_cmp.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->tc_tmsi_cmp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->tc_tmsi_cmp.hdr.msg_int.sdu_key_id,
                   int_ptr->tc_tmsi_cmp.msg_type,
                   int_ptr->tc_tmsi_cmp.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->tc_tmsi_cmp.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  *len_ptr = msg_pos;
#else
  *len_ptr = FENDPOS(cai_rtc_tmsi_cmp_type, reserved);
#endif /* FEATURE_IS2000_REL_A */

  return (status);

} /* xlate_int_tc_tmsi_cmp */

/*===========================================================================

FUNCTION XLATE_INT_TC_BURST

DESCRIPTION
  This function translates a Traffic Channel Data Burst Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_burst
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
   /* Index to loop through character fields */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_rev_tc_burst_type

  /* ------------
  ** Pack message
  ** ------------ */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->tc_burst );

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->tc_burst.msg_number, buf_ptr, msg_pos,
    FSIZ(MTYPE, fix.msg_number));
  msg_pos += FSIZ(MTYPE, fix.msg_number);

  b_packb(int_ptr->tc_burst.burst_type, buf_ptr, msg_pos,
    FSIZ(MTYPE, fix.burst_type));
  msg_pos += FSIZ( MTYPE, fix.burst_type);

  b_packb(int_ptr->tc_burst.num_msgs, buf_ptr, msg_pos,
    FSIZ(MTYPE, fix.num_msgs));
  msg_pos += FSIZ(MTYPE, fix.num_msgs);

  b_packb(int_ptr->tc_burst.num_fields, buf_ptr, msg_pos,
    FSIZ( MTYPE, fix.num_fields));
  msg_pos += FSIZ(MTYPE, fix.num_fields);

  for (i=0; i < int_ptr->tc_burst.num_fields; i++)
  {
    b_packb(int_ptr->tc_burst.chari[i], buf_ptr, msg_pos, FSIZ(MTYPE, var[i]));
    msg_pos += FSIZ(MTYPE, var[i]);
  }

#ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr, &msg_pos, sdu_start_pos,
                         int_ptr->tc_burst.hdr.sdu_encrypt_mode,
                         int_ptr->tc_burst.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->tc_burst.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->tc_burst.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->tc_burst.hdr.msg_int.sdu_key_id,
                   int_ptr->tc_burst.msg_type,
                   int_ptr->tc_burst.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->tc_burst.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  #undef MTYPE

  return (status);

} /* xlate_int_tc_burst */

/*===========================================================================

FUNCTION XLATE_INT_PIL_STR

DESCRIPTION
  This function translates a Traffic Channel Pilot Strength Measurement
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_pil_str
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through pn pilots */
  word msg_pos = 0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_pil_str_type

  if (int_ptr->pil_str.num_msr > CAI_PIL_STR_MAX)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------
    ** Pack message
    ** ------------ */

    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->pil_str);

#ifdef FEATURE_IS2000_REL_A_AES
    /* L3 SDU starts here */
    sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packw( int_ptr->pil_str.ref_pn, buf_ptr, msg_pos,
             FSIZ(MTYPE, fix.ref_pn));
    msg_pos += FSIZ(MTYPE, fix.ref_pn) ;

    b_packb( int_ptr->pil_str.pilot_strength, buf_ptr, msg_pos,
             FSIZ(MTYPE, fix.pilot_strength));
    msg_pos += FSIZ(MTYPE, fix.pilot_strength) ;

    b_packb( int_ptr->pil_str.keep, buf_ptr, msg_pos,
             FSIZ(MTYPE, fix.keep));
    msg_pos += FSIZ(MTYPE, fix.keep) ;

    for (i=0; i < int_ptr->pil_str.num_msr; i++)
    {
      b_packw( int_ptr->pil_str.meas[i].pilot_pn_phase, buf_ptr, msg_pos,
               FSIZ( MTYPE, var[i].pilot_pn_phase ));
      msg_pos += FSIZ(MTYPE, var[i].pilot_pn_phase) ;

      b_packb( int_ptr->pil_str.meas[i].pilot_strength, buf_ptr, msg_pos,
               FSIZ( MTYPE, var[i].pilot_strength ));
      msg_pos += FSIZ(MTYPE, var[i].pilot_strength) ;

      b_packb( int_ptr->pil_str.meas[i].keep, buf_ptr, msg_pos,
               FSIZ( MTYPE, var[i].keep ));
      msg_pos += FSIZ(MTYPE, var[i].keep) ;

    }

#ifdef FEATURE_IS2000_REL_A_AES
    /* SDU done, call encryption function */
    auth_ext_encrypt_cdma( buf_ptr, &msg_pos, sdu_start_pos,
                           int_ptr->pil_str.hdr.sdu_encrypt_mode,
                           int_ptr->pil_str.hdr.ack_req
                         );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    /* Pack MACI field */
    if (int_ptr->pil_str.hdr.msg_int.maci_incl)
    {
      xlate_int_maci(&msg_pos,
                     buf_ptr,
                     CAI_TC_CRC_SIZE,
                     int_ptr->pil_str.hdr.ack_req,
                     CAIX_TC,
                     int_ptr->pil_str.hdr.msg_int.sdu_key_id,
                     int_ptr->pil_str.msg_type,
                     int_ptr->pil_str.hdr.msg_int.sdu_integrity_algo,
                     &int_ptr->pil_str.hdr.msg_int.maci
                     );
    }
#endif /* FEATURE_IS2000_REL_C */

    /* Set message length */
    *len_ptr = msg_pos;
  }

  #undef MTYPE

  return (status);

} /* xlate_int_pil_str */

/*===========================================================================

FUNCTION XLATE_INT_PWR_MSR

DESCRIPTION
  This function translates a Traffic Channel Power Measurement Report
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_pwr_msr
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_pwr_rpt_type

  #define MTYPE_2000 cai_pwr_rpt_2000_type

  if (int_ptr->pwr_rpt.num_pilots > CAI_PWR_MAX)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------
    ** Pack message
    ** ------------ */

    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->pwr_rpt);

#ifdef FEATURE_IS2000_REL_A_AES
    /* L3 SDU starts here */
    sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packb(int_ptr->pwr_rpt.errors_detected, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.errors_detected));
    msg_pos += FSIZ(MTYPE, fix.errors_detected);

    b_packw(int_ptr->pwr_rpt.pwr_meas_frames, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.pwr_meas_frames));
    msg_pos += FSIZ(MTYPE, fix.pwr_meas_frames);

    b_packb(int_ptr->pwr_rpt.last_hdm_seq, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.last_hdm_seq));
    msg_pos += FSIZ(MTYPE, fix.last_hdm_seq);

    b_packb(int_ptr->pwr_rpt.num_pilots, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.num_pilots));
    msg_pos += FSIZ(MTYPE, fix.num_pilots);

    for (i=0; i < int_ptr->pwr_rpt.num_pilots;i++)
    {
      b_packb(int_ptr->pwr_rpt.pilot_strength[i], buf_ptr, msg_pos,
        FSIZ(MTYPE, var[i].pilot_strength));
      msg_pos += FSIZ(MTYPE, var[i].pilot_strength);
    }

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      b_packb(int_ptr->pwr_rpt.dcch_pwr_meas_incl, buf_ptr, msg_pos,
        FSIZ(MTYPE_2000, dcch_pwr_meas_incl));
      msg_pos += FSIZ(MTYPE_2000, dcch_pwr_meas_incl);

      if (int_ptr->pwr_rpt.dcch_pwr_meas_incl)
      {
        b_packw(int_ptr->pwr_rpt.dcch_pwr_meas_frames, buf_ptr, msg_pos,
          FSIZ(MTYPE_2000, dcch_pwr_meas_frames));
        msg_pos += FSIZ(MTYPE_2000, dcch_pwr_meas_frames);

        b_packb(int_ptr->pwr_rpt.dcch_errors_detected, buf_ptr, msg_pos,
          FSIZ(MTYPE_2000, dcch_errors_detected) );
        msg_pos += FSIZ(MTYPE_2000, dcch_errors_detected);
      }

      b_packb(int_ptr->pwr_rpt.sch_pwr_meas_incl, buf_ptr, msg_pos,
        FSIZ(MTYPE_2000, sch_pwr_meas_incl));
      msg_pos += FSIZ(MTYPE_2000, sch_pwr_meas_incl);

      if (int_ptr->pwr_rpt.sch_pwr_meas_incl)
      {
        b_packb(int_ptr->pwr_rpt.sch_id, buf_ptr, msg_pos,
          FSIZ(MTYPE_2000, sch_id) );
        msg_pos += FSIZ(MTYPE_2000, sch_id);

        b_packw(int_ptr->pwr_rpt.sch_pwr_meas_frames, buf_ptr, msg_pos,
          FSIZ(MTYPE_2000, sch_pwr_meas_frames));
        msg_pos += FSIZ(MTYPE_2000, sch_pwr_meas_frames);

        b_packw(int_ptr->pwr_rpt.sch_errors_detected, buf_ptr, msg_pos,
          FSIZ(MTYPE_2000, sch_errors_detected));
        msg_pos += FSIZ(MTYPE_2000, sch_errors_detected);
      }
    } // if (caix_p_rev_ ..)

#ifdef FEATURE_IS2000_REL_A_AES
    /* SDU done, call encryption function */
    auth_ext_encrypt_cdma( buf_ptr, &msg_pos, sdu_start_pos,
                           int_ptr->pwr_rpt.hdr.sdu_encrypt_mode,
                           int_ptr->pwr_rpt.hdr.ack_req
                         );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    /* Pack MACI field */
    if (int_ptr->pwr_rpt.hdr.msg_int.maci_incl)
    {
      xlate_int_maci(&msg_pos,
                     buf_ptr,
                     CAI_TC_CRC_SIZE,
                     int_ptr->pwr_rpt.hdr.ack_req,
                     CAIX_TC,
                     int_ptr->pwr_rpt.hdr.msg_int.sdu_key_id,
                     int_ptr->pwr_rpt.msg_type,
                     int_ptr->pwr_rpt.hdr.msg_int.sdu_integrity_algo,
                     &int_ptr->pwr_rpt.hdr.msg_int.maci
                     );
    }
#endif /* FEATURE_IS2000_REL_C */

    /* Set message length */
    *len_ptr = msg_pos;
  }  /* else pilot num > ... */

  #undef MTYPE
  #undef MTYPE_2000

  return (status);

} /* xlate_int_pwr_msr */

/*===========================================================================

FUNCTION XLATE_INT_SEND_DTMF

DESCRIPTION
  This function translates a Traffic Channel Send Burst DTMF Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_send_dtmf
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through dtmf digits */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_sbdtmf_type


  /* ------------
  ** Pack message
  ** ------------ */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->sbdtmf);

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->sbdtmf.num_digits, buf_ptr, msg_pos,
    FSIZ(MTYPE, fix.num_digits));
  msg_pos += FSIZ(MTYPE, fix.num_digits);

  b_packb(int_ptr->sbdtmf.dtmf_on_length, buf_ptr, msg_pos,
    FSIZ(MTYPE, fix.dtmf_on_length));
  msg_pos += FSIZ(MTYPE, fix.dtmf_on_length);

  b_packb(int_ptr->sbdtmf.dtmf_off_length, buf_ptr, msg_pos,
    FSIZ(MTYPE, fix.dtmf_off_length));
  msg_pos += FSIZ(MTYPE, fix.dtmf_off_length);

  for (i=0; i < int_ptr->sbdtmf.num_digits; i++)
  {
    b_packb(int_ptr->sbdtmf.digit[i], buf_ptr, msg_pos, FSIZ( MTYPE, var[i]));
    msg_pos += FSIZ( MTYPE, var[i] );
  }
#ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    b_packb(int_ptr->sbdtmf.con_ref_incl, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix2.con_ref_incl));
    msg_pos += FSIZ(MTYPE, fix2.con_ref_incl);

    if (int_ptr->sbdtmf.con_ref_incl)
    {
      b_packb(int_ptr->sbdtmf.con_ref, buf_ptr, msg_pos,
        FSIZ(MTYPE, fix2.con_ref));
      msg_pos +=  FSIZ(MTYPE, fix2.con_ref);
    }
  }

  #ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr, &msg_pos, sdu_start_pos,
                         int_ptr->sbdtmf.hdr.sdu_encrypt_mode,
                         int_ptr->sbdtmf.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->sbdtmf.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->sbdtmf.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->sbdtmf.hdr.msg_int.sdu_key_id,
                   int_ptr->sbdtmf.msg_type,
                   int_ptr->sbdtmf.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->sbdtmf.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  #undef MTYPE

  return (status);

} /* xlate_int_send_dtmf */

/*===========================================================================

FUNCTION XLATE_INT_STATUS

DESCRIPTION
  This function translates a Status Message from internal to external
  format.

DEPENDENCIES
  Depends on the internal message type having the correct number of variable
  record parts.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_status
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word msg_pos = 0;
    /* Position to pack message in */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, of external info rec. */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------
  ** Pack message
  ** ------------ */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->status);

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  status = xlate_int_info_rec((byte*) int_ptr->status.recs, &irec_len,
                              CAI_REV_TC_MSG_BODY_SIZE - msg_pos - 7, /* 7 reserved bits */
                              buf_ptr, msg_pos, &xrec_len);

  if (status == CAIX_DONE_S)
  {
    msg_pos += xrec_len; /* Move to end of info rec */
    //b_packb(0, buf_ptr, msg_pos, 7); /* Add 7 reserved bits */
    //msg_pos += 7;
  }

#ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr, &msg_pos,
                         sdu_start_pos,
                         int_ptr->status.hdr.sdu_encrypt_mode,
                         int_ptr->status.hdr.ack_req
                        );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->status.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->status.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->status.hdr.msg_int.sdu_key_id,
                   int_ptr->status.msg_type,
                   int_ptr->status.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->status.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  return (status);

} /* xlate_int_status */

/*===========================================================================

FUNCTION XLATE_INT_ORIG_C

DESCRIPTION
  This function translates an Origination Continuation Message from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_orig_c
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index through dialed digits */
  word msg_pos = 0;
    /* Position to pack field in buffer */
  word j;
    /* Index to loop through characters */
  byte *rec_ptr;
    /* Pointer to internal format information record */

  word start_enc_pos;
    /* Start point of fields that might require encryption using CMEA */

  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_orig_c_type

  /* -------------------------------------------------------------------
  ** Make sure that number of digits in msg does not exceed valid limits
  ** ------------------------------------------------------------------- */
  if (int_ptr->orig_c.num_fields > CAI_ORIG_C_MAX)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->orig_c);

#ifdef FEATURE_IS2000_REL_A_AES
   /* L3 SDU starts here */
   sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

   b_packb(int_ptr->orig_c.digit_mode, buf_ptr, msg_pos,
     FSIZ(MTYPE, fix.digit_mode));
   msg_pos += FSIZ(MTYPE, fix.digit_mode);

   b_packb(int_ptr->orig_c.num_fields, buf_ptr, msg_pos,
     FSIZ(MTYPE, fix.num_fields));
   msg_pos += FSIZ(MTYPE, fix.num_fields);

   for (i=0; i < int_ptr->orig_c.num_fields; i++)
   {
     if (int_ptr->orig_c.digit_mode)
     {
       /* --------------------
       ** Pack digits in ASCII
       ** -------------------- */
       b_packb(int_ptr->orig_c.chari[i], buf_ptr, msg_pos,
         FSIZ(cai_orig_c_var_type, digit8));
       msg_pos += FSIZ(cai_orig_c_var_type, digit8);
     }
     else
     {
       /* ---------------------
       ** Pack digits in 4 bits
       ** --------------------- */
       b_packb(int_ptr->orig_c.chari[i], buf_ptr, msg_pos,
         FSIZ(cai_orig_c_var_type, digit4));
       msg_pos += FSIZ(cai_orig_c_var_type, digit4);
     }
   } /* for */


   if (int_ptr->orig_c.hdr.encryption == CAI_ENCRYPT_CALL_CTL_MSGS &&
       int_ptr->orig_c.num_fields > 0)
   {
     /* We've finished with digits, now its time to encrypt them */
     auth_encrypt_orig_c(&msg_pos, buf_ptr, int_ptr);
   }
   start_enc_pos = msg_pos;



   rec_ptr = (byte*)(&int_ptr->orig_c.recs[0]);

   for (i=0; (i < int_ptr->orig_c.num_recs) && (status == CAIX_DONE_S); i++)
   {
     /* ----------------------------------------------------
     ** Check to make sure that there is room for the header
     ** ---------------------------------------------------- */
     if ((msg_pos + sizeof( cai_rec_hdr_type )) > CAI_REV_TC_MSG_BODY_SIZE)
     {
       status = CAIX_INV_LEN_S;
     }
     else
     {
       b_packb(((caii_rec_hdr_type *) rec_ptr)->record_type,
         buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_type));
       msg_pos += FSIZ( cai_rec_hdr_type, record_type);

       switch (((caii_rec_hdr_type *) rec_ptr)->record_type)
       {
         /* -------------------------------------------
         ** Called Party Subaddress Informatin Record
         ** Calling Party Subaddress Informatin Record
         ** Connected Subaddress Informatin Record
         ** ------------------------------------------- */
         case CAI_REV_CALLED_SUB_REC:
         case CAI_REV_CALLING_SUB_REC:
           /* ----------------------------------------------------
           ** RECORD_LEN = Number of CHARI fields + 1 (8 bits)
           ** ---------------------------------------------------- */
           b_packb((byte) (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char + 1),
             buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len));
           msg_pos += FSIZ(cai_rec_hdr_type, record_len);

           if ((msg_pos + sizeof( cai_subaddr_fix_type ) +
               (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char *
                FSIZ( cai_subaddr_var_type, chari ))) > CAI_REV_TC_MSG_BODY_SIZE)
           {
             status = CAIX_INV_LEN_S;
           }
           else
           {
             b_packb(((caii_subaddr_rec_type *) rec_ptr)->fix.extension_bit,
               buf_ptr, msg_pos, FSIZ(cai_subaddr_fix_type, extension_bit));
             msg_pos += FSIZ(cai_subaddr_fix_type, extension_bit);

             b_packb(((caii_subaddr_rec_type *)rec_ptr)->fix.subadd_type,
               buf_ptr, msg_pos, FSIZ(cai_subaddr_fix_type, subadd_type));
             msg_pos += FSIZ(cai_subaddr_fix_type, subadd_type);

             b_packb(((caii_subaddr_rec_type *)rec_ptr)->fix.odd_even_ind,
               buf_ptr, msg_pos, FSIZ(cai_subaddr_fix_type, odd_even_ind));
             msg_pos += FSIZ(cai_subaddr_fix_type, odd_even_ind);

             /* -----------------------
             ** Pack 0 for reserved bit
             ** ----------------------- */
             b_packb(0, buf_ptr, msg_pos, 3);
             msg_pos += 3;

             for (j=0; j < ((caii_subaddr_rec_type *) rec_ptr)->fix.num_char; j++)
             {
               b_packb(((caii_subaddr_rec_type *) rec_ptr)->var[j], buf_ptr,
                 msg_pos, FSIZ(cai_subaddr_var_type, chari));
               msg_pos += FSIZ(cai_subaddr_var_type, chari);
             }

             if (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char == 0)
             {
               rec_ptr += FSIZ(caii_subaddr_rec_type, fix ); /*lint !e662 */
             }
             else
             {
               rec_ptr += FENDPOS(caii_subaddr_rec_type,
                 var[((caii_subaddr_rec_type *) rec_ptr)->fix.num_char - 1]);
             }
           }
           break;

         case CAI_REV_CALLING_REC:
           /* -----------------------------------------------------
           ** RECORD_LEN = Number of CHARI fields + 2 (16 bits) for
           ** NUMBER_TYPE, NUMBER_PLAN, PI, SI and RESERVED fields
           ** ----------------------------------------------------- */
           b_packb((byte) (((caii_calling_rec_type *) rec_ptr)->fix.num_char + 2),
             buf_ptr, msg_pos, FSIZ(cai_rec_hdr_type, record_len));
           msg_pos += FSIZ(cai_rec_hdr_type, record_len);

           if ((msg_pos + sizeof( cai_calling_fix_type ) +
               (((caii_calling_rec_type *) rec_ptr)->fix.num_char *
                FSIZ( cai_calling_var_type, chari )) + 5) > CAI_REV_TC_MSG_BODY_SIZE)
           {
             status = CAIX_INV_LEN_S;
           }
           else
           {
             b_packb(((caii_calling_rec_type *) rec_ptr)->fix.number_type,
               buf_ptr, msg_pos, FSIZ(cai_calling_fix_type, number_type));
             msg_pos += FSIZ(cai_calling_fix_type, number_type);

             b_packb(((caii_calling_rec_type *) rec_ptr)->fix.number_plan,
               buf_ptr, msg_pos, FSIZ(cai_calling_fix_type, number_plan));
             msg_pos += FSIZ(cai_calling_fix_type, number_plan);

             b_packb(((caii_calling_rec_type *) rec_ptr)->fix.pi,
               buf_ptr, msg_pos, FSIZ( cai_calling_fix_type, pi));
             msg_pos += FSIZ(cai_calling_fix_type, pi);

             b_packb(((caii_calling_rec_type *) rec_ptr)->fix.si,
               buf_ptr, msg_pos, FSIZ(cai_calling_fix_type, si));
             msg_pos += FSIZ(cai_calling_fix_type, si);

             for (j=0; j < ((caii_calling_rec_type *) rec_ptr)->fix.num_char; j++)
             {
               b_packb(((caii_calling_rec_type *) rec_ptr)->var[j],
                 buf_ptr, msg_pos, FSIZ( cai_calling_var_type, chari));
                msg_pos += FSIZ(cai_calling_var_type, chari);
             }

             /* ------------------------
             ** Pack 0 for reserved bits
             ** ------------------------ */
             b_packb(0, buf_ptr, msg_pos, 5);
             msg_pos += 5;

             if (((caii_calling_rec_type *) rec_ptr)->fix.num_char == 0)
             {
               rec_ptr += FSIZ(caii_calling_rec_type, fix); /*lint !e662 */
             }
             else
             {
               rec_ptr += FENDPOS(caii_calling_rec_type,
                 var[((caii_calling_rec_type *) rec_ptr)->fix.num_char - 1]);
             }
           }
           break;

         default:
           status = CAIX_INV_MSG_S;
           break;
       } /* end switch (((caii_rec_hdr_type *) rec_ptr)->record_type) */

       rec_ptr = (byte*)ALIGN_DWORD(((dword)rec_ptr));
     }
   } /* end for loop */


   /* This is the encryption of the info record part. */
   if (int_ptr->orig_c.num_recs > 0 &&
       int_ptr->orig_c.hdr.encryption == CAI_ENCRYPT_CALL_CTL_MSGS)
   {
     auth_encrypt_info_recs(&msg_pos, buf_ptr, int_ptr,
       start_enc_pos, int_ptr->orig_c.num_recs );
   }


#ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
   auth_ext_encrypt_cdma( buf_ptr,
                          &msg_pos,
                          sdu_start_pos,
                          int_ptr->orig_c.hdr.sdu_encrypt_mode,
                          int_ptr->orig_c.hdr.ack_req
                        );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
   /* Pack MACI field */
   if (int_ptr->orig_c.hdr.msg_int.maci_incl)
   {
     xlate_int_maci(&msg_pos,
                    buf_ptr,
                    CAI_TC_CRC_SIZE,
                    int_ptr->orig_c.hdr.ack_req,
                    CAIX_TC,
                    int_ptr->orig_c.hdr.msg_int.sdu_key_id,
                    int_ptr->orig_c.msg_type,
                    int_ptr->orig_c.hdr.msg_int.sdu_integrity_algo,
                    &int_ptr->orig_c.hdr.msg_int.maci
                    );
   }
#endif /* FEATURE_IS2000_REL_C */

   /* -------------------------
   ** Fill in length of message
   ** ------------------------- */
   *len_ptr = msg_pos;

  }

  #undef MTYPE

  return (status);

} /*xlate_int_orig_c */

/*===========================================================================

FUNCTION XLATE_INT_COMP

DESCRIPTION
  This function translates a Handoff Completion Message from internal to
  external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_comp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through pilots */
  word msg_pos = 0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_comp_type

  /* --------------------------------------
  ** Make sure message is of minimum length
  ** -------------------------------------- */
  if (int_ptr->comp.num_pilots == 0)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------
    ** Pack message
    ** ------------ */

    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->comp);

#ifdef FEATURE_IS2000_REL_A_AES
    /* L3 SDU starts here */
    sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packb(int_ptr->comp.last_hdm_seq, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.last_hdm_seq));
    msg_pos += FSIZ(MTYPE, fix.last_hdm_seq);

    for (i=0; i < int_ptr->comp.num_pilots; i++)
    {
      b_packw(int_ptr->comp.pilot_pn[i], buf_ptr, msg_pos,
        FSIZ(MTYPE, var[i].pilot_pn));
      msg_pos += FSIZ(MTYPE, var[i].pilot_pn);
    }

#ifdef FEATURE_IS2000_REL_A_AES
    /* SDU done, call encryption function */
    auth_ext_encrypt_cdma( buf_ptr, &msg_pos,
                           sdu_start_pos,
                           int_ptr->comp.hdr.sdu_encrypt_mode,
                           int_ptr->comp.hdr.ack_req
                         );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    /* Pack MACI field */
    if (int_ptr->comp.hdr.msg_int.maci_incl)
    {
      xlate_int_maci(&msg_pos,
                     buf_ptr,
                     CAI_TC_CRC_SIZE,
                     int_ptr->comp.hdr.ack_req,
                     CAIX_TC,
                     int_ptr->comp.hdr.msg_int.sdu_key_id,
                     int_ptr->comp.msg_type,
                     int_ptr->comp.hdr.msg_int.sdu_integrity_algo,
                     &int_ptr->comp.hdr.msg_int.maci
                     );
    }
#endif /* FEATURE_IS2000_REL_C */

    /* Set message length */
    *len_ptr = msg_pos;

  } /* else for the length check */

  #undef MTYPE

  return (status);

} /* xlate_int_comp */

/*===========================================================================

FUNCTION XLATE_INT_PARM_RSP

DESCRIPTION
  This function translates a Parameters Response Message from internal to
  external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_parm_rsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through parameters */
  word buf_pos = 0;
    /* Position in message in which to pack next field */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_parm_rsp_type

  /* --------------------------------------
  ** Make sure message is of minimum length
  ** -------------------------------------- */
  if (int_ptr->parm_rsp.num_parms == 0)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&buf_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->parm_rsp);

#ifdef FEATURE_IS2000_REL_A_AES
    /* L3 SDU starts here */
    sdu_start_pos = buf_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

    /* ------------------------
    ** Pack array of parameters
    ** ------------------------ */
    for (i=0; i < int_ptr->parm_rsp.num_parms; i++)
    {
      b_packw(int_ptr->parm_rsp.parms[i].parameter_id, buf_ptr,
        buf_pos, FSIZ(MTYPE, var.parameter_id));
      buf_pos += FSIZ(MTYPE, var.parameter_id);

      b_packw(int_ptr->parm_rsp.parms[i].parameter_len, buf_ptr,
        buf_pos, FSIZ(MTYPE, var.parameter_len));
      buf_pos += FSIZ(MTYPE, var.parameter_len);

      /* ---------------------------------------------------------
      ** If parameter_len = '11 1111 1111' this is an unsupported
      ** or unrecognized parameter, so we omit the PARAMETER field
      ** (See IS-95A 6.7.2.3.2.11).
      ** --------------------------------------------------------- */
      if (int_ptr->parm_rsp.parms[i].parameter_len != 0x3ff)
      {
        if (int_ptr->parm_rsp.parms[i].parameter_len > 31)
        {
          b_packq(int_ptr->parm_rsp.parms[i].parameter.parm_q,
            buf_ptr, buf_pos, int_ptr->parm_rsp.parms[i].parameter_len + 1);
        }
        else if (int_ptr->parm_rsp.parms[i].parameter_len > 15)
        {
          b_packd(int_ptr->parm_rsp.parms[i].parameter.parm_d,
            buf_ptr, buf_pos, int_ptr->parm_rsp.parms[i].parameter_len + 1);
        }
        else if (int_ptr->parm_rsp.parms[i].parameter_len > 7)
        {
          b_packw(int_ptr->parm_rsp.parms[i].parameter.parm_w,
            buf_ptr, buf_pos, int_ptr->parm_rsp.parms[i].parameter_len + 1);
        }
        else
        {
          b_packb(int_ptr->parm_rsp.parms[i].parameter.parm_b,
            buf_ptr, buf_pos, int_ptr->parm_rsp.parms[i].parameter_len + 1);
        }

        /* -----------------------------------------
        ** Adjust buffer position for next parameter
        ** ----------------------------------------- */
        buf_pos += int_ptr->parm_rsp.parms[i].parameter_len + 1;

      } /* end if (supported parameter) */
    } /* for */

#ifdef FEATURE_IS2000_REL_A_AES
       /* SDU done, call encryption function */
    auth_ext_encrypt_cdma( buf_ptr,
                           &buf_pos,
                           sdu_start_pos,
                           int_ptr->parm_rsp.hdr.sdu_encrypt_mode,
                           int_ptr->parm_rsp.hdr.ack_req
                         );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    /* Pack MACI field */
    if (int_ptr->parm_rsp.hdr.msg_int.maci_incl)
    {
      xlate_int_maci(&buf_pos,
                     buf_ptr,
                     CAI_TC_CRC_SIZE,
                     int_ptr->parm_rsp.hdr.ack_req,
                     CAIX_TC,
                     int_ptr->parm_rsp.hdr.msg_int.sdu_key_id,
                     int_ptr->parm_rsp.msg_type,
                     int_ptr->parm_rsp.hdr.msg_int.sdu_integrity_algo,
                     &int_ptr->parm_rsp.hdr.msg_int.maci
                     );
    }
#endif /* FEATURE_IS2000_REL_C */

  }  /* else for the message length check */

  *len_ptr = buf_pos;

  #undef MTYPE

  return (status);

} /* xlate_int_parm_rsp */

/*===========================================================================

FUNCTION XLATE_INT_SRV_REQ

DESCRIPTION
  This function translates a Service Request Message from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_srv_req
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word cfg_len;
    /* To receive length of imbedded service config record. */
  word msg_pos = 0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos = 0;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_rtc_srv_req_fix_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->srv_req);

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->srv_req.req_seq, buf_ptr, msg_pos, FSIZ(MTYPE, req_seq));
  msg_pos += FSIZ(MTYPE, req_seq);

  b_packb(int_ptr->srv_req.purp, buf_ptr, msg_pos, FSIZ(MTYPE, purp));
  msg_pos += FSIZ(MTYPE, purp);

  if (int_ptr->srv_req.purp == CAI_SRV_PRO_PURP)
  {
    status = xlate_int_srv_cfg(&cfg_len, buf_ptr, msg_pos, &int_ptr->srv_req.cfg);
    if ( status == CAIX_DONE_S )
    {
      msg_pos += cfg_len;
    }
  }

#ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr, &msg_pos,
                         sdu_start_pos,
                         int_ptr->srv_req.hdr.sdu_encrypt_mode,
                         int_ptr->srv_req.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->srv_req.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->srv_req.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->srv_req.hdr.msg_int.sdu_key_id,
                   int_ptr->srv_req.msg_type,
                   int_ptr->srv_req.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->srv_req.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_srv_req */

/*===========================================================================

FUNCTION XLATE_INT_SRV_RSP

DESCRIPTION
  This function translates a Service Response Message from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_srv_rsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be translated */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word cfg_len;
    /* To receive length of imbedded service config record. */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_rtc_srv_rsp_fix_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->srv_rsp);

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->srv_rsp.req_seq, buf_ptr, msg_pos, FSIZ(MTYPE,  req_seq));
  msg_pos += FSIZ(MTYPE, req_seq);

  b_packb(int_ptr->srv_rsp.purp, buf_ptr, msg_pos, FSIZ( MTYPE,  purp));
  msg_pos += FSIZ(MTYPE, purp);

  if (int_ptr->srv_rsp.purp == CAI_SRV_PRO_PURP)
  {
    status = xlate_int_srv_cfg(&cfg_len, buf_ptr, msg_pos, &int_ptr->srv_rsp.cfg);

    if ( status == CAIX_DONE_S )
    {
      msg_pos += cfg_len;
      /* If service config record translation successful, add in
         length of configuration record */
    }
  }

#ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->srv_rsp.hdr.sdu_encrypt_mode,
                         int_ptr->srv_rsp.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->srv_rsp.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->srv_rsp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->srv_rsp.hdr.msg_int.sdu_key_id,
                   int_ptr->srv_rsp.msg_type,
                   int_ptr->srv_rsp.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->srv_rsp.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_srv_rsp */

/*===========================================================================

FUNCTION XLATE_INT_SRV_CMP

DESCRIPTION
  This function translates a Service Connect Completion Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_srv_cmp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
  /* Status to be returned to calling procedure */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_srv_cmp_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->srv_cmp);

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(0, buf_ptr, msg_pos, FSIZ( MTYPE, reserved1));
  msg_pos += FSIZ(MTYPE, reserved1);

  b_packb(int_ptr->srv_cmp.con_seq, buf_ptr, msg_pos,
    FSIZ(MTYPE, con_seq));
  msg_pos += FSIZ(MTYPE, con_seq);

  /* No need to pad here, it is done in TXC or in int_maci as needed */
  //b_packb(0, buf_ptr, msg_pos, FSIZ(cai_srv_cmp_type, reserved));
  //msg_pos += FSIZ(cai_srv_cmp_type, reserved);

#ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->srv_cmp.hdr.sdu_encrypt_mode,
                         int_ptr->srv_cmp.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->srv_cmp.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->srv_cmp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->srv_cmp.hdr.msg_int.sdu_key_id,
                   int_ptr->srv_cmp.msg_type,
                   int_ptr->srv_cmp.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->srv_cmp.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

return (status);

} /* xlate_int_srv_cmp */

/*===========================================================================

FUNCTION XLATE_INT_SRV_CTL

DESCRIPTION
  This function translates a Service Option Control Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_srv_ctl
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word  status = CAIX_DONE_S;
    /* For returning status to caller */
  word  i;
    /* For indexing through type specific fields */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_rtc_srv_ctl_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->srv_ctl);

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->srv_ctl.con_ref, buf_ptr, msg_pos, FSIZ(MTYPE, fix.con_ref));
  msg_pos += FSIZ(MTYPE, fix.con_ref);

  b_packw(int_ptr->srv_ctl.so, buf_ptr, msg_pos, FSIZ(MTYPE, fix.so));
  msg_pos += FSIZ(MTYPE, fix.so);

  b_packb(0, buf_ptr, msg_pos, FSIZ(MTYPE, fix.reserved));
  msg_pos += FSIZ(MTYPE, fix.reserved);

  b_packb(int_ptr->srv_ctl.tsf_len, buf_ptr, msg_pos, FSIZ(MTYPE, fix.tsf_len));
  msg_pos += FSIZ(MTYPE, fix.tsf_len);

  /* Translate type specific fields portion of message */
  for (i = 0; i < int_ptr->srv_ctl.tsf_len; i++)
  {
    b_packb(int_ptr->srv_ctl.tsf[i],
      buf_ptr, msg_pos, FSIZ(MTYPE, var[i].tsf));
    msg_pos += FSIZ(MTYPE, var[i].tsf);
  }

  *len_ptr = msg_pos; /* Compute message length */

#ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->srv_ctl.hdr.sdu_encrypt_mode,
                         int_ptr->srv_ctl.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->srv_ctl.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->srv_ctl.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->srv_ctl.hdr.msg_int.sdu_key_id,
                   int_ptr->srv_ctl.msg_type,
                   int_ptr->srv_ctl.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->srv_ctl.hdr.msg_int.maci
                  );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_srv_ctl */

/*===========================================================================

FUNCTION XLATE_INT_TC_STRSP

DESCRIPTION
  This function translates a Reverse Traffic Channel Status Response Message
  from internal to external format.

DEPENDENCIES
  Depends on the internal message type having the correct number of variable
  record parts.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_strsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->tc_strsp);

#ifdef FEATURE_IS2000_REL_A_AES
    /* L3 SDU starts here */
    sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  /* Translate other message fields */
  b_packb(int_ptr->tc_strsp.qual, buf_ptr, msg_pos,
    FSIZ(cai_tc_strsp_fix_type, qual_typ));
  msg_pos += FSIZ(cai_tc_strsp_fix_type, qual_typ);

  if (int_ptr->tc_strsp.qual == CAI_NO_QUAL)
  {
    b_packb(0, buf_ptr, msg_pos, FSIZ(cai_tc_strsp_fix_type, qual_len));
    msg_pos += FSIZ(cai_tc_strsp_fix_type, qual_len);
  }
  else if (int_ptr->tc_strsp.qual == CAI_BAND_QUAL)
  {
    b_packb(sizeof(cai_qual_info1_type) / 8,
      buf_ptr, msg_pos, FSIZ(cai_tc_strsp_fix_type, qual_len));
    msg_pos += FSIZ(cai_tc_strsp_fix_type, qual_len);

    b_packb(int_ptr->tc_strsp.band, buf_ptr, msg_pos,
    FSIZ(cai_qual_info1_type, band));
    msg_pos += FSIZ(cai_qual_info1_type, band);

    b_packb(0, buf_ptr, msg_pos, FSIZ(cai_qual_info1_type, reserved));
    msg_pos += FSIZ(cai_qual_info1_type, reserved);
  }
  else if (int_ptr->tc_strsp.qual == CAI_BAND_OP_MODE_QUAL)
  {
    b_packb(sizeof(cai_qual_info2_type) / 8, buf_ptr, msg_pos,
    FSIZ(cai_tc_strsp_fix_type, qual_len));
    msg_pos += FSIZ(cai_tc_strsp_fix_type, qual_len);

    b_packb(int_ptr->tc_strsp.band, buf_ptr, msg_pos,
    FSIZ(cai_qual_info2_type, band));
    msg_pos += FSIZ(cai_qual_info2_type, band);

    b_packb(int_ptr->tc_strsp.op_mode, buf_ptr, msg_pos,
    FSIZ(cai_qual_info2_type, op_mode));
    msg_pos += FSIZ(cai_qual_info2_type, op_mode);

    b_packb(0, buf_ptr, msg_pos, FSIZ(cai_qual_info2_type, reserved));
    msg_pos += FSIZ(cai_qual_info2_type, reserved);
  }
  else
  {
    return (CAIX_INV_MSG_S); /* Unknown qual info type */
  }

  /* Translate info recs */
  for (i = irec_pos = 0; (i < int_ptr->tc_strsp.num_recs); i++)
  {
    if((irec_pos/4) < CAII_MAX_INFO_REC_DWORDS)
    {
      status = xlate_int_info_rec((byte*) (&int_ptr->tc_strsp.recs[irec_pos/4]), &irec_len,
                                  (word) (CAI_REV_TC_MSG_BODY_SIZE - msg_pos - FSIZ( cai_tc_strsp_fix_type, reserved)),
                                  buf_ptr, msg_pos, &xrec_len );
    }

    if (status != CAIX_DONE_S)
    {
      return (status);
    }

    msg_pos  += xrec_len; /* Advance external message position */
    irec_pos += irec_len; /* Advance internal message position */
    /* The next record will start only on a dword boundary, so move positions accordingly */

    irec_pos = (irec_pos%4) ? (irec_pos+(sizeof(dword))-irec_pos%4) : irec_pos;

  } /* for */


#ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->tc_strsp.hdr.sdu_encrypt_mode,
                         int_ptr->tc_strsp.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->tc_strsp.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->tc_strsp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->tc_strsp.hdr.msg_int.sdu_key_id,
                   int_ptr->tc_strsp.msg_type,
                   int_ptr->tc_strsp.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->tc_strsp.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos; /* Set length of message */

  return (status);

} /* xlate_int_tc_strsp() */

/*===========================================================================

FUNCTION XLATE_INT_TC_SC_REQ

DESCRIPTION
  This function translates a Supplemental Channel Request Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_sc_req
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  word i;
    /* For indexing through info recs */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_A
  byte reserve_bits;
  word rec_len_pos;
  word rec_start_pos;
#endif /* FEATURE_IS2000_REL_A */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_scrm_fix_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->scrm );

  b_packb(int_ptr->scrm.sz_req_blob, buf_ptr, msg_pos, FSIZ(MTYPE, sz_req_blob));
  msg_pos += FSIZ(MTYPE, sz_req_blob);

#ifdef FEATURE_IS2000_REL_A_AES
    /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  for (i=0; i<int_ptr->scrm.sz_req_blob; i++)
  {
    b_packb(int_ptr->scrm.req_blob[i],buf_ptr, msg_pos,
    FSIZ(cai_scrm_var1_type, req_blob_data));
    msg_pos += FSIZ(cai_scrm_var1_type, req_blob_data);
  }

  b_packb(int_ptr->scrm.use_scrm_seq_num, buf_ptr, msg_pos,
    FSIZ(cai_scrm_fix_type, use_scrm_seq_num));
  msg_pos += FSIZ(cai_scrm_fix_type, use_scrm_seq_num);

  if ( int_ptr->scrm.use_scrm_seq_num )
  {
    b_packb(int_ptr->scrm.scrm_seq_num, buf_ptr, msg_pos,
    FSIZ(cai_scrm_fix_type, scrm_seq_num));
    msg_pos += FSIZ(cai_scrm_fix_type, scrm_seq_num);
  }

  if ((int_ptr->scrm.use_scrm_seq_num != 0 ) ||
       (int_ptr->scrm.sz_req_blob != 0))
  {
    b_packw(int_ptr->scrm.ref_pn, buf_ptr, msg_pos,
    FSIZ(cai_scrm_fix_type, ref_pn));
    msg_pos += FSIZ(cai_scrm_fix_type, ref_pn);

    b_packb(int_ptr->scrm.pilot_str, buf_ptr, msg_pos,
    FSIZ(cai_scrm_fix_type, pilot_str));
    msg_pos += FSIZ(cai_scrm_fix_type, pilot_str);

    b_packb(int_ptr->scrm.num_act_pn, buf_ptr, msg_pos,
    FSIZ(cai_scrm_fix_type, num_act_pn));
    msg_pos += FSIZ(cai_scrm_fix_type, num_act_pn);

    for (i=0; i<int_ptr->scrm.num_act_pn; i++)
    {
      b_packw(int_ptr->scrm.act_pn[i].pn_phase, buf_ptr, msg_pos,
      FSIZ(cai_scrm_var2_type, act_pn_phase));
      msg_pos += FSIZ(cai_scrm_var2_type, act_pn_phase);

      b_packb(int_ptr->scrm.act_pn[i].pn_strength, buf_ptr, msg_pos,
      FSIZ(cai_scrm_var2_type, act_pn_str));
      msg_pos += FSIZ(cai_scrm_var2_type, act_pn_str);
    }

    b_packb(int_ptr->scrm.num_nghbr_pn, buf_ptr, msg_pos,
    FSIZ(cai_scrm_fix_type, num_nghbr_pn));
    msg_pos += FSIZ(cai_scrm_fix_type, num_nghbr_pn);

    for (i=0; i<int_ptr->scrm.num_nghbr_pn; i++)
    {
      b_packw(int_ptr->scrm.nghbr_pn[i].pn_phase, buf_ptr, msg_pos,
      FSIZ(cai_scrm_var3_type, nghbr_pn_phase));
      msg_pos += FSIZ(cai_scrm_var3_type, nghbr_pn_phase);

      b_packb(int_ptr->scrm.nghbr_pn[i].pn_strength, buf_ptr, msg_pos,
        FSIZ(cai_scrm_var3_type, nghbr_pn_str));
      msg_pos += FSIZ(cai_scrm_var3_type, nghbr_pn_str);
    }
  }

  #ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    if ((int_ptr->scrm.use_scrm_seq_num != 0 ) ||
        (int_ptr->scrm.sz_req_blob != 0))
    {
      b_packb(int_ptr->scrm.ref_pil_rec.pilot_rec_incl, buf_ptr, msg_pos,
        FSIZ(cai_scrm_fix2_type, ref_pilot_rec_incl));
      msg_pos += FSIZ(cai_scrm_fix2_type, ref_pilot_rec_incl);

      if (int_ptr->scrm.ref_pil_rec.pilot_rec_incl)
      {
        /* at this point we can only pack auxilary pilot */
        /* note that Auxiliary pilot rec type is defined as 1 in caii.h
           but here it needs to be packed as 0 */

        b_packb(0, buf_ptr, msg_pos,
          FSIZ(cai_scrm_fix2_type, ref_pilot_rec_type));
        msg_pos += FSIZ(cai_scrm_fix2_type, ref_pilot_rec_type);

        rec_len_pos = msg_pos;

        msg_pos += FSIZ(cai_scrm_fix2_type, ref_record_len);

        rec_start_pos = msg_pos;

        /*  pack the reference pilot if it's auxiliary */
        if (int_ptr->scrm.ref_pil_rec.pilot_rec_type == 0)
        {
          b_packb(int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.qof, buf_ptr, msg_pos,
            FSIZ(cai_add_pilot_rec1_type, qof));
          msg_pos += FSIZ(cai_add_pilot_rec1_type, qof);

          b_packb(int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.walsh_length, buf_ptr, msg_pos,
            FSIZ(cai_add_pilot_rec1_type, walsh_length));
          msg_pos += FSIZ(cai_add_pilot_rec1_type, walsh_length);

          /* if the aux walsh is less than 3, pack a byte */
          b_packw(int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.aux_pilot_walsh, buf_ptr, msg_pos,
            int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.walsh_length + 6);
          msg_pos += int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.walsh_length + 6;

          /* length of reserved bits */
          reserve_bits = (sizeof(cai_add_pilot_rec1_type ) +
            int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.walsh_length) %8;
          if (reserve_bits != 0)
          {
            reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
            b_packb(0, buf_ptr, msg_pos, reserve_bits);
            msg_pos += reserve_bits;
          }

          b_packb((msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
            FSIZ(cai_scrm_fix2_type, ref_record_len));
        }
      }
      /* now pack num act pn pilots */
      for (i=0; i < int_ptr->scrm.num_act_pn ; i++)
      {
        b_packb(int_ptr->scrm.act_pil_rec[i].pilot_rec_incl, buf_ptr, msg_pos,
          FSIZ(cai_scrm_fix0_type, pilot_rec_incl));
        msg_pos += FSIZ(cai_scrm_fix0_type, pilot_rec_incl);

        if (int_ptr->scrm.act_pil_rec[i].pilot_rec_incl)
        {
          b_packb(0, buf_ptr, msg_pos, FSIZ(cai_scrm_fix1_type, pilot_rec_type));
          msg_pos += FSIZ(cai_scrm_fix1_type, pilot_rec_type);

          rec_len_pos = msg_pos;

          msg_pos += FSIZ(cai_scrm_fix1_type, record_len);

          rec_start_pos = msg_pos;

          if (int_ptr->scrm.act_pil_rec[i].pilot_rec_type == 0)
          {
            b_packb(int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.qof, buf_ptr, msg_pos,
              FSIZ(cai_add_pilot_rec1_type,qof));
            msg_pos += FSIZ(cai_add_pilot_rec1_type, qof);

            b_packb(int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.walsh_length, buf_ptr, msg_pos,
              FSIZ(cai_add_pilot_rec1_type,walsh_length));
            msg_pos += FSIZ(cai_add_pilot_rec1_type, walsh_length);

            /* if the aux walsh is less than 3, pack a byte */
            b_packw(int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.aux_pilot_walsh, buf_ptr,
              msg_pos, int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.walsh_length + 6);
            msg_pos += int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.walsh_length + 6;

            /* length of reserved bits */
            reserve_bits = (sizeof(cai_add_pilot_rec1_type) +
              int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.walsh_length) %8;

            if (reserve_bits != 0)
            {
              reserve_bits = 8 - reserve_bits;

              /* Pack reserved bits */
              b_packb(0, buf_ptr, msg_pos, reserve_bits);
              msg_pos += reserve_bits;
            }

            b_packb((msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
              FSIZ(cai_scrm_fix1_type, record_len));
          }
        }
      }
      /* finally pack num nghbr pilots */
      for (i=0; i<int_ptr->scrm.num_nghbr_pn ; i++)
      {
        b_packb(int_ptr->scrm.nghbr_pil_rec[i].pilot_rec_incl,
          buf_ptr, msg_pos, FSIZ(cai_scrm_fix0_type, pilot_rec_incl));
        msg_pos += FSIZ(cai_scrm_fix0_type, pilot_rec_incl);

        if (int_ptr->scrm.nghbr_pil_rec[i].pilot_rec_incl)
        {
          b_packb(0, buf_ptr, msg_pos, FSIZ(cai_scrm_fix1_type, pilot_rec_type));
          msg_pos += FSIZ(cai_scrm_fix1_type, pilot_rec_type);

          rec_len_pos = msg_pos;

          msg_pos += FSIZ(cai_scrm_fix1_type, record_len);

          rec_start_pos = msg_pos;

          if (int_ptr->scrm.nghbr_pil_rec[i].pilot_rec_type == 0)
          {
            b_packb(int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.qof,
              buf_ptr, msg_pos, FSIZ(cai_add_pilot_rec1_type,qof));
            msg_pos += FSIZ(cai_add_pilot_rec1_type, qof);

            b_packb(int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.walsh_length, buf_ptr,
              msg_pos, FSIZ(cai_add_pilot_rec1_type,walsh_length));
            msg_pos += FSIZ(cai_add_pilot_rec1_type,walsh_length);

            /* if the aux walsh is less than 3, pack a byte */
            b_packw(int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.aux_pilot_walsh, buf_ptr,
              msg_pos, int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.walsh_length + 6);
            msg_pos += int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.walsh_length + 6;

            /* length of reserved bits */
            reserve_bits = (sizeof(cai_add_pilot_rec1_type) +
              int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.walsh_length) %8;

            if( reserve_bits != 0 )
            {
              reserve_bits = 8 - reserve_bits;

              /* Pack reserved bits */
              b_packb(0, buf_ptr, msg_pos, reserve_bits);
              msg_pos += reserve_bits;
            }

            b_packb((msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
              FSIZ(cai_scrm_fix1_type, record_len));
          }
        }
      }
    }
  } /* prev >=7 ... */
  #endif /* FEATURE_IS2000_REL_A */


  #ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->scrm.hdr.sdu_encrypt_mode,
                         int_ptr->scrm.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

  #ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->scrm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->scrm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->scrm.hdr.msg_int.sdu_key_id,
                   int_ptr->scrm.msg_type,
                   int_ptr->scrm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->scrm.hdr.msg_int.maci
                   );
  }
  #endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_sc_req */

/*===========================================================================

FUNCTION XLATE_INT_TC_CFS_RSP

DESCRIPTION
  This function translates a Candidate Frequency Search Response Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_cfs_rsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
   /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_cfs_rsp_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->cfs_rsp);

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->cfs_rsp.last_cfsrm_seq, buf_ptr, msg_pos, FSIZ(MTYPE, last_cfsrm_seq));
  msg_pos += FSIZ(MTYPE, last_cfsrm_seq);

  b_packb(int_ptr->cfs_rsp.tot_off_tm_fwd, buf_ptr, msg_pos, FSIZ(MTYPE, tot_off_tm_fwd));
  msg_pos += FSIZ(MTYPE, tot_off_tm_fwd );

  b_packb(int_ptr->cfs_rsp.max_off_tm_fwd, buf_ptr, msg_pos, FSIZ(MTYPE, max_off_tm_fwd));
  msg_pos += FSIZ(MTYPE, max_off_tm_fwd );

  b_packb(int_ptr->cfs_rsp.tot_off_tm_rev, buf_ptr, msg_pos, FSIZ(MTYPE, tot_off_tm_rev));
  msg_pos += FSIZ(MTYPE, tot_off_tm_rev );

  b_packb(int_ptr->cfs_rsp.max_off_tm_rev, buf_ptr, msg_pos, FSIZ(MTYPE, max_off_tm_rev));
  msg_pos += FSIZ(MTYPE, max_off_tm_rev );

  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
  {
    #define IS2K_MTYPE cai_cfs_rsp_is2000_type

    #ifdef FEATURE_IS2000_REL_A
    /* at this point because of the encryption fields FPOS (mytpe ) may not
    give the right position, set it to msg_pos */
    byte fpos = (byte) msg_pos;
    #else
    byte fpos = FPOS(MTYPE, reserved);
    #endif /* FEATURE_IS2000_REL_A */

    b_packb(int_ptr->cfs_rsp.pcg_off_times, buf_ptr,
      fpos + FPOS(IS2K_MTYPE, pcg_off_times), FSIZ(IS2K_MTYPE, pcg_off_times));

    b_packb(int_ptr->cfs_rsp.align_timing_used, buf_ptr,
      fpos + FPOS(IS2K_MTYPE, align_timing_used), FSIZ(IS2K_MTYPE, align_timing_used));

    *len_ptr = fpos + FPOS(IS2K_MTYPE, max_num_visits);

    if (int_ptr->cfs_rsp.align_timing_used)
    {
      b_packb(int_ptr->cfs_rsp.max_num_visits, buf_ptr,
        fpos + FPOS(IS2K_MTYPE, max_num_visits), FSIZ(IS2K_MTYPE, max_num_visits));

      if (int_ptr->cfs_rsp.max_num_visits)
      {
        b_packb(int_ptr->cfs_rsp.inter_visit_time, buf_ptr,
          fpos + FPOS(IS2K_MTYPE, inter_visit_time), FSIZ(IS2K_MTYPE, inter_visit_time));
        *len_ptr = fpos + sizeof(IS2K_MTYPE);
      }
      else
      {
        *len_ptr = fpos + FPOS(IS2K_MTYPE, inter_visit_time);
      }
    }

    #undef IS2K_MTYPE

  }
  else
  {
    /* backward compatible */
    b_packb(0, PARAMS(reserved));
    /* Set message length */
    *len_ptr = sizeof(MTYPE);
  }

  #ifdef FEATURE_IS2000_REL_A_AES
  /* now that everything is done call encryption */
  auth_ext_encrypt_cdma( buf_ptr,
                         len_ptr,
                         sdu_start_pos,
                         int_ptr->cfs_rsp.hdr.sdu_encrypt_mode,
                         int_ptr->cfs_rsp.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

  #ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->cfs_rsp.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(len_ptr,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->cfs_rsp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->cfs_rsp.hdr.msg_int.sdu_key_id,
                   int_ptr->cfs_rsp.msg_type,
                   int_ptr->cfs_rsp.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->cfs_rsp.hdr.msg_int.maci
                   );
  }
  #endif /* FEATURE_IS2000_REL_C */

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_cfs_rsp */

/*===========================================================================

FUNCTION xlate_int_tc_cfs_rpt

DESCRIPTION
  This function translates a Candidate Frequency Search Response Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_cfs_rpt
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word rec_pos;
    /* For indexing through info rec bytes */
  word info_rec_len_pos;
    /* where the length info is written for recs */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_A
  word rec_len_pos;
  /* position where the length info needs to be packed */
  word rec_start_pos;
  /* starting position for the pilot record to be packed */
  byte reserve_bits;
  /* used for packing the zeros at the end for pilot recs */
#endif /* FEATURE_IS2000_REL_A */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_cfs_rpt_fix_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->cfs_rpt.fix);

#ifdef FEATURE_IS2000_REL_A_AES
    /* L3 SDU starts here */
    sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->cfs_rpt.fix.last_srch_msg, buf_ptr, msg_pos, FSIZ(MTYPE, last_srch_msg));
  msg_pos += FSIZ(MTYPE, last_srch_msg);

  b_packb(int_ptr->cfs_rpt.fix.last_srch_seq, buf_ptr, msg_pos, FSIZ(MTYPE, last_srch_seq));
  msg_pos += FSIZ(MTYPE, last_srch_seq);

  b_packb(int_ptr->cfs_rpt.fix.srch_mode, buf_ptr, msg_pos, FSIZ( MTYPE, srch_mode));
  msg_pos += FSIZ(MTYPE, srch_mode);

  info_rec_len_pos = msg_pos;
  msg_pos += FSIZ(MTYPE, mode_sp_len); /* len will be packed later */

  rec_pos = msg_pos;

  switch (int_ptr->cfs_rpt.fix.srch_mode)
  {
    case CAI_CF_SRCH_TYPE_CDMA:
      b_packb(int_ptr->cfs_rpt.var.mod0.band_class,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_fix_type, band_class));
      msg_pos += FSIZ(cai_cfs_rpt_mod0_fix_type, band_class);

      b_packw(int_ptr->cfs_rpt.var.mod0.cdma_freq,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_fix_type, cdma_freq));
      msg_pos += FSIZ(cai_cfs_rpt_mod0_fix_type, cdma_freq);

      b_packb(int_ptr->cfs_rpt.var.mod0.sf_tot_rx_pwr,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_fix_type, sf_tot_rx_pwr));
      msg_pos += FSIZ(cai_cfs_rpt_mod0_fix_type, sf_tot_rx_pwr);

      b_packb(int_ptr->cfs_rpt.var.mod0.cf_tot_rx_pwr,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_fix_type,
        cf_tot_rx_pwr));
      msg_pos += FSIZ(cai_cfs_rpt_mod0_fix_type, cf_tot_rx_pwr);

      b_packb(int_ptr->cfs_rpt.var.mod0.num_pilots,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_fix_type, num_pilots));
      msg_pos += FSIZ(cai_cfs_rpt_mod0_fix_type, num_pilots);

      for (i=0; i<int_ptr->cfs_rpt.var.mod0.num_pilots; i++)
      {
        b_packw(int_ptr->cfs_rpt.var.mod0.pilot[i].plt_pn_phase,
          buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_var_type, plt_pn_phase));
        msg_pos += FSIZ(cai_cfs_rpt_mod0_var_type, plt_pn_phase);

        b_packb(int_ptr->cfs_rpt.var.mod0.pilot[i].plt_str,
          buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_var_type, plt_str));
        msg_pos += FSIZ(cai_cfs_rpt_mod0_var_type, plt_str);

        b_packb(0, buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_var_type,
          reserved));
        msg_pos += FSIZ(cai_cfs_rpt_mod0_var_type, reserved);
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        for (i=0; i<int_ptr->cfs_rpt.var.mod0.num_pilots; i++)
        {
          b_packb(int_ptr->cfs_rpt.var.mod0.pilot2[i].pilot_rec_incl,
            buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_var2_type,pilot_rec_incl));
          msg_pos += FSIZ(cai_cfs_rpt_mod0_var2_type, pilot_rec_incl);

          if (int_ptr->cfs_rpt.var.mod0.pilot2[i].pilot_rec_incl)
          {
            b_packb(int_ptr->cfs_rpt.var.mod0.pilot2[i].pilot_rec_type, buf_ptr, msg_pos,
              FSIZ(cai_cfs_rpt_mod0_var2_type, pilot_rec_type));
            msg_pos += FSIZ(cai_cfs_rpt_mod0_var2_type, pilot_rec_type);

            rec_len_pos = msg_pos;

            msg_pos += FSIZ(cai_cfs_rpt_mod0_var2_type, record_len);

            rec_start_pos = msg_pos;

            /*  pack the reference pilot if it's auxiliary
                see table 2.7.2.3.2.34-1*/
            if (int_ptr->cfs_rpt.var.mod0.pilot2[i].pilot_rec_type == 0)
            {
              b_packb(int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.qof,
                buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,qof));
              msg_pos += FSIZ(cai_add_pilot_rec1_type,qof);

              b_packb(int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.walsh_length,
                buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,walsh_length));
              msg_pos += FSIZ(cai_add_pilot_rec1_type,walsh_length);

              b_packw(int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.aux_pilot_walsh, buf_ptr,
                msg_pos, int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.walsh_length + 6);
              msg_pos += int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.walsh_length + 6;

              /* length of reserved bits */
              reserve_bits = (sizeof(cai_add_pilot_rec1_type ) +
                int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.walsh_length) %8;

              if (reserve_bits != 0)
              {
                reserve_bits = 8 - reserve_bits;

                /* Pack reserved bits */
                b_packb(0, buf_ptr, msg_pos, reserve_bits);
                msg_pos += reserve_bits;
              }

              b_packb((msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
                FSIZ(cai_cfs_rpt_mod0_var2_type, record_len));
            }
          }
        }
      }
#endif /* FEATURE_IS2000_REL_A */

      /* Calculate MODE_SPECIFIC_LEN */
      xrec_len = msg_pos - rec_pos;

#ifdef FEATURE_IS2000_REL_A
      if (xrec_len%8 == 0)
#endif /* FEATURE_IS2000_REL_A */
      {
        b_packb((byte) (xrec_len/8), buf_ptr, info_rec_len_pos,
          FSIZ(MTYPE, mode_sp_len));
      }
#ifdef FEATURE_IS2000_REL_A
      else
      {
        b_packb(0, buf_ptr, msg_pos, (word)(8-(xrec_len%8)));
        b_packb((byte) (xrec_len/8) + 1, buf_ptr, info_rec_len_pos,
          FSIZ(MTYPE, mode_sp_len));
        msg_pos += 8 - xrec_len%8;
      }
#endif  /* FEATURE_IS2000_REL_A */

      break;

    case CAI_CF_SRCH_TYPE_ANALOG:
      b_packb(int_ptr->cfs_rpt.var.mod1.band_class,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod1_fix_type, band_class));
      msg_pos += FSIZ(cai_cfs_rpt_mod1_fix_type, band_class);

      b_packb(int_ptr->cfs_rpt.var.mod1.sf_tot_rx_pwr,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod1_fix_type, sf_tot_rx_pwr));
      msg_pos += FSIZ(cai_cfs_rpt_mod1_fix_type, sf_tot_rx_pwr);

      b_packb(int_ptr->cfs_rpt.var.mod1.num_analog_freqs, buf_ptr, msg_pos,
        FSIZ(cai_cfs_rpt_mod1_fix_type, num_analog_freqs));
      msg_pos += FSIZ(cai_cfs_rpt_mod1_fix_type, num_analog_freqs);

      b_packb(0, buf_ptr, msg_pos, FSIZ(cai_cfs_rpt_mod1_fix_type, reserved));
      msg_pos += FSIZ(cai_cfs_rpt_mod1_fix_type, reserved);

      for (i=0; i<int_ptr->cfs_rpt.var.mod1.num_analog_freqs; i++)
      {
        b_packw(int_ptr->cfs_rpt.var.mod1.analog[i].analog_freq,
          buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod1_var_type, analog_freq));
        msg_pos += FSIZ(cai_cfs_rpt_mod1_var_type, analog_freq);

        b_packb(int_ptr->cfs_rpt.var.mod1.analog[i].sig_str, buf_ptr,
          msg_pos, FSIZ(cai_cfs_rpt_mod1_var_type, sig_str));
        msg_pos += FSIZ(cai_cfs_rpt_mod1_var_type, sig_str);
      }

      /* Calculate MODE_SPECIFIC_LEN */
      xrec_len = msg_pos - rec_pos;

      /* Append necessary reserved bits */
      if (xrec_len%8)
      {
        b_packb(0, buf_ptr, msg_pos, (word)(8-(xrec_len%8)));
        msg_pos += 8 - xrec_len%8;
        xrec_len += 8 - xrec_len%8;
      }


      b_packb((byte)(xrec_len/8), buf_ptr,
        info_rec_len_pos, FSIZ( MTYPE, mode_sp_len ));
      break;

    default:
      M1X_MSG( DCP, LEGACY_ERROR,
        "Invalid CF SRCH MODE %d",
        int_ptr->cfs_rpt.fix.srch_mode);

      status = CAIX_INV_MSG_S;
  }

#ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->auth_resp.hdr.sdu_encrypt_mode,
                         int_ptr->auth_resp.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->cfs_rpt.fix.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->cfs_rpt.fix.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->cfs_rpt.fix.hdr.msg_int.sdu_key_id,
                   int_ptr->cfs_rpt.fix.msg_type,
                   int_ptr->cfs_rpt.fix.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->cfs_rpt.fix.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;
    /* Set message length */

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_cfs_rpt */

/*===========================================================================

FUNCTION xlate_int_tc_per_plt

DESCRIPTION
  This function translates a Periodic Pilot Strength Measurement Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_per_plt
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  word i;
    /* For indexing through info recs */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */
  #ifdef FEATURE_IS2000_REL_A
  byte reserve_bits;
  word rec_len_pos;
  word rec_start_pos;
  #endif /* FEATURE_IS2000_REL_A */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_plt_str_meas_fix_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->per_plt);

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packw(int_ptr->per_plt.fix.ref_pn, buf_ptr, msg_pos, FSIZ(MTYPE, ref_pn));
  msg_pos += FSIZ(MTYPE, ref_pn);
  b_packb(int_ptr->per_plt.fix.pilot_str, buf_ptr, msg_pos, FSIZ(MTYPE, pilot_str));
  msg_pos += FSIZ(MTYPE, pilot_str);
  b_packb(int_ptr->per_plt.fix.keep, buf_ptr, msg_pos, FSIZ(MTYPE, keep));
  msg_pos += FSIZ(MTYPE, keep);
  b_packb(int_ptr->per_plt.fix.sf_rx_pwr, buf_ptr, msg_pos, FSIZ(MTYPE, sf_rx_pwr));
  msg_pos += FSIZ(MTYPE, sf_rx_pwr);
  b_packb(int_ptr->per_plt.fix.num_pilot, buf_ptr, msg_pos, FSIZ(MTYPE, num_pilot));
  msg_pos += FSIZ(MTYPE, num_pilot);

  for (i=0; i<int_ptr->per_plt.fix.num_pilot; i++)
  {
    b_packw(int_ptr->per_plt.var[i].plt_pn_phase,
      buf_ptr, msg_pos, FSIZ(cai_plt_str_meas_var_type, plt_pn_phase));
    msg_pos += FSIZ(cai_plt_str_meas_var_type, plt_pn_phase);

    b_packb(int_ptr->per_plt.var[i].plt_str,
      buf_ptr, msg_pos, FSIZ(cai_plt_str_meas_var_type, plt_str));
    msg_pos += FSIZ(cai_plt_str_meas_var_type, plt_str);

    b_packb(int_ptr->per_plt.var[i].keep,
      buf_ptr, msg_pos, FSIZ(cai_plt_str_meas_var_type, keep));
    msg_pos += FSIZ(cai_plt_str_meas_var_type, keep);
  }

#ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    for (i=0; i<int_ptr->per_plt.fix.num_pilot; i++)
    {
      b_packb(int_ptr->per_plt.var2[i].pilot_rec_incl, buf_ptr, msg_pos,
        FSIZ(cai_plt_str_meas_var2_type, pilot_rec_incl));
      msg_pos += FSIZ(cai_plt_str_meas_var2_type, pilot_rec_incl);

      if (int_ptr->per_plt.var2[i].pilot_rec_incl)
      {
        b_packb(int_ptr->per_plt.var2[i].pilot_rec_type, buf_ptr, msg_pos,
          FSIZ(cai_plt_str_meas_var2_type, pilot_rec_type));
        msg_pos += FSIZ(cai_plt_str_meas_var2_type, pilot_rec_type);

        rec_len_pos = msg_pos;

        msg_pos += FSIZ(cai_plt_str_meas_var2_type, record_len);

        rec_start_pos = msg_pos;

        /*  pack the reference pilot if it's auxiliary
          see table 2.7.2.3.2.34-1*/
        if (int_ptr->per_plt.var2[i].pilot_rec_type == 0)
        {
          b_packb(int_ptr->per_plt.var2[i].rec.qof,
          buf_ptr, msg_pos, FSIZ(cai_add_pilot_rec1_type,qof));
          msg_pos += FSIZ(cai_add_pilot_rec1_type,qof);

          b_packb(int_ptr->per_plt.var2[i].rec.walsh_length,
          buf_ptr, msg_pos, FSIZ(cai_add_pilot_rec1_type,walsh_length));
          msg_pos += FSIZ(cai_add_pilot_rec1_type,walsh_length);

          b_packw(int_ptr->per_plt.var2[i].rec.aux_pilot_walsh, buf_ptr,
          msg_pos, int_ptr->per_plt.var2[i].rec.walsh_length + 6);
          msg_pos += int_ptr->per_plt.var2[i].rec.walsh_length + 6;

          /* length of reserved bits */
          reserve_bits = (sizeof(cai_add_pilot_rec1_type) +
                               int_ptr->per_plt.var2[i].rec.walsh_length) %8;
          if (reserve_bits != 0)
          {
            reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
            b_packb(0, buf_ptr, msg_pos, reserve_bits);
            msg_pos += reserve_bits;
          }

          b_packb((msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
            FSIZ(cai_plt_str_meas_var2_type, record_len));
        }
      }
    }

  #undef MTYPE

  #define MTYPE cai_plt_str_meas_fix2_type

    b_packb(int_ptr->per_plt.fix2.setpt_incl,
      buf_ptr, msg_pos, FSIZ( MTYPE, setpt_incl));
    msg_pos +=  FSIZ(MTYPE, setpt_incl);

    if (int_ptr->per_plt.fix2.setpt_incl)
    {
      b_packb(int_ptr->per_plt.fix2.fch_incl,
        buf_ptr, msg_pos, FSIZ(MTYPE, fch_incl));
      msg_pos +=  FSIZ(MTYPE, fch_incl);

      if (int_ptr->per_plt.fix2.fch_incl)
      {
        b_packb(int_ptr->per_plt.fix2.fpc_fch_curr_setpt,
        buf_ptr, msg_pos, FSIZ(MTYPE, fpc_fch_curr_setpt));
        msg_pos +=  FSIZ(MTYPE, fpc_fch_curr_setpt);
      }

      b_packb(int_ptr->per_plt.fix2.dcch_incl,
      buf_ptr, msg_pos, FSIZ(MTYPE, dcch_incl));
      msg_pos +=  FSIZ(MTYPE, dcch_incl);

      if (int_ptr->per_plt.fix2.dcch_incl)
      {
        b_packb(int_ptr->per_plt.fix2.fpc_dcch_curr_setpt,
        buf_ptr, msg_pos, FSIZ(MTYPE, fpc_dcch_curr_setpt));
        msg_pos +=  FSIZ(MTYPE, fpc_dcch_curr_setpt);
      }

      b_packb(int_ptr->per_plt.fix2.num_sup,
        buf_ptr, msg_pos, FSIZ(MTYPE, num_sup));
      msg_pos +=  FSIZ(MTYPE, num_sup);

      for (i=0; i<int_ptr->per_plt.fix2.num_sup; i++)
      {
        b_packb(int_ptr->per_plt.fix2.sup[i].sch_id, buf_ptr, msg_pos,
        FSIZ(cai_plt_str_meas_var3_type, sch_id));
        msg_pos +=  FSIZ(cai_plt_str_meas_var3_type, sch_id);

        b_packb(int_ptr->per_plt.fix2.sup[i].fpc_sch_curr_setpt, buf_ptr, msg_pos,
        FSIZ(cai_plt_str_meas_var3_type, fpc_sch_curr_setpt));
        msg_pos +=  FSIZ(cai_plt_str_meas_var3_type, fpc_sch_curr_setpt);
      }
    }
  }
#endif /* FEATURE_IS2000_REL_A */


#ifdef FEATURE_IS2000_REL_A_AES
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->per_plt.hdr.sdu_encrypt_mode,
                         int_ptr->per_plt.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->per_plt.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->per_plt.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->per_plt.hdr.msg_int.sdu_key_id,
                   int_ptr->per_plt.msg_type,
                   int_ptr->per_plt.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->per_plt.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_per_plt */

/*===========================================================================

FUNCTION xlate_int_tc_outer_rpt

DESCRIPTION
  This function translates a Outer Loop Report Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_outer_rpt
(
  word *len_ptr,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to where translated message should be placed */

  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  word i;
    /* For indexing through info recs */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_outer_rpt_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->outer_rpt);

#ifdef FEATURE_IS2000_REL_A_AES
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->outer_rpt.fch_incl, buf_ptr, msg_pos, FSIZ(MTYPE, fch_incl) );
  msg_pos += FSIZ(MTYPE, fch_incl);

  if (int_ptr->outer_rpt.fch_incl)
  {
    b_packb(int_ptr->outer_rpt.fpc_fch_curr_setpt, buf_ptr, msg_pos,
      FSIZ(MTYPE, fpc_fch_curr_setpt));
    msg_pos += FSIZ(MTYPE, fpc_fch_curr_setpt);
  }

  b_packb(int_ptr->outer_rpt.dcch_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, dcch_incl));
  msg_pos += FSIZ(MTYPE, dcch_incl);

  if (int_ptr->outer_rpt.dcch_incl)
  {
    b_packb(int_ptr->outer_rpt.fpc_dcch_curr_setpt, buf_ptr, msg_pos,
      FSIZ(MTYPE, fpc_dcch_curr_setpt));
    msg_pos += FSIZ(MTYPE, fpc_dcch_curr_setpt);
  }

  b_packb(int_ptr->outer_rpt.num_sup, buf_ptr, msg_pos, FSIZ(MTYPE, num_sup));
  msg_pos += FSIZ(MTYPE, num_sup);

  for (i=0; i<int_ptr->outer_rpt.num_sup && i<CAI_OUTER_RPT_MAX_SUP; i++)
  {
    b_packb(int_ptr->outer_rpt.sup[i].sch_id, buf_ptr, msg_pos,
      FSIZ(MTYPE, sch_id));
    msg_pos += FSIZ(MTYPE, sch_id);

    b_packb(int_ptr->outer_rpt.sup[i].fpc_sch_curr_setpt, buf_ptr, msg_pos,
      FSIZ(MTYPE, fpc_sch_curr_setpt));
    msg_pos += FSIZ(MTYPE, fpc_sch_curr_setpt);
  }

#ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->outer_rpt.hdr.sdu_encrypt_mode,
                         int_ptr->outer_rpt.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->outer_rpt.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->outer_rpt.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->outer_rpt.hdr.msg_int.sdu_key_id,
                   int_ptr->outer_rpt.msg_type,
                   int_ptr->outer_rpt.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->outer_rpt.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;
    /* Set message length */

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_per_plt */

/* ======== ========== ========= ======== ========= ========= ======== =====

              Release A message coding for Reverse Traffic Channel
                      starts here

  ========= ==========  ========= ========= ========= ======== =========  */

/*===========================================================================

FUNCTION xlate_int_tc_rrm

DESCRIPTION
  This function translates a Resource Request Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_rrm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->rrm);

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->rrm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->rrm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->rrm.hdr.msg_int.sdu_key_id,
                   int_ptr->rrm.msg_type,
                   int_ptr->rrm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->rrm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  return (status);
} /* xlate_int_tc_rrm */

/*===========================================================================

FUNCTION xlate_int_tc_errm

DESCRIPTION
  This function translates a Extended Release Response Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_errm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->errm);

#define MTYPE cai_errm_type
  /* Set up MTYPE definition for PARAMS macro */

#undef MTYPE

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->errm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->errm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->errm.hdr.msg_int.sdu_key_id,
                   int_ptr->errm.msg_type,
                   int_ptr->errm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->errm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  return (status);

} /* xlate_int_tc_errm */

/*===========================================================================

FUNCTION xlate_int_tc_rrrm

DESCRIPTION
  This function translates a Resource Release Request Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_rrrm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos=0;
    /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_rrrm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->rrrm);

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->rrrm.gating_disconnect_ind, buf_ptr, msg_pos,
           FSIZ( MTYPE, gating_disconnect_ind));
  msg_pos += FSIZ( MTYPE, gating_disconnect_ind);

  if (!int_ptr->rrrm.gating_disconnect_ind)
  {
    b_packb( int_ptr->rrrm.con_ref, buf_ptr, msg_pos, FSIZ( MTYPE, con_ref));
    msg_pos += FSIZ( MTYPE, con_ref);
    b_packb( int_ptr->rrrm.purge_service, buf_ptr, msg_pos, FSIZ( MTYPE, purge_service));
    msg_pos += FSIZ( MTYPE, purge_service);

  }

#ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->rrrm.hdr.sdu_encrypt_mode,
                         int_ptr->rrrm.hdr.ack_req
                       );
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->rrrm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->rrrm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->rrrm.hdr.msg_int.sdu_key_id,
                   int_ptr->rrrm.msg_type,
                   int_ptr->rrrm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->rrrm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  #undef MTYPE
  /* Deactivate MTYPE definition */

  return (status);

} /* xlate_int_tc_rrrm */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION xlate_int_tc_uzurm

DESCRIPTION
  This function translates a Uzer Zone Update Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_uzurm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_uzurm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->uzurm );

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packw( int_ptr->uzurm.uzid, buf_ptr, msg_pos,
           FSIZ( MTYPE, uzid));
  msg_pos += FSIZ( MTYPE, uzid);

  #ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->uzurm.hdr.sdu_encrypt_mode,
                         int_ptr->uzurm.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->uzurm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->uzurm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->uzurm.hdr.msg_int.sdu_key_id,
                   int_ptr->uzurm.msg_type,
                   int_ptr->uzurm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->uzurm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  status = CAIX_DONE_S;

  /* Set message length */
  *len_ptr = msg_pos;

  #undef MTYPE
  /* Deactivate MTYPE definition */

  return ( status );

} /* xlate_int_tc_uzurm */

/*===========================================================================

FUNCTION xlate_int_tc_eom

DESCRIPTION
  This function translates a Enhanced Origination Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_eom
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */

  word start_enc_pos;
    /* Start point of fields that might require encryption using CMEA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_eom_fix1_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->eom );

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->eom.tag, buf_ptr, msg_pos, FSIZ(MTYPE, tag));
  msg_pos += FSIZ( MTYPE, tag);

  b_packb(int_ptr->eom.ch_ind, buf_ptr, msg_pos, FSIZ(MTYPE, ch_ind));
  msg_pos += FSIZ(MTYPE, ch_ind);

#ifdef FEATURE_IS2000_REL_C
  if (int_ptr->eom.ch_ind == 0x07)
  {
    b_packb(int_ptr->eom.ext_ch_ind, buf_ptr, msg_pos, FSIZ( MTYPE, ext_ch_ind));
    msg_pos += FSIZ(MTYPE, ext_ch_ind);
  }
#endif /* FEATURE_IS2000_REL_C */

  b_packb(int_ptr->eom.sr_id, buf_ptr, msg_pos, FSIZ(MTYPE, sr_id));
  msg_pos += FSIZ(MTYPE, sr_id);

  b_packb(int_ptr->eom.global_em_flag, buf_ptr, msg_pos,
    FSIZ(MTYPE, global_emergency_call));
  msg_pos += FSIZ(MTYPE, global_emergency_call);

  if (int_ptr->eom.global_em_flag)
  {
    b_packb(int_ptr->eom.ms_init_pos_loc_ind, buf_ptr, msg_pos,
      FSIZ(MTYPE, ms_init_pos_loc_ind));
    msg_pos += FSIZ(MTYPE, ms_init_pos_loc_ind);
  }

  b_packb(int_ptr->eom.enc_info_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, enc_info_inc));
  msg_pos += FSIZ(MTYPE, enc_info_inc);

  if (int_ptr->eom.enc_info_incl)
  {
    b_packb(int_ptr->eom.ui_enc_req, buf_ptr, msg_pos,
      FSIZ(MTYPE, ui_encrypt_req));
    msg_pos += FSIZ(MTYPE, ui_encrypt_req);

    b_packb(int_ptr->eom.ui_enc_sup, buf_ptr, msg_pos,
      FSIZ(MTYPE, ui_encrypt_sup));
    msg_pos += FSIZ(MTYPE, ui_encrypt_sup);
  }

  b_packw(int_ptr->eom.service_option, buf_ptr, msg_pos,
    FSIZ(MTYPE, service_option));
  msg_pos += FSIZ(MTYPE, service_option);

  b_packb(int_ptr->eom.more_so_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, more_so_info_incl));
  msg_pos += FSIZ(MTYPE, more_so_info_incl);

  if (int_ptr->eom.more_so_incl)
  {
    b_packb(int_ptr->eom.num_alt_so, buf_ptr, msg_pos, FSIZ(MTYPE, num_alt_so));
    msg_pos += FSIZ(MTYPE, num_alt_so);

    for (i=0; i<int_ptr->eom.num_alt_so && i<cai_ac_alt_so_max; i++)
    {
      b_packw(int_ptr->eom.alt_so[i], buf_ptr, msg_pos,
        FSIZ(cai_alt_so_type, alt_so ));
      msg_pos += FSIZ(cai_alt_so_type, alt_so);
    }

    b_packb(int_ptr->eom.so_bitmap_ind, buf_ptr, msg_pos,
      FSIZ(cai_eom_var_type, so_bitmap_ind));
    msg_pos += FSIZ(cai_eom_var_type, so_bitmap_ind);

    if (int_ptr->eom.so_bitmap_ind != SO_BITMAP_SIZE_0)
    {
      b_packb(int_ptr->eom.so_group_num, buf_ptr, msg_pos,
        FSIZ(cai_eom_var_type, so_group_num));
      msg_pos += FSIZ(cai_eom_var_type, so_group_num);

      /* so_bitmap is 2^(1+so_bitmap_ind) long */
      b_packw(int_ptr->eom.so_bitmap, buf_ptr, msg_pos,
        ( (byte)1 << (1+int_ptr->eom.so_bitmap_ind) ) );
      msg_pos += ( (byte)1 << (1+int_ptr->eom.so_bitmap_ind) );
    }
  }

  #undef MTYPE

  #define MTYPE cai_eom_fix2_type

  b_packb(int_ptr->eom.drs, buf_ptr, msg_pos, FSIZ(MTYPE, drs));
  msg_pos += FSIZ(MTYPE, drs);

  b_packb(int_ptr->eom.prev_sid_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, prev_sid_incl));
  msg_pos += FSIZ(MTYPE, prev_sid_incl);

  if (int_ptr->eom.prev_sid_incl)
  {
    b_packw(int_ptr->eom.prev_sid, buf_ptr, msg_pos,
      FSIZ(MTYPE, prev_sid));
    msg_pos += FSIZ(MTYPE, prev_sid);
  }

  b_packb(int_ptr->eom.prev_nid_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, prev_nid_incl));
  msg_pos += FSIZ(MTYPE, prev_nid_incl);

  if (int_ptr->eom.prev_nid_incl)
  {
    b_packw(int_ptr->eom.prev_nid, buf_ptr, msg_pos,
      FSIZ(MTYPE, prev_nid));
    msg_pos += FSIZ(MTYPE, prev_nid);
  }

  b_packb(int_ptr->eom.prev_pzid_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, prev_pzid_incl));
  msg_pos += FSIZ(MTYPE, prev_pzid_incl);

  if (int_ptr->eom.prev_pzid_incl)
  {
    b_packw(int_ptr->eom.prev_pzid, buf_ptr, msg_pos,
      FSIZ(MTYPE, prev_pzid));
    msg_pos += FSIZ(MTYPE, prev_pzid);
  }

  b_packb(int_ptr->eom.dialed_digs_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, dialed_digs_incl));
  msg_pos += FSIZ(MTYPE, dialed_digs_incl);

  if (int_ptr->eom.dialed_digs_incl)
  {
    b_packb( int_ptr->eom.digit_mode, buf_ptr, msg_pos,
             FSIZ( MTYPE, digit_mode ));
    msg_pos += FSIZ( MTYPE, digit_mode );

    if (int_ptr->eom.digit_mode
#ifdef FEATURE_IS2000_REL_C
        || (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
#endif /* FEATURE_IS2000_REL_C */
       )
    {
      b_packb(int_ptr->eom.number_type, buf_ptr, msg_pos,
        FSIZ(MTYPE, number_type));
      msg_pos += FSIZ(MTYPE, number_type);

#ifdef FEATURE_IS2000_REL_C
      if (int_ptr->eom.digit_mode)
#endif /* FEATURE_IS2000_REL_C */
      {
        b_packb(int_ptr->eom.number_plan, buf_ptr, msg_pos,
          FSIZ(MTYPE, number_plan));
        msg_pos += FSIZ(MTYPE, number_plan);
      }
    }

    b_packb(int_ptr->eom.num_fields, buf_ptr, msg_pos,
      FSIZ(MTYPE, num_fields));
    msg_pos += FSIZ(MTYPE, num_fields);


    start_enc_pos = msg_pos;


    for (i=0; i < int_ptr->eom.num_fields; i++)
    {
      if (int_ptr->eom.digit_mode)
      {
        b_packb(int_ptr->eom.chari[i], buf_ptr, msg_pos,
          FSIZ(cai_orig_var_type, char8));
        /* ca use cai_orig_var_type here */
        msg_pos += FSIZ(cai_orig_var_type, char8);
      }
      else
      {
        b_packb(int_ptr->eom.chari[i], buf_ptr, msg_pos,
          FSIZ(cai_orig_var_type, char4));
        msg_pos += FSIZ(cai_orig_var_type, char4);
      }
    }


    /* EOM has two portions might need to be encrypted. Digits and Info Recs.
    ** Encryption function can pad to the digits. So calling encryption function
    ** here is much simpler.
    */
    if ((int_ptr->eom.num_fields > 0) &&
        (int_ptr->eom.hdr.encryption == CAI_ENCRYPT_CALL_CTL_MSGS))
    {
      auth_encrypt_eom_digits(&msg_pos, buf_ptr, int_ptr, start_enc_pos);
    }

  }

  b_packb(int_ptr->eom.num_recs, buf_ptr, msg_pos,
    FSIZ(cai_eom_fix3_type, num_recs));
  msg_pos += FSIZ(cai_eom_fix3_type, num_recs);


  start_enc_pos = msg_pos;


  if (int_ptr->eom.num_recs)
  {
    for (i = irec_pos = 0; (i < int_ptr->eom.num_recs); i++)
    {
      if((irec_pos/4) < CAII_MAX_INFO_REC_DWORDS)
      {
        status = xlate_int_info_rec((byte*) &int_ptr->eom.recs[irec_pos/4],
                                    &irec_len, (word) (CAI_REV_TC_MSG_BODY_SIZE - msg_pos),
                                    buf_ptr, msg_pos, &xrec_len);
      }

      if (status != CAIX_DONE_S)
      {
        return (status);
      }
      msg_pos  += xrec_len;  /* Advance external msg buf position */
      irec_pos += irec_len;  /* Advance internal msg buf position */
      /* The next record will start only on a dword boundary, so move positions accordingly */
      irec_pos = (irec_pos%4)?(irec_pos+(sizeof(dword))-irec_pos%4):irec_pos;
    }


    /* This is the encryption of the info record part. */
    if (int_ptr->eom.hdr.encryption == CAI_ENCRYPT_CALL_CTL_MSGS)
    {
      auth_encrypt_info_recs(&msg_pos, buf_ptr, int_ptr,
        start_enc_pos, int_ptr->eom.num_recs);
    }

  } /* if int_ptr->eom.num_recs */

#ifdef FEATURE_IS2000_REL_C
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
    b_packb(int_ptr->eom.sync_id_incl, buf_ptr, msg_pos,
      FSIZ(cai_eom_fix4_type, sync_id_incl));
    msg_pos += FSIZ(cai_eom_fix4_type, sync_id_incl);

    if (int_ptr->eom.sync_id_incl)
    {
      b_packb(int_ptr->eom.sync_id_len, buf_ptr, msg_pos,
        FSIZ(cai_eom_fix4_type, sync_id_len));
      msg_pos += FSIZ(cai_eom_fix4_type, sync_id_len);

      for (i=0; i < int_ptr->eom.sync_id_len; i++)
      {
        b_packb(int_ptr->eom.sync_id[i], buf_ptr, msg_pos,
          FSIZ(cai_eom_fix4_type, sync_id));
        msg_pos += FSIZ(cai_eom_fix4_type, sync_id);
      }
    }
  }
#endif /* FEATURE_IS2000_REL_C */

  #ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->eom.hdr.sdu_encrypt_mode,
                         int_ptr->eom.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->eom.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->eom.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->eom.hdr.msg_int.sdu_key_id,
                   int_ptr->eom.msg_type,
                   int_ptr->eom.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->eom.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_eom */

/*===========================================================================

FUNCTION xlate_int_tc_efwim

DESCRIPTION
  This function translates a Extended Flash with Info Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_efwim
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */
  word i;
    /* Index to loop through records */
  word j;
    /* Index to loop through characters */
  byte *rec_ptr;
    /* Pointer to internal format information record */
  word rec_len_pos = 0;
  word reserv_len = 0;
#ifdef FEATURE_IS2000_REL_C
  word rec_len;
  /* Size of record in bits */
#endif /* FEATURE_IS2000_REL_C */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_efwim_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->efwim );

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  rec_ptr = (byte*)&int_ptr->efwim.recs[0];

  b_packb( int_ptr->efwim.con_ref_incl, buf_ptr, msg_pos, FSIZ( MTYPE, con_ref_incl));
  msg_pos += FSIZ( MTYPE, con_ref_incl);

  status = CAIX_DONE_S;

  if (int_ptr->efwim.con_ref_incl)
  {
    b_packb( int_ptr->efwim.con_ref, buf_ptr, msg_pos, FSIZ( MTYPE, con_ref));
    msg_pos += FSIZ( MTYPE, con_ref);
  }

  b_packb( int_ptr->efwim.num_rec, buf_ptr, msg_pos, FSIZ( MTYPE, num_rec));
  msg_pos += FSIZ( MTYPE, num_rec);

  for (i=0; (i < int_ptr->efwim.num_rec) && (status == CAIX_DONE_S); i++)
  {
    /* ----------------------------------------------------
    ** Check to make sure that there is room for the header
    ** ---------------------------------------------------- */
    if ((msg_pos + sizeof( cai_rec_hdr_type )) > CAI_REV_TC_MSG_BODY_SIZE)
    {
      status = CAIX_INV_LEN_S;
    }

    else
    {
      b_packb( ((caii_rec_hdr_type *) rec_ptr)->record_type,
               buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_type ));
      msg_pos += FSIZ( cai_rec_hdr_type, record_type );

      switch (((caii_rec_hdr_type *) rec_ptr)->record_type)
      {
        /* ------------------------------------
        ** Feature Indicator Information Record
        ** ------------------------------------ */
        case CAI_FEAT_REC:
          /* -------------------------------------------------------
          ** Feature Indicator Info Record length = 1 octet (8 bits)
          ** ------------------------------------------------------- */
          b_packb( 1, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos + sizeof( cai_feat_type )) > CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else {
            b_packb( ((caii_feat_rec_type *) rec_ptr)->feature,
                     buf_ptr, msg_pos, FSIZ( cai_feat_type, feature ));
            msg_pos += FSIZ( cai_feat_type, feature );

            /* -----------------------
            ** Pack reserved bits as 0
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_feat_type, reserved ));
            msg_pos += FSIZ( cai_feat_type, reserved );
            rec_ptr += FENDPOS( caii_feat_rec_type, feature );
          }
          break;

        /* ----------------------------------
        ** Keypad Facility Information Record
        ** ---------------------------------- */
        case CAI_KEYPAD_REC:
          if ((((caii_key_rec_type *) rec_ptr)->fix.num_char) == 0) {
            /* --------------------------------------------------------
            ** There must be at least one occurrence of the chari field
            ** -------------------------------------------------------- */
            return (CAIX_INV_LEN_S);
          }

          b_packb( ((caii_key_rec_type *) rec_ptr)->fix.num_char, buf_ptr,
                 msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos +
              (((caii_key_rec_type *) rec_ptr)->fix.num_char *
                 FSIZ( cai_keypad_type, chari ))) >
                   CAI_REV_TC_MSG_BODY_SIZE)
          {
            /* --------------------------------------------
            ** Not enough room to pack keypad facility type
            ** -------------------------------------------- */
            status = CAIX_INV_LEN_S;
          }

          else {
            for (j=0; j < ((caii_key_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_key_rec_type *) rec_ptr)->var[j], buf_ptr,
                     msg_pos, FSIZ(cai_keypad_type, chari) );
              msg_pos += FSIZ( cai_keypad_type, chari );
            }

            rec_ptr += FENDPOS( caii_key_rec_type,
            var[((caii_key_rec_type *) rec_ptr)->fix.num_char - 1] );
          }
          break;

        /* --------------------------------------
        ** Called Party Number Information Record
        ** -------------------------------------- */
        case CAI_REV_CALLED_REC:
          /* ----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 1 (8 bits) for
          ** NUMBER_TYPE, NUMBER_PLAN and RESERVED fields
          ** ---------------------------------------------------- */
          b_packb(
            (byte) (((caii_called_rec_type *) rec_ptr)->fix.num_char + 1),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len);

          if ((msg_pos + sizeof( cai_called_fix_type ) +
              (((caii_called_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_called_var_type, chari )) + 1) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else {
            b_packb( ((caii_called_rec_type *) rec_ptr)->fix.number_type,
                     buf_ptr, msg_pos,
                     FSIZ( cai_called_fix_type, number_type ));
            msg_pos += FSIZ(cai_called_fix_type, number_type);

            b_packb( ((caii_called_rec_type *)rec_ptr)->fix.number_plan,
                   buf_ptr, msg_pos,
                   FSIZ( cai_called_fix_type, number_plan));
            msg_pos += FSIZ( cai_called_fix_type, number_plan);

            for (j=0;
                 j < ((caii_called_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_called_rec_type *) rec_ptr)->var[j], buf_ptr,
                        msg_pos, FSIZ( cai_called_var_type, chari ));
              msg_pos += FSIZ( cai_called_var_type, chari );
            }

            /* -----------------------
            ** Pack 0 for reserved bit
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, 1 );
            msg_pos += 1;

            if (((caii_called_rec_type *) rec_ptr)->fix.num_char == 0) {
              rec_ptr += FSIZ( caii_called_rec_type, fix );
            }

            else {
              rec_ptr += FENDPOS( caii_called_rec_type,
                   var[((caii_called_rec_type *) rec_ptr)->fix.num_char - 1] );
            }
          }
          break;

        /* -----------------------------------------------------------
        ** Calling Party Number or Connected Number Information Record
        ** ----------------------------------------------------------- */
        case CAI_REV_CALLING_REC:
        case CAI_REV_CONN_REC:
          /* -----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 2 (16 bits) for
          ** NUMBER_TYPE, NUMBER_PLAN, PI, SI and RESERVED fields
          ** ----------------------------------------------------- */
          b_packb(
            (byte) (((caii_calling_rec_type *) rec_ptr)->fix.num_char + 2),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos + sizeof( cai_calling_fix_type ) +
              (((caii_calling_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_calling_var_type, chari )) + 5) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else {
            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.number_type,
                      buf_ptr, msg_pos,
                      FSIZ( cai_calling_fix_type, number_type ));
            msg_pos += FSIZ( cai_calling_fix_type, number_type );

            b_packb( (( caii_calling_rec_type *) rec_ptr)->fix.number_plan,
                     buf_ptr, msg_pos,
                     FSIZ( cai_calling_fix_type, number_plan ));
            msg_pos += FSIZ(cai_calling_fix_type, number_plan);

            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.pi,
                   buf_ptr, msg_pos, FSIZ( cai_calling_fix_type, pi ));
            msg_pos += FSIZ( cai_calling_fix_type, pi );

            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.si,
                    buf_ptr, msg_pos, FSIZ( cai_calling_fix_type, si ));
            msg_pos += FSIZ( cai_calling_fix_type, si);

            for (j=0;
                 j < ((caii_calling_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_calling_rec_type *) rec_ptr)->var[j],
                        buf_ptr, msg_pos, FSIZ( cai_calling_var_type, chari));
              msg_pos += FSIZ( cai_calling_var_type, chari );
            }

            /* ------------------------
            ** Pack 0 for reserved bits
            ** ------------------------ */
            b_packb( 0, buf_ptr, msg_pos, 5 );
            msg_pos += 5;

            if (((caii_calling_rec_type *) rec_ptr)->fix.num_char == 0) {
              rec_ptr += FSIZ( caii_calling_rec_type, fix ); /*lint !e662 */
            }
            else {
              rec_ptr += FENDPOS( caii_calling_rec_type,
              var[((caii_calling_rec_type *) rec_ptr)->fix.num_char - 1] );
            }
          }
          break;

        /* -------------------------------------------
        ** Called Party Subaddress Informatin Record
        ** Calling Party Subaddress Informatin Record
        ** Connected Subaddress Informatin Record
        ** ------------------------------------------- */
        case CAI_REV_CALLED_SUB_REC:
        case CAI_REV_CALLING_SUB_REC:
        case CAI_REV_CONN_SUB_REC:
          /* ----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 1 (8 bits)
          ** ---------------------------------------------------- */
          b_packb(
            (byte) (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char + 1),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len);

          if ((msg_pos + sizeof( cai_subaddr_fix_type ) +
              (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_subaddr_var_type, chari ))) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else {
            b_packb( ((caii_subaddr_rec_type *) rec_ptr)->fix.extension_bit,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, extension_bit ));
            msg_pos += FSIZ(cai_subaddr_fix_type, extension_bit);

            b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.subadd_type,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, subadd_type));
            msg_pos += FSIZ( cai_subaddr_fix_type, subadd_type);

            b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.odd_even_ind,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, odd_even_ind));
            msg_pos += FSIZ( cai_subaddr_fix_type, odd_even_ind);

            /* -----------------------
            ** Pack 0 for reserved bit
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, 3 );
            msg_pos += 3;

            for (j=0;
                 j < ((caii_subaddr_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_subaddr_rec_type *) rec_ptr)->var[j], buf_ptr,
                      msg_pos, FSIZ( cai_subaddr_var_type, chari ));
              msg_pos += FSIZ( cai_subaddr_var_type, chari );
            }

            if (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char == 0) {
              rec_ptr += FSIZ( caii_subaddr_rec_type, fix ); /*lint !e662 */
            }

            else {
              rec_ptr += FENDPOS( caii_subaddr_rec_type,
                   var[((caii_subaddr_rec_type *) rec_ptr)->fix.num_char - 1]);
            }
          }
          break;

        case CAI_GLOB_EM_CALL_REC:
        {

           if (  !((caii_global_emerg_type *) rec_ptr)->num_incl  )
             {
               b_packb(1, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
               msg_pos += FSIZ( cai_rec_hdr_type, record_len);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_incl,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix1_type, num_incl ));
               msg_pos += FSIZ(cai_global_emerg_fix1_type, num_incl);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->ms_orig_pos_loc_ind,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_var2_type, ms_orig_pos_loc_ind ));
               msg_pos += FSIZ(cai_global_emerg_var2_type, ms_orig_pos_loc_ind);

               b_packb( 0, buf_ptr, msg_pos, 6 );
               msg_pos += 6;

               /* that's all */
             }
             else /* digits included */
             {
               rec_len_pos = msg_pos;

               /* save the space for record length */
               msg_pos += FSIZ( cai_rec_hdr_type, record_len);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_incl,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix1_type, num_incl ));
                 msg_pos += FSIZ(cai_global_emerg_fix1_type, num_incl);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->digit_mode,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, digit_mode ));
                 msg_pos += FSIZ(cai_global_emerg_fix2_type, digit_mode);

               if (((caii_global_emerg_type *) rec_ptr)->digit_mode)
               {
                 b_packb( ((caii_global_emerg_type *) rec_ptr)->number_type,
                     buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, number_type ));
                   msg_pos += FSIZ(cai_global_emerg_fix2_type, number_type);

                 b_packb( ((caii_global_emerg_type *) rec_ptr)->number_plan,
                     buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, number_plan ));
                   msg_pos += FSIZ(cai_global_emerg_fix2_type, number_plan);
               }
               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_char,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, num_char ));
                 msg_pos += FSIZ(cai_global_emerg_fix2_type, num_char);

               for (j=0;
                    j < ((caii_global_emerg_type *) rec_ptr)->num_char; j++)
               {
                   if (((caii_global_emerg_type *) rec_ptr)->digit_mode)
                   {
                     b_packb( ((caii_global_emerg_type *) rec_ptr)->chari[j], buf_ptr,
                              msg_pos, FSIZ( cai_orig_var_type, char8 ));
                     msg_pos += FSIZ( cai_orig_var_type, char8 );
                   }
                   else
                   {
                     b_packb( ((caii_global_emerg_type *) rec_ptr)->chari[j], buf_ptr,
                              msg_pos, 4);
                     msg_pos += 4;
                   }
               }
               b_packb( ((caii_global_emerg_type *) rec_ptr)->ms_orig_pos_loc_ind,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_var2_type, ms_orig_pos_loc_ind ));
               msg_pos += FSIZ(cai_global_emerg_var2_type, ms_orig_pos_loc_ind);

               reserv_len = (msg_pos - rec_len_pos ) % 8;
               if (reserv_len != 0)
               {
                 reserv_len = 8 - reserv_len;
                 b_packb( 0, buf_ptr, msg_pos, reserv_len );
                 msg_pos += reserv_len;
               }

               /* put length (byte)(msg_pos - rec_len_pos) */
               b_packb( (int)(((msg_pos - rec_len_pos ) / 8) - 1) ,
                 buf_ptr, rec_len_pos, FSIZ( cai_rec_hdr_type, record_len ));

             } /* digits included */
          }
        rec_ptr += sizeof (caii_global_emerg_type); /*lint !e662 */
        break;

#ifdef FEATURE_IS2000_REL_C
        /* -------------------------------------------
        ** Extended Keypad Facility Information Record
        ** ------------------------------------------- */
        case CAI_EXT_KEYPAD_REC:
          {
            if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
            {
              /* Compute record length, add in reserved bits */
              if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
              {
                rec_len = sizeof(cai_ext_keypad_facility_info_fix_type) +
                          (sizeof(cai_ext_keypad_facility_info_var_type) *
                           ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields) + 2;
              }
              else
              {
                rec_len = FSIZ(cai_ext_keypad_facility_info_fix_type, number_info_incl) +
                          FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields) +
                          (sizeof(cai_ext_keypad_facility_info_var_type) *
                           ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields) + 1;
              }

              if ( msg_pos + rec_len > CAI_REV_TC_MSG_BODY_SIZE )
              {
                status = CAIX_INV_LEN_S;
              }
              else
              {
                /* Pack record length */
                b_packb(rec_len / 8, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
                msg_pos += FSIZ( cai_rec_hdr_type, record_len);

                /* Add other record fields */
                b_packb( ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl,
                         buf_ptr, msg_pos,
                         FSIZ( cai_ext_keypad_facility_info_fix_type, number_info_incl ));
                msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, number_info_incl);

                if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
                {
                  b_packb( ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_type,
                           buf_ptr, msg_pos,
                           FSIZ(cai_ext_keypad_facility_info_fix_type , number_type ));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, number_type);

                  b_packb( ((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.number_plan,
                           buf_ptr, msg_pos,
                           FSIZ(cai_ext_keypad_facility_info_fix_type , number_plan));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type , number_plan);
                }

                b_packb(((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.num_fields,
                        buf_ptr, msg_pos,
                        FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields));
                msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields);

                for (j=0; j < ((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.num_fields; j++)
                {
                  b_packb(((caii_ext_keypad_facility_info_type *)rec_ptr)->var[j].chari,
                          buf_ptr, msg_pos,
                          FSIZ(cai_ext_keypad_facility_info_var_type, chari));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_var_type, chari);
                }

                if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
                {
                  /* There are two reserved bits if number_info_incl is 1 */
                  b_packb(0, buf_ptr, msg_pos, 2);
                  msg_pos += 2;
                }
                else
                {
                  /* Otherwise, there is 1 */
                  b_packb(0, buf_ptr, msg_pos, 1);
                  msg_pos += 1;
                }

              }
            } /* REL C*/

            rec_ptr += sizeof(caii_ext_keypad_facility_info_fix_type) +
                       (sizeof(caii_ext_keypad_facility_info_var_type) *
                        ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields);

            break;
          } /* CAI_EXT_KEYPAD_REC */

#endif /* FEATURE_IS2000_REL_C */

         default:
          status = CAIX_INV_MSG_S;
          break;
      } /* end switch (((caii_rec_hdr_type *) rec_ptr)->record_type) */
      rec_ptr = (byte*)ALIGN_DWORD(((dword)rec_ptr));
    }  /* end for else */
  } /* end for loop */

  #ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
  auth_ext_encrypt_cdma( buf_ptr,
                         &msg_pos,
                         sdu_start_pos,
                         int_ptr->efwim.hdr.sdu_encrypt_mode,
                         int_ptr->efwim.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->efwim.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->efwim.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->efwim.hdr.msg_int.sdu_key_id,
                   int_ptr->efwim.msg_type,
                   int_ptr->efwim.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->efwim.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

status = CAIX_DONE_S;

#undef MTYPE
  /* Deactivate MTYPE definition */

  return ( status );

} /* xlate_int_tc_efwim */

/*===========================================================================

FUNCTION xlate_int_tc_epsmm

DESCRIPTION
  This function translates a Extended Pilot Strength Meas Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_epsmm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  word i;
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos=0;
  /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */

  byte reserve_bits;
  word rec_len_pos;
  word rec_start_pos;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_epsm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->epsmm );

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */


  b_packw( int_ptr->epsmm.ref_pn, buf_ptr, msg_pos,
           FSIZ(MTYPE, fix1.ref_pn));
  msg_pos += FSIZ(MTYPE, fix1.ref_pn) ;
  b_packb( int_ptr->epsmm.pilot_strength, buf_ptr, msg_pos,
           FSIZ(MTYPE, fix1.pilot_strength));
  msg_pos += FSIZ(MTYPE, fix1.pilot_strength) ;
  b_packb( int_ptr->epsmm.keep, buf_ptr, msg_pos,
           FSIZ(MTYPE, fix1.keep));
  msg_pos += FSIZ(MTYPE, fix1.keep) ;

  b_packb( int_ptr->epsmm.ref_pilot_rec_incl,
    buf_ptr, msg_pos, FSIZ( cai_epsm_var1_type, ref_pilot_rec_incl));
  msg_pos += FSIZ( cai_epsm_var1_type, ref_pilot_rec_incl );

  if (int_ptr->epsmm.ref_pilot_rec_incl)
  {

    /* at this point we can only pack auxilary pilot */
    /* note that Auxiliary pilot rec type is defined as 1 in caii.h
     but here it needs to be packed as 0 */

    b_packb( 0, buf_ptr, msg_pos,
      FSIZ( cai_epsm_var1_type, ref_pilot_rec_type));
    msg_pos += FSIZ( cai_epsm_var1_type, ref_pilot_rec_type );

    rec_len_pos = msg_pos;

    msg_pos += FSIZ( cai_epsm_var1_type, ref_record_len );

    rec_start_pos = msg_pos;

    /*  pack the reference pilot if it's auxiliary */
    if (int_ptr->epsmm.ref_pilot_rec_type == 0)
    {

      b_packb( int_ptr->epsmm.ref_rec.qof,
              buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,qof));
      msg_pos += FSIZ( cai_add_pilot_rec1_type,qof );

      b_packb( int_ptr->epsmm.ref_rec.walsh_length,
              buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,walsh_length));
      msg_pos += FSIZ( cai_add_pilot_rec1_type,walsh_length );

      b_packw( int_ptr->epsmm.ref_rec.aux_pilot_walsh,
               buf_ptr, msg_pos,
               int_ptr->epsmm.ref_rec.walsh_length + 6);

      msg_pos += int_ptr->epsmm.ref_rec.walsh_length + 6;

            /* length of reserved bits */
      reserve_bits = (sizeof( cai_add_pilot_rec1_type ) +
                                int_ptr->epsmm.ref_rec.walsh_length) %8;
      if( reserve_bits != 0 )
      {
        reserve_bits = 8 - reserve_bits;

         /* Pack reserved bits */
        b_packb( 0, buf_ptr, msg_pos, reserve_bits );
        msg_pos += reserve_bits;
      }
      /* Now pack the record length */

      b_packb( (msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
        FSIZ( cai_epsm_var1_type, ref_record_len ));
    }
  }


  b_packb( int_ptr->epsmm.sf_rx_power, buf_ptr, msg_pos,
    FSIZ(MTYPE, fix2.sf_rx_pwr));
  msg_pos += FSIZ(MTYPE, fix2.sf_rx_pwr);

  b_packb( int_ptr->epsmm.num_pilots, buf_ptr, msg_pos,
    FSIZ(MTYPE, fix2.num_pilots));
  msg_pos += FSIZ(MTYPE, fix2.num_pilots) ;

  for (i=0; i < int_ptr->epsmm.num_pilots; i++)
  {
    b_packw( int_ptr->epsmm.meas[i].pilot_pn_phase, buf_ptr,
      msg_pos, FSIZ( cai_epsm_var2_type, pilot_pn_phase ));
    msg_pos += FSIZ(cai_epsm_var2_type, pilot_pn_phase) ;

    b_packb( int_ptr->epsmm.meas[i].pilot_strength, buf_ptr,
      msg_pos, FSIZ( cai_epsm_var2_type, pilot_strength ));
    msg_pos += FSIZ(cai_epsm_var2_type, pilot_strength) ;

    b_packb( int_ptr->epsmm.meas[i].keep,
      buf_ptr, msg_pos, FSIZ( cai_epsm_var2_type, keep));
    msg_pos += FSIZ( cai_epsm_var2_type,  keep );

    b_packb( int_ptr->epsmm.meas[i].pilot_rec_incl,
      buf_ptr, msg_pos, FSIZ( cai_epsm_var2_type, pilot_rec_incl));
    msg_pos += FSIZ( cai_epsm_var2_type, pilot_rec_incl );

    if (int_ptr->epsmm.meas[i].pilot_rec_incl)
    {
      b_packb( 0,
          buf_ptr, msg_pos, FSIZ( cai_epsm_var2_type, pilot_rec_type));
          msg_pos += FSIZ( cai_epsm_var2_type, pilot_rec_type );

      rec_len_pos = msg_pos;

      msg_pos += FSIZ( cai_epsm_var2_type, record_len );

      rec_start_pos = msg_pos;

      if (int_ptr->epsmm.meas[i].pilot_rec_type == 0)
      {

        b_packb( int_ptr->epsmm.meas[i].rec.qof,
            buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,qof));
        msg_pos += FSIZ( cai_add_pilot_rec1_type,qof );

        b_packb( int_ptr->epsmm.meas[i].rec.walsh_length,
            buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,walsh_length));
        msg_pos += FSIZ( cai_add_pilot_rec1_type,walsh_length );

          /* if the aux walsh is less than 3, pack a byte */
        b_packw( int_ptr->epsmm.meas[i].rec.aux_pilot_walsh, buf_ptr,
                   msg_pos,
                   int_ptr->epsmm.meas[i].rec.walsh_length + 6);

        msg_pos += int_ptr->epsmm.meas[i].rec.walsh_length + 6;

          /* length of reserved bits */
        reserve_bits = (sizeof( cai_add_pilot_rec1_type ) +
                       int_ptr->epsmm.meas[i].rec.walsh_length ) %8;
        if( reserve_bits != 0 )
        {
          reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
          b_packb( 0, buf_ptr, msg_pos, reserve_bits );
          msg_pos += reserve_bits;
        }

        b_packb( (msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
                 FSIZ( cai_epsm_var2_type, record_len ));

      }
    }
  }

#ifdef FEATURE_IS2000_REL_B
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
  {
    b_packb( int_ptr->epsmm.resq_ind_incl, buf_ptr, msg_pos,
       FSIZ(MTYPE, fix3.resq_ind_incl));
    msg_pos += FSIZ(MTYPE, fix3.resq_ind_incl);

    if (int_ptr->epsmm.resq_ind_incl)
    {
      for (i=0; i < int_ptr->epsmm.num_pilots; i++)
      {
        b_packb( int_ptr->epsmm.resq[i].resq_ind, buf_ptr, msg_pos,
                 FSIZ(cai_epsm_var3_type, resq_ind));
        msg_pos += FSIZ(cai_epsm_var3_type, resq_ind);
      }
    }
  }
#endif /* FEATURE_IS2000_REL_B */

  #ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
  auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                        int_ptr->epsmm.hdr.sdu_encrypt_mode,
                        int_ptr->epsmm.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->epsmm.hdr.msg_int.maci_incl)
  {
    M1X_MSG( DCP, LEGACY_MED,
      "EPSMM using key ID %d",
      int_ptr->epsmm.hdr.msg_int.sdu_key_id);
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->epsmm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->epsmm.hdr.msg_int.sdu_key_id,
                   int_ptr->epsmm.msg_type,
                   int_ptr->epsmm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->epsmm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

#undef MTYPE
  /* Deactivate MTYPE definition */

  status = CAIX_DONE_S;

  /* Set message length */
  *len_ptr = msg_pos;

  return ( status );

} /* xlate_int_tc_epsmm */

/*===========================================================================

FUNCTION xlate_int_tc_ehcm

DESCRIPTION
  This function translates a Extended Handoff Completion Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_ehcm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */
  word i;
    /* counter for active pilot loop */
  word rec_len_pos;
    /* position where the length info needs to be packed */
  word rec_start_pos;
    /* starting position for the pilot record to be packed */
  byte reserve_bits;
    /* used for packing the zeros at the end for pilot recs */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->ehcm );

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->ehcm.last_hdm_seq, buf_ptr, msg_pos,
           FSIZ( cai_ehcm_fix_type, last_hdm_seq));
  msg_pos += FSIZ( cai_ehcm_fix_type, last_hdm_seq);

  b_packb( int_ptr->ehcm.num_pilots, buf_ptr, msg_pos,
           FSIZ( cai_ehcm_fix_type, num_pilots));
  msg_pos += FSIZ( cai_ehcm_fix_type, num_pilots);

  for (i=0; i < int_ptr->ehcm.num_pilots; i++)
  {
    b_packw( int_ptr->ehcm.act_pil_rec[i].pilot_pn, buf_ptr, msg_pos,
      FSIZ( cai_ehcm_fix1_type, pilot_pn ));
    msg_pos += FSIZ( cai_ehcm_fix1_type, pilot_pn);

    b_packb( int_ptr->ehcm.act_pil_rec[i].pilot_rec_incl, buf_ptr, msg_pos,
      FSIZ( cai_ehcm_fix1_type, pilot_rec_incl ));
    msg_pos += FSIZ( cai_ehcm_fix1_type, pilot_rec_incl);

    if (int_ptr->ehcm.act_pil_rec[i].pilot_rec_incl)
    {

      b_packb( int_ptr->ehcm.act_pil_rec[i].pilot_rec_type, buf_ptr, msg_pos,
          FSIZ( cai_ehcm_var_type, pilot_rec_type));
      msg_pos += FSIZ( cai_ehcm_var_type, pilot_rec_type );

      rec_len_pos = msg_pos;

      msg_pos += FSIZ( cai_ehcm_var_type, record_len );

      rec_start_pos = msg_pos;

      /*  pack the reference pilot if it's auxiliary
          see table 2.7.2.3.2.34-1*/
      if (int_ptr->ehcm.act_pil_rec[i].pilot_rec_type == 0)
      {
        b_packb( int_ptr->ehcm.act_pil_rec[i].rec.qof,
            buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,qof));
        msg_pos += FSIZ( cai_add_pilot_rec1_type,qof );

        b_packb( int_ptr->ehcm.act_pil_rec[i].rec.walsh_length,
            buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,walsh_length));
        msg_pos += FSIZ( cai_add_pilot_rec1_type,walsh_length );

        b_packw( int_ptr->ehcm.act_pil_rec[i].rec.aux_pilot_walsh, buf_ptr,
                   msg_pos,
                   int_ptr->ehcm.act_pil_rec[i].rec.walsh_length + 6);

        msg_pos += int_ptr->ehcm.act_pil_rec[i].rec.walsh_length + 6;

        /* length of reserved bits */
        reserve_bits = (sizeof( cai_add_pilot_rec1_type ) +
                              int_ptr->ehcm.act_pil_rec[i].rec.walsh_length ) %8;
        if( reserve_bits != 0 )
        {
          reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
          b_packb( 0, buf_ptr, msg_pos, reserve_bits );
          msg_pos += reserve_bits;
        }

        b_packb( (msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
                 FSIZ( cai_ehcm_var_type, record_len ));

      }
    }
  }

  #ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
  auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                        int_ptr->ehcm.hdr.sdu_encrypt_mode,
                        int_ptr->ehcm.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->ehcm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->ehcm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->ehcm.hdr.msg_int.sdu_key_id,
                   int_ptr->ehcm.msg_type,
                   int_ptr->ehcm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->ehcm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  status = CAIX_DONE_S;

  /* Set message length */
  *len_ptr = msg_pos;

  return ( status );

  /* Deactivate MTYPE definition */
} /* xlate_int_tc_ehcm */

/*===========================================================================

FUNCTION xlate_int_tc_smrm

DESCRIPTION
  This function translates a Security Mode Request Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_smrm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */
  word i;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_smrm_fix1_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->tsmrm );

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->tsmrm.ui_enc_incl, buf_ptr, msg_pos, FSIZ( MTYPE, ui_enc_incl));
  msg_pos += FSIZ( MTYPE, ui_enc_incl);

  if (int_ptr->tsmrm.ui_enc_incl)
  {
    b_packb( int_ptr->tsmrm.ui_encrypt_sup, buf_ptr, msg_pos, FSIZ( MTYPE, ui_encrypt_sup));
    msg_pos += FSIZ( MTYPE, ui_encrypt_sup);
    b_packb( int_ptr->tsmrm.num_recs, buf_ptr, msg_pos, FSIZ( MTYPE, num_recs));
    msg_pos += FSIZ( MTYPE, num_recs);

    for (i=0; (i < int_ptr->tsmrm.num_recs+1) && (i < MAX_TSMRM_RECS); i++)
    {
      b_packb( int_ptr->tsmrm.recs[i].con_ref, buf_ptr, msg_pos,
               FSIZ( cai_smrm_var_type, con_ref));
      msg_pos += FSIZ(cai_smrm_var_type, con_ref);
      b_packb( int_ptr->tsmrm.recs[i].ui_encrypt_req, buf_ptr, msg_pos,
               FSIZ( cai_smrm_var_type, ui_encrypt_req));
      msg_pos += FSIZ(cai_smrm_var_type, ui_encrypt_req);
    }
  }

  b_packb( int_ptr->tsmrm.sig_enc_incl, buf_ptr, msg_pos,
           FSIZ( cai_smrm_fix2_type, sig_enc_incl));
  msg_pos += FSIZ( cai_smrm_fix2_type, sig_enc_incl);

  if (int_ptr->tsmrm.sig_enc_incl)
  {
    b_packb( int_ptr->tsmrm.sig_encrypt_sup, buf_ptr, msg_pos,
         FSIZ( cai_smrm_fix2_type, sig_encrypt_sup));
    msg_pos += FSIZ( cai_smrm_fix2_type, sig_encrypt_sup);

    b_packb( int_ptr->tsmrm.d_sig_encrypt_req, buf_ptr, msg_pos,
           FSIZ( cai_smrm_fix2_type, d_sig_encrypt_req));
    msg_pos += FSIZ( cai_smrm_fix2_type, d_sig_encrypt_req);

  }

  b_packb( int_ptr->tsmrm.enc_seq_h_incl, buf_ptr, msg_pos,
         FSIZ( cai_smrm_fix2_type, enc_seq_h_incl));
  msg_pos += FSIZ( cai_smrm_fix2_type, enc_seq_h_incl);

  if (int_ptr->tsmrm.enc_seq_h_incl)
  {
      b_packd( int_ptr->tsmrm.enc_seq_h, buf_ptr, msg_pos,
            FSIZ( cai_smrm_fix2_type, enc_seq_h));
      msg_pos += FSIZ( cai_smrm_fix2_type, enc_seq_h);

      b_packb( int_ptr->tsmrm.enc_seq_h_sig, buf_ptr, msg_pos,
          FSIZ( cai_smrm_fix2_type, enc_seq_h_sig));
      msg_pos += FSIZ( cai_smrm_fix2_type, enc_seq_h_sig);

  }
#ifdef FEATURE_IS2000_REL_C
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
    b_packb( int_ptr->tsmrm.msg_int_info_incl, buf_ptr, msg_pos,
           FSIZ( cai_smrm_fix2_type, msg_int_info_incl));
    msg_pos += FSIZ( cai_smrm_fix2_type, msg_int_info_incl);
    if (int_ptr->tsmrm.msg_int_info_incl)
    {
      b_packb( int_ptr->tsmrm.sig_integrity_sup_incl, buf_ptr, msg_pos,
             FSIZ( cai_smrm_fix2_type, sig_integrity_sup_incl));
      msg_pos += FSIZ( cai_smrm_fix2_type, sig_integrity_sup_incl);

      if (int_ptr->tsmrm.sig_integrity_sup_incl)
      {
        b_packb( int_ptr->tsmrm.sig_integrity_sup, buf_ptr, msg_pos,
               FSIZ( cai_smrm_fix2_type, sig_integrity_sup));
        msg_pos += FSIZ( cai_smrm_fix2_type, sig_integrity_sup);
        b_packb( int_ptr->tsmrm.sig_integrity_req, buf_ptr, msg_pos,
               FSIZ( cai_smrm_fix2_type, sig_integrity_req));
        msg_pos += FSIZ( cai_smrm_fix2_type, sig_integrity_req);
      }
    }

  }
#endif /* FEATURE_IS2000_REL_C */

  #ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
  auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                        int_ptr->tsmrm.hdr.sdu_encrypt_mode,
                        int_ptr->tsmrm.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->tsmrm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->tsmrm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->tsmrm.hdr.msg_int.sdu_key_id,
                   int_ptr->tsmrm.msg_type,
                   int_ptr->tsmrm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->tsmrm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

  #undef MTYPE
  /* Deactivate MTYPE definition */

return ( status );

} /* xlate_int_tc_smrm */

/*===========================================================================

FUNCTION xlate_int_tc_ccm

DESCRIPTION
  This function translates a Call Cancel Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_ccm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_ccm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->ccm );

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->ccm.tag, buf_ptr, msg_pos, FSIZ( MTYPE, tag));
  msg_pos += FSIZ( MTYPE, tag);

  #ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
  auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                        int_ptr->ccm.hdr.sdu_encrypt_mode,
                        int_ptr->ccm.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->ccm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->ccm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->ccm.hdr.msg_int.sdu_key_id,
                   int_ptr->ccm.msg_type,
                   int_ptr->ccm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->ccm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

#undef MTYPE
  /* Deactivate MTYPE definition */

return ( status );

} /* xlate_int_tc_ccm */

/*===========================================================================

FUNCTION xlate_int_tc_dim

DESCRIPTION
  This function translates a Device Information Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_dim
(
  word *len_ptr,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to where translated message should be placed */

  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, of external info rec. */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_dim_fix_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->rdim );

  /* Translate remainder of fields for message */

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->rdim.wll_device_type,
           buf_ptr, msg_pos, FSIZ( MTYPE, wll_device_type));
  msg_pos += FSIZ( MTYPE, wll_device_type);

  b_packb( int_ptr->rdim.num_recs,
           buf_ptr, msg_pos, FSIZ( MTYPE, num_info_records));
  msg_pos += FSIZ( MTYPE, num_info_records);

  /* Translate info recs */
  for (i = irec_pos = 0; (i < int_ptr->rdim.num_recs); i++)
  {
    if((irec_pos/4) < CAII_MAX_INFO_REC_DWORDS)
    {
      status = xlate_int_info_rec((byte*) (&int_ptr->rdim.recs[irec_pos/4]), &irec_len,
                                  (word) (CAI_REV_TC_MSG_BODY_SIZE - msg_pos - FSIZ( cai_tc_strsp_fix_type, reserved)),
                                  buf_ptr, msg_pos, &xrec_len );
    }

    if (status != CAIX_DONE_S)
    {
      return (status);
    }

    msg_pos  += xrec_len; /* Advance external message position */
    irec_pos += irec_len; /* Advance internal message position */
    /* The next record will start only on a dword boundary, so move positions accordingly */

    irec_pos = (irec_pos%4) ? (irec_pos+(sizeof(dword))-irec_pos%4) : irec_pos;

  } /* for */

  #ifdef FEATURE_IS2000_REL_A_AES
  /* SDU done, call encryption fucntion */
  auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                        int_ptr->rdim.hdr.sdu_encrypt_mode,
                        int_ptr->rdim.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->rdim.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->rdim.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->rdim.hdr.msg_int.sdu_key_id,
                   int_ptr->rdim.msg_type,
                   int_ptr->rdim.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->rdim.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;
    /* Set message length */

  status = CAIX_DONE_S;

#undef MTYPE
  /* Deactivate MTYPE definition */

  return ( status );

} /* xlate_int_tc_dim */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_INT_BS_STATUS_REQ

DESCRIPTION
  This function translates a Traffic Channel Base Station Status Request
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_bs_status_req
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* Status to be returned to calling procedure */
  word i, j;
   /* Index to loop through character fields */
  word msg_pos=0;
  /* Position to pack message in */
  word record_len;
  /* Record length */
  word record_pos;
  /* Position of the record */
  word reserved_bits;
  /* Number of reserved bits to be packed */
  word qual_info_len;
  /* Qualinficaton Information Length */
#ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
  /* Start position for L3 fields */
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_bs_status_req_type

  /* ------------
  ** Pack message
  ** ------------ */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->bssreq);

#ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->bssreq.qual, buf_ptr, msg_pos,
           FSIZ( MTYPE, bss_fix.qual_info_type));
  msg_pos += FSIZ( MTYPE, bss_fix.qual_info_type);

  switch ( int_ptr->bssreq.qual )
  {
    case CAI_NO_QUAL:
      qual_info_len = 0;
      b_packb( (byte) qual_info_len, buf_ptr, msg_pos,
               FSIZ( MTYPE, bss_fix.qual_info_len ));
      msg_pos += FSIZ( MTYPE, bss_fix.qual_info_len);
      break;

    case CAI_BAND_QUAL:
      qual_info_len = sizeof(cai_qual_info1_type)/8;
      b_packb( (byte) qual_info_len, buf_ptr, msg_pos,
               FSIZ( MTYPE, bss_fix.qual_info_len ));
      msg_pos += FSIZ( MTYPE, bss_fix.qual_info_len);

      b_packb( int_ptr->bssreq.band, buf_ptr, msg_pos,
               FSIZ( MTYPE, qi.qi1.band ));
      msg_pos += FSIZ( MTYPE, qi.qi1.band );

      b_packb( 0, buf_ptr, msg_pos,
               FSIZ( MTYPE, qi.qi1.reserved ));
      msg_pos += FSIZ( MTYPE, qi.qi1.reserved );
      break;

    case CAI_BAND_OP_MODE_QUAL:
      qual_info_len = sizeof(cai_qual_info2_type)/8;
      b_packb( (byte) qual_info_len, buf_ptr, msg_pos,
               FSIZ( MTYPE, bss_fix.qual_info_len ));
      msg_pos += FSIZ( MTYPE, bss_fix.qual_info_len);

      b_packb( int_ptr->bssreq.band, buf_ptr, msg_pos,
               FSIZ(MTYPE, qi.qi2.band ));
      msg_pos += FSIZ(MTYPE, qi.qi2.band);
      b_packb( int_ptr->bssreq.op_mode, buf_ptr, msg_pos,
               FSIZ(MTYPE, qi.qi2.op_mode ));
      msg_pos += FSIZ(MTYPE, qi.qi2.op_mode );

      b_packb( 0, buf_ptr, msg_pos,
               FSIZ(MTYPE, qi.qi2.reserved ));
      msg_pos += FSIZ(MTYPE, qi.qi2.reserved );
      break;

    default:
      M1X_MSG( DCP, LEGACY_ERROR,
        "BSSREQ: Qual_info_type %d unsupported",
        int_ptr->bssreq.qual );
      return CAIX_INV_MSG_S;
  }

  b_packb( int_ptr->bssreq.num_record, buf_ptr, msg_pos,
           FSIZ( MTYPE, bss_fix.num_record ));
  msg_pos += FSIZ( MTYPE, bss_fix.num_record);

  if ( CAI_BSS_NUM_RECORDS < int_ptr->bssreq.num_record )
  {
    M1X_MSG( DCP, LEGACY_ERROR,
      "BSSREQ: num_record %d overflow",
      int_ptr->bssreq.num_record);
    return CAIX_INV_MSG_S;
  }

  for ( i = 0; i < int_ptr->bssreq.num_record; i++ )
  {
    if (int_ptr->bssreq.bss_rec[i].record_type != CAI_BSS_PILOT_INFO_REQ)
    {
      M1X_MSG( DCP, LEGACY_ERROR,
        "BSSREQ: Record_type %d unsupported",
        int_ptr->bssreq.bss_rec[i].record_type );
      return CAIX_INV_MSG_S;
    }
    else
    {
      b_packb( int_ptr->bssreq.bss_rec[i].record_type, buf_ptr, msg_pos,
               FSIZ( MTYPE, rec_fix.record_type ));
      msg_pos += FSIZ( MTYPE, rec_fix.record_type );

      /* Skip the record_length for now */
      msg_pos += FSIZ( MTYPE, rec_fix.record_length );

      /* Record Type 0. Set the record position here for the   */
      /* record type 0 specific fields.                        */
      record_pos = msg_pos;

      b_packb( int_ptr->bssreq.bss_rec[i].pi.num_pilots, buf_ptr, msg_pos,
               FSIZ( MTYPE, rec0.fix.num_pilots ));
      msg_pos += FSIZ( MTYPE, rec0.fix.num_pilots );
      b_packb( int_ptr->bssreq.bss_rec[i].pi.sid_nid_req, buf_ptr, msg_pos,
               FSIZ( MTYPE, rec0.fix.sid_nid_req ));
      msg_pos += FSIZ( MTYPE, rec0.fix.sid_nid_req );

      if (CAI_BSS_NUM_PILOTS < int_ptr->bssreq.bss_rec[i].pi.num_pilots)
      {
        M1X_MSG( DCP, LEGACY_ERROR,
          "BSSREQ: num_pilots %d overflow",
          int_ptr->bssreq.bss_rec[i].pi.num_pilots);
        return CAIX_INV_MSG_S;
      }

      for (j = 0; j < int_ptr->bssreq.bss_rec[i].pi.num_pilots; j++ )
      {
        b_packw( int_ptr->bssreq.bss_rec[i].pi.pilot_pn[j], buf_ptr, msg_pos,
                 FSIZ( MTYPE, rec0.var.pilot_pn ));
        msg_pos += FSIZ( MTYPE, rec0.var.pilot_pn );
      }

      /* Pack the reserved bits */
      reserved_bits = 8 - ((msg_pos - record_pos) % 8);
      if (reserved_bits != 8)
      {
        b_packb( 0, buf_ptr, msg_pos, reserved_bits );
        msg_pos += reserved_bits;
      }

      /* Pack the record_length, in octets */
      record_len = ( msg_pos - record_pos ) / 8;
      b_packb( (byte) record_len, buf_ptr,
               record_pos - FSIZ(MTYPE, rec_fix.record_length),
               FSIZ( MTYPE, rec_fix.record_length ));
    }
  } /* for num_record */

#ifdef FEATURE_IS2000_REL_A_AES
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    /* SDU done, call encryption function */
    auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                          int_ptr->bssreq.hdr.sdu_encrypt_mode,
                          int_ptr->bssreq.hdr.ack_req
                         );
  }
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->bssreq.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->bssreq.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->bssreq.hdr.msg_int.sdu_key_id,
                   int_ptr->bssreq.msg_type,
                   int_ptr->bssreq.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->bssreq.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

  #undef MTYPE

  return (status);

} /* xlate_int_bs_status_req */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
/*===========================================================================

FUNCTION xlate_int_tc_cotrm

DESCRIPTION
  This function translates a CDMA Off Time Report Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_cotrm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_cotrm_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->cotrm);

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->cotrm.cdma_off_time_enable, buf_ptr, msg_pos,
    FSIZ(MTYPE, cdma_off_time_enable));
  msg_pos += FSIZ(MTYPE, cdma_off_time_enable);

  if (int_ptr->cotrm.cdma_off_time_enable)
  {
    b_packb(int_ptr->cotrm.cdma_off_time_start, buf_ptr, msg_pos,
      FSIZ(MTYPE, cdma_off_time_start));
    msg_pos += FSIZ(MTYPE, cdma_off_time_start);

    b_packb(int_ptr->cotrm.cdma_off_time_unit, buf_ptr, msg_pos,
      FSIZ(MTYPE, cdma_off_time_unit));
    msg_pos += FSIZ(MTYPE, cdma_off_time_unit);

    b_packb(int_ptr->cotrm.cdma_off_time_mode, buf_ptr, msg_pos,
      FSIZ(MTYPE, cdma_off_time_mode));
    msg_pos += FSIZ(MTYPE, cdma_off_time_mode);

    b_packb(int_ptr->cotrm.cdma_off_time, buf_ptr, msg_pos,
      FSIZ(MTYPE, cdma_off_time));
    msg_pos += FSIZ(MTYPE, cdma_off_time);

    if (int_ptr->cotrm.cdma_off_time_mode)
    {
      b_packb(int_ptr->cotrm.cdma_off_time_period, buf_ptr, msg_pos,
        FSIZ(MTYPE, cdma_off_time_period));
      msg_pos += FSIZ(MTYPE, cdma_off_time_period);
    }

  }

  #ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
  auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                        int_ptr->cotrm.hdr.sdu_encrypt_mode,
                        int_ptr->cotrm.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->cotrm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->cotrm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->cotrm.hdr.msg_int.sdu_key_id,
                   int_ptr->cotrm.msg_type,
                   int_ptr->cotrm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->cotrm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

#undef MTYPE

  return ( status );

} /* xlate_int_tc_cotrm */
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION xlate_int_tc_aurspm

DESCRIPTION
  This function translates a Autehntication Response Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_aurspm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_aurspm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->taurspm );

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packq(int_ptr->taurspm.res_hi, buf_ptr, msg_pos,
            FSIZ(MTYPE,  res )/2);
  msg_pos += FSIZ(MTYPE,  res )/2;
  b_packq(int_ptr->taurspm.res_lo, buf_ptr, msg_pos,
            FSIZ(MTYPE,  res )/2);
  msg_pos += FSIZ(MTYPE,  res )/2;

  b_packb(int_ptr->taurspm.sig_integrity_sup_incl, buf_ptr, msg_pos,
          FSIZ(MTYPE,sig_integrity_sup_incl));
  msg_pos += FSIZ(MTYPE,sig_integrity_sup_incl);
  if (int_ptr->taurspm.sig_integrity_sup_incl)
  {
    b_packb(int_ptr->taurspm.sig_integrity_sup, buf_ptr, msg_pos,
            FSIZ(MTYPE,sig_integrity_sup));
    msg_pos += FSIZ(MTYPE,sig_integrity_sup);
    b_packb(int_ptr->taurspm.sig_integrity_req, buf_ptr, msg_pos,
            FSIZ(MTYPE,sig_integrity_req));
    msg_pos += FSIZ(MTYPE,sig_integrity_req);
  }
  b_packb(int_ptr->taurspm.new_key_id, buf_ptr, msg_pos,
          FSIZ(MTYPE,new_key_id));
  msg_pos += FSIZ(MTYPE,new_key_id);

  b_packd(int_ptr->taurspm.new_sseq_h, buf_ptr, msg_pos,
          FSIZ(MTYPE,new_sseq_h));
  msg_pos += FSIZ(MTYPE,new_sseq_h);


  #ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
  auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                        int_ptr->taurspm.hdr.sdu_encrypt_mode,
                        int_ptr->taurspm.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

  /* Pack MACI field */
  if (int_ptr->taurspm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->taurspm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->taurspm.hdr.msg_int.sdu_key_id,
                   int_ptr->taurspm.msg_type,
                   int_ptr->taurspm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->taurspm.hdr.msg_int.maci
                   );
  }

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

#undef MTYPE

  return ( status );

}

/*===========================================================================

FUNCTION xlate_int_tc_aursynm

DESCRIPTION
  This function translates a Autehntication ReSync Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_aursynm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
  word sdu_start_pos;
    /* Start position for L3 fields */
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_aursynm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->taursynm );

  #ifdef FEATURE_IS2000_REL_A_AES
  /* L3 SDU starts here */
  sdu_start_pos = msg_pos;
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packq(int_ptr->taursynm.con_ms_sqn, buf_ptr, msg_pos,
            FSIZ(MTYPE, con_ms_sqn ));
  msg_pos += FSIZ(MTYPE, con_ms_sqn );

  b_packq(int_ptr->taursynm.mac_s, buf_ptr, msg_pos,
          FSIZ(MTYPE,mac_s));
  msg_pos += FSIZ(MTYPE,mac_s);


  #ifdef FEATURE_IS2000_REL_A_AES
   /* SDU done, call encryption function */
  auth_ext_encrypt_cdma(buf_ptr, &msg_pos, sdu_start_pos,
                        int_ptr->taursynm.hdr.sdu_encrypt_mode,
                        int_ptr->taursynm.hdr.ack_req
                       );
  #endif /* FEATURE_IS2000_REL_A_AES */

  /* Pack MACI field */
  if (int_ptr->taursynm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->taursynm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->taursynm.hdr.msg_int.sdu_key_id,
                   int_ptr->taursynm.msg_type,
                   int_ptr->taursynm.hdr.msg_int.sdu_integrity_algo,
                   &int_ptr->taursynm.hdr.msg_int.maci
                   );
  }

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

#undef MTYPE

  return ( status );

}
#endif /* FEATURE_IS2000_REL_C */

/*===========================================================================

FUNCTION XLATE_INT_TC_MSG

DESCRIPTION
  This function translates a Traffic Channel message to be transmitted
  to the base station from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_msg
(
  word *len_ptr,
    /* Length of message in bits */
  byte *tc_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* Status to be returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (int_ptr->gen_tc.msg_type) {
    case CAI_TC_REV_ORD_MSG:
      status = xlate_int_tc_ord( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX order type 0x%x ack_seq %x msg_seq %x",
        int_ptr->tc_ord.gen.order,
        int_ptr->tc_ord.gen.hdr.ack_seq,
        int_ptr->tc_ord.gen.hdr.msg_seq );
      break;

    case CAI_TC_AUTH_RESP_MSG:
      status = xlate_int_auth_resp( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX auth resp, authu %lx",
        int_ptr->auth_resp.authu );
      break;

    case CAI_REV_FLASH_MSG:
      status = xlate_int_flash( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX Flash with %x records",
        int_ptr->flash.num_recs );
      break;

    case CAI_TC_REV_BURST_MSG:
      status = xlate_int_tc_burst( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC burst msg# %x type %x msgs %x",
        int_ptr->tc_burst.msg_number,
        int_ptr->tc_burst.burst_type,
        int_ptr->tc_burst.num_msgs );
      break;

    case CAI_PIL_STR_MSG:
      status = xlate_int_pil_str( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX Pil Str ref %x #pn's %x ",
        int_ptr->pil_str.ref_pn,
        int_ptr->pil_str.num_msr );
      break;

    case CAI_PWR_MSR_MSG:
      status = xlate_int_pwr_msr( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX PMRM, FCH/DCCH: errs %d frames %d",
        int_ptr->pwr_rpt.errors_detected,
        int_ptr->pwr_rpt.pwr_meas_frames );
      if (int_ptr->pwr_rpt.sch_pwr_meas_incl)
      {
        M1X_MSG( DCP, LEGACY_MED,
          "TX PMRM, SCH: errs %d frames %d",
          int_ptr->pwr_rpt.sch_errors_detected,
          int_ptr->pwr_rpt.sch_pwr_meas_frames);
      }
      break;

    case CAI_SEND_DTMF_MSG:
      status = xlate_int_send_dtmf( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX DTMF %x",
        int_ptr->sbdtmf.digit[0] );
      break;

    case CAI_STATUS_MSG:
      status = xlate_int_status( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX status message " );
      break;

    case CAI_ORIG_C_MSG:
      status = xlate_int_orig_c( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX Orig Cont with %x digits",
        int_ptr->orig_c.num_fields );
      break;

    case CAI_HO_COMP_MSG:
      status = xlate_int_comp( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX HO Comp with %x pilots, hdm_seq %x",
        int_ptr->comp.num_pilots,
        int_ptr->comp.last_hdm_seq );
      break;

    case CAI_PARM_RSP_MSG:
      status = xlate_int_parm_rsp( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "RX Parms Resp with %x parms",
        int_ptr->parm_rsp.num_parms );
      break;

    case CAI_RTC_SRV_REQ_MSG:
      status = xlate_int_srv_req( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX Srv Req. Purp: %x Num Con: %x",
        int_ptr->srv_req.purp,
        int_ptr->srv_req.cfg.num_con );
      break;

    case CAI_RTC_SRV_RSP_MSG:
      status = xlate_int_srv_rsp( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX Srv Rsp. Purp: %x Num Con: %x",
        int_ptr->srv_rsp.purp,
        int_ptr->srv_rsp.cfg.num_con );
      break;

    case CAI_SRV_CMP_MSG:
      status = xlate_int_srv_cmp( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX Srv Cmp. Con Seq: %x",
        int_ptr->srv_cmp.con_seq );
      break;

    case CAI_RTC_SRV_CTL_MSG:
      status = xlate_int_srv_ctl( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX Srv Ctl. Con Ref: %x SO: %x",
        int_ptr->srv_ctl.con_ref,
        int_ptr->srv_ctl.so );
      break;

    case CAI_TC_STRSP_MSG:
      status = xlate_int_tc_strsp( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX Stat Rsp" );
      break;

    case CAI_RTC_TMSI_CMP_MSG:
      status = xlate_int_tc_tmsi_cmp( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC TMSI Assignment Completion msg" );
      break;

    case CAI_SUP_CHAN_REQ_MSG:
      status = xlate_int_tc_sc_req( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Supplemental Channel Request msg" );
      break;

    case CAI_CFS_RSP_MSG:
      status = xlate_int_tc_cfs_rsp( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Candidate Frequency Search Response msg" );
      break;

    case CAI_CFS_RPT_MSG:
      status = xlate_int_tc_cfs_rpt( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Candidate Frequency Search Report msg" );
      break;

    case CAI_PER_PLT_STR_MSG:
      status = xlate_int_tc_per_plt( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Periodic Pilot Strength Measurement msg" );
      break;


    case CAI_OUTER_RPT_MSG:
      status = xlate_int_tc_outer_rpt( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Outer Loop Report Message" );
      break;

  case CAI_RES_REQ_MSG:
    status = xlate_int_tc_rrm( len_ptr, tc_ptr, int_ptr );
    M1X_MSG( DCP, LEGACY_MED,
      "TX TC Resource Request Message" );
    break;

  case CAI_EXT_REL_RSP_MSG:
    status = xlate_int_tc_errm( len_ptr, tc_ptr, int_ptr );
    M1X_MSG( DCP, LEGACY_MED,
      "TX TC Extended Release Response Message" );
    break;

  case CAI_RES_REL_REQ_MSG:
    status = xlate_int_tc_rrrm( len_ptr, tc_ptr, int_ptr );
    M1X_MSG( DCP, LEGACY_MED,
      "TX TC Resource Release Request Message" );
    break;


#ifdef FEATURE_IS2000_REL_A

      /* Following messages are added in Release A */

    case CAI_EOM_MSG:
      status = xlate_int_tc_eom( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Enhanced Origination Message" );
      break;

    case CAI_EFWIM_MSG:
      status = xlate_int_tc_efwim( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Extended Flash with Info Message" );
      break;

    case CAI_EPSMM_MSG:
      status = xlate_int_tc_epsmm( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Extended Pilot Strength Meas Message" );
      break;

    case CAI_EHOCM_MSG:
      status = xlate_int_tc_ehcm( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Extended Handoff Completion Message" );
      break;

    case CAI_SMRM_MSG:
      status = xlate_int_tc_smrm( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Security Mode Request Message" );
      break;

    case CAI_UZURM_MSG:
      status = xlate_int_tc_uzurm( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Uzer Zone Update Message" );
      break;

    case CAI_CLCM_MSG:
      status = xlate_int_tc_ccm( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Call Cancel Message" );
      break;

    case CAI_DIM_MSG:
      status = xlate_int_tc_dim( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Device Information Message" );
      break;

#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A
    case CAI_BS_STATUS_REQ_MSG:
      status = xlate_int_bs_status_req( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC BS Status Request Message" );
      break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
    case CAI_COTRM_MSG:
      status = xlate_int_tc_cotrm( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC CDMA Off Time Report Message" );
      break;
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
    case CAI_AUTH_RESYNC_MSG:
      status = xlate_int_tc_aursynm( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Auth Resync Message" );
      break;
    case CAI_AUTH_RSP_MSG:
      status = xlate_int_tc_aurspm( len_ptr, tc_ptr, int_ptr );
      M1X_MSG( DCP, LEGACY_MED,
        "TX TC Auth Response Message" );
      break;
#endif /* FEATURE_IS2000_REL_C */

    default:
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */


  if ((int_ptr->gen_tc.hdr.encryption == CAI_ENCRYPT_CALL_CTL_MSGS )
      && ((int_ptr->gen.msg_type != CAI_ORIG_C_MSG)
#ifdef FEATURE_IS2000_REL_A_SVD
      && (int_ptr->gen_tc.msg_type != CAI_EOM_MSG)
#endif /* FEATURE_IS2000_REL_A_SVD */
         )
     )
  {
    auth_encrypt_cdma( len_ptr, tc_ptr, int_ptr );
  }


  return (status);

} /* xlate_int_tc_msg */

/*===========================================================================

FUNCTION CAIX_INT_TO_EXT

DESCRIPTION
  This function translates a message from the internal format used by
  the Main Control task to the external format used by the Transmit
  task.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word caix_int_to_ext
(
  word *len_ptr,
    /* Pointer to where message length, in bits, should be placed */
  word chn,
    /* Channel message is to be transmitted on */
  caii_tx_msg_type *int_msg_ptr,
    /* Pointer to internal mesage to be translated */
  cai_tx_msg_type *tx_msg_ptr,

  /* Pointer to where translated message should be placed */
  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_AC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  caix_p_rev_in_use = mc_get_p_rev_in_use();

  switch (chn)
  {
    case CAIX_AC:
    #ifdef FEATURE_IS2000_REL_A
    case CAIX_REACH:
    case CAIX_RCCCH:
    case CAIX_RCSCH:
    #endif /* FEATURE_IS2000_REL_A */
      status = xlate_int_ac_msg( len_ptr, tx_msg_ptr->ac.body, int_msg_ptr, chn, parsing_reason );
      break;

    case CAIX_TC:
      status = xlate_int_tc_msg( len_ptr, tx_msg_ptr->tc.body, int_msg_ptr );
      break;

    default:
      status = CAIX_INV_CHN_S;
      break;
  } /* end of switch */

  return (status);

} /* cai_int_to_ext */

