/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

                        D A T A   S E R V I C E S
                A T   C O M M A N D   P R O C E S S O R

GENERAL DESCRIPTION
  This module provides the table driven AT modem command processor.

EXTERNALIZED FUNCTIONS INTERNAL TO DSAT UNIT    
  dsatcmdp_queue_token
    Queues token structure into token queue.

  dsatcmdp_flush_token_queue
    Flushes any tokens currently in token queue.

  dsatcmdpi_queue_cmd_results
    This function places the results of AT commands in a queue,
    so they can be output (or discarded) at the end of the command
    line.

  dsatcmdp_send_queued_cmd_results
    This functions flushes the results queue to the serial port or PS
    protocol stack based on the registered response routing function.
  
  dsatcmdp_discard_queued_cmd_results
    This functions discards any queued up AT command results.  Required
    for IS-707 unrecognized command processing.

  dsatcmdp_handle_async_cmd_rsp
    This function formats the raw unformatted response generated by an
    asynchronous command handler and queues it up for transmission.

  dsatcmdp_abort_command
    Calls abort command handler located in command table to abort the
    abortable AT command currently being processed.

  dsatcmdp_command_abort_complete
    Clears flag used during abort command processing and places SIO
    preprocessor in AT command mode.
  
  dsatcmdp_disable_cmd_abort_complete
    Disables termination of abort command handling of current command
    being processed when call to function to send result code is made
    by clearing flag.

  dsatcmdp_block_indications  
    Returns value to indicate whether or not indications sent to the TE
    should be blocked.
    
  dsatcmdp_send_respose_to_te
    If ATCOP gets an unsolicited asynchronous event, this function formats 
    the data that needs to be sent to TE.  Note this routine is intended
    for use in asynchronous events only.

INITIALIZATION AND SEQUENCING REQUIREMENTS
  Call the function dsat_init on initial power-up and call
  dsat_init_service_mode each time a new operating service mode
  is entered.

Copyright (c) 2000 - 2015 by Qualcomm Technologies Incorporated.
All Rights Reserved.
Qualcomm Confidential and Proprietary.
*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/

/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/datamodem/interface/atcop/src/dsatcmdp.c#1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
10/24/14   tk      ATCoP changes for dynamic memory optimizations.
09/04/14   pg      Fixed NULL DUP DSM During reassembly.
08/12/14   pg      Modified DS Profile APIs to per subs.
07/29/14   sc      Added support for NV Refresh.
06/27/14   tk      Added support for Dynamic ATCoP.
06/06/14   pg      Added support for SGLTE+G.
03/27/14   pg      Fixed NOCARRIER response for command issue.
03/16/14   tk      Fixed issue in URC queuing of DSM packet buffer chain.
03/14/14   tk      Optimized debug macros usage in ATCoP.
12/30/13   sc      Fixed static code bugs.
11/14/13   tk      Fixed issues in online command state.
10/19/13   tk      Fixed the forwarded commands abort handling issue.
09/13/13   tk      ATCoP changes for LTE and DSDS concurrency solution.
09/13/13   sc      Fixed KW errors.
08/06/13   pg      Fixed ASSERT issue.
08/01/13   sc      Fixed KW errors.
06/01/13   tk      Fixed call variables dynamic memory allocation issue.
05/16/13   sk      $QCCOPS command for Extension of network search.
04/02/13   tk      Fixed issues in single SIM device mode.
03/27/13   tk      Fixed issues in dual stack commands.
02/07/13   tk      ATCoP changes for DSDx Co-existence with TDS.
02/05/13   tk      Fixed memory leak issue in URC queuing.
01/30/13   tk      Fixed stack corruption issue.
01/04/13   tk      ATCoP changes for DSDX C/G+G with True World Mode Support.
11/30/12   tk      ATCoP changes for Triton DSDA.
10/12/12   tk      Fixed issue in command line processing with NO_RESULT_CODE.
08/22/12   sk      Mainlining Nikel Changes.
08/10/12   tk      Deprecated ATCoP - DIAG interface.
07/26/12   sb      Fixed KW Errors.
06/30/12   sk      Added UMTS_CMD check.
07/02/12   sk      Reset support for  CFUN = 7 followed by CFUN = 6
06/01/12   sk      TDS mode changes.
05/18/12   tk      Migrated to MSG 2.0 macros
04/11/12   sk      Adding support for forwarding CFUN.
02/17/12   sk      Migrating Data related AT commands interface to unified MH.
02/06/12   nc      Added support for ^SPN and URC Queue.
01/19/12   sk      Feature cleanup.
10/25/11   nc      Adopted prototype change for the usage of 'ds_cnedsd_if_get_preferred_sys'.
10/03/11   ua      Added support for LTE_CPHY_RFCHAIN_CNF to support DRX/PRX
                   in ATCoP. Currently, its only registration. 
10/04/11   mk      Fixed the memory leak in process_at_cmd_line function
07/22/11   dvk     Global Variable Cleanup
05/26/11   dvk     Global Variables Cleanup
04/20/11   bs      NIKEL Phase I support.
03/16/11   bs      Restructured command tables to be mode independant.
03/03/11   nc      Fixed CLCC for Fusion.
02/04/11   nc      Featurising CKPD under FEATURE_HS.
01/17/11   ad      Fixed compilation errors . 
01/11/11   ad      Removed pending variable .
01/11/11   ad      Remove extern usage.used get/set API for command associated  
                   value pointers.
10/25/10   ad      Init Changes for DSDS. 
10/07/10   ad      Added MSG_HIGH for command response.
10/06/10   ad      Added Error msg before Assert(0).
08/30/10   nc      Cleaned up few state variables in FUSION.
07/27/10   vk      Used correct API for preferred system check for FUSION
07/23/10   nc      Added 1x SMS Support for FUSION Architecture.
06/04/10   ua      Removing support of CKPD and HS services for all 
                   THIN UI targets.
06/04/10   bs      MMGSDI SESSION Migration.
05/14/10   sa      Added support for LTE packet event reporting.
05/10/10   kk      Added support for ^HC SMS commands.
04/20/10   bs      Added support for +CGCMOD for LTE.
03/18/10   nc      Added Support for $QCDGEN for LTE.
02/08/10   sa      Added function dsat_rmsm_done_handler().
01/15/10   ua      Moved send_response_to_te to common file. 
01/06/10   ua      Moving flow_ctl_type enum to a header file.  
01/06/10   bs      Added +CGACT command support for LTE.
12/15/09   nc      Featurisation changes for LTE.
11/24/09   sa      Fixed the blocking of AT commands during DSAT_ASYNC_CMD_MODE.
09/22/09   vrk	   Merged LTE changes.
09/14/09   na      Fixed $QCMIPNAI, $QCMIPMASS, $QCMIPMHSS responses 
                   after ATZ execution.
09/07/09   ps      CMI SU level modifications.
06/29/09   vg      Replacing the depricated MSG_XXX macro with MSG_SPRINTF_X.
04/29/09   ua      Fixed Lint High Errors.
04/29/09   ua      Fixed compiler warnings. 
04/20/09   bs/sa   Added support for Modem Bridge Architecture.
12/11/08   nc      Fixed Off Target Lint Errors
10/23/08   bs      Added support for 1X AT Phonebook commands.
10/17/08   bs      Fixed Klocwork issues.
08/27/08   bs      Fixed +CRM issue for JCDMA builds.
08/22/08   nc      Corrected the echo of second AT command during processing
                   of first one.
07/16/08   ua      Added support for external client support.
02/18/08   sa      Added modification for Passport Feature support.
05/05/08   sa      Updated AT command processing state using 
                   ds3g_siolib_get_at_state function.
12/26/07   bs      Corrected ATH command's async functionality.
11/24/07   ua      Fixed Lint-lows. 
10/17/07   ua      Modifying dsat_report_rate_val based on new connect 
                   rate stucture.
10/09/07   ss      Correcting the behaviour for GSM+1x targets.
09/13/07   sa      Feature wrapped S2 register in FEATURE_DATA_S2_REG.
08/24/07   ar      Fix feature wrapping for non-GCSD builds.
08/16/07   sa      Replaced dsat_get_escape_char_val with a genaral
                   query function for S register dsat_get_sreg_val().
08/06/07   pp      Added dependency note between +IFC and AT\Q commands.
07/27/07   ar      Added dsat_change_rlp_params() and dsat_get_rlp_params()
07/26/07   sa      Added dsat_get_escape_char_val.
06/21/07   ua      Enabling +CKPD command for single processor THIN UI builds.
05/18/07   sa      Changing async signal and async command handlers not to send 
                   response to TE, when async command processing is complete.
04/23/07   pp      Lint Medium fixes.
02/15/07   ss      Fixed lint high errors
02/12/07   ua      Removing support for +CKPD in THIN_UI builds
01/30/07   ss      Replaced banned string API calls
06/13/06   sl      Use SIOLIB active port on flow control interface.
03/31/06   snb     IS-707 mobile IP variables now in ds_1x_static_profile
01/20/06   snb     Change signal handling to allow multiple, simultaneous
                   signals to be correctly processed.
01/07/06   TMR     Added dsat_get_baud
09/07/05   ar      Added dsatetsicall_init_call().
09/07/05   ar      Add call response mode initialization.
08/14/05   sl      Added new API in serializer (dsat_change_sio_params).
07/29/05   ar      Add async subtask signal for CM event handling.
04/19/05   tkk     Initialization of vibrator, ringer, alert mode items.
04/19/05   dvp     Added a global to capture the AT cmd in execution.
04/15/05   ar      Add dsatcmdp_set_restricted_mode().
04/15/05   sb      Fixed lint errors
03/31/05   sb      Fixes from testing the serializer changes.
03/15/05   tkk     Featurized GPRS event indications under PS data wrapper.
03/15/05   sb      Fixes from testing the serializer changes.
02/18/05   ar      Add DIAG interface module initialization.
02/15/05   snb     Fix CDMA-only build issues.
01/17/05   ar      Add accessory support module to initialization sequence.
01/27/05   pdv     Merge from Sirius-ATCoP development.
01/27/05   pdv     Rebase from mainline.
01/17/05   tkk     Added support for +CGEREP command.
10/18/04   ar      Add generic timer support
08/16/04   gr      Fixed the problem with the AT+CDV command when there is
                   no delimiter between the command and dial string
07/15/04   snb     Fixed undefined variables in ERR_FATAL calls.
05/18/04   jk      Fixed bug in copying NAI information.
04/06/04   ar      Added dsatetsicall_init_call_param_from_nv() to NV sync.
02/24/04   snb     Added support for handling SMSes via signals.
01/15/04   sb      Removed the extern declaration of dsat_report_rate_val
01/06/03   snb     Move registration for pin event with GSDI and handling 
                   callback for pin events to common file and add protocol
                   stack re-initialization under feature define.
11/28/03   sb      CDMA SMS changes
11/19/03   ar      Added check for default structure on all parameters.
11/14/03   snb     Add support for CSD call data rate reporting on CONNECT.
11/11/03   ar      Add check for async event table end in processing loop.
10/08/03   snb     Assume restricted mode on power-up when 
                   FEATURE_DATA_ETSI_PIN enabled
08/29/03   ar      Bypass restricted cmd check in non-ETSI modes.
08/13/03   snb     Added support for $QCPDPLT command
07/30/03   ar      Added dsatetsicall_init_crlp_export() to initialization.
06/10/03   ar      Invoke dsatutil_init_pkt_dial_string_from_nv() during
                   init.  Removed obsolete header file.
05/21/03   rsl     Changed temp_qos_pri type to byte to match rlp func. proto.
05/21/03   atp     Added include dsrlp.h - the change below inadvertently
                   removed it. 
05/05/03   jd      Removed dependency on dsiface_def.h
05/01/03   sb      While processing command line check to see if we are 
                   processing ATH command. If so then exit processing the
                   command line. It will be called later when call is dropped
                   and DSMGR sends us the result code.
04/28/03   sb      AT command flow control. Removed FEATURE_DSAT_FLOW_CONTROL
                   Changed the queue limit #define to a variable. 
04/17/03   dgy     Merged GSM and WCDMA CS Data mode-specific handlers.
04/04/03   ar      Add flush of ME notifications after cmdline processed.
03/17/03   ar      Correct range offset increment for BROKEN_RANGE logic.
02/26/03   ar      Added intialization of ETSI PDP activation tracking.
02/25/03   ar      Removed reset_cbst_val() function.
02/20/03   wx      Clean the feature define logics in dsatcmdp_init_config
02/14/03   wx      Add ABORTING state to the abortable command to 
                   handle the aborting in async command processing.
02/10/03   wx      Add NO_RESET attrib for cmd to prevent ATZ, AT&F
                   from changing parameter values.
01/13/03   ar      Removed call to dsatetsipkt_init_pdp_context() during init
01/09/03   wx      Add support for export +ES and +ESA values
01/07/03   sb      reduced the priority of MSG(E) to MSG_HIGH when we receive
                   unexpected event (when we are in a wrong mode)
12/12/02   ar      Added call to dsatesticmif_init_cmif()
12/05/02   ak      On a strcpy, needed a typecast (under MOBILE_IP)
12/02/02   ak      Compiler fixes for Mobile IP under 1X.
11/14/02   jd      Fixed AT$QCMIPNAI hdling, set QCMDR/QCMIP/CRM correctly
                   on startup.
11/11/02   sb      Moved ETSI related NV initialization into dsat_nv_sync()
                   function.
11/08/02   sb      Check to see if command handlers return NO_CARRIER (for 
                   abortable commands) before setting the SIO preprocessor mode
                   to Abortable mode.
11/07/02   ar      Added FEATURE_GSM_GPRS to FEATURE_DATA_WCDMA_PS wrappers
10/28/02   sb      Added Voice SM initialization functions
10/09/02   sb      Fixed Simba R5.0 Merge issues
10/07/02   atp     Fixed compilation bugs in REL_A.
09/24/02   atp     Added support for QOS. (1x Release-A feature).
09/05/02   sb      ATCOP changes based on new Multi mode Data services design
07/13/02   atp     In process_at_cmd_line() added code to check if fmt 
                   response function registered and if so calls it instead
                   of default fmt_response().
07/12/02   ak      Changes to support writing new IPR value into nv.
07/01/02   ak      When CDMA mode, in init, needed 'break' in switch.
06/27/02   ar      Accomodate changed interface to packet data initialization
06/27/02   wx      Drop any incoming AT cmd when ATCOP is processing an
                   Async cmd
06/11/02   wx      Fix a problem of dsatcmdp_queue_cmd_results.  It lost a 
                   dsm item when cmd_results_hold_queue count reaches 
                   MAX_QUEUED_DSM_ITEMS.
04/17/02   rc      Removed FEATURE wrap FEATURE_DS_SOCKETS around dns 
                   functions.
02/21/02   sjd     Changed init service mode parameter to CM system mode type.
08/28/01   sjd     Modifications to support new ATCOP VU structure.
08/10/01   sjd     Initial release to MSM5200 archives.

===========================================================================*/


/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/
#include "datamodem_variation.h"
#include "comdef.h"
#include "customer.h"
#ifdef FEATURE_DATA_IS707

#include <stringl/stringl.h>
#endif /* FEATURE_DATA_IS707 */


#include "target.h"
#include "err.h"
#include "amssassert.h"
#include "ds3gmgr.h"
#include "ds3gsiolib.h"
#include "ds3gsiolib_ex.h"
#include "dsati.h"
#include "dstaski.h"
#include "dsatctab.h"
#include "dsatvend.h"
#include "dsatcmif.h"
#include "dsatvoice.h"
#include "dsatact.h"
#include "dsatme.h"
#include "dsatclient.h"
#include "dsat_ext_api.h"
#include "msg.h"
#include "sio.h"
#include "sys.h"
#include "nv.h"

#if defined(FEATURE_CDMA_SMS) || defined(FEATURE_ETSI_SMS)
#include "dsatsms.h"
#endif /* defined(FEATURE_CDMA_SMS) || defined(FEATURE_ETSI_SMS) */

#ifdef FEATURE_DSAT_ETSI_MODE
#include "dsatetsictab.h"
#include "dsatetsime.h"
#include "dsatetsicmif.h"
#include "dsatetsicall.h"

#if defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS)
#include "dsatetsicall.h"
#include "dsucsdappif.h"
#endif /* defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS) */

#ifdef FEATURE_DSAT_ETSI_DATA
#include "dsatetsipkt.h"
#endif /* FEATURE_DSAT_ETSI_DATA */
#endif /* FEATURE_DSAT_ETSI_MODE */

#if defined(FEATURE_DATA_IS707)
#ifdef FEATURE_IS2000_REL_A
#include "ds707.h"
#include "dsrlp_v.h"
#endif /* FEATURE_IS2000_REL_A */
#include "dsat707vendctab.h"
#include "dsat707util.h"
#ifdef FEATURE_DS_MOBILE_IP
#include "dsat707mipctab.h"
#include "dsat707mip.h"
#include "ds707_so_pkt.h"
#include "dsat707mip_api.h"
#endif /* FEATURE_DS_MOBILE_IP */
#include "ds_1x_profile.h"
#include "ds707_jcdma_m51.h"
#include "dsatparm.h"
#include "ds707_pkt_mgr.h"
#endif /* FEATURE_DATA_IS707 */

#ifdef FEATURE_DSAT_MDM_FUSION
#include "ds707_rmsm_proxy.h"
#include "ds3gdsdif.h"
#endif /* FEATURE_DSAT_MDM_FUSION */

#ifdef FEATURE_DATA_LTE
  #include "dsmsgr.h"
  #include "lte_cphy_msg.h"
#endif /* FEATURE_DATA_LTE */
#include "dsatetsipkt.h"

/*===========================================================================

                    REGIONAL DEFINITIONS AND DECLARATIONS

===========================================================================*/

/*---------------------------------------------------------------------------
    Flag that indicates a forwarded command is under processing along
    with the port it is pending.
---------------------------------------------------------------------------*/
dsat_fwd_at_pending_type dsatcmdp_processing_fwd_cmd = {0};

/*---------------------------------------------------------------------------
    Flag that indicates whether or not ME is operating in restricted
    command mode due to authorization requirement.
---------------------------------------------------------------------------*/
extern boolean dsatcmdp_restricted_commands[];
/*---------------------------------------------------------------------------
    Flag that indicates a async cmd is under processing,
    Atcop preprocessor does not process any incoming char when it is TRUE.
---------------------------------------------------------------------------*/
extern boolean dsatcmdp_processing_async_cmd;

/*---------------------------------------------------------------------------
    Flag that indicates ATH cmd is under processing,
    continues to process the AT command line if TRUE.
---------------------------------------------------------------------------*/
boolean dsati_processing_ath_cmd = FALSE;

/*---------------------------------------------------------------------------
  ds_nv_baud_cmd_buf: Give command to NV to change the Baud Rate.
  This buffer is used to send commands to NV for changing the Baud rate.  A
  new buffer has been used instead of using the DS command buffer because
  ds_change_baud function can be called from any task. The existing nv
  command type expects only DS to call it and blocks the DS task. Since, we
  donot want it to happen, a new command buffer has been used.
  Note that this new command buffer is used by Non-Data tasks only.
---------------------------------------------------------------------------*/
nv_cmd_type ds_nv_baud_cmd_buf;

/* Pointer to function defining how responses should be formated. */
extern dsat_fmting_func_type fmt_at_cmd_rsp_func_ptr;

#ifdef FEATURE_DSAT_MDM_FUSION
extern boolean dsat_sms_over_ims;
uint32 forwarded_command_attribute;
boolean append_response = FALSE;
#endif /* FEATURE_DSAT_MDM_FUSION */

#if defined(FEATURE_ETSI_PBM) || defined(FEATURE_DSAT_CDMA_PBM)
extern me_pb_entry_type me_cpbs_entry;
#endif /* defined(FEATURE_ETSI_PBM) || defined(FEATURE_DSAT_CDMA_PBM) */

/* Hold the variables of the command in execution */
dsat_cmd_hdlr_state_s_type dsat_curr_cmd_var = {0};

/*===========================================================================

            LOCAL DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains local definitions for constants, macros, types,
  variables and other items needed by this module.

===========================================================================*/

/*--------------------------------------------------------------------------
  Debug macro for this module.
---------------------------------------------------------------------------*/

#define DEBUG( x )

/*--------------------------------------------------------------------------
  Array of pointers to unrecognized command handlers for each AT command
  operating mode supported.
---------------------------------------------------------------------------*/
extern dsati_unrec_cmd_handler_ptr_type
        unrec_cmd_handler[NUM_OPER_CMD_MODES];

/*--------------------------------------------------------------------------
  Pointer to support processing of abortable commands.  Points to command
  table entry of the currently executing abortable AT command.
---------------------------------------------------------------------------*/
const dsati_cmd_type       *abort_cmd_table_entry_ptr;
const dsati_cmd_abort_type *abort_cmd_table_entry_ptr_ex;

/*--------------------------------------------------------------------------
   Pointer to support processing of abortable commands. This holds current
   dsat_fwd_at_cmd_table_type pointer.
---------------------------------------------------------------------------*/
LOCAL dsat_fwd_at_cmd_table_type*  curr_ext_at_abort_fwd_ptr = NULL;

#define TOKEN_BUF_CNT    40
/*Gives the total number of tokens present at a time*/
LOCAL uint8  total_tokens = 0;

LOCAL q_type token_q;

LOCAL token_q_struct_type*  curr_token_ptr = NULL;

/*--------------------------------------------------------------------------
  Queue to hold command responses while processing an AT command line.
  The maximum number of DSM items on the queue is controlled by the
  maximum queued DSM items threshold.  This is used to control DSM
  usage for command line responses, as some responses can be large.
  Note: This threshold may need to be modified to support IS-707 mode
  of operation.
---------------------------------------------------------------------------*/
LOCAL q_type cmd_results_hold_queue;

/* Based on mode this variable will be changed.
   If it is ETSI then we can send it to TE as we are ready to send 
   However in IS707 we need to hold 5 items before we flush 
*/
extern int max_queued_dsm_items;

/*--------------------------------------------------------------------------
  Buffer to hold token command line data for items on token queue and
  pointers to manage buffer.
---------------------------------------------------------------------------*/
#define TOKEN_BUF_SIZE  (2*MAX_LINE_SIZE)

LOCAL byte *token_buffer    = NULL;
LOCAL byte *token_fill_ptr  = NULL;
LOCAL byte *token_empty_ptr = NULL;

extern uint32 curr_cmd_attrib;

/*-------------------------------------------------------------------------
   Pointer to the AT command line currently being processed.
-------------------------------------------------------------------------*/
LOCAL byte *at_cmd_line_ptr = NULL;


/*-------------------------------------------------------------------------
   Pointer to formatted response DSM item containing results of commands
   processed on the current AT command line.  It is global to this module
   to support asynchronous command processing, where two calls are made
   to the command line processor to process each asynchronous command in
   the command line.  This pointer points to buffers allocated across
   asynchronous events for asynchronous commands in a command line.
-------------------------------------------------------------------------*/
LOCAL dsm_item_type *formatted_rsp_ptr;

typedef struct {
  q_link_type    link;         /* Queue link type */
  dsm_item_type *dsm_item_ptr; /* DSM item pointer */
} dsat_urc_msg_type;

#define DSAT_MAX_QUEUED_URC 20

extern dsat_sio_info_s_type *dsatcmdp_sio_info_ptr[DS3G_SIOLIB_PORT_MAX];

/*-------------------------------------------------------------------------
   Flow control type received by +IFC command.  The ordering of this enum
   is largely dictated by the standard.

   Note: Any changes to +IFC command [mainly the following structure] affects 
   the flow control command AT\Q.
-------------------------------------------------------------------------*/       
typedef enum
{
  DS_FCTL_OFF,                             /* Flow control disabled.       */
  DS_XONXOFF_STRIP_FCTL,                   /* Use XON/XOFF flow control 
                                              but strip XON/XOFF characters
                                              from stream.                 */
  DS_CTSRFR_FCTL,                          /* Hardware flow control.       */
  DS_XONXOFF_NSTRIP_FCTL,                  /* Use XON/XOFF flow control 
                                              and leave XON/XOFF characters
                                              in stream.                   */
  DS_MAX_FLOW                              /* For bounds checking only.    */

} flow_ctl_type;                

/*-------------------------------------------------------------------------
    Prototypes for local functions:
-------------------------------------------------------------------------*/

LOCAL void process_at_cmd_line
(
  dsat_mode_enum_type at_state,
  dsat_result_enum_type result_code,
  byte *cmd_line_ptr
);

LOCAL void free_token
(
  token_q_struct_type *token_item_ptr
);

LOCAL void dsatcmdp_etsi_nv_sync( void );

LOCAL void set_flow_control
(
  ds3g_siolib_port_e_type  port_id
);
LOCAL sio_flow_ctl_type convert_flow_control
( 
  flow_ctl_type    flow_ctl,              /* Flow control method          */
  boolean          fail_safe              /* Fail safe                    */
);
#ifdef FEATURE_DSAT_MDM_FUSION
LOCAL void dsat_process_cmd_attrib
( 
  const dsati_cmd_type *table_ptr, 
  uint32 *attr
);

LOCAL void dsat_forward_cdma_cmd
(
  const dsati_cmd_type *table_ptr, 
  token_q_struct_type  *token_ptr,
  dsm_item_type        *raw_rsp_ptr
);
#endif /* FEATURE_DSAT_MDM_FUSION */

LOCAL dsat_result_enum_type cmdp_validate_cmd_forwarding
(
  token_q_struct_type *token_ptr         /* Pointer to current token    */
);
/*===========================================================================

FUNCTION  DSATCMDP_INIT

DESCRIPTION
 This Function will intiate ATcop intialization.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  Initializes ATCOP internal variables and queues.

===========================================================================*/
void dsatcmdp_init( void )
{
  /*-------------------------------------------------------------------------
    Initialize queue used to hold responses for commands in AT command line.
  -------------------------------------------------------------------------*/
  (void) q_init( &cmd_results_hold_queue );

  /*-------------------------------------------------------------------------
    Initialize queues used for token structures.
  -------------------------------------------------------------------------*/
  (void) q_init( &token_q );
  /*-------------------------------------------------------------------------
    Initialize token buffer on the heap with TOKEN_BUF_SIZE. This buffer will
    not be de-allocated until the scope of ATCOP.
  -------------------------------------------------------------------------*/
  token_buffer = (byte *) dsat_alloc_memory(TOKEN_BUF_SIZE, FALSE);

  /*-------------------------------------------------------------------------
    Assign token_fill_ptr and token_empty_pointer to tokken_buffer.
  -------------------------------------------------------------------------*/
  token_fill_ptr  = token_buffer;
  token_empty_ptr = token_buffer;

  /*------------------------------------------------------------------------
    Initialize all internal ATCOP variables.
  -------------------------------------------------------------------------*/
  abort_cmd_table_entry_ptr = NULL;
  abort_cmd_table_entry_ptr_ex = NULL;

  /*-------------------------------------------------------------------------
    Set defaults from NV for command processing
  -------------------------------------------------------------------------*/
  dsatcmdp_etsi_nv_sync();

  /*-------------------------------------------------------------------------
    Initialize the operating system timers.
  -------------------------------------------------------------------------*/
  dsatutil_init_timers();

  /*------------------------------------------------------------------------
    Initialize ATCoP/Call Manager interface 
  -------------------------------------------------------------------------*/
  dsatcmif_init_cmif();

  /*------------------------------------------------------------------------
    Initialize SMS (Initialize and register Call Back functions)
  -------------------------------------------------------------------------*/
  dsatsms_init_sms();

#ifdef FEATURE_DSAT_ETSI_DATA
  /*-------------------------------------------------------------------------
    Initialize ETSI PDP context activation tracking
  -------------------------------------------------------------------------*/
  dsatetsicmif_init_pdp_connect_state( );
#endif /* FEATURE_DSAT_ETSI_DATA */

#ifdef FEATURE_DSAT_DYNAMIC_LOADING
  dsatme_init_config_from_efs();
#endif /* FEATURE_DSAT_DYNAMIC_LOADING */

  return;
  
} /* dsatcmdp_init( ) */

/*===========================================================================

FUNCTION  DSATCMDP_DEINIT

DESCRIPTION
  This function deinitializes ATcoP.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_deinit( void )
{
  /*-------------------------------------------------------------------------
    Deinitialize queue used to hold responses for commands in AT command line.
  -------------------------------------------------------------------------*/
  q_destroy( &cmd_results_hold_queue );

  /*-------------------------------------------------------------------------
    Deinitialize queues used for token structures.
  -------------------------------------------------------------------------*/
  q_destroy( &token_q );

  /*-------------------------------------------------------------------------
    De-initialize token_buffer from the heap
  -------------------------------------------------------------------------*/
  dsatutil_free_memory_ext((void **) &token_buffer);

  /*-------------------------------------------------------------------------
    Deinitialize the operating system timers.
  -------------------------------------------------------------------------*/
  dsatutil_deinit_timers();

  /*------------------------------------------------------------------------
    Deinitialize ATCoP/Call Manager interface 
  -------------------------------------------------------------------------*/
  dsatcmif_deinit_cmif( );

  /*------------------------------------------------------------------------
    Deinitialize SMS (Deinitialize and deregister Call Back functions)
  -------------------------------------------------------------------------*/
  dsatsms_deinit_sms( );

  return;
} /* dsatcmdp_deinit( ) */

/*===========================================================================

FUNCTION  DSATCMDP_INIT_SIO_INFO

DESCRIPTION
  This function initializes the SIO info for a given port ID if not
  already initialized.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

dsat_sio_info_s_type *dsatcmdp_init_sio_info
(
  ds3g_siolib_port_e_type port_id
)
{
  if ((port_id < DS3G_SIOLIB_DATA_PORT) || (port_id >= DS3G_SIOLIB_PORT_MAX))
  {
    ERR_FATAL("Invalid SIO Port ID", 0, 0, 0);
  }

  if (NULL == dsatcmdp_sio_info_ptr[port_id])
  {
    dsatcmdp_sio_info_ptr[port_id] =
      dsat_alloc_memory(sizeof(dsat_sio_info_s_type), FALSE);

        /* All the bytes in cmd_line_buffer and prev_line_buffer arrays are already
           initialized to 0 in dsat_alloc_memory() */
    dsatcmdp_sio_info_ptr[port_id]->at_cmd_prep_state      = DSAT_CMD_PREP_STATE_HUNT;
    dsatcmdp_sio_info_ptr[port_id]->build_cmd_ptr          = NULL;
    dsatcmdp_sio_info_ptr[port_id]->prev_cmd_ptr           = NULL;
    dsatcmdp_sio_info_ptr[port_id]->block_indications_flag = FALSE;
    dsatcmdp_sio_info_ptr[port_id]->qcsimapp_val           = dsatcmdp_dds_qcsimapp_val;
    dsatcmdp_sio_info_ptr[port_id]->qcsimapp_val_updated   = DSAT_QCSIMAPP_VAL_INVALID;
    dsatcmdp_sio_info_ptr[port_id]->qcsimapp_val_user_flag = FALSE;

    (void) q_init(&dsatcmdp_sio_info_ptr[port_id]->urc_msg_q);
  }

  return dsatcmdp_sio_info_ptr[port_id];
} /* dsatcmdp_init_sio_info */

/*===========================================================================

FUNCTION  DSATCMDP_IS_SIO_INFO_INITED

DESCRIPTION
  This function returns if the SIO info is initialized for a given port ID.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

boolean dsatcmdp_is_sio_info_inited
(
  ds3g_siolib_port_e_type port_id
)
{
  if ((port_id < DS3G_SIOLIB_DATA_PORT) || (port_id >= DS3G_SIOLIB_PORT_MAX))
  {
    ERR_FATAL("Invalid SIO Port ID", 0, 0, 0);
  }

  if (NULL == dsatcmdp_sio_info_ptr[port_id])
  {
    return FALSE;
  }

  return TRUE;
} /* dsatcmdp_is_sio_info_inited */

/*===========================================================================

FUNCTION  DSATCMDP_GET_SIO_INFO_PTR

DESCRIPTION
  This function returns the SIO info pointer for a given port ID.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

dsat_sio_info_s_type *dsatcmdp_get_sio_info_ptr
(
  ds3g_siolib_port_e_type port_id
)
{
  dsat_sio_info_s_type *sio_info_ptr = NULL;

  if ((port_id >= DS3G_SIOLIB_DATA_PORT) && (port_id < DS3G_SIOLIB_PORT_MAX))
  {
    sio_info_ptr = dsatcmdp_sio_info_ptr[port_id];
  }

  if (NULL == sio_info_ptr)
  {
    ERR_FATAL("Invalid SIO Info: Port = %d", port_id, 0, 0);
  }

  return sio_info_ptr;
} /* dsatcmdp_get_sio_info_ptr */

/*===========================================================================

FUNCTION DSATI_PROCESS_CMD_LINE

DESCRIPTION
  This function parses the AT command line, which may contain multiple
  commands, and processes the commands. Command line does not include
  leading "AT" and is NULL terminated.  Command processing is dependent on
  AT mode: command, online data, or online commmand.  

  Command response and command line result codes are generated.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  Token queue is emptied.
  Verifies no DSM items are allocated by referencing formatted_rsp_ptr 
  and will free item if one is allocated.
  
===========================================================================*/
void dsatcmdp_process_cmd_line
(
  dsat_mode_enum_type at_state,         /* Command, online data, or online
                                           command */
  byte *cmd_line_ptr                    /* Pointer to NULL terminated
                                           command line. */
)
{
  /* If we are in the middle of processing an async commond
     We drop this new line of at cmd */
  if(dsatcmdp_processing_async_cmd)
  {
    DS_AT_MSG0_ERROR("AT command is already in process");
    return;
  }
  /* Initialize pointer to command line currently being processed. */
  at_cmd_line_ptr = cmd_line_ptr;

  /* Verify the formatted response pointer is NULL.  This should always
     be the case when this function is called, as it is only called to
     process a new command line. */
  if ( formatted_rsp_ptr != NULL )
  {
    DS_AT_MSG0_ERROR("Async cmd handling error - formatted rsp item allocated!");

    dsm_free_packet( &formatted_rsp_ptr );
  }
    
  /* Parse command line */
  if ( dsatpar_parse_cmd_line( cmd_line_ptr ) != DSAT_ERROR )
  {
    /* Process parsed AT commands.  Initial command result code must be
       OK in order for command line to be processed. */
    process_at_cmd_line( at_state, DSAT_OK, cmd_line_ptr );

  }

} /* dsatcmdp_process_cmd_line( ) */


/*===========================================================================

FUNCTION PROCESS_AT_CMD_LINE

DESCRIPTION
  This function processes all commands in a command line.  It processes
  token structures generated by the parser for each command in the command
  line.  These token structures are located in a queue.  The AT command
  processor is table driven.  Based on the ME operating mode and information
  contained within the token structure, a linear search is performed to
  find the command in one of the command tables.  When a match is found
  a command processing function is called to process the command.  The
  response generated by the command, if any, and command result code are
  sent to the destination which is typically the TE.

  Note, in order for a new command line to be processed, the initial result
  code passed in must be DSAT_OK.  To continue processing a command line
  after a command requiring asynchronous events is processed, the result
  code should be set to the result code of the command just completed.

DEPENDENCIES
  ME operating mode must be initialized.

RETURN VALUE
  None

SIDE EFFECTS
  Modifies the modem configuration data base.
  May establish the transport layer.
  Uses formatted_rsp_ptr to point to DSM items allocated.
  
===========================================================================*/
/* ARGSUSED */
LOCAL void process_at_cmd_line
(
  dsat_mode_enum_type at_state,         /* Command, online data, or online
                                           command state */
  dsat_result_enum_type result_code,    /* Initial command result code */
  byte *cmd_line_ptr                    /* Pointer to NULL terminated
                                           command line. */
)
{
  static token_q_struct_type    *token_ptr;   /* Pointer to current token    */
  dsm_item_type                 *raw_rsp_ptr; /* Raw command results         */
  boolean                        dm_go_flag;  /* Go to DM mode if true       */
#ifdef FEATURE_DSAT_MDM_FUSION
  static uint32                  command_attribute;
  boolean                        token_free     = TRUE;
#endif /* FEATURE_DSAT_MDM_FUSION */
  ds3g_siolib_port_e_type        active_port    = ds3g_siolib_get_active_port();
  ds3g_siolib_at_state_e_type    port_at_state  = DS3G_SIOLIB_NULL_AT_STATE;
  dsati_operating_cmd_mode_type  curr_operating_mode = 
                                   dsatcmdp_get_operating_cmd_mode();
  dsat_apps_id_e_type            gw_apps_id = dsat_get_current_gw_apps_id(TRUE);
  sys_modem_as_id_e_type         subs_id = dsat_get_current_subs_id(TRUE);
  dsatme_mmgsdi_state_ms_info   *me_ms_val      = NULL;
  const dsati_cmd_abort_type    *temp_abort_ptr = NULL;

  /* Free command memory pointer */
  dsat_free_cmd_mem_ptr();

  /*-------------------------------------------------------------------------
    Set the regional AT state variable mode based on the current 
    AT command processing state of the port.
  ------------------------------------------------------------------------*/
  port_at_state = ds3g_siolib_get_at_state(active_port);
  
  if( port_at_state == DS3G_SIOLIB_COMMAND_AT_STATE )
  {
    dsatcmdp_at_state = DSAT_CMD;
  }
  else if( port_at_state == DS3G_SIOLIB_ONLINE_CMD_AT_STATE )
  {
    dsatcmdp_at_state = DSAT_ONLINE_CMD;
  }
  else
  {
    DS_AT_MSG0_ERROR("Invalid ATCoP state");
    /* Clear flag to indicate indications are no longer blocked. */
    dsatcmdp_set_block_indications(active_port, FALSE);
    return;
  }

  /*-------------------------------------------------------------------------
    Results of commands are accummulated until the end of the line, 
    until a command is executed which results in an ONLINE status, or
    until an error is discovered.  The result is initially set to OK.

    'result_code' contains the results codes specified in EIA 602 (plus
    some internal codes).

    'raw_rsp_ptr' points to a temporary buffer, which is reinitialized
    on each command.  It contains the raw result codes for the current
    command.

    'formatted_rsp_ptr' points to a watermark item containing the results
    of all the commands on the current line.  It is formatted according
    to the settings of the ATE and ATV parameters.  This pointer is
    global to this module to support asynchronous command processing.
  -------------------------------------------------------------------------*/

  /*-------------------------------------------------------------------------
      Get an item to hold the responses of the commands in this line, if
      a buffer is not already allocated for formatted responses.  Note,
      the only time a buffer will not be allocated is if this function is
      called by the asynchronous event handler.
  -------------------------------------------------------------------------*/
  if ( formatted_rsp_ptr == NULL )
  {
    formatted_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);
  }

  /*-------------------------------------------------------------------------
      BEGIN MAIN LOOP: Process all command tokens for commands making up
      command line as long as result code is OK or NO_RESULT_CODE.
  -------------------------------------------------------------------------*/
#ifdef FEATURE_DSAT_MDM_FUSION
  while ( ((token_ptr != NULL) || ((token_ptr = q_get( &token_q )) != NULL))
          && (token_ptr->token.name != NULL)
          && ((result_code == DSAT_OK) || (result_code == DSAT_NO_RESULT_CODE)) )
#else
  while ( ((token_ptr = q_get( &token_q )) != NULL)
          && (token_ptr->token.name != NULL)
          && ((result_code == DSAT_OK) || (result_code == DSAT_NO_RESULT_CODE)) )
#endif /* FEATURE_DSAT_MDM_FUSION */
  {
    unsigned int             j=0, k=0, l=0;       /* Count indices */
    int                      no_match;   /* Indicates if cmd found in tables */
    dsati_at_cmd_table_entry_type *array_ptr = NULL;  /* Ptr to array of cmd tables */
    dsati_at_cmd_table_ex_entry_type *array_ptr_ex = NULL;  /* Ptr to array of cmd tables */
    const dsati_cmd_type *table_ptr;           /* Pointer to cmd table entry */
    const dsati_cmd_ex_type *table_ptr_ex ;           /* Pointer to cmd table entry */
#ifdef FEATURE_DSAT_EXT_CLIENT_SUPPORT
    boolean is_cmd_supported = TRUE;
#endif /* FEATURE_DSAT_EXT_CLIENT_SUPPORT */

#ifdef FEATURE_DATA_IS707
    /*-----------------------------------------------------------------------
    Changes relating to AT+CDV. Special processing required since its an
    extended command but format is AT+CDV dialstring, this is not handled 
    by the generic parsing routines.
    -----------------------------------------------------------------------*/ 
    unsigned int cmd_len = 4;
    const char small_cdv[5] = "+cdv";
    const char cap_cdv[5] = "+CDV";
    char tmp_name[MAX_LINE_SIZE];
    unsigned int shift_len = 0;
    /* check if first 4 chars. in tmp_name is +cdv */
    if (((strncmp((char *)token_ptr->token.name, small_cdv, cmd_len)) == 0)
        || ((strncmp((char *)token_ptr->token.name, cap_cdv, cmd_len)) == 0))
    {
      /* check if argument has been found in the token. If argument
         has not been found, do the following special processing   */
      if((token_ptr->token.op & AR ) == 0)
      {
        /* The processing of CDV command has the following combinations
           1. +CDV=<dial string> - already taken care of in the 
              process_extended_command. No special processing needed
           2. +CDV <dial string> - needs special processing. 
           3. +CDV<dial string> - needs special processing
        
           If the length of the command including delimiter and argument
           exceeds the MAX_LINE_SIZE, just shift only the characters that
           would fit in the MAX_LINE_SIZE. Ignore the rest of the string */

        shift_len = strlen((char *)(token_ptr->token.name+cmd_len+1))+1;
        if((shift_len+cmd_len) > MAX_LINE_SIZE )
          shift_len = (MAX_LINE_SIZE - cmd_len) - 1;

        (void)strlcpy(tmp_name, 
                    (char *)(token_ptr->token.name+cmd_len),
                    (int)(shift_len+1));

        *(token_ptr->token.name+cmd_len) = '\0';
        (void)strlcpy ((char *)(token_ptr->token.name+cmd_len+1),
                     tmp_name,
                     (int)(shift_len+1));
        token_ptr->token.op |=  (EQ | AR);
        token_ptr->token.args_found  = 1;
        token_ptr->token.arg[0] = token_ptr->token.name+cmd_len+1;
      }
    }  
#endif /* FEATURE_DATA_IS707 */
#ifdef FEATURE_DSAT_EXT_CLIENT_SUPPORT	
    /* This is basically to check if the command line AT commands
       are supported through external clients */
    if ( ( active_port == DS3G_SIOLIB_CLIENT_VSP_PORT ) &&
         ( ! dsatclient_is_cmd_supported ( (const char *)token_ptr->token.name )))
    {
       is_cmd_supported = FALSE;
    }
#endif /* FEATURE_DSAT_EXT_CLIENT_SUPPORT */
    /*-----------------------------------------------------------------------
      Get a buffer for response to command that is about to be processed.
    ------------------------------------------------------------------------*/
    raw_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);
    raw_rsp_ptr->data_ptr[0] = '\0';

    /*-----------------------------------------------------------------------
      Search command tables for command.
    ------------------------------------------------------------------------*/

    result_code = cmdp_validate_cmd_forwarding(token_ptr);

    /* If command is not forwarded to remote client processing fall back to 
       ATCOP internal tables only if result_code is not ERROR.
       In case where our internal tables needs to be used, 
       result_code will be DSAT_OK.
    */
    if( result_code == DSAT_OK )
    {
        /* Get a pointer to array of command table entries for current
         command category and operating mode from command table. */
#ifdef FEATURE_DSAT_EXT_CLIENT_SUPPORT
      if ( is_cmd_supported )
#endif /* FEATURE_DSAT_EXT_CLIENT_SUPPORT */
    {
#ifdef FEATURE_DSAT_MDM_FUSION
      dsati_operating_cmd_mode_type oper_mode;
#endif /* FEATURE_DSAT_MDM_FUSION */

      DSAT_ASSERT((token_ptr->token.cmd_category < NUM_AT_CMD_CATEGORIES));

      DS_AT_MSG4_HIGH("ATCoP Operating mode = %d, Present mode = %d, Qcsimapp = %d, Subs_id = %d",
        curr_operating_mode, dsatcmdp_get_current_mode(), dsat_get_qcsimapp_val(), subs_id);

      /* Initialize to no command match found in command tables. */
      no_match = 1;      
      array_ptr = at_cmd_table[token_ptr->token.cmd_category];
      array_ptr_ex = at_cmd_table_ex[token_ptr->token.cmd_category];
      /* Check if an array of command tables pointers exist for this
         command category and operating mode. */
      if ( array_ptr != NULL )
      {
        /* An array of command table entries exists for this element of
           the table. Now look for command tables within the array and
           search the command table pointed to by each array entry for
           a match to command identified within the token structure.*/
  
        /* Search each command table entry pointed to by array entry. */
        for ( j = 0, k = 0; array_ptr[j].table_ptr != NULL && no_match; j++ )
        {
          /* Search each command table entry for command match. */
          for ( k = 0; k < *(array_ptr[j].table_size) && no_match; k++ )
          {
            no_match =
              dsatutil_strcmp_ig_sp_case( token_ptr->token.name,
                                          (const byte *)array_ptr[j].table_ptr[k].name );
          }
        }
      }
    }
#ifdef FEATURE_DSAT_EXT_CLIENT_SUPPORT
    else
    {
      no_match = 1;
    }
#endif /* FEATURE_DSAT_EXT_CLIENT_SUPPORT */
    /* Check if the command was found in the tables. */
    if ( !no_match )
    {
      /* Command was found in the tables, so process command if function
         pointer not NULL, otherwise just return OK result code. */

      /* Lint complains about j, k, and array_ptr possibly not being
         initialized.  This cannot occur, since no_match can only be
         set to zero if j, k, and array_ptr are initialized. */
      table_ptr = &(array_ptr[j-1].table_ptr[k-1]);   /*lint !e613 */
      table_ptr_ex = &(array_ptr_ex[j-1].table_ptr[k-1]);

      if( table_ptr->cmd_id != table_ptr_ex->cmd_id )
      {
        DATA_ERR_FATAL("Table Entry Index Mismatch");
      }

      curr_cmd_attrib = table_ptr->attrib;

      if((table_ptr->attrib & UMTS_CMD) && (dsatcmdp_get_operating_cmd_mode() != ETSI_CMD_MODE))
      {
        DS_AT_MSG0_HIGH("Command not supported in CDMA mode.");
        result_code = DSAT_ERROR;
      }

#ifdef FEATURE_DSAT_MDM_FUSION
      /* Copy the command attribute before manipulating */
      forwarded_command_attribute = table_ptr->attrib;
      
      dsat_process_cmd_attrib(table_ptr, &command_attribute);
      
      DS_AT_MSG2_HIGH("Processing Command with attr %d - fwd attr %d",command_attribute,
                                             forwarded_command_attribute);
      if(command_attribute == CDMA_CMD)
      {
        dsat_forward_cdma_cmd(table_ptr,token_ptr,raw_rsp_ptr);
        free_token( token_ptr );
        token_ptr = NULL;
        command_attribute = ATTRIB_NONE;
        return;
      }
      /* If the command is Common Command, First execute it locally and 
       * then forward it so that all basic errors are absorbed on MDM  
      */
      if(command_attribute == COMMON_CMD)
      {
        token_free = FALSE;
        command_attribute = CDMA_CMD;
      }
#endif /* FEATURE_DSAT_MDM_FUSION */
/*Displaying Command name */
      if(NULL != token_ptr->token.name)
      {
        unsigned int i;
        DS_AT_MSG_SPRINTF_2_HIGH(
            "Command Name %s Op = 0x%x ", token_ptr->token.name,token_ptr->token.op);
        for ( i = 0; i < token_ptr->token.args_found; i++ )
        {
          DS_AT_MSG_SPRINTF_2_HIGH(
                                     "arg[%d] = %s",i,token_ptr->token.arg[i]);
        }
      }

      DS_AT_MSG2_HIGH("CPBS:: memory state:- %d, PBM pref = %d, ",
                      me_cpbs_entry.device,
                      (dsat_num_item_type)dsatutil_get_val(DSAT_VENDOR_QCPBMPREF_IDX,0,0,NUM_TYPE));
  
      me_ms_val = dsat_get_base_addr_per_session(gw_apps_id, TRUE);
      if (NULL != me_ms_val)
      {
      /* Check to see if ME in restricted command mode (ETSI only) */
      DS_AT_MSG2_HIGH("Pin State :: PIN REQURIED : %d PIN BLOCKED : %d",
                      me_ms_val->dsat_pin_required,me_ms_val->dsat_pin_blocked);

      /* Spec 27.007 sec 8.3 .MT is waiting SIM PIN2 to be given (this <code> is recommended to be returned only when 
             * the last executed command resulted in PIN2 authentication failure*/

        if((me_ms_val->dsat_mask_pin2_state == FALSE)&&
          !( 0 == dsatutil_strncmp_ig_sp_case((const byte *)token_ptr->token.name, (const byte *)"+CPIN",5 )  && token_ptr->token.op == (NA|QU)))
        {
          me_ms_val->dsat_mask_pin2_state = TRUE;
        }
      }
#if defined(FEATURE_8960_SGLTE_FUSION) || defined(FEATURE_8960_DSDA_FUSION)
        DS_AT_MSG1_HIGH("Card provising status  %d",dsat_get_provision_state());
#endif /* defined(FEATURE_8960_SGLTE_FUSION) || defined(FEATURE_8960_DSDA_FUSION) */

      if (ETSI_CMD_MODE == curr_operating_mode)
      {
        if (table_ptr->attrib & RESTRICTED)
        {
          if ((table_ptr->attrib & MULTI_SUBS) && (!IS_VALID_SUBS_ID(subs_id)))
          {
            result_code = DSAT_ERROR;
          }
        }
        else
        {
          /* Restricted attribute is not set, so throw error if the restricted mode is TRUE */
          if ((!IS_VALID_SUBS_ID(subs_id)) || (TRUE == dsatcmdp_restricted_commands[gw_apps_id]))
          {
            DS_AT_MSG0_ERROR("Command not allowed in restricted mode");
            result_code = DSAT_ERROR;
          }
#if defined(FEATURE_8960_SGLTE_FUSION) || defined(FEATURE_8960_DSDA_FUSION)
          else if ( !(table_ptr->attrib & NOT_PROVISIONED) && DSAT_MMGSDI_INACTIVE == dsat_get_provision_state() )
          {
            DS_AT_MSG0_ERROR("Command is not allowed before provisioning");
            result_code = DSAT_ERROR;
          }
#endif /* defined(FEATURE_8960_SGLTE_FUSION) || defined(FEATURE_8960_DSDA_FUSION) */
        }
      }

      if (result_code != DSAT_ERROR)
      {
           
        /* Check if command is abortable and set flag if it is. Also,
           since this is the start of command processing for a new command,
           set flag to insure command abort processing will be ended
           if send response function is called (default behavior). */
        if ( table_ptr->attrib & ABORT_CMD )
        {
          dsatcmdp_abortable_state = ABORTABLE;
          /*Search for the abort function from abort table* temp_abort_ptr*/
          for (l=0; l<dsat_abort_table_size; l++)
          {
            temp_abort_ptr = &dsat_abort_table[l];
            if (temp_abort_ptr != NULL && 
                table_ptr->cmd_id == temp_abort_ptr->cmd_id)
            {
              break;
            }
          }
          if (temp_abort_ptr == NULL)
          {
            /*Invalid Abort Flag set, no Abort function present*/
            dsatcmdp_abortable_state = NOT_ABORTABLE;
            DS_AT_MSG1_ERROR("Invalid abort state: %d", table_ptr->cmd_id);
          }
        }
        dsatcmdp_end_abort_in_send_rsp = TRUE;
      
        /* Process command if processing function pointer not NULL. */
        if ( table_ptr_ex->proc_func != NULL )
        {
          dsat_curr_cmd_var.mode = dsatcmdp_at_state;
          dsat_curr_cmd_var.parse_table = table_ptr;
          dsat_curr_cmd_var.tok_ptr = &(token_ptr->token);
          /*the token item will be used to free this token when its async command*/
          dsat_curr_cmd_var.tok_q_item = token_ptr;
          dsat_curr_cmd_var.res_buff_ptr = raw_rsp_ptr;
          result_code = table_ptr_ex->proc_func( dsatcmdp_at_state,
                                              table_ptr,
                                              &(token_ptr->token),
                                              raw_rsp_ptr );
        }

        /* Check if abortable command flag is still set after initial
           command processing has completed. */
        if ( dsatcmdp_abortable_state == ABORTABLE )
        {
          /* Abort command processing still active. */
          if ( result_code == DSAT_ERROR || 
               result_code == DSAT_CMD_ERR_RSP || 
               result_code == DSAT_OK ||
               result_code == DSAT_NO_CARRIER )
          {
            /* A command processing error occurred, so terminate the abort
               processing for command. */
            dsatcmdp_abortable_state = NOT_ABORTABLE;
          }
          else
          {
            /* Command is abortable and no error occurred so save pointer
               to command table entry and set SIO preprocessor mode to
               abort command mode. */
            abort_cmd_table_entry_ptr    = table_ptr;
            abort_cmd_table_entry_ptr_ex = temp_abort_ptr;
            dsatprep_set_preprocessor_mode(DSATI_ABORT_CMD_MODE, active_port);
          }
        }
      }
    }
    else if ( (curr_operating_mode < NUM_OPER_CMD_MODES) && 
              ( unrec_cmd_handler[curr_operating_mode] != NULL )
#ifdef FEATURE_DSAT_EXT_CLIENT_SUPPORT
              && ( is_cmd_supported ) 
#endif /* FEATURE_DSAT_EXT_CLIENT_SUPPORT */
             )
    {
        DS_AT_MSG0_HIGH("Unknown command");
      /* Unrecognized command and an unrecognized command handler is
         registered for the command mode, so call the handler. */
      result_code = unrec_cmd_handler[curr_operating_mode]( cmd_line_ptr );
    }
    else
    {
      /* Unrecognized command and no unrecognized command handler is
         registered, so return error result code. */
      result_code = DSAT_ERROR;
    }
    }
  /*-----------------------------------------------------------------------
      Finally, if 'result_code' is OK or command specific error response,
      and raw responses exist, format the response for this command.  

    ------------------------------------------------------------------------*/
    if ( raw_rsp_ptr->data_ptr[0] != '\0' &&
         (result_code == DSAT_OK || result_code == DSAT_CMD_ERR_RSP 
           || result_code == DSAT_NO_RESULT_CODE) )
    {
      /* Format the raw data response */
      if (   ( fmt_at_cmd_rsp_func_ptr != NULL )
          && ( dsatcmdp_at_state == DSAT_ONLINE_DATA) )
      {
        /*-------------------------------------------------------------------
          If mode-specific handler has registered a function to format
          responses, it should be invoked when in ONLINE DATA mode. This
          is needed for IS-707 async reflected AT cmds which need to format
          responses with 617 codes.
        -------------------------------------------------------------------*/
        fmt_at_cmd_rsp_func_ptr (
                                  &raw_rsp_ptr,
                                  DSAT_COMPLETE_RSP,
                                  FALSE,
                                  &formatted_rsp_ptr,
                                  result_code
                                );
      }
      else
      {
        dsat_fmt_response( &raw_rsp_ptr, DSAT_COMPLETE_RSP, FALSE,
                           &formatted_rsp_ptr );
      }
    }

    /* Free the response buffer */
    dsm_free_packet( &raw_rsp_ptr );

    /*-----------------------------------------------------------------------
      If this is a command that needs to be handled with asynchronous events
      or delayed result code (from DSMGR) , exit this function with the 
      formatted data item allocated so it can be used by the asynchronous 
      event handler or after we receive the delayed result code. This function
      will later be called by the asynchronous event handler or 
      dsat_finished_ath_cmd() when the command processing has been completed.  
      The remaining commands in the command line (token buffers) will then be 
      processed.
      Also, dont free this token as we will be using the
      dsat_curr_cmd_var to process the commands. The tokens will be free'd
      in the end
    ------------------------------------------------------------------------*/ 
    /*Dont free the token here. Free it in the end after processing*/ 
    if ( result_code == DSAT_ASYNC_CMD )
    {
      /* Asynchronous events are required to complete processing of
         this command so exit this function. */ 
      dsatcmdp_processing_async_cmd = TRUE;
      return;
    }
    else if ( result_code == DSAT_ATH_CMD )
    {
      /* DSMGR has to tell us when the call has dropped. 
         Need to come back to command line after that */
      dsatcmdp_processing_async_cmd = TRUE;
      dsati_processing_ath_cmd = TRUE;
      return;
    }

    /* Free command memory pointer */
    dsat_free_cmd_mem_ptr();

    /* Free the token and put it back on the queue. Dont free the token
       if the command is ASYNC and still in process. */
#ifdef FEATURE_DSAT_MDM_FUSION
    if(token_free == TRUE)
    {
      free_token( token_ptr );
      token_ptr = NULL;
      command_attribute = ATTRIB_NONE;
    }
#else
    free_token( token_ptr );
#endif /* FEATURE_DSAT_MDM_FUSION */

  } /*  end MAIN LOOP: token_ptr = q_get ... */

  curr_cmd_attrib = ATTRIB_NONE;

  /*-------------------------------------------------------------------------
    Make sure the token is freed for the case when the main loop was exited
    with result code not equal to DSAT_OK and token pointer not equal
    to NULL.
  -------------------------------------------------------------------------*/
#ifdef FEATURE_DSAT_MDM_FUSION
  if((token_free == TRUE) || (result_code != DSAT_OK ))
  {
    free_token( token_ptr );
    token_ptr = NULL;
    command_attribute = ATTRIB_NONE;
  }
#else
  free_token( token_ptr );
#endif /* FEATURE_DSAT_MDM_FUSION */

  /*-------------------------------------------------------------------------
    Insure the token queue is empty and all token buffers have been
    placed on the free queue.
  -------------------------------------------------------------------------*/
  dsatcmdp_flush_token_queue( );

  /*-------------------------------------------------------------------------
    Update SIO to reflect the latest flow control and DCD settings.  If
    these parameters were not updated, these calls are benign.
  -------------------------------------------------------------------------*/
#ifdef FEATURE_DSAT_EXT_CLIENT_SUPPORT
  if(active_port != DS3G_SIOLIB_CLIENT_VSP_PORT)
#endif /*FEATURE_DSAT_EXT_CLIENT_SUPPORT*/
  {
    set_flow_control( active_port );

    ds3g_siolib_set_client_type ( DS3G_SIOLIB_CLIENT_ATCOP );  

    (void) ds3g_siolib_set_cd_state( DS3G_SIOLIB_EVENT_NONE );

  }
  /*-------------------------------------------------------------------------
    Check for change to DM mode: if true set up to change mode after
    result (OK) is returned; else continue.
  -------------------------------------------------------------------------*/
  if ( result_code == DSAT_DO_DM )
  {
    dm_go_flag = TRUE;
    result_code = DSAT_OK;
  }
  else
  {
    dm_go_flag = FALSE;
  }

  /*-------------------------------------------------------------------------
    All commands in command line have been processed.  Format the final
    response and output it.
  -------------------------------------------------------------------------*/

  /* Generate a final result code if the result code does not indicate 
     no response or a command specific error should be sent. */
  if ( result_code != DSAT_NO_RSP && result_code != DSAT_CMD_ERR_RSP 
       && result_code != DSAT_NO_RESULT_CODE)
  {
    dsatrsp_fmt_result_code( result_code, &formatted_rsp_ptr );
  }

  if (NULL != formatted_rsp_ptr)
  {
    /* Flush the queue to the Rm interface. */
    dsatcmdp_send_queued_cmd_results( );

    /* Check the formatted response data item. If it is not empty, send it
       to the Rm interface. */
    if ( formatted_rsp_ptr->used != 0 )
    {
      dsatrsp_send_response( formatted_rsp_ptr, (boolean) !dm_go_flag );
    }
    else
    {
      dsm_free_packet( &formatted_rsp_ptr );
    }

    /* Clear flag to indicate indications are no longer blocked if result
       code does not state no response should be sent.  A result code of
       no response, indicates command processing has not completed. Also,
       flush any pending received SMS indications. */
    if ( result_code != DSAT_NO_RSP )
    {
      dsatcmdp_set_block_indications(active_port, FALSE);

#if defined(FEATURE_ETSI_SMS) || defined(FEATURE_CDMA_SMS)
      /* Flush any outstanding SMS indications */
      dsatsms_flush_sms_indications( );
#endif /* defined(FEATURE_ETSI_SMS) || defined(FEATURE_CDMA_SMS) */

#ifdef FEATURE_DSAT_ETSI_DATA
      if ((ETSI_CMD_MODE == curr_operating_mode) && IS_VALID_SUBS_ID(subs_id))
      {
        dsatetsipkt_gprs_msg_ms_info *gprs_dd_val = NULL;

        gprs_dd_val = dsat_get_base_addr_per_subs(DSAT_MS_MD_VALS, subs_id, FALSE);

        if(((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CGEREP_IDX,subs_id,0,
           NUM_TYPE) == DSAT_CGEREP_BUFFER_FWD_TE )||(gprs_dd_val->flush_gprs_buffer == TRUE))
        {
          dsatetsipkt_flush_gprs_event_indications(subs_id);
          gprs_dd_val->flush_gprs_buffer = FALSE;
        }
      }
#endif /* FEATURE_DSAT_ETSI_DATA */
      dsatcmdp_flush_urc(active_port);
    }
  
    formatted_rsp_ptr = NULL;
  }
} /* process_at_cmd_line( ) */

/*===========================================================================

FUNCTION DSATCMDP_PROCESS_CURR_CMD

DESCRIPTION
  This function processes the current command.

DEPENDENCIES
  None
  
RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_OK : if the command has been successfully executed
    DSAT_ERROR : if there was any problem in executing the command

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatcmdp_process_curr_cmd(void)
{
  dsm_item_type         *raw_rsp_ptr;
  dsat_result_enum_type  result;

  if (NULL == dsat_curr_cmd_var.proc_func)
  {
    return DSAT_ERROR;
  }

  /*-----------------------------------------------------------------------
      Get a buffer for response to command that is about to be processed.
    ------------------------------------------------------------------------*/
  raw_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);

  raw_rsp_ptr->data_ptr[0] = '\0';

  result = dsat_curr_cmd_var.proc_func( dsatcmdp_at_state,
                                        dsat_curr_cmd_var.parse_table,
                                        dsat_curr_cmd_var.tok_ptr,
                                        raw_rsp_ptr );

  /*-----------------------------------------------------------------------
      Finally, if 'result_code' is OK or command specific error response,
      and raw responses exist, format the response for this command.  

    ------------------------------------------------------------------------*/
  if ( raw_rsp_ptr->data_ptr[0] != '\0' &&
       (result == DSAT_OK || result == DSAT_CMD_ERR_RSP
         || result == DSAT_NO_RESULT_CODE) )
  {
    dsatcmdp_handle_async_cmd_rsp(raw_rsp_ptr, DSAT_COMPLETE_RSP);
  }
  else
  {
    /* Free the response buffer */
    dsm_free_packet(&raw_rsp_ptr);
  }

  return result;
} /* dsatcmdp_process_curr_cmd */

/*===========================================================================

FUNCTION DSATCMDP_QUEUE_TOKEN

DESCRIPTION
  Queues token structure generated by parser on token queue.  A token
  structure is generated by each command parsed by the AT command parser.

DEPENDENCIES
  Token queues must have been initialized.

RETURN VALUE
  DSAT_OK if token structure was successfully queued.  DSAT_ERROR
  if no buffers are available for token structure and it could not be
  placed on queue.

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatcmdp_queue_token
(
  const tokens_struct_type *token_ptr       /* Pointer to token structure */
)
{
  token_q_struct_type *buf_ptr = NULL;       /* Token buffer pointer */
  byte                *src_ptr = NULL;       /* Source data pointer */
  unsigned int         i;             /* Counter index */

  /*----------------------------------------------------------------------
    Get a token buffer from the free queue.  Call error routine if no
    buffers are available, otherwise copy input token to buffer and
    place on token queue.
  -----------------------------------------------------------------------*/
  buf_ptr = (token_q_struct_type *) dsat_alloc_memory(sizeof(token_q_struct_type), TRUE);

  if (buf_ptr != NULL && total_tokens < TOKEN_BUF_CNT)
  {
    /* Copy token data to new token item obtained from free queue. */
    buf_ptr->token.working_at_line = token_fill_ptr;
    buf_ptr->token.name = token_fill_ptr +
      (token_ptr->name - token_ptr->working_at_line);
    buf_ptr->token.op = token_ptr->op; 

    for ( i = 0; i < token_ptr->args_found; i++ )
    {
      buf_ptr->token.arg[i] = token_fill_ptr +
        (token_ptr->arg[i] - token_ptr->working_at_line);
    }
    buf_ptr->token.args_found = token_ptr->args_found;

    /* Copy token command line data to buffer. */
    src_ptr = token_ptr->working_at_line;
    while ( src_ptr <= token_ptr->end_of_line )
    {
      ASSERT( token_fill_ptr < &token_buffer[TOKEN_BUF_SIZE] );
      *token_fill_ptr++ = *src_ptr++;
    }

    buf_ptr->token.end_of_line = token_fill_ptr - 1;
    buf_ptr->token.cmd_category = token_ptr->cmd_category;

    /* Queue the token. */
    q_put( &token_q, &buf_ptr->link );
    total_tokens++;

    return( DSAT_OK );
  }
  else 
  {
    /* Command line is too long */
    DS_AT_MSG0_ERROR("Data task AT token free buffer empty.");
    dsatutil_free_memory_ext((void **)&buf_ptr);
    return( DSAT_ERROR );
  }

} /* dsatcmdp_queue_token( ) */


/*===========================================================================

FUNCTION FREE_TOKEN

DESCRIPTION
  Frees token item placing it back on token free queue.  If token item
  pointer is NULL, function just returns without performing any operation.

DEPENDENCIES
  Token queues must have been initialized.  Assumes a complete command
  line of tokens are first placed on queue and then all are removed
  before any new token items are added.

RETURN VALUE
  None

SIDE EFFECTS
  Updates pointers to token storage buffer.

===========================================================================*/
LOCAL void free_token
(
  token_q_struct_type *token_item_ptr    /* Pointer to token queue item */
)
{
  /* Check for NULL pointer and just return if NULL. */
  if ( token_item_ptr == NULL )
  {
    return;
  }

  /* Update token buffer pointers. */
  token_empty_ptr = token_item_ptr->token.end_of_line + 1;
  ASSERT( token_empty_ptr >= token_buffer &&
          token_empty_ptr < &token_buffer[TOKEN_BUF_SIZE] );
  if ( token_empty_ptr == token_fill_ptr )
  {
    /* All token items have been removed from queue, so update pointers
       to point to beginning of buffer. */

    token_empty_ptr = token_fill_ptr = token_buffer;
    /*memset the token_buffer here as all commands have been processed now*/
    memset(token_buffer, 0 , TOKEN_BUF_SIZE);
  }

  /* Remove the link for the token from the queue and free the token. */
  q_delete( &token_q, &token_item_ptr->link );
  dsatutil_free_memory_ext((void **) &token_item_ptr);
  if (  total_tokens > 0) 
  {
    total_tokens--;
  }
} /* free_token( ) */


/*===========================================================================

FUNCTION DSATCMDP_FLUSH_TOKEN_QUEUE

DESCRIPTION
  Flushes token queue.  Any token structures in queue are removed and
  placed back on the token free queue.

DEPENDENCIES
  Token queues must be initialized.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_flush_token_queue( void )
{
  token_q_struct_type *token_ptr;

  /* Flush the token queue and return token buffers to free queue */
  while ( (token_ptr = (token_q_struct_type *) q_get( &token_q )) != NULL )
  {
    free_token( token_ptr );
  }

} /* dsatcmdp_flush_token_queue( ) */


/*===========================================================================

FUNCTION DSATCMDPI_QUEUE_CMD_RESULTS

DESCRIPTION
  This function places the results of AT commands in a queue,
  so they can be output (or discarded) at the end of the command
  line. It will output the contents of the queue if more than a
  defined number of DSM items are on the queue.  This is done
  to control DSM usage, as some responses can be large.

  Note: The queue count threshold may require adjustment for IS-707
  mode of operation, to insure the entire command line response
  can be buffered.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdpi_queue_cmd_results
(
  dsm_item_type *item_ptr       /* Pointer to command results to queue */
)
{
  if ( item_ptr != NULL )
  {
    if ( item_ptr->used > 0 )
    {
      /* This code controls the maximum number of DSM items needed by
         ATCOP. It only allows a certain number of DSM items to be
         queued up for a response and flushes the queue to the TE if
         this count is exceeded. In ETSI mode we don't have to queue 
         them.  We can flush them as and when we are ready to send. */
      if ( q_cnt( &cmd_results_hold_queue ) >= max_queued_dsm_items )
      {
        /* Flush the queue to the TE since the maximum queued DSM item
           count has been reached. */
        dsatcmdp_send_queued_cmd_results( );
      }

      /*  Place the DSM item on the queue. */
      q_put( &cmd_results_hold_queue, &(item_ptr->link) );
    }
    else
    {
      (void) dsm_free_buffer( item_ptr );
    }    
  }
} /* dsatcmdpi_queue_cmd_results( ) */


/*===========================================================================

FUNCTION DSATCMDP_SEND_QUEUED_CMD_RESULTS

DESCRIPTION
  This functions flushes the results queue to the serial port or PS
  protocol stack based on the registered response routing function.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_send_queued_cmd_results( void )
{
  dsm_item_type *dq_item_ptr;

  while ( (dq_item_ptr = (dsm_item_type *)q_get(&cmd_results_hold_queue))
          != NULL )
  {
    ASSERT( dq_item_ptr->used > 0 );   

    dsatrsp_send_response( dq_item_ptr, FALSE );
  }
  
} /* dsatcmdp_send_queued_cmd_results( ) */


/*===========================================================================

FUNCTION DSATCMDP_DISCARD_QUEUED_CMD_RESULTS

DESCRIPTION
  This functions discards any queued up AT command results.  Required
  for IS-707 unrecognized command processing.

DEPENDENCIES
  AT command processor must have been initialized prior to calling
  this function.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_discard_queued_cmd_results( void )
{
  dsm_item_type *dq_item_ptr;

  while ( (dq_item_ptr = (dsm_item_type *)q_get(&cmd_results_hold_queue))
          != NULL )
  {
    (void) dsm_free_buffer( dq_item_ptr );
  }

} /* dsatcmdp_discard_queued_cmd_results( ) */


/*===========================================================================

FUNCTION DSATCMDP_HANDLE_ASYNC_CMD_RSP

DESCRIPTION
  Handles the raw unformatted AT command response generated by an
  asynchronous command handler function.  Formats the raw response
  contained in possibly chained DSM items and queues it up for
  transmission or sends it immediately.  The DSM item pointed to by
  the raw response buffer is freed.

  The response is formatted based on the input parameter "type of
  response".  This specifies whether the response contained in the
  DSM item is the start, end, complete, or intermediate response and
  in turn if a header, trailer, header and trailer, or no header and
  trailer should be added to the response, respectively.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  Uses DSM item pointed to by formatted_rsp_ptr.

===========================================================================*/
void dsatcmdp_handle_async_cmd_rsp
(
  dsm_item_type *raw_rsp_ptr,   /* Ptr to raw unformatted AT cmd response */
  dsat_rsp_enum_type type_of_rsp   /* Type of response data in DSM item   */
)
{

  ASSERT( raw_rsp_ptr != NULL );

  /* Verify the formatted response pointer is not NULL.  A DSM item
     should always be allocated when this function is called, since an
     asynchronous command is being processed when this function is
     called. */
  if ( formatted_rsp_ptr == NULL )
  {
    DS_AT_MSG0_ERROR("Async cmd handling error - formatted rsp item not allocated!");
    
    formatted_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);
  }
  
  /* Format the raw data response */
  dsat_fmt_response( &raw_rsp_ptr, type_of_rsp, FALSE, &formatted_rsp_ptr );

} /* dsatcmdp_handle_async_cmd_rsp( ) */

/*===========================================================================

FUNCTION DSATCMDP_ADD_URC_TO_QUEUE

DESCRIPTION
  Adds the passed DSM item onto the URC queue.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_add_urc_to_queue
(
  ds3g_siolib_port_e_type  port_id,
  dsm_item_type           *dsm_item_ptr
)
{
  dsat_sio_info_s_type *sio_info_ptr;
  dsat_urc_msg_type    *msg_ptr;

  sio_info_ptr = dsatcmdp_get_sio_info_ptr(port_id);

  if( q_cnt(&sio_info_ptr->urc_msg_q) < DSAT_MAX_QUEUED_URC )
  {
    msg_ptr = (dsat_urc_msg_type *)dsat_alloc_memory(sizeof(dsat_urc_msg_type), TRUE);
  }
  else
  {
    msg_ptr = (dsat_urc_msg_type*)q_get(&sio_info_ptr->urc_msg_q);
    if(msg_ptr != NULL)
    {
      DS_AT_MSG0_HIGH("Overwriting the first queued element due to queue limit");
      dsm_free_packet(&msg_ptr->dsm_item_ptr);
    }
  }

  if(msg_ptr == NULL)
  {
    DS_AT_MSG0_ERROR("Invalid Queue element");
    dsm_free_packet(&dsm_item_ptr);
    return;
  }

  msg_ptr->dsm_item_ptr = dsm_item_ptr;
  q_put( &sio_info_ptr->urc_msg_q, &msg_ptr->link );

  DS_AT_MSG2_HIGH("URC: queued - Q count: %d, DSM item ptr: %p",
                  q_cnt(&sio_info_ptr->urc_msg_q), dsm_item_ptr);

  return;
}/* dsatcmdp_add_urc_to_queue */

/*===========================================================================
FUNCTION  DSATCMDP_FLUSH_URC

DESCRIPTION
  Flushes the buffered Unsolicited result codes

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_flush_urc
(
  ds3g_siolib_port_e_type port_id
)
{
  dsat_sio_info_s_type *sio_info_ptr;
  dsat_urc_msg_type    *msg_ptr;

  sio_info_ptr = dsatcmdp_get_sio_info_ptr(port_id);

  /* Get messages from the queue until the queue is empty */
  while( (msg_ptr = (dsat_urc_msg_type*)
                    q_get( &sio_info_ptr->urc_msg_q )) != NULL )
  {
    /* Set the Tx port and Type. */
    ds3g_siolib_set_tx_type(DS3G_SIOLIB_UNSOLICTED_CM, port_id);

    dsatrsp_send_response(msg_ptr->dsm_item_ptr, TRUE);

    DS_AT_MSG2_HIGH("URC: flushed - Q count: %d, DSM item ptr: %p",
                    q_cnt(&sio_info_ptr->urc_msg_q), msg_ptr->dsm_item_ptr);

    dsatutil_free_memory_ext((void **) &msg_ptr);
  }
}/* dsatcmdp_flush_urc */
/*===========================================================================

FUNCTION DSATCMDP_PROCESS_ASYNC_CMD

DESCRIPTION
  Asynchronous ATCOP command handler.  Processes asynchronous ATCOP commands
  received by data services task dispatcher.  Function looks up commands in
  mode specific command table.  Command processing function corresponding to
  current command and operating mode is called from table. 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_process_async_cmd
(
  ds_cmd_type           *cmd_ptr,    /* Pointer to command */
  dsat_result_enum_type  result_code
)
{
  /* This check is to filter the race condition between abort handler 
     and async cmd processing. The first result will send the response to 
     the terminal and clears dsatcmdp_processing_cmd and 
     ds3g_siolib_active_port . This will complete the processing of 
     AT command and the second response is filtered here.
  */
  if ( (!dsatcmdp_processing_async_cmd ) && 
       ( result_code != DSAT_ASYNC_CMD && result_code != DSAT_ASYNC_EVENT ) )
  {
    if ( formatted_rsp_ptr != NULL )
    {
      dsm_free_packet( &formatted_rsp_ptr );
    }
    DS_AT_MSG1_HIGH("Unexpected ATCoP asynchronous event %d received!",
              cmd_ptr->hdr.cmd_id);
    result_code = DSAT_ASYNC_EVENT;
  }
  /* Complete processing of AT command line if this is the last
     asynchronous event associated with the current AT command (processing
     of command is complete) and this is not an asynchronous event that is
     not associated with a command. */
  if ( result_code != DSAT_ASYNC_CMD && result_code != DSAT_ASYNC_EVENT )
  {
    /* No more asynchronous events for this command, so first insure
       processing associated with an abortable asynchronous command is
       no longer active and then continue processing the remaining
       commands in command line.
       If the result code is DSAT_NO_RSP, the abortable state is still on.
       The abortability of the command ends when the subsystem call
       dsat_send_result_code to finally end the comand.
    */
    if (result_code != DSAT_NO_RSP)
    {
      dsatcmdp_command_abort_complete( );
    }
    dsatcmdp_processing_async_cmd = FALSE;
    /* When a command is in processing there is a possibility of
       QCSIMAPP value to be updated. */

    /*Free the async cmd token*/
    free_token(dsat_curr_cmd_var.tok_q_item);
    dsat_curr_cmd_var.tok_q_item = NULL;

    dsat_update_qcsimapp_val();
    process_at_cmd_line( dsatcmdp_at_state, result_code, at_cmd_line_ptr );
  }
} /* dsatcmdp_process_async_cmd( ) */

/*===========================================================================

FUNCTION DSATCMDP_PROCESS_ASYNC_SIGNAL

DESCRIPTION
  Asynchronous ATCOP REX signal handler.  Processes asynchronous ATCOP
  signals received by data services task dispatcher.  Function looks up
  signals in mode specific signal table.  Signal processing function
  corresponding to current signal and operating mode is called from table. 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_process_async_signal
(
  dsat_result_enum_type result_code
)
{
  /* This check is to filter the race condition between abort handler 
     and async cmd processing. The first result will send the response to 
     the terminal and clears the dsatcmdp_processing_cmd and 
     ds3g_siolib_active_port. This completes the AT command processing and 
     the second response is filtered here.
  */
  if ( (!dsatcmdp_processing_async_cmd ) && 
       ( result_code != DSAT_ASYNC_CMD && result_code != DSAT_ASYNC_EVENT ) )
  {
    if( formatted_rsp_ptr != NULL )
    {
      (void) dsm_free_buffer( formatted_rsp_ptr );
      formatted_rsp_ptr = NULL;
    }
    DS_AT_MSG0_HIGH("Unexpected ATCoP asynchronous signal received!");
    result_code = DSAT_ASYNC_EVENT;
  }
  /* Complete processing of AT command line if this is the last
     asynchronous event associated with the current AT command (processing
     of command is complete) and this is not an asynchronous event that is
     not associated with a command. */
  if ( result_code != DSAT_ASYNC_CMD && result_code != DSAT_ASYNC_EVENT )
  {
    /* No more asynchronous events for this command, so first insure
       processing associated with an abortable asynchronous command is
       no longer active and then continue processing the remaining
       commands in command line.
       If the result code is DSAT_NO_RSP, the abortable state is still on.
       The abortability of the command ends when the subsystem call
       dsat_send_result_code to finally end the comand.
    */
    if ( result_code != DSAT_NO_RSP )
    {
      dsatcmdp_command_abort_complete( );
    }

    dsatcmdp_processing_async_cmd = FALSE;
    /* When a command is in processing there is a possibility of
       QCSIMAPP value to be updated. */
    /*Free the async signal token*/
    free_token(dsat_curr_cmd_var.tok_q_item);
    dsat_curr_cmd_var.tok_q_item = NULL;

    dsat_update_qcsimapp_val();
    process_at_cmd_line( dsatcmdp_at_state, result_code, at_cmd_line_ptr );
  }

} /* dsatcmdp_process_async_signal( ) */

/*===========================================================================

FUNCTION DSATCMDP_ABORT_COMMAND

DESCRIPTION
  Calls abort command handler located in command table to abort the
  abortable AT command currently being processed.  This function
  may be called multiple times during the command abort process,
  although only the first call to this function during a particular
  command's abort sequence will invoke the command abort handler.

DEPENDENCIES
  None

RETURN VALUE
  Value indicating whether or not call should be aborted:
      TRUE if call should be aborted, FALSE otherwise.

SIDE EFFECTS
  May set abortable command table entry pointer to NULL.

===========================================================================*/
boolean dsatcmdp_abort_command( void )
{
  boolean abort_call;
  
  /* Call the abort function to abort the command currently in
     progress, if the abort command handler has not already been
     called once to abort the current command. */
  if ( ( abort_cmd_table_entry_ptr != NULL ) &&
       ( abort_cmd_table_entry_ptr_ex != NULL ) )
  {
    /* Verify abort handler pointer is valid.  Pointer should never be
       NULL when this function is called to abort a command. */
    ASSERT( abort_cmd_table_entry_ptr_ex->abort_func != NULL );

    /* Call the abort command handler and then set pointer to NULL to
       indicate the handler has been called. */
    abort_call =
      abort_cmd_table_entry_ptr_ex->abort_func( abort_cmd_table_entry_ptr );
    abort_cmd_table_entry_ptr = NULL;
    abort_cmd_table_entry_ptr_ex = NULL;
  }
  else if (curr_ext_at_abort_fwd_ptr != NULL) 
  {
    /* Verify abort handler pointer is valid.  Pointer should never be
       NULL when this function is called to abort a command. */
    ASSERT( curr_ext_at_abort_fwd_ptr->ext_at_abort_cb != NULL );

    abort_call = FALSE;

    if(dsatcmdp_abortable_state != NOT_ABORTABLE)
    {
      /* Clear the pending flag,client and port */
      /* Note: In future when resp_type is taken into 
         consideration this needs to be re-worked. 
      */
      dsatcmdp_processing_fwd_cmd.is_pending = FALSE;
      dsatcmdp_processing_fwd_cmd.port = DS3G_SIOLIB_DATA_PORT;
      dsatcmdp_processing_fwd_cmd.client_id = 0;
      memset(dsatcmdp_processing_fwd_cmd.cmd_name, 0x0, MAX_CMD_SIZE);

      curr_ext_at_abort_fwd_ptr->ext_at_abort_cb(
              curr_ext_at_abort_fwd_ptr->user_info_ptr,
              (int32)DS3G_SIOLIB_DATA_PORT);

      dsatcmdp_command_abort_complete( );
      dsatcmdp_processing_async_cmd = FALSE;
      /*Free the current token if the command is aborted*/
      free_token(dsat_curr_cmd_var.tok_q_item);
      dsat_curr_cmd_var.tok_q_item = NULL;

      process_at_cmd_line( dsatcmdp_at_state, DSAT_OK, at_cmd_line_ptr );
      abort_call = TRUE;
    }
    /* clear the current abort call back function */
    curr_ext_at_abort_fwd_ptr = NULL;
  }
  else
  {
    /* Always return FALSE to indicate call should not be aborted when
       this is not the first call to this function during a command
       abort. */
    abort_call = FALSE;
  }
  DS_AT_MSG1_HIGH(" Abort call status: %d" , abort_call);

  return abort_call;

} /* dsatcmdp_abort_command( ) */


/*===========================================================================

FUNCTION DSATCMDP_COMMAND_ABORT_COMPLETE

DESCRIPTION
  Clears flag used during abort command processing and places SIO
  preprocessor in AT command mode.  Must be called when command abort
  processing has been completed, even if the command was not sucessfully
  aborted.  

DEPENDENCIES
  Should only be called when the process of aborting a command has
  completed, and must be called even if command was not aborted
  successfully.

RETURN VALUE
  None

SIDE EFFECTS
  Clears abort command flag and sets SIO preprocessor to AT command
  mode.

===========================================================================*/
void dsatcmdp_command_abort_complete( void )
{

  ds3g_siolib_port_e_type port = ds3g_siolib_get_active_port();
  dsatcmdp_command_abort_complete_with_port(port);
  
} /* dsatcmdp_command_abort_complete( ) */

/*===========================================================================

FUNCTION DSATCMDP_COMMAND_ABORT_COMPLETE_WITH_PORT

DESCRIPTION
  Clears flag used during abort command processing and places SIO
  preprocessor in AT command mode.  Must be called when command abort
  processing has been completed, even if the command was not sucessfully
  aborted and when PORT is known.  

DEPENDENCIES
  Should only be called when the process of aborting a command has
  completed, and must be called even if command was not aborted
  successfully.

RETURN VALUE
  None

SIDE EFFECTS
  Clears abort command flag and sets SIO preprocessor to AT command
  mode.

===========================================================================*/
void dsatcmdp_command_abort_complete_with_port
(
  ds3g_siolib_port_e_type port
)
{

  /* Check whther the port is a valid Modem port */
  if(( port >= DS3G_SIOLIB_PORT_MAX ) ||( port <= DS3G_SIOLIB_DATA_PORT ))
  {
    DS_AT_MSG1_ERROR("Invalid SIO port: %d",(int)port);
    return;
  }
  /* Clear flag and set SIO preprocessor mode to AT command mode if
     command abort processing is in progress. */
  if ( dsatcmdp_abortable_state != NOT_ABORTABLE )
  {
    dsatcmdp_abortable_state = NOT_ABORTABLE;
    dsatprep_set_preprocessor_mode( DSATI_AT_CMD_MODE, port );

    /* Clear abort handlers */
    dsat_curr_abort_handler = NULL;
#ifdef FEATURE_DSAT_MDM_FUSION
    dsat_proxy_curr_abort_handler = NULL;
#endif /* FEATURE_DSAT_MDM_FUSION */
    curr_ext_at_abort_fwd_ptr = NULL;
  }
  
} /* dsatcmdp_command_abort_complete_with_port */

/*===========================================================================

FUNCTION DSATCMDP_DISABLE_CMD_ABORT_COMPLETE

DESCRIPTION
  Disables termination of abort command handling of current command
  being processed when call to function to send result code is made.
  By default, calls to function to send result code will end the abort
  handling of an abortable command in progress.

  Should be called by ATCoP command execution function requiring this
  behavior for abortable commands.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  Clears end abort in send response flag.

===========================================================================*/
void dsatcmdp_disable_cmd_abort_complete( void )
{
  /* Clear flag so call to send result code does not end the abort
     command handling for the command currently being processed. */
  dsatcmdp_end_abort_in_send_rsp = FALSE;
  
} /* dsatcmdp_disable_cmd_abort_complete( ) */

/*===========================================================================

FUNCTION DSATCMDP_ETSI_NV_SYNC

DESCRIPTION
  This function will read all ETSI related NV items for commands processing.

DEPENDENCIES
  

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

LOCAL void dsatcmdp_etsi_nv_sync( void )
{
  sys_modem_as_id_e_type subs_id;
#ifdef FEATURE_DSAT_ETSI_MODE
      /*-------------------------------------------------------------------------
        Initialize ETSI call paramaters
      -------------------------------------------------------------------------*/
   dsatetsicall_init_call_param_from_nv( );

#endif /* FEATURE_DSAT_ETSI_MODE */
 /* Below NV items which might be skipped in case AT commands are not used in production environment.*/
  /*-------------------------------------------------------------------------
    Initialize the Packet Dial String lookup table from the NV.
  -------------------------------------------------------------------------*/
   for (subs_id = SYS_MODEM_AS_ID_1; subs_id < DSAT_SYS_MODEM_AS_ID_MAX; subs_id++)
   {
     dsatutil_init_pkt_dial_string_from_nv(subs_id);
   }
}/*dsatcmdp_etsi_nv_sync*/

/*===========================================================================

FUNCTION CONVERT_FLOW_CONTROL

DESCRIPTION
  This function will convert flow control values dictated by AT command
  standard to SIO flow control values.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL sio_flow_ctl_type convert_flow_control
( 
  flow_ctl_type    flow_ctl,              /* Flow control method          */
  boolean          fail_safe              /* Fail safe                    */
)
{
  sio_flow_ctl_type return_val = SIO_CTSRFR_FCTL;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch ( flow_ctl )
  {
  case DS_FCTL_OFF:
    return_val = SIO_FCTL_OFF;
    break;       

  case DS_XONXOFF_STRIP_FCTL:
    if ( fail_safe )
    {
      return_val = SIO_XONXOFF_STRIP_FCTL_FS; 
    }
    else
    {
      return_val = SIO_XONXOFF_STRIP_FCTL_NFS;
    }
    break;               

  case DS_CTSRFR_FCTL:
    return_val = SIO_CTSRFR_FCTL; 
    break;                      

  case DS_XONXOFF_NSTRIP_FCTL:
    if ( fail_safe )
    {
      return_val = SIO_XONXOFF_NSTRIP_FCTL_FS; 
    }
    else
    {
      return_val = SIO_XONXOFF_NSTRIP_FCTL_NFS;
    }
    break;             

  case DS_MAX_FLOW:
    /* Invalid flow control so fall through. */

  default:
    ERR_FATAL( "Invalid Flow control value",0,0,0);
    break;
  }

  return return_val;

} /* convert_flow_control */


/*===========================================================================

FUNCTION SET_FLOW_CONTROL

DESCRIPTION
  Sets the flow control in the serial interface.

  If dsat_fclass_val is 2, which means +FCLASS = 2.0, the both
  directions are set from dsat_flo_val (AT+FLO).

  Otherwise, the flow control for each direction is set individually
  from dsat_ifc_val[] (AT+IFC).

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL void set_flow_control
( 
  ds3g_siolib_port_e_type  port_id              /* SIOLIB port id */
)
{
  sio_flow_ctl_type tx_flow_ctl;
  sio_flow_ctl_type rx_flow_ctl;
  dsat_num_item_type  temp_val;
  if ( (dsat_num_item_type)dsatutil_get_val(
                               DSAT_EXT_FCLASS_IDX,0,0,NUM_TYPE) == 2 )
  {
    temp_val = (dsat_num_item_type)dsatutil_get_val(DSAT707_FAX_FLO_IDX,0,0,NUM_TYPE);
    tx_flow_ctl = convert_flow_control( (flow_ctl_type) temp_val, TRUE );
    temp_val = (dsat_num_item_type)dsatutil_get_val(DSAT707_FAX_FLO_IDX,0,0,NUM_TYPE);
    rx_flow_ctl = convert_flow_control( (flow_ctl_type) temp_val, TRUE );
  }   
  else
  {
    temp_val = (dsat_num_item_type)dsatutil_get_val(DSAT_EXT_IFC_IDX,0,0,NUM_TYPE);
    tx_flow_ctl = convert_flow_control( (flow_ctl_type) temp_val,TRUE );
    temp_val = (dsat_num_item_type)dsatutil_get_val(DSAT_EXT_IFC_IDX,0,1,NUM_TYPE);
    rx_flow_ctl = convert_flow_control( (flow_ctl_type)temp_val ,TRUE );
  }

  (void) ds3g_siolib_set_flow_ctl_method( port_id, tx_flow_ctl, rx_flow_ctl );

} /* set_flow_control( ) */

/*===========================================================================

FUNCTION DSAT_CHANGE_BAUD

DESCRIPTION
  This function is called by other modules to write the value to the current 
  baud rate variable, dsat_ipr_val. Whenever the baud rate is changed
  it should also be entered into the NV.

  The second parameter in this function is a boolean type. It informs 
  the function if the Baud rate should be changed NOW or later (later
  implies, after sending acknowledgement). This is needed because, when 
  UI changes the baud rate, the baud rate should take effect immediately. 
  But when an AT command changes the baud rate, the baud rate should be 
  changed after an "OK" is sent to the TE2. 

DEPENDENCIES
  This code does not check for auto baud enabled or not. So, it is the 
  responsibility of the calling function to ascertain that if 
  FEATURE_AUTOBAUD is not enabled then value 0 should not be passed.

  This code is called from sdevmap.c, which means it can execute in
  non-DS task context.

RETURN VALUE
  None

SIDE EFFECTS
  Modifies the current values of IPR and QCTER and the corresponding
  value ds_default_baud in the NV.    

===========================================================================*/
void dsat_change_baud
(
    sio_bitrate_type new_baud_rate,     /* Requested baud rate   */
    boolean change_baud_now             /* Immediate or post ack */
)
{
  dsat_num_item_type temp_val;

  /*--------------------------------------------------------------------------
  Check if the Baud rate is with in the maximum permissible value. If yes 
  update the variable and write to NV. Else return without modifying.

  If Autobaud not allowed, UI gives an "ERROR" to the user. 
  --------------------------------------------------------------------------*/
  if (new_baud_rate >= SIO_BITRATE_BEST ) 
  {
    DS_AT_MSG0_HIGH("Unknown Baud rate requested");
    return;
  }

  /*-------------------------------------------------------------------------
  Copy the new_baud_rate into the ipr and qcter variables.
  -------------------------------------------------------------------------*/
  DSATUTIL_SET_VAL(DSAT_EXT_IPR_IDX,0,0,0,new_baud_rate,NUM_TYPE)
  DSATUTIL_SET_VAL(DSAT_VENDOR_QCTER_IDX,0,0,0,new_baud_rate,NUM_TYPE)

  /*-----------------------------------------------------------------------
  Check if the baud rate should be changed NOW or later and change the
  baud rate accordingly, by informing the SIO. 
  -----------------------------------------------------------------------*/
  temp_val = (dsat_num_item_type)dsatutil_get_val(DSAT_EXT_IPR_IDX,0,0,NUM_TYPE);
  (void) ds3g_siolib_change_baud_rate((sio_bitrate_type) temp_val,change_baud_now );

  /*-------------------------------------------------------------------------
  Write the new value of the baud_rate to the NV. 
  -------------------------------------------------------------------------*/
  temp_val = (dsat_num_item_type) dsatutil_get_val(DSAT_EXT_IPR_IDX,0,0,NUM_TYPE);
  ds_nv_item.ds_default_baudrate = (nv_sio_baudrate_type) temp_val;

  /*-------------------------------------------------------------------------
    Write the new value of the baud_rate to the NV.
  -------------------------------------------------------------------------*/
  temp_val = (dsat_num_item_type)dsatutil_get_val(DSAT_EXT_IPR_IDX,0,0,NUM_TYPE);
  ds_nv_item.ds_default_baudrate = (nv_sio_baudrate_type) temp_val;
  /*-------------------------------------------------------------------------
    Prepare command buffer to write the item to NV.
        tcb_ptr:    We donot have to inform current task when the write is
                    complete. Note that after the information is written NV,
                    NV task need not inform us. This is done because, baud
                    rate is not very critical and so we donot want to confirm
                    if it is writtena also, we donot want to block current
                    task.
        sigs:       Make it NULL. We donot want any signal to be set because
                    we donot want to block on this action.
        done_q_ptr: Command does not have to go to any queue when done.
        item:       The item to be written is NV_DS_DEFAULT_BAUDRATE_I.
        cmd:        Inform NV to write the item.
        data_ptr:   Give the address of the data to be written as ds_nv_item.
                    Note that this uses the DS space and has a potential to
                    clash between the DS data and UI data. But this is okay
                    because Baud rate given by either UI or AT command will
                    be stored here @ NV_DS_DEFAULT_BAUDRATE_I location.
                    In a racing condition, we leave it for latest entry to
                    be used, which will be done.

        Give the command to the NV task to write the data in the NV.
  -------------------------------------------------------------------------*/
  ds_nv_baud_cmd_buf.tcb_ptr = NULL;
  ds_nv_baud_cmd_buf.sigs = 0;
  ds_nv_baud_cmd_buf.done_q_ptr = NULL;

  ds_nv_baud_cmd_buf.item = NV_DS_DEFAULT_BAUDRATE_I;
  ds_nv_baud_cmd_buf.cmd = NV_WRITE_F;

  ds_nv_baud_cmd_buf.data_ptr =  &ds_nv_item;

  /*-------------------------------------------------------------------------
   Issue the command to NV. Note that we donot wait for the response.
  -------------------------------------------------------------------------*/
  nv_cmd( &ds_nv_baud_cmd_buf );
} /* dsat_change_baud() */


/*===========================================================================

FUNCTION DSAT_GET_BAUD

DESCRIPTION
  This function is called by other modules to get the current AT+IPR
  baud rate value 

DEPENDENCIES
  This code does not check for auto baud enabled or not. So, it is the 
  responsibility of the calling function to ascertain that if 
  FEATURE_AUTOBAUD is not enabled then value 0 should not be passed.

RETURN VALUE
  Baud rate

SIDE EFFECTS
  None    
===========================================================================*/
dsat_num_item_type dsat_get_baud
( 
  void 
)
{
  return (dsat_num_item_type)dsatutil_get_val(
                             DSAT_EXT_IPR_IDX,0,0,NUM_TYPE);
}

/*===========================================================================

FUNCTION DSATCMDP_IS_ETSI_CMD

DESCRIPTION
  Returns TRUE if the current command in execution is ETSI otherwise FALSE.

DEPENDENCIES
  None

RETURN VALUE

SIDE EFFECTS
  None

===========================================================================*/
boolean dsatcmdp_is_etsi_cmd( void )
{
  if (curr_cmd_attrib & (CDMA_CMD | DO_PREF_CMD | COMMON_CMD))
  {
    return FALSE;
  }
  else
  {
    return TRUE;
  }
} /* dsatcmdp_is_etsi_cmd( ) */

/*===========================================================================

FUNCTION DSATCMDP_IS_CDMA_CMD

DESCRIPTION
  Returns TRUE if the current command in execution is CDMA otherwise FALSE.

DEPENDENCIES
  None

RETURN VALUE

SIDE EFFECTS
  None

===========================================================================*/
boolean dsatcmdp_is_cdma_cmd( void )
{
  if (curr_cmd_attrib & (CDMA_CMD | DO_PREF_CMD))
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
} /* dsatcmdp_is_cdma_cmd( ) */

#ifdef FEATURE_DATA_IS707
/*===========================================================================

FUNCTION DSATCMDP_NOT_SUPPORTED_IN_JCDMA

DESCRIPTION
  This function checks the current mode for the commands that are not supported
  in JCDMA.

DEPENDENCIES
  None

RETURN VALUE
  Boolean

SIDE EFFECTS
  None

===========================================================================*/
boolean dsatcmdp_not_supported_in_jcmda( void )
{
  if (IS_JCDMA_MODE())
  {
    DS_AT_MSG0_HIGH("This command is not supported in JCDMA mode");
    return TRUE;
  }

  return FALSE;
} /* dsatcmdp_not_supported_in_jcmda( ) */

#endif /*FEATURE_DATA_IS707*/

/*===========================================================================

FUNCTION DSATCMDP_BLOCK_INDICATIONS

DESCRIPTION
  Returns value to indicate whether or not indications sent to the TE
  should be blocked.  No indications should be sent to TE from the
  time entering an AT command line begins to the time command line
  processing completes.  Command line processing is considered completed
  after the final result code or response is sent to the TE.  Also,
  indications should not be sent to the TE while in a data call.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if sending of indications to TE should be blocked or FALSE
  otherwise.

SIDE EFFECTS
  None

===========================================================================*/
boolean dsatcmdp_block_indications( void )
{
  ds3g_siolib_port_e_type port_id;

  for (port_id = DS3G_SIOLIB_DATA_PORT; port_id < DS3G_SIOLIB_PORT_MAX; port_id++)
  {
    if (TRUE == dsatcmdp_get_block_indications(port_id))
    {
      return TRUE;
    }
  }

  return FALSE;
} /* dsatcmdp_block_indications( ) */

/*===========================================================================

FUNCTION DSATCMDP_GET_BLOCK_INDICATIONS

DESCRIPTION
  This function is used to get block indications flag on a serial port.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
boolean dsatcmdp_get_block_indications
(
  ds3g_siolib_port_e_type port_id
)
{
  dsat_sio_info_s_type *sio_info_ptr;

  if (TRUE == dsatcmdp_is_sio_info_inited(port_id))
  {
    sio_info_ptr = dsatcmdp_get_sio_info_ptr(port_id);
    return sio_info_ptr->block_indications_flag;
  }

  return FALSE;
} /* dsatcmdp_get_block_indications( ) */

/*===========================================================================

FUNCTION DSATCMDP_SET_BLOCK_INDICATIONS

DESCRIPTION
  This function is used to set block indications flag on a serial port.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_set_block_indications
(
  ds3g_siolib_port_e_type port_id,
  boolean                 flag_val
)
{
  dsat_sio_info_s_type *sio_info_ptr;

  DS_AT_MSG2_MED("Set block indications flag to %d on port %d",
                 flag_val, port_id);

  sio_info_ptr = dsatcmdp_get_sio_info_ptr(port_id);
  sio_info_ptr->block_indications_flag = flag_val;

  return;
} /* dsatcmdp_set_block_indications( ) */

/*===========================================================================

FUNCTION DSATCMDP_SET_BLOCK_INDICATIONS_ALL_PORTS

DESCRIPTION
  This function is used to set block indications flag on all serial ports.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_set_block_indications_all_ports
(
  boolean flag_val
)
{
  ds3g_siolib_port_e_type port_id;

  for (port_id = DS3G_SIOLIB_DATA_PORT; port_id < DS3G_SIOLIB_PORT_MAX; port_id++)
  {
    if (TRUE == dsatcmdp_is_sio_info_inited(port_id))
    {
      dsatcmdp_set_block_indications(port_id, flag_val);
    }
  }

  return;
} /* dsatcmdp_set_block_indications_all_ports( ) */

/*===========================================================================

FUNCTION DSATCMDP_SIO_IS_BUSY

DESCRIPTION
  This function is used by SIOLib to tell ATCoP that SIO is busy now and 
  Mode Specific Handlers are in charge of SIO.

  This is called when Mode Specific Handlers register their SIO Handlers.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  ATCOP stops sending the AT command results to the TE. It will resume
  its normal operatioon only when dsat_sio_is_free() is called.

===========================================================================*/
void dsatcmdp_sio_is_busy
(
  ds3g_siolib_port_e_type port_id
)
{
  /* Set regional flag to indicate indications should not be 
     sent to TE at this time. */
  dsatcmdp_set_block_indications(port_id, TRUE);

  return;
}

/*===========================================================================

FUNCTION DSATCMDP_SIO_IS_FREE

DESCRIPTION
  This function is used by SIOLib to tell ATCoP that SIO is free now. ATCoP
  Can now resume its normal operation.

  This is called when Mode Specific Handlers de-register their SIO Handlers.
  i.e. when the serial port is no longer in a call.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  In ETSI mode, the queued SMS indications are flushed.

===========================================================================*/
void dsatcmdp_sio_is_free
(
  ds3g_siolib_port_e_type port_id
)
{
  dsat_sio_info_s_type         *sio_info_ptr = dsatcmdp_get_sio_info_ptr(port_id);
  sys_modem_as_id_e_type        subs_id;
  dsatetsipkt_gprs_msg_ms_info *gprs_dd_val = NULL;

  /* Clear regional flag to indicate indications can now be sent to TE. */
  dsatcmdp_set_block_indications(port_id, FALSE);

#if defined(FEATURE_ETSI_SMS) || defined(FEATURE_CDMA_SMS)
  /* Flush any outstanding SMS indications */
  dsatsms_flush_sms_indications( );
#endif /* defined(FEATURE_ETSI_SMS) || defined(FEATURE_CDMA_SMS) */

#ifdef FEATURE_DSAT_ETSI_DATA
  subs_id = dsat_qcsimapp_table[sio_info_ptr->qcsimapp_val].subs_id;
  gprs_dd_val = dsat_get_base_addr_per_subs(DSAT_MS_MD_VALS, subs_id, TRUE);
  if (NULL != gprs_dd_val)
  {
    if(((dsat_num_item_type)dsatutil_get_val( DSATETSI_EXT_CGEREP_IDX,subs_id,0,
            NUM_TYPE) == DSAT_CGEREP_BUFFER_FWD_TE )||(gprs_dd_val->flush_gprs_buffer == TRUE))
    {
      dsatetsipkt_flush_gprs_event_indications(subs_id);
      gprs_dd_val->flush_gprs_buffer = FALSE;
    }
  }
#endif /* FEATURE_DSAT_ETSI_DATA */

  dsatcmdp_flush_urc(port_id);
  /* On call end, resetting the dsat_report_rate_val*/
  memset(&dsat_report_rate_val,0,sizeof( dsat_connect_rate_s_type));


  return;
}

/*===========================================================================

FUNCTION DSAT_FINISHED_ATH_CMD

DESCRIPTION
  Resets the state variable. Continues processing the AT command line.
  Called by dsat_send_result_code(). Used when we are processing ATH cmd.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  Does not resutn to CS data handler tillwe finifh processing the AT command
  line.

===========================================================================*/
void dsat_finished_ath_cmd 
(
 dsat_result_enum_type result_code         /* Command result code */
)
{
  /* Clear regional flag to indicate  */
  dsati_processing_ath_cmd = FALSE;
  dsatcmdp_processing_async_cmd = FALSE;
  /* When a command is in processing there is a possibility of
     QCSIMAPP value to be updated. */
  dsat_update_qcsimapp_val();

  /*Free the ath cmd token*/
  free_token(dsat_curr_cmd_var.tok_q_item);
  dsat_curr_cmd_var.tok_q_item = NULL;
  process_at_cmd_line( dsatcmdp_at_state, result_code, at_cmd_line_ptr );

  return;
}

/*===========================================================================
FUNCTION DSATCMDP_PROCESS_CMD_FORWARDING

DESCRIPTION
  This function will forward the command if required and 
  sets the abort handling and result code accordingly.
  

DEPENDENCIES
  NONE 

RETURN VALUE
  DSAT_OK        -- if this is not forwarded to remote client. 
  DSAT_ASYNC_CMD -- if command forwarding to external client is SUCCESS
  DSAT_ERROR  -- if command forwarding is a FAILURE

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatcmdp_process_cmd_forwarding ( void )
{
  dsat_result_enum_type result_code = DSAT_OK;
  uint8 i=0;
  dsat_cmd_state_type  curr_state;
  token_q_struct_type *token_ptr = curr_token_ptr;
  dsatme_mmgsdi_state_ms_info  *me_ms_val = NULL; 
  ds3g_siolib_port_e_type active_port = ds3g_siolib_get_active_port();
  byte curr_arg[4] = {'1','\0','1','\0'};
  if( token_ptr == NULL )
  {
    return DSAT_OK;
  }

  for ( i=0; i< MAX_CMD_LIST ;i++ )
  {	
    if ( 0 ==  dsatutil_strcmp_ig_sp_case( (const byte *)token_ptr->token.name, 
                           (const byte *)&dsat_fwd_at_cmds[i].cmd_name[0]) )
    {
       DS_AT_MSG2_HIGH("Found match for remote client processing cmd=%s Port = %d",
                 token_ptr->token.name,(int)active_port);
      me_ms_val = dsat_get_base_addr_per_session(dsat_get_current_gw_apps_id(TRUE), TRUE);
      if ((NULL != me_ms_val) && (me_ms_val->dsat_mask_pin2_state == FALSE))
      {
         me_ms_val->dsat_mask_pin2_state = TRUE;
      }

      dsatclient_state_info_update(&curr_state);
      /*If issued command is AT+CFUN=6 .mapped CFUN=6 into CFUN=1,1*/
        if(( 0 ==  dsatutil_strcmp_ig_sp_case( (const byte *)token_ptr->token.name, 
                                          (const byte *)"+CFUN") )&&
           ((dsat_num_item_type)DSAT_ME_FUNC_RESET == (dsat_num_item_type)dsatutil_get_val(
                                          DSAT_EXT_CFUN_IDX,0,0,MIX_NUM_TYPE)))
        {
          token_ptr->token.args_found = 2;
          token_ptr->token.arg[0] = curr_arg;
          token_ptr->token.arg[1] = curr_arg+2;
        }
       /* update local variables before forwarding.
          Clear it in any kind of issues before leaving the function */
      /* always the result code will be async command if it a forwarded 
         command. No further action needs to be taken below for this command.
         The response for forwarded commands will always be handled in
         dsatclient_ext_at_resp_handler(). Clearing of this variable for success
         case will be done there. */
      dsatcmdp_processing_fwd_cmd.is_pending = TRUE;
      dsatcmdp_processing_fwd_cmd.port = active_port;
      dsatcmdp_processing_fwd_cmd.client_id= dsat_fwd_at_cmds[i].client_id;
      (void)strlcpy((char *) dsatcmdp_processing_fwd_cmd.cmd_name,
                    (const char *) token_ptr->token.name, MAX_CMD_SIZE);

      if ( dsat_fwd_at_cmds[i].ext_at_cmd_exec_cb == NULL )
      {
        ERR_FATAL("Exec_callback function pointer is NULL",0,0,0);
      }
      if ( DSAT_SUCCESS == dsat_fwd_at_cmds[i].ext_at_cmd_exec_cb( 
                                       dsatcmdp_at_state,
                                       &(token_ptr->token),
                                       curr_state,
                                       (uint32)(int)(active_port),
                                       dsat_fwd_at_cmds[i].user_info_ptr))
      {
        result_code = DSAT_ASYNC_CMD;
       
        /* Check if command is abortable and set flag if it is. Also,
           since this is the start of command processing for a new command,
           set flag to insure command abort processing will be ended
           if send response function is called (default behavior). */
        if ( dsat_fwd_at_cmds[i].is_abortable )
        {
          ASSERT( dsat_fwd_at_cmds[i].ext_at_abort_cb != NULL );

          dsatcmdp_abortable_state = ABORTABLE;
          /* Command is abortable and save pointer
             to external abort CB and set SIO preprocessor mode to
             abort command mode. */
          curr_ext_at_abort_fwd_ptr = &dsat_fwd_at_cmds[i];
          dsatprep_set_preprocessor_mode(DSATI_ABORT_CMD_MODE, active_port);
        }
        dsatcmdp_end_abort_in_send_rsp = TRUE;         
        /* Process command if processing function pointer not NULL. */
        dsat_curr_cmd_var.mode = dsatcmdp_at_state;
        dsat_curr_cmd_var.parse_table = NULL;
        dsat_curr_cmd_var.tok_ptr = &(token_ptr->token);
        dsat_curr_cmd_var.tok_q_item = token_ptr;
        dsat_curr_cmd_var.res_buff_ptr = NULL;
      } /* Command forwarding is SUCCESS */
      else
      {
        /* fail processing of rest of the command line and return DSAT_ERROR */
        DS_AT_MSG0_ERROR("Command cannot be forwarded, return ERROR");
        /* Clear the pending flag,client and port */
        dsatcmdp_processing_fwd_cmd.is_pending = FALSE;
        dsatcmdp_processing_fwd_cmd.port = DS3G_SIOLIB_DATA_PORT;
        dsatcmdp_processing_fwd_cmd.client_id = 0;
        memset(dsatcmdp_processing_fwd_cmd.cmd_name, 0x0, MAX_CMD_SIZE);

        result_code = DSAT_ERROR;
      }
      break;
    }/* End of If .. */
  } /* end of for loop */
  return result_code;
}/* dsatcmdp_process_cmd_forwarding */

/*===========================================================================
FUNCTION CMDP_VALIDATE_CMD_FORWARDING

DESCRIPTION
  
  

DEPENDENCIES
  NONE 

RETURN VALUE
  DSAT_OK        -- if this is not forwarded to remote client. 
  DSAT_ASYNC_CMD -- if command forwarding to external client is SUCCESS
  DSAT_ERROR  -- if command forwarding is a FAILURE

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type cmdp_validate_cmd_forwarding
(
  token_q_struct_type *token_ptr         /* Pointer to current token    */
)
{
  dsat_result_enum_type result_code = DSAT_OK;
  curr_token_ptr = token_ptr;

  if( ( 0 !=  dsatutil_strcmp_ig_sp_case( (const byte *)token_ptr->token.name, 
                                           (const byte *)"+CFUN") ) &&
      ( 0 !=  dsatutil_strcmp_ig_sp_case( (const byte *)token_ptr->token.name, 
                                           (const byte *)"$QCPWRDN") ) )
  {
    result_code = dsatcmdp_process_cmd_forwarding();
  }
  else
  {
   result_code = DSAT_OK;
  }
  return result_code;
}


/*===========================================================================
FUNCTION  DSATCMDP_SEND_RESPOSE_TO_TE

DESCRIPTION
  If ATCOP gets an unsolicited asynchronous event, this function formats 
  the data that needs to be sent to TE.  The formatting flag controls
  response formatting and identifies if header, trailer, both header and
  trailer, or no header and trailer should be added to the response. 
  Note this routine is intended for use in asynchronous events only.

DEPENDENCIES
  None

RETURNS
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ASYNC_EVENT : if it is a success.

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatcmdp_send_respose_to_te
(
  dsm_item_type * res_buff_ptr,        /* Raw response buffer */
  dsat_rsp_enum_type type_of_rsp       /* Formatting flag     */
)
{
  dsm_item_type * formatted_res_buff = NULL;

  /* We are done with filling up raw response buffer */
  /* Format it and send it to TE                     */
  formatted_res_buff = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, FALSE);

  /* Send the new response to the user */
  /* Use START_OF_RSP to start on new line */ 
  dsat_fmt_response( &res_buff_ptr, type_of_rsp, FALSE, 
                     &formatted_res_buff );

  if (NULL != formatted_res_buff)
  {
    /* Set the Tx port and Type for URC and queued results. */
    ds3g_siolib_set_tx_type 
      (DS3G_SIOLIB_UNSOLICTED_CM, DS3G_SIOLIB_DATA_PORT); 

    /* Flush the updated queue to the Rm interface. */
    dsatcmdp_send_queued_cmd_results( );

    /* Check the formatted response data item. If it is not empty, send it
           to the Rm interface. */
    if ( formatted_res_buff->used != 0 )
    {
      /* Set the Tx port and Type. */
      ds3g_siolib_set_tx_type 
        (DS3G_SIOLIB_UNSOLICTED_CM, DS3G_SIOLIB_DATA_PORT); 
      dsatrsp_send_response( formatted_res_buff, TRUE );
    }
    else
    {
      (void) dsm_free_buffer( formatted_res_buff );
    }
  }

  return DSAT_ASYNC_EVENT;
} /* dsatcmdp_send_respose_to_te */


/*===========================================================================
FUNCTION  DSATCMDP_SEND_RESPOSE_TO_TE_EX

DESCRIPTION
  If ATCOP gets an unsolicited asynchronous event, this function formats 
  the data that needs to be sent to TE.  The formatting flag controls
  response formatting and identifies if header, trailer, both header and
  trailer, or no header and trailer should be added to the response. 
  Note this routine is intended for use in asynchronous events only.

DEPENDENCIES
  None

RETURNS
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ASYNC_EVENT : if it is a success.

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatcmdp_send_respose_to_te_ex
(
  void               *buf_ptr,
  size_t              buf_len,
  dsat_rsp_enum_type  type_of_rsp       /* Formatting flag     */
)
{
  dsat_result_enum_type  result = DSAT_ASYNC_EVENT;
  dsm_item_type         *res_buff_ptr;

  res_buff_ptr = dsat_dsm_create_packet(buf_ptr, (uint16) buf_len, TRUE);
  if (NULL != res_buff_ptr)
  {
    result = dsatcmdp_send_respose_to_te(res_buff_ptr, DSAT_COMPLETE_RSP);
  }

  return result;
} /* dsatcmdp_send_respose_to_te_ex */

/*===========================================================================
FUNCTION  PROCESS_SEND_URC

DESCRIPTION
  This function is used for processing to send an URC.

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/

LOCAL void process_send_urc
(
  dsat_msim_id_s_type *msim_id_ptr,
  dsm_item_type       *buffer,
  dsat_rsp_enum_type   rsp_type
)
{
  /* Send response to TE */
  dsm_item_type               *formatted_res_buff = NULL;
  ds3g_siolib_port_e_type      port_id;
  ds3g_siolib_state_info_type *state = NULL;
  dsm_item_type               *dup_buffer = NULL;
  uint16                       buffer_size;
  dsat_sio_info_s_type        *sio_info_ptr = NULL;
  boolean                      dtr_status = FALSE;
  dsat_num_item_type           qcsimapp_val;
  boolean                      block_indications_flag = FALSE;
  boolean                      handle_urc = FALSE;

  if ((dsat_num_item_type) dsatutil_get_val(DSAT_BASIC_Q_IDX,0,0,NUM_TYPE) == 0)
  {
    formatted_res_buff = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
    if (NULL == formatted_res_buff)
    {
      dsm_free_packet(&buffer);
      return;
    }

    dsat_fmt_response(&buffer, rsp_type, FALSE, &formatted_res_buff);
    if (NULL == formatted_res_buff)
    {
      return;
    }

    if (0 == formatted_res_buff->used)
    {
      dsm_free_packet(&formatted_res_buff);
      return;
    }

    buffer_size = (uint16) dsm_length_packet(formatted_res_buff);

    for (port_id = DS3G_SIOLIB_DATA_PORT; port_id < DS3G_SIOLIB_PORT_MAX; port_id++)
    {
      state = ds3g_siolib_get_ds3g_siolib_state(port_id);

      /* Handle URC if port has a valid stream i.e. opened */
      if (SIO_NO_STREAM_ID != state->serial_info.stream_id)
      {
        (void)ds3g_siolib_ex_is_dtr_asserted(&dtr_status, port_id);

        /* Handle URC if DTR signal is HIGH on the port */
        if (TRUE == dtr_status)
        {
          /* If the port info initialized i.e. first AT command is received on the port, then use QCSIMAPP value
             and block indications flag in the port info. Otherwise use default QCSIMAPP value and use
             block indication flag as FALSE as there is no AT command yet on the port */
          if (FALSE == dsatcmdp_is_sio_info_inited(port_id))
          {
            qcsimapp_val           = dsatcmdp_dds_qcsimapp_val;
            block_indications_flag = FALSE;
          }
          else
          {
            sio_info_ptr           = dsatcmdp_get_sio_info_ptr(port_id);
            qcsimapp_val           = sio_info_ptr->qcsimapp_val;
            block_indications_flag = sio_info_ptr->block_indications_flag;
          }

          /* Handle URC based on MSIM ID */
          switch (msim_id_ptr->class_val)
          {
            case DSAT_MSIM_CLASS_INDEPENDENT:
              handle_urc = TRUE;
              break;

            case DSAT_MSIM_CLASS_SLOT:
              handle_urc = (msim_id_ptr->id.slot_id == (qcsimapp_val + MMGSDI_SLOT_1));
              break;

            case DSAT_MSIM_CLASS_SESSION:
              handle_urc = (msim_id_ptr->id.apps_id ==
                            (dsat_apps_id_e_type) dsat_qcsimapp_table[qcsimapp_val].subs_id);
              break;

            case DSAT_MSIM_CLASS_SUBS:
              handle_urc = (msim_id_ptr->id.subs_id ==
                            dsat_qcsimapp_table[qcsimapp_val].subs_id);
              break;

            default:
              handle_urc = FALSE;
              break;
          }

          if (TRUE == handle_urc)
          {
            if (buffer_size != dsm_dup_packet(&dup_buffer, formatted_res_buff, 0, buffer_size))
            {
              dsm_free_packet(&dup_buffer);
            }
            else
            {
              /* If indications are blocked on the port, then queue the URC. Otherwise directly send it. */
              if (TRUE == block_indications_flag)
              {
                dsatcmdp_add_urc_to_queue(port_id, dup_buffer);
              }
              else
              {
                /* Set the Tx port and Type. */
                ds3g_siolib_set_tx_type(DS3G_SIOLIB_UNSOLICTED_CM, port_id);
                dsatrsp_send_response(dup_buffer, TRUE);
              }
            }

            dup_buffer = NULL;
          }
        }
      }
    }

    dsm_free_packet(&formatted_res_buff);
  }
  else
  {
    dsm_free_packet(&buffer);

    DS_AT_MSG0_HIGH("URC suppressed by ATQ ");
  }

  return;
} /* process_send_urc */

/*===========================================================================
FUNCTION  DSATCMDP_SEND_URC

DESCRIPTION
  This function is used to send an URC.

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/

void dsatcmdp_send_urc
(
  dsm_item_type      *buffer,
  dsat_rsp_enum_type  rsp_type
)
{
  dsat_msim_id_s_type msim_id;

  msim_id.class_val = DSAT_MSIM_CLASS_INDEPENDENT;

  process_send_urc(&msim_id, buffer, rsp_type);
}

/*===========================================================================
FUNCTION  DSATCMDP_SEND_URC_PER_SLOT

DESCRIPTION
  This function is used to send an URC per slot.

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/

void dsatcmdp_send_urc_per_slot
(
  mmgsdi_slot_id_enum_type  slot_id,
  dsm_item_type            *buffer,
  dsat_rsp_enum_type        rsp_type
)
{
  dsat_msim_id_s_type msim_id;

  msim_id.class_val  = DSAT_MSIM_CLASS_SLOT;
  msim_id.id.slot_id = slot_id;

  process_send_urc(&msim_id, buffer, rsp_type);
}

/*===========================================================================
FUNCTION  DSATCMDP_SEND_URC_PER_SESSION

DESCRIPTION
  This function is used to send an URC per session.

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/

void dsatcmdp_send_urc_per_session
(
  dsat_apps_id_e_type  apps_id,
  dsm_item_type       *buffer,
  dsat_rsp_enum_type   rsp_type
)
{
  dsat_msim_id_s_type msim_id;

  msim_id.class_val  = DSAT_MSIM_CLASS_SESSION;
  msim_id.id.apps_id = apps_id;

  process_send_urc(&msim_id, buffer, rsp_type);
}

/*===========================================================================
FUNCTION  DSATCMDP_SEND_URC_PER_SUBS

DESCRIPTION
  This function is used to send an URC per subscription.

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/

void dsatcmdp_send_urc_per_subs
(
  sys_modem_as_id_e_type  subs_id,
  dsm_item_type          *buffer,
  dsat_rsp_enum_type      rsp_type
)
{
  dsat_msim_id_s_type msim_id;

  msim_id.class_val  = DSAT_MSIM_CLASS_SUBS;
  msim_id.id.subs_id = subs_id;

  process_send_urc(&msim_id, buffer, rsp_type);
}

/*===========================================================================
FUNCTION DSATCMDP_RMSM_DONE_HANDLER

DESCRIPTION
  This function is called by Mode Handler when commands processing
  is complete.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
======================================================================*/
void dsatcmdp_rmsm_done_handler
(
  dsat_rmsm_cmd_type            dsat_rmsm_cmd,
  dsat_rmsm_info_s_type         dsat_rmsm_info
)
{
  ds_at_pdp_cmd_type     *pdp_info_ptr = NULL;
  ds_cmd_type            *cmd_buf  = NULL;

  DS_AT_MSG3_HIGH("RMSM done handler, Command = %d, Response = %d, Reason type = %d",
                dsat_rmsm_cmd,dsat_rmsm_info.result,dsat_rmsm_info.reason_type);
  if (dsat_rmsm_cmd == DSAT_RMSM_CGACT_CMD)
  {
    dsatetsipkt_cgact_done_handler(dsat_rmsm_info,
                                   dsat_rmsm_info.user_info_ptr);
  }
  else if(dsat_rmsm_cmd == DSAT_RMSM_CGCMOD_CMD)
  {
    dsatetsipkt_cgcmod_done_handler(dsat_rmsm_info.result,
                                   dsat_rmsm_info.user_info_ptr);
  }
  else if((dsat_rmsm_cmd == DSAT_RMSM_QCDGEN_CMD) &&
          CHECK_PENDING(DSAT_VENDOR_QCDGEN_IDX,0,DSAT_PENDING_TRUE))
  {

    SET_PENDING(DSAT_VENDOR_QCDGEN_IDX ,0, DSAT_PENDING_FALSE)
    cmd_buf = dsat_get_cmd_buf(sizeof(ds_at_pdp_cmd_type), FALSE);
    pdp_info_ptr = cmd_buf->cmd_payload_ptr;

    /* send the message to ATCOP */
    cmd_buf->hdr.cmd_id = DS_CMD_ATCOP_PDP_CMD;
    pdp_info_ptr->response       = dsat_rmsm_info.result;
    pdp_info_ptr->reason_type    = dsat_rmsm_info.reason_type;
    pdp_info_ptr->iface_net_down = dsat_rmsm_info.reason.iface_net_down;
    pdp_info_ptr->ext_info_code  = dsat_rmsm_info.reason.ext_info_code;
    pdp_info_ptr->dsat_rmsm_cmd  = dsat_rmsm_cmd;
    ds_put_cmd(cmd_buf);
  }
}/* dsatcmdp_rmsm_done_handler */

#ifdef FEATURE_DSAT_MDM_FUSION
/*===========================================================================

FUNCTION DSAT_FORWARD_CDMA_CMD

DESCRIPTION
  This Function forwards the CDMA command to the MSM in Fusion 
DEPENDENCIES
  MSM should be available to recieve the same.

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void dsat_forward_cdma_cmd
(
  const dsati_cmd_type *table_ptr, 
  token_q_struct_type  *token_ptr,
  dsm_item_type        *raw_rsp_ptr
)
{
  boolean dial_cmd = FALSE;
   ds3g_siolib_status_e_type ret_val = DS3G_SIOLIB_OK;
  ds3g_siolib_port_e_type forwarding_port = DS3G_SIOLIB_PORT_NONE;
  ds3g_siolib_port_e_type allocate_forwarding_port = DS3G_SIOLIB_PORT_NONE;
  /* Forward the Command to MSM by de-tokenizing, Put the MDM in ASYNC state */
  dsm_item_type *format_cmd = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);

  if(table_ptr->special == SPECIAL_ATD)
  {
   dial_cmd = TRUE;
   /* Call the New RM-SM proxy cb */
   dsat_proxy_curr_abort_handler  = ds707_rmsm_proxy_dial_str_cb(NULL,TRUE,NULL);
  }
  
  dsat_proxy_format_cmd((const tokens_struct_type *) &token_ptr->token,
                         (const byte *)table_ptr->name,
                         format_cmd,
                         dial_cmd );
  
  /* Get UART forwarding port */
  forwarding_port = ds3g_siolib_get_forwarding_port(
                                 ds3g_siolib_get_ds3g_siolib_active_port());
  ds3g_siolib_set_ds3g_siolib_proxy_port(forwarding_port);
  if(forwarding_port == DS3G_SIOLIB_PORT_NONE)
  {
    allocate_forwarding_port = ds3g_siolib_allocate_forwarding_port(
                                    ds3g_siolib_get_ds3g_siolib_active_port());
    ds3g_siolib_set_ds3g_siolib_proxy_port(allocate_forwarding_port);
    if(allocate_forwarding_port == DS3G_SIOLIB_PORT_NONE)
    {
      DS_AT_MSG0_ERROR("UART forwarding port is invalid");
      ASSERT(0);
    }
  }
  DS_AT_MSG1_HIGH("Forwarding port found %d",ds3g_siolib_get_proxy_port());
  
  ds3g_siolib_send_data_to_port(&ret_val,format_cmd, FALSE,
                                    ds3g_siolib_get_proxy_port());
  if(ret_val != DS3G_SIOLIB_OK )
  {
    DS_AT_MSG0_ERROR("Could not Post the Proxy command");
    ASSERT(0);
  }
  else
  {
    dsatprep_set_preprocessor_mode(DSATI_AT_PROXY_CMD_MODE, 
                                   ds3g_siolib_get_ds3g_siolib_active_port());
    dsatcmdp_processing_async_cmd = TRUE;
    free_token( token_ptr );
    token_ptr = NULL;
    /* Free the response buffer */
    dsm_free_packet( &raw_rsp_ptr );
    return;
  }
}/* dsat_forward_cdma_cmd */

/*===========================================================================

FUNCTION DSAT_PROCESS_CMD_ATTRIB

DESCRIPTION
This function evalutes the command attribute based on the 
          1. Command table entry
          2. Operating mode
Typically commands for Fusion can be executed on MDM or MSM or on both.
If in case DO is available on MDM, few commands can be avoided to forwarding to
MSM. But if DO is not available then these need to be executed on MSM. These 
commands are termed 'DO_PREFFERED'. 

All the parameter commands including S-Register commands have to be executed on 
both modems. These are termed 'COMMON_CMD'. The execution is serialised to be 
performed on MDM followed by MSM. Thus if the command_attribute in the below 
function is found to be CDMA_CMD while the table_ptr->attrib is COMMON_CMD, it 
indicates that it would get executed on MSM.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void dsat_process_cmd_attrib
( 
  const dsati_cmd_type *table_ptr, 
  uint32 *attr
)
{
  sys_sys_mode_e_type pref_sys;

  if(table_ptr->special == SPECIAL_ATD)
  {
    //NOTE ruishi check with ATCOP on how to pass sub id */
    pref_sys = ds3gdsdif_get_preferred_sys(
                        ds3gsubsmgr_subs_id_cm_to_ds3g(ds3g_get_ps_subs_id()));

    switch (pref_sys) 
    {
    case SYS_SYS_MODE_CDMA:
      *attr = CDMA_CMD;
      break;

    case SYS_SYS_MODE_HDR:
      *attr = DO_PREF_CMD;
      break;

    case SYS_SYS_MODE_LTE:
      *attr = UMTS_CMD;
      break;

    default:
      *attr = ATTRIB_NONE;
    }

    DS_AT_MSG2_HIGH("Preferred Data Service pref_sys = %d, *attr = %d",
                    pref_sys, *attr);

    return;
  }

  if(table_ptr->special == SPECIAL_SMS)
  {
    if(dsat_sms_over_ims == TRUE)
    {
      *attr = DO_PREF_CMD;
    }
    else
    {
      *attr = CDMA_CMD;
    }

    DS_AT_MSG1_HIGH("SMS over %d", *attr);

    return;
  }

  if (table_ptr->attrib & DO_PREF_CMD)
  {
    *attr = DO_PREF_CMD;
  }
  else if(table_ptr->attrib & CDMA_CMD)
  {
    *attr = CDMA_CMD;
  }
  else if(table_ptr->attrib & COMMON_CMD)
  { 
    if(*attr != CDMA_CMD)
    {
      *attr = COMMON_CMD;
    }
  }
  else
  {
    *attr = UMTS_CMD;
  }
  
  if(*attr == DO_PREF_CMD)
  {
    /* present_mode is the mode on MDM, if it is found to be as CDMA, it means 
       MDM is camped to DO service. 
    */
    if (dsatcmdp_get_current_mode() != DSAT_MODE_CDMA)
    {
    /* Forward the DO_PREF_CMD to MSM as DO service is not available */
      *attr = CDMA_CMD;
    }
  }
}/* dsat_process_cmd_attrib */

/*===========================================================================

FUNCTION DSAT_PROXY_FORMAT_CMD

DESCRIPTION
  This function takes a token data structure and builds back the raw command. 
  This is used for forwarding a command to MSM.
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS

===========================================================================*/
extern void dsat_proxy_format_cmd
(
  const tokens_struct_type *token_ptr,           /* Pointer to the Token  */
  const byte                     *cmd_name,            /* Pointer to the cmd name as 
                                                    present in the Table */
  dsm_item_type            *format_cmd_ptr,      /* Resultant Raw command  */
  boolean                  dial_cmd
)
{
  uint8              i = 0;
  dsat_num_item_type temp1;
  ASSERT((format_cmd_ptr != NULL) && (cmd_name != NULL) && (token_ptr != NULL));

  format_cmd_ptr->used = (word) snprintf(
                                       (char *)format_cmd_ptr->data_ptr, 
                                       format_cmd_ptr->size,
                                       "%s%s","AT",cmd_name);

  if( ( token_ptr->op & EQ) &&(token_ptr->cmd_category != BASIC_AT_CMD))
  {
    format_cmd_ptr->data_ptr[format_cmd_ptr->used++] = '=';
  }

  if(token_ptr->op & QU)
  {
    format_cmd_ptr->data_ptr[format_cmd_ptr->used++] = '?';
  }

  if( ( token_ptr->op & AR) || ( TRUE == dial_cmd ))
  {
    for(i=0;i < token_ptr->args_found; i++)
    {
      format_cmd_ptr->used += (word) snprintf(
         (char *)&format_cmd_ptr->data_ptr[format_cmd_ptr->used], 
                 format_cmd_ptr->size - format_cmd_ptr->used ,
                 "%s,",token_ptr->arg[i]);
    }
    format_cmd_ptr->used--;  /* Offset the last ',' */
  }
  temp1 = (dsat_num_item_type)dsatutil_get_val(DSAT_SREG_S3_IDX,0,0,NUM_TYPE);
  format_cmd_ptr->data_ptr[format_cmd_ptr->used++] = temp1;
  temp1 = (dsat_num_item_type)dsatutil_get_val(DSAT_SREG_S4_IDX,0,0,NUM_TYPE);
  format_cmd_ptr->data_ptr[format_cmd_ptr->used++] = temp1;

}/* dsat_proxy_format_cmd */

/*===========================================================================
FUNCTION DSAT_GET_FORWARD_CMD_ATTRIB

DESCRIPTION
 This function gets the command attributes of the command that is forwarded to
 the other processor.

DEPENDENCIES
 This functionality is only applicable for FUSION based architecture.

RETURN VALUE
 Command table attribute.

SIDE EFFECTS
 None.

===========================================================================*/
uint32 dsat_get_forward_cmd_attrib( void )
{
  return forwarded_command_attribute;
}/* dsat_get_forward_cmd_attrib */

/*===========================================================================
FUNCTION DSAT_GET_APPEND_RSP_STATE

DESCRIPTION
 This function gets the state of the MSM response to be appended or not.

DEPENDENCIES
 This functionality is only applicable for FUSION based architecture.

RETURN VALUE
 TRUE : MSM response is appended
 FALSE : MSM response is ignored 

SIDE EFFECTS
 NONE.

===========================================================================*/
boolean dsat_get_append_rsp_state( void )
{
    DS_AT_MSG0_HIGH("Append response query");
  return append_response;
}/* dsat_get_append_rsp_state */

/*===========================================================================
FUNCTION DSAT_SET_APPEND_RSP_STATE

DESCRIPTION
 This function sets the condition to either append the MSM response or not.

DEPENDENCIES
 This functionality is only applicable for FUSION based architecture.

RETURN VALUE
 NONE 

SIDE EFFECTS
 If used in any other parameter command, may have a side effect of doubling the o/p 
 response. Thus 'append' should only be TRUE only if necessary.

===========================================================================*/
void dsat_set_append_rsp_state( boolean append)
{
  DS_AT_MSG1_HIGH("Append response set to %d",append);
  append_response = append;
}/* dsat_set_append_rsp_state */


/*===========================================================================

FUNCTION DSATCMDP_SEND_PROXY_RESPONSE

DESCRIPTION
  This function sends the proxy response. 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_send_proxy_response
(
  dsat_result_enum_type result_code
)
{
  dsatcmdp_command_abort_complete( );
  dsatcmdp_processing_async_cmd = FALSE;
  dsatprep_set_preprocessor_mode( DSATI_AT_CMD_MODE,
                                  ds3g_siolib_get_ds3g_siolib_active_port());

  /*Free the current token if the command is aborted*/
  free_token(dsat_curr_cmd_var.tok_q_item);
  dsat_curr_cmd_var.tok_q_item = NULL;

  process_at_cmd_line( dsatcmdp_at_state, result_code, at_cmd_line_ptr );
}/* dsatcmdp_send_proxy_response */

#endif /* FEATURE_DSAT_MDM_FUSION */

/*===========================================================================

FUNCTION DSATCMDP_REFRESH_SUBS_BASED_NV

DESCRIPTION
  This function refreshes all the subscription based NVs 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL void dsatcmdp_refresh_subs_based_nv
(
  sys_modem_as_id_e_type      subs_id
)
{
  dsatutil_init_pkt_dial_string_from_nv (subs_id);
} /* dsatcmdp_refresh_subs_based_nv */
