/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

                D A T A   S E R V I C E S

                U M T S

                C A L L   C O N T R O L
                                
                A T   C O M M A N D   P R O C E S S I N G

GENERAL DESCRIPTION
  This module executes AT commands. It executes UMTS specific call control 
  AT commands.

  
EXTERNALIZED FUNCTIONS
  dsat_send_cr_result
    Sends intermediate service reporting result code to TE or PS protocol
    stack based on response routing provided by response router.
    

EXTERNALIZED FUNCTIONS INTERNAL TO DSAT UNIT
  dsatetsicall_init_call
    This function intializes ETSI call handling.

  dsatetsicall_exec_cdip_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CDIP command, which enables/disables the display of 
    called line identification.
  
  dsatetsicall_exec_ctfr_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CTFR command, which controls the call deflection (call Transfer)
    supplementary service acording to 3GPP TS 22.072 [30]
      
  dsatetsicall_set_crc_result
    Produces unformatted incoming call indication or GPRS network request
    for PDP context activation result and returns in DSM item.

  dsatetsicall_exec_cbst_cmd
    This function takes the result from the command line parser
    and executes it. It executes +CBST command.It is used to select
    bearer services to be used when data calls are originated. 

  dsatetsicall_voice_dial_cmd
    Handle atd voice dial commands.  This function is called by 
    dsatact_exec_atd_cmd when dial string has ;.

  dsatetsicall_exec_chup_cmd
    This is the command handler function for +CHUP.

  dsatetsicall_exec_ccfc_cmd
    This function takes the result from the command line parser and executes 
    it. 

  dsatetsicall_report_ccfc
    This function reports the call forwarding supplementary service status
    received from Call Manager.

  dsatetsicall_exec_clck_cmd
    This function controls the facility lock supplementary service.

  dsatetsicall_report_clck
    This function reports the facility lock supplementary service status
    received from Call Manager.

  dsatetsicall_exec_cpwd_cmd
    This function sets new passwords for facility lock supplementary service.

  dsatetsicall_exec_cusd_cmd
    This function control of Unstructured Supplementary Service Data (USSD).

  dsatetsicall_exec_ccwa_cmd
    This function controls the call waiting supplementary service. 

  dsatetsicall_exec_chld_cmd
    This function controls the call hold supplementary service. 

  dsatetsicall_update_call_state
    Maintains call state, held/active, for voice and CS data calls. 
    
  dsatetsicall_sups_cmd_cb_handler
    Handles error responses for CM Supplementary Service commands generated by
    +CHLD command

  dsatetsicall_call_event_mng_calls_conf
    Handles CM_CALL_EVENT_MNG_CALLS_CONF events, keeping call state info up to 
    date.

  dsatetsicall_call_event_connect
    Handles CM_CALL_EVENT_CONNECT events, keeping call state info up to 
    date.

  dsatetsicall_call_event_end
    Handles CM_CALL_EVENT_END events, keeping call state info up to 
    date.

  dsatetsicall_call_event_incom
    Handles CM_CALL_EVENT_INCOM events, keeping call state info up to 
    date.

  dsatetsicall_exec_es_cmd
    This function executes +ES command, which set parameters for entering 
    or exiting synchronous access mode.

  dsatetsicall_exec_esa_cmd
    This function executes +ESA command, which set parameters for synchronous 
    access mode configuration.

  dsatetsicall_es_export
    This function export the +ES's value to other subsystem.

  dsatetsicall_esa_export
    This function export the +ESA's value to other subsystem.

  dsatetsicall_exec_crlp_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CRLP command, which processes parameters for
    non-transparnet/asynchronous circuit-switched data calls.

  dsatetsicall_crlp_response_fmt
    This function generates the response for the +CRLP read & test
    commands.  The &V command respose is handled as well.  Data is
    extracted from data structure and formatted according to
    parameter flag.

  dsatetsicall_init_crlp_export
    This function intializes the +CRLP multidimensional value list.

  dsatetsicall_exec_caoc_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CAOC command, which enables/disables
    unsolitited result codes for advice of charge supplementary service.

  dsatetsicall_caoc_timer_expired_handler 
    This function is the handler function for the +CAOC command
    reporting timer expired event.

  dsatetsicall_exec_cacm_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CACM command, which reports the
    accumulated call meteter from the SIM/USIM.
    
  dsatetsicall_exec_camm_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CAMM command, which reports or resets the 
    accumulated call meter maximum from the SIM/USIM.

  dsatetsicall_aoc_verify_pin_handler
    This function is the handler function for the +CACM/+CAMM commands
    PIN2 verification.

  dsatetsicall_exec_cpuc_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CPUC command, which reports or sets the 
    Price per Unit and Currency table from the SIM/USIM.

  dsatetsicall_exec_cops_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +COPS command, which list available networks and sets
    automatic/manual registration.

  dsatetsicall_cops_abort_cmd_handler
  dsatetsicall_cops_abort_event_handler
    This function handles an abort command to terminate asynchronous
    processing for +COPS registration operation.
    
  dsatetsicall_cops_asynch_handler
    This function manages the asynchronous processing of the +COPS
    command. 

  dsatetsicall_exec_ceer_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CEER command, which report the reason
    for the last call failure to setup or release.

  dsatetsicall_exec_cqi_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CQI command, which report the GW Channel 
    Quality Indicator.
    
   Copyright (c) 2001 - 2016 by Qualcomm Technologies Incorporated.
   All Rights Reserved.
   Qualcomm Confidential and Proprietary.
*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

  $PVCSPath:  L:/src/asw/MSM5200/data/vcs/dsatetsicall.c_v   1.7   12 Jul 2002 10:05:08   randrew  $
   $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/datamodem/interface/atcop/src/dsatetsicall.c#1 $ $DateTime: 2016/12/13 08:00:03 $ $Author: mplcsds1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
06/09/16   skc     Fixed issue with at+chld=2 during MPTY calls
06/08/16   skc     Fixed PLMN display issue.
05/05/16   skc     Fixed abort issue related to CPOL command.
02/04/15   skc     Fixed issue with chld=0 where call id of active call was sent
                   if there is any active call 
12/16/15   skc     Fixed issue where wrong call id is stored during one 
                   active call and one held call and at+chld=2 is issued.
12/10/15   skc     Fixed +COPN issue in MNC display logic.
04/15/15   sc      Fixed issue in event handling to use subs_id provided in 
                   event info.
02/19/15   tk      Fixed issue in subscription not available event handling.
10/24/14   tk      ATCoP changes for dynamic memory optimizations.
09/26/14   pg      Fixed skiping of zeros in MNC display.
08/27/14   pg      Fixed CLCK query issue.
08/01/14   sc      Added support for linked MO and MT USSD sessions.
07/08/14   sc      Fixed SGLTE+G issue on SUB2.
06/27/14   tk/sc   Added support for Dynamic ATCoP.
06/12/14   pg      Depricated mmgsdi_session_perso APIs.
06/11/14   sc      Fixed PLMN name issue having '@'.
02/15/14   pg      Added support for SGLTE+G.
05/23/14   pg      Fixed LLVM warnings.
04/29/14   sc      Added csg_list_cat support to $QCCSGCOPS command.
04/17/14   sc      Fixed ATCoP KW errors.
04/07/14   pg      Fixed CREG cmd issue on sub2.
03/27/14   pg      Fixed NOCARRIER response for command issue.
03/14/14   tk/sc   Optimized debug macros usage in ATCoP.
02/20/14   pg      Fixed last character missing issue in cops response.
01/22/14   pg      Fixed incorrect CREG status in Limited service.
12/30/13   sc      Fixed static code bugs.
12/30/13   sc      Used cm_user* api instead of sys_sel* api
12/23/13   sc      Fixed PLMN name encoding/decoding issue.
12/17/13   ab      Fixed at+cops=? truncated response issue.
11/22/13   sc      Fixed Bolt MOB3.0 compiler warnings.
11/18/13   sc      Fixed ATCoP KW errors.
11/13/13   sc      Added support for $QCCSGCOPS command.
10/28/13   pg      Fixed CPOL issue on DSDS.
10/15/13   sc      Fixed +CACM issue with SIM PIN2 enabled on SUB2.
10/11/13   sc      Added support for $QCNSP, $QCSIMT, $QCRCIND commands and
                   REMOTE CALL END, REMOTE RING, REMOTE ANSWER
                   unsolicited result codes.
09/13/13   sc      Fixed KW errors.
08/01/13   sc      Fixed KW errors.
07/24/13   sc      Migrated Extended MMGSDI api to disaply RPLMN name always.
07/05/13   tk      Fixed +CUSD issue when no USSD command pending to abort.
07/02/13   pg      Migrated to MMGSDI API to find PLMN info in SE13 table
06/05/13   tk      ATCoP changes for SGLTE support on Dime Plus.
05/24/13   tk      Fixed +CVMOD issue causing crash due to exception.
05/22/13   sk      updated cm api for bcd to ascii conversion.
05/16/13   sk      $QCCOPS command for Extension of network search.
05/03/13   tk      Fixed +CEREG issue when CS domain registration denied.
04/19/13   tk      Fixed issue in DSDS device mode.
03/27/13   tk      Fixed issues in dual stack commands.
03/01/13   tk      Fixed CEER issue with network ended CS calls.
02/22/13   tk      ATCoP - CM interface changes for Triton DSDA.
02/15/13   tk      Fixed KW error.
01/08/12   sk      Encoding type MMGSDI_EONS_ENC_UCS2_PACKED added.
01/23/13   tk      Fixed ATA issue.
01/23/13   sk      DS command buffer memory reduction.
01/17/13   tk      Fixed KW errors.
01/04/13   tk      Fixed +CPAS and +CEER issues.
01/04/13   tk      ATCoP changes for DSDX C/G+G with True World Mode Support.
11/30/12   tk      ATCoP changes for Triton DSDA.
10/12/12   tk      Fixed COPS dereg issue.
10/12/12   sk      Support to add "No Change" when  value is not given in +COPS.
10/10/12   sk      Fixed COPS short name Display Issue.
08/29/12   sb      Fix for No unsolicited codes returned for CGREG.
08/22/12   sk      Mainlining Nikel Changes.
07/31/12   sk      C-EONS Feature Support.
07/26/12   sb      Fixed KW Errors.
07/16/12   tk      Added RAT input to lookup SE13 table.
06/15/12   sk      Fixed CEER issue.
06/07/12   sk      fixed COPS issue in LTE mode.
05/18/12   tk      Migrated to MSG 2.0 macros
05/11/12   sk      Fixed CLCC MT calls reporting in CDMA mode.
05/04/12   sk      Fixed PDP deactivation issue when CHUP issued.
04/20/12   sk      DSAT_NIKEL featurization changes.
03/07/12   sk      Made CLCC common for all modes.
02/20/12   sb      Fixed Compiler Warnings.
02/17/12   sk      Migrating Data related AT commands interface to unified MH.
02/06/12   ad      Added CSTF/CEN/CGPIAF/CVMOD command support.
02/06/12   nc      Added support for ^SPN and URC Queue.
12/26/11   ad      Added Support the New Call Control Interface in Call Manager.
01/19/12   sk      Feature cleanup.
01/04/12   sb      Fixed KW Warnings.
11/03/11   sb      Fixed KW Warnings.
10/17/11   ad      Added +CECALL support.
10/04/11   ht      Included dsut header to support offtarget stubs.
10/03/11   nc      Fixed the short name display for COPS command.
09/14/11   ua      Extending uiutils network type to LTE. 
09/07/11   ad      Fixed +CRLP command.
07/05/11   nc      Added support for ^MODE,^CARDMODE,^SYSCONFIG,^SYSINFO,^DSCI.
04/13/11   ua      Extneding EONS for DSDS.
04/06/11   nc      Fixed the <act> parameter display for LTE in COPS.
03/29/11   nc      Fixed +VTS command.
03/18/11   bs      Fixed CLIP num type reporting.
03/11/11   bs      Fixed SUBSCRIPTION issue.
02/24/11   bs      Fixed Klocwork errors.
02/10/11   ad      Fixed CM realted commands .
01/11/11   ad      Removed pending variable .
01/11/11   ad      Remove extern usage.used get/set API for command associated  
                   value pointers.
10/25/10   ad      Init Changes for DSDS. 
10/06/10   ad      Added Error msg before Assert(0).
10/12/10   bs      Fixed mode pref change during active voice call.
10/04/10   ua      Additional messages for the COPS network name.
09/30/10   ad      Fixed Compilation warnings. 
08/30/10   ad      Fixed cops act issue.
08/17/10   ad      Fixed +CEREG for LTE.
07/09/10   bs      Fixed +CGACT for LTE.
07/01/10   nc      Corrected the check for CEREG and CGREG command execution.
06/04/10   bs      MMGSDI SESSION Migration.
05/19/10   bs      Added <act> support for CREG.
05/17/10   ad      Added Support for $CEREG for LTE.
05/10/10   kk      Mainlining pending GOBI changes.
03/15/10   bs      Added +CQI support.
01/15/10   sa      Added support for +CPIN,^CPIN and +CLCK for RUIM cards.
                   correcting COPS response. 
12/15/09   nc      Featurisation changes for LTE.
12/8/09    vg      Fixed network operator name issue.
12/08/09   nc      Added support to display an incoming call as +CCWA when a held 
                   held call is present.
11/30/09   bs      Added +COPS support for LTE.
12/07/09   nc      Added support for <E-UTRAN_AcT> parameter for +CPOL in LTE.
10/05/09   ua\bs   Fixed +COPS issue.
11/02/09   sa      Replacing snprintf with std_snprintf.
10/30/09   nc      Limiting argument size to 1 and Returning OK after 
                   STOP_CONT_DTMF_CONF from CM for +VTS.
09/09/09   bs      Fixed Klocwork criticals.
09/22/09   vrk	   Merged LTE changes.
09/09/09   ua      Added support for EONS (spec 22.101).
08/21/09   bs      Fixed +CHLD corner case issue.
08/05/09   nc      Fixed the Input length of Passwords for +CPWD.
07/14/09   bs      Added support for $CREG command.
06/11/09   nc      Modified the waiting call end using +CHUP to 
                   reflect the correct cause code.
06/04/09   bs      Fixed +CPWD test command.
06/29/09   vg	   Replacing MSG_XXX with MSG_SPRINTF_X.
04/29/09   ua      Fixed compiler warnings. 
04/20/09   ua      Fixed lint errors.
04/16/09   sa      Removed CLIR val updation as per S65 phone's behavior.
03/20/09   ss      Fixed lac id display for creg.
01/19/09   bs      Fixed +COPS issue associated with DSAT_CFUN_CARD_POWER_CTL enabled.
01/20/09   nc      Fixed CPUC Response for Floating point output.
01/12/09   bs      Fixed +CCFC number type issue.
12/29/08   nc      Added support for +VTS Command
12/12/08   ua      Fixed Off target lint errors.
11/28/08   bs      Changed DSM LARGE item to SMALL.
11/28/08   ss      Off target Lint fix.
10/23/08   bs      Added support for 1X AT Phonebook commands.
10/18/08   bs      Fixing Featurization issues.
10/13/08   bs      Fixing 6800 compilation issues.
09/03/08   bs      Fixed Alignment issues with MDM8200.
09/08/08   bs      Fixed +COPS command for manual mode.
09/05/08   nc      Fixed +CR result reporting issue when auto answer is OFF.
07/21/08   bs      Added support for +CREG=2 command.
04/25/08   bs      Fixed +CLCK query command for personalization facilities. 
03/24/08   bs      Fixed Klocwork criticals.
03/21/08   sa      Set network access technology to automatic if not given by +COPS.
01/25/08   bs      Fixing COPS test command behaviour on SMS arrival scenario.
01/22/08   sa      Fixed +CLCK and +CPIN issues related with SIM PIN2.
11/04/07   pp      Lint low - fixes.
10/12/07   sa      Correcting COPS issues.
09/27/07   sa      Modified dsat_send_cr_result not to change ds3g_siolib_active_port.
09/25/07   ss      Fixed lint high errors.
09/21/07   sa      Fixed +CLCC reporting when call is in set-up indication phase.
08/24/07   ar      Fix feature wrapping for non-GCSD builds.
07/27/07   ar      Added support for UCSD API updating RLP parameters.
07/18/07   sa      Fixed feature wrap errors for GSM 1x builds.
06/22/07   sa      Added dsat_bsg_extra_conversion_table for conversion of basic service 
                   codes to class parameter which are not present in bsg_conversion_table.
06/14/07   sa      Corrected +CHLD not to send multiple result codes 
                   in ERROR scenarios.
05/25/07   ua      Verify the password when provided, irrespective of the 
                   SIM PIN2 status for +CPUC command. 
05/24/07   ss      +CPUC now allows only quoted strings as arguments.
05/23/07   ua      Call RAB release stack only when SMD is established.
05/18/07   sa      Corrected abort handlers to send response to TE only when
                   it is not in the NOT_ABORTABLE state.
05/17/07   ss      Moved to MMGSDI APIs for pin status operations. 
04/23/07   pp      Lint Medium fixes.
04/19/07   pp      Corrected setting of dsat_cli_presence flag in 
                   dsatetsicall_report_clip[colp]_result functions.
04/12/07   ua      Corrected CR result code to send it to answerport
                   when auto answer is choosen.
04/05/07   ua      Added support for COPS=2 (deregistration )
04/04/07   sa      Correcting COPS abort handling.
03/28/07   sa      Correcting +CHLD for 2x send.
03/21/07   sa      Add support for BS code not being sent in case of class 255 
                   to map to All tele and bearerservices of MMI code and lint 
                   fix corrections.
03/02/07   sa      Added outgoing voice call support when there is an active call  
                   for ATD command.
01/29/06   ua      Added support for GSM 7bit '@' character (0x00).
02/13/07   sa      Fixed issues related to MULTIPORT support.
02/15/07   ua      Added new phone book "FD" support.
02/15/07   ss      Fixed lint high errors
02/14/07   ph      dsatutil_reset_password() now requires total buffer size
02/13/07   sa      Correcting +CHLD command.
02/13/07   pkp     Fixed RVCT compiler warnings.
01/30/07   ss      Replaced banned string API calls.
12/14/06   sa      Fixed +CLIP <CLI validity>.
11/29/06   ua      CLCK deactivation procedure is called for deactication instead of
                   permanent disable for network personalization 
11/03/06   snb     Dual processor changes.
08/01/06   snb     Clear query_mode on failure.
07/11/06   ua      CACM/CAMM modifications according to the new CM API's.
                   PIN2 verification made mandatory for CACM/CAMM commands 
04/07/06   snb     Use dsatvoice_go_to_connecting_cmd_ext() interface.
02/27/06   snb     Allow for 2 or 3 digit MNC in PLMN.
02/21/06   sa      Merged from Sirius Branch
                   -Correct +CPOL display.
                   -Added +CLIR support
01/19/06   ua      Add support for +CTFR command
01/16/06   ua      Add support for +CDIP command
01/06/06   snb     Check for SIM PIN2 on slot selected by $QCSLOT command.
05/12/06   ua      Function dsatetsicall_display_pref_networks wrapped
                   under FEATURE_MMGSDI
05/08/06   ua      Eliminating the use of gsdi interface for CPOL command. 
                   dsatetsime_get_num_pplmn_rec is removed.
02/27/06   snb     Allow for 2 or 3 digit MNC in PLMN 
12/17/05   snb     Correct call history entry and Lint issues.
12/09/05   ar      Permit +CUSD to send empty USSD data string.
12/08/05   snb     Minor correction during addition of IPV6 support.
11/30/05   snb     Add support for +CGCMOD command.
11/11/05   ar      Return immediately to command mode for voice calls.
11/09/05   snb     Correct FEATURE_ETSI_PBM wrapping.
11/08/05   ar      Add use of BREW serving system query callbacks.  Handle 
                   async responses better.
09/23/05   snb     Add call ID to CM in-call supplementary service calls 
                   in +CHLD command handler, correct +CCFC response.
09/14/05   tkk     Corrected basic services code for +CLIP & +COLP commands.
09/07/05   ar      Added dsatetsicall_init_call().
08/15/05   snb     Fix multiple response problem when RAB reestablished.
08/03/05   hap     Modified dsatetsime_ld_save to avoid making duplicate 
                   entries in call history
07/25/05   snb     Add external RAB event handler function to support 
                   WCDMA-mode $QCDGEN.
06/14/05   ar      Return error on if +CPUC missing first two params.
05/05/05   iv      Added call id to sequence number mapping for +CLCC
04/29/05   ar      Add support for +CEER command.
04/27/05   ar      Add support for +CV120 command.
04/22/05   snb     Changes to track call sequence number as described in 3GPP 
                   TS 22.030 section 6.5.5.1 and required by +CHLD command.
04/19/05   tkk     Removed resetting of CMUT status.
04/19/05   dvp     Added a global to capture the AT cmd in execution.
04/12/05   ar      Add support for +COPS access technology selection.
04/06/05   hap     Corrections for +CSSN command
04/05/05   ar      Add support for +CIND indicators.
04/05/05   iv      Modified +CLCC to support CS data calls.
04/01/05   ar      Remove FEATURE_DSAT_COPS_ALWAYS_REPORT_HOME code.
03/30/05   tkk     Removed extra comma during number reporting.
03/30/05   iv      Fixed bugs in +CPOL.
03/29/05   ar      Minor adjustments for +COPS command handler.
03/15/05   dvp     Fixed bugs in +CLCK(personalization).
03/11/05   snb     Redo voice call LD entry fix and lint corrections.
02/28/05   hap     Added support for +CSSN command
02/21/05   dvp     Added support for Personalization facility in +CLCK
02/14/05   dvp     Removed compilation warning.
02/10/05   sb      Accessories related changes.
02/02/05   tkk     Added support for +CLIR command and generalized abort 
                   handler to include (+CLIR, +COLP and +CLIP).
02/03/05   iv      Added support for +CPOL command.
01/31/05   iv      Added support for +COPN command.
01/27/05   pdv     Merge from Sirius-ATCoP development.
01/27/05   pdv     Rebase from Mainline.
01/20/05   tkk     Incorporated +CLIP abort handling.
01/05/05   ar      Code review action items.
01/05/05   iv      Added support for +CLCC command
01/05/05   snb     Correct search for waiting and connecting voice calls,
                   make LD entry for voice calls as OEM_ no longer does.
12/30/04   tkk     Added support for +CLIP, +COLP commands.
12/29/04   snb     Further changes for new character sets, +CGACT response fix.
12/15/04   snb     Add +CHUP to hangup UI voice calls and make some variables
                   external.
12/08/04   snb     Correct number_type setting.
12/07/04   ar      Add support for +COPS command.
12/06/04   snb     Initialize number_plan on +CCFC write command.
11/19/04   tkk     Reseting voice muting after the call is done in 
                   "dsatetsicall_call_event_end".
11/18/04   snb     Add +CSCS character set support and lint corrections.
10/04/04   snb     Fix +CGACT response problem.
11/09/04   ar      Add support for +CPUC.
10/15/04   ar      Add Advice of Charge support.
09/03/04   snb     Add +CHLD support.
05/12/04   snb     Fix +CGACT response when deactivating contexts activated via
                   embedded sockets.
04/07/04   ar      Add support for setting default RLP version from NV.
03/19/04   snb     Added support for +CCWA command.
11/07/03   snb     Fix out of order responses due to local formatted response
                   buffers.
10/23/03   ar      Use CSData +CBST parameter validation routine.
10/07/03   ar      Add +CREG and +CGREG support
09/30/03   ar      Validate parameter count in +CRLP command handler.
09/04/03   ar      Adjust interface for SupS event repoting routines.
07/29/03   ar      Added command handler and response generator for +CRLP
06/26/03   sb      Moved dsatetsicall_voice_cmd_orig_cb_handler() to common
                   files. Now it is dsatvoice_cmd_orig_cb_handler().
06/09/03   ar      Fix +ES to use validated numeric parameters on test cmd.
06/03/03   ar      +CCFC response number decoding changed to BCD.
05/21/03   snb     Verify chars of +CCFC number parm in set [0-9*#abc] per
                   GSM 04.08 and correctly verify type & satype parms.
05/06/03   snb     Correct +CLCK/+CCFC response on error condition.
04/03/03   ar      Accomodate restructuring of SupS event info.
03/26/03   sb      Allow +CUSD no value default command.
03/25/03   ar      Enforce spec PIN constraints on +CPWD new password.
03/17/03   ar      Move VALID_TOKEN macro to common header file.
                   Fix +CUSD dcs parameter range test. Lint correction.
03/07/03   ar      Remove FEATURE_DATA_ETSI_SUPSERV wrappers
02/25/03   wx      Use mixed_param to implement +ES's parameters
02/25/03   ar      Removed mode switching behavior in +CBST handler
02/20/03   wx      Get rid of spaces for +ES's query result
02/06/03   ar      Fix +CLCK response for SIM action.
01/16/03   ar      Corrections to +CCFC response generation
01/08/03   wx      Added support for +ES and +ESA command
12/09/02   ar      Added support for +CUSD command
12/02/02   ar      Added support for +CPWD command
11/21/02   ar      Added support for +CCUG and +CLCK commands
10/31/02   ar      Added support for +CCFC command
10/28/02   sb      Opened Voice call related handlers (moved to a common file)
09/04/02   ar      Wrap multimode build API changes under FEATURE_DATA_MM
05/07/02   wx      Call ds3g_sio_ri_assert, ds3g_sio_ri_deassert to alert TE
01/28/02   ar      Export +CBST integer values
10/17/01   sb      Created module.

===========================================================================*/


/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/
#include "datamodem_variation.h"
#include "comdef.h"
#include "customer.h"

#include <stringl/stringl.h>


/* This file should be included only in GSM or WCDMA mode */
#ifdef FEATURE_DSAT_ETSI_MODE

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "rex.h"
#include "amssassert.h"
#include "err.h"
#include "msg.h"
#include "cmutil.h"

#if defined(T_WINNT)
#error code not present
#endif /* WINNT */

#include "dsati.h"
#include "dsatact.h"
#include "dsatctab.h"
#include "dsatetsicall.h"
#include "dsatetsictab.h"
#include "dsatetsime.h"
#include "dsatetsicmif.h"
#include "dsatcmif.h"
#include "dsatparm.h"
#include "dsatvoice.h"
#include "ds_cap.h" /* ITC_SPEECH */
#include "mn_cm_exp.h"
#include "dsucsdhdlr.h"
#include "dsumtsps.h"

#ifdef FEATURE_DSAT_ETSI_DATA
#include "dsatetsipkt.h"
#endif /* FEATURE_DSAT_ETSI_DATA */

#include "ds3gsiolib.h"

#ifdef FEATURE_DATA_GCSD_FAX
  #include "dsatgsmfax.h"
#endif /* FEATURE_DATA_GCSD_FAX */


#ifdef FEATURE_DATA_WCDMA_PS
#include "dsatvend.h"
#endif /* FEATURE_DATA_WCDMA_PS */

#include "dsutil.h"
#include "sys_v.h"

/*===========================================================================

            PUBLIC DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains public definitions for constants, macros, types,
  variables and other items needed by this module.

===========================================================================*/
#define MAX_BCD_NUMBER_LEN          ( CM_MAX_DIALED_DIGITS / 2 )
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
#define CREG_DISP_LAC_CELL_ID (2)
#define CGREG_DISP_LAC_CELL_ID (2)
#ifdef FEATURE_DSAT_LTE
#define CEREG_DISP_RAC_LAC_CELL_ID (2)
#endif /* FEATURE_DSAT_LTE */
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
#define MAX_COPN_ALPHA_LEN  128
#define CSSI_ENABLE 1
#define CSSI_DISABLE 0
#define CSSU_ENABLE 1
#define CSSU_DISABLE 0

/* Variables required for CLIP, CDIP and COLP functionality */
boolean                  dsat_clip_pending[DSAT_SYS_MODEM_AS_ID_MAX];
boolean                  dsat_colp_pending[DSAT_SYS_MODEM_AS_ID_MAX];
boolean                  dsat_cdip_pending[DSAT_SYS_MODEM_AS_ID_MAX];
/*-------------------------------------------------------------------------
    External Variables:
-------------------------------------------------------------------------*/
extern const bsg_conversion_s_type dsat_bsg_conversion_table[];
extern const bsg_conversion_s_type dsat_bsg_extra_conversion_table[];
extern const uint32 dsat_ccfc_allowed_classes;
extern const uint32 dsat_clck_allowed_classes;
extern const uint32 dsat_ccwa_allowed_classes;
extern const dsat_string_item_type dsat_clck_fac_valstr[][8];
extern const dsat_string_item_type dsat_clck_fac_tststr[];
extern const dsat_string_item_type dsat_cpwd_fac_valstr[][8];
extern const mixed_def_s_type * dsat_cops_mixed_dfl[];

#ifdef FEATURE_MMGSDI
#define MAX_CPOL_BUFF_LEN  128
#endif /* FEATURE_MMGSDI */

#ifdef FEATURE_DSAT_EXTENDED_SMS
extern boolean dsat_unicode_response;
#endif /* FEATURE_DSAT_EXTENDED_SMS */


/*===========================================================================

            LOCAL DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains local definitions for constants, macros, types,
  variables and other items needed by this module.

===========================================================================*/

/*-------------------------------------------------------------------------
    Local variables:
-------------------------------------------------------------------------*/
/* CM serving system state information */
#if defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS)
/* Enum for refernce to +CRLP elements */
enum crlp_params
{
  CRLP_IWS,
  CRLP_MWS,  
  CRLP_T1,  
  CRLP_N2,  
  CRLP_VERSION
};

/* Map RLP version to ATCOP parameter limit array element */
/* RLP v0/1 -> element 0 */
/* RLP v2   -> element 1 */
extern const byte rlpv_xref[];

typedef enum rlp_version_e
{
  /* CRLP_DEFAULT_MIN, */
  CRLP_DEFAULT_V0  = 0,
  CRLP_DEFAULT_V1  = 1,
  CRLP_DEFAULT_V2  = 2,
  CRLP_DEFAULT_MAX
} dsatetsicall_rlp_version_e_type;

/* Flag to indicate default +CRLP version to be used */
#define CRLP_DEFAULT     CRLP_DEFAULT_V1
LOCAL dsatetsicall_rlp_version_e_type dsatetsicall_crlp_version_default = CRLP_DEFAULT;

#endif /* defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS) */
typedef enum net_state_e
{
  DSAT_NET_STAT_UNKNOWN    = 0,   /* Network state unknown */
  DSAT_NET_STAT_AVAILABLE  = 1,   /* Network is available for registration */
  DSAT_NET_STAT_CURRENT    = 2,   /* Network currently registered */
  DSAT_NET_STAT_FORBIDDEN  = 3,   /* Network forbidden registraiton */
  DSAT_NET_STAT_MAX          /* Internal use only */
} dsat_net_state_e_type;
#define MAX_NETWORK_REPORT_LEN 92

#define CPUC_CURCODE_SIM_CSET ALPHA_GSM
#define CPUC_CURCODE_STR_LEN 3
#define CPUC_MAX_PARAM_STR_LEN 20   /* Currency 3 or PPU 18 */ 
#define CPUC_MAX_PPU_ACCUM 4095     /* Largest accumulator supported */ 
#define CPUC_MAX_PPU_EXPN 7         /* Largest exponent supported */ 
#define DSAT_SIM_PADDING          0xFF  /* padding byte used by the sim       */

/* PLMN list stored on ME need to be aborted(TRUE) or not(FALSE) */
LOCAL boolean dsat_abort_plmn_listing = FALSE;

/* +CEER Error lookup tables */
#define DSAT_CEER_MAX_ERROR_MSG_LEN 44
#define DSAT_CEER_LIST_TERMINATOR  (-2)
typedef struct ceer_lookup_s
{
  int16     code;
  char     *text;
} ceer_lookup_s_type;

/* CS internal cause lookup */
LOCAL const ceer_lookup_s_type ceer_cm_cause_codes[] =
{
  { (int16)CM_CALL_END_NONE,            "No cause information available" },
  { (int16)CM_CALL_END_OFFLINE,         "Phone is offline" },
  { (int16)CM_CALL_END_NO_SRV,          "No service available" },
  { (int16)CM_CALL_END_REL_NORMAL,      "Network release, no reason given"},
  { (int16)CM_CALL_END_INCOM_CALL,      "Received incoming call" },
  { (int16)CM_CALL_END_CLIENT_END,      "Client ended call" },
  { (int16)CM_CALL_END_UIM_NOT_PRESENT, "UIM not present" },
  { (int16)CM_CALL_END_ACC_IN_PROG,     "Access attempt already in progress" },
  { (int16)CM_CALL_END_ACC_FAIL,        "Access failure, unknown source" },
  { (int16)CM_CALL_END_CCS_NOT_SUPPORTED_BY_BS,
                                 "Concur service not supported by network"},
  { (int16)CM_CALL_END_NO_RESPONSE_FROM_BS,
                                 "No response received from network"},
  { (int16)CM_CALL_END_USER_CALL_ORIG_DURING_GPS,
                                 "GPS call ended for user call"},
  { (int16)CM_CALL_END_USER_CALL_ORIG_DURING_SMS,
                                 "SMS call ended for user call"},
  { (int16)CM_CALL_END_USER_CALL_ORIG_DURING_DATA,
                                 "Data call ended for emergency call" },
  { (int16)CM_CALL_END_REDIR_OR_HANDOFF,"Rejected during redirect or handoff" },
  { (int16)CM_CALL_END_LL_CAUSE,        "Lower-layer ended call" },
  { (int16)CM_CALL_END_CONF_FAILED,     "Call origination request failed" },
  { (int16)CM_CALL_END_INCOM_REJ,       "Client rejected incoming call" },
  { (int16)CM_CALL_END_SETUP_REJ,       "Client rejected setup indication" },
  { (int16)CM_CALL_END_NETWORK_END,     "Network ended call" },
  { (int16)CM_CALL_END_NO_FUNDS,        "No funds available" },
  { (int16)CM_CALL_END_NO_GW_SRV,       "No service available" },
  { (int16)CM_CALL_END_NO_FULL_SRV,     "Full service not available" },
  { (int16)CM_CALL_END_MAX_PS_CALLS,    "Maximum packet calls exceeded" },
  { (int16)CM_CALL_END_VIDEO_CONN_LOST, "Video connection lost" },
  { (int16)CM_CALL_END_VIDEO_SETUP_FAILURE,
                                 "Video call setup failure" },
  { (int16)CM_CALL_END_VIDEO_PROTOCOL_CLOSED,
                                 "Video protocol closed after setup" },
  { (int16)CM_CALL_END_VIDEO_PROTOCOL_SETUP_FAILURE,
                                 "Video protocol setup failure" },
  { (int16)CM_CALL_END_INTERNAL_ERROR,  "Internal error" },
  { DSAT_CEER_LIST_TERMINATOR,   "" }
};

/* CS network cause lookup */
LOCAL const ceer_lookup_s_type ceer_cm_net_cause_codes[] =
{
  { UNASSIGNED_CAUSE,                 "Unassigned/unalloacted number" },
  { NO_ROUTE_TO_DEST,                 "No route to destination" },
  { CHANNEL_UNACCEPTABLE,             "Channel unacceptable" },
  { OPERATOR_DETERMINED_BARRING,      "Operator determined barring" },
  { NORMAL_CALL_CLEARING,             "Normal call clearing" },
  { USER_BUSY,                        "User busy" },
  { NO_USER_RESPONDING,               "No user responding" },
  { USER_ALERTING_NO_ANSWER,          "User alerting, no answer" },
  { CALL_REJECTED,                    "Call rejected" },
  { NUMBER_CHANGED,                   "Number changed" },
  { NON_SELECTED_USER_CLEARING,       "Non selected user clearing" },
  { DESTINATION_OUT_OF_ORDER,         "Destination out of order" },
  { INVALID_NUMBER_FORMAT,            "Invalid/incomplete number" },
  { FACILITY_REJECTED,                "Facility rejected" },
  { RESPONSE_TO_STATUS_ENQUIRY,       "Response to Status Enquiry" },
  { NORMAL_UNSPECIFIED,               "Normal, unspecified" },
  { NO_CIRCUIT_CHANNEL_AVAILABLE,     "No circuit/channel available" },
  { NETWORK_OUT_OF_ORDER,             "Network out of order" },
  { TEMPORARY_FAILURE,                "Temporary failure" },
  { SWITCHING_EQUIPMENT_CONGESTION,   "Switching equipment congestion" },
  { ACCESS_INFORMATION_DISCARDED,     "Access information discarded" },
  { REQUESTED_CIRCUIT_CHANNEL_NOT_AVAILABLE,
                                 "Requested circuit/channel not available" },
  { RESOURCES_UNAVAILABLE_UNSPECIFIED,"Resources unavailable, unspecified" },
  { QUALITY_OF_SERVICE_UNAVAILABLE,   "Quality of service unavailable" },
  { REQUESTED_FACILITY_NOT_SUBSCRIBED,"Requested facility not subscribed" },
  { INCOMING_CALL_BARRED_WITHIN_CUG,  "Incoming calls barred within the CUG" },
  { BEARER_CAPABILITY_NOT_AUTHORISED, "Bearer capability not authorized" },
  { BEARER_CAPABILITY_NOT_PRESENTLY_AVAILABLE,
                                      "Bearer capability not available" },
  { SERVICE_OR_OPTION_NOT_AVAILABLE,  "Service/option not available" },
  { BEARER_SERVICE_NOT_IMPLEMENTED,   "Bearer service not implemented" },
  { ACM_GEQ_ACMMAX,                   "ACM >= ACMmax" },
  { REQUESTED_FACILITY_NOT_IMPLEMENTED, "Requested facility not implemented" },
  { ONLY_RESTRICTED_DIGITAL_INFO_BC_AVAILABLE,
                                      "Only RDI bearer is available" },
  { SERVICE_OR_OPTION_NOT_IMPLEMENTED,  "Service/option not implemented" },
  { INVALID_TRANSACTION_ID_VALUE,     "Invalid transaction identifier value" },
  { USER_NOT_MEMBER_OF_CUG,           "User not member of CUG" },
  { INCOMPATIBLE_DESTINATION,         "Incompatible destination" },
  { INVALID_TRANSIT_NETWORK_SELECTION,"Invalid transit network selection" },
  { SEMANTICALLY_INCORRECT_MESSAGE,   "Semantically incorrect message" },
  { INVALID_MANDATORY_INFORMATION,    "Invalid mandatory information" },
  { MESSAGE_TYPE_NON_EXISTENT,        "Message non-existent/not implemented" },
  { MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE,
                                    "Message type not compatible with state" },
  { IE_NON_EXISTENT_OR_NOT_IMPLEMENTED, "IE non-existent/not implemented" },
  { CONDITIONAL_IE_ERROR,             "Conditional IE error" },
  { MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE,
                                      "Message not compatible with state" },
  { RECOVERY_ON_TIMER_EXPIRY,         "Recovery on timer expiry" },
  { PROTOCOL_ERROR_UNSPECIFIED,       "Protocol error, unspecified" },
  { INTERWORKING_UNSPECIFIED,         "Interworking, unspecified" },
  { DSAT_CEER_LIST_TERMINATOR,        "" }
};

/* CS network reject lookup */
LOCAL const ceer_lookup_s_type ceer_cm_net_reject_codes[] =
{
  { IMSI_UNKNOWN_IN_HLR,              "IMSI unknown in HLR" },
  { ILLEGAL_MS,                       "Illegal MS" },
  { IMSI_UNKNOWN_IN_VLR,              "IMSI unknown in VLR" },
  { IMEI_NOT_ACCEPTED,                "IMEI not accepted" },
  { ILLEGAL_ME,                       "Illegal ME" },
  { GPRS_SERVICES_NOT_ALLOWED,        "GPRS services not allowed" },
  { GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED,
                                      "GPRS & non GPRS services not allowed" },
  { MS_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK,
                                      "MS identity cannot be derived" },
  { IMPLICITLY_DETACHED,              "Implicitly detached" },
  { PLMN_NOT_ALLOWED,                 "PLMN not allowed" },
  { LA_NOT_ALLOWED,                   "Location Area not allowed" },
  { NATIONAL_ROAMING_NOT_ALLOWED,     "Roaming not allowed" },
  { GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN,
                                      "GPRS services not allowed in PLMN" },
  { NO_SUITABLE_CELLS_IN_LA,          "No Suitable Cells In Location Area" },
  { MSC_TEMPORARILY_NOT_REACHABLE,    "MSC temporarily not reachable" },
  { NETWORK_FAILURE,                  "Network failure" },
  { MAC_FAILURE,                      "MAC failure" },
  { SYNCH_FAILURE,                    "Synch failure" },
  { CONGESTTION,                      "Congestion" },
  { GSM_AUTH_UNACCEPTED,              "GSM authentication unacceptable" },
  { SERVICE_OPTION_NOT_SUPPORTED,     "Service option not supported" },
  { REQ_SERV_OPT_NOT_SUBSCRIBED,      "Requested service option not subscribed" },
  { SERVICE_OPT__OUT_OF_ORDER,        "Service option temporarily out of order" },
  { CALL_CANNOT_BE_IDENTIFIED,        "Call cannot be identified" },
  { NO_PDP_CONTEXT_ACTIVATED,         "No PDP context activated" },
  { SEMANTICALLY_INCORRECT_MSG,       "Semantically incorrect message" },
  { INVALID_MANDATORY_INFO,           "Invalid mandatory information" },
  { MESSAGE_TYPE_NON_EXISTANT,        "Message type non-existent" },
  { MESSAGE_TYPE_NOT_COMP_PRT_ST,     "Message type not compatible with state" },
  { IE_NON_EXISTANT,                  "Information element non-existent " },
  { MSG_NOT_COMPATIBLE_PROTOCOL_STATE,"Message not compatible with state" },

  { AS_REJ_RR_REL_IND,                "RR release indication" },
  { AS_REJ_RR_RANDOM_ACCESS_FAILURE,  "RR random access failure" },
  { AS_REJ_RRC_REL_IND,               "RRC release indication" },
  { AS_REJ_RRC_CLOSE_SESSION_IND,     "RRC close session indication" },
  { AS_REJ_RRC_OPEN_SESSION_FAILURE,  "RRC open session failure" },
  { AS_REJ_LOW_LEVEL_FAIL,            "Low level failure" },
  { AS_REJ_LOW_LEVEL_FAIL_REDIAL_NOT_ALLOWED,
                                      "Low level failure no redial allowed" },
  { MM_REJ_INVALID_SIM,               "Invalid SIM" },
  { MM_REJ_NO_SERVICE,                "No service" },
  { MM_REJ_TIMER_T3230_EXP,           "Timer T3230 expired" },
  { MM_REJ_NO_CELL_AVAILABLE,         "No cell available" },
  { MM_REJ_WRONG_STATE,               "Wrong state" },
  { MM_REJ_ACCESS_CLASS_BLOCKED,      "Access class blocked" },
  { ABORT_MSG_RECEIVED,               "Abort message received" },
  { OTHER_CAUSE,                      "Other cause" },
  { CNM_REJ_TIMER_T303_EXP,           "Timer T303 expired" },
  { CNM_REJ_NO_RESOURCES,             "No resources" },
  { CNM_MM_REL_PENDING,               "Release pending" },
  { CNM_INVALID_USER_DATA,            "Invalid user data" },
  { DSAT_CEER_LIST_TERMINATOR,        "" }
};

/* PS internal cause lookup */
LOCAL const ceer_lookup_s_type ceer_ps_cause_codes[] =
{
  { (int16)INVALID_CONNECTIN_ID,             "Invalid connection identifier" },
  { (int16)INVALID_NSAPI,                    "Invalid NSAPI" },
#ifndef FEATURE_DSAT_LEGACY_GCF_SUPPORT
  { (int16)INVALID_PRI_NSAPI,                "Invalid Primary NSAPI" },
  { (int16)PDP_ESTABLISH_MAX_TIMEOUT,        "PDP establish timeout" },
#endif /* FEATURE_DSAT_LEGACY_GCF_SUPPORT */
  { (int16)INVALID_FIELD,                    "Invalid field" },
  { (int16)SNDCP_FAILURE,                    "SNDCP failure" },
  { (int16)RAB_SETUP_FAILURE,                "RAB setup failure" },
  { (int16)NO_GPRS_CONTEXT,                  "No GPRS context" },
  { (int16)PDP_ACTIVATE_MAX_TIMEOUT,         "PDP activate timeout" },
  { (int16)PDP_MODIFY_MAX_TIMEOUT,           "PDP modify timeout" },
  { (int16)PDP_INACTIVE_MAX_TIMEOUT,         "PDP inactive max timeout" },
  { (int16)PDP_LOWERLAYER_ERROR,             "PDP lowerlayer error" },
  { (int16)PDP_DUPLICATE,                    "PDP duplicate" },
  { (int16)UE_RAT_CHANGE,                    "Access technology change" },
  { (int16)PPD_UNKNOWN_REASON,               "PDP unknown reason" },
  { DSAT_CEER_LIST_TERMINATOR,        "" }
};

/* PS network cause lookup */
LOCAL const ceer_lookup_s_type ceer_ps_net_cause_codes[] =
{
  { (int16)SM_LLC_SNDCP_FAILURE,             "LLC or SNDCP failure" },
  { (int16)SM_INSUFFICIENT_RESOURCES,        "Insufficient resources" },
  { (int16)SM_MISSING_OR_UNKNOWN_APN,        "Missing or unknown APN" },
  { (int16)SM_UNKNOWN_PDP_ADDRESS_OR_TYPE,   "Unknown PDP address or PDP type" },
  { (int16)SM_USER_AUTHENTICATION_FAILED,    "User Aauthentication failed" },
  { (int16)SM_ACTIVATION_REJECTED_BY_GGSN,   "Activation rejected by GGSN" },
  { (int16)SM_ACTIVATION_REJECTED_UNSPECIFIED, "Activation rejected, unspecified" },
  { (int16)SM_SERVICE_OPTION_NOT_SUPPORTED,  "Service option not supported" },
  { (int16)SM_SERVICE_NOT_SUBSCRIBED,        "Requested service option not subscribed" },
  { (int16)SM_SERVICE_OUT_OR_ORDER,          "Service option temporarily out of order" },
  { (int16)SM_NSAPI_ALREADY_USED,            "NSAPI already used (not sent)" },
  { (int16)SM_REGULAR_DEACTIVATION,          "Regular deactivation" },
  { (int16)SM_QOS_NOT_ACCEPTED,              "QoS not accepted" },
  { (int16)SM_NETWORK_FAILURE,               "Network failure" },
  { (int16)SM_REACTIVATION_REQUIRED,         "Reactivation required" },
  { (int16)SM_FEATURE_NOT_SUPPORTED,         "Feature not supported" },
  { (int16)SM_SEMANTIC_ERR_IN_TFT,           "Semantic error in the TFT operation" },
  { (int16)SM_SYNTACTIC_ERR_IN_TFT,          "Syntactical error in the TFT operation" },
  { (int16)SM_UNKNOWN_PDP_CONTEXT,           "Unknown PDP context" },
  { (int16)SM_SEMANTIC_ERR_IN_FILTER,        "PDP context without TFT already activated" },
  { (int16)SM_SYNTACTIC_ERR_IN_FILTER,       "Semantic errors in packet filter" },
  { (int16)SM_PDP_WITHOUT_TFT_ACTIVE,        "Syntactical errors in packet filter" },
  { (int16)SM_INVALID_TRANS_ID,              "Invalid transaction identifier " },
  { (int16)SM_SEMANTIC_INCORRECT_MESG,       "Semantically incorrect message" },
  { (int16)SM_INVALID_MANDATORY_INFO,        "Invalid mandatory information" },
  { (int16)SM_MESG_TYPE_NON_EXISTENT,        "Message non-existent/not implemented" },
  { (int16)SM_MESG_TYPE_NOT_COMPATIBLE,      "Message type not compatible with state" },
  { (int16)SM_IE_NON_EXISTENT,               "IE non-existent/not implemented" },
  { (int16)SM_CONDITIONAL_IE_ERR,            "Conditional IE error" },
  { (int16)SM_MESG_NOT_COMPATIBLE,           "Message not compatible with state" },
  { (int16)SM_PROTOCOL_ERR,                  "Protocol error, unspecified" },
  { DSAT_CEER_LIST_TERMINATOR,        "" }
};

/* PS lte cause lookup */
LOCAL const ceer_lookup_s_type ceer_ps_lte_cause_codes[] =
{
  { (int16)NAS_ESM_OPTR_DETERMINED_BARRING,                    "Operator determined barring" },
  { (int16)NAS_ESM_INSUFFICIENT_RESOURCES,                     "Insufficient Resources" },
  { (int16)NAS_ESM_UNKNOWN_MISSING_APN,                        "Missing or unknown APN" },
  { (int16)NAS_ESM_UNKNOWN_PDN_TYPE,                           "Unknown PDP address or PDP type" },
  { (int16)NAS_ESM_USER_AUTHENTICATION_FAILED,                 "User Aauthentication faile" },
  { (int16)NAS_ESM_OPN_REJ_SERVICING_GW_OR_PDN_GW,             "Activation rejected by Servicing GW or PDN GW" },
  { (int16)NAS_ESM_ACTIVATION_REJECTED,                        "Activation rejected, unspecified" },
  { (int16)NAS_ESM_SERV_OPT_NOT_SUPPORTED,                     "Service option not supported" },
  { (int16)NAS_ESM_REQ_SERV_OPT_NOT_SPECIFIED,                 "Requested service option not subscribed" },
  { (int16)NAS_ESM_SERV_OPT_TEMP_OUT_OF_ORDER,                 "Service option temporarily out of order" },
  { (int16)NAS_ESM_PTI_ALREADY_IN_USE,                         "PTI already In use" },
  { (int16)NAS_ESM_REGULAR_DEACTIVATION,                       "Regular deactivation" },
  { (int16)NAS_ESM_EPS_QOS_NOT_ACCEPTED,                       "QoS not accepted" },
  { (int16)NAS_ESM_NETWORK_FAILURE,                            "Network failure" },
  { (int16)NAS_ESM_REACTIVATION_REQUIRED,                      "Reactivation required" },
  { (int16)NAS_ESM_FEATURE_NOT_SUPPORTED,                      "Feature not supported" },
  { (int16)NAS_ESM_SEMANTIC_ERR_IN_TFT_OPERATION,              "Semantic error in the TFT operation" },
  { (int16)NAS_ESM_SYNTACTICAL_ERR_IN_TFT_OPERATION,           "Syntactical error in the TFT operation" },
  { (int16)NAS_ESM_UNKNOWN_EPS_BEARER_CONTEXT,                 "Unknown Bearer context" },
  { (int16)NAS_ESM_SYMANTIC_ERR_IN_PKT_FILTER,                 "Semantic errors in packet filter" },
  { (int16)NAS_ESM_SYNTACTICAL_ERR_IN_PKT_FILTER,              "Syntactical errors in packet filter" },
  { (int16)NAS_ESM_EPS_BEARER_CONT_WO_TFT_ALREADY_ACT,         "Bearer Context without TFT already Active" },
  { (int16)NAS_ESM_PTI_MISMATCH,                               "PTI mismatch" },
  /* This is not in the standard in table 9.9.4.4.1, but
     is referred to in section 7.3 of the standard */
  { (int16)NAS_ESM_LAST_PDN_DISCONNECTED_NOT_ALLOWED,          "PDN disconnected ,Not allowed" },
  { (int16)NAS_ESM_PDN_TYPE_IPV4_ONLY_ALLOWED,                 "PDN type IPV4 only Allowed" },
  { (int16)NAS_ESM_PDN_TYPE_IPV6_ONLY_ALLOWED,                 "PDN type IPV6 only Allowed" },
  { (int16)NAS_ESM_SINGLE_ADR_BEARERS_ONLY_ALLOWED,            "Single ADR bearers only Allowed" },
  { (int16)NAS_ESM_ESM_INFO_NOT_RECEIVED,                      "ESM info not recieved" },
  { (int16)NAS_ESM_PDN_CONN_DOES_NOT_EXIST,                    "PDN connection does not exist" },
  { (int16)NAS_ESM_MULTIPLE_PDN_CONN_FOR_GIVEN_APN_NOT_ALLOWED,"Multiple PDN connection for given APN not allowed" },
  { (int16)NAS_ESM_COLLISION_WITH_NW_INIT_REQ,                 "Collision with network init request" },
  { (int16)NAS_ESM_UNSUPPORTED_QCI_VALUE,                      "Unsupported QCI value" },
  { (int16)NAS_ESM_INVALID_PTI_VALUE,                          "Invalid PTI value" },
  { (int16)NAS_ESM_SYMANTICALLY_INVALID_MSG,                   "Symantically invalid message" },
  { (int16)NAS_ESM_INVALID_MANDATORY_INFORMATION,              "Invalid mandatory information" },
  { (int16)NAS_ESM_MSG_TYPE_NON_EXISTANT,                      "Message non-existent/not implemented" },
  { (int16)NAS_ESM_MSG_TYPE_INCOMPATIBLE_PROT_STATE,           "Message type not compatible with state" },
  { (int16)NAS_ESM_INFO_ELEMENT_NON_EXISTANT,                  "Info Elemant non existent" },
  { (int16)NAS_ESM_CONDITIONAL_IE_ERR,                         "Conditional IE error" },
  { (int16)NAS_ESM_MSG_INCOMPATIBLE_WITH_PRO_STATE,            "Message type not compatible with state" },
  { (int16)NAS_ESM_PROTOCOL_ERROR,                             "Protocol error, unspecified" },
  { (int16)NAS_ESM_APN_RESTRICT_VAL_INCOMPAT_WITH_ACT_CONTEXT, "APN restrict value incompatible with ACT context" },
  { (int16)NAS_ESM_NO_FAILURE,                                 "No Failure" },
  { DSAT_CEER_LIST_TERMINATOR,                                 "" }
};

/* PS lte cause lookup */
LOCAL const ceer_lookup_s_type ceer_ps_lte_local_cause_codes[] =
{
  /* Add to this section any OTA(over the air) cause values that need equivalent representation as a local cause value*/
  /* Equivalent cause values to the EMM cause values for the purpose of relaying the srvice reject cause value to the DS*/
  { (int16)LTE_NAS_ILLEGAL_UE_LOCAL,                                   "Illegal UE" },
  { (int16)LTE_NAS_ILLEGAL_ME_LOCAL,                                   "Illegal ME" },
  { (int16)LTE_NAS_EPS_SERVICES_NOT_ALLOWED_LOCAL,                     "EPS services not allowed" },
  { (int16)LTE_NAS_UE_ID_CANNOT_BE_DERIVED_BY_NW_LOCAL,                "UE id can't be driven by network" },
  { (int16)LTE_NAS_IMPLICITLY_DETACHED_LOCAL,                          "Implicitly Detached" },
  { (int16)LTE_NAS_PLMN_NOT_ALLOWED_LOCAL,                             "PLMN not allowed" },
  { (int16)LTE_NAS_TRACKING_AREA_NOT_ALLOWED_LOCAL,                    "tracking area not allowed" },
  { (int16)LTE_NAS_ROAMING_NOT_ALLOWED_IN_THIS_TRACKING_AREA_LOCAL,    "Roaming not allowed in this tracking area" },
  { (int16)LTE_NAS_NO_SUITABLE_CELLS_IN_TRACKING_AREA_LOCAL,           "No Suitable cells in tracking area" },
  { (int16)LTE_NAS_CS_DOMAIN_NOT_AVAILABLE_LOCAL,                      "CS Domain Not available" },
  { (int16)LTE_NAS_NOT_AUTHORIZED_FOR_THIS_CSG_LOCAL,                  "Not Authorized for this CSG" },
  { (int16)LTE_NAS_CS_FALLBACK_CALL_EST_NOT_ALLOWED_LOCAL,             "CS fallback call EST not allowed" },
  { (int16)LTE_NAS_CS_DOMAIN_TEMP_NOT_AVAILABLE_LOCAL,                 "CS domain temperarly not allowed" },
  { (int16)LTE_NAS_ESM_UNKNOWN_EPS_BEARER_CONTEXT,                     "Unknown EPS bearer context" },

  /* Add local cause values to this section*/
  { (int16)DRB_RELEASED_AT_RRC,                                        "Released AT RRC" },
  { (int16)NAS_SIG_CONN_RELEASED,                                      "Signal Connection Released" },
  { (int16)EMM_DETACHED,                                               "EMM detached" },
  { (int16)EMM_ATTACH_FAILED,                                          "EMM attach failed" },
  { (int16)EMM_ATTACH_STARTED,                                         "EMM attach started" },
  { (int16)LTE_NAS_SERVICE_REQ_FAILED,                                 "NAS service request failed" },
  { (int16)ESM_ACTIVE_DEDICATED_BEARER_REACTIVATED_BY_NW,              "ESM activate dedicated bearer reactivater by network" },
  { (int16)ESM_LOWER_LAYER_FAILURE,                                    "Lower layer failure" },
  { (int16)ESM_SYNC_UP_WITH_NW,                                        "ESM sync up with network" },
  { (int16)ESM_NW_ACTIVATED_DED_BEARER_WITH_ID_OF_DEF_BEARER,          "Network activater dedicated bearer with ID of deffered bearer" },
  { (int16)ESM_BAD_OTA_MESSAGE,                                        "BAD OTA message" },
  { (int16)ESM_DS_REJECTED_THE_CALL,                                   "DS rejected the call" },
  { (int16)ESM_CONTEXT_TRANSFERED_DUE_TO_IRAT,                         "Context transferred due to IRAT" },
  { (int16)DS_EXPLICIT_DEACT,                                          "DS explicit deactivation" },

  { (int16)ESM_MSGR_FAILURE,                                           "ESM MSGR failure" },
  { (int16)ESM_LOCAL_CUASE_NONE,                                       "Local Cause not Available" },
  { (int16)ESM_REJ_DUE_TO_CONNECTED_STATE,                             "Rejected due to connected state" },
  { (int16)LTE_NAS_SERVICE_REQ_FAILED_NO_THROTTLE,                     "Nas Service request failed ,no throttle" },
  { (int16)ACL_FAILURE,                                                "ACL failure" },
  { (int16)LTE_NAS_SERVICE_REQ_FAILED_DS_DISALLOW,                     "Nas Service request failed , DS disallow" },
  { (int16)EMM_T3417_EXPIRED,                                          "EMM T3417 expired" },
  { (int16)EMM_T3417_EXT_EXPIRED,                                      "EMM T3417 ext expired" },
  { (int16)LTE_NAS_LRRC_UL_DATA_CNF_FAILURE_TXN,                       "Nas LRRC UL data CNF failure TXN" },
  { (int16)LTE_NAS_LRRC_UL_DATA_CNF_FAILURE_HO,                        "Nas LRRC UL data CNF failure HO" },
  { (int16)LTE_NAS_LRRC_UL_DATA_CNF_FAILURE_CONN_REL,                  "Nas LRRC UL data CNF failure Conn release" },
  { (int16)LTE_NAS_LRRC_UL_DATA_CNF_FAILURE_RLF,                       "Nas LRRC UL data CNF failure RLF" },
  { (int16)LTE_NAS_LRRC_UL_DATA_CNF_FAILURE_CTRL_NOT_CONN,             "Nas LRRC UL data CNF failure control Not CONN" },
  { (int16)LTE_NAS_LRRC_CONN_EST_SUCCESS,                              "NAS LRRC connection EST success" },
  { (int16)LTE_NAS_LRRC_CONN_EST_FAILURE,                              "NAS LRRC connection EST failure" },
  { (int16)LTE_NAS_LRRC_CONN_EST_FAILURE_ABORTED,                      "NAS LRRC connection EST failure, aborted" },
  { (int16)LTE_NAS_LRRC_CONN_EST_FAILURE_ACCESS_BARRED,                "NAS LRRC connection EST failure, access barrer" },
  { (int16)LTE_NAS_LRRC_CONN_EST_FAILURE_CELL_RESEL,                   "NAS LRRC connection EST failure, CELL resel" },
  { (int16)LTE_NAS_LRRC_CONN_EST_FAILURE_CONFIG_FAILURE,               "NAS LRRC connection EST failure, config failure" },
  { (int16)LTE_NAS_LRRC_CONN_EST_FAILURE_TIMER_EXPIRED,                "NAS LRRC connection EST failure, timer expired" },
  { (int16)LTE_NAS_LRRC_CONN_EST_FAILURE_LINK_FAILURE,                 "NAS LRRC connection EST failure, link failure" },
  { (int16)LTE_NAS_LRRC_CONN_EST_FAILURE_NOT_CAMPED,                   "NAS LRRC connection EST failure, not camped" },
  { (int16)LTE_NAS_LRRC_CONN_EST_FAILURE_SI_FAILURE,                   "NAS LRRC connection EST failure, SI failure" },
  { (int16)LTE_NAS_LRRC_CONN_EST_FAILURE_CONN_REJECT,                  "NAS LRRC connection EST failure, CONN reject" },
  { (int16)LTE_NAS_LRRC_CONN_REL_NORMAL,                               "NAS LRRC connection release normal" },
  { (int16)LTE_NAS_LRRC_CONN_REL_RLF,                                  "NAS LRRC connection release RLF" },
  { (int16)LTE_NAS_LRRC_CONN_REL_CRE_FAILURE,                          "NAS LRRC connection release CRE failure" },
  { (int16)LTE_NAS_LRRC_CONN_REL_OOS_DURING_CRE,                       "NAS LRRC connection release QOS during CRE" },
  { (int16)LTE_NAS_LRRC_CONN_REL_ABORTED,                              "NAS LRRC connection release aborted" },
  { (int16)LTE_NAS_LRRC_CONN_REL_SIB_READ_ERROR,                       "NAS LRRC connection release SIB read error" },
  { (int16)LTE_NAS_LRRC_CONN_REL_ABORTED_IRAT_SUCCESS,                 "NAS LRRC connection release aborted IRAT Success" },
  { (int16)LTE_NAS_REJ_LRRC_RADIO_LINK_FAILURE,                        "Nas Reject LRRC radio link failure" },
  { (int16)LTE_NAS_SERVICE_REQ_FAILURE_LTE_NW_REJECT,                  "Nas service request failure, LTE network reject" },
  { (int16)LTE_NAS_DETACH_WITH_REATTACH_LTE_NW_DETACH,                 "Nas detach with reattach, LTE network detach" },
  { (int16)LTE_NAS_DETACH_WITH_OUT_REATTACH_LTE_NW_DETACH,             "NAS detach without reacttach, LTE network detach" },
  { DSAT_CEER_LIST_TERMINATOR,                                         "" }
};


/*-------------------------------------------------------------------------
    Prototypes for local functions:
-------------------------------------------------------------------------*/

LOCAL void etsicall_encode_subaddr
(
  const byte   *ascii_subaddress,   /* SubAddress in ASCII */
  uint8  type,                      /* SubAddress type */
  byte   *subaddress,               /* Encoded SubAddress */
  byte   *length                    /* Length of SubAddress */
);

#if defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS)
LOCAL boolean etsicall_convert_cbst_param
(
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  const uint8 index,
  dsat_num_item_type* value_ptr
);

LOCAL dsat_result_enum_type etsicall_process_crlp_param
(
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  const dflm_type *def_lim_ptr,         /*  Ptr to parameter limits     */
  const uint32 pindex,                  /*  Parameter index             */
  void * result_ptr                     /*  Pointer to result           */  
);
#endif /* defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS) */

LOCAL void cssn_move_call_id
(
  sys_modem_as_id_e_type   subs_id,
  cm_call_id_type          call_id,
  dsat_cssu_e_type         cssu_res
);

LOCAL void etsicall_convert_chrset_todefault
(
  mmgsdi_eons_encoding_enum_type enc_type,
  const byte  *src_data,
  size_t      src_size,
  byte        *dst_data,
  size_t      dst_size,
  size_t      *num_unpacked
);
LOCAL void etsicall_cops_generate_network_response
(
  ds_at_plmn_info        *plmn_info_ptr,
  boolean                 eons_available,
  sys_modem_as_id_e_type  subs_id,
  dsm_item_type          *res_buff_ptr           /*  Place to put response       */
);

LOCAL dsat_net_state_e_type etsicall_find_net_state
(
  const dsat_sys_detailed_plmn_list_info_s_type * plmn_info_ptr,
  dsat_cops_act_e_type * act_ptr
);

LOCAL boolean etsicall_convert_mminfo_oper_name
(
  const uint8  * name_ptr,
  sys_network_name_coding_scheme_type_e_type  in_scheme,
  char         * out_ptr,
  uint8          max_len,
  uint8          encoded_len
);

LOCAL void etsicall_lineid_buf_copy
(
  sys_modem_as_id_e_type  subs_id,
  const uint8            *line_num_buf,
  uint8                   line_num_len
);

LOCAL void etsicall_lineid_subaddr_buf_copy
(
  sys_modem_as_id_e_type  subs_id,
  const uint8            *line_num_buf,
  uint8                   line_num_len
);


LOCAL dsat_result_enum_type etsicall_copn_reenter_handler
(
  ds_cmd_type* cmd_ptr
);

LOCAL dsat_result_enum_type etsicall_setup_network_selection
(
  const dsati_cmd_type *parse_table,
  const tokens_struct_type *tok_ptr,
  dsm_item_type *res_buff_ptr,
  dsat_num_item_type  prev_mode,
  dsatetsicall_network_pref_s_type * net_pref_ptr
);

LOCAL boolean etsicall_lookup_cause_code
(
  const ceer_lookup_s_type  *table_ptr,
  const int16                code,
  const ceer_lookup_s_type  **row_pptr
);

LOCAL void etsicall_called_lineid_buf_copy
(
  sys_modem_as_id_e_type  subs_id,
  const uint8            *line_num_buf,
  uint8                   line_num_len
);

LOCAL void dsat_cops_copy_all_categories
(
  dsat_sys_detailed_plmn_list_s_type *plmn_list,
  mmgsdi_plmn_id_type                *plmn_id_list,
  dsat_cops_cmd_idx_e_type            cmd_idx
);

/*-------------------------------------------------------------------------
    Function Definitions:
-------------------------------------------------------------------------*/

/*===========================================================================

FUNCTION  DSATETSICALL_SEND_CR_RESULT

DESCRIPTION
  Sends intermediate service reporting result code to TE or PS protocol
  stack based on response routing provided by response router.

  Should be called from mode specific protocol stack at time during
  connection negotiation that speed and quality of service is determined 
  and before compression and connect result code are sent.
 
DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsatetsicall_send_cr_result
(
  dsat_cr_service_e_type service
)
{
  /* The table of serv_text is according to
     3GPP Table_Size 27.007 Section 6.9
     Service reporting control +CR */
  dsat_num_item_type cr_val ;
  static const struct {
    dsat_cr_service_e_type serv_code;
    char * serv_text;
  } serv_table[] = {
    { DSAT_CR_SERVICE_ASYNC,     "ASYNC"     },
    { DSAT_CR_SERVICE_SYNC,      "SYNC"      },
    { DSAT_CR_SERVICE_REL_ASYNC, "REL ASYNC" },
    { DSAT_CR_SERVICE_REL_SYNC,  "REL SYNC"  },
    { DSAT_CR_SERVICE_GPRS,      "GPRS"      },
    { DSAT_CR_SERVICE_MAX,        NULL       }
  };
  cr_val =(dsat_num_item_type)dsatutil_get_val(
                                             DSATETSI_EXT_CR_IDX,0,0,NUM_TYPE);
  /* the service reporting is done only when +CR set to be 1 */
  if(cr_val == 1)
  {
    int index = 0;
    char * serv_string;

    dsm_item_type *raw_rsp_ptr, *formatted_rsp_ptr;
    char * buff_ptr;

    /* search through the serv_table for serv_text */
    do
    {
      serv_string = serv_table[index].serv_text;
    } while (serv_table[index++].serv_code != service &&
             serv_string != NULL);
  
    if(serv_string == NULL)
    {
      DS_AT_MSG1_ERROR("Incorrect service type %d", service);
      return;
    }

    /* use dsm buffer to output results */
    raw_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
    if (NULL != raw_rsp_ptr)
    {
      buff_ptr = (char *) raw_rsp_ptr->data_ptr;
      raw_rsp_ptr->used = (word)snprintf(buff_ptr,raw_rsp_ptr->size,
                                               "+CR: %s", serv_string);

      formatted_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);

      if (NULL != formatted_rsp_ptr)
      {
        /* format the result code and send response */
        dsat_fmt_response( &raw_rsp_ptr, DSAT_COMPLETE_RSP, TRUE,
                           &formatted_rsp_ptr );

        if (NULL != formatted_rsp_ptr)
        {
          /* If auto answer is set and CR is enabled, then there wont be 
             a valid active port to send the CR result, get the port 
             from the auto answer port */
          if ( ds3g_siolib_get_active_port() == DS3G_SIOLIB_PORT_NONE )
          {
            /* If the accessory feature is enabled, inform SIOLIB which port 
             this should go to */
            ds3g_siolib_port_e_type port = ds3g_siolib_get_answer_port();
            if( port == DS3G_SIOLIB_PORT_NONE )
            {
              /* If there is no auto answer port send */
              /* the response to all data ports       */
              port = DS3G_SIOLIB_DATA_PORT;
            }
            ds3g_siolib_set_tx_type( DS3G_SIOLIB_UNSOLICTED_DS_RESULT_CODE, 
                                     port); 
          }
    
          dsatrsp_send_response( formatted_rsp_ptr, FALSE );
        }
      }
    }
  }
} /* dsatetsicall_send_cr_result( ) */

/*===========================================================================

FUNCTION  DSATETSICALL_SEND_CR_RESULT_EX

DESCRIPTION
  Sends intermediate service reporting result code to TE or PS protocol
  stack based on response routing provided by response router.

  Should be called from mode specific protocol stack at time during
  connection negotiation that speed and quality of service is determined 
  and before compression and connect result code are sent.
 
DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsatetsicall_send_cr_result_ex
(
  dsat_cr_service_e_type service,
  ds3g_siolib_port_e_type port 
)
{
  /* The table of serv_text is according to
     3GPP Table_Size 27.007 Section 6.9
     Service reporting control +CR */
  dsat_num_item_type cr_val ;
  static const struct {
    dsat_cr_service_e_type serv_code;
    char * serv_text;
  } serv_table[] = {
    { DSAT_CR_SERVICE_ASYNC,     "ASYNC"     },
    { DSAT_CR_SERVICE_SYNC,      "SYNC"      },
    { DSAT_CR_SERVICE_REL_ASYNC, "REL ASYNC" },
    { DSAT_CR_SERVICE_REL_SYNC,  "REL SYNC"  },
    { DSAT_CR_SERVICE_GPRS,      "GPRS"      },
    { DSAT_CR_SERVICE_MAX,        NULL       }
  };
  cr_val =(dsat_num_item_type)dsatutil_get_val(
                                             DSATETSI_EXT_CR_IDX,0,0,NUM_TYPE);
  /* the service reporting is done only when +CR set to be 1 */
  if(cr_val == 1)
  {
    int index = 0;
    char * serv_string;

    dsm_item_type *raw_rsp_ptr, *formatted_rsp_ptr;
    char * buff_ptr;

    /* search through the serv_table for serv_text */
    do
    {
      serv_string = serv_table[index].serv_text;
    } while (serv_table[index++].serv_code != service &&
             serv_string != NULL);
  
    if(serv_string == NULL)
    {
      DS_AT_MSG1_ERROR("Incorrect service type %d", service);
      return;
    }
  
    /* use dsm buffer to output results */
    raw_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
    if ( raw_rsp_ptr == NULL )
    {
      return;
    }

    buff_ptr = (char *) raw_rsp_ptr->data_ptr;
    raw_rsp_ptr->used = (word)snprintf(buff_ptr,raw_rsp_ptr->size,
                                             "+CR: %s", serv_string);

    formatted_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
    if ( formatted_rsp_ptr == NULL )
    {
      (void)dsm_free_buffer(raw_rsp_ptr);
      return;
    }

    /* format the result code and send response */
    dsat_fmt_response( &raw_rsp_ptr, DSAT_COMPLETE_RSP, TRUE,
                       &formatted_rsp_ptr );


    ds3g_siolib_set_tx_type( DS3G_SIOLIB_UNSOLICTED_DS_RESULT_CODE, 
                               port); 

    dsatrsp_send_response( formatted_rsp_ptr, FALSE );
  }
} /* dsatetsicall_send_cr_result_ex( ) */

/*===========================================================================

FUNCTION  DSATETSICALL_EXEC_CEER_CMD

DESCRIPTION
  This function takes the result from the command line parser and
  executes it. It executes +CEER command, which report the reason for
  the last call failure to setup or release.  Both CS and PS domain
  call types are reported on.  Cause data is captured from Call
  Manager events and cached locally to later use by this command.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_OK : if it is a success for local execution
  
SIDE EFFECTS
  None
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_ceer_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result  = DSAT_ERROR;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_current_subs(DSAT_CALL_DA_VALS);
  /* Processing for WRITE syntax */
  if( tok_ptr->op == (NA) )
  {
    char buffer[80];  /* scratch buffer */
    const ceer_lookup_s_type  *table_ptr = NULL;
    const ceer_lookup_s_type  *result_ptr = NULL;
    int16 code;
    word size;

    /* Determine list of status codes to use */
    if( DSAT_CES_DOMAIN_CS == call_da_val->dsatetsicmif_call_end_status.domain)
    {
      ceer_cs_domain_s_type *info_ptr =
        &call_da_val->dsatetsicmif_call_end_status.error_info.cs_domain;

      /* Check for CS domain lower-layer or network report.
         When a call is ended by lower-layer, CM sends reject code with CM_CALL_END_LL_CAUSE.
         When a call is ended by network, CM sends cause code with CM_CALL_END_NETWORK_END. */
      if( ( CM_CALL_END_LL_CAUSE == info_ptr->end_status ) ||
          ( CM_CALL_END_NETWORK_END == info_ptr->end_status ) )
      {
        
        /* (Non)Access stratum error */
        if( TRUE == info_ptr->cc_cause.present )
        {
          /* Cause codes */
          table_ptr = ceer_cm_net_cause_codes;
          code = info_ptr->cc_cause.cause_value;
        }
        else if( TRUE == info_ptr->cc_reject.present )
        {
          /* Reject codes */
          table_ptr = ceer_cm_net_reject_codes;
          code = info_ptr->cc_reject.rej_value;
        }
        else
        {
          /* Error condition; use default code */
          DS_AT_MSG0_ERROR("Cause and reject information unavailable");
          table_ptr = ceer_cm_cause_codes;
          code = (int16)CM_CALL_END_NONE;
        }
      }
      else
      {
        /* Call processing error */
        table_ptr = ceer_cm_cause_codes;
        code = (int16)info_ptr->end_status;
      }
    }
    else if( DSAT_CES_DOMAIN_PS == call_da_val->dsatetsicmif_call_end_status.domain )
    {
      ceer_ps_domain_s_type *info_ptr =
        &call_da_val->dsatetsicmif_call_end_status.error_info.ps_domain;
      if(info_ptr->sys_mode == SYS_SYS_MODE_LTE)
      {
        if(info_ptr->esm_cause.valid)
        {
          /*cause code */
          code = (int16)info_ptr->esm_cause.esm_cause;
          table_ptr = ceer_ps_lte_cause_codes;
        }
        else if(info_ptr->esm_local_cause.valid)
        {
          /*cause code */
          code = (int16)info_ptr->esm_local_cause.local_cause;
          table_ptr = ceer_ps_lte_local_cause_codes;
        }
        else
        {
          /* Initialization condition */
          code = (int16)CM_CALL_END_NONE;
          table_ptr = ceer_cm_cause_codes;
        }
      }
      else
      {
        if((call_da_val->dsat_pdp_deactivation_cause == CM_CALL_END_LL_CAUSE) ||
              (call_da_val->dsat_pdp_deactivation_cause == CM_CALL_END_NETWORK_END))
        {
          /* Check for PS domain lower-layer report */
          if( SM_NETWORK_CAUSE == info_ptr->pdp_cause_type )
          {
            /* Network (external) cause */
            code = (int16)info_ptr->cause.ext_cause;
            table_ptr = ceer_ps_net_cause_codes;
          }
          else
          {
            /* Internal cause */
            code = (int16)info_ptr->cause.int_cause;
            table_ptr = ceer_ps_cause_codes;
          }
        }
        else
        {
          code = call_da_val->dsat_pdp_deactivation_cause;
          table_ptr = ceer_cm_cause_codes;
        }
      }
    }
    else
    {
      /* Initialization condition */
      code = (int16)CM_CALL_END_NONE;
      table_ptr = ceer_cm_cause_codes;
    }
    
    /* Lookup cause code based on domain type */
    if( TRUE != etsicall_lookup_cause_code( table_ptr, code, &result_ptr) )
    {
      DS_AT_MSG2_ERROR("Failed to lookup cause code, using default: %d %d",
                code,call_da_val->dsatetsicmif_call_end_status.domain);
      result_ptr = &ceer_cm_cause_codes[0];
    }

      
    size = (word)snprintf( buffer, sizeof(buffer),
                           "%s: %s",
                           parse_table->name,
                           result_ptr->text );

    dsat_dsm_pushdown_tail(&res_buff_ptr, buffer, size,
                           DSM_ITEM_POOL(res_buff_ptr), FALSE);
    result = DSAT_OK;

  }
  /* Processing for TEST syntax */
  else if( tok_ptr->op == (NA|EQ|QU) ) 
  {
    /* Do nothing, just report OK */
    result = DSAT_OK;
  }
  
  return result;
} /* dsatetsicall_exec_ceer_cmd */



/*===========================================================================

FUNCTION  DSATETSICALL_SET_CRC_RESULT

DESCRIPTION
  Produces unformatted incoming call indication or GPRS network request
  for PDP context activation result and returns in DSM item.

  If AT+CRC is 0, only RING is returned.
  If AT+CRC is 1, the extendted format RING <type> is returned.
                  <type> is defined in Section 6.11 of 3GPP TS 27.007

DEPENDENCIES
  None
  
RETURN VALUE
  Pointer to DSM item containing unformatted CRC result.
  
SIDE EFFECTS
  None
===========================================================================*/
dsm_item_type *dsatetsicall_set_crc_result
(
  dsat_result_enum_type crc_code
)
{
  dsm_item_type *raw_rsp_ptr;
  dsat_num_item_type temp_val; 
  dsat_num_item_type crc_val ;
  
  /* +CRING <type> table according to Section 6.11 of 3GPP TS 27.007 */
  static const struct
  {
    dsat_result_enum_type crc_code;
    char * crc_type;
  } crc_table[] =
  {
    { DSAT_CRC_CODE_ASYNC,               "ASYNC"  },
    { DSAT_CRC_CODE_SYNC,                "SYNC"  },
    { DSAT_CRC_CODE_REL_ASYNC,           "REL ASYNC"  },
    { DSAT_CRC_CODE_REL_SYNC,            "REL SYNC"  },
    { DSAT_CRC_CODE_FAX,                 "FAX"  },
    { DSAT_CRC_CODE_VOICE,               "VOICE"  },
    { DSAT_CRC_CODE_VOICE_ASYNC,         "VOICE/ASYNC"  },
    { DSAT_CRC_CODE_VOICE_SYNC,          "VOICE/SYNC"  },
    { DSAT_CRC_CODE_VOICE_REL_ASYNC,     "VOICE/REL ASYNC"  },
    { DSAT_CRC_CODE_VOICE_REL_SYNC,      "VOICE/REL SYNC"  },
    { DSAT_CRC_CODE_ALT_VOICE_ASYNC,     "ALT VOICE/ASYNC"  },
    { DSAT_CRC_CODE_ALT_VOICE_SYNC,      "ALT VOICE/SYNC"  },
    { DSAT_CRC_CODE_ALT_VOICE_REL_ASYNC, "ALT VOICE/REL ASYNC"  },
    { DSAT_CRC_CODE_ALT_VOICE_REL_SYNC,  "ALT VOICE/REL SYNC"  },
    { DSAT_CRC_CODE_ALT_ASYNC_VOICE,     "ALT ASYNC/VOICE"  },
    { DSAT_CRC_CODE_ALT_SYNC_VOICE,      "ALT SYNC/VOICE"  },
    { DSAT_CRC_CODE_ALT_REL_ASYNC_VOICE, "ALT REL ASYNC/VOICE"  },
    { DSAT_CRC_CODE_ALT_REL_SYNC_VOICE,  "ALT REL SYNC/VOICE"  },
    { DSAT_CRC_CODE_ALT_VOICE_FAX,       "ALT VOICE/FAX"  },
    { DSAT_CRC_CODE_ALT_FAX_VOICE,       "ALT FAX/VOICE"  },
    { DSAT_CRC_CODE_GPRS,                "GPRS"  },
    { DSAT_CRC_CODE_MAX,                 NULL }
  };
  crc_val =(dsat_num_item_type)dsatutil_get_val(
                                             DSATETSI_EXT_CRC_IDX,0,0,NUM_TYPE);
  /* crc extended format is enabled */
  if(crc_val == 1)
  {
    int index = 0;
    char *crc_type_string = NULL;
    
    /* search the crc type table for the extended format 
       type field */
    do
    {
      crc_type_string = crc_table[index].crc_type;
    } while ( crc_table[index++].crc_code != crc_code &&
              crc_type_string != NULL );

    if( crc_type_string == NULL )
    {
      DS_AT_MSG1_ERROR("Incorrect crc result code %d", crc_code);
      return NULL;
    }

    /* produce the extended format for incoming call indication 
       or GPRS network request for PDP context activation */
    raw_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
    if (NULL != raw_rsp_ptr)
    {
      raw_rsp_ptr->used = (word) snprintf( (char *) raw_rsp_ptr->data_ptr,
                                                  raw_rsp_ptr->size,
                                                  "+CRING: %s",
                                                  crc_type_string );
    }
  }
  else /* crc extended format is disabled */
  {
    temp_val = (dsat_num_item_type) dsatutil_get_val(DSAT_BASIC_V_IDX,0,0,NUM_TYPE);
    raw_rsp_ptr = dsatrsp_set_basic_result_code( DSAT_RING,(boolean)temp_val);
  }

  return raw_rsp_ptr;
  
} /* dsatetsicall_set_crc_result( ) */


/*===========================================================================

FUNCTION DSATETSICALL_VOICE_DIAL_CMD

DESCRIPTION
  Handle atd voice dial commands.  This function is called by 
  dsatact_exec_atd_cmd and me_dd_dial when dial string has ;.

  This function initiates a voice call and goes to DIALING state.

DEPENDENCIES

RETURN VALUE
  DSAT_ASYNC_CMD : If the command succeeds.  CM will call the cmd cb 
                   function later to report status.
  DSAT_ERROR:      If the command fails.

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_voice_dial_cmd
(
  const dsati_dial_str_type * dial_str        /* containing dial string 
                                                 and its attribs*/
)
{
  dsat_result_enum_type result;
  sys_modem_as_id_e_type subs_id = dsat_get_current_subs_id(FALSE);
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

#if defined( FEATURE_DSAT_UMTS_UNDP) && defined (FEATURE_CM_DISABLE_CALL_TYPE)
  /* For UNDP target MO voice call is not supported */
  return dsat_send_cme_error(DSAT_CME_OP_NOT_SUPPORTED);
#endif /* defined( FEATURE_DSAT_UMTS_UNDP) && defined (FEATURE_CM_DISABLE_CALL_TYPE) */

#ifdef FEATURE_DUAL_ACTIVE
  if (TRUE == dsatvoice_validate_call_cmd(subs_id, DSAT_CALL_CMD_ORIG))
#else
  /* allow ATD<str>; only when no incoming call is present */
  if ( !call_da_val->etsicall_wait_call_present )
#endif /* FEATURE_DUAL_ACTIVE */
  {
    cm_call_id_type call_id = 0;

    if ( dsatetsicmif_initiate_voice_call(dial_str, &call_id) )
    {
      dsatvoice_go_to_connecting_cmd_ext( subs_id, call_id, VOICE_CMD_ATD );

      /* the command callback function will be called */
      result = DSAT_ASYNC_CMD;
    }
    else
    {
      /* fail it, release atcop cmd processor */
      call_da_val->etsicall_was_call_active = FALSE;
      result = DSAT_ERROR;
    }
  }
  else
  {
#ifdef FEATURE_DUAL_ACTIVE
    result = dsat_send_cme_error(DSAT_CME_OP_NOT_ALLOWED);
#else
    result = DSAT_ERROR;
#endif /* FEATURE_DUAL_ACTIVE */
  }
  
  return result;

} /* dsatetsicall_voice_dial_cmd */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CHUP_CMD

DESCRIPTION
  This is the command handler function for +CHUP.

  This function sends request to CM to end current ETSI voice calls for
  action command.

  Return OK for test command.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_ASYNC_CMD : if the action command succeeds.
  DSAT_OK        : if there is no active voice call or if this
                   is a test command.
  DSAT_ERROR     : if the action command fails.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_chup_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result;
  sys_modem_as_id_e_type subs_id = dsat_get_current_subs_id(FALSE);
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  /*---------------------------------------------  
    There is no argument. Assume default value  
  ----------------------------------------------*/
  if (tok_ptr->op == NA)
  {
    uint8 num_calls = 0;
    cm_call_id_type call_ids[CM_CALL_ID_MAX];
    uint8 index;

#ifdef FEATURE_DUAL_ACTIVE
    if (FALSE == dsatvoice_validate_call_cmd(subs_id, DSAT_CALL_CMD_END))
    {
      return dsat_send_cme_error(DSAT_CME_OP_NOT_ALLOWED);
    }
#endif /* FEATURE_DUAL_ACTIVE */

    memset ((void*)call_ids, CM_CALL_ID_INVALID, sizeof(call_ids));
      
    /* Waiting calls need to end using call_cmd_answer with reply as false*/
    if( call_da_val->etsicall_wait_call_present )
    {
      etsicall_cmd_pending[subs_id] = CMD_CHUP;
      if( dsatcmif_answer_voice_call(subs_id,call_da_val->etsicall_wait_call_id,FALSE,voice_state[subs_id][call_da_val->etsicall_wait_call_id].call_mode) )
      {
        result = DSAT_ASYNC_CMD;
      }
      else
      {
        etsicall_cmd_pending[subs_id] = CMD_NONE;
        DS_AT_MSG0_ERROR("End call request failed");
        result = DSAT_ERROR;
        return result;
      }
    }

    /* in ETSI builds active and held call lists are maintained for +CHLD
       command but these types must be searched for */
    for ( index = 0; 
          index < CM_CALL_ID_MAX; 
          index++ )
    {
      if ( voice_state[subs_id][index].state == DSAT_VOICE_STATE_CONNECTING )
      {
        call_ids[num_calls++] = index;
      }
    }

    /* If any voice calls are active or held */
    if ( num_calls > 0 ||
         call_da_val->etsicall_num_active_calls != 0 ||
         call_da_val->etsicall_num_held_calls != 0 ) 
    {
      /* 27.007 describes +CHUP command as ending "current" GSM/UMTS call.
         "current" call could be a multiparty call. Additionally
         22.030, describing MMI states "The use of END key shall release all 
         calls in progress" and in 6.5.5.6 clarifies END key should terminate
         active and held calls. This is the behavior emulated by +CHUP */

      /* Fill call_ids[] with all active & held voice calls that 
         should be ended by +CHUP */
      if ( call_da_val->etsicall_num_active_calls )
      {
        for ( index = 0; (index < call_da_val->etsicall_num_active_calls&& index < CM_CALL_ID_MAX &&
               num_calls < CM_CALL_ID_MAX); index++ )
        {
          call_ids[num_calls++] = call_da_val->etsicall_active_call_ids[index];
        }
      }

      if ( call_da_val->etsicall_num_held_calls )
      {
        for ( index = 0; (index < call_da_val->etsicall_num_held_calls && index < CM_CALL_ID_MAX &&
                          num_calls < CM_CALL_ID_MAX ); index++ )
        {
          call_ids[num_calls++] = call_da_val->etsicall_held_call_ids[index];
        }
      }

      etsicall_cmd_pending[subs_id] = CMD_CHUP;

      /* Make CM call to release them all */
      if ( dsatcmif_end_calls(num_calls, &call_ids[0]) )
      {
        /* the command callback function will be called */
        result = DSAT_ASYNC_CMD;
      }
      else
      {
        etsicall_cmd_pending[subs_id] = CMD_NONE;
        DS_AT_MSG0_ERROR("End call request failed");
        result = DSAT_ERROR;
      }
    }
    else
    {
      /* +CHUP is used to hangup voice call.  If there is no
         active call or current call type is not voice call,
         return ok. 
         Spec does not specify what to retrun if
         the ph is not connected.
         This implementation follows ATH's behavior. */
      result = DSAT_OK;
    }
  }

  /*----------------------------------------------------------------
   Test command.
  -----------------------------------------------------------------*/
  else if ( tok_ptr->op == (NA|EQ|QU) )
  {
    /* we support this command */
    result = DSAT_OK;
  }

  /* other commands are illegal */
  else
  {
    result = DSAT_ERROR;
  }

  return result;
} /* dsatetsicall_exec_chup_cmd */



/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CCUG_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CCUG command, which manages the parameters for Closed User
  Group supplementary service acording to 3GPP TS 22.085

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_ccug_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
   Processing for READ command 
  -----------------------------------------------------------*/
  if ((tok_ptr->op == (NA|EQ|AR)) ||
      (tok_ptr->op == (NA|QU)) ||
      (tok_ptr->op == (NA)))
  {
    result = dsatparm_exec_param_cmd(
                                     mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr
                                    );
    
  }
  /*--------------------------------------
  Processing for a TEST command
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    /* Report nothing for test command per 3GPP TS 27.007 */
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
}  /* dsatetsicall_exec_ccug_cmd */



/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CREG_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CREG and +CGREG commands, which manage the parameters
  for network registration reporting.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_creg_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  sys_modem_as_id_e_type subs_id = dsat_get_current_subs_id(FALSE);
  void               *base_add = NULL;
#ifdef FEATURE_DSAT_LTE
  dsati_mode_e_type  sys_mode = dsatcmdp_get_current_mode();
  dsat_num_item_type cereg_val = 0;
#endif /*FEATURE_DSAT_LTE */
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
  char fmt_string[70];
  dsat_cops_act_e_type current_act;
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;


  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS, subs_id, FALSE);

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
   Processing for TEST command 
  -----------------------------------------------------------*/
  if ((tok_ptr->op == (NA|EQ|AR)) ||
      (tok_ptr->op == (NA|EQ|QU)) ||
      (tok_ptr->op == (NA)))
  {
    result = dsatparm_exec_param_cmd(
                                     mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr
                                    );
    
  }
  /*--------------------------------------
  Processing for a READ command
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|QU) )
  {
    net_reg_status_e_type reg_state;
#ifdef FEATURE_DSAT_LTE
    if((sys_mode != DSAT_MODE_LTE)&&(sys_mode != DSAT_MODE_1XLTE) 
       && (0 == dsatutil_strcmp_ig_sp_case((byte*)"+CEREG", (const byte *)parse_table->name)))
    {
      cereg_val =(dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CEREG_IDX,subs_id,0,NUM_TYPE);
       /* <stat> 4 unknown (e.g. out of E-UTRAN coverage)
          In this latest case <AcT>, <tac> and <ci> are sent only if available */
      res_buff_ptr->used =
        (word)snprintf((char*)res_buff_ptr->data_ptr,
                                res_buff_ptr->size,
                                "+CEREG: %d,4",cereg_val);
      return result;
    }
#endif /*# FEATURE_DSAT_LTE*/

    /* Determine domain to report based on command name */

    reg_state =
      ((0 == dsatutil_strcmp_ig_sp_case((byte*)"+CGREG", (const byte *)parse_table->name)) || 
       (0 == dsatutil_strcmp_ig_sp_case((byte*)"+CEREG", (const byte *)parse_table->name)))?
      ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] :
      ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS];

    base_add = (void*)dsatutil_get_val(parse_table->cmd_id,subs_id,0,STR_TYPE);

    res_buff_ptr->used =
      (word)snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                            "%s: %d,%d",
                            parse_table->name,
                            *(dsat_num_item_type*)base_add,
                            reg_state);
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
    current_act = ph_ss_ms_val->dsat_net_reg_state.act;

    if(0 == dsatutil_strcmp_ig_sp_case((byte*)"+CREG", (const byte *)parse_table->name))
    {
      /* location id, cell id is required only when CREG = 2*/
      /* Cell ID should be in  hex format*/
      /* cmd_name variable is just to differentiate if this is called
         for +CREG */
      /* Display Cell id and location id only when camped */
      if ((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CREG_IDX,
                         subs_id,0,NUM_TYPE) == CREG_DISP_LAC_CELL_ID)
      {
        /* +CREG requires only lac and cell_id */
        if(((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_HOME)||
            (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_ROAMING))&&
           ((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
            (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac != 0XFFFF)))
        {
        (void) snprintf(fmt_string,
                            sizeof(fmt_string),
                            ",\"%X\",\"%X\",%X",
                            ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                            (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                            current_act);
          res_buff_ptr->used += 
            (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                 res_buff_ptr->size - res_buff_ptr->used,
                                 "%s",fmt_string );
        }
      }
    }
#ifdef FEATURE_DSAT_DEV_CMDS
    else if(0 == dsatutil_strcmp_ig_sp_case((byte*)"$CREG", (const byte *)parse_table->name))
    {
      /* location id, cell id is required only when CREG = 2*/
      /* PSC to be displayed for WCDMA */
      /* Cell ID should be in  hex format*/
      /* cmd_name variable is just to differentiate if this is called
         for $CREG */
      /* Display Cell id and location id only when camped */
      if ((dsat_num_item_type)dsatutil_get_val(
           DSAT_VENDOR_CREG_IDX,0,0,NUM_TYPE) == CREG_DISP_LAC_CELL_ID)
      {
        /* $CREG requires only lac and cell_id */
        if(((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_HOME)||
          ( ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_ROAMING))&&
          ((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac != 0XFFFF)))
        {
          if(ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.psc == 0xFFFF)
          {
            (void) snprintf(fmt_string,
                                sizeof(fmt_string),
                                ",\"%X\",\"%X\"",
                                ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                                (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id);
          }
          else
          {
            (void) snprintf(fmt_string,
                                sizeof(fmt_string),
                                ",\"%X\",\"%X\",%X",
                                ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                                (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                                ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.psc);
          }
          res_buff_ptr->used += 
            (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                 (res_buff_ptr->size - res_buff_ptr->used),
                                 "%s",fmt_string );
        }
      }
    }
#endif /* FEATURE_DSAT_DEV_CMDS */
    else if(0 == dsatutil_strcmp_ig_sp_case((byte*)"+CGREG", (const byte *)parse_table->name))
    {
      /* location id, cell id is required only when CGREG = 2*/
      /* Cell ID should be in  hex format*/
      /* cmd_name variable is just to differentiate if this is called
         for +CGREG */
      /* Display Cell id and location id only when camped */
      if ((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CGREG_IDX,
                               subs_id,0,NUM_TYPE) == CGREG_DISP_LAC_CELL_ID)
      {
        /* +CGREG requires only lac and cell_id */
        if(((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_HOME)||
          (  ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_ROAMING))&&
          ((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac != 0XFFFF)))
        {
          (void) snprintf(fmt_string,
                              sizeof(fmt_string),
                              ",\"%X\",\"%X\",%X",
                              ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                              (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                              current_act);
          res_buff_ptr->used += 
            (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                 res_buff_ptr->size - res_buff_ptr->used,
                                 "%s",fmt_string );
        }
      }
    }
#ifdef FEATURE_DSAT_LTE
    else if(((sys_mode == DSAT_MODE_LTE) || (sys_mode == DSAT_MODE_1XLTE) 
                )&& (0 == dsatutil_strcmp_ig_sp_case((byte*)"+CEREG",(const byte *) parse_table->name)))
    {
      /* Routing area code, location id, cell id is required only when CGREG = 2*/
      /* Routing area code, location id and Cell ID  should be in  hex format*/
      /* cmd_name variable is just to differentiate if this is called for +CEREG */
      if((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CEREG_IDX,
                 subs_id,0,NUM_TYPE) == CEREG_DISP_RAC_LAC_CELL_ID)
      {
        if(((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_HOME)||
          ( ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_ROAMING))&&
          ((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.lte_tac != 0XFFFF)))
        {
          (void) snprintf(fmt_string,
                              sizeof(fmt_string),
                              ",\"%X\",\"%X\",\"%X\",%X",
                              ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.lte_tac,
                              ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.lte_rac_or_mme_code,
                              (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                              current_act);
          res_buff_ptr->used += 
            (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                 res_buff_ptr->size - res_buff_ptr->used,
                                 "%s",fmt_string );
        }
      }
    }
#endif  /* FEATURE_DSAT_LTE */

#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
}

/*===========================================================================

FUNCTION DSATETSICALL_GET_NET_REG

DESCRIPTION
  This function return last reported domain.

DEPENDENCIES
  None
  
RETURN VALUE
  Domain Net registation status

SIDE EFFECTS
  None
  
===========================================================================*/

net_reg_status_e_type  dsatetsicall_get_net_reg
( 
  net_reg_domain_e_type  domain,
  sys_modem_as_id_e_type subs_id
)
{

  net_reg_status_e_type net_reg_stat = DSAT_NET_REG_NONE;
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;
  
  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS, subs_id, FALSE);
  net_reg_stat = ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[domain];

  return net_reg_stat;
} /*dsatetsicall_get_net_reg*/

/*===========================================================================

FUNCTION DSATETSICALL_REPORT_CREG_RESULT

DESCRIPTION
  This function generates the unsolicited result code for registration
  commands +CREG and +CGREG.  The command parameter <n> controls whether
  results are presented or suppressed.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_report_creg_result 
(
  dsat_num_item_type      stack_id,
  sys_modem_as_id_e_type  subs_id,
  dsat_creg_report_e_type report_creg
)
{
  dsm_item_type * res_buff_ptr = NULL;
  dsat_num_item_type is_creg_reported = FALSE;
  const char *creg_name = "+CREG";
  
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
  char fmt_string[70];
  dsat_cops_act_e_type current_act;
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;

  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS, subs_id, FALSE);

#ifdef FEATURE_DSAT_LTE 
  if(report_creg & REPORT_CGREG)
  {
    report_creg |= REPORT_CEREG;
  }
#endif /* FEATURE_DSAT_LTE */


#ifdef FEATURE_GSM_RR_CELL_CALLBACK
  current_act = ph_ss_ms_val->dsat_net_reg_state.act;
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */

  /* Report CS domain (+CREG) response */
  if ( 0 < (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CREG_IDX,
                   subs_id,0,NUM_TYPE)) 
  {
#ifdef FEATURE_SGLTE
   if ((subs_id == dsatcmif_get_sglte_hybr_subs_id()) && (DSAT_STACK_HYBR == stack_id))
   {
     creg_name = "$QCHCREG";
   }
#endif /* FEATURE_SGLTE */

    res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
    if (NULL == res_buff_ptr)
    {
      return;
    }
    if((report_creg & REPORT_CREG))
    {
      res_buff_ptr->used =
        (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                            "%s: %d",
                            creg_name,
                            ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]);
      is_creg_reported = TRUE;
    }
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
    /* location id, cell id is required only when CREG = 2*/
    /* Cell ID should be in  hex format*/
    /* cmd_name variable is just to differentiate if this is called
       for +CREG */
    if ((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CREG_IDX,
                                         subs_id,0,NUM_TYPE) == CREG_DISP_LAC_CELL_ID)
    {
      /* +CREG displays lac and cell_id only when camped */
      if(((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_HOME)||
          (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_ROAMING))&&
          ((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac != 0XFFFF))&&
             ((report_creg & ( REPORT_CREG | REPORT_CREG_LAC | REPORT_CREG_CELL_ID))))
      {
        if((report_creg & REPORT_CREG) != REPORT_CREG)
        {
          res_buff_ptr->used =
           (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                              "%s: %d",
                              creg_name,
                              ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]);
        }
        (void) snprintf(fmt_string,
                            sizeof(fmt_string),
                            ",\"%X\",\"%X\", %X",
                            ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                            (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                            current_act);
        res_buff_ptr->used += 
          (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                               res_buff_ptr->size - res_buff_ptr->used,
                               "%s",fmt_string );
        is_creg_reported = TRUE;
      }
    }
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
  }

  /* Report PS domain (+CGREG) response */
  if (0 < (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CGREG_IDX,
               subs_id,0,NUM_TYPE))
  {
    DS_AT_MSG0_HIGH("Unsolicited cell id indication");
    if ( NULL == res_buff_ptr )
    {
      res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
      if (NULL == res_buff_ptr)
      {
        return;
      }
    }
    else if(is_creg_reported == TRUE)
    {
      res_buff_ptr->data_ptr[res_buff_ptr->used++] = '\n';
      res_buff_ptr->data_ptr[res_buff_ptr->used++] = '\n';
    }

    res_buff_ptr->data_ptr[res_buff_ptr->used] = '\0';
    if(report_creg & REPORT_CGREG)
    {
      res_buff_ptr->used =
        (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                             "%s+CGREG: %d",
                             res_buff_ptr->data_ptr,
                             ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]);
      is_creg_reported = TRUE;
    }
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
    /* location id, cell id is required only when CGREG = 2*/
    /* Cell ID should be in  hex format*/
    /* cmd_name variable is just to differentiate if this is called
       for +CGREG */
    if ((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CGREG_IDX,
                                        subs_id,0,NUM_TYPE) == CGREG_DISP_LAC_CELL_ID)
    {
      /* +CGREG displays lac and cell_id only when camped */
      if(((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_HOME)||
          (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_ROAMING))&&
          ((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac != 0XFFFF))&&
             ((report_creg &( REPORT_CGREG | REPORT_CREG_LAC | REPORT_CREG_CELL_ID))))
      {
        if((report_creg & REPORT_CGREG) != REPORT_CGREG)
        {
          res_buff_ptr->used =
            (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                              "%s+CGREG: %d",
                              res_buff_ptr->data_ptr,
                              ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]);
        }

        (void) snprintf(fmt_string,
                            sizeof(fmt_string),
                            ",\"%X\",\"%X\",%d",
                            (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                            (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                            (unsigned int)current_act);
        res_buff_ptr->used += 
          (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                               res_buff_ptr->size - res_buff_ptr->used,
                               "%s",fmt_string );
        is_creg_reported = TRUE;
      }
    }
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
  }
#ifdef FEATURE_DSAT_LTE
    /* Report PS domain (+CEREG) response */
  if ( 0 < (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CEREG_IDX,
            subs_id,0,NUM_TYPE) )
  {
    DS_AT_MSG0_HIGH("Unsolicited cell id indication");
    if((dsatcmdp_get_current_mode_per_subs(subs_id) == DSAT_MODE_LTE)
       || (dsatcmdp_get_current_mode_per_subs(subs_id) == DSAT_MODE_1XLTE) 
        )            
    {
      if ( NULL == res_buff_ptr )
      {
        res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
        if (NULL == res_buff_ptr)
        {
          return;
        }
      }
      else if(is_creg_reported == TRUE)
      {
        res_buff_ptr->data_ptr[res_buff_ptr->used++] = '\n';
        res_buff_ptr->data_ptr[res_buff_ptr->used++] = '\n';
      }
        
      res_buff_ptr->data_ptr[res_buff_ptr->used] = '\0';
      if(report_creg & REPORT_CEREG)
      {
        res_buff_ptr->used =
          (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                               "%s+CEREG: %d",
                               res_buff_ptr->data_ptr,
                                ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]);
        is_creg_reported = TRUE;
      }
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
      /* Routing area code, location id, cell id is required only when CGREG = 2*/
      /* Routing area code, location id and Cell ID  should be in  hex format*/
      /* cmd_name variable is just to differentiate if this is called for +CEREG */
      if((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CEREG_IDX,
                  subs_id,0,NUM_TYPE)== CEREG_DISP_RAC_LAC_CELL_ID)
      {
      /* +CEREG displays lac and cell_id only when camped */
        if(((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_HOME)||
          (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_ROAMING))&&
          ((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.lte_tac != 0XFFFF))&&
            ((report_creg &(REPORT_CEREG | REPORT_CREG_LAC | REPORT_CREG_CELL_ID))))
        {
          if((report_creg & REPORT_CEREG)!= REPORT_CEREG)
          {
            res_buff_ptr->used =
             (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                                "%s+CEREG: %d",
                                 res_buff_ptr->data_ptr,
                                 ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]);
          }

          (void) snprintf(fmt_string,
                                sizeof(fmt_string),
                                ",\"%X\",\"%X\",\"%X\",%X",
                                ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.lte_tac,
                                ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.lte_rac_or_mme_code,
                                (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                                current_act);
          res_buff_ptr->used += 
            (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                   res_buff_ptr->size - res_buff_ptr->used,
                                   "%s",fmt_string );
          is_creg_reported = TRUE;
        }
      }
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
    }
  }
#endif /* FEATURE_DSAT_LTE */
#ifdef FEATURE_DSAT_DEV_CMDS
  /* Report CS domain ($CREG) response */
  if ( 0 < (dsat_num_item_type)dsatutil_get_val(
                                   DSAT_VENDOR_CREG_IDX,0,0,NUM_TYPE) ) 
  {
    if ( NULL == res_buff_ptr )
    {
      res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
      if (NULL == res_buff_ptr)
      {
        return;
      }
    }
    else if(is_creg_reported == TRUE)
    {
      res_buff_ptr->data_ptr[res_buff_ptr->used++] = '\n';
      res_buff_ptr->data_ptr[res_buff_ptr->used++] = '\n';
    }

    res_buff_ptr->data_ptr[res_buff_ptr->used] = '\0';
    if(report_creg & REPORT_CREG)
    {
      res_buff_ptr->used =
         (word) snprintf((char*)res_buff_ptr->data_ptr,
                             res_buff_ptr->size,
                             "%s$CREG: %d",
                             res_buff_ptr->data_ptr,
                             ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]);
      is_creg_reported = TRUE;
    }
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
    /* location id, cell id is required only when CREG = 2*/
    /* PSC to be displayed for WCDMA */
    /* Cell ID should be in  hex format*/
    /* cmd_name variable is just to differentiate if this is called
       for $CREG */
    if ((dsat_num_item_type)dsatutil_get_val(
           DSAT_VENDOR_CREG_IDX,0,0,NUM_TYPE) == CREG_DISP_LAC_CELL_ID)
    {
      /* +CREG displays lac and cell_id only when camped */
      if(((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_HOME)||
          (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_ROAMING))&&
          ((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac != 0XFFFF))&&
             ((report_creg &( REPORT_CREG | REPORT_CREG_LAC | REPORT_CREG_CELL_ID))))
      {
     
        if((report_creg & REPORT_CREG) != REPORT_CREG)
        {
          res_buff_ptr->used =
           (word) snprintf((char*)res_buff_ptr->data_ptr,
                              res_buff_ptr->size,
                              "%s$CREG: %d",
                              res_buff_ptr->data_ptr,
                              ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]);
        }
        if((ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.psc == 0xFFFF) || 
               ((report_creg & REPORT_CREG_CELL_PSC) != REPORT_CREG_CELL_PSC))
        {
          (void) snprintf(fmt_string,
                          sizeof(fmt_string),
                          ",\"%X\",\"%X\"",
                          ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                          (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id);
        }
        else
        {
          (void) snprintf(fmt_string,
                              sizeof(fmt_string),
                              ",\"%X\",\"%X\",%X",
                              ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                             (unsigned int)ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                              ph_ss_ms_val->dsat_net_reg_state.dsat_creg_reported.psc);
        }

        res_buff_ptr->used += 
          (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                               res_buff_ptr->size - res_buff_ptr->used,
                               "%s",fmt_string );
        is_creg_reported = TRUE;
      }
    }
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
  }
#endif /* FEATURE_DSAT_DEV_CMDS */
  /* Ensure a response was generated */

  if (NULL != res_buff_ptr)
  { 
   if(is_creg_reported == TRUE)
   {
    /* Send response to TE */
      dsatcmdp_send_urc_per_subs(subs_id, res_buff_ptr, DSAT_COMPLETE_RSP);
    }
   else
    {
     /*CREG status not changed*/
      DS_AT_MSG1_HIGH(" Is creg reported:- %d",is_creg_reported);
     (void)dsm_free_buffer(res_buff_ptr);
    }
  }
} /* dsatetsicall_report_creg_result */



/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CCFC_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CCFC command, which controls the call forwarding
  supplementary service acording to 3GPP TS 22.082

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_ccfc_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsatetsicmif_sups_state_ss_info  *sups_ss_val = NULL;
  dsatetsicmif_sups_state_ms_info  *sups_ms_val = NULL;

  sups_ms_val = dsat_get_base_addr_current_subs(DSAT_SUPS_MS_VALS);
  sups_ss_val = dsat_get_base_addr(DSAT_SUPS_SS_VALS, FALSE);

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
  if (tok_ptr->op == (NA|EQ|AR))
  {
    ss_cf_user_s_type * sscf_ptr = &sups_ms_val->dsat_ss_cm_data.user_data.opdata.call_fwd;
    cm_num_s_type number ;
    byte length = 0;
    dsat_num_item_type temp;
    mixed_def_s_type ** mixed_def_list = 
      (mixed_def_s_type **) parse_table->def_lim_ptr;

    /* Initialize data structure */
    memset( &number ,0, sizeof(cm_num_s_type));
    memset (&sups_ms_val->dsat_ss_cm_data.user_data, 0, sizeof(ss_user_data_s_type));
    sups_ms_val->dsat_ss_cm_data.user_data.operation = DSAT_SSOP_CALL_FWD;
    
    /* Validate REASON parameter (no default) */
    if (VALID_TOKEN(0))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[0], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert REASON parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((dsat_num_item_type)DSAT_CCFC_REASON_MAX <= temp)
      {
        DS_AT_MSG0_HIGH("REASON parameter outside range");
        return DSAT_ERROR;
      }
      sscf_ptr->reason = (ccfc_reason_e_type)temp;
    }
    else
    {
      DS_AT_MSG0_HIGH("+CCFC REASON parameter mandatory");
      return DSAT_ERROR;
    }
    
    /* Validate MODE parameter  (no default) */
    if (VALID_TOKEN(1))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[1], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert MODE parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((dsat_num_item_type)DSAT_CCFC_MODE_MAX <= temp)
      {
        DS_AT_MSG0_HIGH("MODE parameter outside range");
        return DSAT_ERROR;
      }
      sscf_ptr->mode = (ccfc_mode_e_type)temp;
    }
    else
    {
      DS_AT_MSG0_HIGH("+CCFC MODE parameter mandatory");
      return DSAT_ERROR;
    }

    /* Validate CLASS parameter  (default available) */
    if (VALID_TOKEN(4))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[4], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert CLASS parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((mixed_def_list[4]->def->dflm.upper <  temp) &&
          (mixed_def_list[4]->def->dflm.lower >  temp))
      {
        DS_AT_MSG0_HIGH("MODE parameter outside range");
        return DSAT_ERROR;
      }

      /* See if class in Basice Service Group lookup table */
      if ((dsat_ccfc_allowed_classes != (dsat_ccfc_allowed_classes | temp)) &&
          ((dsat_num_item_type)DSAT_SS_CLASS_ALL != temp))
      {
        DS_AT_MSG0_HIGH("Class not mapped to allowed BSG");
        return DSAT_ERROR;
      }
      
      sups_ms_val->dsat_ss_cm_data.user_data.class = (uint8)temp;
    }
    else
    {
      /* Default */
      sups_ms_val->dsat_ss_cm_data.user_data.class = (uint8)mixed_def_list[4]->def->dflm.default_v;
    }

    /* Validate TIME parameter  (default available) */
    if (VALID_TOKEN(7))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[7], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert TIME parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((mixed_def_list[7]->def->dflm.upper <  temp) ||
          (mixed_def_list[7]->def->dflm.lower >  temp))                                            
      {
        DS_AT_MSG0_HIGH("TIME parameter outside range");
        return DSAT_ERROR;
      }
      sscf_ptr->time = (uint8)temp;
    }
    else
    {
      /* Default */
      sscf_ptr->time = (uint8)mixed_def_list[7]->def->dflm.default_v;
    }

    /* Validate NUMBER parameter */
    if (VALID_TOKEN(2))
    {
      const byte *digit = tok_ptr->arg[2];

      /* Test length */
      if (mixed_def_list[2]->def->string_len <
          strlen((char*)tok_ptr->arg[2]))
      {
        DS_AT_MSG0_HIGH("NUMBER parameter too long");
        return DSAT_ERROR;
      }

      /* Strip quotes if present */
      if ('"' == *tok_ptr->arg[2])
      {
        if (!dsatutil_strip_quotes_out(
               tok_ptr->arg[2], tok_ptr->arg[2],
               mixed_def_list[2]->def->string_len))
        {
          DS_AT_MSG0_HIGH("Quote stripping failed");
          return DSAT_ERROR;
        }
      }

      /*Hold number in Ascii formate for MMI string constuction */
      memset(&sups_ss_val->dsat_reg_number[0],0,CM_CALLED_PARTY_BCD_NO_LENGTH);

      (void) dsatutil_memscpy((void*)&sups_ss_val->dsat_reg_number[0],
              CM_CALLED_PARTY_BCD_NO_LENGTH,(void*)digit,
              MIN(strlen((char*)digit),CM_CALLED_PARTY_BCD_NO_LENGTH));

      /* cm_num_fill does nothing to verify number */
      if ('+' == *digit)
      {
        digit++;
      }    
      /* per GSM 04.08, table 10.81 */
      while (*digit)
      {
        if ( ((*digit < '0') || (*digit > '9')) &&
             (*digit != '*') && (*digit != '#') && 
             (*digit != 'a') && (*digit != 'b') && (*digit != 'c') )
        {
          return DSAT_ERROR;
        }       
        digit++;
      } 

      /* Format number structure, accounting for '+' prefix. */
      /* '+' is stripped if detected.                        */
      cm_num_fill(&number, (byte *)tok_ptr->arg[2],
                  (byte)strlen((char*)tok_ptr->arg[2]),
                  CM_DIGIT_MODE_8BIT_ASCII);
      /* Updating number type as cm_num_fill does not fill it */
      if (number.buf[0] == '+' )
      {
        number.number_type = INTERNATIONAL_TON_ISDN_NPI;
      }
      else
      {
        number.number_type = UNKNOWN_TON_ISDN_NPI;
      }
    }
    else
    {
      /* Clear number structure */
      memset(&number, 0, sizeof(number));
    }

    /* Process TYPE parameter */
    if (VALID_TOKEN(3))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[3], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert TYPE parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((mixed_def_list[3]->def->dflm.upper <  temp) ||
          (mixed_def_list[3]->def->dflm.lower >  temp))
      {
        DS_AT_MSG0_HIGH("TYPE parameter outside range");
        return DSAT_ERROR;
      }
      sscf_ptr->type = (uint8)temp;
    }
    else
    {
      /* cm_num_fill() accounts for '+' prefix to assign type */
      sscf_ptr->type = number.number_type;
    }

    /* Encode Number */
    if (number.len)
    {
      /* Number type documented in GSM 04.08 section 10.5.4.7  */
      /* If user speficied the number type, it has precedence. */
      /* The BCD encoding routine will set final type value.   */
      number.number_type = (sscf_ptr->type & CM_TON_MASK) >> 4;
      number.number_plan = sscf_ptr->type & CM_NUM_PLAN_MASK;
      cm_util_number_to_bcd( &number, sscf_ptr->addr );
      
      /* Remove size from BCD array */ 
      sscf_ptr->alength =  sscf_ptr->addr[0];
      (void) dsatutil_memscpy((void*)&sscf_ptr->addr[0],
              CM_CALLED_PARTY_BCD_NO_LENGTH,(void*)&sscf_ptr->addr[1],
              MIN(CM_CALLED_PARTY_BCD_NO_LENGTH - 1,sscf_ptr->alength));
      if( sscf_ptr->alength < CM_CALLED_PARTY_BCD_NO_LENGTH )
      {
        sscf_ptr->addr[sscf_ptr->alength] = '\0';
      }
      else
      {
        sscf_ptr->addr[CM_CALLED_PARTY_BCD_NO_LENGTH - 1] = '\0';
      }
    }
        
    /* Process SATYPE parameter */
    if (VALID_TOKEN(6))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[6], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert SATYPE parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((mixed_def_list[6]->def->dflm.upper <  temp) ||
          (mixed_def_list[6]->def->dflm.lower >  temp))
      {
        DS_AT_MSG0_HIGH("SATYPE parameter outside range");
        return DSAT_ERROR;
      }
      sscf_ptr->satype = (uint8)temp;
    }
    else
    {
      sscf_ptr->satype = 0x80; /* see SUBADDRESS_NSAP in mn_cm_exp.h */
    }

     /* Validate SUBADDR parameter */
    if (VALID_TOKEN(5))
    {
      /* Test length */
      if (mixed_def_list[5]->def->string_len <
          strlen((char*)tok_ptr->arg[5]))
      {
        DS_AT_MSG0_HIGH("SUBADDR parameter too long");
        return DSAT_ERROR;
      }

      /* Strip quotes if present */
      if ('"' == *tok_ptr->arg[5])
      {
        if (!dsatutil_strip_quotes_out(
               tok_ptr->arg[5], tok_ptr->arg[5],
               mixed_def_list[5]->def->string_len))
        {
          DS_AT_MSG0_HIGH("Quote stripping failed");
          return DSAT_ERROR;
        }
      }
      
      /* Encode SubAddress and SaType */
      etsicall_encode_subaddr(tok_ptr->arg[5], sscf_ptr->satype,
                              sscf_ptr->subaddr, &length);
      if (0 == length)
      {
        DS_AT_MSG0_HIGH("Cannot encode SubAddress parameter");
        return DSAT_ERROR;
      }
    }
      
    /* Initiate CM command */
    result = dsatetsicmif_sups_class_action (TRUE, dsat_get_current_subs_id(FALSE));
  }

  /*--------------------------------------
  Processing for a TEST command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    byte buffer[((uint8)DSAT_CCFC_REASON_MAX*2)];
    byte * s_ptr = buffer;
    uint8 i = 0;

    ccfc_reason_e_type ccfc_reason_list[DSAT_CCFC_REASON_MAX] =
    {
      DSAT_CCFC_REASON_UNCOND,
      DSAT_CCFC_REASON_BUSY,
      DSAT_CCFC_REASON_NOREPLY,
      DSAT_CCFC_REASON_NOTREACH,
      DSAT_CCFC_REASON_ALLCALL,
      DSAT_CCFC_REASON_ALLCOND
    };

    /* Generate reason list */
    while (i < (uint8)DSAT_CCFC_REASON_MAX)
    {
      *s_ptr++ = (byte)ccfc_reason_list[i] + '0';
      *s_ptr++ = ',';
      i++;
    }
    /* Replace last comma */
    *--s_ptr = '\0';

    res_buff_ptr->used = (word) snprintf ((char*)res_buff_ptr->data_ptr,
                                                res_buff_ptr->size,
                                                "%s: (%s)",
                                                parse_table->name, 
                                                buffer);
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_ccfc_cmd */

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CTFR_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CTFR command, which controls the call deflection (call Transfer)
  supplementary service acording to 3GPP TS 22.072 [30]

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_CMD_ERR_RSP : Sending CME error code
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_ctfr_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type      result = DSAT_OK;
  cm_call_sups_type_e_type   sups_cmd;
  cm_call_sups_params_s_type sups_params;
  sys_modem_as_id_e_type     subs_id = dsat_get_current_subs_id(FALSE);
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);
  if (tok_ptr->op == (NA|EQ|AR))
  {
  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
    cm_num_s_type number;
    byte length = 0;
    dsat_num_item_type temp;
    mixed_def_s_type ** mixed_def_list = 
      (mixed_def_s_type **) parse_table->def_lim_ptr;

    memset( &sups_params, 
              CM_CALL_CMD_PARAM_DEFAULT_VALUE, 
              sizeof(cm_call_sups_params_s_type) );
    /* Initialize data structure */
    memset(&number, 0, sizeof(number));
        
    /* Validate NUMBER parameter */
    if (VALID_TOKEN(0))
    {
      const byte *digit = tok_ptr->arg[0];

      /* Test length */
      if (mixed_def_list[0]->def->string_len <
          strlen((char*)tok_ptr->arg[0]))
      {
        DS_AT_MSG0_HIGH("NUMBER parameter too long");
        return DSAT_ERROR;
      }

      /* Strip quotes if present */
      if ('"' == *tok_ptr->arg[0])
      {
        if (!dsatutil_strip_quotes_out(
               tok_ptr->arg[0], tok_ptr->arg[0],
               mixed_def_list[0]->def->string_len))
        {
          DS_AT_MSG0_HIGH("Quote stripping failed");
          return DSAT_ERROR;
        }
      }

      /* cm_num_fill does nothing to verify number */
      if ('+' == *digit)
      {
        digit++;
      }
      /* per GSM 04.08, table 10.81 */
      while (*digit)
      {
        if ( ((*digit < '0') || (*digit > '9')) &&
             (*digit != '*') && (*digit != '#') && 
             (*digit != 'a') && (*digit != 'b') && (*digit != 'c') )
        {
          return DSAT_ERROR;
        }       
        digit++;
      } 

      /* Format number structure, accounting for '+' prefix. */
      /* '+' is stripped if detected.                        */
      cm_num_fill(&number, (byte *)tok_ptr->arg[0],
                  (byte)strlen((char*)tok_ptr->arg[0]),
                  CM_DIGIT_MODE_8BIT_ASCII);
    }
    else
    {
      /* Clear number structure */
      memset(&number, 0, sizeof(number));
      return DSAT_ERROR;
    }

    /* Process TYPE parameter */
    if (VALID_TOKEN(1))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[1], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert TYPE parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((mixed_def_list[1]->def->dflm.upper <  temp) ||
          (mixed_def_list[1]->def->dflm.lower >  temp))
      {
        DS_AT_MSG0_HIGH("TYPE parameter outside range");
        return DSAT_ERROR;
      }
      number.number_type = (uint8)temp;
    }
    else
    {
      if (number.buf[0] == '+' )
      {
        number.number_type = INTERNATIONAL_TON_ISDN_NPI;
      }
      else
      {
        number.number_type = UNKNOWN_TON_ISDN_NPI;
      }
    }

    if (number.len)
    {
      /* Number type documented in GSM 04.08 section 10.5.4.7  */
      /* If user speficied the number type, it has precedence. */
      /* The BCD encoding routine will set final type value.   */

      number.number_plan = number.number_type & CM_NUM_PLAN_MASK;
      number.number_type = (number.number_type & CM_TON_MASK) >> 4;
    }
        
    /* Process SATYPE parameter */
    if (VALID_TOKEN(3))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[3], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert SATYPE parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((mixed_def_list[3]->def->dflm.upper <  temp) ||
          (mixed_def_list[3]->def->dflm.lower >  temp))
      {
        DS_AT_MSG0_HIGH("SATYPE parameter outside range");
        return DSAT_ERROR;
      }
      number.subaddr.subadd_type = (uint8)temp;
    }
    else
    {
      number.subaddr.subadd_type = SUBADDRESS_NSAP; /* see SUBADDRESS_NSAP in mn_cm_exp.h */
    }

     /* Validate SUBADDR parameter */
    if (VALID_TOKEN(2))
    {
      /* Test length */
      if (mixed_def_list[2]->def->string_len <
          strlen((char*)tok_ptr->arg[2]))
      {
        DS_AT_MSG0_HIGH("SUBADDR parameter too long");
        return DSAT_ERROR;
      }

      /* Strip quotes if present */
      if ('"' == *tok_ptr->arg[2])
      {
        if (!dsatutil_strip_quotes_out(
               tok_ptr->arg[2], tok_ptr->arg[2],
               mixed_def_list[2]->def->string_len))
        {
          DS_AT_MSG0_HIGH("Quote stripping failed");
          return DSAT_ERROR;
        }
      }
      
      /* Encode SubAddress and SaType */
      etsicall_encode_subaddr(tok_ptr->arg[2], number.subaddr.subadd_type,
                              number.subaddr.chari, &length);
      if (0 == length)
      {
        DS_AT_MSG0_HIGH("Cannot encode SubAddress parameter");
        return DSAT_ERROR;
      }
    }
      
    sups_cmd=CM_CALL_SUPS_TYPE_CALL_DEFLECTION;

    /* Make CM call */
    etsicall_cmd_pending[subs_id] = ((etsicall_cmd_type)sups_cmd );

    /* Keep track of waiting call at time command was issued */
    sups_params.call_id = call_da_val->etsicall_wait_call_id;
    sups_params.sups_number = number;
    /* an incoming alerting call to be forwarded to a specified number */
    if(call_da_val->etsicall_wait_call_present)
    {
#ifdef FEATURE_DUAL_SIM
      if ( !cm_mm_call_cmd_sups_per_subs( dsatcmif_call_cmd_cb_func,
                                 NULL,
                                 dsatcm_client_id,
                                 sups_cmd,
                                 &sups_params,
                                 subs_id) )
      {
        /* CM couldn't alloc cmd buffer */
        etsicall_cmd_pending[subs_id] = CMD_NONE;
        dsatme_set_cme_error(DSAT_CME_MEMORY_FAILURE, res_buff_ptr);
        result = DSAT_CMD_ERR_RSP;
      }

#else
      if ( !cm_mm_call_cmd_sups( dsatcmif_call_cmd_cb_func,
                                 NULL,
                                 dsatcm_client_id,
                                 sups_cmd,
                                 &sups_params) )
      {
        /* CM couldn't alloc cmd buffer */
        etsicall_cmd_pending[subs_id] = CMD_NONE;
        dsatme_set_cme_error(DSAT_CME_MEMORY_FAILURE, res_buff_ptr);
        result = DSAT_CMD_ERR_RSP;
      }
#endif /* FEATURE_DUAL_SIM */
    }
    else
    {
      result = dsat_send_cme_error(DSAT_CME_OP_NOT_ALLOWED);
    }
  }
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    /*--------------------------------------
    Processing for a TEST command:
    ----------------------------------------*/

    /* Nothing to do as per Spec TS 27.007 */
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_ctfr_cmd */

#ifdef FEATURE_DSAT_ETSI_MODE
#ifdef FEATURE_WCDMA_L1_HS_CQI_STAT
/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CQI_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CQI command, which reports the Channel Quality Indicator.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cqi_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsatcmif_servs_state_ss_info  *ph_ss_val = NULL;
  
  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
   Processing for TEST command 
  -----------------------------------------------------------*/
  if ((tok_ptr->op == (NA|EQ|AR)) ||
      (tok_ptr->op == (NA|EQ|QU)) ||
      (tok_ptr->op == (NA)))
  {
    result = dsatparm_exec_param_cmd(
                                     mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr
                                    );
    
  }
  /*--------------------------------------
  Processing for a READ command
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|QU) )
  {
    ph_ss_val = dsat_get_base_addr(DSAT_SS_PH_SS_VALS, FALSE);

    res_buff_ptr->used =
      (word)snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                            "%s: %d,%d,%d",
                            parse_table->name,
                            *(dsat_num_item_type*)parse_table->val_ptr,
                            ph_ss_val->dsat_cqi_info.gw_cqi,
                            ph_ss_val->dsat_cqi_info.num_cqi_samples);
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_cqi_cmd */

/*===========================================================================

FUNCTION DSATETSICALL_REPORT_CQI_RESULT

DESCRIPTION
  This function generates the unsolicited result code for +CQI command.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_report_cqi_result ( void )
{
  dsm_item_type * res_buff_ptr = NULL;
  /* Report CS domain (+CREG) response */
  dsatcmif_servs_state_ss_info  *ph_ss_val = NULL;
  ph_ss_val = dsat_get_base_addr(DSAT_SS_PH_SS_VALS, FALSE);

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
  if (NULL != res_buff_ptr)
  {
    res_buff_ptr->used =
      (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                            "+CQI: %d,%d",
                            ph_ss_val->dsat_cqi_info.gw_cqi,
                            ph_ss_val->dsat_cqi_info.num_cqi_samples);

    /* Send response to TE */
    dsatcmdp_send_urc(res_buff_ptr, DSAT_COMPLETE_RSP);
  }
} /* dsatetsicall_report_cqi_result */
#endif /* FEATURE_WCDMA_L1_HS_CQI_STAT  */
#endif /* FEATURE_DSAT_ETSI_MODE */

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CLCK_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CLCK command, which controls the facility lock
  supplementary service acording to 3GPP TS 22.088

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was an problem in executing the command
    DSAT_CMD_ERR_RSP : if there was a problem during aynchronous execution
    DSAT_ASYNC_CMD : if aynchronous command continues successfully
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_clck_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type            result = DSAT_ASYNC_EVENT;
  mmgsdi_return_enum_type          mmgsdi_status;
  mmgsdi_data_type                 pin_data;
  dsatetsicmif_sups_state_ms_info *sups_ms_val = NULL;
  dsat_apps_id_e_type              apps_id = dsat_get_current_gw_apps_id(FALSE);
  mmgsdi_session_id_type           session_id = dsat_get_current_gw_session_id(FALSE);
  simlock_set_lock_ck_msg_req_type req_data;
  dsat_perso_user_type             user_data;

  sups_ms_val = dsat_get_base_addr_current_subs(DSAT_SUPS_MS_VALS);

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
  if (tok_ptr->op == (NA|EQ|AR))
  {
    ss_fl_user_s_type * ssfl_ptr = &sups_ms_val->dsat_ss_cm_data.user_data.opdata.fac_lock;
    dsat_num_item_type temp;
    byte  max_pw_len = 0;
    mixed_def_s_type ** mixed_def_list = 
      (mixed_def_s_type **) parse_table->def_lim_ptr;

    /* Define list of facilities which are restriced to unlock mode, */
    /* as listed in dsat_clck_fac_valstr[] */
    const dsat_string_item_type unlock_only_facs[4][8] =
          { "\"AB\"", "\"AG\"", "\"AC\"", "" };
    
#ifdef FEATURE_DATA_ETSI_PIN
    /* Define list of PIN oriented facilities, as listed in */
    /* dsat_clck_fac_valstr[] */
    const dsat_string_item_type pin_facs[3][8] = { "\"SC\"", "\"FD\"", "" };
    boolean isFDN = FALSE; /* If the request is for FD phone book" */
#ifdef FEATURE_MMGSDI_PERSONALIZATION
    /* Personalization facilities. */
    const dsat_string_item_type
      perso_facs[6][8] = { "\"PN\"", "\"PU\"", "\"PP\"", "\"PC\"", "\"PF\"",
                          "" };
#endif /* FEATURE_MMGSDI_PERSONALIZATION */
    enum { REST_FAC = 0, PIN_FAC, PERSO_FAC } pin_fac = REST_FAC;
#endif /* FEATURE_DATA_ETSI_PIN */
    
    /* Initialize data structure */
    memset (&sups_ms_val->dsat_ss_cm_data.user_data, 0, sizeof(ss_user_data_s_type));
    sups_ms_val->dsat_ss_cm_data.user_data.operation = DSAT_SSOP_FACILITY;
    memset (&req_data, 0, sizeof(simlock_set_lock_ck_msg_req_type));
      
    /* Validate MODE parameter  (no default) */
    if (VALID_TOKEN(1))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[1], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert MODE parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((dsat_num_item_type)DSAT_CLCK_MODE_MAX <= temp)
      {
        DS_AT_MSG0_HIGH("MODE parameter outside range");
        return DSAT_ERROR;
      }
      ssfl_ptr->mode = (clck_mode_e_type)temp;
    }
    else
    {
      DS_AT_MSG0_HIGH("+CLCK MODE parameter mandatory");
      return DSAT_ERROR;
    }

    /* Validate FACILITY parameter  (no default) */
    if (VALID_TOKEN(0))
    {
      /* Search for token in valid list */
      if (PARAM_HIT != dsatutil_srch_list (
                         &temp, 
                         dsat_clck_fac_valstr,
                         tok_ptr->arg[0],
                         ACTION_QUOTE_NO_QUOTE ))
      {
        DS_AT_MSG0_HIGH("Token not in FACILITY list");
        return DSAT_ERROR;
      }
      /* Store position in list */ 
      ssfl_ptr->facility = (ss_fac_e_type)temp;

      /* Ensure ALL facilities used only in unlock mode */
      if ((DSAT_CLCK_MODE_UNLOCK != ssfl_ptr->mode) &&
          (PARAM_HIT == dsatutil_srch_list (
                         &temp,
                         unlock_only_facs,
                         tok_ptr->arg[0],
                         ACTION_QUOTE_NO_QUOTE )))
      {
        DS_AT_MSG0_HIGH("FACILITY not allowed in specified mode");
        return DSAT_ERROR;
      }

#ifdef FEATURE_DATA_ETSI_PIN
      /* Search for token in PIN list and set flag */
      if (PARAM_HIT == dsatutil_srch_list (
                         &temp, 
                         pin_facs,
                         tok_ptr->arg[0],
                         ACTION_QUOTE_NO_QUOTE ))
      {
        pin_fac = PIN_FAC;
        max_pw_len =  MMGSDI_PIN_MAX_LEN;
      }
#ifdef FEATURE_MMGSDI_PERSONALIZATION
      else if (PARAM_HIT == dsatutil_srch_list (
                         &temp, 
                         perso_facs,
                         tok_ptr->arg[0],
                         ACTION_QUOTE_NO_QUOTE ))
      {
        pin_fac = PERSO_FAC;
        max_pw_len =  MMGSDI_PIN_MAX_LEN;
        ssfl_ptr->facility = (ss_fac_e_type)temp;
      }
#endif /* FEATURE_MMGSDI_PERSONALIZATION */
      else {
        /* Network PIN */
        max_pw_len = MAX_PWD_CHAR;
      }
#endif /* FEATURE_DATA_ETSI_PIN */

    }

    /* Validate PASSWORD parameter  (no default) */
    if (VALID_TOKEN(2))
    {
      /* Test string length */
      temp = (dsat_num_item_type)strlen((char*)tok_ptr->arg[2]);
      if ((dsat_num_item_type)(max_pw_len+2) < temp)
      {
        DS_AT_MSG0_HIGH("Password string too long");
        return DSAT_ERROR;
      }
      /* Strip quotes */
      if (!dsatutil_strip_quotes_out(tok_ptr->arg[2],
                                     ssfl_ptr->passwd,
                                     (word)temp))
      {
        DS_AT_MSG0_HIGH("Problem stripping quotes");
        return DSAT_ERROR;
      }
      /* Clear password */
      dsatutil_reset_password (tok_ptr->arg[2], (word)temp+1);
    }
    
    /* Validate CLASS parameter  (default available) */
    if (VALID_TOKEN(3))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[3], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert CLASS parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((mixed_def_list[3]->def->dflm.upper <  temp) &&
          (mixed_def_list[3]->def->dflm.lower >  temp))
      {
        DS_AT_MSG0_HIGH("MODE parameter outside range");
        return DSAT_ERROR;
      }

      /* See if class in Basice Service Group lookup table */
      if ((dsat_clck_allowed_classes != (dsat_clck_allowed_classes | temp)) &&
          ((dsat_num_item_type)DSAT_SS_CLASS_ALL != temp))
      {
        DS_AT_MSG0_HIGH("Class not mapped to Basic Service Group");
        return DSAT_ERROR;
      }
      
      sups_ms_val->dsat_ss_cm_data.user_data.class = (uint8)temp;
    }
    else
    {
      /* Default */
      sups_ms_val->dsat_ss_cm_data.user_data.class =
        (uint8)mixed_def_list[3]->def->dflm.default_v;
    }

    pin_data.data_ptr = (uint8 *)(char *)ssfl_ptr->passwd;
    pin_data.data_len = (mmgsdi_len_type)strlen((char *)ssfl_ptr->passwd);

#ifdef FEATURE_DATA_ETSI_PIN
    switch (pin_fac)
    {
      case PIN_FAC:
        isFDN = ( (0 == strcmp((char *)tok_ptr->arg[0], "\"FD\""))||
                  (0 == strcmp((char *)tok_ptr->arg[0], "\"fd\"")) );

        /* Initiate GSDI call */
        switch (ssfl_ptr->mode)
        {
          case DSAT_CLCK_MODE_LOCK:
            if (isFDN) 
            { /* Operation is for FD phone book */
              VERIFY_PIN( session_id,
                      MMGSDI_PIN2, 
                      pin_data, 
                      CLCK_MMGSDI_FDN_LOCK );
              if(MMGSDI_SUCCESS == mmgsdi_status)
              {
                result = DSAT_ASYNC_CMD; 
              }
              else 
              { 
                result = DSAT_ERROR; 
              }
            }
            else 
            { /* Operation is for SC */
#ifdef FEATURE_MMGSDI
              result = dsatetsime_set_pin_status(MMGSDI_PIN1, TRUE,
                                                 ssfl_ptr->passwd, apps_id);
#else 
              #error code not present
#endif /* FEATURE_MMGSDI */
            }
            break;
          case DSAT_CLCK_MODE_UNLOCK:
            if (isFDN) 
            { /* Operation is for FD phone book */
              VERIFY_PIN( session_id,
                      MMGSDI_PIN2, 
                      pin_data, 
                      CLCK_MMGSDI_FDN_UNLOCK );

              if(MMGSDI_SUCCESS == mmgsdi_status) 
              {
                result = DSAT_ASYNC_CMD; 
              }
              else 
              { 
                result = DSAT_ERROR; 
              }
            }
            else 
            { /* Operation is for SC */
              result = dsatetsime_set_pin_status(MMGSDI_PIN1, FALSE,
                                                 ssfl_ptr->passwd, apps_id);
            }
            break;
          case DSAT_CLCK_MODE_QUERY:
            if (isFDN) 
            { /* Operation is for FD phone book */
              if (MMGSDI_SUCCESS == mmgsdi_session_get_app_capabilities(
                                            session_id,
                                            dsatme_mmgsdi_perso_req_cb,
                                            (uint32)CLCK_MMGSDI_FDN_QUERY))
              {
                result = DSAT_ASYNC_CMD;
              }
              else 
              {
                DS_AT_MSG0_ERROR("SIM capabilities returned failure ");
                dsatme_set_cme_error(DSAT_CME_SIM_FAILURE, res_buff_ptr);
                return DSAT_CMD_ERR_RSP;
              }
            }
            else 
            { /* Operation is for SC */
              result = dsatetsime_get_pin_status(MMGSDI_PIN1);
            }
            break;
          default:
            DS_AT_MSG0_ERROR("Unsupported MODE parameter");
            return DSAT_ERROR;
        }

        /* Clear password */
        dsatutil_reset_password (ssfl_ptr->passwd,
            sizeof(ssfl_ptr->passwd));

        break;

#ifndef FEATURE_DSAT_LEGACY_GCF_SUPPORT
#ifdef FEATURE_MMGSDI_PERSONALIZATION
      case PERSO_FAC:
        {
          if((DSAT_CLCK_MODE_LOCK == ssfl_ptr->mode) ||
             (DSAT_CLCK_MODE_UNLOCK == ssfl_ptr->mode))
          {
            req_data.ck.simlock_ck_length=
              (uint8)strlen((char*)ssfl_ptr->passwd);
            dsatutil_memscpy(req_data.ck.simlock_ck_data,SIMLOCK_CK_MAX,
                  ssfl_ptr->passwd,req_data.ck.simlock_ck_length);
          }
          switch (dsat_get_current_slot_id())
          {
            case MMGSDI_SLOT_1:
              req_data.slot = SIMLOCK_SLOT_1;
              break;
            case MMGSDI_SLOT_2:
              req_data.slot = SIMLOCK_SLOT_2;
              break;
            case MMGSDI_SLOT_3:
              req_data.slot = SIMLOCK_SLOT_3;
              break;
            default:
              return DSAT_ERROR;
              break;
          }
          user_data.slot = req_data.slot;
          
          switch((clck_perso_fac_e_type)ssfl_ptr->facility)
          {
            case DSAT_MMGSDI_PERSO_FAC_PN:
              req_data.category.category_type = SIMLOCK_CATEGORY_3GPP_NW;
              break;
            case DSAT_MMGSDI_PERSO_FAC_PU:
              req_data.category.category_type = SIMLOCK_CATEGORY_3GPP_NS;
              break;
            case DSAT_MMGSDI_PERSO_FAC_PP:
              req_data.category.category_type = SIMLOCK_CATEGORY_3GPP_SP;
              break;
            case DSAT_MMGSDI_PERSO_FAC_PC:
              req_data.category.category_type = SIMLOCK_CATEGORY_3GPP_CP;
              break;
            case DSAT_MMGSDI_PERSO_FAC_PF:
              req_data.category.category_type = SIMLOCK_CATEGORY_3GPP_SIM;
              break;
            default:
              DS_AT_MSG0_HIGH("Invalid facility");
              return DSAT_ERROR;
              break;
          }
          req_data.auto_lock = TRUE; /* Indicates the lock codes are taken from the first SIM card that is inserted */
          req_data.blacklist = FALSE; /* Should be false when autolock is true */
          req_data.num_retries_max = 10;
          req_data.iteration_cnt = 10000;
          
          if( DSAT_CLCK_MODE_LOCK == ssfl_ptr->mode)
          {
            user_data.session_id = session_id;
            user_data.perso_cmd = CPIN_MMGSDI_PERSO_ACT;
            if(SIMLOCK_SUCCESS != simlock_ck_lock(req_data,dsatme_sim_mmgsdi_perso_req_cb,&user_data))
            {
              result = DSAT_ERROR;
            } else {
              /* Flag that the PIN state is being changed */
              dsatme_pending_mmgsdi_command[apps_id] = TRUE;
              result = DSAT_ASYNC_CMD;
            }
          } else if(DSAT_CLCK_MODE_UNLOCK == ssfl_ptr->mode)
          {
            simlock_unlock_device_msg_req_type req_data_unlock;
            req_data_unlock.slot = req_data.slot;

            req_data_unlock.category = req_data.category.category_type;
            req_data_unlock.ck.simlock_ck_length=
              (uint8)strlen((char*)ssfl_ptr->passwd);
            dsatutil_memscpy(req_data_unlock.ck.simlock_ck_data,SIMLOCK_CK_MAX,
                  ssfl_ptr->passwd,req_data_unlock.ck.simlock_ck_length);
            user_data.session_id = session_id;
            user_data.perso_cmd = CPIN_MMGSDI_PERSO_DEACT;
            if(SIMLOCK_SUCCESS != simlock_unlock(req_data_unlock,dsatme_sim_mmgsdi_perso_req_cb,&user_data))
            {
              result = DSAT_ERROR;
            } else {
                    dsatme_pending_mmgsdi_command[apps_id] = TRUE;
                    result = DSAT_ASYNC_CMD;
            }
          } else if(DSAT_CLCK_MODE_QUERY == ssfl_ptr->mode)
          {
            clck_perso_fac = (clck_perso_fac_e_type)ssfl_ptr->facility;
            user_data.session_id = session_id;
            user_data.perso_cmd = CPIN_MMGSDI_PERSO_GET_IND_RSP;
            if(SIMLOCK_SUCCESS != simlock_get_status(dsatme_sim_mmgsdi_perso_req_cb,&user_data))
            {
              result = DSAT_ERROR;
            } else {
              dsatme_pending_mmgsdi_command[apps_id] = TRUE;
              result = DSAT_ASYNC_CMD;
            }
          } else {
              DS_AT_MSG0_ERROR("Unsupported MODE parameter");
              return DSAT_ERROR;
          }
        }
        break;
#endif /* FEATURE_MMGSDI_PERSONALIZATION */
#endif /* FEATURE_DSAT_LEGACY_GCF_SUPPORT */

      default:
#endif /* FEATURE_DATA_ETSI_PIN */
        {
          /* Initiate CM command */
          result = dsatetsicmif_sups_class_action (TRUE,dsat_get_current_subs_id(FALSE));
        }
#ifdef FEATURE_DATA_ETSI_PIN
    }
#endif /* FEATURE_DATA_ETSI_PIN */
  }

  /*--------------------------------------
  Processing for a TEST command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    res_buff_ptr->used = (word) snprintf ((char*)res_buff_ptr->data_ptr,
                                                res_buff_ptr->size,
                                                "%s: %s",
                                                parse_table->name, 
                                                dsat_clck_fac_tststr);
    result = DSAT_OK;
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_clck_cmd */

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CPWD_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CPWD command, which sets new passwords for facility lock
  supplementary service.

  Facility PIN values are restricted to four digits in range 0-9 per 
  3GPP TS 22.004 section 5.2.  SIM PIN values may be 4 to 8 digits in 
  range 0-9 per 3GPP TS 11.11 section 9.3.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_ASYNC_CMD : if aynchronous command continues successfully
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cpwd_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_ASYNC_EVENT;
  dsatetsicmif_sups_state_ms_info  *sups_ms_val = NULL;

  sups_ms_val = dsat_get_base_addr_current_subs(DSAT_SUPS_MS_VALS);

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
  if (tok_ptr->op == (NA|EQ|AR))
  {
    ss_fl_user_s_type * ssfl_ptr = &sups_ms_val->dsat_ss_cm_data.user_data.opdata.fac_lock;
    dsat_num_item_type temp = 0;
    byte  min_pw_len = 0;
    byte  max_pw_len = 0;

#ifdef FEATURE_DATA_ETSI_PIN
    /* Define list of PIN oriented facilities, as listed in */
    /* dsat_cpwd_fac_valstr[] */
    const dsat_string_item_type pin_facs[3][8] = { "\"SC\"", "\"P2\"", "" };
    /* MMGSDI PIN identifiers in same order as above */
    const mmgsdi_pin_enum_type pin_ids[] = {MMGSDI_PIN1, MMGSDI_PIN2};
    mmgsdi_pin_enum_type  pin_id = MMGSDI_MAX_PIN_ENUM;
    boolean pin_fac = FALSE;
#endif /* FEATURE_DATA_ETSI_PIN */
    
    /* WRITE command should have 3 Mandatory Arguments */
    if( tok_ptr->args_found != 3 )
    {
      DS_AT_MSG0_ERROR("Invalid no of Arguments in +CPWD Command");
      return DSAT_ERROR;
    }
    /* Initialize data structure */
    memset (&sups_ms_val->dsat_ss_cm_data.user_data, 0, sizeof(ss_user_data_s_type));
    sups_ms_val->dsat_ss_cm_data.user_data.operation = DSAT_SSOP_FACILITY;
      
    /* Validate FACILITY parameter  (no default) */
    if (VALID_TOKEN(0))
    {
      /* Search for token in valid list */
      if (PARAM_HIT != dsatutil_srch_list (
                         &temp, 
                         dsat_cpwd_fac_valstr,
                         tok_ptr->arg[0],
                         ACTION_QUOTE_NO_QUOTE ))
      {
        DS_AT_MSG0_HIGH("Token not in FACILITY list");
        return DSAT_ERROR;
      }
      /* Store position in list */ 
      ssfl_ptr->facility = (ss_fac_e_type)temp;

#ifdef FEATURE_DATA_ETSI_PIN
      /* Search for token in PIN list and set flag */
      if (PARAM_HIT == dsatutil_srch_list (
                         &temp, 
                         pin_facs,
                         tok_ptr->arg[0],
                         ACTION_QUOTE_NO_QUOTE ))
      {
        pin_fac = TRUE;
        pin_id = pin_ids[temp];
        min_pw_len =  MMGSDI_PIN_MIN_LEN;
        max_pw_len =  MMGSDI_PIN_MAX_LEN;
      }
      else
#endif /* FEATURE_DATA_ETSI_PIN */
      {
        /* Network Facility PIN */
        min_pw_len = MAX_PWD_CHAR;
        max_pw_len = MAX_PWD_CHAR;
      }
    }

    /* Validate old PASSWORD parameter  (no default) */
    if (VALID_TOKEN(1))
    {
      /* Strip quotes */
      if ('"' == tok_ptr->arg[1][0])
      {
        if (!dsatutil_strip_quotes_out(tok_ptr->arg[1],
                                       tok_ptr->arg[1],
                                       (word)strlen((char*)tok_ptr->arg[1])))
        {
          DS_AT_MSG0_HIGH("Problem stripping quotes");
          return DSAT_ERROR;
        }
      }
      
      /* Test string length */
      temp = (dsat_num_item_type)strlen((char*)tok_ptr->arg[1]);
      if ( (max_pw_len < temp) || (temp < min_pw_len) )
      {
        DS_AT_MSG1_ERROR("Incorrect OLD Password Length %d",temp);
        return DSAT_ERROR;
      }
      else
      {
        (void)strlcpy ((char*)ssfl_ptr->passwd,
                       (char*)tok_ptr->arg[1], max_pw_len+1);
      }

      /* Clear password */
      dsatutil_reset_password (tok_ptr->arg[1],
                               (word)strlen((char*)tok_ptr->arg[1])+1);
    }
    
    /* Validate new PASSWORD parameter  (no default) */
    if (VALID_TOKEN(2))
    {
      byte * c_ptr;
        
      /* Strip quotes */
      if ('"' == tok_ptr->arg[2][0])
      {
        if (!dsatutil_strip_quotes_out(tok_ptr->arg[2],
                                       tok_ptr->arg[2],
                                       (word)strlen((char*)tok_ptr->arg[2])))
        {
          DS_AT_MSG0_HIGH("Problem stripping quotes");
          return DSAT_ERROR;
        }
      }
      
      temp = (dsat_num_item_type)strlen((char*)tok_ptr->arg[2]);
      if ( (max_pw_len < temp) || (temp < min_pw_len) )
      {
        DS_AT_MSG1_ERROR("Incorrect NEW Password Length %d",temp);
        return DSAT_ERROR;
      }
      else
      {
        (void)strlcpy ((char*)ssfl_ptr->new_passwd,
                           (char*)tok_ptr->arg[2], max_pw_len+1);
      }

      /* Clear password */
      dsatutil_reset_password (tok_ptr->arg[2],
                               (word)strlen((char*)tok_ptr->arg[2])+1);

      
      /* Test string length */
      temp = (dsat_num_item_type)strlen((char*)ssfl_ptr->new_passwd);
      if ((max_pw_len < temp) || (min_pw_len > temp))
      {
        DS_AT_MSG3_HIGH("PIN string outside length bounds [%d-%d]: %d",
                  min_pw_len, max_pw_len, temp);
        return DSAT_ERROR;
      }
      
      /* Verify allowed digits */
      c_ptr = ssfl_ptr->new_passwd;
      while ( '\0' != *c_ptr )
      {
        /* Report error if char not numeric */
        if (!(('0' <= *c_ptr) && ('9' >= *c_ptr)))
        { 
          DS_AT_MSG1_HIGH("PIN char outside range [0-9]: %c",*c_ptr);
          return DSAT_ERROR;
        }
        c_ptr++;
      }
    }

#ifdef FEATURE_DATA_ETSI_PIN
    if (pin_fac)
    {
      /* Prevent null passwords */
      if ('\0' == *ssfl_ptr->new_passwd)
      {
        DS_AT_MSG0_MED("Null PIN password prohibited");
        dsatme_set_cme_error(DSAT_CME_INCORRECT_PASSWORD, res_buff_ptr);
        return DSAT_CMD_ERR_RSP;
      }
      
      /* Initiate GSDI PIN change */
      result = dsatetsime_change_pin (pin_id,
                                      ssfl_ptr->passwd,
                                      ssfl_ptr->new_passwd);
      /* Clear passwords */
      dsatutil_reset_password (ssfl_ptr->passwd,
                               sizeof(ssfl_ptr->passwd));
      dsatutil_reset_password (ssfl_ptr->new_passwd,
                               sizeof(ssfl_ptr->new_passwd));
    }
    else
#endif /* FEATURE_DATA_ETSI_PIN */
    {
      /* Initiate CM command */
      result = dsatetsicmif_sups_change_password();
    }
  }

  /*--------------------------------------
  Processing for a TEST command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    const struct cpwd_tst_entry
    {
      dsat_string_item_type fac[5];
      dsat_num_item_type len;
    } cpwd_tst_table[] =
    {
      { "\"AB\"",  MAX_PWD_CHAR},
      { "\"AC\"",  MAX_PWD_CHAR},
      { "\"AG\"",  MAX_PWD_CHAR},
      { "\"AI\"",  MAX_PWD_CHAR},
      { "\"AO\"",  MAX_PWD_CHAR},
      { "\"IR\"",  MAX_PWD_CHAR},
      { "\"OI\"",  MAX_PWD_CHAR},
      { "\"OX\"",  MAX_PWD_CHAR},
#ifdef FEATURE_DATA_ETSI_PIN
      { "\"SC\"",  MMGSDI_PIN_MAX_LEN},
      { "\"P2\"",  MMGSDI_PIN_MAX_LEN},
#endif /* FEATURE_DATA_ETSI_PIN */
      { "",        0}
    };
    byte i = 0;

    res_buff_ptr->used = (word) snprintf ((char*)res_buff_ptr->data_ptr,
                                                res_buff_ptr->size,
                                                "%s: ",
                                                parse_table->name);

    while ('\0' != cpwd_tst_table[i].fac[0])
    {
      res_buff_ptr->used = (word) snprintf ((char*)res_buff_ptr->data_ptr,
                                                  res_buff_ptr->size,
                                                  "%s(%s,%d),",
                                                  res_buff_ptr->data_ptr,
                                                  cpwd_tst_table[i].fac,
                                                  cpwd_tst_table[i].len);
      i++;
    }
    /* Overwrite last comma */
    res_buff_ptr->data_ptr[--res_buff_ptr->used] = '\0';
    result = DSAT_OK;
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_cpwd_cmd */



/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CUSD_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CUSD command, which allows control of Unstructured
  Supplementary Service Data (USSD).

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_ASYNC_CMD : if aynchronous command continues successfully
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cusd_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
#define MAX_DCS_LIMIT 255
  dsat_result_enum_type result = DSAT_OK;
  dsat_num_item_type cscs_val ;
  dsatetsicmif_sups_state_ms_info  *sups_ms_val = NULL;
  
  sups_ms_val = dsat_get_base_addr_current_subs(DSAT_SUPS_MS_VALS);

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
  if (tok_ptr->op == (NA|EQ|AR) ||
      tok_ptr->op == NA)
  {
    ss_us_user_s_type * ssus_ptr = &sups_ms_val->dsat_ss_cm_data.user_data.opdata.ussd;
    dsat_num_item_type temp;
    dsat_num_item_type initial_n;
    dsat_mixed_param_val_type * mixed_val_list = 
      (dsat_mixed_param_val_type *) dsatutil_get_val(parse_table->cmd_id,0,0,STR_TYPE);
    

    /* Capture initial <n> setting */
    initial_n = mixed_val_list[0].num_item;

    result = dsatparm_exec_param_cmd(
                                     mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr
                                    );
    if (DSAT_OK == result)
    {
      boolean network_op = FALSE;

      /* Initialize SS data structure */
      sups_ms_val->dsat_ss_cm_data.user_data.operation = DSAT_SSOP_USSD;

      switch (mixed_val_list[0].num_item)
      {
        case 0:
        case 1:
          /* Check for USSD string present */
          if (VALID_TOKEN(1))
          {
            /* Process data string (may be empty string) */
	    if ('\0' != mixed_val_list[1].string_item[0])
	    {
	      /* Convert from TE character set, per +CSCA setting, to ME's 
		 internal chset, IRA T.50, fail on inconvertible character */
		 cscs_val =(dsat_num_item_type)dsatutil_get_val(
                                           DSATETSI_EXT_CSCS_IDX,0,0,NUM_TYPE);
	      if ( dsatutil_convert_chset( 
		     (const char *)&mixed_val_list[1].string_item[0], 
		     (dsati_chset_type)cscs_val,
		     (const char *)&mixed_val_list[1].string_item[0], 
		     ALPHA_IRA, 
		     MAX_USS_CHAR_ASCII + 1,
		     FALSE ) == NULL )
	      {
		DS_AT_MSG0_HIGH("Inconvertible chars in USSD");
		return DSAT_ERROR;
	      }
            }

            /* Preserve USSD string */
            (void)strlcpy ((char*)ssus_ptr->string,
                               (char*)mixed_val_list[1].string_item,
                               MAX_USS_CHAR_ASCII+1);
            mixed_val_list[1].string_item[0] = '\0';

            /* Determine DCS value (default 0) */
            ssus_ptr->dcs = 0;
            if (VALID_TOKEN(2))
            {
              /* Convert DCS to number */
              if (ATOI_OK !=
                  dsatutil_atoi(&temp, mixed_val_list[2].string_item, 10))
              {
                DS_AT_MSG0_HIGH("Cannot convert DCS parameter");
                return DSAT_ERROR;
              }
              /* Test for in-range */
              if (MAX_DCS_LIMIT < temp)
              {
                DS_AT_MSG0_HIGH("DCS parameter outside range");
                return DSAT_ERROR;
              }
              ssus_ptr->dcs = (uint8)temp;
            }
            mixed_val_list[2].string_item[0] = '\0';

            /* Update state machine if in NULL state */
            if (DSAT_CUSD_STATE_NULL == sups_ms_val->dsat_ss_cm_data.ussd_state)
            {
              dsatetsicmif_set_cusd_state(&(sups_ms_val->dsat_ss_cm_data), DSAT_CUSD_STATE_MS_SEND, 0);
            }
            network_op = TRUE;
          }
          break;
          
        case 2:
          /* For <n>=2, restore intial <n> */
          mixed_val_list[0].num_item = initial_n;

          /* Check to see if there is pending USSD command to abort */
          if (TRUE != sups_ms_val->dsat_ss_cm_data.pending_msg)
          {
            DS_AT_MSG0_HIGH("No USSD command pending; abort rejected");
            result = DSAT_ERROR;
          }
          else
          {
            /* Set state machine to ABORT */
            dsatetsicmif_set_cusd_state( &(sups_ms_val->dsat_ss_cm_data),DSAT_CUSD_STATE_MS_ABORT, 0);
            network_op = TRUE;
          }
          break;

        default:
          DS_AT_MSG1_ERROR("Unsupported CUSD <n> parameter: %d",
                     mixed_val_list[0].num_item);
      }

      /* Check for error condition */
      if (network_op && (DSAT_ERROR != result))
      {
        /* Start network interaction */
        result = dsatetsicmif_sups_process_ussd();
      }
    }
    else
    {
      result = DSAT_ERROR;
    }
  }

  /*--------------------------------------
  Processing for a READ command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|QU) )
  {
    if (0 == dsatetsicall_cusd_response_fmt (parse_table,
                                             &res_buff_ptr,
                                             MULTI_INDEX_READ))
    {
      DS_AT_MSG0_HIGH("Problem generating query response");
      result = DSAT_ERROR;
    }
  }

  /*--------------------------------------
  Processing for a TEST command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    if (0 == dsatetsicall_cusd_response_fmt (parse_table,
                                             &res_buff_ptr,
                                             MULTI_INDEX_TEST))
    {
      DS_AT_MSG0_HIGH("Problem generating query response");
      result = DSAT_ERROR;
    }
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_cusd_cmd */


/*===========================================================================

FUNCTION DSATETSICALL_CUSD_RESPONSE_FMT

DESCRIPTION
  This function generates the response for the +CUSD read & test
  commands.  The &V command respose is handled as well.  Data is
  extracted from data structure and formatted according to parameter flag.

DEPENDENCIES
  None

RETURN VALUE
  Returns number of characters in response buffer.

SIDE EFFECTS
  None

===========================================================================*/
dsat_num_item_type dsatetsicall_cusd_response_fmt
(
  const dsati_cmd_type   *parse_table,    /*  Ptr to cmd in parse table   */
  dsm_item_type * const  *out_buff_ptr,   /*  Place to put response       */
  multi_index_fmt_e_type  format          /*  Flag for format type        */
)
{
  int size = 0;
  int result = 0;
  dsm_item_type * res_buff_ptr = *out_buff_ptr;
  mixed_def_s_type ** mixed_def_list = 
    (mixed_def_s_type **) parse_table->def_lim_ptr;
  dsat_mixed_param_val_type * mixed_val_list = 
    (dsat_mixed_param_val_type *) dsatutil_get_val(parse_table->cmd_id,0,0,STR_TYPE);

  switch (format)
  {
    case MULTI_INDEX_TEST:
      res_buff_ptr->used =
        (word) snprintf ((char*)res_buff_ptr->data_ptr,
                        res_buff_ptr->size,
                        "%s: (%d-%d)",
                        parse_table->name,
                        mixed_def_list[0]->def->dflm.lower,
                        mixed_def_list[0]->def->dflm.upper);
      result = res_buff_ptr->used;
      break;

    case MULTI_INDEX_READ:
      res_buff_ptr->used = (word) snprintf ((char*)res_buff_ptr->data_ptr,
                                                  res_buff_ptr->size,
                                                  "%s: %d",
                                                  parse_table->name,
                                                  mixed_val_list[0].num_item);
      result = res_buff_ptr->used;
      break;

    case MULTI_INDEX_AMPV:
      size = res_buff_ptr->used;
      res_buff_ptr->data_ptr[res_buff_ptr->used] = '\0';
      result = snprintf ((char*)res_buff_ptr->data_ptr,
                               res_buff_ptr->size,
                               "%s%s: %d",
                               res_buff_ptr->data_ptr,
                               parse_table->name,
                               mixed_val_list[0].num_item);
      result = (result - size);
      break;

    default:
      DS_AT_MSG0_HIGH("Unsupported format type");
  }
  return (dsat_num_item_type)result;
}  /* dsatetsicall_cusd_response_fmt */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CCWA_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CCWA command, which controls the call waiting
  supplementary service according to 3GPP TS 22.083

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_ccwa_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsatetsicmif_sups_state_ms_info  *sups_ms_val = NULL;

  sups_ms_val = dsat_get_base_addr_current_subs(DSAT_SUPS_MS_VALS);

  /*---------------------------------------------------------
   Processing for WRITE and name-only commands
  -----------------------------------------------------------*/
  if ( tok_ptr->op == (NA|EQ|AR) ||
       tok_ptr->op == NA )
  {
    dsat_num_item_type temp;
    dflm_type *limits_ptr = (dflm_type *)parse_table->def_lim_ptr;

    /* Validate <n> parameter (default 0) */
    if (VALID_TOKEN(0))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[0], 10))
      {
        DS_AT_MSG0_HIGH("+CCWA: Cannot convert <n> parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ( temp < limits_ptr->lower ||
           temp > limits_ptr->upper )
      {
        DS_AT_MSG0_HIGH("+CCWA: <n> parameter outside range");
        return DSAT_ERROR;
      }
      DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_CCWA_ETSI_IDX,0,0,0,temp,NUM_TYPE)
    }
    else if ( tok_ptr->args_found == 0 )
    {
      DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_CCWA_ETSI_IDX,0,0,0,limits_ptr->default_v,NUM_TYPE)
    }
    
    if ( tok_ptr->args_found > 1 )
    {
      ss_cw_user_s_type *sscw_ptr = &sups_ms_val->dsat_ss_cm_data.user_data.opdata.call_wt;
  
      /* Initialize data structure */
      memset (&sups_ms_val->dsat_ss_cm_data.user_data, 0, sizeof(ss_user_data_s_type));
      sups_ms_val->dsat_ss_cm_data.user_data.operation = DSAT_SSOP_CALL_WT;
    
      /* Validate MODE parameter (default DSAT_CCWA_MODE_ENABLE) */
      if (VALID_TOKEN(1))
      {
        /* Convert to number */
        if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[1], 10))
        {
          DS_AT_MSG0_HIGH("+CCWA: Cannot convert MODE parameter");
          return DSAT_ERROR;
        }
        /* Test for in-range */
        if ((dsat_num_item_type)DSAT_CCWA_MODE_MAX <= temp)
        {
          DS_AT_MSG0_HIGH("+CCWA: MODE parameter outside range");
          return DSAT_ERROR;
        }
        sscw_ptr->mode = (ccwa_mode_e_type)temp;
      }
      else 
      {
        sscw_ptr->mode = DSAT_CCWA_MODE_ENABLE;
      }

      /* Validate CLASS parameter  (default 7) */
      if (VALID_TOKEN(2))
      {
        /* Convert to number */
        if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[2], 10))
        {
          DS_AT_MSG0_HIGH("+CCWA: Cannot convert CLASS parameter");
          return DSAT_ERROR;
        }
        /* Test for in-range */
        if ( temp < (dsat_num_item_type)DSAT_SS_CLASS_VOICE ||
             temp > (dsat_num_item_type)DSAT_SS_CLASS_ALL )
        {
          DS_AT_MSG0_HIGH("+CCWA: CLASS parameter outside range");
          return DSAT_ERROR;
        }

        /* See if class in Basic Service Group lookup table */
        if ((dsat_ccwa_allowed_classes != (dsat_ccwa_allowed_classes | temp)) &&
            ((dsat_num_item_type)DSAT_SS_CLASS_ALL != temp))
        {
          DS_AT_MSG0_HIGH("+CCWA: Class not mapped to allowed BSG");
          return DSAT_ERROR;
        }
      
        sups_ms_val->dsat_ss_cm_data.user_data.class = (uint8)temp;
      }
      else
      {
        /* Default */
        sups_ms_val->dsat_ss_cm_data.user_data.class = 
          (uint8)((uint8)DSAT_SS_CLASS_VOICE | (uint8)DSAT_SS_CLASS_DATA |
                     (uint8)DSAT_SS_CLASS_FAX);
      }
      
      /* Initiate CM command */
      result = dsatetsicmif_sups_class_action (TRUE, dsat_get_current_subs_id(FALSE));
    }
  }

  /*---------------------------------------------------------
   Processing for READ and TEST commands
  -----------------------------------------------------------*/
  else if ( tok_ptr->op == (NA|QU) || 
            tok_ptr->op == (NA|EQ|QU) )
  {
    result = dsatparm_exec_param_cmd(
                                     mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr
                                    );
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_ccwa_cmd */

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CHLD_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CHLD command, which controls the call hold
  supplementary service according to 3GPP TS 27.007 and 22.083

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR :     if AT command syntax error
    DSAT_ASYNC_CMD : if CM call successful

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_chld_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result  = DSAT_ASYNC_CMD;
  sys_modem_as_id_e_type subs_id = dsat_get_current_subs_id(FALSE);
#ifdef FEATURE_DUAL_ACTIVE
  dsat_call_cmd_e_type  call_cmd = DSAT_CALL_CMD_SUPS_CHLD_0;
#endif 
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  /*---------------------------------------------------------
   Processing for WRITE and name-only commands
  -----------------------------------------------------------*/
  if ( tok_ptr->op == (NA|EQ|AR) ||
       tok_ptr->op == NA )
  {
    cm_call_sups_type_e_type sups_cmd;
    cm_call_sups_params_s_type sups_params;

    memset( &sups_params, 
            CM_CALL_CMD_PARAM_DEFAULT_VALUE, 
            sizeof(cm_call_sups_params_s_type) );
    sups_params.call_id = CM_CALL_ID_INVALID;

    /* Validate <n> parameter (default to 2 - hold call) */
    if (VALID_TOKEN(0) && tok_ptr->args_found == 1 )
    {
      uint8 parm_length = (uint8)strlen((char*)tok_ptr->arg[0]);
      dsat_num_item_type seq_num;
      cm_call_id_type call_id;
      boolean found = FALSE;
      /* Verify and convert first digit of <n> to CM SupS command */
      switch (*(char *)tok_ptr->arg[0]) 
      {
        case '0':
          sups_cmd = CM_CALL_SUPS_TYPE_HELD_CALL_REL_OR_UDUB;
#ifdef FEATURE_DUAL_ACTIVE
          call_cmd = DSAT_CALL_CMD_SUPS_CHLD_0;
#endif
          if (CM_CALL_MODE_INFO_IP == voice_state[subs_id][call_da_val->etsicall_wait_call_id].call_mode)
          {
            sups_params.ip_params.rej_cause = CM_CALL_END_SIP_486_BUSY_HERE;
          }
          if ( ( call_da_val->etsicall_num_held_calls == 0 ) &&
               ( !call_da_val->etsicall_wait_call_present ) )
          {
            /* Currently this scenario of AT+CHLD=0 is not
              handled by NAS/CM, hence handling in ATCoP */
             return DSAT_ERROR;
          }
          
          break;
        case '1':
          sups_cmd = (parm_length == 1) ? 
            CM_CALL_SUPS_TYPE_ACTIVE_CALL_REL :
            CM_CALL_SUPS_TYPE_ACTIVE_CALL_X_REL;

#ifdef FEATURE_DUAL_ACTIVE
          call_cmd = (parm_length == 1) ?
            DSAT_CALL_CMD_SUPS_CHLD_1 :
            DSAT_CALL_CMD_SUPS_CHLD_1X;
#endif
          break;
        case '2':
          sups_cmd = (parm_length == 1) ? 
            CM_CALL_SUPS_TYPE_HOLD_CALL :
            CM_CALL_SUPS_TYPE_SELECT_CALL_X;

#ifdef FEATURE_DUAL_ACTIVE
          call_cmd = (parm_length == 1) ?
            DSAT_CALL_CMD_SUPS_CHLD_2 :
            DSAT_CALL_CMD_SUPS_CHLD_2X;
#endif

          break;

        case '3':
          sups_cmd = CM_CALL_SUPS_TYPE_MULTIPARTY_CALL;

#ifdef FEATURE_DUAL_ACTIVE
          call_cmd = DSAT_CALL_CMD_SUPS_CHLD_3;
#endif 

          break;
        case '4':
          sups_cmd = CM_CALL_SUPS_TYPE_EXPLICIT_CALL_TRANSFER;
#ifdef FEATURE_DUAL_ACTIVE
          call_cmd = DSAT_CALL_CMD_SUPS_CHLD_4;
#endif 
          break;
        default:
          return DSAT_ERROR;
      }

#ifdef FEATURE_DUAL_ACTIVE
      if (FALSE == dsatvoice_validate_call_cmd(subs_id, call_cmd))
      {
        return dsat_send_cme_error(DSAT_CME_OP_NOT_ALLOWED);
      }
#endif /* FEATURE_DUAL_ACTIVE */

      /* Verify presence and validity of additional call sequence number digits
         in <n> per SupS command type and convert to call id if present */
      switch (sups_cmd)
      {
        /* Additional call sequence number digits must be present and valid 
           for these SupS commands... */
        case CM_CALL_SUPS_TYPE_ACTIVE_CALL_X_REL:
        case CM_CALL_SUPS_TYPE_SELECT_CALL_X:
          /* User must have specified call sequence number */
          if ( ATOI_OK != dsatutil_atoi(&seq_num, 
                                        (tok_ptr->arg[0] + 1), 
                                        10) ||
               (call_id = dsatetsicall_seqnum_to_callid(subs_id, seq_num))
               == CM_CALL_ID_INVALID )
          {
            DS_AT_MSG0_HIGH("+CHLD: Invalid sequence number in <n> parameter");
            return DSAT_ERROR;
          }
          /* If a valid call_id is found, check to see if its not a PS call. */
          if(( seq_num > 0 && seq_num <= CM_CALL_ID_MAX ) &&
             (call_da_val->dsat_seqnum_callid[seq_num - 1].call_type == CM_CALL_TYPE_PS_DATA))
          {
            DS_AT_MSG0_HIGH("+CHLD Operation on PS call not allowed");
            return dsat_send_cme_error(DSAT_CME_OP_NOT_ALLOWED);
          }
          if( call_da_val->etsicall_num_active_calls == 1 )
          {
            found = etsicall_search_call_list(
                      &call_da_val->etsicall_num_active_calls,
                       call_da_val->etsicall_active_call_ids,
                      call_id,
                      FALSE);
          }
          if( ( sups_cmd == CM_CALL_SUPS_TYPE_SELECT_CALL_X )&&
              ( found == TRUE ) )
          {
            /* Currently AT+CHLD=2x, if x is the only call active, is
            not handled in NAS or CM hence handling in ATCoP*/
            DS_AT_MSG0_HIGH(" Only this call-id is active ");
            return DSAT_ERROR;
          }

          sups_params.call_id = call_id;
          break;
        /* Call id digits should be absent for all other SupS commands */
        default:
          if (parm_length != 1)
          {
            return DSAT_ERROR;
          }
          break;
      }
    }
    else if ( tok_ptr->args_found == 0 )
    {
      /* Default to <n> = 2 */
      sups_cmd = CM_CALL_SUPS_TYPE_HOLD_CALL;
    }
    else 
    {
      /* Bad parameters */
      return DSAT_ERROR;
    }

    /* Duplicating UI code's behavior: it sets this only for 1x command */
    if ( sups_cmd == CM_CALL_SUPS_TYPE_ACTIVE_CALL_X_REL )
    {
      sups_params.cause = CM_CAUSE_DEFAULT;
    }

    /* If it was MPTY call but there is no active calls and held calls,
       reset the flag */
    if( call_da_val->etsicall_num_active_calls == 0 &&
        call_da_val->etsicall_num_held_calls == 0   &&
        call_da_val->etsicall_was_mpty_call )
    {
      call_da_val->etsicall_was_mpty_call = FALSE;
    }

    /* Keep track of waiting call at time command was issued */
    call_da_val->etsicall_was_waiting = call_da_val->etsicall_wait_call_present;
    call_da_val->was_waiting_call_id  = call_da_val->etsicall_wait_call_id;

    /* Per CM group: call ID must now be included for all in-call supplementary
       service calls. It can be any of allocated call IDs for active, held or 
       waiting calls. */
    if ( CM_CALL_ID_INVALID == sups_params.call_id )
    {
      DS_AT_MSG1_HIGH("+CHLD: sups_cmd = %d", sups_cmd);
      if(CM_CALL_SUPS_TYPE_HELD_CALL_REL_OR_UDUB == sups_cmd)
      {        
        if ( call_da_val->etsicall_num_held_calls > 0 )
        {
          sups_params.call_id = call_da_val->etsicall_held_call_ids[0];
        }
        else if ( call_da_val->etsicall_wait_call_present )
        {
          sups_params.call_id = call_da_val->etsicall_wait_call_id;
        }
        else
        {         
          return DSAT_ERROR;
        }
      }
      else
      {
        if ( call_da_val->etsicall_num_active_calls > 0 )
        {
          sups_params.call_id = call_da_val->etsicall_active_call_ids[0];
        }
        else if ( call_da_val->etsicall_num_held_calls > 0 )
        {
          sups_params.call_id = call_da_val->etsicall_held_call_ids[0];
        }
        else if ( call_da_val->etsicall_wait_call_present )
        {
          sups_params.call_id = call_da_val->etsicall_wait_call_id;
        }
        else
        {
          return DSAT_ERROR;
        }
      }
    }
    
    /* Make CM call */
    etsicall_cmd_pending[subs_id] = (etsicall_cmd_type)((uint8)sups_cmd | (uint8)CMD_CONF);

    /* The success as well as failure will be handled by the call back function */
#ifdef FEATURE_DUAL_SIM
    (void)cm_mm_call_cmd_sups_per_subs( dsatcmif_call_cmd_cb_func,
                               NULL,
                               dsatcm_client_id,
                               sups_cmd,
                               &sups_params,
                               subs_id);
#else
    (void)cm_mm_call_cmd_sups( dsatcmif_call_cmd_cb_func,
                               NULL,
                               dsatcm_client_id,
                               sups_cmd,
                               &sups_params);
#endif /* FEATURE_DUAL_SIM */
    result = DSAT_ASYNC_CMD;
    
  }

  /*---------------------------------------------------------
   Processing for TEST command
  -----------------------------------------------------------*/
  else if ( tok_ptr->op == (NA|EQ|QU) )
  {
    res_buff_ptr->used = (word) snprintf ( (char*)res_buff_ptr->data_ptr,
                                                 res_buff_ptr->size,
                                                 "+CHLD: (0,1,1x,2,2x,3,4)" );

    result = DSAT_OK;
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_chld_cmd */



/*===========================================================================

FUNCTION DSATETSICALL_SUPS_CMD_CB_HANDLER

DESCRIPTION
  This function is the handler function for the CM SupS call commands

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR :      if there was any problem in execution.
    DSAT_ASYNC_CMD :  if it is a success and asynch cmd continues.
    DSAT_OK :         if it is a success and asynch cmd done. 

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_sups_cmd_cb_handler
(
  sys_modem_as_id_e_type  subs_id,
  ds_at_cm_call_cmd_type *call_cmd /* Call command pointer */
)
{
  dsat_result_enum_type result = DSAT_ASYNC_CMD;

  DS_AT_MSG1_MED("In sups_cmd_cb_handler: %d", call_cmd->cmd_err);

  /* Check for error condition */
  if (CM_CALL_CMD_ERR_NOERR != call_cmd->cmd_err)
  {
    dsat_cme_error_e_type error_code;

    etsicall_cmd_pending[subs_id] = CMD_NONE;

    switch (call_cmd->cmd_err)
    {
      case CM_CALL_CMD_ERR_SRV_STATE_S:
        error_code = DSAT_CME_NO_NETWORK_SERVICE;
        break;

      default:
        error_code = DSAT_CME_UNKNOWN;
        DS_AT_MSG1_HIGH("Unmapped CM SupS cmd error type: %d", call_cmd->cmd_err);
        break;
    }

    /* Report +CME error */
    result = dsat_send_cme_error(error_code);
  }
  
  return result;
} /* dsatetsicall_sups_cmd_cb_handler */



/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_MNG_CALLS_CONF

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_MNG_CALLS_CONF event.
  For ATCOP originated events: 
    On success needs to update state indicating no longer waiting for this 
    confirmation and on failure must issue CME ERROR result code.
  For other clients:
    On success of hold call(s) command needs to update held calls info so 
    any subsequent AT+CHLD=0 (release all held calls) command will know number
    of END events to expect before giving result code.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP : if CM reports failure.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_call_event_mng_calls_conf
(
  ds_at_cm_call_event_type *call_event, /* Call event pointer */
  sys_modem_as_id_e_type    subs_id     /* Subsription ID */
)
{
  dsat_result_enum_type result = DSAT_ASYNC_EVENT;
  boolean select_found = FALSE;
  boolean clr_pending = FALSE;
  uint8 num_calls = 0;
  uint8 call_id = 0;
  cm_call_id_type call_ids[CM_CALL_ID_MAX];      
  boolean temp_stg = FALSE;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS,subs_id, TRUE);
  if (NULL == call_da_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  /* If ATCOP has initiated a +CHLD SupS command of this type and
     command confirmation event not yet received or when ATD has 
        initiated a voice call when a call is already up */
  if ( ( ((uint8)etsicall_cmd_pending[subs_id] & ~(uint8)CMD_CONF) == 
         (uint8)call_event->event_info.sups_type ) ||
         (call_da_val->etsicall_was_call_active) )
  {
    /* If MNG_CALLS confirmation not yet received */
    if ( (uint8)etsicall_cmd_pending[subs_id] & (uint8)CMD_CONF )
    {
      if ( call_event->event_info.call_ss_success)
      {
        /* Clear bit indicating CM_CALL_EVENT_MNG_CALLS_CONF expected */
        etsicall_cmd_pending[subs_id] = (etsicall_cmd_type)((uint8)etsicall_cmd_pending[subs_id] & ~(uint8)CMD_CONF);

        switch ( call_event->event_info.sups_type )
        {
          case CM_CALL_SUPS_TYPE_HELD_CALL_REL_OR_UDUB:
            /* +CHLD=0 - Release all held calls or set User Determined User 
               Busy (UDUB) for a waiting call. */
            if ( (call_da_val->etsicall_was_waiting && !call_da_val->etsicall_wait_call_present) ||
                  call_da_val->etsicall_num_held_calls == 0 )
            {
              /* If there was a waiting call but it's been ended OR
                 any & all held calls have been released... */
              clr_pending = TRUE;
            }
            break;

          case CM_CALL_SUPS_TYPE_ACTIVE_CALL_REL:
            /* +CHLD=1 - Release any & all active calls and accept other call 
               (held or waiting) */

            /* If there was a waiting call at time command was issued and... */
            if ( call_da_val->etsicall_was_waiting )
            {
              /* It has since been connected... */
              if ( !call_da_val->etsicall_wait_call_present )
              {
                /* Give OK response and clear pending command */
                clr_pending = TRUE;
              }
            }
            else
            {
              /* Move held calls to active call list, excluding none */
              (void)etsicall_move_calls( &call_da_val->etsicall_num_held_calls,
                                          call_da_val->etsicall_held_call_ids,
                                         &call_da_val->etsicall_num_active_calls,
                                          call_da_val->etsicall_active_call_ids,
                                         CM_CALL_ID_INVALID );

              /* Give OK response and clear pending command */
              clr_pending = TRUE;
            }
            break;

          case CM_CALL_SUPS_TYPE_ACTIVE_CALL_X_REL:
            /* +CHLD=1x - Release a specific call x */
            /* Search for call id among etsicall_active_call_ids */
            select_found = etsicall_search_call_list( 
              &call_da_val->etsicall_num_active_calls,
               call_da_val->etsicall_active_call_ids,
              call_event->event_info.call_id,
              FALSE);
            /* If not found (already released) end pending command */
            clr_pending = !select_found;
            break;

          case CM_CALL_SUPS_TYPE_HOLD_CALL:
            /* +CHLD=2 - Place all active calls on hold and
               accept other call(s) (held or waiting) */

            /* If there was no waiting call at time command was issued AND
               there are held call(s) save them in temporary storage */
            if ( !call_da_val->etsicall_was_waiting &&
                  call_da_val->etsicall_num_held_calls != 0 )
            {
              if(call_da_val->was_active_call_hold && call_da_val->was_hold_call_retrieved)
              {
                clr_pending = TRUE;
                DS_AT_MSG0_HIGH("Already active call moved to hold and hold to active");
                break;
              }
              (void)etsicall_move_calls( &call_da_val->etsicall_num_held_calls,
                                          call_da_val->etsicall_held_call_ids,
                                         &num_calls,
                                         call_ids,
                                         CM_CALL_ID_INVALID );

              temp_stg = TRUE;
            }

            /* Move active calls to held:
               If there was a waiting call at time command was issued exclude
               it. This handles case where CM incorrectly returns CONNECT event
               for the waiting call prior to the MNG_CALLS_CONF event. */
            (void)etsicall_move_calls( &call_da_val->etsicall_num_active_calls,
                                        call_da_val->etsicall_active_call_ids,
                                       &call_da_val->etsicall_num_held_calls,
                                        call_da_val->etsicall_held_call_ids,
                                       ( call_da_val->etsicall_was_waiting ? 
                                         call_da_val->was_waiting_call_id : 
                                         CM_CALL_ID_INVALID ) );

            /* Temporarily stored (previously held) calls should be moved to 
               active calls storage */
            if ( temp_stg )
            {
              (void)etsicall_move_calls( &num_calls,
                                         call_ids,
                                         &call_da_val->etsicall_num_active_calls,
                                          call_da_val->etsicall_active_call_ids,
                                         CM_CALL_ID_INVALID );
            }

            if ( !call_da_val->etsicall_was_waiting || !call_da_val->etsicall_wait_call_present )
            {
              /* If there was no waiting call at time command was issued OR
                 there was a waiting call but it has already been connected */
              clr_pending = TRUE;
            }
            break;

          case CM_CALL_SUPS_TYPE_SELECT_CALL_X:
            /* +CHLD=2x - Place all active calls on hold except x
               with which communication is still established. */
            if(call_da_val->etsicall_num_active_calls != 0)
            {
              /* Move active calls to held call list */
              (void)etsicall_move_calls( 
                &call_da_val->etsicall_num_active_calls,
                 call_da_val->etsicall_active_call_ids,
                &call_da_val->etsicall_num_held_calls,
                 call_da_val->etsicall_held_call_ids,
                CM_CALL_ID_INVALID);
            }
            for (num_calls = 0;
                 num_calls < call_event->event_info.dsat_mode_info.info.gw_cs_call.active_calls_list.size;
                 num_calls++)
            {
              /* Remove the call-id's from held call list if present */
              (void)etsicall_search_call_list(
                &call_da_val->etsicall_num_held_calls,
                 call_da_val->etsicall_held_call_ids,
                call_event->event_info.dsat_mode_info.info.gw_cs_call.active_calls_list.table[num_calls],
                TRUE);
              /* Add call id to active call list */
              call_da_val->etsicall_active_call_ids[call_da_val->etsicall_num_active_calls++] = 
                call_event->event_info.dsat_mode_info.info.gw_cs_call.active_calls_list.table[num_calls];
             
            }
            /* No further events expected */
            clr_pending = TRUE;
            break;

          case CM_CALL_SUPS_TYPE_MULTIPARTY_CALL:
            /* +CHLD=3 - Add a held call to the conversation,
               Multiparty call */

            /* Move held calls to active call list, excluding none */
            (void)etsicall_move_calls( &call_da_val->etsicall_num_held_calls,
                                        call_da_val->etsicall_held_call_ids,
                                       &call_da_val->etsicall_num_active_calls,
                                        call_da_val->etsicall_active_call_ids,
                                       CM_CALL_ID_INVALID );
            /* No further events expected */
            clr_pending = TRUE;
            call_da_val->etsicall_was_mpty_call = TRUE;
            break;

          case CM_CALL_SUPS_TYPE_EXPLICIT_CALL_TRANSFER:
            /* +CHLD=4 - Explicit call transfer */
            if ( call_da_val->etsicall_num_active_calls == 0 &&
                 call_da_val->etsicall_num_held_calls == 0 )
            {
              clr_pending = TRUE;
            }
            break;

          default:
            break;
        }

        if ( clr_pending )
        {
          etsicall_cmd_pending[subs_id] = CMD_NONE;
          call_da_val->was_active_call_hold = FALSE;
          call_da_val->was_hold_call_retrieved = FALSE;
          result = DSAT_OK;
        }
      } /* End successful */
      else
      {
        etsicall_cmd_pending[subs_id] = CMD_NONE;

        /* Report +CME error */
        return dsat_send_cme_error(DSAT_CME_SUPS_NETWORK_REJECTED);
      }
    }
    else if (call_da_val->etsicall_was_call_active)
    {
      /* This occurs if another call is dialed via ATCoP when a call
         is already up. Change the state for the previous active calls to DSAT_VOICE_STATE_IDLE;
         and then move them to held_call list */
      
      for ( call_id = 0;call_id < CM_CALL_ID_MAX; call_id++ )
      {
        if ( voice_state[subs_id][call_id].state == DSAT_VOICE_STATE_ACTIVE )
        {
          dsatvoice_go_to_idle_state(subs_id, call_id);
        }
      }
      DS_AT_MSG0_MED("Move the active calls to held call list");
      /* Move active calls to held call list */
      (void)etsicall_move_calls( &call_da_val->etsicall_num_active_calls,
                                  call_da_val->etsicall_active_call_ids,
                                 &call_da_val->etsicall_num_held_calls,
                                  call_da_val->etsicall_held_call_ids,
                                 CM_CALL_ID_INVALID);
      call_da_val->etsicall_was_call_active = FALSE;
    }
    /* Else MNG_CALLS confirmation already received */
    else
    {
      /* If MNG_CALLS was already received for MPTY call and issued command was to hold call,
         clear pending command and set result to DSAT_OK.
         We don't need to mask CONF as we came here as CONF was already received */
      if( call_da_val->etsicall_was_mpty_call && ((uint8)etsicall_cmd_pending[subs_id] == CMD_CHLD2) )
      {        
        etsicall_cmd_pending[subs_id] = CMD_NONE;
        result = DSAT_OK;
      }
      DS_AT_MSG0_HIGH("MNG_CALLS confirmation already received");
    }
  } /* End ATCOP initiated SupS command */

  return result;
} /* dsatetsicall_call_event_mng_calls_conf */


/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_CONNECT

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_CONNECT event. It adds the call id connected to the active
  calls list of our state info and if a +CHLD command is pending and no 
  further events are expected gives result code.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_OK :          if +CHLD command processing complete.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_call_event_connect
(
  ds_at_cm_call_event_type*  call_event,     /* call event pointer         */
  sys_modem_as_id_e_type     subs_id,        /* Subsription ID */
  dsat_result_enum_type      result
)
{
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS,subs_id, TRUE);
  if (NULL == call_da_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  /* Only display if unsolicited result codes are enabled for MO calls. */
  if(( (dsat_num_item_type)dsatutil_get_val(
       DSATETSI_EXT_ACT_COLP_ETSI_IDX,0,0,NUM_TYPE) == DSAT_COLP_ENABLED ) &&
     ( voice_state[subs_id][call_event->event_info.call_id].
             cmd_active == VOICE_CMD_ATD ))
  {
    result = dsatetsicmif_get_colp_info_or_report_result(subs_id,
                                        &call_event->event_info);
  }


  if ( etsicall_cmd_pending[subs_id] != CMD_NONE )
  {
    /* Mask off CMD_CONF bit to give only command enum */
    switch ( (uint8)etsicall_cmd_pending[subs_id] & ~(uint8)CMD_CONF )
    {
      /* These are the only 2 +CHLD commands that should cause CONNECT
         events */
      case CMD_CHLD1:
        /* +CHLD=1 - Release all active calls and accept other call 
           (held or waiting) */
      case CMD_CHLD2:
        /* +CHLD=2 - Place all active calls on hold and
           accept another call (held or waiting) */
        if ( call_da_val->etsicall_was_waiting  )
        {
          /* There was a call waiting at the time command was issued */
          if ( !((uint8)etsicall_cmd_pending[subs_id] & (uint8)CMD_CONF) && !call_da_val->etsicall_was_mpty_call)
          {
            /* Not still waiting for CM_CALL_EVENT_MNG_CALLS_CONF */
            etsicall_cmd_pending[subs_id] = CMD_NONE;
            result = DSAT_OK;
          }
        }
        break;

      default:
        break;
    }

    /* Maintain dsatvoice state machine state */
    voice_state[subs_id][call_event->event_info.call_id].state = DSAT_VOICE_STATE_ACTIVE;
  }

  return result;
} /* dsatetsicall_call_event_connect */


/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_END

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_MNG_CALLS_CONF event and removes the call id ended from 
  our call state info.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP : if CM reports failure.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_call_event_end
(
  ds_at_cm_call_event_type *call_event, /* Call event pointer */
  sys_modem_as_id_e_type    subs_id     /* Subsription ID */
)
{
  dsat_result_enum_type            result = DSAT_ASYNC_EVENT;
  boolean                          clr_pending = FALSE;
  cm_call_id_type                  call_id;
  dsatetsicall_call_state_da_info *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS,subs_id, TRUE);
  if (NULL == call_da_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  call_id = call_event->event_info.call_id;


  if(call_event->event_info.report_cssu == TRUE)
  {
    dsatetsicall_call_event_cssu_report( call_event,
                                         subs_id,
                                         DSAT_CSSU_CALL_HOLD_RELEASED);
    call_event->event_info.report_cssu = FALSE;
  }
  
    if ( etsicall_cmd_pending[subs_id] != CMD_NONE )
    {
      DS_AT_MSG1_MED("Command = %d",(uint8)etsicall_cmd_pending[subs_id]);
      /* Mask off CMD_CONF bit to give only command enum */
      switch ( (uint8)etsicall_cmd_pending[subs_id] & ~(uint8)CMD_CONF )
      {
        case CMD_CHLD0:
          /* If previously waiting call released OR
             any & all held calls have already been released AND
             SupS command confirmation has been received give result code and 
             clear Sups command pending */
          if ( call_da_val->etsicall_was_waiting )
          {
            /* CM does not give MNG_CALLS SupS command confirmation after
               +CHLD=0 to UDUB a waiting call */
            if ( !call_da_val->etsicall_wait_call_present )
            {
              clr_pending = TRUE;
            }
          }
          else 
          {
            /* CM does not give MNG_CALLS event in the case when multiple
               calls are being held */
            if (call_da_val->etsicall_num_held_calls == 0 )
            {
              clr_pending = TRUE;
            }
          }
          break;
  
        case CMD_CHLD1:
          /* If any & all active calls have been released AND
             any waiting call that might have been has already been connected AND
             SupS command confirmation has been received give result code and 
             clear Sups command pending */
          if (  call_da_val->etsicall_num_active_calls == 0 &&
               !call_da_val->etsicall_wait_call_present &&
               !((uint8)etsicall_cmd_pending[subs_id] & (uint8)CMD_CONF) 
             )
          {
            clr_pending = TRUE;
          }
          break;
  
        case CMD_CHLD1x:
          /* If this call id was found among active call ids and has been released 
               and SupS command confirmation received then give result code and clear
             Sups command pending */
          if ( call_event->event_info.is_call_id_found &&
						   call_event->event_info.is_call_among_active &&
						   !((uint8)etsicall_cmd_pending[subs_id] & (uint8)CMD_CONF) )
          {
            clr_pending = TRUE;
          }
          break;

        case CMD_CHLD2:
        case CMD_CHLD2x:
        case CMD_CHLD3:
          /* If all the calls are ended clear the pending command */
          if ( ( call_da_val->etsicall_num_active_calls == 0) &&
               ( call_da_val->etsicall_num_held_calls == 0) &&
               (!call_da_val->etsicall_wait_call_present) )
          {
            if( VOICE_CMD_NONE != 
                 voice_state[subs_id][call_event->event_info.call_id].cmd_active )
            {
              /* Send the NO CARRIER response MT ends connected or waiting call */
              if (!(( voice_state[subs_id][call_event->event_info.call_id].state 
                  == DSAT_VOICE_STATE_CONNECTING ) &&( VOICE_CMD_ATD != 
                  voice_state[subs_id][call_event->event_info.call_id].cmd_active )))
              {
                /* Need to explicitly send unsolicited response for Serializer and 
                   reset afterward */
                dsatrsp_send_urc_per_subs(subs_id, DSAT_NO_CARRIER);
              }
            }
            clr_pending = TRUE;
          }
          break;

        case CMD_CHLD4:
          /* If both the single active and single held calls have been ECTed and 
             released and SupS command confirmation has been received give result
             code and clear Sups command pending */
          if ( call_da_val->etsicall_num_active_calls == 0 &&
               call_da_val->etsicall_num_held_calls == 0 &&
               !((uint8)etsicall_cmd_pending[subs_id] & (uint8)CMD_CONF) )
          { 
            clr_pending = TRUE;
          }
          break;
  
        case CMD_CHUP:
        case CMD_ATH:
          if ( call_da_val->etsicall_num_active_calls == 0 &&
               call_da_val->etsicall_num_held_calls == 0 ) 
          {
            clr_pending = TRUE;
          }
          break;
  
        default:
          break;
      }

      /* Maintain dsatvoice state machine state */
      dsatvoice_go_to_idle_state( subs_id, call_id );

      if ( clr_pending )
      {
        etsicall_cmd_pending[subs_id] = CMD_NONE;
        result = DSAT_OK;
      }
    }
    else
    {
      if ( ( VOICE_CMD_ATD == voice_state[subs_id][call_id].cmd_active ) &&
           ( call_da_val->etsicall_was_call_active) )
      {
        /* clear the call active flag */
        call_da_val->etsicall_was_call_active = FALSE;
      }
      result = dsatvoice_call_event_end(subs_id,
                                        &call_event->event_info);
    }
  return result;
} /* dsatetsicall_call_event_end */

#ifdef FEATURE_WCDMA
/*===========================================================================

FUNCTION DSATETSICALL_EXEC_ES_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +ES command, which set parameters for entering or exiting
  synchronous access mode.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_es_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;

  dsat_num_item_type es_orig, es_ans_fbk;

  /*---------------------------------------------------------
   Processing for write cmd
  -----------------------------------------------------------*/
  if ( (tok_ptr->op ==(NA|EQ|AR)))
  {
    /* Validate the first arg, es_orig */
    if(tok_ptr->arg[0][0] != '\0')
    {
      if(dsatutil_atoi(&es_orig, tok_ptr->arg[0], 10) != ATOI_OK)
      {
        return DSAT_ERROR;
      }

      if( (es_orig > dsat_es_orig_dflm.upper) || 
          (es_orig < dsat_es_orig_dflm.lower) )
      {
        return DSAT_ERROR;
      }
      else
      {
         /* Set token to be validated value for test cmd. */
         tok_ptr->arg[0][0] = (byte) (es_orig + '0');
         tok_ptr->arg[0][1] = '\0';
      }
    }

    /* The second arg is not supported and should be null */
    if((tok_ptr->args_found > 1) &&
       (tok_ptr->arg[1][0] != '\0'))
    {
      return DSAT_ERROR;
    }

    /* Validate the 3rd arg, es_ans_fbk */
    if((tok_ptr->args_found > 2) &&
       (tok_ptr->arg[2][0] != '\0'))
      {
      if(dsatutil_atoi(&es_ans_fbk, tok_ptr->arg[2], 10) != ATOI_OK)
        {
        return DSAT_ERROR;
        }

      if( (es_ans_fbk > dsat_es_ans_fbk_dflm.upper) || 
          (es_ans_fbk < dsat_es_ans_fbk_dflm.lower) )
        {
        return DSAT_ERROR;
        }
       else
       {
         /* Set token to be validated value for test cmd. */
         tok_ptr->arg[2][0] = (byte) (es_ans_fbk + '0');
         tok_ptr->arg[2][1] = '\0';
       }
      }
    
    /* Default parameter processing */
    result = dsatparm_exec_param_cmd(mode, parse_table, tok_ptr, res_buff_ptr);
    if (DSAT_OK == result) 
    {
       dsatetsicall_es_export();
    }
    }

  /*---------------------------------------------------------
   Processing for read, and default cmd
  -----------------------------------------------------------*/
  else if ( (tok_ptr->op == (NA|QU)) ||
            (tok_ptr->op ==(NA)) ) 
  {
    result = dsatparm_exec_param_cmd(mode, parse_table, tok_ptr, res_buff_ptr);

    if ( (DSAT_OK == result) &&
         (tok_ptr->op == (NA)) )
    {
      dsatetsicall_es_export();
    }
  }

  /*---------------------------------------------------------
   Processing for test cmd
  -----------------------------------------------------------*/
  else if ( tok_ptr->op == (NA|EQ|QU) )
  {
    char orig_tst[20], ans_fbk_tst[20];

    /* Get the es_orig test string */
    if(dsat_es_orig_dflm.upper == dsat_es_orig_dflm.lower)
    {
      (void) snprintf(orig_tst,sizeof(orig_tst), "(%d)", 
                            dsat_es_orig_dflm.lower);
    }
    else
    {
      (void) snprintf(orig_tst,sizeof(orig_tst), "(%d-%d)",
                            dsat_es_orig_dflm.lower,
                            dsat_es_orig_dflm.upper);
    }

    /* Get the es_ans_fbk test string */
    if(dsat_es_ans_fbk_dflm.upper == dsat_es_ans_fbk_dflm.lower)
    {
      (void) snprintf(ans_fbk_tst,sizeof(ans_fbk_tst), "(%d)", 
                            dsat_es_ans_fbk_dflm.lower);
    }
    else
    {
      (void) snprintf(ans_fbk_tst,sizeof(ans_fbk_tst), "(%d-%d)",
                           dsat_es_ans_fbk_dflm.lower,
                           dsat_es_ans_fbk_dflm.upper);
    }
    
    res_buff_ptr->used = (word) snprintf ((char *) res_buff_ptr->data_ptr,
                                                res_buff_ptr->size,
                                                "+ES: %s,,%s",
                                                orig_tst,
                                                ans_fbk_tst);
    result = DSAT_OK;
  }

  else
  {
    result = DSAT_ERROR;
  }

  return result;
} /* dsatetsicall_exec_es_cmd */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_ESA_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +ESA command, which set parameters for synchronous access 
  mode configuration.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_esa_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result;

  /*---------------------------------------------------------
   Processing for the command 
  -----------------------------------------------------------*/
  result = dsatparm_exec_param_cmd(mode, parse_table, tok_ptr, res_buff_ptr);

  /* for write or default command, export the newly written parameters */
  if(result == DSAT_OK  &&
     (tok_ptr->op == (NA|EQ|AR) || tok_ptr->op == NA) )
  {
    dsatetsicall_esa_export();
  }

  return result;
} /* dsatetsicall_exec_esa_cmd */

#endif /* FEATURE_WCDMA */

#if defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS)

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CBST_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CBST command. It is used to select bearser services to be 
  used when data calls are originated.  The paramaters are validated using
  a routine from CS stack.

DEPENDENCIES
  The values exported may or may not be appropriate for the mode-specific
  handler.  Validation in mode-specific handler is assumed. 
  
RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cbst_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_num_item_type* temp_dsat_cbst_export_val;
  dsat_result_enum_type result = DSAT_ERROR;
  
  /* Processing for WRITE syntax */
  if ( (tok_ptr->op == (NA|EQ|AR)) )
  {
    dsat_num_item_type speed,name,celement;

    /* Convert tokens to numerics; use previous value if token null */
    if ( etsicall_convert_cbst_param( tok_ptr, 0, &speed ) &&
         etsicall_convert_cbst_param( tok_ptr, 1, &name ) &&
         etsicall_convert_cbst_param( tok_ptr, 2, &celement ) )
    {
      /* Validate parameter set with CS data stack */
      if (TRUE == ds_ucsd_validate_cbst_values( speed, name, celement ))
      {
        /* Perform default paramater processing */
        if (DSAT_OK == dsatparm_exec_param_cmd( mode,
                                                parse_table,
                                                tok_ptr,
                                                res_buff_ptr ))
        {
          /* Populate the exported values */
          temp_dsat_cbst_export_val = dsat_get_cbst_export_val(0);
          *temp_dsat_cbst_export_val = speed;
          temp_dsat_cbst_export_val = dsat_get_cbst_export_val(1);
          *temp_dsat_cbst_export_val = name;
          temp_dsat_cbst_export_val = dsat_get_cbst_export_val(2);
          *temp_dsat_cbst_export_val = celement;
          result = DSAT_OK;
        }
      }
    }
  }
  /* Processing for TEST and READ syntax */
  else if ( (tok_ptr->op == (NA|EQ|QU)) ||
            (tok_ptr->op == (NA|QU)) ||
            (tok_ptr->op == (NA)) )
  {
    result = dsatparm_exec_param_cmd( mode,
                                      parse_table,
                                      tok_ptr,
                                      res_buff_ptr );

    /* For default case, export default parameters */
    if (tok_ptr->op == (NA))
    {
      temp_dsat_cbst_export_val = dsat_get_cbst_export_val(0);
      (void)dsatutil_atoi(temp_dsat_cbst_export_val,
                  &dsat_cbst_speed_valstr[dsat_cbst_list[0].default_v][0],10);
      temp_dsat_cbst_export_val = dsat_get_cbst_export_val(1);
      (void)dsatutil_atoi(temp_dsat_cbst_export_val,
                  &dsat_cbst_name_valstr[dsat_cbst_list[1].default_v][0],10);
      temp_dsat_cbst_export_val = dsat_get_cbst_export_val(2);
      (void)dsatutil_atoi(temp_dsat_cbst_export_val,
                  &dsat_cbst_ce_valstr[dsat_cbst_list[2].default_v][0],10);
    }
  }

  return result;
} /* dsatetsicall_exec_cbst_cmd */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CRLP_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CRLP command, which processes parameters for
  non-transparnet/asynchronous circuit-switched data calls.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_ASYNC_CMD : if aynchronous command continues successfully
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_crlp_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsat_num_item_type  *crlp_ptr;
  dsat_num_item_type   crlp_size;
  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
  if (tok_ptr->op == (NA|EQ|AR) )
  {
    const byte radix = 10;
    dsat_num_item_type version = (dsat_num_item_type)dsatetsicall_crlp_version_default;
    dsat_num_item_type temp[MAX_CRLP_PARAMS];
    dflm_type *limits_ptr;

    /* Verify number of parameters */
    if (tok_ptr->args_found > parse_table->compound)
    {
      return (DSAT_ERROR);
    }
      
    /* Process version identifier, need it for selecting limits
     * for other parameters */
    if ( VALID_TOKEN((byte)CRLP_VERSION) )
    {
      if (ATOI_OK != dsatutil_atoi(&version, tok_ptr->arg[CRLP_VERSION], radix))
      {
        DS_AT_MSG0_HIGH("Cannot convert VERSION parameter");
        return DSAT_ERROR;
      }
    }
    if (MAX_CRLP_VERSIONS <= version)
    {
      /* Value outside limits */
      DS_AT_MSG3_HIGH("Value outside range: %d [%d, %d]",
                version, 0, MAX_CRLP_VERSIONS);
      return DSAT_ERROR;
    }
    
    limits_ptr = (dflm_type*)dsat_crlp_dflm[ rlpv_xref[version] ];
    
    /* Load previous values into temporary parameter list */
    CRLP_SIZE(version ,0,crlp_size)
    crlp_ptr = (dsat_num_item_type  *)dsatutil_get_val(DSATETSI_EXT_CRLP_IDX,0,0,STR_TYPE);
    
    (void) dsatutil_memscpy((void*)temp, sizeof(temp),
                            (void*)(crlp_ptr  + crlp_size), sizeof(temp));
    
    /* Process IWS parameter */
    if (DSAT_OK != etsicall_process_crlp_param (tok_ptr, limits_ptr, (uint32)CRLP_IWS,
                                                &temp[CRLP_IWS]))
    {
        DS_AT_MSG0_HIGH("Error validating IWS parameter");
        return DSAT_ERROR;
    }
    
    /* Process MWS parameter */
    if (DSAT_OK != etsicall_process_crlp_param (tok_ptr, limits_ptr, (uint32)CRLP_MWS,
                                                &temp[CRLP_MWS]))
    {
        DS_AT_MSG0_HIGH("Error validating MWS parameter");
        return DSAT_ERROR;
    }

    /* Process T1 parameter */
    if (DSAT_OK != etsicall_process_crlp_param (tok_ptr, limits_ptr, (uint32)CRLP_T1,
                                                &temp[CRLP_T1]))
    {
        DS_AT_MSG0_HIGH("Error validating T1 parameter");
        return DSAT_ERROR;
    }
    
    /* Process N2 parameter */
    if (DSAT_OK != etsicall_process_crlp_param (tok_ptr, limits_ptr, (uint32)CRLP_N2,
                                                &temp[CRLP_N2]))
    {
        DS_AT_MSG0_HIGH("Error validating T1 parameter");
        return DSAT_ERROR;
    }

    /* Transfer temporary parameters to exported array */
    CRLP_SIZE(version ,0,crlp_size)
    crlp_ptr = (dsat_num_item_type  *)dsatutil_get_val(DSATETSI_EXT_CRLP_IDX,0,0,STR_TYPE);

   (void) dsatutil_memscpy((void*)(crlp_ptr  + crlp_size), MAX_CRLP_PARAMS * sizeof(dsat_num_item_type),
                          (void*)temp, MAX_CRLP_PARAMS * sizeof(dsat_num_item_type));
    
  }

  /*--------------------------------------
  Processing for a READ command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|QU) )
  {
    if (0 == dsatetsicall_crlp_response_fmt (parse_table,
                                             &res_buff_ptr,
                                             MULTI_INDEX_READ))
    {
      DS_AT_MSG0_HIGH("Problem generating query response");
      result = DSAT_ERROR;
    }
  }

  /*--------------------------------------
  Processing for a TEST command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    if (0 == dsatetsicall_crlp_response_fmt (parse_table,
                                             &res_buff_ptr,
                                             MULTI_INDEX_TEST))
    {
      DS_AT_MSG0_HIGH("Problem generating query response");
      result = DSAT_ERROR;
    }
  }
  else if (tok_ptr->op == (NA) )
  {
    /* Do nothing */
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_crlp_cmd */


/*===========================================================================

FUNCTION DSATETSICALL_CRLP_RESPONSE_FMT

DESCRIPTION
  This function generates the response for the +CRLP read & test
  commands.  The &V command respose is handled as well.  Data is
  extracted from data structure and formatted according to parameter flag.

DEPENDENCIES
  None

RETURN VALUE
  Returns number of characters in response buffer.

SIDE EFFECTS
  None

===========================================================================*/
dsat_num_item_type dsatetsicall_crlp_response_fmt
(
  const dsati_cmd_type  *parse_table,   /*  Ptr to cmd in parse table   */
  dsm_item_type * const *out_buff_ptr,  /*  Place to put response       */
  multi_index_fmt_e_type format        /*  Flag for format type        */
)
{
  byte name_buff[16];
  int size = 0;
  int result = 0;
  byte i;
  byte vindex;
  byte index1;
  byte index2;
  byte index3;
  byte index4;
  dsm_item_type * res_buff_ptr = *out_buff_ptr;

  /* Format the command name */
  (void)snprintf((char*)name_buff,
                       sizeof(name_buff),
                       "%s: ",
                       parse_table->name);
  res_buff_ptr->data_ptr[res_buff_ptr->used] = '\0';

  switch (format)
  {
  case MULTI_INDEX_TEST:
    for (i=0; i < MAX_CRLP_VERSIONS; i++)
    {
      /* Determine which default set for version */
      vindex = rlpv_xref[ i ];
      
      size = snprintf ((char *)res_buff_ptr->data_ptr, 
                      res_buff_ptr->size,
                      "%s%s%s(%d-%d),(%d-%d),(%d-%d),(%d-%d),%d",
                      res_buff_ptr->data_ptr,
                      (i > 0) ? "\n" : "",
                      name_buff,
                      dsat_crlp_dflm[vindex][CRLP_IWS].lower,
                      dsat_crlp_dflm[vindex][CRLP_IWS].upper,
                      dsat_crlp_dflm[vindex][CRLP_MWS].lower,
                      dsat_crlp_dflm[vindex][CRLP_MWS].upper,
                      dsat_crlp_dflm[vindex][CRLP_T1].lower,
                      dsat_crlp_dflm[vindex][CRLP_T1].upper,
                      dsat_crlp_dflm[vindex][CRLP_N2].lower,
                      dsat_crlp_dflm[vindex][CRLP_N2].upper,
                      i
                     );
    }
    res_buff_ptr->used = (uint16)size;
    result = size;
    break;

  case MULTI_INDEX_READ:
    for (i=0; i < MAX_CRLP_VERSIONS; i++)
    {
     CRLP_SIZE(i ,CRLP_IWS,index1)
     CRLP_SIZE(i ,CRLP_MWS,index2)
     CRLP_SIZE(i ,CRLP_T1,index3)
     CRLP_SIZE(i ,CRLP_N2,index4)
      size = snprintf (
       (char *)res_buff_ptr->data_ptr,
        res_buff_ptr->size, 
        "%s%s%s%d,%d,%d,%d,%d",
        res_buff_ptr->data_ptr,
       (i > 0) ? "\n" : "",
        name_buff,
       (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CRLP_IDX,0,index1,NUM_TYPE),
       (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CRLP_IDX,0,index2,NUM_TYPE),
       (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CRLP_IDX,0,index3,NUM_TYPE),
       (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CRLP_IDX,0,index4,NUM_TYPE),
        i
        );
    }
    res_buff_ptr->used = (uint16)size;
    result = size;
    break;

  case MULTI_INDEX_AMPV:
    size = res_buff_ptr->used;
    res_buff_ptr->used = (word)snprintf(
                                 (char *)res_buff_ptr->data_ptr,
                                 res_buff_ptr->size, 
                                 "%s%s",
                                 res_buff_ptr->data_ptr,
                                 name_buff);
    
    for (i=0; i < MAX_CRLP_VERSIONS; i++)
    {
      /* Check to see if a new DSM item is required */
      /* Reduce normal threshold by size of strings */
      res_buff_ptr = dsatutil_append_dsm_item(
                       res_buff_ptr, DSM_BUFFER_THRESHOLD);
      /* If buffer appended, reset linesize */
      if ( size > res_buff_ptr->used)
      {
        size = res_buff_ptr->used;
        res_buff_ptr->data_ptr[res_buff_ptr->used++] = ' '; 
        res_buff_ptr->data_ptr[res_buff_ptr->used] = '\0';
#if 0 /* future need, if reqd */
        *out_buff_ptr = res_buff_ptr;
#endif
      }
      CRLP_SIZE(i ,CRLP_IWS,index1)
      CRLP_SIZE(i ,CRLP_MWS,index2)
      CRLP_SIZE(i ,CRLP_T1,index3)
      CRLP_SIZE(i ,CRLP_N2,index4)
      res_buff_ptr->used = (word)snprintf (
       (char *)res_buff_ptr->data_ptr,
        res_buff_ptr->size,  
        "%s%s(%d,%d,%d,%d,%d)",
        res_buff_ptr->data_ptr,
       (i > 0) ? "," : "",
       (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CRLP_IDX,0,index1,NUM_TYPE),
       (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CRLP_IDX,0,index2,NUM_TYPE),
       (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CRLP_IDX,0,index3,NUM_TYPE),
       (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CRLP_IDX,0,index4,NUM_TYPE),
        i);
    }
    result = (res_buff_ptr->used - size);
    res_buff_ptr->used -= (word)result;  /* caller increments used */
    break;

  default:
    DS_AT_MSG0_HIGH("Unsupported format type");
  }
  return (dsat_num_item_type)result;
}  /* dsatetsicall_crlp_response_fmt */



/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CV120_CMD

DESCRIPTION
  This function takes the result from the command line parser and
  executes it. It executes +CV120 command. It is used to set the V.120
  rate adaption paramaters for the CS Data stack.

DEPENDENCIES
  The values exported may or may not be appropriate for the mode-specific
  handler.  Validation in mode-specific handler is assumed. 
  
RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cv120_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_ERROR;
  dsat_num_item_type  temp_cv120;
  /* Processing for WRITE syntax */
  if ( (tok_ptr->op == (NA|EQ|AR)) )
  {
    /* Perform default paramater processing */
    if (DSAT_OK == dsatparm_exec_param_cmd( mode,
                                            parse_table,
                                            tok_ptr,
                                            res_buff_ptr ))
    {
      uint8 i;
      dsat_num_item_type tmp_dsat_cv120_export_val = 0;
      
      /* Populate the exported values */
      dsat_set_cv120_export_val(tmp_dsat_cv120_export_val);
      
      for(i=0; i < (uint8)DSAT_CV120_MAX_POS; i++)
      {
        temp_cv120 = (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CV120_IDX,0,i,NUM_TYPE);
	tmp_dsat_cv120_export_val |= temp_cv120 << i;
	dsat_set_cv120_export_val(tmp_dsat_cv120_export_val); 
      }
      result = DSAT_OK;
    }
  }
  /* Processing for TEST and READ syntax */
  else if ( (tok_ptr->op == (NA|EQ|QU)) ||
            (tok_ptr->op == (NA|QU)) ||
            (tok_ptr->op == (NA)) )
  {
    result = dsatparm_exec_param_cmd( mode,
                                      parse_table,
                                      tok_ptr,
                                      res_buff_ptr );

    /* For default case, export default parameters */
    if (tok_ptr->op == (NA))
    {
     dsat_set_cv120_export_val((dsat_num_item_type)DSAT_CV120_DEFAULT_VALUE);
    }
  }

  return result;
} /* dsatetsicall_exec_cv120_cmd */

#endif /* defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS) */


/*===========================================================================
FUNCTION DSATETSICALL_INIT_CALL_PARAM_FROM_NV

DESCRIPTION
  This function reads call setup defaults from NV.  If paramaters are
  unintialized, intial values are written basd on current build
  configuration.
    
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  NV parameters are updated if not previously initialized.
  
===========================================================================*/
void dsatetsicall_init_call_param_from_nv
(
  void
)
{
#if defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS)
  nv_stat_enum_type    status;
 
  /*-------------------------------------------------------------------------
    Get default RLP version from NV. Look at the status returned.
    If status !=NV_DONE_S, then either NV was never written or it cannot
    be reused. 
  -------------------------------------------------------------------------*/
  memset ((void*)&ds_nv_item, 0, sizeof(ds_nv_item));
  status = dsatutil_get_nv_item( NV_DS_ATCOP_RLP_VERSION_DEFAULT_I, 
                                 &ds_nv_item );
  if ( NV_DONE_S == status )
  {
    /*-----------------------------------------------------------------------
      Store value retrieved from NV.
    -----------------------------------------------------------------------*/
    if (CRLP_DEFAULT_MAX > (dsatetsicall_rlp_version_e_type)ds_nv_item.ds_atcop_rlp_version_default)
    {
      dsatetsicall_crlp_version_default = (dsatetsicall_rlp_version_e_type)
        ds_nv_item.ds_atcop_rlp_version_default;
    }
    else
    {
      /* Stored value exceeds known value range */
      DS_AT_MSG3_ERROR("NV value for CRLP default version out of range: %d [%d,%d]",
                 ds_nv_item.ds_atcop_rlp_version_default, CRLP_DEFAULT_V0, CRLP_DEFAULT_V2 );
    }
  }
#endif /* defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS) */

} /* dsatetsicall_init_call_param_from_nv */



/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CAOC_CMD

DESCRIPTION
  This function takes the result from the command line parser and
  executes it. It executes +CAOC command, which enables/disables
  unsolitited result codes for advice of charge supplementary service.
  In addition, the current value of accumulated call meter may be
  queried from the SIM/USIM via CM API.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_ASYNC_CMD : if aynchronous command continues successfully
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  Unsolicited result codes may be generated at a future time if enabled.
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_caoc_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsat_num_item_type prev_caoc_val = (dsat_num_item_type)dsatutil_get_val(
                                   DSATETSI_EXT_ACT_CAOC_ETSI_IDX,0,0,NUM_TYPE); 
  dsatetsicall_call_state_ms_info  *call_ms_val = NULL;
  
  call_ms_val = dsat_get_base_addr_current_subs(DSAT_CALL_MS_VALS);

  /*---------------------------------------------------------
   Processing for a WRITE, READ, TEST command
  -----------------------------------------------------------*/
  if ((tok_ptr->op == (NA|EQ|AR) ) ||
      (tok_ptr->op == (NA|EQ|QU) ) ||
      (tok_ptr->op == (NA|QU) ) ||
      (tok_ptr->op == (NA) ))
  {
    result =
      dsatparm_exec_param_cmd(mode, parse_table, tok_ptr, res_buff_ptr);

    /* Handle WRITE syntax */
    if ((DSAT_OK == result) &&
        (tok_ptr->op == (NA|EQ|AR)))
    {
      dsat_timer_s_type *t_ptr = &dsatutil_timer_table[DSAT_TIMER_CAOC_REPORT];
      
      /* Query for the current call meter value */
      if (0 == (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_ACT_CAOC_ETSI_IDX,0,0,NUM_TYPE))
      {
        etsicall_report_aoc_ccm (res_buff_ptr);
        
        /* Restore previous value */
        DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_CAOC_ETSI_IDX,0,0,0,prev_caoc_val,NUM_TYPE)
      }
      else if (1 == (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_ACT_CAOC_ETSI_IDX,0,0,NUM_TYPE))
      {
        /* Abort timer if active */
        if ( TRUE == t_ptr->is_running )
        { 
          (void) rex_clr_timer(t_ptr->timer_ptr);
          t_ptr->is_running = FALSE;
        }
      }  
      else /* (2 == dsat_caoc_val) */
      {
        /* Initialize the previous value */
#ifdef FEATURE_DUAL_SIM
        call_ms_val->etsicall_prev_ccm_val = 
           cm_ph_cmd_aoc_get_ccm_per_subs(dsat_get_current_subs_id(FALSE));
#else
        call_ms_val->etsicall_prev_ccm_val = cm_ph_cmd_aoc_get_ccm();
#endif /* FEATURE_DUAL_SIM */
        /* Start timer for unsolicited result reporting */
        (void) rex_set_timer( t_ptr->timer_ptr, t_ptr->duration );
        t_ptr->is_running = TRUE;
      }
    }
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_caoc_cmd */

#ifdef FEATURE_DATA_ETSI_PIN

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CACM_CMD

DESCRIPTION
  This function takes the result from the command line parser and
  executes it. It executes +CACM command, which reports the
  accumulated call meteter from the SIM/USIM.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cacm_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsatetsicall_call_state_ms_info  *call_ms_val = NULL;
  dsatme_mmgsdi_state_ms_info  *me_ms_val = NULL;

  me_ms_val = dsat_get_base_addr_current_session();
  call_ms_val = dsat_get_base_addr_current_subs(DSAT_CALL_MS_VALS);

  /*---------------------------------------------------------
   Processing for a WRITE command
  -----------------------------------------------------------*/
  if ((tok_ptr->op == (NA|EQ|AR) ) ||
      (tok_ptr->op == (NA) ))
  {
    byte pin_buffer[MMGSDI_PIN_MAX_LEN + 1];
    dsatutil_reset_password(pin_buffer, sizeof(pin_buffer));

    /* Process password paramater */
    if ( VALID_TOKEN(0) )
    {
      /* Strip quotes */
      if (( '"' == *tok_ptr->arg[0] ) &&
          ( TRUE != dsatutil_strip_quotes_out(tok_ptr->arg[0],
                                              pin_buffer,
                                              (word)sizeof(pin_buffer)) ))
      {
        return DSAT_ERROR;
      }
      /* PIN2 verification is made mandatory for CACM command 
       * if the PIN is provided */

      /* Ensure password was entered */
      if (0xFF != pin_buffer[0])
      {
        result = dsatetsime_verify_pin (MMGSDI_PIN2,
                                        pin_buffer,
                                        CACM_MMGSDI_PIN2_VERIFY);
        
        dsatutil_reset_password(pin_buffer, sizeof(pin_buffer));
      }
      else
      {
        DS_AT_MSG0_ERROR("PIN2 not specified");
        result = DSAT_ERROR;
      }
    }
    /* If PIN2 is not provided, check for PIN2 enabled 
     * on slot selected by $QCSLOT */
    else if ( IS_VALID_SLOT_ID(dsat_get_current_slot_id()) &&
              IS_PIN_STATE(DSAT_CPIN_SIM_PIN2_REQUIRED)
            )
    {
      DS_AT_MSG0_ERROR("PIN2 enabled but not specified");
      /* If attempted verification of pin2 failed due to incorrect pin
         show this result in next +CPIN command response */
      me_ms_val->dsat_mask_pin2_state = FALSE;
      result = dsat_send_cme_error (DSAT_CME_SIM_PIN2_REQUIRED);
    }
    else 
    {
      /* Send command to Call Manager to reset ACM value */
      result = dsatetsicmif_aoc_reset_acm();
    }
  }
  /*---------------------------------------------------------
   Processing for a READ command
  -----------------------------------------------------------*/
  else if (tok_ptr->op == (NA|QU))
  {
    /* Query Call Manager for accumulated call meter */
    call_ms_val->dsat_acm_res_type = DSAT_ACM_READ;
#ifdef FEATURE_DUAL_SIM
    if ( TRUE != cm_ph_cmd_get_ph_info_per_subs(dsatcmif_ph_cmd_cb_func,
                                    NULL,
                                    dsatcm_client_id,
                                    dsat_get_current_subs_id(FALSE)) )
    {
      call_ms_val->dsat_acm_res_type = DSAT_ACM_NONE;
      DS_AT_MSG0_ERROR("Unable to retreive phone information");
    }
#else
    if ( TRUE != cm_ph_cmd_get_ph_info(dsatcmif_ph_cmd_cb_func,
                                    NULL,
                                    dsatcm_client_id
                                    ) )
    {
      call_ms_val->dsat_acm_res_type = DSAT_ACM_NONE;
      DS_AT_MSG0_ERROR("Unable to retreive phone information");
    }
#endif /* FEATURE_DUAL_SIM */
    result = DSAT_ASYNC_CMD;
  }
  /*---------------------------------------------------------
   Processing for a TEST command
  -----------------------------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU))
  {
    /* Do nothing */
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_cacm_cmd */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CAMM_CMD

DESCRIPTION
  This function takes the result from the command line parser and
  executes it. It executes +CAMM command, which reports or resets the 
  accumulated call meter maximum from the SIM/USIM.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_camm_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  #define DEF_ACMMAX_VALUE ((uint32)0xFFFFFFFF)

  dsat_result_enum_type result = DSAT_OK;
  dsatetsicall_call_state_ms_info  *call_ms_val = NULL;
  dsatme_mmgsdi_state_ms_info  *me_ms_val = NULL;
  
  me_ms_val = dsat_get_base_addr_current_session();
  call_ms_val = dsat_get_base_addr_current_subs(DSAT_CALL_MS_VALS);

  /*---------------------------------------------------------
   Processing for a WRITE command
  -----------------------------------------------------------*/
  if ((tok_ptr->op == (NA|EQ|AR) ) ||
      (tok_ptr->op == (NA) ))
  {
    /* Handle WRITE syntax */
    if (tok_ptr->op == (NA|EQ|AR))
    {
      byte pin_buffer[MMGSDI_PIN_MAX_LEN + 1];
      dsatutil_reset_password(pin_buffer, sizeof(pin_buffer));
      call_ms_val->etsicall_acmmax = DEF_ACMMAX_VALUE;
      
      /* Process ACM max paramater */
      if ( VALID_TOKEN(0) )
      {
        byte buffer[8];
        byte *acm_buf = buffer;
        
        /* Strip quotes */
        buffer[0] = '\0';
        if (( '"' == *tok_ptr->arg[0] ) &&
            ( TRUE != dsatutil_strip_quotes_out(tok_ptr->arg[0],
                                                acm_buf,
                                                (word)sizeof(buffer)) ))
        {
          return DSAT_ERROR;
        }
        acm_buf = ('\0' == buffer[0])? tok_ptr->arg[0] : buffer;
        
        /* Convert ACM max paramter to integer */
        if (ATOI_OK != dsatutil_atoi(&call_ms_val->etsicall_acmmax, acm_buf, 16))
        {
          DS_AT_MSG0_ERROR("Cannot convert ACMMAX parameter");
          return DSAT_ERROR;
        }
      }

      /* Process password paramater */
      if ( VALID_TOKEN(1) )
      {
        /* Strip quotes */
        if (( '"' == *tok_ptr->arg[1] ) &&
            ( TRUE != dsatutil_strip_quotes_out(tok_ptr->arg[1],
                                                pin_buffer,
                                                (word)sizeof(pin_buffer)) ))
        {
          return DSAT_ERROR;
        }
        /* Continue if ACM max parameter OK */
        if ( DEF_ACMMAX_VALUE != call_ms_val->etsicall_acmmax )
        {
          /* PIN2 verification is made mandatory for CACM command 
           * if the PIN2 is provided */
          /* Ensure password was entered */
          if (0xFF != pin_buffer[0])
          {
            result = dsatetsime_verify_pin (MMGSDI_PIN2,
                                            pin_buffer,
                                            CAMM_MMGSDI_PIN2_VERIFY);
        
            dsatutil_reset_password(pin_buffer, sizeof(pin_buffer));
          }
          else
          {
            DS_AT_MSG0_ERROR("PIN2 not specified");
            result = DSAT_ERROR;
          }
        }
      } /* Check for PIN2 enabled on slot selected by $QCSLOT 
         * if PIN2 is not provided */
      else if ( IS_VALID_SLOT_ID(dsat_get_current_slot_id()) &&
                IS_PIN_STATE(DSAT_CPIN_SIM_PIN2_REQUIRED)
              )
      {
        DS_AT_MSG0_ERROR("PIN2 enabled but not specified");
        /* If attempted verification of pin2 failed due to incorrect pin
           show this result in next +CPIN command response */
        me_ms_val->dsat_mask_pin2_state = FALSE;
        result = dsat_send_cme_error (DSAT_CME_SIM_PIN2_REQUIRED);
      }
      else if (DEF_ACMMAX_VALUE != call_ms_val->etsicall_acmmax )
      {
        /* Send command to Call Manager */
        result = dsatetsicmif_aoc_set_acmmax ( call_ms_val->etsicall_acmmax );
      }
      else
      {
        DS_AT_MSG0_ERROR("Wrong ACMMAX value specified");
        result = DSAT_ERROR;
      }
    }
  }
  /*---------------------------------------------------------
   Processing for a READ command
  -----------------------------------------------------------*/
  else if (tok_ptr->op == (NA|QU))
  {
    call_ms_val->dsat_acm_res_type = DSAT_ACM_MAX_READ;
#ifdef FEATURE_DUAL_SIM
    if ( TRUE != cm_ph_cmd_get_ph_info_per_subs(dsatcmif_ph_cmd_cb_func,
                                    NULL,
                                    dsatcm_client_id,
                                    dsat_get_current_subs_id(FALSE)
                                    ) )
    {
      call_ms_val->dsat_acm_res_type = DSAT_ACM_NONE;
      DS_AT_MSG0_ERROR("Unable to retreive phone information");
    }
#else
    if ( TRUE != cm_ph_cmd_get_ph_info(dsatcmif_ph_cmd_cb_func,
                                    NULL,
                                    dsatcm_client_id
                                    ) )
    {
      call_ms_val->dsat_acm_res_type = DSAT_ACM_NONE;
      DS_AT_MSG0_ERROR("Unable to retreive phone information");
    }
#endif /* FEATURE_DUAL_SIM */
    result = DSAT_ASYNC_CMD;
  }
  /*---------------------------------------------------------
   Processing for a TEST command
  -----------------------------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU))
  {
    /* Do nothing */
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_camm_cmd */

/*===========================================================================

FUNCTION  DSATETSICALL_AOC_VERIFY_PIN_HANDLER

DESCRIPTION
  This function is the handler function for the +CACM/+CAMM commands
  PIN2 verification.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_OK      - if subcommand executed successfully
  DSAT_ERROR   - if error encountered

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_aoc_verify_pin_handler
(
  const ds_at_cmd_status_type *cmd_ptr
)
{
  dsat_result_enum_type result =  DSAT_ASYNC_EVENT;
  dsatetsicall_call_state_ms_info  *call_ms_val = NULL;
  
  call_ms_val = dsat_get_base_addr_current_subs(DSAT_CALL_MS_VALS);

  /* Call the appropriate set function */
  switch (cmd_ptr->cmd_id)
  {
  case CACM_MMGSDI_PIN2_VERIFY:
    result = dsatetsicmif_aoc_reset_acm ();
    break;
      
  case CAMM_MMGSDI_PIN2_VERIFY:
    result = dsatetsicmif_aoc_set_acmmax ( call_ms_val->etsicall_acmmax );
    break;
      
  default:
    DS_AT_MSG1_MED("Invalid PIN Verify cmd_id: %d",
            cmd_ptr->cmd_id);
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_caoc_timer_expired_handler */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CPUC_CMD

DESCRIPTION
  This function takes the result from the command line parser and
  executes it. It executes +CPUC command, which reports or sets the 
  Price per Unit and Currency table from the SIM/USIM.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cpuc_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsat_num_item_type cscs_val ;
  dsat_error_info_s_type    err_info;

  err_info.errval = DSAT_ERR_NO_ERROR;
  err_info.arg_num = 0;
  
  /*---------------------------------------------------------
   Processing for a WRITE command
  -----------------------------------------------------------*/
  if (tok_ptr->op == (NA|EQ|AR) )
  {
    byte buffer[CPUC_MAX_PARAM_STR_LEN+1];
    byte pin_buffer[MMGSDI_PIN_MAX_LEN+1];
    char cscurcode[(4*CPUC_CURCODE_STR_LEN)+1];
    byte *cur_buf, *ppu_buf;
    dsatetsicall_call_state_ss_info  *call_ss_val = NULL;
    dsatme_mmgsdi_state_ms_info      *me_ms_val   = NULL;
    
    me_ms_val = dsat_get_base_addr_current_session();
    call_ss_val = dsat_get_base_addr(DSAT_CALL_SS_VALS, FALSE);
    
    memset( (void*)call_ss_val->dsatetsicall_cpuc_mmgsdi_data, 0x0,DSAT_PUCT_LEN );
    dsatutil_reset_password(pin_buffer, sizeof(pin_buffer));
    
    /* Process Currency code paramater */
    if ( VALID_TOKEN(0) )
    {
        
      /* Strip quotes */
      memset((void*)buffer, 0x0, sizeof(buffer));
      /* CPUC currency code should be exactly 5 characters */
      if ( !(strlen((char *)tok_ptr->arg[0])== 5))
        {
          return DSAT_ERROR;
        }
            
      if ( TRUE != dsatutil_strip_quotes_out(tok_ptr->arg[0],
                                             buffer,
                                             (word)sizeof(buffer)) )
      {
        err_info.errval = DSAT_ERR_QUOTE_STRIP_FAILURE;
        err_info.arg_num = 0;
        goto send_error;
      }
      cur_buf = ('\0' == buffer[0])? tok_ptr->arg[0] : buffer;
        
      /* Convert to internal character set */
     (void) dsatutil_memscpy((void*)cscurcode,
             sizeof(cscurcode),(void*)buffer,sizeof(cscurcode)); 
     /* Convert string to ALPHA_GSM_WITH_AT which replaces the special character 
        usage of GSM @ to its original values 0x00.(if any) apart 
        from conversion from present TE chset to GSM*/
      cscs_val =(dsat_num_item_type)dsatutil_get_val(
                                           DSATETSI_EXT_CSCS_IDX,0,0,NUM_TYPE);
      if (NULL == dsatutil_convert_chset( (char*)cur_buf,
                         (dsati_chset_type)cscs_val,
                                               cscurcode, 
                                       ALPHA_GSM_WITH_AT,
                                       sizeof(cscurcode),
                                                 FALSE ))
      {
        /* Report CME error */
        dsatme_set_cme_error ( DSAT_CME_INVALID_CHAR_IN_TEXT,
                                   res_buff_ptr );
        return DSAT_CMD_ERR_RSP;
      }
      cur_buf = (byte*)cscurcode;

      /* Setup SIM encoding per 3GPP TS31.102 section 4.2.13 */
      /* Currency code is bytes 0..2 */
    (void) dsatutil_memscpy((void*)call_ss_val->dsatetsicall_cpuc_mmgsdi_data,
            DSAT_PUCT_LEN,(void*)cur_buf,CPUC_CURCODE_STR_LEN);
      
    }
    else
    {
      /* Currency code is mandatory parameter */
      err_info.errval = DSAT_ERR_PARAMETER_MANDATORY;
      err_info.arg_num = 0;
      goto send_error;
    }

    /* Process PPU parameter */
    if ( VALID_TOKEN(1) )
    {
      byte *digit;
      int32 expn = 0; 
      uint32 accum = 0;
      uint8 sign;
      boolean decimal_found = FALSE;
      boolean truncate = FALSE;

      /* Strip quotes */
      memset((void*)buffer, 0x0, sizeof(buffer));
      if ( TRUE != dsatutil_strip_quotes_out(tok_ptr->arg[1],
                                             buffer,
                                             (word)sizeof(buffer)) )
      {
        err_info.errval = DSAT_ERR_QUOTE_STRIP_FAILURE;
        err_info.arg_num = 1;
        goto send_error;
      }
      ppu_buf = ('\0' == buffer[0])? tok_ptr->arg[1] : buffer;

      /* Convert float string to SIM representation */
      digit = ppu_buf;
      while ('\0' != *digit)
      {
        /* Check for invalid character */
        if ( (('0' > *digit) || ('9' < *digit)) && ('.' != *digit) )
        {
          DS_AT_MSG0_ERROR("Invalid character in real number string");
          return DSAT_ERROR;
        }

        /* Check for decimal point */
        if ('.' == *digit)
        {
          if (TRUE == decimal_found)
          {
            DS_AT_MSG0_ERROR("Multiple decimals in real number string");
            return DSAT_ERROR;
          }
          decimal_found = TRUE;
        }
        else
        {
          uint32 new_accum = 10*accum + (*digit - '0');

          /* Check for accumulator overflow */
          if (CPUC_MAX_PPU_ACCUM < new_accum)
          {
            /* If decimal point found, skip further digit processing */
            if (TRUE == decimal_found)
            {
              /* Check for roundup (current digit > 4) */
              if ('4' < *digit)
                accum += 1;
              break;
            }
            /* Overflow condition so truncate further accumulation. */
            /* Keep processing digits to get correct exponent.      */
            else
            {
              truncate = TRUE;
              /* Check for roundup (current digit > 4) */
              if ('4' < *digit)
                accum += 1;
            }
          }

          /* Update exponent */
          if ( (TRUE == decimal_found) ||     /* fraction    */
               (TRUE == truncate ) )          /* truncation  */
          {
            expn += (TRUE == decimal_found)? -1 : 1;
          }

          /* Update accumulator if liit not reached */
          if (FALSE == truncate)
          {
            accum = new_accum;
          }
        }
        /* Advance digit pointer */                                     
        digit++;
      }

      sign = (0 > expn)? 1 : 0;  /* negative = 1, positive = 0 */

      expn = (sign)? (-1 * expn) : expn;  /* abs(expn) */
      if (CPUC_MAX_PPU_EXPN < expn)
      {
         DS_AT_MSG0_ERROR("PPU exponent exceeds limit");
         return DSAT_ERROR;
      }

      /* Setup SIM encoding per 3GPP TS31.102 section 4.2.13 */
      /* PPU is bytes 3..4 */
      call_ss_val->dsatetsicall_cpuc_mmgsdi_data[3] = (byte) (accum >> 4);        /* 2^b4-11 */
      call_ss_val->dsatetsicall_cpuc_mmgsdi_data[4] = (byte) ((accum & 0xF) +      /* 2^b0-2  */
                                              (sign << 4) +
                                               ((expn & 0x7) << 5)); 
    }
    else
    {
      /* PPU is mandatory parameter */
      err_info.errval = DSAT_ERR_PARAMETER_MANDATORY;
      err_info.arg_num = 1;
      goto send_error;
    }

    /* Process password paramater */
    if ( VALID_TOKEN(2) )
    {
      /* Strip quotes */
      if ( TRUE != dsatutil_strip_quotes_out(tok_ptr->arg[2],
                                             pin_buffer,
                                             (word)sizeof(pin_buffer)) )
      {
        err_info.errval = DSAT_ERR_QUOTE_STRIP_FAILURE;
        err_info.arg_num = 2;
        goto send_error;
      }
    }
    
    /* Verify the password provided, irrespective of the SIM PIN2 status */
    if (DSAT_SIM_PADDING != pin_buffer[0])
    {
      result = dsatetsime_verify_pin (MMGSDI_PIN2,
                                      pin_buffer,
                                      CPUC_MMGSDI_PIN2_VERIFY);
        
      dsatutil_reset_password(pin_buffer, sizeof(pin_buffer));
    }  /* Check for PIN2 enabled on slot selected by $QCSLOT */
    else  if ( IS_VALID_SLOT_ID(dsat_get_current_slot_id()) &&
               IS_PIN_STATE(DSAT_CPIN_SIM_PIN2_REQUIRED)
             )
    {
      DS_AT_MSG0_ERROR("PIN2 enabled but not specified");
      /* If attempted verification of pin2 failed due to incorrect pin
         show this result in next +CPIN command response */
      me_ms_val->dsat_mask_pin2_state = FALSE;
      result = dsat_send_cme_error(DSAT_CME_SIM_PIN2_REQUIRED);
    }
    else
    {
      /* Send write command to GSDI */
      result = dsatetsicall_cpuc_mmgsdi_write (NULL);
    }
  }
  /*---------------------------------------------------------
   Processing for a READ command
  -----------------------------------------------------------*/
  else if (tok_ptr->op == (NA|QU))
  {
    if ( DSAT_ERROR != dsatetsime_sim_read( CPUC_MMGSDI_SIM_READ ) )
    {
      result = DSAT_ASYNC_CMD;
    }
    /* Problem reading the SIM PUC EF */
    else
    {
      dsatme_set_cme_error(DSAT_CME_SIM_FAILURE, res_buff_ptr);
      result = DSAT_CMD_ERR_RSP;
    }
  
  }
  /*---------------------------------------------------------
   Processing for a TEST command
  -----------------------------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU))
  {
    /* Do nothing */
  }
  else
  {
    /* wrong operation */
    err_info.errval = DSAT_ERR_INVALID_SYNTAX;
    goto send_error;
  }
  
  return result;

send_error:
  if( err_info.errval == DSAT_ERR_INVALID_SYNTAX )
  {
    DS_AT_MSG1_ERROR("Error:%d",err_info.errval);
  }
  else
  {
    DS_AT_MSG2_ERROR("Error:%d, arg_num:%d",err_info.errval,err_info.arg_num);
  }
  return DSAT_ERROR;

} /* dsatetsicall_exec_cpuc_cmd */


/*===========================================================================

FUNCTION DSATETSICALL_CPUC_GSDI_WRITE

DESCRIPTION
  This function write the Price per Unit and Currency table
  to the SIM/USIM.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP:  if there was any problem in executing the command 
  DSAT_ASYNC_CMD :   if it is a success.

SIDE EFFECTS
  None.

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type  dsatetsicall_cpuc_mmgsdi_write
(
  ds_at_cmd_status_type *cmd_ptr
)
{
  dsat_result_enum_type result = DSAT_ASYNC_CMD;
  dsatetsicall_call_state_ss_info  *call_ss_val = NULL;
  
  call_ss_val = dsat_get_base_addr(DSAT_CALL_SS_VALS, FALSE);

  /* Write PUCT to GSDI after PIN2 verified */
  if ( DSAT_ERROR ==
       dsatetsime_sim_write( CPUC_MMGSDI_SIM_WRITE,
                             call_ss_val->dsatetsicall_cpuc_mmgsdi_data,
                             DSAT_PUCT_LEN) )
  {
    dsm_item_type *res_buff_ptr;

    res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);
    dsatme_set_cme_error(DSAT_CME_SIM_FAILURE, res_buff_ptr);
    DSAT_SEND_RESPONSE( res_buff_ptr, DSAT_COMPLETE_RSP );
    result = DSAT_CMD_ERR_RSP;
  }
  
  return result;
} /* dsatetsicall_cpuc_gsdi_write() */


/*===========================================================================

FUNCTION DSATETSICALL_REPORT_CPUC

DESCRIPTION
  This function reports the Price per Unit and Currency table
  stored in the SIM/USIM.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP:  if there was any problem in executing the command 
  DSAT_OK :          if it is a success.

SIDE EFFECTS
  None.

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_report_cpuc
(
  ds_at_mmgsdi_sim_info_type *sim_info_ptr /* MMGSDI SIM info pointer */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsm_item_type * res_buff_ptr = NULL;
  uint8  mmgsdi_status;

  char curcode[CPUC_CURCODE_STR_LEN+1];
  char cscurcode[(4*CPUC_CURCODE_STR_LEN)+1];
  char * cur_ptr = NULL;
  byte * buf_ptr = NULL;
  dsat_num_item_type cscs_val ;

  mmgsdi_status = sim_info_ptr->cmd_status;
  
  if (mmgsdi_status != (uint8)MMGSDI_SUCCESS)
  {
    result = dsat_send_cme_error(DSAT_CME_SIM_FAILURE);
    return DSAT_CMD_ERR_RSP;
  }

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);

  /* Check for undefined +CPUC */
  buf_ptr = sim_info_ptr->data;
  if( DSAT_SIM_PADDING == *buf_ptr )
  {
    /* +CPUC not specified in SIM, send empty response */
    res_buff_ptr->used = (word)snprintf ((char*)res_buff_ptr->data_ptr,
                                               res_buff_ptr->size, 
                                               "+CPUC: "); 
  }
  else
  {
    /* Convert SIM/USIM format to display format */
    /* Bytes 0-2: currency code */
    memset((void*)curcode, 0x0, sizeof(curcode));

    /* Adjust for character set */

    /* Data is comming from GSDI module in GSM character set;
       This should be converted to replace GSM @ (0x00) characters if any */
    if (! dsatutil_convert_alpha_gsm_with_at_to_alpha_gsm ( 
                        (const char *)buf_ptr , curcode, CPUC_CURCODE_STR_LEN ) )
    {
      DS_AT_MSG0_ERROR(" Invalid string received from GSDI");
      /* Report CME error */
      dsatme_set_cme_error ( DSAT_CME_INVALID_CHAR_IN_TEXT,
                                res_buff_ptr );
      result = DSAT_CMD_ERR_RSP;
    }
    else if ( (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CSCS_IDX,
                   0,0,NUM_TYPE) != (dsat_num_item_type)CPUC_CURCODE_SIM_CSET )
    {
      memset((void*)cscurcode, 0x0, sizeof(cscurcode));
      cscs_val =(dsat_num_item_type)dsatutil_get_val(
                                           DSATETSI_EXT_CSCS_IDX,0,0,NUM_TYPE);
      if (NULL == dsatutil_convert_chset( curcode, 
                                          CPUC_CURCODE_SIM_CSET,
                                          cscurcode,
                                          (dsati_chset_type)cscs_val,
                                          sizeof(cscurcode),
                                          FALSE ))
      {
        /* Report CME error */
        dsatme_set_cme_error ( DSAT_CME_INVALID_CHAR_IN_TEXT,
                                   res_buff_ptr );
        result = DSAT_CMD_ERR_RSP;
      }
      else
      {
        cur_ptr = cscurcode;
      }
    }
    else
    {
      cur_ptr = curcode;
    }

    if ( DSAT_OK == result )
    {
      int32 i;
      uint8 expn;
      int8 sign;
      uint16 eppu;
      float factor = 1;
    
      /* Bytes 3-4: encoded  price per unit */
      sign = (buf_ptr[4] & 0x10) >> 4;      /* exponent sign: 0=positive,
                                               1=negative  */
      expn = (buf_ptr[4] >> 5);             /* exponent */
      eppu = (buf_ptr[3] << 4) + (buf_ptr[4] & 0x0F);

      for (i=expn; i>0; i--)
      {
        factor *= 10.0;
      }
      /* Format the response */
        if(sign)
        {
           res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                                 res_buff_ptr->size,
                                                 "+CPUC: \"%s\",\"%.4g\"", 
                                                  cur_ptr, eppu/factor);   
        }
        else
        {
           res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                                 res_buff_ptr->size,
                                                 "+CPUC: \"%s\",\"%.12g\"", 
                                                 cur_ptr, eppu*factor);   
        }
    }
  }
  
  DSAT_SEND_RESPONSE( res_buff_ptr, DSAT_COMPLETE_RSP );
  return result;
} /* dsatetsicall_report_cpuc */

#endif /* FEATURE_DATA_ETSI_PIN */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_COPS_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +COPS command, which list available networks and sets
  automatic/manual registration.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_CMD_ERR_RSP: if there was a problem in lower layers
    DSAT_ASYNC_CMD : if aynchronous command continues successfully
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cops_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type         result   = DSAT_OK;
  sys_modem_as_id_e_type        subs_id = dsat_get_current_subs_id(FALSE);
  dsatcmif_servs_state_ms_info *ph_ss_ms_val = NULL;
  cm_network_list_type_e_type   network_list_type = CM_NETWORK_LIST_AVAILABLE;
  dsat_cops_cmd_idx_e_type      temp_cmd_idx;
  byte                          temp_cmd_name[DSAT_COPS_CMD_NAME_SIZE];

  ph_ss_ms_val = dsat_get_base_addr_current_subs(DSAT_SS_PH_MS_VALS);

/*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
  memset ((void*)&(ph_ss_ms_val->dsatetsicall_network_list), 0x0,
            sizeof(ph_ss_ms_val->dsatetsicall_network_list));
  if(0 == (dsatutil_strncmp_ig_sp_case((const byte *)parse_table->name,
        (const byte *)"$QCCOPS" ,strlen((const char *)"$QCCOPS"))))
  {
    ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_QCCOPS;
  }
  else if(0 ==(dsatutil_strncmp_ig_sp_case((const byte *)parse_table->name,
        (const byte *)"$QCCSGCOPS" ,strlen((const char *)"$QCCSGCOPS"))))
  {
    ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_QCCSGCOPS;
  }
  else
  {
    ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_COPS;
  }  
  dsatutil_memscpy(&ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                   DSAT_COPS_CMD_NAME_SIZE,
                   tok_ptr->name,
                   strlen((const char*)tok_ptr->name)+1);

  if (tok_ptr->op == (NA|EQ|AR) )
  {
    dsat_num_item_type prev_mode = (dsat_num_item_type)dsatutil_get_val(
               DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,0,MIX_NUM_TYPE); /* list index */
      
    result = dsatparm_exec_param_cmd(mode, parse_table, tok_ptr, res_buff_ptr);

    if ( DSAT_OK == result )
    {
      /* Setup network selection operation */
      result =etsicall_setup_network_selection( parse_table, tok_ptr,
                                                        res_buff_ptr, prev_mode,
                                                &ph_ss_ms_val->net_pref );
    }
    if ( ( DSAT_ERROR == result ) || ( DSAT_CMD_ERR_RSP == result ) )
    {
      /* Restore previous COPS value in case of ERROR */
      DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,
                     0,0,(dsat_num_item_type)prev_mode,MIX_NUM_TYPE)
    }
    return result;
  }

  /*--------------------------------------
  Processing for a READ command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|QU) )
  {
    dsat_num_item_type mode_val = (dsat_num_item_type)dsatutil_get_val(
                       DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,0,MIX_NUM_TYPE);

    dsat_cops_fmt_e_type fmt = (dsat_num_item_type)dsatutil_get_val(
                       DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,1,MIX_NUM_TYPE);
      
    if ( FALSE == ph_ss_ms_val->dsat_net_reg_state.net_id_info.present )
    {
        res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                             res_buff_ptr->size, 
                                             "%s: %d",
                                              parse_table->name,
                                              mode_val );
    }
    else if( fmt == DSAT_COPS_FMT_PLMN )
    {
      dsat_cops_act_e_type net_act = ph_ss_ms_val->dsat_net_reg_state.act;
      boolean plmn_undefined = FALSE;
      sys_mcc_type mcc = 0;
      sys_mnc_type mnc = 0;
      boolean pcs_flag = FALSE;

          sys_plmn_get_mcc_mnc( ph_ss_ms_val->dsat_net_reg_state.net_id_info.plmn,
                                &plmn_undefined,
                                &pcs_flag,
                                &mcc,
                                &mnc );

          /* PLMN may be undefined */
          if (TRUE == plmn_undefined)
          {
       res_buff_ptr->used = (word)snprintf ((char*)res_buff_ptr->data_ptr,
                                         res_buff_ptr->size,
                                         "%s: %d,%d,\"\",%d",
                                         &ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                                         mode_val,
                                   fmt,
                                   net_act );
          }
          else
          {
            if ( pcs_flag )
            {
              /* Print MNC as 3 digits */
          res_buff_ptr->used = (word)snprintf ((char*)res_buff_ptr->data_ptr,
                                         res_buff_ptr->size,
                                          "%s: %d,%d,\"%03lu%03lu\",%d",
                                          &ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                                          mode_val,
                                          fmt,
                                          mcc,mnc,
                                          net_act );
            }
            else
            {
          res_buff_ptr->used = (word)snprintf ((char*)res_buff_ptr->data_ptr,
                                            res_buff_ptr->size,
                                            "%s: %d,%d,\"%03lu%02lu\",%d",
                                           &ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                                            mode_val,
                                     fmt,
                                     mcc,mnc,
                                     net_act );
            }
          }
 
       if(ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS &&
           SYS_CSG_ID_INVALID != ph_ss_ms_val->dsat_net_reg_state.net_id_info.csg_id )
       {
          res_buff_ptr->used += (word)snprintf ((char*)(res_buff_ptr->data_ptr + res_buff_ptr->used),
                                                (res_buff_ptr->size - res_buff_ptr->used),
                                                ",%lu,%d",
                                                ph_ss_ms_val->dsat_net_reg_state.net_id_info.csg_id,
                                                ph_ss_ms_val->dsat_net_reg_state.csg_rat);
       }
        }
    else
    {
#ifdef FEATURE_MMGSDI
      mmgsdi_plmn_id_list_type plmn_id_list;
      mmgsdi_plmn_id_type plmn_id;
      sys_sys_mode_e_type sys_act = ph_ss_ms_val->dsat_net_reg_state.sys_mode;

      plmn_id_list.num_of_plmn_ids = 1;

      (void) dsatutil_memscpy((void*)&plmn_id.plmn_id_val[0], MMGSDI_PLMN_ID_SIZE,
                      (void *)&ph_ss_ms_val->dsat_net_reg_state.net_id_info.plmn.identity[0],
                      MMGSDI_PLMN_ID_SIZE);

      if(ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS)
      {
        plmn_id.csg_id = ph_ss_ms_val->dsat_net_reg_state.net_id_info.csg_id;
      }
      else
      {
        plmn_id.csg_id = SYS_CSG_ID_INVALID;
      }

     switch(sys_act)
     {
       case SYS_SYS_MODE_WCDMA:
         plmn_id.rat = MMGSDI_RAT_UMTS;
         break;
#ifdef FEATURE_TDSCDMA
       case SYS_SYS_MODE_TDS:
#endif /* FEATURE_TDSCDMA */
         plmn_id.rat = MMGSDI_RAT_TDS;
         break;

       case SYS_SYS_MODE_LTE:
         plmn_id.rat = MMGSDI_RAT_LTE;
         break;

       case SYS_SYS_MODE_GSM:
         plmn_id.rat = MMGSDI_RAT_GSM;
         break;

       default:
         plmn_id.rat = MMGSDI_RAT_NONE;
         break;
     }

      plmn_id_list.plmn_list_ptr = &plmn_id;
      ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_GET_NAME;
      
      if( MMGSDI_SUCCESS == mmgsdi_session_get_operator_name_ext (
                dsat_get_current_gw_session_id(FALSE),
                plmn_id_list,
                MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND,
                dsatme_mmgsdi_get_operator_name_cb,
                DSAT_MMGSDI_GET_CURR_OPER_NAME) )
      {
        result = DSAT_ASYNC_CMD;
    }
    else
    {
        ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
        ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
        DS_AT_MSG0_ERROR("mmgsdi_session_get_operator_name API call failed");
        dsatme_set_cme_error(DSAT_CME_PHONE_FAILURE, res_buff_ptr);
        result = DSAT_CMD_ERR_RSP;
    }
#endif /* FEATURE_MMGSDI */
    }
  }

  /*--------------------------------------
  Processing for a TEST command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    /* Allocate command memory pointer for +COPS=? command */
    (void) dsat_alloc_cmd_mem_ptr(sizeof(dsat_sys_detailed_plmn_list_s_type));

    temp_cmd_idx = ph_ss_ms_val->dsatetsicall_network_list.cmd_idx;
    dsatutil_memscpy(&temp_cmd_name[0], DSAT_COPS_CMD_NAME_SIZE,
                     &ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                     DSAT_COPS_CMD_NAME_SIZE);
    
    memset ((void*)&ph_ss_ms_val->dsatetsicall_network_list, 0x0,
            sizeof(dsatetsicall_network_list_s_type));

    ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = temp_cmd_idx;
    dsatutil_memscpy(&ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                       DSAT_COPS_CMD_NAME_SIZE,
                       &temp_cmd_name[0], DSAT_COPS_CMD_NAME_SIZE);

    /* Preserve the current PLMN and network selection preference
     * to determine current provider */
    ph_ss_ms_val->dsatetsicall_network_list.previous_pref.plmn =
      ph_ss_ms_val->dsat_net_reg_state.net_id_info.plmn;
    ph_ss_ms_val->dsatetsicall_network_list.previous_pref.mode = 
      (dsat_cops_mode_e_type)(dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,0,MIX_NUM_TYPE);
    if(ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS)
    {
       network_list_type = CM_NETWORK_LIST_CSG;
    }
    /* Invoke network query from CM API; remaining processing done
     * asynchronously. */
    ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_ANETS;
    
    if ( DSAT_ERROR == dsatetsicmif_query_networks(network_list_type) )
    {
      ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
      ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
      dsatme_set_cme_error(DSAT_CME_NO_NETWORK_SERVICE, res_buff_ptr);
      return DSAT_CMD_ERR_RSP;
    }
    result = DSAT_ASYNC_CMD;
  }
  else if (tok_ptr->op == (NA) )
  {
    /* Do nothing */
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_cops_cmd */



/*===========================================================================

FUNCTION DSATETSICALL_COPS_ABORT_CMD_HANDLER

DESCRIPTION
  This function handles an abort command to terminate asynchronous
  processing for +COPS registration operation.  The network
  registration preferences before the last +COPS comamnd handler
  execution are restored.

DEPENDENCIES
  None

RETURN VALUE
  Value indicating whether or not command should be aborted:
      TRUE if call should be aborted, FALSE otherwise.

SIDE EFFECTS
  Allocates and submits command buffer to DS task

===========================================================================*/
/* ARGSUSED */
boolean dsatetsicall_cops_abort_cmd_handler
(
  const dsati_cmd_type *cmd_table_entry_ptr  /* Ptr to cmd entry in table. */
)
{
  boolean result = FALSE;

  cm_subscription_status_e_type status_one    = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  cm_subscription_status_e_type status_two    = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
  cm_subscription_status_e_type status_three  = CM_SUBSCRIPTION_STATUS_NO_CHANGE;

  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;
  ds_at_cmd_status_type         *status_cmd_ptr = NULL;

  ph_ss_ms_val = dsat_get_base_addr_current_subs(DSAT_SS_PH_MS_VALS);

  /* Abort operation only if network preference change underway */
  if( (DSAT_COPS_ASTATE_PREF == ph_ss_ms_val->dsatetsicall_network_list.cmd_state) ||
      (DSAT_COPS_ASTATE_WAIT == ph_ss_ms_val->dsatetsicall_network_list.cmd_state) || 
      (DSAT_COPS_ASTATE_WAIT_2 == ph_ss_ms_val->dsatetsicall_network_list.cmd_state) )
  {
    ds_cmd_type *cmd_ptr;

    DS_AT_MSG1_HIGH("COPS abort handler invoked: %d",
              ph_ss_ms_val->dsatetsicall_network_list.cmd_state);
    /* storing the mode,plmn and act value for further processing */
    ph_ss_ms_val->net_pref.mode = ph_ss_ms_val->dsatetsicall_network_list.previous_pref.mode;
    ph_ss_ms_val->net_pref.plmn = ph_ss_ms_val->dsatetsicall_network_list.previous_pref.plmn;
    ph_ss_ms_val->net_pref.act  = ph_ss_ms_val->dsatetsicall_network_list.previous_pref.act;
    /* Make best effort to restore old COPS mode */
    switch(ph_ss_ms_val->net_pref.mode)
    {
      case DSAT_COPS_MODE_DEREG:
        if (!ph_ss_ms_val->net_pref.last_dereg_success)
        {
          /* An ABORT is received after 
             CM_PH_EVENT_SUBSCRIPTION_AVAILABLE. Restore de-registration. */
          (void)dsatetsicmif_change_network_registration (ph_ss_ms_val->net_pref.mode,
                                                          NULL,
                                                          ph_ss_ms_val->net_pref.act,
                                                          dsat_get_current_subs_id(FALSE));
        }
        break;
      case DSAT_COPS_MODE_AUTO:
      case DSAT_COPS_MODE_MANAUTO:
      case DSAT_COPS_MODE_MANUAL:
        /* Restore network select preferences to state before +COPS started 
           If aborted during COPS =2 and current de-registration is success,
           send subscription available and restore back the previous state. */
           
        if (!ph_ss_ms_val->net_pref.last_dereg_success)
        {
          (void)dsatetsicmif_change_network_registration(ph_ss_ms_val->net_pref.mode,
                                                         &ph_ss_ms_val->net_pref.plmn,
                                                         ph_ss_ms_val->net_pref.act,
                                                         dsat_get_current_subs_id(FALSE));
        }
        else  /* current de-registration was successful. */
        {
          ph_ss_ms_val->net_pref.subscription_invoked = TRUE;
          dsatetsicall_update_subs_status( &status_one,
                                           &status_two,
                                           &status_three,
                                           dsat_get_current_subs_id(FALSE));
          (void) cm_ph_cmd_subscription_available3 ( dsatcmif_ph_cmd_cb_func,
                                   NULL,
                                   dsatcm_client_id,
                                   CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                   status_one,
                                   status_two,
                                   status_three);

          }
        break;
      default:
        DS_AT_MSG0_ERROR("Unsupported COPS mode ");
        break;
    }
    ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_ABORT;
    cmd_ptr = dsat_get_cmd_buf(sizeof(ds_at_cmd_status_type), FALSE);
    status_cmd_ptr = cmd_ptr->cmd_payload_ptr;

    /* Send abort event to restore normal command processing */
    cmd_ptr->hdr.cmd_id    = DS_CMD_ATCOP_STATUS_CMD;
    status_cmd_ptr->cmd_id     = (uint16)COPS_CM_CMD_ABORT;
    status_cmd_ptr->cmd_status = MMGSDI_SUCCESS;
    status_cmd_ptr->cmd_data   = 0;
    ds_put_cmd (cmd_ptr);
  }
  
  /* Signal command processor */
  return result;
} /* dsatetsicall_cops_abort_cmd_handler */


/*===========================================================================

FUNCTION DSATETSICALL_COPS_ABORT_EVENT_HANDLER

DESCRIPTION
  This function handles teh +COPS abort event handling. Most of the
  processing is done in the abort command handler.  This routine just
  ensures the AT command processor returns to normal processing.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_cops_abort_event_handler
(
   ds_at_cmd_status_type *cmd_info_ptr
)
{
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;

  ph_ss_ms_val = dsat_get_base_addr_current_subs(DSAT_SS_PH_MS_VALS);

  if(dsatcmdp_abortable_state != NOT_ABORTABLE)
  {
    ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
    ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
    DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_COPS_ETSI_IDX,dsat_get_current_subs_id(FALSE),0,0,
        (dsat_num_item_type)ph_ss_ms_val->dsatetsicall_network_list.previous_pref.mode,MIX_NUM_TYPE)
    return DSAT_OK;
  }
  else
  {
    return DSAT_ASYNC_EVENT ;
  }
}


/*===========================================================================

FUNCTION DSATETSICALL_COPS_ASYNCH_HANDLER

DESCRIPTION
  This function manages the asynchronous processing of the +COPS
  command. Numerous acynch queries are required depnding on the +COPS
  syntax.  For test syntax, its is necessary to get available and
  poreferred networks from CM.  The home PLMN is determined from the
  GSDI IMSI query if necessary.  For read syntax, current state of
  phone is requried from CM.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_CMD_ERR_RSP: if there was a problem in lower layers
    DSAT_ASYNC_CMD : if aynchronous command continues successfully

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_cops_async_handler
(
  dsat_cops_async_state_e_type  cmd_state,    /* Processing state    */
  sys_modem_as_id_e_type        subs_id,
  ds_at_cm_ph_event_type       *ph_event      /* PH event pointer */
)
{
  uint8 i = 0;
#ifdef FEATURE_MMGSDI
  mmgsdi_plmn_id_list_type plmn_id_list;
  mmgsdi_plmn_id_type *plmn_id = NULL;
  mmgsdi_plmn_id_type *plmn_id_temp = NULL;
#endif /* FEATURE_MMGSDI */
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;
  dsat_sys_detailed_plmn_list_s_type *alist        = NULL;
  dsat_result_enum_type          result = DSAT_ASYNC_CMD;

  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS,subs_id, FALSE);
  
  DS_AT_MSG1_MED("In dsatetsicall_cops_async_handler: cmd_state=%d",cmd_state);
  
  switch (cmd_state)
  {
  case DSAT_COPS_ASTATE_NULL:
  case DSAT_COPS_ASTATE_WAIT:
    /* No processing in these states */
    break;
#ifdef FEATURE_MMGSDI
  case DSAT_COPS_ASTATE_ANETS:
    {

      alist = dsat_get_cmd_mem_ptr();

      /* Save results from event info */
      dsatutil_memscpy(alist,
                       sizeof(dsat_sys_detailed_plmn_list_s_type),
                       &ph_event->event_info.available_networks,
                       sizeof(dsat_sys_detailed_plmn_list_s_type));

      DS_AT_MSG1_MED("Available networks list received: length=%d", alist->length);

      plmn_id_list.num_of_plmn_ids = alist->length;

      if(plmn_id_list.num_of_plmn_ids < 1 )
      {
        ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
        ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
        DS_AT_MSG0_ERROR("Invalid List length");
        dsat_send_cme_error(DSAT_CME_OP_NOT_ALLOWED);
        return DSAT_CMD_ERR_RSP;
    }

      plmn_id = (mmgsdi_plmn_id_type *)dsat_alloc_memory((plmn_id_list.num_of_plmn_ids)*
                                                                 sizeof(mmgsdi_plmn_id_type ), FALSE);
      plmn_id_temp = plmn_id;
      i = 0;
      plmn_id_list.plmn_list_ptr = &plmn_id[0];

      (void)dsat_cops_copy_all_categories(alist,plmn_id,ph_ss_ms_val->dsatetsicall_network_list.cmd_idx);

      ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_GET_NAME;

      if( MMGSDI_SUCCESS == mmgsdi_session_get_operator_name_ext (
                dsat_get_current_gw_session_id(FALSE),
                plmn_id_list,
                MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND,
                dsatme_mmgsdi_get_operator_name_cb,
                DSAT_MMGSDI_GET_OPER_NAME_LIST) )
      {
        DS_AT_MSG0_MED ( "Query EONS for Long and short names");
        result = DSAT_ASYNC_CMD;
      }
      else
      {
        ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
        ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
        DS_AT_MSG0_HIGH("mmgsdi_session_get_operator_name API call failed");
        dsat_send_cme_error(DSAT_CME_PHONE_FAILURE);
        result = DSAT_CMD_ERR_RSP;
      }
      if(plmn_id_temp != NULL)
      {
        DS_AT_MSG1_LOW("Memory free for %x",plmn_id_temp);
        dsatutil_free_memory(plmn_id_temp);
        plmn_id_temp = NULL;
      }
    }
    break;
#endif /* FEATURE_MMGSDI */
  case DSAT_COPS_ASTATE_PREF:
  case DSAT_COPS_ASTATE_PREF_ONLY:
    if( DSAT_COPS_ASTATE_PREF == ph_ss_ms_val->dsatetsicall_network_list.cmd_state )
    {
      /* If ATCOP originated preference change action, and we got here
       * there was no error so wait for service preference change. */
      ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_WAIT;
    }
    else if( DSAT_COPS_ASTATE_PREF_ONLY == ph_ss_ms_val->dsatetsicall_network_list.cmd_state )
    {
      /* Preferences changed so return to command mode */
      ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
      ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;

      if( DSAT_COPS_MODE_MANAUTO ==
             ph_ss_ms_val->dsatetsicall_network_list.requested_pref.mode )
      { 
            /* Update COPS state based on the current network state.*/ 
        dsat_cops_mode_e_type curr_cops_mode = (dsat_cops_mode_e_type)
              ph_ss_ms_val->dsat_net_reg_state.cmph_pref.network_sel_mode_pref;
        DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,0,0,
                               (dsat_num_item_type)curr_cops_mode,MIX_NUM_TYPE)
      }
      result = DSAT_OK;
    }
    break;
    
  case DSAT_COPS_ASTATE_ABORT:
    /* Async command processing is done */
    ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
    ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
    /* Abort handler responsible for sending result code */
    result = DSAT_ASYNC_EVENT;
    break;
    
  default:
    DS_AT_MSG1_ERROR("Unsupported COPS state: %d", cmd_state);
    break;
  }
  
  return result;      
} /* dsatetsicall_cops_asynch_handler */

#ifndef FEATURE_DSAT_CUST
/*===========================================================================

FUNCTION DSATETSICALL_EXEC_COPN_CMD

DESCRIPTION
  This function takes the result from the command line parser and
  executes it. It executes +COPN command, which displays list of 
  operator names from the ME. This command is implemented as 
  asynchronous command to make it abortable

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_exec_copn_cmd
(
  dsat_mode_enum_type       mode,         /*  AT command mode:            */
  const dsati_cmd_type     *parse_table,  /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,      /*  Command tokens from parser  */
  dsm_item_type            *res_buff_ptr  /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsatetsicall_call_state_ss_info  *call_ss_val = NULL;

  call_ss_val = dsat_get_base_addr(DSAT_CALL_SS_VALS, FALSE);

  /* Reset abort flag */
  dsat_abort_plmn_listing = FALSE;

  if(tok_ptr->op == (NA|EQ|QU))
  {
    /* Test command is valid - we support this command */
    result = DSAT_OK;
  }
  else if (tok_ptr->op == NA)
  {
    call_ss_val->dsatetsicall_copn_plmn_index = 0;
    (void)strlcpy(call_ss_val->etsicall_copn_display_name,
                     ((char *)(parse_table->name)),MAX_COPN_LEN);
    result =  dsatetsime_get_next_netwk_plmn();
  }
  else
  {
    /* other commands are illegal */
    result = DSAT_ERROR;
  }

  return result;

} /* dsatetsicall_exec_copn_cmd() */

#endif /* FEATURE_DSAT_CUST */


/*===========================================================================

FUNCTION DSATETSICALL_DISPLAY_PLMN_LIST

DESCRIPTION
  This function displays list of operator names from the ME.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_display_plmn_list
(
  void
)
{
  dsm_item_type        *res_buff_ptr;
  char full_name[DSAT_MAX_FULLNAME_STR_LEN+1];
  mmgsdi_se13_network_info_type *netinfo;
  dsat_num_item_type cscs_val ;
  dsatcmif_servs_state_ss_info  *ph_ss_val = NULL;
  dsatetsicall_call_state_ss_info  *call_ss_val = NULL;

  ph_ss_val = dsat_get_base_addr(DSAT_SS_PH_SS_VALS, FALSE);
  call_ss_val = dsat_get_base_addr(DSAT_CALL_SS_VALS, FALSE);

  netinfo = &ph_ss_val->dsatetsicall_copn_plmn_info;
  
  if (TRUE == dsat_abort_plmn_listing)
  {
    /* user has aborted the PLMN listing */
    dsat_abort_plmn_listing = FALSE;

    /* Abort handler responsible for sending error */
    return DSAT_ASYNC_EVENT;
  }

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);

  memset ((void*)full_name, 0x0, sizeof(full_name));

  (void)strlcpy(full_name,
                    netinfo->long_name,
                    DSAT_MAX_FULLNAME_STR_LEN+1);
  cscs_val =(dsat_num_item_type)dsatutil_get_val(
                                           DSATETSI_EXT_CSCS_IDX,0,0,NUM_TYPE);
  if((dsati_chset_type)cscs_val != ALPHA_GSM)
  {
    char alpha_buff[MAX_COPN_ALPHA_LEN] = "\0";
    if(dsatutil_convert_chset(
                  full_name,
                  ALPHA_GSM,
                  alpha_buff,
                  (dsati_chset_type)cscs_val,
                  MAX_COPN_ALPHA_LEN,
                  TRUE) == NULL)

    {
      return dsat_send_cme_error(DSAT_CME_UNKNOWN);
    }

    if ((netinfo->mnc > 99) || (MMGSDI_PLMN_NETWK_TYPE_PCS_1900_MASK & netinfo->network_type_mask))
    {
      /* Print MNC as 3 digits */
      res_buff_ptr->used = (word)snprintf(
                      (char*)res_buff_ptr->data_ptr,
                      res_buff_ptr->size,
                      "%s: \"%03lu%03lu\",\"%s\"\n", 
                      call_ss_val->etsicall_copn_display_name,
                      (long unsigned int)netinfo->mcc, 
                      (long unsigned int)netinfo->mnc, alpha_buff);
    }
    else
    {
      /* Print MNC as 2 digits */
      res_buff_ptr->used = (word)snprintf(
                      (char*)res_buff_ptr->data_ptr,
                      res_buff_ptr->size,
                      "%s: \"%03lu%02lu\",\"%s\"\n", 
                      call_ss_val->etsicall_copn_display_name, 
                      (long unsigned int)netinfo->mcc, 
                      (long unsigned int)netinfo->mnc, alpha_buff);
    }
  }
  else
  {
    if ((netinfo->mnc > 99) || (MMGSDI_PLMN_NETWK_TYPE_PCS_1900_MASK & netinfo->network_type_mask))
    {
      /* Print MNC as 3 digits */
      res_buff_ptr->used = (word)snprintf(
                      (char*)res_buff_ptr->data_ptr,
                      res_buff_ptr->size,
                      "%s: \"%03lu%03lu\",\"%s\"\n", 
                      call_ss_val->etsicall_copn_display_name, 
                      (long unsigned int)netinfo->mcc, 
                      (long unsigned int)netinfo->mnc, full_name);
    }
    else
    {
      /* Print MNC as 2 digits */
      res_buff_ptr->used = (word)snprintf(
                      (char*)res_buff_ptr->data_ptr,
                      res_buff_ptr->size,
                      "%s: \"%03lu%02lu\",\"%s\"\n", 
                      call_ss_val->etsicall_copn_display_name, 
                      (long unsigned int)netinfo->mcc,
                      (long unsigned int)netinfo->mnc, full_name);
    }
  }

  if (call_ss_val->dsatetsicall_copn_plmn_index == 0)
  {
    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_START_OF_RSP);
  }
  else
  {
    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_INTERMEDIATE_RSP);
  }

  if ( dsati_tx_wm_high )
  {
     /* High watermark has been hit on dsat to sio queue: 
        set up handler to re-enter COPN entry reading once queue hits low
        watermark */
     dsati_to_sio_low_handler = etsicall_copn_reenter_handler;
      return DSAT_ASYNC_CMD;
  }

  call_ss_val->dsatetsicall_copn_plmn_index++;
  
  if (dsatetsime_get_next_netwk_plmn() == DSAT_ERROR)
  {
    return DSAT_OK;
  }
  else
  {
    return DSAT_ASYNC_CMD;
  }

}/* dsatetsicall_display_plmn_list */

#ifdef FEATURE_MMGSDI

/*===========================================================================

FUNCTION  DSATETSICALL_DISPLAY_PREF_NETWORKS

DESCRIPTION
  This function displays valid preffered PLMNs in the given index range.
  
DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_ERROR :    if there was any problem in executing the command
    DSAT_OK :       if it is a success.

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_display_pref_networks
(
  ds_at_mmgsdi_oper_name_type *oper_name_ptr /* Operator name pointer */
)
{
  int index;
  dsm_item_type        *res_buff_ptr;
  dsat_num_item_type cscs_val ;
  boolean hit                                             = FALSE;
  dsatme_mmgsdi_state_ms_info    *me_ms_val               = NULL;
  sys_user_pref_plmn_list_s_type *user_pref_plmn_list_ptr = NULL;
  dsat_me_cpol_read_param_s_type *read_params_ptr         = NULL;

  /*  If user aborted the listing */
  if (TRUE == dsat_abort_plmn_listing)
  {
    dsat_abort_plmn_listing = FALSE;

    /* Abort handler responsible for sending error */
    return DSAT_ASYNC_EVENT;
  }

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);

  me_ms_val = dsat_get_base_addr_current_session();

  read_params_ptr         = dsat_get_cmd_mem_ptr();
  user_pref_plmn_list_ptr = &read_params_ptr->user_pref_networks;

  for (index = read_params_ptr->start_index -1; 
    index < read_params_ptr->end_index && 
    index <= ( user_pref_plmn_list_ptr->length - 1) &&
    index < SYS_USER_PPLMN_LIST_MAX_LENGTH; index++)
  {
    /* Check whether the PLMN is valid or not */
    if ((FALSE == dsat_abort_plmn_listing) && 
      (!sys_plmn_id_is_undefined(user_pref_plmn_list_ptr->info[index].plmn)))
    {
      char full_name[DSAT_MAX_FULLNAME_STR_LEN + 1] = "\0";
      char short_name[DSAT_MAX_SHORTNAME_STR_LEN + 1] = "\0";
      char buffer[MAX_CPOL_BUFF_LEN] = "\0";
      char format_str[40] = "%s: %d,%d";
      char alpha_buff[MAX_CPOL_BUFF_LEN] = "\0";
      uint8 size = 0;
      sys_access_tech_e_type act1 =0;
      sys_access_tech_e_type act2 =0;
      sys_access_tech_e_type act3 =0;
#ifdef FEATURE_DSAT_LTE
      sys_access_tech_e_type act4 =0;
#endif /* FEATURE_DSAT_LTE */
      sys_mcc_type mcc = 0;
      sys_mnc_type mnc = 0;
      boolean plmn_undefined = FALSE;
      boolean pcs_flag = FALSE;
      uinetwk_network_info_s_type  netinfo;
      ds_at_plmn_info * plmn_info_ptr = NULL;
      uint8 j=0;
      uint32 name_len = 0;

      for(j = 0; j < oper_name_ptr->num_of_plmn_ids; j++)
      {
        if( memcmp((byte *)&user_pref_plmn_list_ptr->info[index].plmn,
            &oper_name_ptr->plmn_info_ptr[j]->plmn_id.plmn_id_val,3) == 0 )
        {
          plmn_info_ptr = oper_name_ptr->plmn_info_ptr[j];
          hit = TRUE;
          break;
        }
      }
    
      if(!hit)
      { 
        continue;
      }
      memset ((void*)&netinfo, 0x0, sizeof(netinfo));
      /* Convert PLMN to MCC/MNC */
      sys_plmn_get_mcc_mnc( user_pref_plmn_list_ptr->info[index].plmn,
                            &plmn_undefined,
                            &pcs_flag,
                            &mcc,
                            &mnc );
      memset ((void*)full_name, 0x0, sizeof(full_name));
      memset ((void*)short_name, 0x0, sizeof(short_name));
      DS_AT_MSG0_HIGH(" EONS available");
      if(plmn_info_ptr == NULL)
      {
        return DSAT_ERROR;
      }
      /*UCS2 encoding have 2 byte long char. e.g. 5 UCS2 character fit in 10 byte long array.*/
      if(MMGSDI_EONS_ENC_UCS2 == plmn_info_ptr->long_name_encoding)
      {
        plmn_info_ptr->long_name_len = (plmn_info_ptr->long_name_len)/2;
      }
      name_len = MIN(plmn_info_ptr->long_name_len,DSAT_MAX_FULLNAME_STR_LEN);
      if(name_len > 0)
      {
        etsicall_convert_chrset_todefault(plmn_info_ptr->long_name_encoding,(const byte *)plmn_info_ptr->long_name,
                                           (size_t)name_len,(byte *)full_name,
                                           DSAT_MAX_FULLNAME_STR_LEN,NULL);
      }
      if(MMGSDI_EONS_ENC_UCS2 == plmn_info_ptr->short_name_encoding)
      {
        plmn_info_ptr->short_name_len = (plmn_info_ptr->short_name_len)/2;
      }
      name_len = MIN(plmn_info_ptr->short_name_len,DSAT_MAX_SHORTNAME_STR_LEN);
      if(name_len > 0)
      {
        etsicall_convert_chrset_todefault(plmn_info_ptr->short_name_encoding,(const byte *)plmn_info_ptr->short_name,
                                           (size_t)name_len,(byte *)short_name,
                                           DSAT_MAX_SHORTNAME_STR_LEN,NULL);
      }
      /* Setting Access Technologies to 1 */
      if ( user_pref_plmn_list_ptr->info[index].access_tech & SYS_ACT_GSM_MASK )
      {
        act1 = 1;
      }
      if ( user_pref_plmn_list_ptr->info[index].access_tech & SYS_ACT_GSM_COMPACT_MASK )
      {
        act2 = 1;
      }
      if ( user_pref_plmn_list_ptr->info[index].access_tech & SYS_ACT_UMTS_MASK )
      {
        act3 = 1;
      }
#ifdef FEATURE_DSAT_LTE
      if ( user_pref_plmn_list_ptr->info[index].access_tech & SYS_ACT_LTE_MASK )
      {
        act4 = 1;
      }
#endif /* FEATURE_DSAT_LTE */
      /* Display preffered PLMNs in the user configured format */
      switch (read_params_ptr->format)
      {
      case DSAT_CPOL_LONG_ALPHA_NUMERIC:
      case DSAT_CPOL_SHORT_ALPHA_NUMERIC:
        /* If name exists in requested format... */
        if ( ( DSAT_CPOL_LONG_ALPHA_NUMERIC == read_params_ptr->format &&
               strlen(full_name) > 0 ) ||
             ( DSAT_CPOL_SHORT_ALPHA_NUMERIC == read_params_ptr->format &&
               strlen(short_name) > 0 ) )
        {
          /* If TE character set is not GSM 7bit alphabet, convert name into
             this character set... */
          cscs_val =(dsat_num_item_type)dsatutil_get_val(
                                           DSATETSI_EXT_CSCS_IDX,0,0,NUM_TYPE);
          if((dsati_chset_type)cscs_val != ALPHA_GSM)
          {
            if (dsatutil_convert_chset(
                          ( DSAT_CPOL_LONG_ALPHA_NUMERIC == 
                              read_params_ptr->format ? 
                              full_name : short_name ),
                          ALPHA_GSM,
                          alpha_buff,
                          (dsati_chset_type)cscs_val,
                          MAX_CPOL_BUFF_LEN,
                          TRUE) == NULL)

            {
              (void)dsm_free_buffer(res_buff_ptr);
              return dsat_send_cme_error(DSAT_CME_UNKNOWN);
            }
          }
          /* Else just copy name into buffer. */
          else
          {
            (void)strlcpy( alpha_buff, 
                           ( DSAT_CPOL_LONG_ALPHA_NUMERIC == 
                           read_params_ptr->format ? 
                           full_name : short_name ),
                           MAX_CPOL_BUFF_LEN );
          }

          if (me_ms_val->dsat_plmn_wact_supported)
          {
            /* Display ACT indicators */
#ifdef FEATURE_DSAT_LTE
            (void)strlcat(format_str,",\"%s\",%d,%d,%d,%d\n",sizeof(format_str));
#else 
            (void)strlcat(format_str,",\"%s\",%d,%d,%d\n",sizeof(format_str));
#endif /* FEATURE_DSAT_LTE */
          }
          else
          {
            /* Don't display 3 ACT indicators */
            (void)strlcat( format_str, ",\"%s\"\n",sizeof(format_str));
          }
#ifdef FEATURE_DSAT_LTE
          size += (uint8)snprintf(
                        buffer + size,
                        sizeof(buffer),
                        format_str, 
                        read_params_ptr->display_str,
                        index + 1, read_params_ptr->format, alpha_buff,
                        act1, act2, act3,act4 ); 
#else 
          size += (uint8)snprintf(
                        buffer + size,
                        sizeof(buffer),
                        format_str, 
                        read_params_ptr->display_str,
                        index + 1, read_params_ptr->format, alpha_buff,
                        act1, act2, act3 ); 
#endif /* FEATURE_DSAT_LTE */
        }
        else
        {
          /* If full name not available */

          if ( pcs_flag || UI_NETWK_TYPE_PCS_1900 == netinfo.network_type )
          {
            /* Display MNC of PLMN as 3 digits */
            (void)strlcat( format_str, ",\"%03lu%03lu\"",sizeof(format_str) );
          }
          else
          {
            /* Display MNC of PLMN as 2 digits */
            (void)strlcat( format_str, ",\"%03lu%02lu\"",sizeof(format_str) );
          }

          if (me_ms_val->dsat_plmn_wact_supported)
          {
            /* Display ACT indicators */
#ifdef FEATURE_DSAT_LTE
            (void)strlcat( format_str, ",%d,%d,%d,%d\n",sizeof(format_str) );
#else 
            (void)strlcat( format_str, ",%d,%d,%d\n",sizeof(format_str) );
#endif /* FEATURE_DSAT_LTE */
          }
          else
          {
            /* Don't display 3 ACT indicators */
            (void)strlcat( format_str, "\n",sizeof(format_str));
          }
#ifdef FEATURE_DSAT_LTE          
          size += (uint8)snprintf( buffer + size,
                                   sizeof(buffer),
                                   format_str,
                                   read_params_ptr->display_str,
                                   (index + 1), 
                                   DSAT_CPOL_NUMERIC, mcc, mnc, 
                                   act1, act2, act3, act4 );       
#else
          size += (uint8)snprintf( buffer + size,
                                   sizeof(buffer),
                                   format_str,
                                   read_params_ptr->display_str,
                                   (index + 1), 
                                   DSAT_CPOL_NUMERIC, mcc, mnc, 
                                   act1, act2, act3 );            
#endif /* FEATURE_DSAT_LTE */     
        }
        break;      

      case DSAT_CPOL_NUMERIC:
        if ( pcs_flag || UI_NETWK_TYPE_PCS_1900 == netinfo.network_type )
        {
          /* Display MNC of PLMN as 3 digits */
          (void)strlcat( format_str, ",\"%03lu%03lu\"",sizeof(format_str) );
        }
        else
        {
          /* Display MNC of PLMN as 2 digits */
          (void)strlcat( format_str, ",\"%03lu%02lu\"",sizeof(format_str) );
        }

        if (me_ms_val->dsat_plmn_wact_supported)
        {
          /* Display ACT indicators */
#ifdef FEATURE_DSAT_LTE          
          (void)strlcat( format_str, ",%d,%d,%d,%d\n",sizeof(format_str));
#else
          (void)strlcat( format_str, ",%d,%d,%d\n",sizeof(format_str));
#endif /* FEATURE_DSAT_LTE */
        }
        else
        {
          /* Don't display 3 ACT indicators */
          (void)strlcat( format_str, "\n",sizeof(format_str));
        }
#ifdef FEATURE_DSAT_LTE          
        size += (uint8)snprintf( buffer + size,
                                 sizeof(buffer),
                                 format_str,
                                 read_params_ptr->display_str, 
                                 (index + 1), 
                                 DSAT_CPOL_NUMERIC, mcc, mnc, 
                                 act1, act2, act3,act4 );
#else
        size += (uint8)snprintf( buffer + size,
                                 sizeof(buffer),
                                 format_str,
                                 read_params_ptr->display_str, 
                                 (index + 1), 
                                 DSAT_CPOL_NUMERIC, mcc, mnc, 
                                 act1, act2, act3 );            
#endif /* FEATURE_DSAT_LTE */            
        break;

      default:
        (void)dsm_free_buffer(res_buff_ptr);
        return dsat_send_cme_error(DSAT_CME_UNKNOWN);      
      }

      dsat_dsm_pushdown_tail(&res_buff_ptr, buffer, size,
                             DSM_ITEM_POOL(res_buff_ptr), FALSE);
    }
    memset(&user_pref_plmn_list_ptr->info[index],0xFF,sizeof(sys_user_pref_plmn_list_info_s_type));
  }
  
  if ((res_buff_ptr != NULL) && (res_buff_ptr->used > 0))
  {
    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_COMPLETE_RSP);
  }
  else
  {
    (void)dsm_free_buffer(res_buff_ptr);
  }

  return DSAT_OK;
} /* dsatetsicall_display_pref_networks */
#endif /* FEATURE_MMGSDI */

/*===========================================================================

FUNCTION DSATETSICALL_PLMN_ABORT_CMD_HANDLER

DESCRIPTION
  This function handles an abort command to terminate listing of both 
  preffered PLMN and PLMN list stored on the ME.

DEPENDENCIES
  None

RETURN VALUE
  Value indicating whether or not command should be aborted:
      TRUE if call should be aborted, FALSE otherwise.

===========================================================================*/
/*ARGSUSED*/
boolean dsatetsicall_plmn_abort_cmd_handler
(
  const dsati_cmd_type *cmd_table_entry_ptr  /* Ptr to cmd entry in table. */
)
{
  ds_cmd_type               *cmd_ptr;
  ds_at_cmd_status_type     *status_cmd_ptr = NULL;

  dsat_abort_plmn_listing = TRUE;

  cmd_ptr = dsat_get_cmd_buf(sizeof(ds_at_cmd_status_type), FALSE);
  status_cmd_ptr = cmd_ptr->cmd_payload_ptr;

  /* Send abort event to restore normal command processing */
  cmd_ptr->hdr.cmd_id           = DS_CMD_ATCOP_STATUS_CMD;
  status_cmd_ptr->cmd_id        = (uint16)COPN_CM_CMD_ABORT;
  status_cmd_ptr->cmd_status    = MMGSDI_SUCCESS;
  status_cmd_ptr->cmd_data      = 0;
  ds_put_cmd (cmd_ptr);

  return TRUE;
}


/*===========================================================================

FUNCTION DSATETSICALL_COPN_ABORT_EVENT_HANDLER

DESCRIPTION
  This function handles teh +COPN abort event handling. Most of the
  processing is done in the abort command handler.  This routine just
  ensures the AT command processor returns to normal processing.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_ERROR : As command is aborted

SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_copn_abort_event_handler
(
  ds_at_cmd_status_type *cmd_info_ptr
)
{
  if( dsatcmdp_abortable_state != NOT_ABORTABLE )
  {
    return DSAT_ERROR;
  }
  else
  {
    return DSAT_ASYNC_EVENT;
  }
}

/*===========================================================================

FUNCTION ETSICALL_COPN_REENTER_HANDLER

DESCRIPTION
  Local function that is used to reenter reading PLMN entries once DSAT to SIO
  queue has hit low watermark (or) DSM large item threshold timer expiry.

DEPENDENCIES
  none

RETURN VALUE
  DSAT_OK          : If reading of all records complete.
  DSAT_ASYNC_CMD   : Additional entries remain to be read.
  DSAT_CMD_ERR_RSP : If there is a CME ERROR.
  DSAT_ERROR       : Read action fails due to non-CME errors.

SIDE EFFECTS
  None
===========================================================================*/
/* ARGSUSED */
LOCAL dsat_result_enum_type etsicall_copn_reenter_handler
(
  ds_cmd_type* cmd_ptr
)
{
  dsat_result_enum_type result;
  dsatetsicall_call_state_ss_info  *call_ss_val = NULL;

  call_ss_val = dsat_get_base_addr(DSAT_CALL_SS_VALS, FALSE);

  /* Reset handler function pointers */
  /* Handler function for low event, now not neccesary */
  dsati_to_sio_low_handler = NULL;

  call_ss_val->dsatetsicall_copn_plmn_index++;
  DS_AT_MSG1_HIGH("etsicall_copn_reenter_handler: reading index from %d",
          call_ss_val->dsatetsicall_copn_plmn_index);

  result = dsatetsime_get_next_netwk_plmn ();

  return result;
}/* etsicall_copn_reenter_handler */
/*===========================================================================

FUNCTION ETSICALL_SETUP_NETWORK_SELECTION

DESCRIPTION
  This function does the necessary setup to perform network selection
  based on +COPS command parameters.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success for local execution
    DSAT_CMD_ERR_RSP: if there was +CME error

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL dsat_result_enum_type etsicall_setup_network_selection
(
  const dsati_cmd_type *parse_table,
  const tokens_struct_type *tok_ptr,
  dsm_item_type *res_buff_ptr,
  dsat_num_item_type prev_mode,
  dsatetsicall_network_pref_s_type * net_pref_ptr
)
{
  dsat_num_item_type temp;
  const byte *param_ptr;
  dsat_cops_fmt_e_type fmt;
  dsat_num_item_type result = DSAT_ERROR;
  dsat_mixed_param_val_type *val_ptr =
    (dsat_mixed_param_val_type*)dsatutil_get_val(parse_table->cmd_id,dsat_get_current_subs_id(FALSE),0,STR_TYPE);
  mixed_def_s_type ** mixed_def_list = 
    (mixed_def_s_type **) parse_table->def_lim_ptr;
  byte oper[DSAT_MAX_FULLNAME_STR_LEN+1];
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;
  dsatme_mmgsdi_state_ss_info  *me_ss_val = NULL;
  dsat_cops_cmd_idx_e_type           temp_cmd_idx;
  byte                               temp_cmd_name[DSAT_COPS_CMD_NAME_SIZE];
  dsat_cops_csg_rat_e_type csg_rat;

  ph_ss_ms_val = dsat_get_base_addr_current_subs(DSAT_SS_PH_MS_VALS);
  me_ss_val = dsat_get_base_addr(DSAT_MMGSDI_SS_VALS, FALSE);

  /* Macro to convert list index to numberic value */
  #define CONVERT_TO_NUMERIC( i, cast, val ) \
      param_ptr = \
        mixed_def_list[i]->def->def_list.list_v[val_ptr[i].num_item]; \
      if ( ATOI_OK != \
           dsatutil_atoi (&temp, param_ptr, 10) ) \
      { \
        DS_AT_MSG_SPRINTF_1_ERROR(\
        "Cannot convert format param: %s",param_ptr); \
        return DSAT_ERROR; \
      } \
      val = (cast)temp;
  #define CONVERT_TO_PLMN( mcc, mnc, plmn, pcs_flag ) \
      if ( FALSE == \
           sys_plmn_set_mcc_mnc( (mnc > 99 || pcs_flag)? TRUE : FALSE, \
                                 mcc, mnc, &plmn ) ) \
      { \
        DS_AT_MSG2_ERROR("Error parsing MCC/MNC into PLMN: [%d,%d]", \
                   mcc,mnc); \
        dsatme_set_cme_error(DSAT_CME_PHONE_FAILURE, res_buff_ptr); \
        return DSAT_CMD_ERR_RSP; \
      }
      temp_cmd_idx = ph_ss_ms_val->dsatetsicall_network_list.cmd_idx;
      dsatutil_memscpy(&temp_cmd_name[0], DSAT_COPS_CMD_NAME_SIZE,
                       &ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                       DSAT_COPS_CMD_NAME_SIZE);
      
      /* Clear structures */
      memset((void*)&net_pref_ptr->plmn, 0x0, sizeof(sys_plmn_id_s_type));
      memset((void*)&(ph_ss_ms_val->dsatetsicall_network_list),
             0x0,
             sizeof(ph_ss_ms_val->dsatetsicall_network_list));

      ph_ss_ms_val->dsatetsicall_network_list.cmd_idx = temp_cmd_idx;
      dsatutil_memscpy(&ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                       DSAT_COPS_CMD_NAME_SIZE,
                       &temp_cmd_name[0], DSAT_COPS_CMD_NAME_SIZE);
  if(ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS && !VALID_TOKEN(3))
  {
    net_pref_ptr->no_of_args = 5;
  }
  else
  {
    net_pref_ptr->no_of_args = tok_ptr->args_found;
  }
  net_pref_ptr->is_arg0_valid = VALID_TOKEN(0);
  net_pref_ptr->is_arg2_valid = VALID_TOKEN(2);
  DS_AT_MSG1_HIGH("%d Args found in COPS command", net_pref_ptr->no_of_args);

  /* Clear the oper parameter so its not reported in &V response */
  (void)strlcpy((char*)oper,
                    (char*)val_ptr[2].string_item,
                    sizeof(oper));
  val_ptr[2].string_item[0]='\0';
      
  /* Convert list parameters to numerics */
  CONVERT_TO_NUMERIC(0, dsat_cops_mode_e_type, net_pref_ptr->mode);
  CONVERT_TO_NUMERIC(1, dsat_cops_fmt_e_type, fmt);
  CONVERT_TO_NUMERIC(3, dsat_cops_act_e_type, net_pref_ptr->act);
      
  DS_AT_MSG1_MED("cops cmd id %d",ph_ss_ms_val->dsatetsicall_network_list.cmd_idx);
  
   if(ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS )
  {
    if ( !VALID_TOKEN(4) || !VALID_TOKEN(5) ||
    	     ATOI_OK != dsatutil_atoi((dsat_num_item_type*)&(net_pref_ptr->csg_id), tok_ptr->arg[4], 10 ))
    {
      DS_AT_MSG0_ERROR("Invalid or No csg_id, csg_rat");
      return DSAT_ERROR;
    }
    else
    {
      CONVERT_TO_NUMERIC(5, sys_radio_access_tech_e_type, net_pref_ptr->csg_rat);
      csg_rat = (dsat_cops_csg_rat_e_type) net_pref_ptr->csg_rat;
      switch( csg_rat )
      {
        case DSAT_COPS_CSG_RAT_GSM:
          net_pref_ptr->csg_rat = SYS_RAT_GSM_RADIO_ACCESS;
          break;

        case DSAT_COPS_CSG_RAT_UMTS:
          net_pref_ptr->csg_rat = SYS_RAT_UMTS_RADIO_ACCESS;
          break;
#ifdef FEATURE_TDSCDMA
        case DSAT_COPS_CSG_RAT_TDS:
          net_pref_ptr->csg_rat = SYS_RAT_TDS_RADIO_ACCESS;
          break;
#endif /* FEATURE_TDSCDMA */
#ifdef FEATURE_DSAT_LTE
        case DSAT_COPS_CSG_RAT_LTE:
          net_pref_ptr->csg_rat = SYS_RAT_LTE_RADIO_ACCESS;
          break;
#endif /* FEATURE_DSAT_LTE */
        default:
          DS_AT_MSG1_HIGH("Invalid csg_rat = %d",net_pref_ptr->csg_rat );
          return DSAT_ERROR;
      }
    }
    if(VALID_TOKEN(3))
    {
      if( !( ( (net_pref_ptr->csg_rat == SYS_RAT_UMTS_RADIO_ACCESS) &&
               (net_pref_ptr->act == DSAT_COPS_ACT_UTRAN) ) ||
             (
               (net_pref_ptr->csg_rat == SYS_RAT_LTE_RADIO_ACCESS) && 
               (net_pref_ptr->act == DSAT_COPS_ACT_EUTRAN) ) ) )
      {
        DS_AT_MSG0_ERROR("cops_rat and csg_rat invalid pair");
        return DSAT_ERROR;
      }
    }
    else
    {
      if( !( (net_pref_ptr->csg_rat == SYS_RAT_UMTS_RADIO_ACCESS) || 
             (net_pref_ptr->csg_rat == SYS_RAT_LTE_RADIO_ACCESS) ) )
      {
           DS_AT_MSG0_ERROR("Invalid CSG_RAT");
           return DSAT_ERROR;
      }
    }
  }

  /* Process parameters if not just setting format */
  if ( DSAT_COPS_MODE_SETFMT != net_pref_ptr->mode )
  {
       /* Force to automatic AcT if parameter not specified.  This
        * allow user flexibility to select specific AcT or any */
    if( !VALID_TOKEN(3) )
    {
       net_pref_ptr->act = DSAT_COPS_ACT_AUTO;
    }
    /* network ID is valid in both automatic and manual network selection for $QCCOPS command 
       and only in manual selection for +COPS command */
    /* We need to process network ID for $QCCOPS command in auomatic mode , only if it is specified */
     if( ((DSAT_COPS_MODE_AUTO  != net_pref_ptr->mode) || 
        ((ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCOPS ||
         ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS) && 
         VALID_TOKEN(2))) && (DSAT_COPS_MODE_DEREG != net_pref_ptr->mode) )
    {
      
      /* Check for network ID parameter */
      if (( !VALID_TOKEN(2)) && 
          (ph_ss_ms_val->dsatetsicall_network_list.cmd_idx != CMD_IDX_QCCOPS || 
           ph_ss_ms_val->dsatetsicall_network_list.cmd_idx != CMD_IDX_QCCSGCOPS))
      {
        DS_AT_MSG0_ERROR("Missing COPS network identifier");
        return DSAT_ERROR;
      }

      /* Convert alpha parameter to PLMN. */
      /* Force the access technology to that in operator database to
       * speed selection process.  This will change the overall
       * network mode preference; UI does the same. */
      switch (fmt)
      {
      case DSAT_COPS_FMT_LONG:
         case DSAT_COPS_FMT_SHRT:
        {
           mmgsdi_data_type   longname;
           mmgsdi_data_type   shortname;
           longname.data_ptr  = NULL;
           longname.data_len  = 0;
           shortname.data_ptr = NULL;
           shortname.data_len = 0;

           if( DSAT_COPS_FMT_LONG == fmt )
           {
             longname.data_len = strlen((const char *)oper);
             longname.data_ptr = ( uint8 *)oper;
        }
        else
        {
             shortname.data_len = strlen((const char *)oper);
             shortname.data_ptr = ( uint8 *)oper;
        }
#ifdef FEATURE_MMGSDI
           if( MMGSDI_SUCCESS == mmgsdi_get_se13_plmn_info_by_name(
                              me_ss_val->dsat_mmgsdi_client_id,
                              longname,
                              shortname,
                              MMGSDI_RAT_NONE,
                              dsatetsicall_cops_cmd_cb_func,
                              (mmgsdi_client_data_type)COPS_MMGSDI_PLMN_INFO) )
        {
              return DSAT_ASYNC_CMD;
        }
        else
#endif /*FEATURE_MMGSDI*/
        {
          /* Name lookup failed so return error */
             DS_AT_MSG0_ERROR("COPS network name lookup failed");
          dsatme_set_cme_error(DSAT_CME_NOT_FOUND, res_buff_ptr);
          return DSAT_CMD_ERR_RSP;
        }
        break;
       }/* case DSAT_COPS_FMT_SHRT:*/
      case DSAT_COPS_FMT_PLMN:
         {
            byte buffer[8];
            dsat_num_item_type mcc = 0;
            dsat_num_item_type mnc = 0;

        /* Convert string to PLMN structure */
        /* MCC is first 3 characters */
        memset ((void*)buffer, 0x0, sizeof(buffer));
       (void)strlcat ((char*)buffer,
                          (char*)oper,
                          PLMN_STR_MCC_LEN+1);
        if ( ATOI_OK !=
             dsatutil_atoi (&mcc, buffer, 10) )
        {
          DS_AT_MSG0_ERROR("Cannot convert MCC value");
          return DSAT_ERROR;
        }

        /* MNC is next 2 or 3 characters */
        memset ((void*)buffer, 0x0, sizeof(buffer));
        (void)strlcat ((char*)buffer,
                           (char*)(oper+PLMN_STR_MCC_LEN),
                           PLMN_STR_MNC_LEN+1);
        if ( ATOI_OK !=
             dsatutil_atoi (&mnc, buffer, 10) )
        {
          DS_AT_MSG0_ERROR("Cannot convert MNC value");
          return DSAT_ERROR;
        }

        /* Convert MCC/MNC to PLMN, set 3rd MNC digit if MNC string
           was of 3 characters */
        CONVERT_TO_PLMN( mcc, mnc, net_pref_ptr->plmn,
                         (PLMN_STR_MNC_LEN == strlen((char*)buffer)) );
        break;
      }/*case DSAT_COPS_FMT_PLMN:*/
      default:
    {
      DS_AT_MSG1_ERROR("Error: Unsupported format: %d", fmt);
      return DSAT_ERROR;
      break;
    }
    }
    }
    result = dsatetsicall_process_plmn_info();
  }
  else
  {
    /* Restore previous mode when just setting format */
    val_ptr[0].num_item = prev_mode;
     result = DSAT_OK;
  }
  return result;
} /* etsicall_setup_network_selection */


/*===========================================================================

FUNCTION DSATETSICALL_REPORT_COPS_RESULT

DESCRIPTION
  This function generates the response for network query command +COPS
  read syntax.  The order of networks shown in the respose is dictated
  in TS27.007 section 7.3: home, SIM (preferred), other.  Only those
  networks "present" are to be reported.

DEPENDENCIES
  None
  
RETURN VALUE
  DSAT_CMD_ERR_RSP : if CM reports failure
  DSAT_OK : if it is a success for local execution
  DSAT_ERROR : if there was any problem in executing the command
  
SIDE EFFECTS
  May append further DSM items to original result buffer.
  
===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_report_cops_result
(
  ds_at_mmgsdi_oper_name_type *oper_name, /* Operator name pointer */
  sys_modem_as_id_e_type       subs_id
)
{
#define COPS_NETWORK_REPORTED 0xFF  /* control value to flag reported */

  char buffer[MAX_NETWORK_REPORT_LEN];
  uint8 j = 0;
  word size = 0;
  dsat_sys_detailed_plmn_list_s_type *alist        = NULL;
  dsm_item_type                 *res_buff_ptr = NULL;
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;

  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS,subs_id, FALSE);

  if(ph_ss_ms_val->dsatetsicall_network_list.cmd_state != DSAT_COPS_ASTATE_GET_NAME)
  {
    DS_AT_MSG0_ERROR ( "Invalid state");
    return DSAT_ERROR;
  }
  memset ((void*)buffer, 0x0, sizeof(buffer));
  if( oper_name->client_ref == DSAT_MMGSDI_GET_OPER_NAME_LIST )
  {
    alist = dsat_get_cmd_mem_ptr();

  /* Check whether the command was aborted */
  if(alist->length < 1)
  {
    DS_AT_MSG0_ERROR("+COPS command got aborted");
    /* Report +CME error asynchronously */
    return dsat_send_cme_error(DSAT_CME_OP_NOT_ALLOWED);
  }

    if(oper_name->num_of_plmn_ids != alist->length)
    {
      DS_AT_MSG2_ERROR("%d num_of_plmn_ids %d alist->length",
                   oper_name->num_of_plmn_ids,alist->length);
      return DSAT_ERROR;
    }

    /* Get a response buffer */
    res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);
    /* Initialize response */
    size = (word)snprintf( buffer, sizeof(buffer), "%s: ",
           (char*) &ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0] );
    dsat_dsm_pushdown_tail(&res_buff_ptr, buffer, size,
                           DSM_ITEM_POOL(res_buff_ptr), FALSE);

    for(j = 0 ; (j < oper_name->num_of_plmn_ids) && (j < alist->length) ; j++)
    {
      if( oper_name->plmn_info_ptr[j] != NULL )
      {
        etsicall_cops_generate_network_response( oper_name->plmn_info_ptr[j],
                                               TRUE,
                                               subs_id,
                                               res_buff_ptr ); 
      }
    }
    /* Append list of supported nodes/formats */
    size = (word)snprintf( buffer, sizeof(buffer), ",%s,%s",
                          dsat_cops_mixed_dfl[0]->def->def_list.list_t,
                          dsat_cops_mixed_dfl[1]->def->def_list.list_t );
    dsat_dsm_pushdown_tail(&res_buff_ptr, buffer, size,
                           DSM_ITEM_POOL(res_buff_ptr), FALSE);
    /* Ensure a response was generated */
    /* Send response to TE */
    DSAT_SEND_RESPONSE( res_buff_ptr, DSAT_COMPLETE_RSP );
  }
  else if( oper_name->client_ref == DSAT_MMGSDI_GET_CURR_OPER_NAME)
  {
    uint32  name_len=0;

    dsat_cops_act_e_type net_act = ph_ss_ms_val->dsat_net_reg_state.act;
    boolean plmn_undefined = FALSE;
    
    dsat_num_item_type mode_val = (dsat_num_item_type)dsatutil_get_val(
                     DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,0,MIX_NUM_TYPE);

    dsat_cops_fmt_e_type fmt = (dsat_num_item_type)dsatutil_get_val(
                     DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,1,MIX_NUM_TYPE);
    char *cp = buffer;

    uint32 no_of_chars = 0;
    sys_mcc_type mcc = 0;
    sys_mnc_type mnc = 0;

    if(oper_name->num_of_plmn_ids != 1)
    {
      DS_AT_MSG1_ERROR(" Incorrect MMGSDI data found - %d plmn_ids ",oper_name->num_of_plmn_ids);
      return DSAT_ERROR;
    }


    /* Report the mode and current registration info */
    switch (fmt)
    {
    case DSAT_COPS_FMT_LONG:
    case DSAT_COPS_FMT_SHRT:
    {
      size = (word)snprintf (buffer, sizeof(buffer),
                                   "%s: %d,%d,\"",
                                   &ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                                   mode_val,
                                   fmt);
      if( size < MAX_NETWORK_REPORT_LEN )
      {
        cp = buffer + size;
      }
      if((fmt == DSAT_COPS_FMT_LONG) && (oper_name->plmn_info_ptr != NULL))
      {
        /*UCS2 encoding have 2 byte long char. e.g. 5 UCS2 character fit in 10 byte long array.*/
        if(MMGSDI_EONS_ENC_UCS2 == oper_name->plmn_info_ptr[0]->long_name_encoding)
        {
          oper_name->plmn_info_ptr[0]->long_name_len = (oper_name->plmn_info_ptr[0]->long_name_len)/2;
        }
        name_len = MIN(oper_name->plmn_info_ptr[0]->long_name_len,DSAT_MAX_FULLNAME_STR_LEN);
        DS_AT_MSG1_HIGH("name_len = %d",name_len);
        etsicall_convert_chrset_todefault(oper_name->plmn_info_ptr[0]->long_name_encoding,
                                          (const byte *)oper_name->plmn_info_ptr[0]->long_name,(size_t)name_len,(byte *) cp,
                                           DSAT_MAX_FULLNAME_STR_LEN,(size_t*)&no_of_chars);
        cp += no_of_chars;
      }
      else if((fmt == DSAT_COPS_FMT_SHRT) && (oper_name->plmn_info_ptr != NULL))
      {
        /*UCS2 encoding have 2 byte long char. e.g. 5 UCS2 character fit in 10 byte long array.*/
        if(MMGSDI_EONS_ENC_UCS2 == oper_name->plmn_info_ptr[0]->short_name_encoding)
        {
          oper_name->plmn_info_ptr[0]->short_name_len = (oper_name->plmn_info_ptr[0]->short_name_len)/2;
        }

        name_len = MIN(oper_name->plmn_info_ptr[0]->short_name_len,DSAT_MAX_SHORTNAME_STR_LEN);
        DS_AT_MSG1_HIGH("name_len = %d",name_len);
        etsicall_convert_chrset_todefault(oper_name->plmn_info_ptr[0]->short_name_encoding,
                                          (const byte *)oper_name->plmn_info_ptr[0]->short_name,(size_t)name_len,(byte *) cp,
                                           DSAT_MAX_SHORTNAME_STR_LEN,(size_t*)&no_of_chars);
        cp += no_of_chars;
      }
      if((oper_name->spn.eons_encoding != MMGSDI_EONS_ENC_INVALID) &&
          ( oper_name->spn.eons_data.data_len != 0))
      {
        if(no_of_chars != 0)
        {
          *cp++ = ' ';
        }

        if(MMGSDI_EONS_ENC_UCS2 == oper_name->spn.eons_encoding)
        {
          oper_name->spn.eons_data.data_len = (oper_name->spn.eons_data.data_len)/2;
        }

        name_len = MIN(oper_name->spn.eons_data.data_len,DSAT_MAX_FULLNAME_STR_LEN);
        etsicall_convert_chrset_todefault(oper_name->spn.eons_encoding,
                                          (const byte *)oper_name->spn.eons_data.data_ptr,(size_t)name_len,(byte *) cp,
                                           DSAT_MAX_FULLNAME_STR_LEN,(size_t*)&no_of_chars);

        cp += no_of_chars;
      }
      
      *cp++ = '"';
      *cp++ = ',';
      *cp++ = '0' + net_act;
      if(ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS &&
                                               (oper_name->plmn_info_ptr != NULL))
      {
        if( oper_name->plmn_info_ptr[0]->plmn_id.csg_id != SYS_CSG_ID_INVALID )
        {
          size = (word)snprintf (cp, sizeof(buffer) - (cp - buffer),
                                 ",%lu,%d",
                                 oper_name->plmn_info_ptr[0]->plmn_id.csg_id,
                                 ph_ss_ms_val->dsat_net_reg_state.csg_rat
                                 );
          cp += size;
        }
      }
        
      *cp++ = '\0';
      size = cp - buffer;
      break;
    }
    case DSAT_COPS_FMT_PLMN:
    {
      boolean pcs_flag = FALSE;
    
      /* Convert PLMN to MCC/MNC */
      sys_plmn_get_mcc_mnc( ph_ss_ms_val->dsat_net_reg_state.net_id_info.plmn,
                            &plmn_undefined,
                            &pcs_flag,
                            &mcc,
                            &mnc );

      /* PLMN may be undefined */
      if (TRUE == plmn_undefined)
      {
        size = (word)snprintf (buffer, sizeof(buffer),
                               "%s: %d,%d,\"\",%d",
                               &ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                               mode_val,
                               fmt,
                               net_act );
      }
      else
      {
        if ( pcs_flag )
        {
          /* Print MNC as 3 digits */
          size = (word)snprintf (buffer, sizeof(buffer),
                                 "%s: %d,%d,\"%03lu%03lu\",%d",
                                 &ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                                 mode_val,
                                 fmt,
                                 mcc,mnc,
                                 net_act );
        }
        else
        {
          size = (word)snprintf (buffer, sizeof(buffer),
                                 "%s: %d,%d,\"%03lu%02lu\",%d",
                                 &ph_ss_ms_val->dsatetsicall_network_list.cmd_name[0],
                                 mode_val,
                                 fmt,
                                 mcc,mnc,
                                 net_act );
        }
       }
       if(ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS &&
                                               (oper_name->plmn_info_ptr != NULL))
       {
         if( oper_name->plmn_info_ptr[0]->plmn_id.csg_id != SYS_CSG_ID_INVALID )
         {
             size = (word)snprintf ((char*)(buffer),
                                      sizeof(buffer),
                                      "%s,%lu,%d",
                                      buffer,
                                      oper_name->plmn_info_ptr[0]->plmn_id.csg_id,
                                      ph_ss_ms_val->dsat_net_reg_state.csg_rat);
        }
      }
    }
    break;

    case DSAT_COPS_FMT_MAX:
    default:
      DS_AT_MSG1_ERROR ( "Unsupported format code: %d",fmt);
      return DSAT_ERROR;
    }
         
    res_buff_ptr = dsat_dsm_create_packet(buffer, size, FALSE);
    if (NULL != res_buff_ptr)
    {
      dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_COMPLETE_RSP);
    }
  }


  return DSAT_OK;
} /* etsicall_report_cops_result */

#ifdef FEATURE_SGLTE
/*===========================================================================

FUNCTION DSATETSICALL_REPORT_QCHCOPS_RESULT

DESCRIPTION
  This function generates the response for network query command $QCHCOPS
  read syntax.

DEPENDENCIES
  None
  
RETURN VALUE
  DSAT_OK : if it is a success for local execution
  DSAT_ERROR : if there was any problem in executing the command

SIDE EFFECTS
  May append further DSM items to original result buffer.
  
===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_report_qchcops_result
(
  ds_at_mmgsdi_oper_name_type *oper_name /* Operator name pointer */
)
{
  char                          buffer[MAX_NETWORK_REPORT_LEN];
  word                          size = 0;
  dsm_item_type                *res_buff_ptr   = NULL;
  dsatcmif_servs_state_ms_info *ph_ss_ms_val   = NULL;
  uint32                        name_len=0;
  dsat_cops_act_e_type          net_act;
  boolean                       plmn_undefined = FALSE;
  dsat_num_item_type            mode_val;
  dsat_cops_fmt_e_type          fmt;
  char                         *cp = buffer;
  uint32                        no_of_chars    = 0;
  sys_mcc_type                  mcc            = 0;
  sys_mnc_type                  mnc            = 0;

  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS, SYS_MODEM_AS_ID_2, FALSE);

  if(ph_ss_ms_val->dsatetsicall_network_list.cmd_state != DSAT_COPS_ASTATE_GET_NAME)
  {
    DS_AT_MSG0_ERROR("Invalid state");
    return DSAT_ASYNC_EVENT;
  }

  memset ((void*)buffer, 0x0, sizeof(buffer));

  net_act  = ph_ss_ms_val->dsat_net_reg_state.act;
  mode_val = (dsat_num_item_type)dsatutil_get_val(
                DSATETSI_EXT_ACT_COPS_ETSI_IDX,dsat_get_current_subs_id(FALSE),0,MIX_NUM_TYPE);
  fmt      = (dsat_num_item_type)dsatutil_get_val(
                DSATETSI_EXT_ACT_COPS_ETSI_IDX,dsat_get_current_subs_id(FALSE),1,MIX_NUM_TYPE);

  if(oper_name->num_of_plmn_ids != 1)
  {
    DS_AT_MSG1_ERROR(" Incorrect MMGSDI data found - %d plmn_ids ",oper_name->num_of_plmn_ids);
    return DSAT_ERROR;
  }

  /* Report the mode and current registration info */
  switch (fmt)
  {
    case DSAT_COPS_FMT_LONG:
    case DSAT_COPS_FMT_SHRT:
    {
      size = (word)snprintf (buffer, sizeof(buffer),
                                   "%s: %d,%d,\"",
                                   "$QCHCOPS",
                                   mode_val,
                                   fmt);
      if( size < MAX_NETWORK_REPORT_LEN )
      {
        cp = buffer + size;
      }
      if((fmt == DSAT_COPS_FMT_LONG) && (oper_name->plmn_info_ptr != NULL))
      {
        /*UCS2 encoding have 2 byte long char. e.g. 5 UCS2 character fit in 10 byte long array.*/
        if(MMGSDI_EONS_ENC_UCS2 == oper_name->plmn_info_ptr[0]->long_name_encoding)
        {
          oper_name->plmn_info_ptr[0]->long_name_len = (oper_name->plmn_info_ptr[0]->long_name_len)/2;
        }
        name_len = MIN(oper_name->plmn_info_ptr[0]->long_name_len,DSAT_MAX_FULLNAME_STR_LEN);
        DS_AT_MSG1_HIGH("name_len = %d",name_len);
        etsicall_convert_chrset_todefault(oper_name->plmn_info_ptr[0]->long_name_encoding,
                                          (const byte *)oper_name->plmn_info_ptr[0]->long_name,(size_t)name_len,(byte *) cp,
                                           DSAT_MAX_FULLNAME_STR_LEN,(size_t*)&no_of_chars);
        cp += no_of_chars;
      }
      else if((fmt == DSAT_COPS_FMT_SHRT) && (oper_name->plmn_info_ptr != NULL))
      {
        /*UCS2 encoding have 2 byte long char. e.g. 5 UCS2 character fit in 10 byte long array.*/
        if(MMGSDI_EONS_ENC_UCS2 == oper_name->plmn_info_ptr[0]->short_name_encoding)
        {
          oper_name->plmn_info_ptr[0]->short_name_len = (oper_name->plmn_info_ptr[0]->short_name_len)/2;
        }

        name_len = MIN(oper_name->plmn_info_ptr[0]->short_name_len,DSAT_MAX_SHORTNAME_STR_LEN);
        DS_AT_MSG1_HIGH("name_len = %d",name_len);
        etsicall_convert_chrset_todefault(oper_name->plmn_info_ptr[0]->short_name_encoding,
                                          (const byte *)oper_name->plmn_info_ptr[0]->short_name,(size_t)name_len,(byte *) cp,
                                           DSAT_MAX_SHORTNAME_STR_LEN,(size_t*)&no_of_chars);
        cp += no_of_chars;
      }
      if((oper_name->spn.eons_encoding != MMGSDI_EONS_ENC_INVALID) &&
          ( oper_name->spn.eons_data.data_len != 0))
      {
        if(no_of_chars != 0)
        {
          *cp++ = ' ';
        }

        if(MMGSDI_EONS_ENC_UCS2 == oper_name->spn.eons_encoding)
        {
          oper_name->spn.eons_data.data_len = (oper_name->spn.eons_data.data_len)/2;
        }

          name_len = MIN(oper_name->spn.eons_data.data_len,DSAT_MAX_FULLNAME_STR_LEN);
            etsicall_convert_chrset_todefault(oper_name->spn.eons_encoding,
                                            (const byte *)oper_name->spn.eons_data.data_ptr,(size_t)name_len,(byte *) cp,
                                              DSAT_MAX_FULLNAME_STR_LEN,(size_t*)&no_of_chars);

          cp += no_of_chars;
        }

        *cp++ = '"';
        *cp++ = ',';
        *cp++ = '0' + net_act ;
        *cp++ = '\0';
        size = cp - buffer;
        break;
      }
      case DSAT_COPS_FMT_PLMN:
      {
        boolean pcs_flag = FALSE;

        /* Convert PLMN to MCC/MNC */
        sys_plmn_get_mcc_mnc( ph_ss_ms_val->dsat_net_reg_state.net_id_info.plmn,
                              &plmn_undefined,
                              &pcs_flag,
                              &mcc,
                              &mnc );

        /* PLMN may be undefined */
        if (TRUE == plmn_undefined)
        {
          size = (word)snprintf (buffer, sizeof(buffer),
                                 "%s: %d,%d,\"\",%d",
                                 "$QCHCOPS",
                                 mode_val,
                                 fmt,
                                 net_act );
        }
      else
      {
        if ( pcs_flag )
        {
          /* Print MNC as 3 digits */
          size = (word)snprintf (buffer, sizeof(buffer),
                                 "%s: %d,%d,\"%03lu%03lu\",%d",
                                 "$QCHCOPS",
                                 mode_val,
                                 fmt,
                                 mcc,mnc,
                                 net_act );
        }
        else
        {
          size = (word)snprintf (buffer, sizeof(buffer),
                                 "%s: %d,%d,\"%03lu%02lu\",%d",
                                 "$QCHCOPS",
                                 mode_val,
                                 fmt,
                                 mcc,mnc,
                                 net_act );
        }
      }
      }
      break;

      case DSAT_COPS_FMT_MAX:
      default:
        DS_AT_MSG1_ERROR ( "Unsupported format code: %d",fmt);
        return DSAT_ERROR;
    }

  res_buff_ptr = dsat_dsm_create_packet(buffer, size, FALSE);
  if (NULL != res_buff_ptr)
  {
    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_COMPLETE_RSP);
  }

  return DSAT_OK;
} /* dsatetsicall_report_qchcops_result */
#endif /* FEATURE_SGLTE */

/*===========================================================================

FUNCTION ETSICALL_CONVERT_CHRSET_TODEFAULT

DESCRIPTION
  This function converts alpha packed,unpacked and UCS2 to default charset.
  cm_util api's are used to acheive the same.

DEPENDENCIES
  None.
  
RETURN VALUE
  None.
  
SIDE EFFECTS
  None.
  
===========================================================================*/
LOCAL void etsicall_convert_chrset_todefault
(
  mmgsdi_eons_encoding_enum_type enc_type,
  const byte  *src_data,
  size_t      src_size,
  byte        *dst_data,
  size_t      dst_size,
  size_t      *num_unpacked
)
{
  uint32 index = 0;
  uint16 buffer[DSAT_MAX_FULLNAME_STR_LEN+1];
  boolean convert_to_cscs = TRUE;
  size_t  num_of_chars = 0;
  byte temp_src[DSAT_MAX_FULLNAME_STR_LEN*2];
  #define STRIP_UNKNOWN_CHAR(buffer, t_len)\
  {\
    index = 0;\
    while ( (buffer[index]!=0xFF) && ( index < t_len ))\
    {\
      ++index;\
    }\
    buffer[index] = NULL;\
  }

  DS_AT_MSG1_HIGH ( "Encoding Type: %d",enc_type);
  switch(enc_type)
  {
    case MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED:
       cm_util_gsm7_unpack_remove_suspected_padding( src_data, src_size,dst_data,dst_size+1,&num_of_chars);
       break;
    case MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED:
       {
         (void) dsatutil_memscpy((void*)dst_data,
                 dst_size,(void*)src_data,src_size);
         
         STRIP_UNKNOWN_CHAR(dst_data,src_size);
         num_of_chars =(size_t)index;
       }  
       break;
    case MMGSDI_EONS_ENC_UCS2:
       memscpy(temp_src, sizeof(temp_src), src_data, src_size * 2);
       /* Received 16 bits information are in big endian. Converting to little endian */
       dsatutil_convert_endianness16(temp_src, src_size * 2);
       cm_util_utf16_to_gsm7((const uint16 *)temp_src,src_size,dst_data,dst_size+1,&num_of_chars);
       break;
    case MMGSDI_EONS_ENC_UCS2_PACKED:
        memset(&buffer,0x0,sizeof(buffer));
        src_size =  dsatutil_decode_ucs2_80_81_82_encoding(( uint8 *)src_data,src_size,
                               buffer,ARR_SIZE(buffer));
        src_size = MIN(src_size, (DSAT_MAX_FULLNAME_STR_LEN + 1));
        if (src_size > 0)
        {
          cm_util_utf16_to_gsm7((const uint16 *)buffer,src_size,dst_data,dst_size+1,&num_of_chars);
        }
        else
        {
          convert_to_cscs = FALSE;
          DS_AT_MSG0_ERROR("Empty buffer returned in UCS2 decoding");
          num_of_chars = 0;
        }
       break;
    default:
      convert_to_cscs = FALSE;
       break;
  }

   if ( NULL != num_unpacked )
   {
     *num_unpacked = num_of_chars;
   }

   DS_AT_MSG1_HIGH("num_of_chars %d", num_of_chars);

  if(convert_to_cscs)
  {
    if ( TRUE == dsatutil_convert_alpha_gsm_with_at_to_alpha_gsm( (const char *) dst_data,
                                                                  (char *) dst_data, 
                                                                   num_of_chars) )
    {
      if(dsatutil_convert_chset( (const char *) dst_data,
                                 ALPHA_GSM,
                                 (const char *) dst_data,
                                 (dsati_chset_type) dsatutil_get_val
                                           (DSATETSI_EXT_CSCS_IDX,0,0,NUM_TYPE),
                                 dst_size+1,
                                 TRUE) == NULL)
      {
         DS_AT_MSG1_MED("GSM 7 bit to %d char set conversion failure",
	                         (dsat_num_item_type) dsatutil_get_val(DSATETSI_EXT_CSCS_IDX,0,0,NUM_TYPE));
      }
    }	
  }
}
  

/*===========================================================================

FUNCTION ETSICALL_COPS_GENERATE_NETWORK_RESPONSE

DESCRIPTION
  This function generates the response for a single network.  The
  passed structure is cleared after reporting to indicate its been
  processed.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  May append further DSM items to original result buffer.
  
===========================================================================*/
LOCAL void etsicall_cops_generate_network_response
(
  ds_at_plmn_info        *plmn_info_ptr,
  boolean                 eons_available,
  sys_modem_as_id_e_type  subs_id,
  dsm_item_type          *res_buff_ptr           /*  Place to put response       */
)
{
  char buffer[MAX_NETWORK_REPORT_LEN];
  char full_name[DSAT_MAX_FULLNAME_STR_LEN+1];
  char short_name[DSAT_MAX_SHORTNAME_STR_LEN+1];
  dsat_net_state_e_type net_state;
  sys_mcc_type  mcc;
  sys_mnc_type  mnc;
  boolean hit = FALSE;
  boolean undef = TRUE;
  boolean pcs_flag = FALSE;
  word size;
  dsat_cops_act_e_type act;
  dsat_cops_csg_rat_e_type csg_rat = DSAT_COPS_CSG_RAT_MAX;
  dsat_csg_list_cat_e_type csg_list_cat = DSAT_CSG_LIST_CAT_UNKNOWN;
  uint8 j=0;
  uint8 name_len = DSAT_MAX_SHORTNAME_STR_LEN;
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;
  dsat_sys_detailed_plmn_list_s_type *alist  = NULL;

  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS, subs_id, FALSE);

  alist = dsat_get_cmd_mem_ptr();

  ASSERT(plmn_info_ptr != NULL);
  memset(buffer,0x00,sizeof(buffer));
  if(ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS && 
     plmn_info_ptr->plmn_id.csg_id != SYS_CSG_ID_INVALID )
  {
  for(j = 0 ; j < alist->length ; j++)
  {
      if( alist->info[j].csg_info.csg_id == plmn_info_ptr->plmn_id.csg_id )
      {
    if( memcmp((byte *)&alist->info[j].plmn.identity[0],plmn_info_ptr->plmn_id.plmn_id_val,3) == 0 )
    {
      hit = TRUE;
      break;
    }
    }
    }
    
  }
  else
  {
  for(j = 0 ; j < alist->length ; j++)
  {
    if( memcmp((byte *)&alist->info[j].plmn.identity[0],plmn_info_ptr->plmn_id.plmn_id_val,3) == 0 )
    {
      hit = TRUE;
      break;
    }
    }
  
  }
  if(!hit)
  {
    return;
  }

  /* Get the MCC & MNC from PLMN */    
  sys_plmn_get_mcc_mnc( alist->info[j].plmn,&undef, &pcs_flag, &mcc, &mnc );
  if (TRUE == undef)
    {
    mcc = mnc = 0;
    pcs_flag = FALSE;
  }

  memset ((void*)full_name, 0x0, sizeof(full_name));
  memset ((void*)short_name, 0x0, sizeof(short_name));

  net_state = etsicall_find_net_state ( &alist->info[j], &act );

  if(ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS && 
     plmn_info_ptr->plmn_id.csg_id != SYS_CSG_ID_INVALID )
  {
    switch(alist->info[j].rat)
    {
      case SYS_RAT_UMTS_RADIO_ACCESS:
        csg_rat = DSAT_COPS_CSG_RAT_UMTS;
        break;
#ifdef FEATURE_DSAT_LTE
      case SYS_RAT_LTE_RADIO_ACCESS:
        csg_rat = DSAT_COPS_CSG_RAT_LTE;
        break;
#endif /* FEATURE_DSAT_LTE */
      default:
        DS_AT_MSG1_HIGH("Invalid Rat %d",alist->info[j].rat);
        return; 
    }

    switch(alist->info[j].list_category)
    {
      case SYS_DETAILED_PLMN_LIST_ALLOWED_CSG:
        csg_list_cat = DSAT_CSG_LIST_CAT_ALLOWED;
        break;
      case SYS_DETAILED_PLMN_LIST_OPERATOR_CSG:
        csg_list_cat = DSAT_CSG_LIST_CAT_OPERATOR;
        break;
      default:
        csg_list_cat = DSAT_CSG_LIST_CAT_UNKNOWN;
    }
  }
  

  if(MMGSDI_EONS_ENC_UCS2 == plmn_info_ptr->short_name_encoding)
  {
    plmn_info_ptr->short_name_len = (plmn_info_ptr->short_name_len)/2;
  }

  name_len = (uint8) ( MIN(plmn_info_ptr->short_name_len,DSAT_MAX_SHORTNAME_STR_LEN) );
  DS_AT_MSG0_HIGH(" EONS available");
  if(name_len != 0 && plmn_info_ptr->short_name != NULL)
  {
    etsicall_convert_chrset_todefault(plmn_info_ptr->short_name_encoding,
                                            (const byte *)plmn_info_ptr->short_name,(size_t)name_len,(byte *)short_name,
                                             DSAT_MAX_SHORTNAME_STR_LEN,NULL);
  }

  if(MMGSDI_EONS_ENC_UCS2 == plmn_info_ptr->long_name_encoding)
  {
    plmn_info_ptr->long_name_len= (plmn_info_ptr->long_name_len)/2;
  }

  name_len = (uint8) ( MIN(plmn_info_ptr->long_name_len,DSAT_MAX_FULLNAME_STR_LEN) );
  if(name_len != 0 && plmn_info_ptr->long_name!= NULL)
  {
    etsicall_convert_chrset_todefault(plmn_info_ptr->long_name_encoding,
                                          (const byte *)plmn_info_ptr->long_name,(size_t)name_len,(byte *)full_name,
                                             DSAT_MAX_FULLNAME_STR_LEN,NULL);
  }
  if ( pcs_flag )
  {
    size = (word)snprintf( buffer, sizeof(buffer),
                           "(%d,\"%s\",\"%s\",\"%03lu%03lu\",%d",
                           net_state,
                           full_name,
                           short_name,
                           mcc, mnc,
                           act );
  }
  else
  {
    size = (word)snprintf( buffer, sizeof(buffer),
                           "(%d,\"%s\",\"%s\",\"%03lu%02lu\",%d",
                           net_state,
                           full_name,
                           short_name,
                           mcc, mnc,
                           act );
  }
  if(ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS &&
     SYS_CSG_ID_INVALID != plmn_info_ptr->plmn_id.csg_id)
  {
       size = (word)snprintf ((char*)buffer,
                               sizeof(buffer),
                               "%s,%lu,%d,%d),",
                               buffer,
                               plmn_info_ptr->plmn_id.csg_id,
                               csg_rat,
                               csg_list_cat);
     }
  else
  {
        size = (word)snprintf ((char*)buffer,
                                 sizeof(buffer),
                                 "%s),",
                                 buffer);
      }
  /* Clear the reported value to avoid duplication */
  memset((void *)&alist->info[j].plmn,0xFF, 3);

  dsat_dsm_pushdown_tail(&res_buff_ptr, buffer, size,
                         DSM_ITEM_POOL(res_buff_ptr), FALSE);

} /* etsicall_cops_generate_network_response */

/*===========================================================================

FUNCTION ETSICALL_COPS_COPY_CATEGORY

DESCRIPTION 
   Internal Function to copy PLMN ID info. Currently used for +COPS specific
   commands.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL void dsat_cops_copy_all_categories
(
  dsat_sys_detailed_plmn_list_s_type *plmn_list,
  mmgsdi_plmn_id_type                *plmn_id_list,
  dsat_cops_cmd_idx_e_type            cmd_idx
)
{
  dsat_num_item_type        i = 0;
  dsat_num_item_type        j = 0;
  dsat_num_item_type        k = 0;

  dsat_sys_detailed_plmn_list_s_type *alist        = plmn_list;
  mmgsdi_plmn_id_type                *plmn_id      = plmn_id_list;

  for(k=0; k < SYS_DETAILED_PLMN_LIST_CATEGORY_MAX; k++)
  {
    for ( j=0; (j < alist->length) && (j < SYS_PLMN_LIST_MAX_LENGTH ) && ( i < alist->length); j++ )
    {
      if(alist->info[j].list_category == k)
      {
        (void)dsatutil_memscpy(plmn_id->plmn_id_val,MMGSDI_PLMN_ID_SIZE,&alist->info[j].plmn.identity[0],MMGSDI_PLMN_ID_SIZE);
        switch(alist->info[j].rat) 
        {
          case SYS_RAT_GSM_RADIO_ACCESS: 
            plmn_id->rat = MMGSDI_RAT_GSM; 
            break;
          case SYS_RAT_UMTS_RADIO_ACCESS: 
            plmn_id->rat = MMGSDI_RAT_UMTS; 
            break; 
          case SYS_RAT_LTE_RADIO_ACCESS: 
            plmn_id->rat = MMGSDI_RAT_LTE; 
            break; 
          case SYS_RAT_TDS_RADIO_ACCESS: 
            plmn_id->rat = MMGSDI_RAT_TDS; 
            break; 
          default: 
            plmn_id->rat = MMGSDI_RAT_NONE;
        }
        if(cmd_idx == CMD_IDX_QCCSGCOPS) 
        {
          plmn_id->csg_id = alist->info[j].csg_info.csg_id;
        }
        else
        {
          plmn_id->csg_id = SYS_CSG_ID_INVALID;
        }
        plmn_id++;
        i++;
      } 
    }
  }
  DS_AT_MSG1_HIGH("etsicall_cops_copy_category() Total PLMNS Copied: [%d]",i);
} /*etsicall_cops_copy_category*/

/*===========================================================================

FUNCTION ETSICALL_FIND_NET_STATE

DESCRIPTION
  This function returns the network registraiton state for the passed
  PLMN information returned form Call Manager.  The ATCOP AcT decoded
  from the RAT is also returned by reference.

DEPENDENCIES
  None
  
RETURN VALUE
  Enum value indicating network registration state

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL dsat_net_state_e_type etsicall_find_net_state
(
  const dsat_sys_detailed_plmn_list_info_s_type * plmn_info_ptr,
  dsat_cops_act_e_type * act_ptr
)
{
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;

  ph_ss_ms_val = dsat_get_base_addr_current_subs(DSAT_SS_PH_MS_VALS);

  /* Decode the access technology paramater */
  switch (plmn_info_ptr->rat)
  {
  case SYS_RAT_UMTS_RADIO_ACCESS:
#ifdef FEATURE_TDSCDMA
  case SYS_RAT_TDS_RADIO_ACCESS:
#endif /* FEATURE_TDSCDMA */
    *act_ptr = DSAT_COPS_ACT_UTRAN;
    break;
#ifdef FEATURE_DSAT_LTE
  case SYS_RAT_LTE_RADIO_ACCESS:
    *act_ptr = DSAT_COPS_ACT_EUTRAN;
    break;
#endif /* FEATURE_DSAT_LTE */
  case SYS_RAT_GSM_RADIO_ACCESS:
  default:
    *act_ptr = DSAT_COPS_ACT_GSM;
    break;
  }

  /* If COPS is de-registered , then the plmn_forbidden status will
     not be filled correctly by lower layers. So setting
     the state to unknown */
  if( DSAT_COPS_MODE_DEREG == (dsat_num_item_type)dsatutil_get_val(
              DSATETSI_EXT_ACT_COPS_ETSI_IDX,dsat_get_current_subs_id(FALSE),0,MIX_NUM_TYPE) )
  {
    return DSAT_NET_STAT_UNKNOWN;
  }
  /* Check for forbidden state */
  if ( TRUE == plmn_info_ptr->plmn_forbidden )
    return DSAT_NET_STAT_FORBIDDEN;
  /* Check for current registration state */
  else if( ( TRUE ==
            sys_plmn_match ( ph_ss_ms_val->dsatetsicall_network_list.previous_pref.plmn,
                              plmn_info_ptr->plmn ) ) &&
           (ph_ss_ms_val->dsat_net_reg_state.act == *act_ptr) )
    return DSAT_NET_STAT_CURRENT;
  /* Otherwise set available state */
  else
    return DSAT_NET_STAT_AVAILABLE;
  
} /* etsicall_find_net_state */


/*===========================================================================

FUNCTION ETSICALL_CONVERT_MMINFO_OPER_NAME

DESCRIPTION
  This function converts the operator name received from NAS
  mobility management message into suitable format for TE
  presentation.  The IRA character set is the assumed output format.

DEPENDENCIES
  None
  
RETURN VALUE
  TRUE on successful conversion; FALSE otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL boolean etsicall_convert_mminfo_oper_name
(
  const uint8  * name_ptr,
  sys_network_name_coding_scheme_type_e_type  in_scheme,
  char         * out_ptr,
  uint8          max_len,
  uint8          encoded_len
)
{
  uint8 num_chars;

  DS_AT_MSG3_MED("etsicall_convert_mminfo_oper_name: in_scheme = %d max_len = %d "
          "encoded_len = %d", in_scheme, max_len, encoded_len);

  if (!encoded_len || !max_len)
  {
    DS_AT_MSG0_ERROR("etsicall_convert_mminfo_oper_name called on ntw name with max_len "
              "or encoded_len set to 0, returning FALSE");
    return FALSE;
  }

  /* Translate coding scheme */
  switch( in_scheme )
  {
  case SYS_NW_NAME_CODING_SCHEME_UCS2:
    /* Convert from OTA coding scheme, assuming IRA output */
    num_chars = MIN(encoded_len/2, max_len); /* UCS2 is 16 bits per char */
    if( NULL == dsatutil_convert_chset( (char*)name_ptr, ALPHA_UCS2,
                                        out_ptr, ALPHA_IRA,
                                        num_chars, TRUE ))
    {
       DS_AT_MSG0_ERROR("UCS2 decode of MM info failed");
       return FALSE;
    }
    break;
  case SYS_NW_NAME_CODING_SCHEME_CELL_BROADCAST_DEFAULT_ALPHABET:
  default:
      encoded_len = MIN(encoded_len, max_len);
      num_chars = cm_util_gsm_alphabet_to_ascii( (byte*) out_ptr,
                                                 name_ptr,
                                                 encoded_len );
      /* Spare bits will be set to '0' as documented in 3GPP TS24.008
       * Section 10.5.3.5a, but the CM util function unpacks it assuming
       * USSD packing (if 7 spare bits, pack with carriage return = 0x0D).
       * This causes it to append an '@' if there are 7 spare bits, so
       * detect and correct this case. */
      if ( !(encoded_len % 7) && !(name_ptr[encoded_len - 1] & 0xFE) &&
            (out_ptr[num_chars - 1] == '@') )
      {
        DS_AT_MSG0_HIGH("Detected 7 spare bits in network name, removing trailing @");
        out_ptr[num_chars - 1] = '\0';
      }
      break;
  }
  

  return TRUE;
} /* etsicall_convert_mminfo_oper_name */

/*===========================================================================

FUNCTION: ETSICALL_ENCODE_SUBADDR

DESCRIPTION
  Convert the ASCII subaddress to internal format.
  Refer to cm_util_subaddr_to_ascii() for decoding.
  Subaddress documented in GSM 04.08 section 10.5.4.8

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL void etsicall_encode_subaddr
(
  const byte   *ascii_subaddress,   /* SubAddress in ASCII */
  uint8  type,                      /* SubAddress type */
  byte   *subaddress,               /* Encoded SubAddress */
  byte   *length                    /* Length of SubAddress */
)
{
   byte *data_pointer = subaddress;
   const byte *s_pointer = ascii_subaddress;
   #define AFI_IA5 0x50
   
   /* Validate length or subaddress */
   *length = (byte)strlen((char*)ascii_subaddress);
   if (*length > (CM_CALLED_PARTY_SUBADDRESS_LENGTH - 2))
   {
     *length = 0;
     *subaddress = '\0';
     return;
   }

   /* array[0] = subaddress type */
   *data_pointer++ =  type;

   /* array[1] = AFI (Authority and Format Identifier) */
   *data_pointer++ = AFI_IA5;
   
   /* Encode each character */
   while ('\0' != *s_pointer)
   {
     *data_pointer++ = (*s_pointer++ - '0');
   }
   return;
} /* etsicall_encode_subaddr */

#if defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS)

/*===========================================================================

FUNCTION  ETSICALL_CONVERT_CBST_PARAM

DESCRIPTION
  This function converts the +CBST command paramaters to numeric values.
  If no paramater token is specified, the previous value exported is used.

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_OK     : processing successful
    DSAT_ERROR  : error encountered

SIDE EFFECTS
  None

===========================================================================*/
LOCAL boolean etsicall_convert_cbst_param
(
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  const uint8 index,
  dsat_num_item_type* value_ptr
)
{
  /* Check for valid token */
  if ( VALID_TOKEN(index) )
  {
    /* COnvert to numeric */
    if (ATOI_OK != 
        dsatutil_atoi( value_ptr, tok_ptr->arg[index], 10) ) 
    { 
      DS_AT_MSG1_ERROR("+CBST parameter conversion error: %d",index);
      return FALSE; 
    }
  }
  else
  {
    /* Use previous export value */
    *value_ptr = dsat_cbst_export_val[index];
  }
  return TRUE;      
}


/*===========================================================================

FUNCTION ETSICALL_PROCESS_CRLP_PARAM

DESCRIPTION
  This function performs parameter set processing/conversion for +CRLP.
  The target parameter to process is passed as an index.  The result is
  passed back to the caller by reference.
  If no token string value was specified, no processing occurs.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of validation.
  possible values:
    DSAT_ERROR : if there was any problem
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL dsat_result_enum_type etsicall_process_crlp_param
(
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  const dflm_type *def_lim_ptr,         /*  Ptr to parameter limits     */
  const uint32 pindex,                  /*  Parameter index             */
  void * result_ptr                     /*  Pointer to result           */  
)
{
  const word radix = 10;

  /* Check for user specified value */
  if ( VALID_TOKEN(pindex) )
  {
    /* Convert to number */
    if (ATOI_OK != dsatutil_atoi(result_ptr, tok_ptr->arg[pindex], radix))
    {
      DS_AT_MSG1_HIGH("Cannot convert parameter %d",pindex);
      return DSAT_ERROR;
    }

    /* Check against limits */
    if ( (def_lim_ptr[pindex].lower > *(uint32*)result_ptr) ||
         (def_lim_ptr[pindex].upper < *(uint32*)result_ptr) )
    {
      /* Value outside limits */
      DS_AT_MSG3_HIGH("Value outside range: %d [%d, %d]",*(int32*)result_ptr,
                def_lim_ptr[pindex].lower,
                def_lim_ptr[pindex].upper);
      return DSAT_ERROR;
    }
  }
  return DSAT_OK; 
} /* etsicall_process_crlp_param */

#endif /* defined(FEATURE_DATA_GCSD) || defined(FEATURE_DATA_WCDMA_CS) */


/*===========================================================================

FUNCTION ETSICALL_REPORT_AOC_CCM

DESCRIPTION
  This function displays the current call meter reported by Call Manager

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void etsicall_report_aoc_ccm
(
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  char name[8];
  uint32 ccm_val = 0;
  boolean unsolicited_rc = FALSE;
  dsatetsicall_call_state_ms_info  *call_ms_val = NULL;
  
  call_ms_val = dsat_get_base_addr_current_subs(DSAT_CALL_MS_VALS);

  /* Check to ensure (unsolicited) response is still required */
  if (1 == (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_ACT_CAOC_ETSI_IDX,0,0,NUM_TYPE))
    return;

  /* Query Call Manager for current call meter */
  /* Returned value is in units of 1000's (per UI code) */
  ccm_val = cm_ph_cmd_aoc_get_ccm() / 1000;

  /* For unsolicited response, ensure CCM value has changed */
  if ( (2 == (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_ACT_CAOC_ETSI_IDX,
                   0,0,NUM_TYPE)) &&(call_ms_val->etsicall_prev_ccm_val == ccm_val) )
    return;
    
  /* Allocate result buffer for asynchronous reporting */
  if (NULL == res_buff_ptr)
  {
    res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);
    unsolicited_rc = TRUE;
    
    (void)strlcpy(name, "+CCCM", sizeof(name));
  }
  else
  {
    (void)strlcpy(name, "+CAOC", sizeof(name));
  }
  
  /* Format the response */
  res_buff_ptr->used = (word)snprintf ((char*)res_buff_ptr->data_ptr,
                                             res_buff_ptr->size,
                                             "%s: \"%02X%02X%02X\"",
                                             name,
                                             (uint8)(ccm_val>>16 & 0xFF),
                                             (uint8)(ccm_val>>8  & 0xFF),
                                             (uint8)(ccm_val     & 0xFF));
  
  if ( TRUE == unsolicited_rc )
  {
    (void)dsatcmdp_send_respose_to_te (res_buff_ptr, DSAT_COMPLETE_RSP);

    /* Only for unsolicited case update previous value to force first
     * report even if direct query has just been done */
    call_ms_val->etsicall_prev_ccm_val =  ccm_val;
  }
  
} /* etsicall_report_aoc_ccm */

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_COLP_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +COLP command, which enables/disables the display of 
  connected line identification of the remote party

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_colp_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsatetsicmif_sups_state_ms_info  *sups_ms_val = NULL;
  
  sups_ms_val = dsat_get_base_addr_current_subs(DSAT_SUPS_MS_VALS);

  /*--------------------------------------------------------------------------
   Invoke the general AT parameter handler for WRITE & TEST commands
  ---------------------------------------------------------------------------*/
  if((tok_ptr->op == (NA|EQ|AR)) || (tok_ptr->op == (NA|EQ|QU)) ||
     (tok_ptr->op == (NA)))
  {
    result = dsatparm_exec_param_cmd(mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr);
    return result;
  }
  /*------------------------------
   Processing for READ command 
  -------------------------------*/
  else if(tok_ptr->op == (NA|QU))
  {
    cm_interr_ss_params_s_type   interr_colp_params;

    memset(&interr_colp_params, 0, sizeof(cm_interr_ss_params_s_type));
    /* Service code for Connected Line Identification Presentation */
    interr_colp_params.ss_code = (uint8)colp;

    interr_colp_params.basic_service.code_type = NO_CODE;
    interr_colp_params.basic_service.present   = FALSE;

    if(dsatetsicmif_cm_sups_cmd_interrogate(
           NULL, dsatcm_client_id, &interr_colp_params) == TRUE)
    {
      /* Mark interrogating SS service as COLP */
      sups_ms_val->dsat_interr_ss_service = colp;
      sups_ms_val->dsat_ss_abort_status  = FALSE;

      return DSAT_ASYNC_CMD;
    }
    else
    {
      return dsat_send_cme_error(DSAT_CME_PHONE_FAILURE);
    }
  }
  else
  {
    /* wrong operation */
    return DSAT_ERROR;
  }
} /* dsatetsicall_exec_colp_cmd */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CLIP_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CLIP command, which enables/disables the display of 
  calling line identification of the remote party

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_clip_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsatetsicmif_sups_state_ms_info  *sups_ms_val = NULL;
  
  sups_ms_val = dsat_get_base_addr_current_subs(DSAT_SUPS_MS_VALS);

  /*--------------------------------------------------------------------------
   Invoke the general AT parameter handler for WRITE & TEST commands
  ---------------------------------------------------------------------------*/
  if((tok_ptr->op == (NA|EQ|AR)) || (tok_ptr->op == (NA|EQ|QU)) || 
     (tok_ptr->op == (NA)))
  {
    result = dsatparm_exec_param_cmd(mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr);
  }  
  /*------------------------------
   Processing for READ command 
  -------------------------------*/
  else if(tok_ptr->op == (NA|QU))
  {
    cm_interr_ss_params_s_type   interr_clip_params;

    memset(&interr_clip_params, 0, sizeof(cm_interr_ss_params_s_type));

    /* Service code for CLIP  */
    interr_clip_params.ss_code = (uint8)clip;

    interr_clip_params.basic_service.code_type = NO_CODE;
    interr_clip_params.basic_service.present   = FALSE;

    if(dsatetsicmif_cm_sups_cmd_interrogate(
       NULL, dsatcm_client_id, &interr_clip_params) == TRUE)
    {
      /* Mark interrogating SS service as CLIP */
      sups_ms_val->dsat_interr_ss_service = clip;
      sups_ms_val->dsat_ss_abort_status = FALSE;

      return DSAT_ASYNC_CMD;
    }
    else
    {
      return dsat_send_cme_error(DSAT_CME_PHONE_FAILURE);
    }
  }
  else
  {
    /* wrong operation */
    return DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_clip_cmd */


/*===========================================================================

FUNCTION  DSATETSICALL_REPORT_SS_LINEID_STATUS

DESCRIPTION
  This function reports the COLP/CLIP/CDIP supplementary service status
  received from Call Manager.

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR :    if there was any problem in execution.
    DSAT_OK :       if it is a success.

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_report_ss_lineid_status
(
  ss_operation_code_T       * op_code,    /* Interrogation operation code */
  const ie_ss_status_T      * ss_info_ptr, /* SS info pointer */
  boolean                     in_service
)
{
  dsm_item_type           *res_buff_ptr = NULL;
  uint32                   ss_status;
  dsat_result_enum_type    result = DSAT_OK;

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, FALSE);

  if(in_service == FALSE)
  {
    ss_status = DSAT_NO_NW_SERVICE;
  }
  else if (ss_info_ptr->present)
  {
    ss_status = ss_info_ptr->cm_ss_provisioned;
  }
  else
  {
    ss_status = DSAT_NO_NW_SERVICE;
  }

  switch(*op_code)
  {
    case colp:
      res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                          res_buff_ptr->size,
                                          "+COLP: %u,%lu",
                                          (dsat_num_item_type)dsatutil_get_val(
                                          DSATETSI_EXT_ACT_COLP_ETSI_IDX,0,0,NUM_TYPE),
                                          ss_status );
      break;

    case clip:
      res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                          res_buff_ptr->size,
                                          "+CLIP: %u,%lu",
                                          (dsat_num_item_type)dsatutil_get_val(
                                           DSATETSI_EXT_ACT_CLIP_ETSI_IDX,0,0,NUM_TYPE),
                                          ss_status);
      break;

      case allLineIdentificationSS:
        res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                            (res_buff_ptr->size - res_buff_ptr->used),
                                            "+CDIP: %u,%lu",
                                            (dsat_num_item_type)dsatutil_get_val(
                                            DSATETSI_EXT_ACT_CDIP_ETSI_IDX,0,0,NUM_TYPE),
                                            ss_status);
        break;


      case clir:
      res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                          res_buff_ptr->size,
                                          "+CLIR: %u,%lu",
                                          (dsat_num_item_type)dsatutil_get_val(
                                          DSATETSI_EXT_ACT_CLIR_ETSI_IDX,0,0,NUM_TYPE),
                                          ss_status);
      break;

    default:
      /* Being defensive when opcode is not colp/clip/clir & memory 
         was allocated earlier */
      dsm_free_packet(&res_buff_ptr);
      DS_AT_MSG1_ERROR("Invalid operation code %d", *op_code);
      result = DSAT_ERROR;
  }

  *op_code = (ss_operation_code_T)DSAT_INVALID_OP_CODE;
  if(result == DSAT_OK)
  {
    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_COMPLETE_RSP);
  }
  return result;
} /* dsatetsicall_report_ss_lineid_status */


/*===========================================================================

FUNCTION  DSAT_LINEID_BUF_COPY

DESCRIPTION
  This function fills out CLIP/COLP unified lineid buffer with call subaddress.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL void etsicall_lineid_buf_copy
(
  sys_modem_as_id_e_type  subs_id,
  const uint8            *line_num_buf,
  uint8                   line_num_len
)
{
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  dsat_num_item_type buffer_size = 0;
  
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length] = '"';
  call_da_val->dsat_lineid_buf_length++;

  buffer_size = DSAT_BUF_SIZE(DSAT_MAX_LINEID_BUF,call_da_val->dsat_lineid_buf_length);
  
  if(line_num_len <= CM_MAX_NUMBER_CHARS && buffer_size > 0)
  {
    (void) dsatutil_memscpy((void*)&call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length],
          buffer_size,(void*)line_num_buf,line_num_len);
  }else
  {
    DS_AT_MSG1_ERROR("LineID Buffer overflow %d", call_da_val->dsat_lineid_buf_length);
    return;
  }
  
  call_da_val->dsat_lineid_buf_length += line_num_len;

  if( call_da_val->dsat_lineid_buf_length < DSAT_MAX_LINEID_BUF)
  {
    call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length] = '"';
    call_da_val->dsat_lineid_buf_length++;
  }
} /* etsicall_lineid_buf_copy */


/*===========================================================================

FUNCTION  DSAT_LINEID_SUBADDR_BUF_COPY

DESCRIPTION
  This function fills out CLIP/COLP unified lineid buffer with call subaddress.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
LOCAL void etsicall_lineid_subaddr_buf_copy
(
  sys_modem_as_id_e_type  subs_id,
  const uint8            *line_num_buf,
  uint8                   line_num_len
)
{
  dsat_num_item_type buffer_size = 0;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length] = '"';
  call_da_val->dsat_lineid_buf_length++;

  buffer_size = DSAT_BUF_SIZE(DSAT_MAX_LINEID_BUF,call_da_val->dsat_lineid_buf_length);

  if(line_num_len <= CM_MAX_SUBADDRESS_DIGITS && buffer_size > 0)
  {
    (void) dsatutil_memscpy((void*)&call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length],
               buffer_size,
               (void*)line_num_buf,
               line_num_len);
  }
  else
  {
    goto lineid_buf_overflow;
  }

  call_da_val->dsat_lineid_buf_length += line_num_len;

  buffer_size = DSAT_BUF_SIZE(DSAT_MAX_LINEID_BUF,call_da_val->dsat_lineid_buf_length);

  if (0 == buffer_size)
  {
    goto lineid_buf_overflow;
  }

  call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length] = '"';
  call_da_val->dsat_lineid_buf_length++;
  return;

lineid_buf_overflow:

  DS_AT_MSG1_ERROR("LineID Buffer overflow %d", call_da_val->dsat_lineid_buf_length);
  return;
} /* etsicall_lineid_subaddr_buf_copy */

/*===========================================================================

FUNCTION  ETSICALL_CALLED_LINEID_BUF_COPY

DESCRIPTION
  This function fills out CDIP unified lineid buffer with call subaddress.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL void etsicall_called_lineid_buf_copy
(
  sys_modem_as_id_e_type  subs_id,
  const uint8            *line_num_buf,
  uint8                   line_num_len
)
{

  dsat_num_item_type buffer_size = 0;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  call_da_val->dsat_called_lineid_buf[call_da_val->dsat_called_lineid_buf_length] = '"';
  call_da_val->dsat_called_lineid_buf_length++;

  buffer_size = DSAT_BUF_SIZE(DSAT_MAX_CALLED_LINEID_BUF,call_da_val->dsat_called_lineid_buf_length);
  if(buffer_size > 0)
  {
    (void) dsatutil_memscpy((void*)&call_da_val->dsat_called_lineid_buf[call_da_val->dsat_called_lineid_buf_length],
             buffer_size,
             (void*)line_num_buf,
             line_num_len);
  }else
  {
    DS_AT_MSG1_ERROR("Called LineID Buffer overflow %d", call_da_val->dsat_called_lineid_buf_length);
    return;
  }
  call_da_val->dsat_called_lineid_buf_length += line_num_len;

  call_da_val->dsat_called_lineid_buf[call_da_val->dsat_called_lineid_buf_length] = '"';
  call_da_val->dsat_called_lineid_buf_length++;
} /* etsicall_called_lineid_buf_copy */

/*===========================================================================

FUNCTION  DSATETSICALL_REPORT_CLIP_RESULT

DESCRIPTION
  This function accumulates all the CLIP data and calls the PBM to retrieve 
  name.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatetsicall_report_clip_result
(
  ds_at_cm_call_event_type *call_event_ptr, /* Call event pointer */
  sys_modem_as_id_e_type    subs_id
)
{
  dsm_item_type           *res_buff_ptr;
  byte                dsat_cli_presence = DSAT_CLI_INVALID;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  dsatme_mmgsdi_state_ss_info      *me_ss_val = NULL;

  me_ss_val = dsat_get_base_addr(DSAT_MMGSDI_SS_VALS, FALSE);
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  memset((void *)call_da_val->dsat_lineid_buf, 0, DSAT_MAX_LINEID_BUF);
  call_da_val->dsat_lineid_buf_length = 0;

  /* 3GPP spec 24.008(Rel 5): Section 10.5.4.9 Calling party BCD number 
  octet 3:bit 8 holds extension indicator.

  8    7    6    5    4    3    2    1	
  ------------------------------------
  0/1|   type of  |    Numbering plan
  ext|   number   |    identification
  -----------------------------------

  octet 3a: bits 6, 7 hold presentation indicator.

  8      7    6    5    4    3    2    1	
  ------------------------------------
  1  |present. |   0   0   0  | screening	
  ext|indicator|  spare       | indicator
  ------------------------------------

  Presentation indicator (octet 3a)
  Bits
  7	 6			
  0	 0	Presentation allowed
  0	 1	Presentation restricted
  1	 0	Number not available due to interworking
  1	 1	Reserved
  */

  if((boolean)
     ((call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.calling_party_bcd_number.data[0]
         & CM_EXTENSION_BIT) >> 7) == FALSE)
  { 
    /* This indicates presence of Extension Indicator in the incoming 
       setup message. Extract presentation allowed/restricted status */
    dsat_cli_presence = (byte)(
      (call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.calling_party_bcd_number.
      data[1] & CM_PRESENTATION_IND_MASK) >> 5);
  }
  else if(call_event_ptr->event_info.num.len > 0)
  {
    dsat_cli_presence = DSAT_CLI_ALLOWED;
  }
  (void) dsatutil_memscpy((void*)call_da_val->dsat_lineid_buf,
          DSAT_MAX_LINEID_BUF,(void*)"+CLIP: ",7); 
  call_da_val->dsat_lineid_buf_length = 7;

  if(dsat_cli_presence == DSAT_CLI_ALLOWED)
  {
    etsicall_lineid_buf_copy(subs_id, call_event_ptr->event_info.num.buf,
                           call_event_ptr->event_info.num.len);

    /* Number type */
    if(call_event_ptr->event_info.num.buf[0] == DSAT_TA_INTER_PREFIX)
    { 
      call_da_val->dsat_lineid_buf_length += (uint32)snprintf(
                (char *)&call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length],
                (int)DSAT_MAX_LINEID_BUF - call_da_val->dsat_lineid_buf_length,
                ",%d,", DSAT_TA_INTERNATIONAL);
    } 
    else
    { 
      call_da_val->dsat_lineid_buf_length += (uint32)snprintf(
                    (char *)&call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length],
                    (int)DSAT_MAX_LINEID_BUF-call_da_val->dsat_lineid_buf_length,
                    ",%d,",
      0x80|((call_event_ptr->event_info.num.number_type & 0x07) << 4)|
           (call_event_ptr->event_info.num.number_plan & 0x0F));
    }

    if( call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.calling_party_subaddress.present == TRUE ) 
    {
     /* Subaddress */
     etsicall_lineid_subaddr_buf_copy(subs_id, call_event_ptr->event_info.num.subaddr.chari,
                                 call_event_ptr->event_info.num.subaddr.num_char);

     /* Subaddress type */
     call_da_val->dsat_lineid_buf_length += (uint32)snprintf(
                    (char *)&call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length], 
                    (int)DSAT_MAX_LINEID_BUF- call_da_val->dsat_lineid_buf_length,
                    "%d,",call_event_ptr->event_info.num.subaddr.subadd_type);
    }
    else
    {
      call_da_val->dsat_lineid_buf_length += (uint32)snprintf(
                     (char *)&call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length],
                     (int)DSAT_MAX_LINEID_BUF- call_da_val->dsat_lineid_buf_length,
                     ",,");
    }

#ifdef FEATURE_ETSI_PBM
    /* The missing link is now ALPHA tag in the message.
     Make a call to Phonebook entity to retrieve the tag */
    if(dsatetsime_get_alphanumeric_name(call_event_ptr->event_info.num.buf, 
                             MIN(CM_MAX_NUMBER_CHARS,call_event_ptr->event_info.num.len)) == PBM_SUCCESS)
    {
      call_da_val->dsat_lineid_buf_length += (uint32)snprintf(
          (char *)&call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length],
          (int)DSAT_MAX_LINEID_BUF - call_da_val->dsat_lineid_buf_length,
          "\"%s\"",me_ss_val->dsat_alpha_text);
    }
#endif  /* FEATURE_ETSI_PBM */

    call_da_val->dsat_lineid_buf_length += (uint32)snprintf(
                  (char *)&call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length],
                  (int)DSAT_MAX_LINEID_BUF- call_da_val->dsat_lineid_buf_length,
                  ",%d", dsat_cli_presence);

  } 
  else
  {
    call_da_val->dsat_lineid_buf_length += (word)snprintf(
         (char*)&call_da_val->dsat_lineid_buf[call_da_val->dsat_lineid_buf_length],
         (int)DSAT_MAX_LINEID_BUF- call_da_val->dsat_lineid_buf_length,
         "\"\",%d,,,,%d", DSAT_CLIP_NUMBER_TYPE_UNKNOWN,
         dsat_cli_presence);
  }

  if((dsat_num_item_type)dsatutil_get_val(
        DSATETSI_EXT_ACT_CLIP_ETSI_IDX,0,0,NUM_TYPE) == DSAT_CLIP_ENABLED)
  {
    res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
    if (NULL != res_buff_ptr)
    {
      (void) dsatutil_memscpy((void*)res_buff_ptr->data_ptr,
              res_buff_ptr->size,(void*)call_da_val->dsat_lineid_buf,
              MIN(DSAT_MAX_LINEID_BUF, call_da_val->dsat_lineid_buf_length));

      res_buff_ptr->used = (uint16)MIN(DSAT_MAX_LINEID_BUF, call_da_val->dsat_lineid_buf_length);

      /* Send response to TE */
      DSAT_SEND_RESPONSE( res_buff_ptr, DSAT_COMPLETE_RSP );
    }
  }
  dsat_clip_pending[subs_id] = FALSE;
} /* dsatetsicall_report_clip_result */


/*==========================================================================
FUNCTION  DSATETSICALL_REPORT_CLIP_RESULT_RING

DESCRIPTION
  This function report Caller ID to the TE if CLIP reporting is enabled.

DEPENDENCIES
  None

RETURN VALUE
  void.

SIDE EFFECTS
  None

===========================================================================*/
void dsatetsicall_report_clip_result_ring
(
  sys_modem_as_id_e_type subs_id
)
{
  dsm_item_type           *res_buff_ptr;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
  if (NULL != res_buff_ptr)
  {
    (void) dsatutil_memscpy((void*)res_buff_ptr->data_ptr,
            res_buff_ptr->size,(void*)call_da_val->dsat_lineid_buf,
            MIN(DSAT_MAX_LINEID_BUF,call_da_val->dsat_lineid_buf_length));

    res_buff_ptr->used = (uint16)MIN(DSAT_MAX_LINEID_BUF,call_da_val->dsat_lineid_buf_length);

    dsatcmdp_send_urc_per_subs(subs_id, res_buff_ptr, DSAT_COMPLETE_RSP);
  }
} /* dsatetsicall_report_clip_result_ring */


/*===========================================================================

FUNCTION  DSATETSICALL_REPORT_COLP_RESULT

DESCRIPTION
  This function report connected number to the TE if CLIP reporting is enabled.

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None

===========================================================================*/
void dsatetsicall_report_colp_result
(
  ds_at_cm_call_event_type *call_event_ptr, /* Call event pointer */
  sys_modem_as_id_e_type    subs_id
)
{
  dsm_item_type             *res_buff_ptr;
  dsat_cm_gw_cs_call_info_s_type *mode_info_ptr;
  byte         dsat_cli_presence = DSAT_CLI_ALLOWED;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  dsatme_mmgsdi_state_ss_info      *me_ss_val = NULL;

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
  if (NULL == res_buff_ptr)
  {
    return;
  }

  me_ss_val = dsat_get_base_addr(DSAT_MMGSDI_SS_VALS, FALSE);
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS,subs_id, FALSE);

  mode_info_ptr = &call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call;

  (void) dsatutil_memscpy((void*)res_buff_ptr->data_ptr,
          res_buff_ptr->size,(void*)"+COLP: ",7); 
  res_buff_ptr->used = 7;

  if(dsat_cli_presence == DSAT_CLI_ALLOWED)
  {
    res_buff_ptr->data_ptr[res_buff_ptr->used] = '"';
    res_buff_ptr->used += 1;

    (void) dsatutil_memscpy((void*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
            DSAT_BUF_SIZE(res_buff_ptr->size,res_buff_ptr->used),
            (void*)call_event_ptr->event_info.num.buf,
            MIN(CM_MAX_NUMBER_CHARS,call_event_ptr->event_info.num.len));

    res_buff_ptr->used += call_event_ptr->event_info.num.len;
    
    res_buff_ptr->data_ptr[res_buff_ptr->used] = '"';
    res_buff_ptr->used += 1;

    res_buff_ptr->used += (word)snprintf(
                            (char *)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                            res_buff_ptr->size - res_buff_ptr->used,
                            ",%d,", 
                            0x80|call_event_ptr->event_info.num.number_type
                                |call_event_ptr->event_info.num.number_plan );

  if( TRUE == mode_info_ptr->called_party_subaddress.present ||
      TRUE == mode_info_ptr->connected_subaddress.present )
    { 
      /* Subaddress */ 
      res_buff_ptr->data_ptr[res_buff_ptr->used] = '"';
      res_buff_ptr->used += 1;

      (void) dsatutil_memscpy((void*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
              DSAT_BUF_SIZE(res_buff_ptr->size,res_buff_ptr->used),
              (void*)call_event_ptr->event_info.num.subaddr.chari,
                     MIN(CM_MAX_SUBADDRESS_DIGITS,call_event_ptr->event_info.num.subaddr.num_char));

      res_buff_ptr->used += call_event_ptr->event_info.num.subaddr.num_char;

      res_buff_ptr->data_ptr[res_buff_ptr->used] = '"';
      res_buff_ptr->used += 1;

      /* Subaddress type */
      res_buff_ptr->used += (word)snprintf(
                        (char *)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                        res_buff_ptr->size - res_buff_ptr->used,
                        "%d",
                        call_event_ptr->event_info.num.subaddr.subadd_type);
    } 
    else
    { 
      res_buff_ptr->used += (word)snprintf(
                        (char *)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                        res_buff_ptr->size - res_buff_ptr->used,
                        ",");
    } 

    /* The missing link is now ALPHA tag in the message.
       Make a call to Phonebook entity to retrieve the tag */

#ifdef FEATURE_ETSI_PBM
    if(dsatetsime_get_alphanumeric_name(call_event_ptr->event_info.num.buf, 
          MIN(CM_MAX_NUMBER_CHARS,call_event_ptr->event_info.num.len)) == PBM_SUCCESS)
    { 
      res_buff_ptr->used += (word)snprintf(
            (char *)&res_buff_ptr->data_ptr[res_buff_ptr->used], 
            res_buff_ptr->size - res_buff_ptr->used,",\"%s\"",
            me_ss_val->dsat_alpha_text);
    } 
    else
#endif  /* FEATURE_ETSI_PBM */
    {
         res_buff_ptr->data_ptr[res_buff_ptr->used] = ',';
         res_buff_ptr->used += 1;
        
    }
  }
  else
  {
    res_buff_ptr->used += (word)snprintf(
         (char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
         res_buff_ptr->size - res_buff_ptr->used,"\"\",%d,,,",
         DSAT_CLIP_NUMBER_TYPE_UNKNOWN);
  }

  dsatcmdp_send_urc_per_subs(subs_id, res_buff_ptr, DSAT_COMPLETE_RSP);
  dsat_colp_pending[subs_id] = FALSE;
} /* dsatetsicall_report_colp_result */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CDIP_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CDIP command, which enables/disables the display of 
  called line identification.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.
    DSAT_ASYNC_CMD : For interrogating with the network and getting the response
                     from the network.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cdip_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsatetsicmif_sups_state_ms_info  *sups_ms_val = NULL;

  sups_ms_val = dsat_get_base_addr_current_subs(DSAT_SUPS_MS_VALS);

  /*--------------------------------------------------------------------------
   Invoke the general AT parameter handler for WRITE & TEST commands
  ---------------------------------------------------------------------------*/
  if((tok_ptr->op == (NA|EQ|AR)) || (tok_ptr->op == (NA|EQ|QU)) || 
     (tok_ptr->op == (NA)))
  {
    result = dsatparm_exec_param_cmd(mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr);
  }  
  /*------------------------------
   Processing for READ command 
  -------------------------------*/
  else if(tok_ptr->op == (NA|QU))
  {
    cm_interr_ss_params_s_type   interr_cdip_params;

    /* Service code for CDIP  */
    interr_cdip_params.ss_code = (uint8) allLineIdentificationSS;
    interr_cdip_params.basic_service.code_type = NO_CODE;
    interr_cdip_params.basic_service.present   = FALSE;

    if(dsatetsicmif_cm_sups_cmd_interrogate(
       NULL, dsatcm_client_id, &interr_cdip_params) == TRUE)
    {
      /* Mark interrogating SS service as CDIP */
      sups_ms_val->dsat_interr_ss_service =allLineIdentificationSS ;
      sups_ms_val->dsat_ss_abort_status = FALSE;

      return DSAT_ASYNC_CMD;
    }
    else
    {
      return dsat_send_cme_error(DSAT_CME_PHONE_FAILURE);
    }
  }
  else
  {
    /* wrong operation */
    return DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_cdip_cmd */

/*===========================================================================

FUNCTION  DSATETSICALL_REPORT_CDIP_RESULT

DESCRIPTION
  This function accumulates all the CDIP data and calls the PBM to retrieve 
  name.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatetsicall_report_cdip_result
(
  ds_at_cm_call_event_type *call_event_ptr, /* Call event pointer */
  sys_modem_as_id_e_type    subs_id
)
{
  dsm_item_type           *res_buff_ptr;
  byte called_party_bcd_num[CM_CALLED_PARTY_BCD_NO_LENGTH] = {0};
  byte called_party_ascii_num[CM_MAX_DIALED_DIGITS] = {0};
  byte subaddress_ascii[CM_MAX_SUBADDRESS_DIGITS] = {0};
  byte subaddress_length = 0;
  byte num_length = 0;
  byte ton_npi; /* Type of number and Number plan Identification */
  byte number_type;
  byte number_plan;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  dsatme_mmgsdi_state_ss_info      *me_ss_val = NULL;

  me_ss_val = dsat_get_base_addr(DSAT_MMGSDI_SS_VALS, FALSE);
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS,subs_id, FALSE);

  (void) dsatutil_memscpy((void*)call_da_val->dsat_called_lineid_buf,
          DSAT_MAX_CALLED_LINEID_BUF,(void*)"+CDIP: ",7);
  
  call_da_val->dsat_called_lineid_buf_length = 7;

  memset( called_party_bcd_num, 0, CM_CALLED_PARTY_BCD_NO_LENGTH );
  called_party_bcd_num[BCD_LEN] = call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.called_party_bcd_number.length;
  if ( called_party_bcd_num[BCD_LEN] > MAX_BCD_NUMBER_LEN )
  {
    called_party_bcd_num[BCD_LEN] = MAX_BCD_NUMBER_LEN;
  }	
  (void) dsatutil_memscpy((void*)&called_party_bcd_num[1],
          CM_CALLED_PARTY_BCD_NO_LENGTH - 1 ,
          (void*)call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.called_party_bcd_number.data,
          MIN(CM_CALLED_PARTY_BCD_NO_LENGTH,called_party_bcd_num[BCD_LEN]));

  cm_util_bcd_num_to_ascii_num( called_party_bcd_num,
                        called_party_ascii_num,sizeof(called_party_ascii_num));
  num_length = (byte )strlen((char *)called_party_ascii_num);

  etsicall_called_lineid_buf_copy(subs_id, called_party_ascii_num,MIN(CM_MAX_DIALED_DIGITS,num_length));
  
  /* Number type */
  if(called_party_ascii_num[0] == DSAT_TA_INTER_PREFIX)
  {
    call_da_val->dsat_called_lineid_buf_length += 
        (uint32)snprintf((char *)&call_da_val->dsat_called_lineid_buf[call_da_val->dsat_called_lineid_buf_length],
                          DSAT_MAX_CALLED_LINEID_BUF - call_da_val->dsat_called_lineid_buf_length,
                         ",%d,", 
                         DSAT_TA_INTERNATIONAL
                       );
  }
  else
  {
    ton_npi = call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.called_party_bcd_number.data[0];
    number_plan = (byte)(ton_npi & CM_NUM_PLAN_MASK);
    number_type = (byte) (ton_npi & CM_TON_MASK);
    call_da_val->dsat_called_lineid_buf_length += 
        (uint32)snprintf((char *)&call_da_val->dsat_called_lineid_buf[call_da_val->dsat_called_lineid_buf_length],
                          DSAT_MAX_CALLED_LINEID_BUF,
                        ",%d,",
                        0x80 |(number_type << 4)|number_plan                 
                       );
  }

  if ( call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.called_party_subaddress.present 
       == TRUE 
      )
  {
    /* Subaddress */
    if( CM_MAX_SUBADDRESS_DIGITS <
         call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.called_party_subaddress.length  )
    {
      DS_AT_MSG1_HIGH("Dropping CDIP result, INVALID subaddress length :%d",
      	                call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.called_party_subaddress.length );
      dsat_cdip_pending[subs_id] = FALSE;
      return;
    }
    cm_util_subaddr_to_ascii_num( (byte *) call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.called_party_subaddress.data,
                                 call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.called_party_subaddress.length,
                                 subaddress_ascii,
                                 CM_MAX_SUBADDRESS_DIGITS
                             );
    subaddress_length = (byte) strlen((char *) subaddress_ascii );
    /* Using the same function for copying the subaddress line id */ 
    etsicall_called_lineid_buf_copy(subs_id, subaddress_ascii
                         ,MIN(CM_MAX_SUBADDRESS_DIGITS,subaddress_length) );
   
    /* Subaddress type */
    call_da_val->dsat_called_lineid_buf_length += 
        (uint32)snprintf((char *)&call_da_val->dsat_called_lineid_buf[call_da_val->dsat_called_lineid_buf_length],
                          DSAT_MAX_CALLED_LINEID_BUF,
                        ",%d,",
                        call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.called_party_subaddress.data[0]
                       );
  }
  else
  {
    call_da_val->dsat_called_lineid_buf_length += 
        (uint32)snprintf((char *)&call_da_val->dsat_called_lineid_buf[call_da_val->dsat_called_lineid_buf_length],
                          DSAT_MAX_CALLED_LINEID_BUF,",,");
  }

  /* The missing link is now ALPHA tag in the message.
     Make a call to Phonebook entity to retrieve the tag */
  if(dsatetsime_get_alphanumeric_name(called_party_ascii_num,MIN( CM_MAX_DIALED_DIGITS,num_length) ) == PBM_SUCCESS)
                             
  {
    call_da_val->dsat_called_lineid_buf_length += 
        (uint32)snprintf((char *)&call_da_val->dsat_called_lineid_buf[call_da_val->dsat_called_lineid_buf_length],
                          DSAT_MAX_CALLED_LINEID_BUF,
                         "\"%s\"",
                          me_ss_val->dsat_alpha_text
                       );
  }

  call_da_val->dsat_called_lineid_buf_length += 
     (uint32)snprintf((char *)&call_da_val->dsat_called_lineid_buf[call_da_val->dsat_called_lineid_buf_length],
                       DSAT_MAX_CALLED_LINEID_BUF,
                     ",%d",
                       call_event_ptr->event_info.dsat_mode_info.info.gw_cs_call.cause_of_no_cli.cause_value);

  res_buff_ptr = dsat_dsm_create_packet(call_da_val->dsat_called_lineid_buf,
                                        (uint16) call_da_val->dsat_called_lineid_buf_length,
                                        TRUE);
  if (NULL != res_buff_ptr)
  {
    (void)dsatcmdp_send_urc_per_subs(subs_id, res_buff_ptr, DSAT_COMPLETE_RSP);
  }

  dsat_cdip_pending[subs_id] = FALSE;
} /* dsatetsicall_report_cdip_result */

/*==========================================================================
FUNCTION  DSATETSICALL_REPORT_CDIP_RESULT_RING

DESCRIPTION
  This function report Caller ID to the TE if CDIP reporting is enabled.

DEPENDENCIES
  None

RETURN VALUE
  void.

SIDE EFFECTS
  None

===========================================================================*/
void dsatetsicall_report_cdip_result_ring
(
  sys_modem_as_id_e_type subs_id
)
{
  dsm_item_type           *res_buff_ptr;
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  res_buff_ptr = dsat_dsm_create_packet(call_da_val->dsat_called_lineid_buf,
                                        (uint16) call_da_val->dsat_called_lineid_buf_length,
                                        TRUE);
  if (NULL != res_buff_ptr)
  {
    (void)dsatcmdp_send_urc_per_subs(subs_id, res_buff_ptr, DSAT_COMPLETE_RSP);
  }
} /* dsatetsicall_report_cdip_result_ring */


/*===========================================================================

FUNCTION  DSATETSICALL_EXEC_SS_ABORT_HANDLER

DESCRIPTION
  This function is the abort handler function for the SS functionality. 
  
DEPENDENCIES
  None

RETURN VALUE
  TRUE - meaning to abort the delay execution.

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
boolean dsatetsicall_exec_ss_abort_handler
(
  const struct dsati_cmd_struct *ptr
)
{
  ds_cmd_type *cmd_ptr;
  dsatetsicmif_sups_state_ms_info  *sups_ms_val = NULL;
  ds_at_cmd_status_type            *status_cmd_ptr = NULL;
    
  sups_ms_val = dsat_get_base_addr_current_subs(DSAT_SUPS_MS_VALS);

  sups_ms_val->dsat_interr_ss_service = (ss_operation_code_T)DSAT_INVALID_OP_CODE;
  sups_ms_val->dsat_ss_abort_status = TRUE;

  cmd_ptr = dsat_get_cmd_buf(sizeof(ds_at_cmd_status_type), FALSE);
  status_cmd_ptr = cmd_ptr->cmd_payload_ptr;

  /* Send abort event to restore normal command processing */
  cmd_ptr->hdr.cmd_id = DS_CMD_ATCOP_STATUS_CMD;
  status_cmd_ptr->cmd_id     = (uint16)SS_CM_CMD_ABORT;
  status_cmd_ptr->cmd_status = MMGSDI_SUCCESS;
  status_cmd_ptr->cmd_data   = 0;
  ds_put_cmd (cmd_ptr);

  return TRUE;
} /* dsatetsicall_exec_ss_abort_handler */


/*===========================================================================

FUNCTION DSATETSICALL_SS_ABORT_EVENT_HANDLER

DESCRIPTION
  This function handles +CLIP abort event handling.We set the ss service to 
  invalid state and return. This routine just ensures the AT command processor
  returns to normal processing.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_ERROR : as the function is aborted

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_ss_abort_event_handler
(
  ds_at_cmd_status_type *cmd_info_ptr
)
{
  if( dsatcmdp_abortable_state != NOT_ABORTABLE)
  {
    return DSAT_ERROR;
  }
  else
  {
    return DSAT_ASYNC_EVENT ;
  }
} /* dsatetsicall_ss_abort_event_handler */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CLIR_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CLIR command, which enables/disables the restriction of the 
  display of calling line identification.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_clir_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsatetsicmif_sups_state_ms_info  *sups_ms_val = NULL;

  sups_ms_val = dsat_get_base_addr_current_subs(DSAT_SUPS_MS_VALS);

  /*--------------------------------------------------------------------------
   Invoke the general AT parameter handler for WRITE & TEST commands
  ---------------------------------------------------------------------------*/

  /* Read command and interrogate n/w to get the CLIR details */
  if((tok_ptr->op == (NA|EQ|QU)) || 
    (tok_ptr->op == (NA|QU)) || 
    (tok_ptr->op == (NA|EQ|AR)))
  {
    result = dsatparm_exec_param_cmd(mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr);

    if((result == DSAT_OK) && (tok_ptr->op == (NA|QU)))
    {
      cm_interr_ss_params_s_type   interr_clir_params;

      memset((void *)&interr_clir_params, 0, sizeof(cm_interr_ss_params_s_type));

      /* Service code for CLIR */
      interr_clir_params.ss_code = (uint8)clir;

      interr_clir_params.basic_service.code_type = NO_CODE;
      interr_clir_params.basic_service.present   = FALSE;

      if(dsatetsicmif_cm_sups_cmd_interrogate(NULL,
                               dsatcm_client_id, &interr_clir_params) == TRUE)
      { 
        /* Mark interrogating SS service as CLIR */
        sups_ms_val->dsat_interr_ss_service = clir;
        sups_ms_val->dsat_ss_abort_status = FALSE;

        result = DSAT_ASYNC_CMD;
      } 
      else
      { 
        dsatme_set_cme_error(DSAT_CME_PHONE_FAILURE, res_buff_ptr);
        result = DSAT_CMD_ERR_RSP;
      }
    }
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_clir_cmd */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CSSN_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CSSN command, supplementary service according to 
  3GPP TS 27.007 and 22.083

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if AT command syntax error
    DSAT_OK    : if successful

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cssn_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;

  /*---------------------------------------------------------
   Processing for WRITE, TEST and READ commands
  -----------------------------------------------------------*/
  if ((tok_ptr->op == (NA|EQ|AR)) ||
      (tok_ptr->op == (NA|EQ|QU)) ||
      (tok_ptr->op == (NA|QU)))
  {

    result = dsatparm_exec_param_cmd( mode,
                                      parse_table,
                                      tok_ptr,
                                      res_buff_ptr 
                                    );
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_cssn_cmd */


/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_CSSI_REPORT

DESCRIPTION
  This function passes the intermediate result codes to the TE

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if AT command syntax error
    DSAT_OK    : if successful

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
void dsatetsicall_call_event_cssi_report
(
  ds_at_cm_call_event_type *call_event, /* Call event pointer */
  sys_modem_as_id_e_type    subs_id,    /* Subsription ID */
  dsat_cssi_e_type          cssi_res
)
{
  if(!IS_ETSI_MODE(dsatcmdp_get_current_mode_per_subs(call_event->event_info.subs_id)))
  {
    DS_AT_MSG0_MED("Not reporting for CDMA events");
    return;
  }

  if((dsat_num_item_type)dsatutil_get_val(
                             DSATETSI_EXT_CSSN_IDX,0,0,NUM_TYPE) == CSSI_ENABLE)
  {
    dsm_item_type           *res_buff_ptr;

    res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
    if (NULL != res_buff_ptr)
    {
      if(cssi_res == DSAT_CSSI_ORIG_FWD_STAT)
      {
        if(call_event->event_info.ss_info.ss_code.present ==
           TRUE)
        {
          if(call_event->event_info.ss_info.ss_code.ss_code == 
             (byte)allCondForwardingSS)
          {

            res_buff_ptr->used +=
              (word)snprintf(
                         (char*)(res_buff_ptr->data_ptr+res_buff_ptr->used),
                         res_buff_ptr->size - res_buff_ptr->used,
                         "\n+CSSI: %d", DSAT_CSSI_COND_FWD_ACTIVE);
          }

          else if(call_event->event_info.ss_info.ss_code.ss_code == 
                  (byte)cfu)
          {
            res_buff_ptr->used +=
              (word)snprintf(
                         (char*)(res_buff_ptr->data_ptr+res_buff_ptr->used),
                          res_buff_ptr->size - res_buff_ptr->used,
                          "\n+CSSI: %d", DSAT_CSSI_UNCOND_FWD_ACTIVE);
          }
        }
      }

      else 
      {
        res_buff_ptr->used +=
          (word)snprintf(
                        (char*)(res_buff_ptr->data_ptr+res_buff_ptr->used),
                          res_buff_ptr->size - res_buff_ptr->used,
                        "\n+CSSI: %d", cssi_res);
      }

      dsatcmdp_send_urc_per_subs(subs_id, res_buff_ptr, DSAT_INTERMEDIATE_RSP);
    }
  }

} /* dsatetsicall_call_event_cssi_report */


/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_CSSU_REPORT

DESCRIPTION
  This function passes the unsolicited result codes to the TE

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if AT command syntax error
    DSAT_OK    : if successful

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
void dsatetsicall_call_event_cssu_report
(
  ds_at_cm_call_event_type *call_event, /* Call event pointer */
  sys_modem_as_id_e_type    subs_id,    /* Subsription ID */
  dsat_cssu_e_type          cssu_res
)
{
  if(!IS_ETSI_MODE(dsatcmdp_get_current_mode_per_subs(call_event->event_info.subs_id)))
  {
    DS_AT_MSG0_MED("Not reporting for CDMA events");
    return;
  }

  if(cssu_res == DSAT_CSSU_CALL_HOLD)
  {
    cssn_move_call_id( subs_id,
                       call_event->event_info.call_id,
                       DSAT_CSSU_CALL_HOLD
                     );
  }
  else if(cssu_res == DSAT_CSSU_CALL_RETRIEVED)
  {
    cssn_move_call_id( subs_id,
                       call_event->event_info.call_id,
                       DSAT_CSSU_CALL_RETRIEVED
                     );
  }

  if ((dsat_num_item_type)dsatutil_get_val(
                            DSATETSI_EXT_CSSN_IDX,0,1,NUM_TYPE) == CSSU_ENABLE)
  {

    dsm_item_type *res_buff_ptr;

    res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
    if (NULL != res_buff_ptr)
    {
      res_buff_ptr->used +=
                (word)snprintf(
                                   (char*)(res_buff_ptr->data_ptr+res_buff_ptr->used),
                                    res_buff_ptr->size - res_buff_ptr->used,
                                    "\n+CSSU: %d", cssu_res);

      dsatcmdp_send_urc_per_subs(subs_id,res_buff_ptr, DSAT_COMPLETE_RSP);
    }
  }

} /* dsatetsicall_call_event_cssu_report */


/*===========================================================================

FUNCTION CSSN_MOVE_CALL_ID

DESCRIPTION
  This function moves the given call id from active call list to 
  held call list and from held call list to active call list depending on 
  the cssu_res.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
LOCAL void cssn_move_call_id
(
  sys_modem_as_id_e_type   subs_id,
  cm_call_id_type          call_id,
  dsat_cssu_e_type         cssu_res
)
{
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  DS_AT_MSG1_MED("evt_mng: call id %d",
           call_id);

   /* Search for and if found remove call id from active_call_ids */
  if ( etsicall_search_call_list(&call_da_val->etsicall_num_active_calls,
                                  call_da_val->etsicall_active_call_ids,
                                 call_id,
                                 TRUE) )
  {
    DS_AT_MSG0_HIGH("Call id was already in active call list");
  }

  /* Search for and if found remove call id from held_call_ids */
  if ( etsicall_search_call_list(&call_da_val->etsicall_num_held_calls,
                                  call_da_val->etsicall_held_call_ids,
                                 call_id,
                                 TRUE) )
  {
    DS_AT_MSG0_HIGH("CONNECT event's call id was already in held call list");
  }

  if(cssu_res == DSAT_CSSU_CALL_HOLD)
  {
    if ( call_da_val->etsicall_num_held_calls + 1 > CM_CALL_ID_MAX )
    {
      DS_AT_MSG0_HIGH("num_active_calls would exceed bound");
    }
    else
    {
      /* Add call id to held call list */
      call_da_val->etsicall_held_call_ids[call_da_val->etsicall_num_held_calls++] = call_id;
      call_da_val->was_active_call_hold = TRUE;
    }
  }
  else if(cssu_res == DSAT_CSSU_CALL_RETRIEVED)
  {

    if ( call_da_val->etsicall_num_active_calls + 1 > CM_CALL_ID_MAX )
    {
      DS_AT_MSG0_HIGH("num_active_calls would exceed bound");
    }
    else
    {
      /* Add call id to active call list */
      call_da_val->etsicall_active_call_ids[call_da_val->etsicall_num_active_calls++] = call_id;
      call_da_val->was_hold_call_retrieved = TRUE;
    }
  }
} /* cssn_move_call_id */


/*===========================================================================

FUNCTION DSATETSICALL_SEQNUM_TO_CALLID

DESCRIPTION
  Given a call sequence number as described in 3GPP TS 22.030 section 6.5.5.1
  returns the associated call ID.

DEPENDENCIES
  None
  
RETURN VALUE
  Call ID on success or
  CALL_CALL_ID_INVALID on out-of-range sequence number or failure to find.

SIDE EFFECTS
  None
  
===========================================================================*/
cm_call_id_type dsatetsicall_seqnum_to_callid
(
  sys_modem_as_id_e_type  subs_id,
  dsat_num_item_type      sequence_number
)
{
  dsatetsicall_call_state_da_info  *call_da_val = NULL;
  
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  if ( sequence_number > 0 &&
       sequence_number <= CM_CALL_ID_MAX )
  {
    return(call_da_val->dsat_seqnum_callid[sequence_number - 1].call_id);
  }

  return(CM_CALL_ID_INVALID);  
}
  
/*===========================================================================

FUNCTION  ETSICALL_LOOKUP_CAUSE_CODE

DESCRIPTION
  This function performs table lookup for +CEER command.

DEPENDENCIES
  None
  
RETURN VALUE
  TRUE if table lookup found value; FALSE otherwise.

SIDE EFFECTS
  None
===========================================================================*/
/* ARGSUSED */
LOCAL boolean etsicall_lookup_cause_code
(
  const ceer_lookup_s_type  *table_ptr,
  const int16                code,
  const ceer_lookup_s_type  **row_pptr
)
{
  boolean result = FALSE;
  *row_pptr = NULL;
  
  while( DSAT_CEER_LIST_TERMINATOR != table_ptr->code )
  {
    if( table_ptr->code == code )
    {
      *row_pptr = table_ptr; 
      result = TRUE;
      break;
    }
    table_ptr++;
  }
  
  return result;
} /* etsicall_lookup_cause_code */


/*===========================================================================

FUNCTION  DSATETSICALL_REPORT_CLIR_STATUS

DESCRIPTION
  This function reports the CLIR supplementary service interrogation status
  received from Call Manager.

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR :    if there was any problem in execution.
    DSAT_OK :       if it is a success.

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_report_clir_status
(
  ds_at_cm_sups_event_type *sups_event_ptr, /* SUPS event pointer */
  sys_modem_as_id_e_type    subs_id
)
{
  dsm_item_type           *res_buff_ptr = NULL;
  uint32                   clir_interrogate_status;
  dsatetsicmif_sups_state_ms_info  *sups_ms_val = NULL;
  

  /* Initialize CLIR interrogate status to not provisioned
     And later overwrite with the appropriate status 
     received */

  clir_interrogate_status = (uint32)DSAT_CLIR_SRV_NOT_PROVISIONED;

  sups_ms_val = dsat_get_base_addr_per_subs(DSAT_SUPS_MS_VALS, subs_id, FALSE);

  if (sups_event_ptr->event_info.cli_restriction.present == TRUE)
  {
    if (sups_event_ptr->event_info.cli_restriction.cm_cli_restriction_option.present == TRUE)
    {
      switch (sups_event_ptr->event_info.cli_restriction.cm_cli_restriction_option.option)
      {
      case CLI_DEFAULT_OPTION:
        /* This maps to Permanent CLIR provisioning */
        clir_interrogate_status = (uint32)DSAT_CLIR_SRV_PROVISIONED_PERMANENT;
        break;
      
      case CLI_RESTRICT_OPTION:
        /* This maps to default CLIR ON and can be overidden */
        clir_interrogate_status = (uint32)DSAT_CLIR_SRV_PRESENTATION_RESTRICTED;
        break;

      case CLI_OVERRIDE_OPTION:
        /* This maps to CLIR default - requires explicit CLIR status to be used
           during call setup */
        clir_interrogate_status = (uint32)DSAT_CLIR_SRV_PRESENTATION_ALLOWED;
        break;

      default:
        /* Ideally filtered by CM and should not be received */
        /* Map it to non provisioned status */
        break;
      } 
    }
  }

#if 0 

  /* We are removing this behaviour as per CR 177923.*/
  /* Update local CLIR setting in accordance with N/W settings 
     Any conflicting user CLIR setting with interrogated result is made as 
     default. This conforms to S65 phone's behavior */
  if(((dsat_clir_val == (dsat_num_item_type)DSAT_CLIR_SUPPRESSION_OPTION) && 
     ((clir_interrogate_status == (uint32)DSAT_CLIR_SRV_PRESENTATION_ALLOWED) ||  
      (clir_interrogate_status == (uint32)DSAT_CLIR_SRV_PROVISIONED_PERMANENT))) ||
     ((dsat_clir_val == (dsat_num_item_type)DSAT_CLIR_INVOCATION_OPTION) && 
      (clir_interrogate_status == (uint32)DSAT_CLIR_SRV_PRESENTATION_RESTRICTED)) ||
      (clir_interrogate_status == (uint32)DSAT_CLIR_SRV_NOT_PROVISIONED))
  {
    dsat_clir_val = (dsat_num_item_type)DSAT_CLIR_PRESENTATION_INDICATOR;
  }
#endif 
  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
  if (NULL != res_buff_ptr)
  {
    res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                              res_buff_ptr->size,
                                              "+CLIR: %u,%lu",
                                              (dsat_num_item_type)dsatutil_get_val(
                                              DSATETSI_EXT_ACT_CLIR_ETSI_IDX,0,0,NUM_TYPE),
                                              clir_interrogate_status);

    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_COMPLETE_RSP);
  }
  sups_ms_val->dsat_interr_ss_service = (ss_operation_code_T)DSAT_INVALID_OP_CODE;

  return DSAT_OK;
} /* dsatetsicall_report_clir_status */

/*===========================================================================

FUNCTION  DSATETSICALL_EXEC_VTS_CMD

DESCRIPTION
  This function generates a dtmf during an ongoing call.

DEPENDENCIES
  An active call

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR :    if there was any problem in execution.
    DSAT_ASYNC_CMD : Intermediate Response
    DSAT_OK :       if it is a success.
SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_exec_vts_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{

  dsat_result_enum_type result = DSAT_OK;

  /*--------------------------------------------------------------------------
   Invoke the general AT parameter handler for TEST command
  ---------------------------------------------------------------------------*/
  if( tok_ptr->op == (NA|EQ|QU) )
  {
    res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                                res_buff_ptr->size,
                                                "+VTS: (0-9,A-D,*,#)");
  }
  /*--------------------------------------------------------------------------
     Execute command
  ---------------------------------------------------------------------------*/
  else if ( tok_ptr->op == (NA|EQ|AR) )
  {
    /* Return ERROR if there are more than one args or 
     * if token is not valid.
     */
    if( ( tok_ptr->args_found != 1 ) || ( !VALID_TOKEN(0) ) )
    {
      return DSAT_ERROR;
    }
    result = dsatetsicall_start_dtmf( tok_ptr ); 
  }
  else 
  {
    result = DSAT_ERROR;
  }

  return result;
}/* dsatetsicall_exec_vts_cmd */

/*===========================================================================

FUNCTION  DSATETSICALL_START_DTMF

DESCRIPTION
  This function process the 'write' command of +vts.It process the Input DTMF
  code and Calls the CM API to generate a inband DTMF tone in a active call

DEPENDENCIES
  Command Valid if there is an active call

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR :    if there was any problem in execution.
    DSAT_ASYNC_CMD : Intermediate Response

SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_start_dtmf 
(
  const tokens_struct_type * tok_ptr 
)
{
  byte dtmf_code;
  dsat_result_enum_type result  = DSAT_ASYNC_CMD;
  sys_modem_as_id_e_type subs_id = dsat_get_current_subs_id(FALSE);
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS, subs_id, FALSE);

  ASSERT(NULL != tok_ptr);
  dtmf_code = tok_ptr->arg[0][0];
  
  /* Check for an active call and change the case of DTMF code */
  /* Currently we support Inband DTMF on the primary active call */
  if ( call_da_val->etsicall_num_active_calls != 0 )
  {
    dtmf_code = UPCASE( dtmf_code );
    /* Verify DTMF code.  */
    if (  (strlen( (char *)tok_ptr->arg[0] ) == 1 ) &&
          ( IS_DIGIT( dtmf_code ) || 
            (dtmf_code == '#') || 
            (dtmf_code == '*') || 
            ( (dtmf_code >= 'A') && (dtmf_code <= 'D') ) ) )
    {
      DS_AT_MSG0_HIGH("In dsatetsicall_start_dtmf");
      SET_PENDING(DSATETSI_EXT_ACT_VTS_ETSI_IDX ,0, DSAT_PENDING_TRUE)
      /* Return value is ignored as error case is handled by callback func */
      (void) cm_mm_inband_cmd_start_cont_dtmf( dsatcmif_cm_inband_cmd_cb_func, 
                                               NULL,
                                               dsatcm_client_id,
                                               call_da_val->etsicall_active_call_ids[0],
                                               dtmf_code );
    }
    else
    {
      DS_AT_MSG0_HIGH("Unrecognized DTMF tone in dsatetsicall_start_dtmf()");
      result = DSAT_ERROR;
    }
  }
  else 
  {
    DS_AT_MSG0_HIGH("No Active Calls");
    result = DSAT_ERROR;
  }
  return result;

}/* dsatetsicall_start_dtmf */

/*===========================================================================

FUNCTION  dsatetsicall_inband_dtmf_timer_expired_handler

DESCRIPTION
  Handler Function for DTMF Timer.

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR :    if there was any problem in execution.
    DSAT_OK :       if it is a success.
    DSAT_ASYNC_EVENT Intermediate Response

SIDE EFFECTS
  None

SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_inband_dtmf_timer_expired_handler 
(
  ds_cmd_type         * cmd_ptr       /* DS Command pointer		 */
)
{
  sys_modem_as_id_e_type subs_id = dsat_get_current_subs_id(FALSE);
  dsatetsicall_call_state_da_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS,subs_id, TRUE);
  if (NULL == call_da_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  DS_AT_MSG0_HIGH("In dsatetsicall_inband_dtmf_timer_expired_handler");

  if ( CHECK_PENDING(DSATETSI_EXT_ACT_VTS_ETSI_IDX,0,DSAT_PENDING_TRUE) )
  {
    (void)cm_mm_inband_cmd_stop_cont_dtmf( dsatcmif_cm_inband_cmd_cb_func,
                                            NULL,
                                            dsatcm_client_id,
                                            call_da_val->etsicall_active_call_ids[0],
                                            0 );
  }
  else 
  {
    DS_AT_MSG0_ERROR(" Wrong function invocation ");
  }
  return DSAT_ASYNC_EVENT;
}/*dsatetsicall_inband_dtmf_timer_expired_handler*/

#ifdef  FEATURE_ECALL_APP
/*===========================================================================

FUNCTION DSATETSICALL_CECALL_CB_FUNC

DESCRIPTION
  CECALL query command callback function

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

  
===========================================================================*/
LOCAL void dsatetsicall_cecall_cb_func
(
  ecall_type_of_call     type_of_call,
  ecall_activation_type  activation_type
)
{
  ds_cmd_type            *cmd_buf  = NULL;
  ds_at_ecall_cmd_s_type *ecall_cmd_ptr = NULL;

  DS_AT_MSG2_HIGH("In CEcall callback Type of call %d Activation type ",
                        type_of_call,activation_type);
  cmd_buf  = dsat_get_cmd_buf(sizeof(ds_at_ecall_cmd_s_type), FALSE);
  ecall_cmd_ptr = cmd_buf->cmd_payload_ptr;

  /* send the message to ATCOP */
  cmd_buf->hdr.cmd_id = DS_CMD_ATCOP_ECALL_CMD;
  ecall_cmd_ptr->type_of_call    = type_of_call;
  ecall_cmd_ptr->activation_type = activation_type;
  ds_put_cmd(cmd_buf);

}/*dsatetsicall_cecall_cb_func*/
/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CECALL_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CECALL command, to trigger an eCall to the network. Based 
  on the configuration selected, it can be used to either trigger a test call,
  a reconfiguration call, a manually initiated eCall or an automatically initiated eCall"

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_exec_cecall_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{

  dsat_result_enum_type         result       = DSAT_ASYNC_CMD;
  dsat_num_item_type            cecall_type  = DSAT_CECALL_MAX;
  dsati_operating_cmd_mode_type oprt_mode    = dsatcmdp_get_operating_cmd_mode();

  if(oprt_mode != ETSI_CMD_MODE)
  {
    DS_AT_MSG0_ERROR("Invalid Operating Mode");
    result = DSAT_ERROR;
    return result;
  }

  if(tok_ptr->op == (NA|QU))
  {
    SET_PENDING(DSATETSI_EXT_CECALL_IDX ,0, DSAT_PENDING_CECALL_READ)
    /* calling CM API for getting status of call */
    if( FALSE == ecall_session_get_call_info(
                    (dsatetsicall_cecall_cb_func)))
    {
      DS_AT_MSG0_ERROR("Unable to read status of the call");
      result = DSAT_ERROR;
    }
    
  }
  else if(tok_ptr->op == (NA|EQ|QU))
  {
    res_buff_ptr->used = (word) snprintf((char *)res_buff_ptr->data_ptr,
                                          res_buff_ptr->size,
                                          "+CECALL: (0-3)");
    result =  DSAT_OK;
  }
  else if(tok_ptr->op == (NA|EQ|AR))
  {
    /* First argument is mandatory for an Action command.
     If omitted/incorrect throw an Error */
    if( (!VALID_TOKEN(0))|| 
        (tok_ptr->args_found != 1) ||
        (ATOI_OK !=dsatutil_atoi(&cecall_type,tok_ptr->arg[0],10))||
        (cecall_type >= DSAT_CECALL_MAX ))
    {
      DS_AT_MSG1_ERROR("CEcall :: Incorrect parameter  %d",cecall_type);
      result = DSAT_ERROR;
    }
    else
    { 
      SET_PENDING(DSATETSI_EXT_CECALL_IDX ,0, DSAT_PENDING_CECALL_WRITE)
      switch(cecall_type)
      {
        case DSAT_CECALL_TEST:
             if( FALSE == ecall_session_start(
                             (ecall_type_of_call)ECALL_TEST,
                             (ecall_activation_type)ECALL_MANUAL_INITIATED,
                             (dsat_ecall_cb_func)))
             {
               DS_AT_MSG0_ERROR("Unable to start TEST call");
               result = DSAT_ERROR;
             }
             break;
        
        case DSAT_CECALL_RECONF:
            if( FALSE == ecall_session_start(
                            (ecall_type_of_call)ECALL_RECONFIG,
                            (ecall_activation_type)ECALL_MANUAL_INITIATED,
                            (dsat_ecall_cb_func)))
            {
              DS_AT_MSG0_ERROR("Unable to start RECONFIG CEcall");
              result = DSAT_ERROR;
            }
            break;
        
        case DSAT_CECALL_MANUAL:
            if( FALSE == ecall_session_start(
                            (ecall_type_of_call)ECALL_EMERGENCY,
                            (ecall_activation_type)ECALL_MANUAL_INITIATED,
                            (dsat_ecall_cb_func)))
            {
              DS_AT_MSG0_ERROR("Unable to start Manual CEcall");
              result = DSAT_ERROR;
            }
            break;
        
        case DSAT_CECALL_AUTO:
            if( FALSE == ecall_session_start(
                            (ecall_type_of_call)ECALL_EMERGENCY,
                            (ecall_activation_type)ECALL_AUTOMATIC_INITIATED,
                            (dsat_ecall_cb_func)))
            {
              DS_AT_MSG0_ERROR("Unable to start Auto CEcall");
              result = DSAT_ERROR;
            }
            break;
        
        default:
          DS_AT_MSG0_ERROR("Invalid CEcall option");
          result = DSAT_ERROR;
          break;
      }
    }
  }
  else
  {
    DS_AT_MSG0_ERROR("Invalid option");
    result = DSAT_ERROR;
  }
  
  if(result == DSAT_ERROR)
  {
    SET_PENDING(DSATETSI_EXT_CECALL_IDX ,0, DSAT_PENDING_CECALL_NONE)
  }
  
  return result;
}/* dsatetsicall_exec_cecall_cmd */
#endif /*FEATURE_ECALL_APP*/

#ifdef FEATURE_DSAT_LTE
/*===========================================================================
FUNCTION: DSATETSICALL_EXEC_CVMOD_CMD

DESCRIPTION
  This function takes the result from the command line parser
  and executes it. It executes at+cvmod command.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_OK : if the command has been successfully executed
    DSAT_ERROR : if there was any problem in executing the command

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_exec_cvmod_cmd
(
  dsat_mode_enum_type mode,               /*  AT command mode:            */
  const dsati_cmd_type *parse_table,      /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,      /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr             /*  Place to put response       */
)
{
  #define DSAT_VOICE_MODE_MAX  4
  
  dsat_result_enum_type         result        = DSAT_OK;
  dsat_num_item_type                voice_domain_pref = DSAT_VOICE_MODE_MAX;    /* Voice domain preference */  
  cm_cmd_user_pref_update_type      user_pref;
  sys_modem_as_id_e_type        subs_id = dsat_get_current_subs_id(FALSE);
  
  if (tok_ptr->op == (NA|EQ|AR))
  {
    if( tok_ptr->args_found == 1 && (VALID_TOKEN(0))&& 
       (ATOI_OK == dsatutil_atoi(&voice_domain_pref,tok_ptr->arg[0],10))&&
       ( voice_domain_pref < DSAT_VOICE_MODE_MAX)
      )
    {
      memset(&user_pref,0x0,sizeof(user_pref));
      if ( !cm_user_pref_init( &user_pref ) )
      {
       return DSAT_ERROR;
      }
      user_pref.asubs_id =  subs_id;
      user_pref.client_id = dsatcm_client_id;
      user_pref.pref_term = CM_PREF_TERM_PERMANENT;
       /*Change voice domain pref*/
      user_pref.voice_domain_pref = voice_domain_pref;
      SET_PENDING(DSATETSI_EXT_ACT_CVMOD_ETSI_IDX ,0, DSAT_PENDING_TRUE)
      if(FALSE == cm_user_pref_update_req(&user_pref,dsatcmif_ph_cmd_cb_func,NULL))
      {
        SET_PENDING(DSATETSI_EXT_ACT_CVMOD_ETSI_IDX ,0, DSAT_PENDING_FALSE)
        result = DSAT_ERROR;
      }
      else
      {
        result = DSAT_ASYNC_CMD;
      }
      
    }
    else
    {
      DS_AT_MSG1_ERROR("+CVMOD: Invalid arguement value  %d", voice_domain_pref);
      return DSAT_ERROR;
    }
  }else if(tok_ptr->op == (NA|QU))
  {
#ifdef FEATURE_DUAL_SIM
    voice_domain_pref = cm_ph_get_voice_domain_pref_per_sub(subs_id);
#else
    voice_domain_pref = cm_ph_get_voice_domain_pref();
#endif
      res_buff_ptr->used = (word) snprintf((char *)res_buff_ptr->data_ptr,
                                              res_buff_ptr->size,
                                              "+CVMOD: %d",(int)voice_domain_pref);
  }else if(tok_ptr->op == (NA|EQ|QU))
  {
     res_buff_ptr->used = (word) snprintf((char *)res_buff_ptr->data_ptr,
                                              res_buff_ptr->size,
                                              "+CVMOD: (0-3)");
  }else if(tok_ptr->op == (NA))
  {
     /* Do nothing: No default value mentioned in SPEC*/
      result = DSAT_OK;
  }
  else
  {
      /* wrong operation */
    result = DSAT_ERROR;
  }
  return result;
}/*dsatetsicall_exec_cvmod_cmd*/
#endif /* FEATURE_DSAT_LTE*/
/*===========================================================================
FUNCTION: DSATETSICALL_EXEC_CEN_CMD

DESCRIPTION
  This function takes the result from the command line parser
  and executes it. It executes at+cstf command.
  at+cen is used to enable/disable new emergency numbers received from the 
  network with unsolicited result codes .

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_OK : if the command has been successfully executed
    DSAT_ERROR : if there was any problem in executing the command

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_exec_cen_cmd
(
  dsat_mode_enum_type mode,               /*  AT command mode:            */
  const dsati_cmd_type *parse_table,      /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,      /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr             /*  Place to put response       */
)
{
  dsat_result_enum_type   result = DSAT_OK;
  sys_modem_as_id_e_type  subs_id;

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
   Processing for TEST command 
  -----------------------------------------------------------*/
  if ((tok_ptr->op == (NA|EQ|AR)) ||
      (tok_ptr->op == (NA|EQ|QU)) ||
      (tok_ptr->op == (NA)))
  {
    result = dsatparm_exec_param_cmd(
                                     mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr
                                    );
    
  }
  else if(tok_ptr->op == (NA|QU))
  { 
    subs_id = dsat_get_current_subs_id(FALSE);
    dsatcmif_report_cen_list(res_buff_ptr,subs_id);
    result = DSAT_OK;
  }else
  {
    result = DSAT_ERROR;
  }
  return result;
}/*dsatetsicall_exec_cen_cmd*/

/*===========================================================================
FUNCTION: DSATETSICALL_PROCESS_PLMN_INFO

DESCRIPTION
  This function processes PLMN data for at+cops command 
  and registers/deregister with the available network
  based on the Access Technology

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_OK : if the command has been successfully executed
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_ASYNC_CMD : if user want to deregister

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_process_plmn_info(void)
{
   dsat_result_enum_type result = DSAT_ERROR;
   dsat_cops_act_e_type current_act_pref = DSAT_COPS_ACT_MAX;
   dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;
   sys_modem_as_id_e_type subs_id = dsat_get_current_subs_id(FALSE);
   dsatetsicall_call_state_da_info  *call_da_val = NULL;
   dsat_cops_act_e_type current_act;
   dsat_num_item_type prev_mode;

#ifdef FEATURE_DUAL_SIM
   cm_subscription_status_e_type status_one = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
   cm_subscription_status_e_type status_two = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
   cm_subscription_status_e_type status_three = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
#endif /* FEATURE_DUAL_SIM */

  ph_ss_ms_val = dsat_get_base_addr_per_subs(DSAT_SS_PH_MS_VALS,subs_id, FALSE);
  call_da_val = dsat_get_base_addr_per_subs(DSAT_CALL_DA_VALS,subs_id, FALSE);

   current_act = ph_ss_ms_val->dsat_net_reg_state.act;
   /* Cross-reference CM RAT preference to AcT parameter */
   if ( TRUE !=
    dsatetsicmif_lookup_cm_rat_pref( FALSE, &current_act_pref,
    &(ph_ss_ms_val->dsat_net_reg_state.cmph_pref.network_rat_mode_pref))
    )
   {
     current_act_pref = DSAT_COPS_ACT_MAX; /* never match */
   }
 
   /* Check for (PLMN+AcT) same as current OR we are in automatic
       * mode.  No CM SS events are received if PLMN is not different so
       * return to command mode after PH prefernece change event
       * received.  For fully automatic mode, its somewhat non-
       * deterministic whether serving system change event will be
       * received. */
 
   /* If voice call is active, mode pref change needs to be droped 
       since lower layers dont support it */

    if((ph_ss_ms_val->net_pref.act != current_act_pref)&&(call_da_val->etsicall_num_active_calls != 0))
   {
      DS_AT_MSG0_ERROR("Droping request since voice call is active");
      return DSAT_ERROR;
   }

   if (DSAT_COPS_MODE_DEREG == ph_ss_ms_val->net_pref.mode)
   {
     ph_ss_ms_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_DEREG;
   }
   /* Test for (PLMN + AcT) same as current */
   else if( (( TRUE ==
         sys_plmn_match (ph_ss_ms_val->net_pref.plmn,
         (ph_ss_ms_val->dsat_net_reg_state.net_id_info.plmn)) ) &&
         ((ph_ss_ms_val->net_pref.act == current_act_pref)||
         (ph_ss_ms_val->net_pref.act == DSAT_COPS_ACT_AUTO))) ||

          /* Test for certain AcT change case (ie on GSM, requesting UTRAN
           * or opposite case) */
          /* $QCCOPS/$QCCSGCOPS : if network is provided in automatic mode
             the command state should be DSAT_COPS_ASTATE_PREF */

          (( DSAT_COPS_MODE_AUTO == ph_ss_ms_val->net_pref.mode ) &&
          ((current_act == ph_ss_ms_val->net_pref.act) &&
                        (((ph_ss_ms_val->dsatetsicall_network_list.cmd_idx != CMD_IDX_QCCOPS ||
                          ph_ss_ms_val->dsatetsicall_network_list.cmd_idx  != CMD_IDX_QCCSGCOPS)) &&
          (ph_ss_ms_val->net_pref.is_arg2_valid)) )) ||
           /* If This is mode changes only*/
          (( DSAT_COPS_MODE_AUTO == ph_ss_ms_val->net_pref.mode )&&
          ((ph_ss_ms_val->net_pref.no_of_args == 1 && ph_ss_ms_val->net_pref.is_arg0_valid))))
   {
      DS_AT_MSG0_HIGH("COPS setting preference only; early return code");
      ph_ss_ms_val->dsatetsicall_network_list.cmd_state =
                                          DSAT_COPS_ASTATE_PREF_ONLY;
   }
   else
   {
      ph_ss_ms_val->dsatetsicall_network_list.cmd_state =
                                                DSAT_COPS_ASTATE_PREF;
   }
   prev_mode = (dsat_num_item_type)dsatutil_get_val(
        DSATETSI_EXT_ACT_COPS_ETSI_IDX,subs_id,0,MIX_NUM_TYPE); /* list index */ 
   
   /* Preserve the current PLMN and network selection preference
       * incase of user abort */
   ph_ss_ms_val->dsatetsicall_network_list.previous_pref.plmn =
     ph_ss_ms_val->dsat_net_reg_state.net_id_info.plmn;
   ph_ss_ms_val->dsatetsicall_network_list.previous_pref.mode = 
     (dsat_cops_mode_e_type)prev_mode;
   
   if(TRUE != dsatetsicmif_lookup_cm_rat_pref
    ( FALSE,
    &(ph_ss_ms_val->dsatetsicall_network_list.previous_pref.act),
    &(ph_ss_ms_val->dsat_net_reg_state.cmph_pref.network_rat_mode_pref))
    )
   {
    /* Assume auto rat selection */
    ph_ss_ms_val->dsatetsicall_network_list.previous_pref.act =
                                                          DSAT_COPS_ACT_AUTO;
   }

   /* If the dereg_success should be true and the requested mode should not
       be either DEREG or SETFMT */
    if ( ph_ss_ms_val->net_pref.last_dereg_success == TRUE )
    {
       if ( ph_ss_ms_val->net_pref.mode == DSAT_COPS_MODE_DEREG )
       {
          DS_AT_MSG0_HIGH("COPS is already in DEREG state, early return");
          return DSAT_OK;
       }
       else if(ph_ss_ms_val->net_pref.mode !=
                                               DSAT_COPS_MODE_SETFMT)
       {
#ifdef FEATURE_DUAL_SIM
         dsatetsicall_update_subs_status(&status_one, &status_two, &status_three, subs_id);
            if ( cm_ph_cmd_subscription_available3 ( dsatcmif_ph_cmd_cb_func,
                                   NULL,
                                   dsatcm_client_id,
                                   CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                   status_one,
                                   status_two,
                                   status_three) == TRUE )
          {
             ph_ss_ms_val->net_pref.subscription_invoked = TRUE; 
          }
#else
               /* Active flag will not be set to FALSE when ATCoP goes SUBSCRIPTION
                         UNAVAILABLE */
          if (dsat_qcsimapp_info[dsat_get_current_gw_apps_id(FALSE)].active == FALSE)
          {
              prev_mode = (dsat_num_item_type)dsatutil_get_val(
                          DSATETSI_EXT_ACT_COPS_ETSI_IDX,
                          subs_id,
                          0,
                          MIX_NUM_TYPE); /* list index */ 
             DS_AT_MSG0_ERROR("SIM is in illegal subscription state");
                  /* Restore previous COPS value in case of ERROR */
             DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_COPS_ETSI_IDX,
                                   subs_id,
                                   0,
                                   0,
                                   (dsat_num_item_type)prev_mode,
                                   MIX_NUM_TYPE)
             result = dsat_send_cme_error(DSAT_CME_SIM_FAILURE);
             return result;           
          }

          if ( cm_ph_cmd_subscription_available ( dsatcmif_ph_cmd_cb_func,
                                    NULL,
                                    dsatcm_client_id,
                                    CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                    CM_SUBSCRIPTION_STATUS_CHANGE,
                                    CM_SUBSCRIPTION_STATUS_NO_CHANGE) == TRUE )
          {
             /*This boolean is used to handle the geniune event
                          of CM_PH_EVENT_SUBSCRIPTION_AVAILABLE */
             ph_ss_ms_val->net_pref.subscription_invoked = TRUE; 
          }
#endif /* FEATURE_DUAL_SIM */
               return DSAT_ASYNC_CMD;
       }
    }/* Last de-registartion was success */
    DS_AT_MSG2_HIGH("Mode %d ACT %d",ph_ss_ms_val->net_pref.act,
                        ph_ss_ms_val->net_pref.mode);
           /* Process paramaters based on mode */
    switch (ph_ss_ms_val->net_pref.mode)
    {
       case  DSAT_COPS_MODE_AUTO:
       case  DSAT_COPS_MODE_DEREG:
         if( ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCOPS ||
             ph_ss_ms_val->dsatetsicall_network_list.cmd_idx == CMD_IDX_QCCSGCOPS)
         {
          result = dsatetsicmif_change_network_registration (
                                  ph_ss_ms_val->net_pref.mode,
                                  &(ph_ss_ms_val->net_pref.plmn),
                                  ph_ss_ms_val->net_pref.act,
                                  subs_id
                                  );
         }
         else
         {
          result = dsatetsicmif_change_network_registration (
                                  ph_ss_ms_val->net_pref.mode,
                                  NULL,
                                  ph_ss_ms_val->net_pref.act,
                                  subs_id
                                  );
         }

          break;

       case  DSAT_COPS_MODE_MANUAL:
       case  DSAT_COPS_MODE_MANAUTO:
          result = dsatetsicmif_change_network_registration (
                                  ph_ss_ms_val->net_pref.mode,
                                  &(ph_ss_ms_val->net_pref.plmn),
                                  ph_ss_ms_val->net_pref.act,
                                  subs_id
                                  );
          if(DSAT_OK == result)
          {
             /* This happens when CM is already registered with a PLMN 
                        and COPS mode is set to either MANUAL or MANAUTO. If MANAUTO
                        is set then CM will move to MANUAL if it was in automatic previously.*/
              DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_COPS_ETSI_IDX,
                      subs_id,
                      0,
                      0,
                      (dsat_num_item_type)DSAT_COPS_MODE_MANUAL,MIX_NUM_TYPE)
          }
          break;

       case  DSAT_COPS_MODE_SETFMT:
          /* Do nothing */
          break;

       default:
          DS_AT_MSG1_ERROR("Error: Unsupported mode: %d", 
                     ph_ss_ms_val->net_pref.mode);
          result = DSAT_ERROR;
          break;
    }
   
    if (DSAT_ERROR == result)
    {
       result = dsat_send_cme_error(DSAT_CME_PHONE_FAILURE);
    }
  return result;
}/* dsatetsicall_process_plmn_info */

#ifdef FEATURE_MMGSDI

/*===========================================================================
FUNCTION: DSATETSICALL_COPS_MMGSDI_CMD_HANDLER

DESCRIPTION
  This function handles at+cops command.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_OK : if the command has been successfully executed
    DSAT_ERROR : if there was any problem in executing the command

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_cops_mmgsdi_handler
(
  ds_cmd_type *cmd_ptr
)
{
#define CONVERT_TO_PLMN2( mcc, mnc, plmn, pcs_flag ) \
    if ( FALSE == \
         sys_plmn_set_mcc_mnc( (mnc > 99 || pcs_flag)? TRUE : FALSE, \
                               mcc, mnc, &plmn ) ) \
     { \
       DS_AT_MSG2_ERROR("Error parsing MCC/MNC into PLMN: [%d,%d]", \
                  mcc,mnc); \
       dsat_send_cme_error(DSAT_CME_PHONE_FAILURE); \
       return DSAT_CMD_ERR_RSP; \
     }
   
  dsatcmif_servs_state_ms_info  *ph_ss_ms_val = NULL;
  ds_at_mmgsdi_plmn_info_type *plmn_info_ptr = dsat_get_cmd_payload_ptr(cmd_ptr);

   ph_ss_ms_val = dsat_get_base_addr_current_subs(DSAT_SS_PH_MS_VALS);

  if( (MMGSDI_SUCCESS != plmn_info_ptr->mmgsdi_status) ||
       (0 == plmn_info_ptr->num_of_plmn_ids) )
  {
    dsat_send_cme_error(DSAT_CME_NOT_FOUND);
    return DSAT_CMD_ERR_RSP;
  }
  /* Convert MCC/MNC to PLMN, set 3rd MNC digit if MNC string was of 3 characters */
  CONVERT_TO_PLMN2( plmn_info_ptr->plmn_info.mcc, 
        plmn_info_ptr->plmn_info.mnc,
        ph_ss_ms_val->net_pref.plmn,
        (MMGSDI_PLMN_NETWK_TYPE_PCS_1900_MASK &
               plmn_info_ptr->plmn_info.network_mask));

  /* Process PLMN data */
  return dsatetsicall_process_plmn_info();
}/* dsatetsicall_cops_mmgsdi_handler */


/*===========================================================================
FUNCTION: DSATETSICALL_COPS_CMD_CB_FUNC

DESCRIPTION
  This function handles at+cops command.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatetsicall_cops_cmd_cb_func
(
  mmgsdi_return_enum_type status,
  mmgsdi_cnf_enum_type    cnf,
  const mmgsdi_cnf_type  *cnf_ptr
)
{
  ds_cmd_type                 *cmd_buf  = NULL;
  ds_at_mmgsdi_plmn_info_type *plmn_info_ptr = NULL;

  if(cnf_ptr == NULL)
  { 
    /*Message error*/
    DS_AT_MSG0_HIGH("CONF PTR is NULL");
    return;
  }
  DS_AT_MSG2_HIGH("Number of PLMN ids %d , status %d",
                   cnf_ptr->get_se13_plmn_info_by_name_cnf.num_of_plmn_ids,status);

  cmd_buf  = dsat_get_cmd_buf(sizeof(ds_at_mmgsdi_plmn_info_type), FALSE);
  plmn_info_ptr = cmd_buf->cmd_payload_ptr;

  cmd_buf->hdr.cmd_id                 = DS_CMD_ATCOP_COPS_AT_CMD;
  plmn_info_ptr->mmgsdi_status = status;

  plmn_info_ptr->num_of_plmn_ids = 0;
  memset ((void *)&plmn_info_ptr->plmn_info,
           0x0,
           sizeof(mmgsdi_se13_plmn_info_type));

  if( MMGSDI_SUCCESS == status )
  {
    plmn_info_ptr->client_ref = 
      cnf_ptr->get_se13_plmn_info_by_name_cnf.response_header.client_data;
    
    plmn_info_ptr->num_of_plmn_ids = 
      cnf_ptr->get_se13_plmn_info_by_name_cnf.num_of_plmn_ids;

    if(0 != cnf_ptr->get_se13_plmn_info_by_name_cnf.num_of_plmn_ids &&
       NULL !=  cnf_ptr->get_se13_plmn_info_by_name_cnf.se13_plmn_info_ptr )
    { /*+COPS command need only one PLMN ID hence coping only 1st PLMN info here*/
      DS_AT_MSG3_HIGH("PLMN info mcc %d mnc %d Net Mask %d",
            cnf_ptr->get_se13_plmn_info_by_name_cnf.se13_plmn_info_ptr->mcc,
            cnf_ptr->get_se13_plmn_info_by_name_cnf.se13_plmn_info_ptr->mnc,
            cnf_ptr->get_se13_plmn_info_by_name_cnf.se13_plmn_info_ptr->network_mask
            );
      dsatutil_memscpy(&plmn_info_ptr->plmn_info,
               sizeof(mmgsdi_se13_plmn_info_type),
               cnf_ptr->get_se13_plmn_info_by_name_cnf.se13_plmn_info_ptr,
               sizeof(mmgsdi_se13_plmn_info_type));
    }
  }
  ds_put_cmd(cmd_buf);
}/* dsatetsicall_cops_cmd_cb_func */

#endif /*FEATURE_MMGSDI*/

#endif /* FEATURE_DSAT_ETSI_MODE */

/*===========================================================================

FUNCTION  DSATETSICALL_REPORT_QCRCIND_RESULT

DESCRIPTION
  This functions displays the MO call unsolicited result codes.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL void dsatetsicall_report_qcrcind_result
(
sys_modem_as_id_e_type     subs_id,
cm_call_event_e_type      *call_event_ptr
)
{
  dsm_item_type * res_buff_ptr = NULL;  

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
  if (NULL == res_buff_ptr)
  {
    return;
  }
  switch (*call_event_ptr)
  {
    case CM_CALL_EVENT_CONNECT:
       res_buff_ptr->used =(word) snprintf((char*)res_buff_ptr->data_ptr,
                                       res_buff_ptr->size,
                                       "REMOTE ANSWER"
                                       );
    break;
    case CM_CALL_EVENT_ABRV_ALERT:
       res_buff_ptr->used =(word) snprintf((char*)res_buff_ptr->data_ptr,
                                       res_buff_ptr->size,
                                       "REMOTE RING"
                                       );
    break;
    case CM_CALL_EVENT_END:
       res_buff_ptr->used =(word) snprintf((char*)res_buff_ptr->data_ptr,
                                       res_buff_ptr->size,
                                       "REMOTE CALL END"
                                       );
    break;
    default:
    break;
  }
  dsatcmdp_send_urc_per_subs(subs_id,res_buff_ptr,DSAT_COMPLETE_RSP);
} /*  dsatetsicall_report_qcrcind_result  */
