#============================================================================
#
# EFS error number list builder.
#
# GENERAL DESCRIPTION
#    The Embedded File System (EFS) APIs will indicate the reason why the
#    API failed by using an error code. This error codes change depending
#    on the compiler. This builder will use a .c that lists all the error
#    codes into a text file. The text file is generated by parsing and
#    filtering a pre-processed .c file.
#
# Copyright (c) 2011 by Qualcomm Technologies, Incorporated.
# All Rights Reserved.
# QUALCOMM Proprietary/GTDR
#
#----------------------------------------------------------------------------
#
#  $Header: //components/rel/boot.bf/3.1.2.c3/boot_images/core/storage/efs/build/efs_errno_builder.py#1 $ $DateTime: 2015/09/01 00:30:35 $ $Author: pwbldsvc $ $Change: 8935858 $
#
#                      EDIT HISTORY FOR FILE
#
#  This section contains comments describing changes made to the module.
#  Notice that changes are listed in reverse chronological order.
#
# when        who  what, where, why
# ----------  ---  ----------------------------------------------------------
# 2011-11-01  wek  Support python versions prior 2.6.
# 2011-10-05  wek  Create.
#
#============================================================================

import os

#----------------------------------------------------------------------------
# Hooks for Scons
# The generate function gets called by the function LoadToolScript()
# It registers/publishes the methods to the environment.
#----------------------------------------------------------------------------
def generate(env):
   env.AddMethod(fs_errno_list_builder, "FsErrnoListBuilder")
   fs_errno_text_generate(env)

def exists(env):
   return env.Detect('efs_errno_builder')

#----------------------------------------------------------------------------
# This function uses a .c file to generate a pre-processed file, it
# filters the pre-processed data to generate a readeable output.
#
# Parameters:
# env    Environment. Passed automatically.
# target Output file path. This will be the name of the text file.
# source The .c source file.
#----------------------------------------------------------------------------
def fs_errno_list_builder(env, target, source):
   # We are processing only the first entry, therefore reference only
   # the first entry.
   if type(target) is list:
      target = target[0]
   if type(source) is list:
      source = str(source[0])

   # Generate the pre-processed file output path
   target_full = env.RealPath(str(target))
   (target_base, target_ext) = os.path.splitext(target_full)

   # Pre-process the source file.
   efs_errno_pp = env.PreProcess(target_base, source)
   # Pass the pre-process output through the text file builder.
   efs_errno_list = env.FsErrnoTextBuilder (target, efs_errno_pp)

   return efs_errno_list

#----------------------------------------------------------------------------
# Adds into the environment the builder to parse/filter the pre-processed
# file.
#----------------------------------------------------------------------------
def fs_errno_text_generate(env):
    fs_errno_text_act = env.GetBuilderAction (fs_errno_text_builder)
    fs_errno_text_bld = env.Builder(action = fs_errno_text_act,
                                 suffix = '.txt')
    env.Append(BUILDERS = {'FsErrnoTextBuilder' : fs_errno_text_bld})

#----------------------------------------------------------------------------
# Parses/Filters a pre-process file to output all the lines that corresponds
# to a error number code.
#
# Parameters
# target  Output file path. This is the text file.
# source  Input file. This should be the pre-processed file.
# env     Environment. Passed automatically.
#----------------------------------------------------------------------------
def fs_errno_text_builder(target, source, env):
    pre_processed = str(source[0])
    # Open pre processed file in line buffering.
    fin  = open (pre_processed, "r", 1)
    # Extract all the error codes from the pre-processed file.
    err_list = []
    for line in fin:
        raw_line = line
        # Extract only the lines that start with the special string.
        valid_line = raw_line.find ("const unsigned int fs_")
        if valid_line != -1:
            err_line = raw_line.replace ("const unsigned int fs_", "")
            err_name, err_val = err_line.split ("=");
            err_val = err_val.replace (";", "")
            err_val = int(err_val, 0);
            err_list.append ((err_name, err_val))
    fin.close()

    # Sort the error numbers by the value.
    err_list = sorted (err_list, key=lambda err_list:err_list[1]);

    max_len = 0
    for err in err_list:
        length = len (err[0])
        length += len (str(err[1]))
        if length > max_len:
            max_len = length

    parsed = str(target[0])
    fout = open (parsed, "w")
    for err in err_list:
        err_len = max_len - len (err[0]);
        err_formatted = '%s %*d\n' % (err[0], err_len, err[1])
        fout.write (err_formatted);

    fout.close()


